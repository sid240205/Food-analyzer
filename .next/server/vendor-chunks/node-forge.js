/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-forge";
exports.ids = ["vendor-chunks/node-forge"];
exports.modules = {

/***/ "(rsc)/./node_modules/node-forge/lib/aes.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/aes.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Advanced Encryption Standard (AES) implementation.\n *\n * This implementation is based on the public domain library 'jscrypto' which\n * was written by:\n *\n * Emily Stark (estark@stanford.edu)\n * Mike Hamburg (mhamburg@stanford.edu)\n * Dan Boneh (dabo@cs.stanford.edu)\n *\n * Parts of this code are based on the OpenSSL implementation of AES:\n * http://www.openssl.org\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./cipher */ \"(rsc)/./node_modules/node-forge/lib/cipher.js\");\n__webpack_require__(/*! ./cipherModes */ \"(rsc)/./node_modules/node-forge/lib/cipherModes.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\n/* AES API */ module.exports = forge.aes = forge.aes || {};\n/**\n * Deprecated. Instead, use:\n *\n * var cipher = forge.cipher.createCipher('AES-<mode>', key);\n * cipher.start({iv: iv});\n *\n * Creates an AES cipher object to encrypt data using the given symmetric key.\n * The output will be stored in the 'output' member of the returned cipher.\n *\n * The key and iv may be given as a string of bytes, an array of bytes,\n * a byte buffer, or an array of 32-bit words.\n *\n * @param key the symmetric key to use.\n * @param iv the initialization vector to use.\n * @param output the buffer to write to, null to create one.\n * @param mode the cipher mode to use (default: 'CBC').\n *\n * @return the cipher.\n */ forge.aes.startEncrypting = function(key, iv, output, mode) {\n    var cipher = _createCipher({\n        key: key,\n        output: output,\n        decrypt: false,\n        mode: mode\n    });\n    cipher.start(iv);\n    return cipher;\n};\n/**\n * Deprecated. Instead, use:\n *\n * var cipher = forge.cipher.createCipher('AES-<mode>', key);\n *\n * Creates an AES cipher object to encrypt data using the given symmetric key.\n *\n * The key may be given as a string of bytes, an array of bytes, a\n * byte buffer, or an array of 32-bit words.\n *\n * @param key the symmetric key to use.\n * @param mode the cipher mode to use (default: 'CBC').\n *\n * @return the cipher.\n */ forge.aes.createEncryptionCipher = function(key, mode) {\n    return _createCipher({\n        key: key,\n        output: null,\n        decrypt: false,\n        mode: mode\n    });\n};\n/**\n * Deprecated. Instead, use:\n *\n * var decipher = forge.cipher.createDecipher('AES-<mode>', key);\n * decipher.start({iv: iv});\n *\n * Creates an AES cipher object to decrypt data using the given symmetric key.\n * The output will be stored in the 'output' member of the returned cipher.\n *\n * The key and iv may be given as a string of bytes, an array of bytes,\n * a byte buffer, or an array of 32-bit words.\n *\n * @param key the symmetric key to use.\n * @param iv the initialization vector to use.\n * @param output the buffer to write to, null to create one.\n * @param mode the cipher mode to use (default: 'CBC').\n *\n * @return the cipher.\n */ forge.aes.startDecrypting = function(key, iv, output, mode) {\n    var cipher = _createCipher({\n        key: key,\n        output: output,\n        decrypt: true,\n        mode: mode\n    });\n    cipher.start(iv);\n    return cipher;\n};\n/**\n * Deprecated. Instead, use:\n *\n * var decipher = forge.cipher.createDecipher('AES-<mode>', key);\n *\n * Creates an AES cipher object to decrypt data using the given symmetric key.\n *\n * The key may be given as a string of bytes, an array of bytes, a\n * byte buffer, or an array of 32-bit words.\n *\n * @param key the symmetric key to use.\n * @param mode the cipher mode to use (default: 'CBC').\n *\n * @return the cipher.\n */ forge.aes.createDecryptionCipher = function(key, mode) {\n    return _createCipher({\n        key: key,\n        output: null,\n        decrypt: true,\n        mode: mode\n    });\n};\n/**\n * Creates a new AES cipher algorithm object.\n *\n * @param name the name of the algorithm.\n * @param mode the mode factory function.\n *\n * @return the AES algorithm object.\n */ forge.aes.Algorithm = function(name, mode) {\n    if (!init) {\n        initialize();\n    }\n    var self = this;\n    self.name = name;\n    self.mode = new mode({\n        blockSize: 16,\n        cipher: {\n            encrypt: function(inBlock, outBlock) {\n                return _updateBlock(self._w, inBlock, outBlock, false);\n            },\n            decrypt: function(inBlock, outBlock) {\n                return _updateBlock(self._w, inBlock, outBlock, true);\n            }\n        }\n    });\n    self._init = false;\n};\n/**\n * Initializes this AES algorithm by expanding its key.\n *\n * @param options the options to use.\n *          key the key to use with this algorithm.\n *          decrypt true if the algorithm should be initialized for decryption,\n *            false for encryption.\n */ forge.aes.Algorithm.prototype.initialize = function(options) {\n    if (this._init) {\n        return;\n    }\n    var key = options.key;\n    var tmp;\n    /* Note: The key may be a string of bytes, an array of bytes, a byte\n    buffer, or an array of 32-bit integers. If the key is in bytes, then\n    it must be 16, 24, or 32 bytes in length. If it is in 32-bit\n    integers, it must be 4, 6, or 8 integers long. */ if (typeof key === \"string\" && (key.length === 16 || key.length === 24 || key.length === 32)) {\n        // convert key string into byte buffer\n        key = forge.util.createBuffer(key);\n    } else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {\n        // convert key integer array into byte buffer\n        tmp = key;\n        key = forge.util.createBuffer();\n        for(var i = 0; i < tmp.length; ++i){\n            key.putByte(tmp[i]);\n        }\n    }\n    // convert key byte buffer into 32-bit integer array\n    if (!forge.util.isArray(key)) {\n        tmp = key;\n        key = [];\n        // key lengths of 16, 24, 32 bytes allowed\n        var len = tmp.length();\n        if (len === 16 || len === 24 || len === 32) {\n            len = len >>> 2;\n            for(var i = 0; i < len; ++i){\n                key.push(tmp.getInt32());\n            }\n        }\n    }\n    // key must be an array of 32-bit integers by now\n    if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {\n        throw new Error(\"Invalid key parameter.\");\n    }\n    // encryption operation is always used for these modes\n    var mode = this.mode.name;\n    var encryptOp = [\n        \"CFB\",\n        \"OFB\",\n        \"CTR\",\n        \"GCM\"\n    ].indexOf(mode) !== -1;\n    // do key expansion\n    this._w = _expandKey(key, options.decrypt && !encryptOp);\n    this._init = true;\n};\n/**\n * Expands a key. Typically only used for testing.\n *\n * @param key the symmetric key to expand, as an array of 32-bit words.\n * @param decrypt true to expand for decryption, false for encryption.\n *\n * @return the expanded key.\n */ forge.aes._expandKey = function(key, decrypt) {\n    if (!init) {\n        initialize();\n    }\n    return _expandKey(key, decrypt);\n};\n/**\n * Updates a single block. Typically only used for testing.\n *\n * @param w the expanded key to use.\n * @param input an array of block-size 32-bit words.\n * @param output an array of block-size 32-bit words.\n * @param decrypt true to decrypt, false to encrypt.\n */ forge.aes._updateBlock = _updateBlock;\n/** Register AES algorithms **/ registerAlgorithm(\"AES-ECB\", forge.cipher.modes.ecb);\nregisterAlgorithm(\"AES-CBC\", forge.cipher.modes.cbc);\nregisterAlgorithm(\"AES-CFB\", forge.cipher.modes.cfb);\nregisterAlgorithm(\"AES-OFB\", forge.cipher.modes.ofb);\nregisterAlgorithm(\"AES-CTR\", forge.cipher.modes.ctr);\nregisterAlgorithm(\"AES-GCM\", forge.cipher.modes.gcm);\nfunction registerAlgorithm(name, mode) {\n    var factory = function() {\n        return new forge.aes.Algorithm(name, mode);\n    };\n    forge.cipher.registerAlgorithm(name, factory);\n}\n/** AES implementation **/ var init = false; // not yet initialized\nvar Nb = 4; // number of words comprising the state (AES = 4)\nvar sbox; // non-linear substitution table used in key expansion\nvar isbox; // inversion of sbox\nvar rcon; // round constant word array\nvar mix; // mix-columns table\nvar imix; // inverse mix-columns table\n/**\n * Performs initialization, ie: precomputes tables to optimize for speed.\n *\n * One way to understand how AES works is to imagine that 'addition' and\n * 'multiplication' are interfaces that require certain mathematical\n * properties to hold true (ie: they are associative) but they might have\n * different implementations and produce different kinds of results ...\n * provided that their mathematical properties remain true. AES defines\n * its own methods of addition and multiplication but keeps some important\n * properties the same, ie: associativity and distributivity. The\n * explanation below tries to shed some light on how AES defines addition\n * and multiplication of bytes and 32-bit words in order to perform its\n * encryption and decryption algorithms.\n *\n * The basics:\n *\n * The AES algorithm views bytes as binary representations of polynomials\n * that have either 1 or 0 as the coefficients. It defines the addition\n * or subtraction of two bytes as the XOR operation. It also defines the\n * multiplication of two bytes as a finite field referred to as GF(2^8)\n * (Note: 'GF' means \"Galois Field\" which is a field that contains a finite\n * number of elements so GF(2^8) has 256 elements).\n *\n * This means that any two bytes can be represented as binary polynomials;\n * when they multiplied together and modularly reduced by an irreducible\n * polynomial of the 8th degree, the results are the field GF(2^8). The\n * specific irreducible polynomial that AES uses in hexadecimal is 0x11b.\n * This multiplication is associative with 0x01 as the identity:\n *\n * (b * 0x01 = GF(b, 0x01) = b).\n *\n * The operation GF(b, 0x02) can be performed at the byte level by left\n * shifting b once and then XOR'ing it (to perform the modular reduction)\n * with 0x11b if b is >= 128. Repeated application of the multiplication\n * of 0x02 can be used to implement the multiplication of any two bytes.\n *\n * For instance, multiplying 0x57 and 0x13, denoted as GF(0x57, 0x13), can\n * be performed by factoring 0x13 into 0x01, 0x02, and 0x10. Then these\n * factors can each be multiplied by 0x57 and then added together. To do\n * the multiplication, values for 0x57 multiplied by each of these 3 factors\n * can be precomputed and stored in a table. To add them, the values from\n * the table are XOR'd together.\n *\n * AES also defines addition and multiplication of words, that is 4-byte\n * numbers represented as polynomials of 3 degrees where the coefficients\n * are the values of the bytes.\n *\n * The word [a0, a1, a2, a3] is a polynomial a3x^3 + a2x^2 + a1x + a0.\n *\n * Addition is performed by XOR'ing like powers of x. Multiplication\n * is performed in two steps, the first is an algebriac expansion as\n * you would do normally (where addition is XOR). But the result is\n * a polynomial larger than 3 degrees and thus it cannot fit in a word. So\n * next the result is modularly reduced by an AES-specific polynomial of\n * degree 4 which will always produce a polynomial of less than 4 degrees\n * such that it will fit in a word. In AES, this polynomial is x^4 + 1.\n *\n * The modular product of two polynomials 'a' and 'b' is thus:\n *\n * d(x) = d3x^3 + d2x^2 + d1x + d0\n * with\n * d0 = GF(a0, b0) ^ GF(a3, b1) ^ GF(a2, b2) ^ GF(a1, b3)\n * d1 = GF(a1, b0) ^ GF(a0, b1) ^ GF(a3, b2) ^ GF(a2, b3)\n * d2 = GF(a2, b0) ^ GF(a1, b1) ^ GF(a0, b2) ^ GF(a3, b3)\n * d3 = GF(a3, b0) ^ GF(a2, b1) ^ GF(a1, b2) ^ GF(a0, b3)\n *\n * As a matrix:\n *\n * [d0] = [a0 a3 a2 a1][b0]\n * [d1]   [a1 a0 a3 a2][b1]\n * [d2]   [a2 a1 a0 a3][b2]\n * [d3]   [a3 a2 a1 a0][b3]\n *\n * Special polynomials defined by AES (0x02 == {02}):\n * a(x)    = {03}x^3 + {01}x^2 + {01}x + {02}\n * a^-1(x) = {0b}x^3 + {0d}x^2 + {09}x + {0e}.\n *\n * These polynomials are used in the MixColumns() and InverseMixColumns()\n * operations, respectively, to cause each element in the state to affect\n * the output (referred to as diffusing).\n *\n * RotWord() uses: a0 = a1 = a2 = {00} and a3 = {01}, which is the\n * polynomial x3.\n *\n * The ShiftRows() method modifies the last 3 rows in the state (where\n * the state is 4 words with 4 bytes per word) by shifting bytes cyclically.\n * The 1st byte in the second row is moved to the end of the row. The 1st\n * and 2nd bytes in the third row are moved to the end of the row. The 1st,\n * 2nd, and 3rd bytes are moved in the fourth row.\n *\n * More details on how AES arithmetic works:\n *\n * In the polynomial representation of binary numbers, XOR performs addition\n * and subtraction and multiplication in GF(2^8) denoted as GF(a, b)\n * corresponds with the multiplication of polynomials modulo an irreducible\n * polynomial of degree 8. In other words, for AES, GF(a, b) will multiply\n * polynomial 'a' with polynomial 'b' and then do a modular reduction by\n * an AES-specific irreducible polynomial of degree 8.\n *\n * A polynomial is irreducible if its only divisors are one and itself. For\n * the AES algorithm, this irreducible polynomial is:\n *\n * m(x) = x^8 + x^4 + x^3 + x + 1,\n *\n * or {01}{1b} in hexadecimal notation, where each coefficient is a bit:\n * 100011011 = 283 = 0x11b.\n *\n * For example, GF(0x57, 0x83) = 0xc1 because\n *\n * 0x57 = 87  = 01010111 = x^6 + x^4 + x^2 + x + 1\n * 0x85 = 131 = 10000101 = x^7 + x + 1\n *\n * (x^6 + x^4 + x^2 + x + 1) * (x^7 + x + 1)\n * =  x^13 + x^11 + x^9 + x^8 + x^7 +\n *    x^7 + x^5 + x^3 + x^2 + x +\n *    x^6 + x^4 + x^2 + x + 1\n * =  x^13 + x^11 + x^9 + x^8 + x^6 + x^5 + x^4 + x^3 + 1 = y\n *    y modulo (x^8 + x^4 + x^3 + x + 1)\n * =  x^7 + x^6 + 1.\n *\n * The modular reduction by m(x) guarantees the result will be a binary\n * polynomial of less than degree 8, so that it can fit in a byte.\n *\n * The operation to multiply a binary polynomial b with x (the polynomial\n * x in binary representation is 00000010) is:\n *\n * b_7x^8 + b_6x^7 + b_5x^6 + b_4x^5 + b_3x^4 + b_2x^3 + b_1x^2 + b_0x^1\n *\n * To get GF(b, x) we must reduce that by m(x). If b_7 is 0 (that is the\n * most significant bit is 0 in b) then the result is already reduced. If\n * it is 1, then we can reduce it by subtracting m(x) via an XOR.\n *\n * It follows that multiplication by x (00000010 or 0x02) can be implemented\n * by performing a left shift followed by a conditional bitwise XOR with\n * 0x1b. This operation on bytes is denoted by xtime(). Multiplication by\n * higher powers of x can be implemented by repeated application of xtime().\n *\n * By adding intermediate results, multiplication by any constant can be\n * implemented. For instance:\n *\n * GF(0x57, 0x13) = 0xfe because:\n *\n * xtime(b) = (b & 128) ? (b << 1 ^ 0x11b) : (b << 1)\n *\n * Note: We XOR with 0x11b instead of 0x1b because in javascript our\n * datatype for b can be larger than 1 byte, so a left shift will not\n * automatically eliminate bits that overflow a byte ... by XOR'ing the\n * overflow bit with 1 (the extra one from 0x11b) we zero it out.\n *\n * GF(0x57, 0x02) = xtime(0x57) = 0xae\n * GF(0x57, 0x04) = xtime(0xae) = 0x47\n * GF(0x57, 0x08) = xtime(0x47) = 0x8e\n * GF(0x57, 0x10) = xtime(0x8e) = 0x07\n *\n * GF(0x57, 0x13) = GF(0x57, (0x01 ^ 0x02 ^ 0x10))\n *\n * And by the distributive property (since XOR is addition and GF() is\n * multiplication):\n *\n * = GF(0x57, 0x01) ^ GF(0x57, 0x02) ^ GF(0x57, 0x10)\n * = 0x57 ^ 0xae ^ 0x07\n * = 0xfe.\n */ function initialize() {\n    init = true;\n    /* Populate the Rcon table. These are the values given by\n    [x^(i-1),{00},{00},{00}] where x^(i-1) are powers of x (and x = 0x02)\n    in the field of GF(2^8), where i starts at 1.\n\n    rcon[0] = [0x00, 0x00, 0x00, 0x00]\n    rcon[1] = [0x01, 0x00, 0x00, 0x00] 2^(1-1) = 2^0 = 1\n    rcon[2] = [0x02, 0x00, 0x00, 0x00] 2^(2-1) = 2^1 = 2\n    ...\n    rcon[9]  = [0x1B, 0x00, 0x00, 0x00] 2^(9-1)  = 2^8 = 0x1B\n    rcon[10] = [0x36, 0x00, 0x00, 0x00] 2^(10-1) = 2^9 = 0x36\n\n    We only store the first byte because it is the only one used.\n  */ rcon = [\n        0x00,\n        0x01,\n        0x02,\n        0x04,\n        0x08,\n        0x10,\n        0x20,\n        0x40,\n        0x80,\n        0x1B,\n        0x36\n    ];\n    // compute xtime table which maps i onto GF(i, 0x02)\n    var xtime = new Array(256);\n    for(var i = 0; i < 128; ++i){\n        xtime[i] = i << 1;\n        xtime[i + 128] = i + 128 << 1 ^ 0x11B;\n    }\n    // compute all other tables\n    sbox = new Array(256);\n    isbox = new Array(256);\n    mix = new Array(4);\n    imix = new Array(4);\n    for(var i = 0; i < 4; ++i){\n        mix[i] = new Array(256);\n        imix[i] = new Array(256);\n    }\n    var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;\n    for(var i = 0; i < 256; ++i){\n        /* We need to generate the SubBytes() sbox and isbox tables so that\n      we can perform byte substitutions. This requires us to traverse\n      all of the elements in GF, find their multiplicative inverses,\n      and apply to each the following affine transformation:\n\n      bi' = bi ^ b(i + 4) mod 8 ^ b(i + 5) mod 8 ^ b(i + 6) mod 8 ^\n            b(i + 7) mod 8 ^ ci\n      for 0 <= i < 8, where bi is the ith bit of the byte, and ci is the\n      ith bit of a byte c with the value {63} or {01100011}.\n\n      It is possible to traverse every possible value in a Galois field\n      using what is referred to as a 'generator'. There are many\n      generators (128 out of 256): 3,5,6,9,11,82 to name a few. To fully\n      traverse GF we iterate 255 times, multiplying by our generator\n      each time.\n\n      On each iteration we can determine the multiplicative inverse for\n      the current element.\n\n      Suppose there is an element in GF 'e'. For a given generator 'g',\n      e = g^x. The multiplicative inverse of e is g^(255 - x). It turns\n      out that if use the inverse of a generator as another generator\n      it will produce all of the corresponding multiplicative inverses\n      at the same time. For this reason, we choose 5 as our inverse\n      generator because it only requires 2 multiplies and 1 add and its\n      inverse, 82, requires relatively few operations as well.\n\n      In order to apply the affine transformation, the multiplicative\n      inverse 'ei' of 'e' can be repeatedly XOR'd (4 times) with a\n      bit-cycling of 'ei'. To do this 'ei' is first stored in 's' and\n      'x'. Then 's' is left shifted and the high bit of 's' is made the\n      low bit. The resulting value is stored in 's'. Then 'x' is XOR'd\n      with 's' and stored in 'x'. On each subsequent iteration the same\n      operation is performed. When 4 iterations are complete, 'x' is\n      XOR'd with 'c' (0x63) and the transformed value is stored in 'x'.\n      For example:\n\n      s = 01000001\n      x = 01000001\n\n      iteration 1: s = 10000010, x ^= s\n      iteration 2: s = 00000101, x ^= s\n      iteration 3: s = 00001010, x ^= s\n      iteration 4: s = 00010100, x ^= s\n      x ^= 0x63\n\n      This can be done with a loop where s = (s << 1) | (s >> 7). However,\n      it can also be done by using a single 16-bit (in this case 32-bit)\n      number 'sx'. Since XOR is an associative operation, we can set 'sx'\n      to 'ei' and then XOR it with 'sx' left-shifted 1,2,3, and 4 times.\n      The most significant bits will flow into the high 8 bit positions\n      and be correctly XOR'd with one another. All that remains will be\n      to cycle the high 8 bits by XOR'ing them all with the lower 8 bits\n      afterwards.\n\n      At the same time we're populating sbox and isbox we can precompute\n      the multiplication we'll need to do to do MixColumns() later.\n    */ // apply affine transformation\n        sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;\n        sx = sx >> 8 ^ sx & 255 ^ 0x63;\n        // update tables\n        sbox[e] = sx;\n        isbox[sx] = e;\n        /* Mixing columns is done using matrix multiplication. The columns\n      that are to be mixed are each a single word in the current state.\n      The state has Nb columns (4 columns). Therefore each column is a\n      4 byte word. So to mix the columns in a single column 'c' where\n      its rows are r0, r1, r2, and r3, we use the following matrix\n      multiplication:\n\n      [2 3 1 1]*[r0,c]=[r'0,c]\n      [1 2 3 1] [r1,c] [r'1,c]\n      [1 1 2 3] [r2,c] [r'2,c]\n      [3 1 1 2] [r3,c] [r'3,c]\n\n      r0, r1, r2, and r3 are each 1 byte of one of the words in the\n      state (a column). To do matrix multiplication for each mixed\n      column c' we multiply the corresponding row from the left matrix\n      with the corresponding column from the right matrix. In total, we\n      get 4 equations:\n\n      r0,c' = 2*r0,c + 3*r1,c + 1*r2,c + 1*r3,c\n      r1,c' = 1*r0,c + 2*r1,c + 3*r2,c + 1*r3,c\n      r2,c' = 1*r0,c + 1*r1,c + 2*r2,c + 3*r3,c\n      r3,c' = 3*r0,c + 1*r1,c + 1*r2,c + 2*r3,c\n\n      As usual, the multiplication is as previously defined and the\n      addition is XOR. In order to optimize mixing columns we can store\n      the multiplication results in tables. If you think of the whole\n      column as a word (it might help to visualize by mentally rotating\n      the equations above by counterclockwise 90 degrees) then you can\n      see that it would be useful to map the multiplications performed on\n      each byte (r0, r1, r2, r3) onto a word as well. For instance, we\n      could map 2*r0,1*r0,1*r0,3*r0 onto a word by storing 2*r0 in the\n      highest 8 bits and 3*r0 in the lowest 8 bits (with the other two\n      respectively in the middle). This means that a table can be\n      constructed that uses r0 as an index to the word. We can do the\n      same with r1, r2, and r3, creating a total of 4 tables.\n\n      To construct a full c', we can just look up each byte of c in\n      their respective tables and XOR the results together.\n\n      Also, to build each table we only have to calculate the word\n      for 2,1,1,3 for every byte ... which we can do on each iteration\n      of this loop since we will iterate over every byte. After we have\n      calculated 2,1,1,3 we can get the results for the other tables\n      by cycling the byte at the end to the beginning. For instance\n      we can take the result of table 2,1,1,3 and produce table 3,2,1,1\n      by moving the right most byte to the left most position just like\n      how you can imagine the 3 moved out of 2,1,1,3 and to the front\n      to produce 3,2,1,1.\n\n      There is another optimization in that the same multiples of\n      the current element we need in order to advance our generator\n      to the next iteration can be reused in performing the 2,1,1,3\n      calculation. We also calculate the inverse mix column tables,\n      with e,9,d,b being the inverse of 2,1,1,3.\n\n      When we're done, and we need to actually mix columns, the first\n      byte of each state word should be put through mix[0] (2,1,1,3),\n      the second through mix[1] (3,2,1,1) and so forth. Then they should\n      be XOR'd together to produce the fully mixed column.\n    */ // calculate mix and imix table values\n        sx2 = xtime[sx];\n        e2 = xtime[e];\n        e4 = xtime[e2];\n        e8 = xtime[e4];\n        me = sx2 << 24 ^ // 2\n        sx << 16 ^ // 1\n        sx << 8 ^ // 1\n        (sx ^ sx2); // 3\n        ime = (e2 ^ e4 ^ e8) << 24 ^ // E (14)\n        (e ^ e8) << 16 ^ // 9\n        (e ^ e4 ^ e8) << 8 ^ // D (13)\n        (e ^ e2 ^ e8); // B (11)\n        // produce each of the mix tables by rotating the 2,1,1,3 value\n        for(var n = 0; n < 4; ++n){\n            mix[n][e] = me;\n            imix[n][sx] = ime;\n            // cycle the right most byte to the left most position\n            // ie: 2,1,1,3 becomes 3,2,1,1\n            me = me << 24 | me >>> 8;\n            ime = ime << 24 | ime >>> 8;\n        }\n        // get next element and inverse\n        if (e === 0) {\n            // 1 is the inverse of 1\n            e = ei = 1;\n        } else {\n            // e = 2e + 2*2*2*(10e)) = multiply e by 82 (chosen generator)\n            // ei = ei + 2*2*ei = multiply ei by 5 (inverse generator)\n            e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];\n            ei ^= xtime[xtime[ei]];\n        }\n    }\n}\n/**\n * Generates a key schedule using the AES key expansion algorithm.\n *\n * The AES algorithm takes the Cipher Key, K, and performs a Key Expansion\n * routine to generate a key schedule. The Key Expansion generates a total\n * of Nb*(Nr + 1) words: the algorithm requires an initial set of Nb words,\n * and each of the Nr rounds requires Nb words of key data. The resulting\n * key schedule consists of a linear array of 4-byte words, denoted [wi ],\n * with i in the range 0 <= i < Nb(Nr + 1).\n *\n * KeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk)\n * AES-128 (Nb=4, Nk=4, Nr=10)\n * AES-192 (Nb=4, Nk=6, Nr=12)\n * AES-256 (Nb=4, Nk=8, Nr=14)\n * Note: Nr=Nk+6.\n *\n * Nb is the number of columns (32-bit words) comprising the State (or\n * number of bytes in a block). For AES, Nb=4.\n *\n * @param key the key to schedule (as an array of 32-bit words).\n * @param decrypt true to modify the key schedule to decrypt, false not to.\n *\n * @return the generated key schedule.\n */ function _expandKey(key, decrypt) {\n    // copy the key's words to initialize the key schedule\n    var w = key.slice(0);\n    /* RotWord() will rotate a word, moving the first byte to the last\n    byte's position (shifting the other bytes left).\n\n    We will be getting the value of Rcon at i / Nk. 'i' will iterate\n    from Nk to (Nb * Nr+1). Nk = 4 (4 byte key), Nb = 4 (4 words in\n    a block), Nr = Nk + 6 (10). Therefore 'i' will iterate from\n    4 to 44 (exclusive). Each time we iterate 4 times, i / Nk will\n    increase by 1. We use a counter iNk to keep track of this.\n   */ // go through the rounds expanding the key\n    var temp, iNk = 1;\n    var Nk = w.length;\n    var Nr1 = Nk + 6 + 1;\n    var end = Nb * Nr1;\n    for(var i = Nk; i < end; ++i){\n        temp = w[i - 1];\n        if (i % Nk === 0) {\n            // temp = SubWord(RotWord(temp)) ^ Rcon[i / Nk]\n            temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;\n            iNk++;\n        } else if (Nk > 6 && i % Nk === 4) {\n            // temp = SubWord(temp)\n            temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];\n        }\n        w[i] = w[i - Nk] ^ temp;\n    }\n    /* When we are updating a cipher block we always use the code path for\n     encryption whether we are decrypting or not (to shorten code and\n     simplify the generation of look up tables). However, because there\n     are differences in the decryption algorithm, other than just swapping\n     in different look up tables, we must transform our key schedule to\n     account for these changes:\n\n     1. The decryption algorithm gets its key rounds in reverse order.\n     2. The decryption algorithm adds the round key before mixing columns\n       instead of afterwards.\n\n     We don't need to modify our key schedule to handle the first case,\n     we can just traverse the key schedule in reverse order when decrypting.\n\n     The second case requires a little work.\n\n     The tables we built for performing rounds will take an input and then\n     perform SubBytes() and MixColumns() or, for the decrypt version,\n     InvSubBytes() and InvMixColumns(). But the decrypt algorithm requires\n     us to AddRoundKey() before InvMixColumns(). This means we'll need to\n     apply some transformations to the round key to inverse-mix its columns\n     so they'll be correct for moving AddRoundKey() to after the state has\n     had its columns inverse-mixed.\n\n     To inverse-mix the columns of the state when we're decrypting we use a\n     lookup table that will apply InvSubBytes() and InvMixColumns() at the\n     same time. However, the round key's bytes are not inverse-substituted\n     in the decryption algorithm. To get around this problem, we can first\n     substitute the bytes in the round key so that when we apply the\n     transformation via the InvSubBytes()+InvMixColumns() table, it will\n     undo our substitution leaving us with the original value that we\n     want -- and then inverse-mix that value.\n\n     This change will correctly alter our key schedule so that we can XOR\n     each round key with our already transformed decryption state. This\n     allows us to use the same code path as the encryption algorithm.\n\n     We make one more change to the decryption key. Since the decryption\n     algorithm runs in reverse from the encryption algorithm, we reverse\n     the order of the round keys to avoid having to iterate over the key\n     schedule backwards when running the encryption algorithm later in\n     decryption mode. In addition to reversing the order of the round keys,\n     we also swap each round key's 2nd and 4th rows. See the comments\n     section where rounds are performed for more details about why this is\n     done. These changes are done inline with the other substitution\n     described above.\n  */ if (decrypt) {\n        var tmp;\n        var m0 = imix[0];\n        var m1 = imix[1];\n        var m2 = imix[2];\n        var m3 = imix[3];\n        var wnew = w.slice(0);\n        end = w.length;\n        for(var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb){\n            // do not sub the first or last round key (round keys are Nb\n            // words) as no column mixing is performed before they are added,\n            // but do change the key order\n            if (i === 0 || i === end - Nb) {\n                wnew[i] = w[wi];\n                wnew[i + 1] = w[wi + 3];\n                wnew[i + 2] = w[wi + 2];\n                wnew[i + 3] = w[wi + 1];\n            } else {\n                // substitute each round key byte because the inverse-mix\n                // table will inverse-substitute it (effectively cancel the\n                // substitution because round key bytes aren't sub'd in\n                // decryption mode) and swap indexes 3 and 1\n                for(var n = 0; n < Nb; ++n){\n                    tmp = w[wi + n];\n                    wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];\n                }\n            }\n        }\n        w = wnew;\n    }\n    return w;\n}\n/**\n * Updates a single block (16 bytes) using AES. The update will either\n * encrypt or decrypt the block.\n *\n * @param w the key schedule.\n * @param input the input block (an array of 32-bit words).\n * @param output the updated output block.\n * @param decrypt true to decrypt the block, false to encrypt it.\n */ function _updateBlock(w, input, output, decrypt) {\n    /*\n  Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])\n  begin\n    byte state[4,Nb]\n    state = in\n    AddRoundKey(state, w[0, Nb-1])\n    for round = 1 step 1 to Nr-1\n      SubBytes(state)\n      ShiftRows(state)\n      MixColumns(state)\n      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])\n    end for\n    SubBytes(state)\n    ShiftRows(state)\n    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\n    out = state\n  end\n\n  InvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])\n  begin\n    byte state[4,Nb]\n    state = in\n    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\n    for round = Nr-1 step -1 downto 1\n      InvShiftRows(state)\n      InvSubBytes(state)\n      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])\n      InvMixColumns(state)\n    end for\n    InvShiftRows(state)\n    InvSubBytes(state)\n    AddRoundKey(state, w[0, Nb-1])\n    out = state\n  end\n  */ // Encrypt: AddRoundKey(state, w[0, Nb-1])\n    // Decrypt: AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\n    var Nr = w.length / 4 - 1;\n    var m0, m1, m2, m3, sub;\n    if (decrypt) {\n        m0 = imix[0];\n        m1 = imix[1];\n        m2 = imix[2];\n        m3 = imix[3];\n        sub = isbox;\n    } else {\n        m0 = mix[0];\n        m1 = mix[1];\n        m2 = mix[2];\n        m3 = mix[3];\n        sub = sbox;\n    }\n    var a, b, c, d, a2, b2, c2;\n    a = input[0] ^ w[0];\n    b = input[decrypt ? 3 : 1] ^ w[1];\n    c = input[2] ^ w[2];\n    d = input[decrypt ? 1 : 3] ^ w[3];\n    var i = 3;\n    /* In order to share code we follow the encryption algorithm when both\n    encrypting and decrypting. To account for the changes required in the\n    decryption algorithm, we use different lookup tables when decrypting\n    and use a modified key schedule to account for the difference in the\n    order of transformations applied when performing rounds. We also get\n    key rounds in reverse order (relative to encryption). */ for(var round = 1; round < Nr; ++round){\n        /* As described above, we'll be using table lookups to perform the\n      column mixing. Each column is stored as a word in the state (the\n      array 'input' has one column as a word at each index). In order to\n      mix a column, we perform these transformations on each row in c,\n      which is 1 byte in each word. The new column for c0 is c'0:\n\n               m0      m1      m2      m3\n      r0,c'0 = 2*r0,c0 + 3*r1,c0 + 1*r2,c0 + 1*r3,c0\n      r1,c'0 = 1*r0,c0 + 2*r1,c0 + 3*r2,c0 + 1*r3,c0\n      r2,c'0 = 1*r0,c0 + 1*r1,c0 + 2*r2,c0 + 3*r3,c0\n      r3,c'0 = 3*r0,c0 + 1*r1,c0 + 1*r2,c0 + 2*r3,c0\n\n      So using mix tables where c0 is a word with r0 being its upper\n      8 bits and r3 being its lower 8 bits:\n\n      m0[c0 >> 24] will yield this word: [2*r0,1*r0,1*r0,3*r0]\n      ...\n      m3[c0 & 255] will yield this word: [1*r3,1*r3,3*r3,2*r3]\n\n      Therefore to mix the columns in each word in the state we\n      do the following (& 255 omitted for brevity):\n      c'0,r0 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]\n      c'0,r1 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]\n      c'0,r2 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]\n      c'0,r3 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]\n\n      However, before mixing, the algorithm requires us to perform\n      ShiftRows(). The ShiftRows() transformation cyclically shifts the\n      last 3 rows of the state over different offsets. The first row\n      (r = 0) is not shifted.\n\n      s'_r,c = s_r,(c + shift(r, Nb) mod Nb\n      for 0 < r < 4 and 0 <= c < Nb and\n      shift(1, 4) = 1\n      shift(2, 4) = 2\n      shift(3, 4) = 3.\n\n      This causes the first byte in r = 1 to be moved to the end of\n      the row, the first 2 bytes in r = 2 to be moved to the end of\n      the row, the first 3 bytes in r = 3 to be moved to the end of\n      the row:\n\n      r1: [c0 c1 c2 c3] => [c1 c2 c3 c0]\n      r2: [c0 c1 c2 c3]    [c2 c3 c0 c1]\n      r3: [c0 c1 c2 c3]    [c3 c0 c1 c2]\n\n      We can make these substitutions inline with our column mixing to\n      generate an updated set of equations to produce each word in the\n      state (note the columns have changed positions):\n\n      c0 c1 c2 c3 => c0 c1 c2 c3\n      c0 c1 c2 c3    c1 c2 c3 c0  (cycled 1 byte)\n      c0 c1 c2 c3    c2 c3 c0 c1  (cycled 2 bytes)\n      c0 c1 c2 c3    c3 c0 c1 c2  (cycled 3 bytes)\n\n      Therefore:\n\n      c'0 = 2*r0,c0 + 3*r1,c1 + 1*r2,c2 + 1*r3,c3\n      c'0 = 1*r0,c0 + 2*r1,c1 + 3*r2,c2 + 1*r3,c3\n      c'0 = 1*r0,c0 + 1*r1,c1 + 2*r2,c2 + 3*r3,c3\n      c'0 = 3*r0,c0 + 1*r1,c1 + 1*r2,c2 + 2*r3,c3\n\n      c'1 = 2*r0,c1 + 3*r1,c2 + 1*r2,c3 + 1*r3,c0\n      c'1 = 1*r0,c1 + 2*r1,c2 + 3*r2,c3 + 1*r3,c0\n      c'1 = 1*r0,c1 + 1*r1,c2 + 2*r2,c3 + 3*r3,c0\n      c'1 = 3*r0,c1 + 1*r1,c2 + 1*r2,c3 + 2*r3,c0\n\n      ... and so forth for c'2 and c'3. The important distinction is\n      that the columns are cycling, with c0 being used with the m0\n      map when calculating c0, but c1 being used with the m0 map when\n      calculating c1 ... and so forth.\n\n      When performing the inverse we transform the mirror image and\n      skip the bottom row, instead of the top one, and move upwards:\n\n      c3 c2 c1 c0 => c0 c3 c2 c1  (cycled 3 bytes) *same as encryption\n      c3 c2 c1 c0    c1 c0 c3 c2  (cycled 2 bytes)\n      c3 c2 c1 c0    c2 c1 c0 c3  (cycled 1 byte)  *same as encryption\n      c3 c2 c1 c0    c3 c2 c1 c0\n\n      If you compare the resulting matrices for ShiftRows()+MixColumns()\n      and for InvShiftRows()+InvMixColumns() the 2nd and 4th columns are\n      different (in encrypt mode vs. decrypt mode). So in order to use\n      the same code to handle both encryption and decryption, we will\n      need to do some mapping.\n\n      If in encryption mode we let a=c0, b=c1, c=c2, d=c3, and r<N> be\n      a row number in the state, then the resulting matrix in encryption\n      mode for applying the above transformations would be:\n\n      r1: a b c d\n      r2: b c d a\n      r3: c d a b\n      r4: d a b c\n\n      If we did the same in decryption mode we would get:\n\n      r1: a d c b\n      r2: b a d c\n      r3: c b a d\n      r4: d c b a\n\n      If instead we swap d and b (set b=c3 and d=c1), then we get:\n\n      r1: a b c d\n      r2: d a b c\n      r3: c d a b\n      r4: b c d a\n\n      Now the 1st and 3rd rows are the same as the encryption matrix. All\n      we need to do then to make the mapping exactly the same is to swap\n      the 2nd and 4th rows when in decryption mode. To do this without\n      having to do it on each iteration, we swapped the 2nd and 4th rows\n      in the decryption key schedule. We also have to do the swap above\n      when we first pull in the input and when we set the final output. */ a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];\n        b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];\n        c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];\n        d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];\n        a = a2;\n        b = b2;\n        c = c2;\n    }\n    /*\n    Encrypt:\n    SubBytes(state)\n    ShiftRows(state)\n    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\n\n    Decrypt:\n    InvShiftRows(state)\n    InvSubBytes(state)\n    AddRoundKey(state, w[0, Nb-1])\n   */ // Note: rows are shifted inline\n    output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i];\n    output[decrypt ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i];\n    output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i];\n    output[decrypt ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i];\n}\n/**\n * Deprecated. Instead, use:\n *\n * forge.cipher.createCipher('AES-<mode>', key);\n * forge.cipher.createDecipher('AES-<mode>', key);\n *\n * Creates a deprecated AES cipher object. This object's mode will default to\n * CBC (cipher-block-chaining).\n *\n * The key and iv may be given as a string of bytes, an array of bytes, a\n * byte buffer, or an array of 32-bit words.\n *\n * @param options the options to use.\n *          key the symmetric key to use.\n *          output the buffer to write to.\n *          decrypt true for decryption, false for encryption.\n *          mode the cipher mode to use (default: 'CBC').\n *\n * @return the cipher.\n */ function _createCipher(options) {\n    options = options || {};\n    var mode = (options.mode || \"CBC\").toUpperCase();\n    var algorithm = \"AES-\" + mode;\n    var cipher;\n    if (options.decrypt) {\n        cipher = forge.cipher.createDecipher(algorithm, options.key);\n    } else {\n        cipher = forge.cipher.createCipher(algorithm, options.key);\n    }\n    // backwards compatible start API\n    var start = cipher.start;\n    cipher.start = function(iv, options) {\n        // backwards compatibility: support second arg as output buffer\n        var output = null;\n        if (options instanceof forge.util.ByteBuffer) {\n            output = options;\n            options = {};\n        }\n        options = options || {};\n        options.output = output;\n        options.iv = iv;\n        start.call(cipher, options);\n    };\n    return cipher;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvYWVzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVIsV0FBVyxHQUNYQyxPQUFPQyxPQUFPLEdBQUdILE1BQU1JLEdBQUcsR0FBR0osTUFBTUksR0FBRyxJQUFJLENBQUM7QUFFM0M7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNESixNQUFNSSxHQUFHLENBQUNDLGVBQWUsR0FBRyxTQUFTQyxHQUFHLEVBQUVDLEVBQUUsRUFBRUMsTUFBTSxFQUFFQyxJQUFJO0lBQ3hELElBQUlDLFNBQVNDLGNBQWM7UUFDekJMLEtBQUtBO1FBQ0xFLFFBQVFBO1FBQ1JJLFNBQVM7UUFDVEgsTUFBTUE7SUFDUjtJQUNBQyxPQUFPRyxLQUFLLENBQUNOO0lBQ2IsT0FBT0c7QUFDVDtBQUVBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ0RWLE1BQU1JLEdBQUcsQ0FBQ1Usc0JBQXNCLEdBQUcsU0FBU1IsR0FBRyxFQUFFRyxJQUFJO0lBQ25ELE9BQU9FLGNBQWM7UUFDbkJMLEtBQUtBO1FBQ0xFLFFBQVE7UUFDUkksU0FBUztRQUNUSCxNQUFNQTtJQUNSO0FBQ0Y7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDLEdBQ0RULE1BQU1JLEdBQUcsQ0FBQ1csZUFBZSxHQUFHLFNBQVNULEdBQUcsRUFBRUMsRUFBRSxFQUFFQyxNQUFNLEVBQUVDLElBQUk7SUFDeEQsSUFBSUMsU0FBU0MsY0FBYztRQUN6QkwsS0FBS0E7UUFDTEUsUUFBUUE7UUFDUkksU0FBUztRQUNUSCxNQUFNQTtJQUNSO0lBQ0FDLE9BQU9HLEtBQUssQ0FBQ047SUFDYixPQUFPRztBQUNUO0FBRUE7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDRFYsTUFBTUksR0FBRyxDQUFDWSxz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SSxDQUFDM0YsUUFBUW9CO0lBQ3JCO0lBRUEsT0FBT3BCO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvYWVzLmpzPzgyNmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBZHZhbmNlZCBFbmNyeXB0aW9uIFN0YW5kYXJkIChBRVMpIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdGhlIHB1YmxpYyBkb21haW4gbGlicmFyeSAnanNjcnlwdG8nIHdoaWNoXG4gKiB3YXMgd3JpdHRlbiBieTpcbiAqXG4gKiBFbWlseSBTdGFyayAoZXN0YXJrQHN0YW5mb3JkLmVkdSlcbiAqIE1pa2UgSGFtYnVyZyAobWhhbWJ1cmdAc3RhbmZvcmQuZWR1KVxuICogRGFuIEJvbmVoIChkYWJvQGNzLnN0YW5mb3JkLmVkdSlcbiAqXG4gKiBQYXJ0cyBvZiB0aGlzIGNvZGUgYXJlIGJhc2VkIG9uIHRoZSBPcGVuU1NMIGltcGxlbWVudGF0aW9uIG9mIEFFUzpcbiAqIGh0dHA6Ly93d3cub3BlbnNzbC5vcmdcbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vY2lwaGVyJyk7XG5yZXF1aXJlKCcuL2NpcGhlck1vZGVzJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxuLyogQUVTIEFQSSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5hZXMgPSBmb3JnZS5hZXMgfHwge307XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqIGNpcGhlci5zdGFydCh7aXY6IGl2fSk7XG4gKlxuICogQ3JlYXRlcyBhbiBBRVMgY2lwaGVyIG9iamVjdCB0byBlbmNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKiBUaGUgb3V0cHV0IHdpbGwgYmUgc3RvcmVkIGluIHRoZSAnb3V0cHV0JyBtZW1iZXIgb2YgdGhlIHJldHVybmVkIGNpcGhlci5cbiAqXG4gKiBUaGUga2V5IGFuZCBpdiBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMsIGFuIGFycmF5IG9mIGJ5dGVzLFxuICogYSBieXRlIGJ1ZmZlciwgb3IgYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGl2IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdG8gdXNlLlxuICogQHBhcmFtIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gKiBAcGFyYW0gbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5hZXMuc3RhcnRFbmNyeXB0aW5nID0gZnVuY3Rpb24oa2V5LCBpdiwgb3V0cHV0LCBtb2RlKSB7XG4gIHZhciBjaXBoZXIgPSBfY3JlYXRlQ2lwaGVyKHtcbiAgICBrZXk6IGtleSxcbiAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICBkZWNyeXB0OiBmYWxzZSxcbiAgICBtb2RlOiBtb2RlXG4gIH0pO1xuICBjaXBoZXIuc3RhcnQoaXYpO1xuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0FFUy08bW9kZT4nLCBrZXkpO1xuICpcbiAqIENyZWF0ZXMgYW4gQUVTIGNpcGhlciBvYmplY3QgdG8gZW5jcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcywgYVxuICogYnl0ZSBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBtb2RlIHRoZSBjaXBoZXIgbW9kZSB0byB1c2UgKGRlZmF1bHQ6ICdDQkMnKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBtb2RlKSB7XG4gIHJldHVybiBfY3JlYXRlQ2lwaGVyKHtcbiAgICBrZXk6IGtleSxcbiAgICBvdXRwdXQ6IG51bGwsXG4gICAgZGVjcnlwdDogZmFsc2UsXG4gICAgbW9kZTogbW9kZVxuICB9KTtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBkZWNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcignQUVTLTxtb2RlPicsIGtleSk7XG4gKiBkZWNpcGhlci5zdGFydCh7aXY6IGl2fSk7XG4gKlxuICogQ3JlYXRlcyBhbiBBRVMgY2lwaGVyIG9iamVjdCB0byBkZWNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKiBUaGUgb3V0cHV0IHdpbGwgYmUgc3RvcmVkIGluIHRoZSAnb3V0cHV0JyBtZW1iZXIgb2YgdGhlIHJldHVybmVkIGNpcGhlci5cbiAqXG4gKiBUaGUga2V5IGFuZCBpdiBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMsIGFuIGFycmF5IG9mIGJ5dGVzLFxuICogYSBieXRlIGJ1ZmZlciwgb3IgYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGl2IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdG8gdXNlLlxuICogQHBhcmFtIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gKiBAcGFyYW0gbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5hZXMuc3RhcnREZWNyeXB0aW5nID0gZnVuY3Rpb24oa2V5LCBpdiwgb3V0cHV0LCBtb2RlKSB7XG4gIHZhciBjaXBoZXIgPSBfY3JlYXRlQ2lwaGVyKHtcbiAgICBrZXk6IGtleSxcbiAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICBkZWNyeXB0OiB0cnVlLFxuICAgIG1vZGU6IG1vZGVcbiAgfSk7XG4gIGNpcGhlci5zdGFydChpdik7XG4gIHJldHVybiBjaXBoZXI7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgZGVjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlRGVjaXBoZXIoJ0FFUy08bW9kZT4nLCBrZXkpO1xuICpcbiAqIENyZWF0ZXMgYW4gQUVTIGNpcGhlciBvYmplY3QgdG8gZGVjcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcywgYVxuICogYnl0ZSBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBtb2RlIHRoZSBjaXBoZXIgbW9kZSB0byB1c2UgKGRlZmF1bHQ6ICdDQkMnKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBtb2RlKSB7XG4gIHJldHVybiBfY3JlYXRlQ2lwaGVyKHtcbiAgICBrZXk6IGtleSxcbiAgICBvdXRwdXQ6IG51bGwsXG4gICAgZGVjcnlwdDogdHJ1ZSxcbiAgICBtb2RlOiBtb2RlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEFFUyBjaXBoZXIgYWxnb3JpdGhtIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgYWxnb3JpdGhtLlxuICogQHBhcmFtIG1vZGUgdGhlIG1vZGUgZmFjdG9yeSBmdW5jdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBRVMgYWxnb3JpdGhtIG9iamVjdC5cbiAqL1xuZm9yZ2UuYWVzLkFsZ29yaXRobSA9IGZ1bmN0aW9uKG5hbWUsIG1vZGUpIHtcbiAgaWYoIWluaXQpIHtcbiAgICBpbml0aWFsaXplKCk7XG4gIH1cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLm5hbWUgPSBuYW1lO1xuICBzZWxmLm1vZGUgPSBuZXcgbW9kZSh7XG4gICAgYmxvY2tTaXplOiAxNixcbiAgICBjaXBoZXI6IHtcbiAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uKGluQmxvY2ssIG91dEJsb2NrKSB7XG4gICAgICAgIHJldHVybiBfdXBkYXRlQmxvY2soc2VsZi5fdywgaW5CbG9jaywgb3V0QmxvY2ssIGZhbHNlKTtcbiAgICAgIH0sXG4gICAgICBkZWNyeXB0OiBmdW5jdGlvbihpbkJsb2NrLCBvdXRCbG9jaykge1xuICAgICAgICByZXR1cm4gX3VwZGF0ZUJsb2NrKHNlbGYuX3csIGluQmxvY2ssIG91dEJsb2NrLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBzZWxmLl9pbml0ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoaXMgQUVTIGFsZ29yaXRobSBieSBleHBhbmRpbmcgaXRzIGtleS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2UuXG4gKiAgICAgICAgICBrZXkgdGhlIGtleSB0byB1c2Ugd2l0aCB0aGlzIGFsZ29yaXRobS5cbiAqICAgICAgICAgIGRlY3J5cHQgdHJ1ZSBpZiB0aGUgYWxnb3JpdGhtIHNob3VsZCBiZSBpbml0aWFsaXplZCBmb3IgZGVjcnlwdGlvbixcbiAqICAgICAgICAgICAgZmFsc2UgZm9yIGVuY3J5cHRpb24uXG4gKi9cbmZvcmdlLmFlcy5BbGdvcml0aG0ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmKHRoaXMuX2luaXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gIHZhciB0bXA7XG5cbiAgLyogTm90ZTogVGhlIGtleSBtYXkgYmUgYSBzdHJpbmcgb2YgYnl0ZXMsIGFuIGFycmF5IG9mIGJ5dGVzLCBhIGJ5dGVcbiAgICBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCBpbnRlZ2Vycy4gSWYgdGhlIGtleSBpcyBpbiBieXRlcywgdGhlblxuICAgIGl0IG11c3QgYmUgMTYsIDI0LCBvciAzMiBieXRlcyBpbiBsZW5ndGguIElmIGl0IGlzIGluIDMyLWJpdFxuICAgIGludGVnZXJzLCBpdCBtdXN0IGJlIDQsIDYsIG9yIDggaW50ZWdlcnMgbG9uZy4gKi9cblxuICBpZih0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJlxuICAgIChrZXkubGVuZ3RoID09PSAxNiB8fCBrZXkubGVuZ3RoID09PSAyNCB8fCBrZXkubGVuZ3RoID09PSAzMikpIHtcbiAgICAvLyBjb252ZXJ0IGtleSBzdHJpbmcgaW50byBieXRlIGJ1ZmZlclxuICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGtleSk7XG4gIH0gZWxzZSBpZihmb3JnZS51dGlsLmlzQXJyYXkoa2V5KSAmJlxuICAgIChrZXkubGVuZ3RoID09PSAxNiB8fCBrZXkubGVuZ3RoID09PSAyNCB8fCBrZXkubGVuZ3RoID09PSAzMikpIHtcbiAgICAvLyBjb252ZXJ0IGtleSBpbnRlZ2VyIGFycmF5IGludG8gYnl0ZSBidWZmZXJcbiAgICB0bXAgPSBrZXk7XG4gICAga2V5ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgKytpKSB7XG4gICAgICBrZXkucHV0Qnl0ZSh0bXBbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbnZlcnQga2V5IGJ5dGUgYnVmZmVyIGludG8gMzItYml0IGludGVnZXIgYXJyYXlcbiAgaWYoIWZvcmdlLnV0aWwuaXNBcnJheShrZXkpKSB7XG4gICAgdG1wID0ga2V5O1xuICAgIGtleSA9IFtdO1xuXG4gICAgLy8ga2V5IGxlbmd0aHMgb2YgMTYsIDI0LCAzMiBieXRlcyBhbGxvd2VkXG4gICAgdmFyIGxlbiA9IHRtcC5sZW5ndGgoKTtcbiAgICBpZihsZW4gPT09IDE2IHx8IGxlbiA9PT0gMjQgfHwgbGVuID09PSAzMikge1xuICAgICAgbGVuID0gbGVuID4+PiAyO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGtleS5wdXNoKHRtcC5nZXRJbnQzMigpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZXkgbXVzdCBiZSBhbiBhcnJheSBvZiAzMi1iaXQgaW50ZWdlcnMgYnkgbm93XG4gIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkoa2V5KSB8fFxuICAgICEoa2V5Lmxlbmd0aCA9PT0gNCB8fCBrZXkubGVuZ3RoID09PSA2IHx8IGtleS5sZW5ndGggPT09IDgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSBwYXJhbWV0ZXIuJyk7XG4gIH1cblxuICAvLyBlbmNyeXB0aW9uIG9wZXJhdGlvbiBpcyBhbHdheXMgdXNlZCBmb3IgdGhlc2UgbW9kZXNcbiAgdmFyIG1vZGUgPSB0aGlzLm1vZGUubmFtZTtcbiAgdmFyIGVuY3J5cHRPcCA9IChbJ0NGQicsICdPRkInLCAnQ1RSJywgJ0dDTSddLmluZGV4T2YobW9kZSkgIT09IC0xKTtcblxuICAvLyBkbyBrZXkgZXhwYW5zaW9uXG4gIHRoaXMuX3cgPSBfZXhwYW5kS2V5KGtleSwgb3B0aW9ucy5kZWNyeXB0ICYmICFlbmNyeXB0T3ApO1xuICB0aGlzLl9pbml0ID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogRXhwYW5kcyBhIGtleS4gVHlwaWNhbGx5IG9ubHkgdXNlZCBmb3IgdGVzdGluZy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIGV4cGFuZCwgYXMgYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuICogQHBhcmFtIGRlY3J5cHQgdHJ1ZSB0byBleHBhbmQgZm9yIGRlY3J5cHRpb24sIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICpcbiAqIEByZXR1cm4gdGhlIGV4cGFuZGVkIGtleS5cbiAqL1xuZm9yZ2UuYWVzLl9leHBhbmRLZXkgPSBmdW5jdGlvbihrZXksIGRlY3J5cHQpIHtcbiAgaWYoIWluaXQpIHtcbiAgICBpbml0aWFsaXplKCk7XG4gIH1cbiAgcmV0dXJuIF9leHBhbmRLZXkoa2V5LCBkZWNyeXB0KTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyBhIHNpbmdsZSBibG9jay4gVHlwaWNhbGx5IG9ubHkgdXNlZCBmb3IgdGVzdGluZy5cbiAqXG4gKiBAcGFyYW0gdyB0aGUgZXhwYW5kZWQga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBpbnB1dCBhbiBhcnJheSBvZiBibG9jay1zaXplIDMyLWJpdCB3b3Jkcy5cbiAqIEBwYXJhbSBvdXRwdXQgYW4gYXJyYXkgb2YgYmxvY2stc2l6ZSAzMi1iaXQgd29yZHMuXG4gKiBAcGFyYW0gZGVjcnlwdCB0cnVlIHRvIGRlY3J5cHQsIGZhbHNlIHRvIGVuY3J5cHQuXG4gKi9cbmZvcmdlLmFlcy5fdXBkYXRlQmxvY2sgPSBfdXBkYXRlQmxvY2s7XG5cbi8qKiBSZWdpc3RlciBBRVMgYWxnb3JpdGhtcyAqKi9cblxucmVnaXN0ZXJBbGdvcml0aG0oJ0FFUy1FQ0InLCBmb3JnZS5jaXBoZXIubW9kZXMuZWNiKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdBRVMtQ0JDJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmNiYyk7XG5yZWdpc3RlckFsZ29yaXRobSgnQUVTLUNGQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5jZmIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0FFUy1PRkInLCBmb3JnZS5jaXBoZXIubW9kZXMub2ZiKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdBRVMtQ1RSJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmN0cik7XG5yZWdpc3RlckFsZ29yaXRobSgnQUVTLUdDTScsIGZvcmdlLmNpcGhlci5tb2Rlcy5nY20pO1xuXG5mdW5jdGlvbiByZWdpc3RlckFsZ29yaXRobShuYW1lLCBtb2RlKSB7XG4gIHZhciBmYWN0b3J5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBmb3JnZS5hZXMuQWxnb3JpdGhtKG5hbWUsIG1vZGUpO1xuICB9O1xuICBmb3JnZS5jaXBoZXIucmVnaXN0ZXJBbGdvcml0aG0obmFtZSwgZmFjdG9yeSk7XG59XG5cbi8qKiBBRVMgaW1wbGVtZW50YXRpb24gKiovXG5cbnZhciBpbml0ID0gZmFsc2U7IC8vIG5vdCB5ZXQgaW5pdGlhbGl6ZWRcbnZhciBOYiA9IDQ7ICAgICAgIC8vIG51bWJlciBvZiB3b3JkcyBjb21wcmlzaW5nIHRoZSBzdGF0ZSAoQUVTID0gNClcbnZhciBzYm94OyAgICAgICAgIC8vIG5vbi1saW5lYXIgc3Vic3RpdHV0aW9uIHRhYmxlIHVzZWQgaW4ga2V5IGV4cGFuc2lvblxudmFyIGlzYm94OyAgICAgICAgLy8gaW52ZXJzaW9uIG9mIHNib3hcbnZhciByY29uOyAgICAgICAgIC8vIHJvdW5kIGNvbnN0YW50IHdvcmQgYXJyYXlcbnZhciBtaXg7ICAgICAgICAgIC8vIG1peC1jb2x1bW5zIHRhYmxlXG52YXIgaW1peDsgICAgICAgICAvLyBpbnZlcnNlIG1peC1jb2x1bW5zIHRhYmxlXG5cbi8qKlxuICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24sIGllOiBwcmVjb21wdXRlcyB0YWJsZXMgdG8gb3B0aW1pemUgZm9yIHNwZWVkLlxuICpcbiAqIE9uZSB3YXkgdG8gdW5kZXJzdGFuZCBob3cgQUVTIHdvcmtzIGlzIHRvIGltYWdpbmUgdGhhdCAnYWRkaXRpb24nIGFuZFxuICogJ211bHRpcGxpY2F0aW9uJyBhcmUgaW50ZXJmYWNlcyB0aGF0IHJlcXVpcmUgY2VydGFpbiBtYXRoZW1hdGljYWxcbiAqIHByb3BlcnRpZXMgdG8gaG9sZCB0cnVlIChpZTogdGhleSBhcmUgYXNzb2NpYXRpdmUpIGJ1dCB0aGV5IG1pZ2h0IGhhdmVcbiAqIGRpZmZlcmVudCBpbXBsZW1lbnRhdGlvbnMgYW5kIHByb2R1Y2UgZGlmZmVyZW50IGtpbmRzIG9mIHJlc3VsdHMgLi4uXG4gKiBwcm92aWRlZCB0aGF0IHRoZWlyIG1hdGhlbWF0aWNhbCBwcm9wZXJ0aWVzIHJlbWFpbiB0cnVlLiBBRVMgZGVmaW5lc1xuICogaXRzIG93biBtZXRob2RzIG9mIGFkZGl0aW9uIGFuZCBtdWx0aXBsaWNhdGlvbiBidXQga2VlcHMgc29tZSBpbXBvcnRhbnRcbiAqIHByb3BlcnRpZXMgdGhlIHNhbWUsIGllOiBhc3NvY2lhdGl2aXR5IGFuZCBkaXN0cmlidXRpdml0eS4gVGhlXG4gKiBleHBsYW5hdGlvbiBiZWxvdyB0cmllcyB0byBzaGVkIHNvbWUgbGlnaHQgb24gaG93IEFFUyBkZWZpbmVzIGFkZGl0aW9uXG4gKiBhbmQgbXVsdGlwbGljYXRpb24gb2YgYnl0ZXMgYW5kIDMyLWJpdCB3b3JkcyBpbiBvcmRlciB0byBwZXJmb3JtIGl0c1xuICogZW5jcnlwdGlvbiBhbmQgZGVjcnlwdGlvbiBhbGdvcml0aG1zLlxuICpcbiAqIFRoZSBiYXNpY3M6XG4gKlxuICogVGhlIEFFUyBhbGdvcml0aG0gdmlld3MgYnl0ZXMgYXMgYmluYXJ5IHJlcHJlc2VudGF0aW9ucyBvZiBwb2x5bm9taWFsc1xuICogdGhhdCBoYXZlIGVpdGhlciAxIG9yIDAgYXMgdGhlIGNvZWZmaWNpZW50cy4gSXQgZGVmaW5lcyB0aGUgYWRkaXRpb25cbiAqIG9yIHN1YnRyYWN0aW9uIG9mIHR3byBieXRlcyBhcyB0aGUgWE9SIG9wZXJhdGlvbi4gSXQgYWxzbyBkZWZpbmVzIHRoZVxuICogbXVsdGlwbGljYXRpb24gb2YgdHdvIGJ5dGVzIGFzIGEgZmluaXRlIGZpZWxkIHJlZmVycmVkIHRvIGFzIEdGKDJeOClcbiAqIChOb3RlOiAnR0YnIG1lYW5zIFwiR2Fsb2lzIEZpZWxkXCIgd2hpY2ggaXMgYSBmaWVsZCB0aGF0IGNvbnRhaW5zIGEgZmluaXRlXG4gKiBudW1iZXIgb2YgZWxlbWVudHMgc28gR0YoMl44KSBoYXMgMjU2IGVsZW1lbnRzKS5cbiAqXG4gKiBUaGlzIG1lYW5zIHRoYXQgYW55IHR3byBieXRlcyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYmluYXJ5IHBvbHlub21pYWxzO1xuICogd2hlbiB0aGV5IG11bHRpcGxpZWQgdG9nZXRoZXIgYW5kIG1vZHVsYXJseSByZWR1Y2VkIGJ5IGFuIGlycmVkdWNpYmxlXG4gKiBwb2x5bm9taWFsIG9mIHRoZSA4dGggZGVncmVlLCB0aGUgcmVzdWx0cyBhcmUgdGhlIGZpZWxkIEdGKDJeOCkuIFRoZVxuICogc3BlY2lmaWMgaXJyZWR1Y2libGUgcG9seW5vbWlhbCB0aGF0IEFFUyB1c2VzIGluIGhleGFkZWNpbWFsIGlzIDB4MTFiLlxuICogVGhpcyBtdWx0aXBsaWNhdGlvbiBpcyBhc3NvY2lhdGl2ZSB3aXRoIDB4MDEgYXMgdGhlIGlkZW50aXR5OlxuICpcbiAqIChiICogMHgwMSA9IEdGKGIsIDB4MDEpID0gYikuXG4gKlxuICogVGhlIG9wZXJhdGlvbiBHRihiLCAweDAyKSBjYW4gYmUgcGVyZm9ybWVkIGF0IHRoZSBieXRlIGxldmVsIGJ5IGxlZnRcbiAqIHNoaWZ0aW5nIGIgb25jZSBhbmQgdGhlbiBYT1InaW5nIGl0ICh0byBwZXJmb3JtIHRoZSBtb2R1bGFyIHJlZHVjdGlvbilcbiAqIHdpdGggMHgxMWIgaWYgYiBpcyA+PSAxMjguIFJlcGVhdGVkIGFwcGxpY2F0aW9uIG9mIHRoZSBtdWx0aXBsaWNhdGlvblxuICogb2YgMHgwMiBjYW4gYmUgdXNlZCB0byBpbXBsZW1lbnQgdGhlIG11bHRpcGxpY2F0aW9uIG9mIGFueSB0d28gYnl0ZXMuXG4gKlxuICogRm9yIGluc3RhbmNlLCBtdWx0aXBseWluZyAweDU3IGFuZCAweDEzLCBkZW5vdGVkIGFzIEdGKDB4NTcsIDB4MTMpLCBjYW5cbiAqIGJlIHBlcmZvcm1lZCBieSBmYWN0b3JpbmcgMHgxMyBpbnRvIDB4MDEsIDB4MDIsIGFuZCAweDEwLiBUaGVuIHRoZXNlXG4gKiBmYWN0b3JzIGNhbiBlYWNoIGJlIG11bHRpcGxpZWQgYnkgMHg1NyBhbmQgdGhlbiBhZGRlZCB0b2dldGhlci4gVG8gZG9cbiAqIHRoZSBtdWx0aXBsaWNhdGlvbiwgdmFsdWVzIGZvciAweDU3IG11bHRpcGxpZWQgYnkgZWFjaCBvZiB0aGVzZSAzIGZhY3RvcnNcbiAqIGNhbiBiZSBwcmVjb21wdXRlZCBhbmQgc3RvcmVkIGluIGEgdGFibGUuIFRvIGFkZCB0aGVtLCB0aGUgdmFsdWVzIGZyb21cbiAqIHRoZSB0YWJsZSBhcmUgWE9SJ2QgdG9nZXRoZXIuXG4gKlxuICogQUVTIGFsc28gZGVmaW5lcyBhZGRpdGlvbiBhbmQgbXVsdGlwbGljYXRpb24gb2Ygd29yZHMsIHRoYXQgaXMgNC1ieXRlXG4gKiBudW1iZXJzIHJlcHJlc2VudGVkIGFzIHBvbHlub21pYWxzIG9mIDMgZGVncmVlcyB3aGVyZSB0aGUgY29lZmZpY2llbnRzXG4gKiBhcmUgdGhlIHZhbHVlcyBvZiB0aGUgYnl0ZXMuXG4gKlxuICogVGhlIHdvcmQgW2EwLCBhMSwgYTIsIGEzXSBpcyBhIHBvbHlub21pYWwgYTN4XjMgKyBhMnheMiArIGExeCArIGEwLlxuICpcbiAqIEFkZGl0aW9uIGlzIHBlcmZvcm1lZCBieSBYT1InaW5nIGxpa2UgcG93ZXJzIG9mIHguIE11bHRpcGxpY2F0aW9uXG4gKiBpcyBwZXJmb3JtZWQgaW4gdHdvIHN0ZXBzLCB0aGUgZmlyc3QgaXMgYW4gYWxnZWJyaWFjIGV4cGFuc2lvbiBhc1xuICogeW91IHdvdWxkIGRvIG5vcm1hbGx5ICh3aGVyZSBhZGRpdGlvbiBpcyBYT1IpLiBCdXQgdGhlIHJlc3VsdCBpc1xuICogYSBwb2x5bm9taWFsIGxhcmdlciB0aGFuIDMgZGVncmVlcyBhbmQgdGh1cyBpdCBjYW5ub3QgZml0IGluIGEgd29yZC4gU29cbiAqIG5leHQgdGhlIHJlc3VsdCBpcyBtb2R1bGFybHkgcmVkdWNlZCBieSBhbiBBRVMtc3BlY2lmaWMgcG9seW5vbWlhbCBvZlxuICogZGVncmVlIDQgd2hpY2ggd2lsbCBhbHdheXMgcHJvZHVjZSBhIHBvbHlub21pYWwgb2YgbGVzcyB0aGFuIDQgZGVncmVlc1xuICogc3VjaCB0aGF0IGl0IHdpbGwgZml0IGluIGEgd29yZC4gSW4gQUVTLCB0aGlzIHBvbHlub21pYWwgaXMgeF40ICsgMS5cbiAqXG4gKiBUaGUgbW9kdWxhciBwcm9kdWN0IG9mIHR3byBwb2x5bm9taWFscyAnYScgYW5kICdiJyBpcyB0aHVzOlxuICpcbiAqIGQoeCkgPSBkM3heMyArIGQyeF4yICsgZDF4ICsgZDBcbiAqIHdpdGhcbiAqIGQwID0gR0YoYTAsIGIwKSBeIEdGKGEzLCBiMSkgXiBHRihhMiwgYjIpIF4gR0YoYTEsIGIzKVxuICogZDEgPSBHRihhMSwgYjApIF4gR0YoYTAsIGIxKSBeIEdGKGEzLCBiMikgXiBHRihhMiwgYjMpXG4gKiBkMiA9IEdGKGEyLCBiMCkgXiBHRihhMSwgYjEpIF4gR0YoYTAsIGIyKSBeIEdGKGEzLCBiMylcbiAqIGQzID0gR0YoYTMsIGIwKSBeIEdGKGEyLCBiMSkgXiBHRihhMSwgYjIpIF4gR0YoYTAsIGIzKVxuICpcbiAqIEFzIGEgbWF0cml4OlxuICpcbiAqIFtkMF0gPSBbYTAgYTMgYTIgYTFdW2IwXVxuICogW2QxXSAgIFthMSBhMCBhMyBhMl1bYjFdXG4gKiBbZDJdICAgW2EyIGExIGEwIGEzXVtiMl1cbiAqIFtkM10gICBbYTMgYTIgYTEgYTBdW2IzXVxuICpcbiAqIFNwZWNpYWwgcG9seW5vbWlhbHMgZGVmaW5lZCBieSBBRVMgKDB4MDIgPT0gezAyfSk6XG4gKiBhKHgpICAgID0gezAzfXheMyArIHswMX14XjIgKyB7MDF9eCArIHswMn1cbiAqIGFeLTEoeCkgPSB7MGJ9eF4zICsgezBkfXheMiArIHswOX14ICsgezBlfS5cbiAqXG4gKiBUaGVzZSBwb2x5bm9taWFscyBhcmUgdXNlZCBpbiB0aGUgTWl4Q29sdW1ucygpIGFuZCBJbnZlcnNlTWl4Q29sdW1ucygpXG4gKiBvcGVyYXRpb25zLCByZXNwZWN0aXZlbHksIHRvIGNhdXNlIGVhY2ggZWxlbWVudCBpbiB0aGUgc3RhdGUgdG8gYWZmZWN0XG4gKiB0aGUgb3V0cHV0IChyZWZlcnJlZCB0byBhcyBkaWZmdXNpbmcpLlxuICpcbiAqIFJvdFdvcmQoKSB1c2VzOiBhMCA9IGExID0gYTIgPSB7MDB9IGFuZCBhMyA9IHswMX0sIHdoaWNoIGlzIHRoZVxuICogcG9seW5vbWlhbCB4My5cbiAqXG4gKiBUaGUgU2hpZnRSb3dzKCkgbWV0aG9kIG1vZGlmaWVzIHRoZSBsYXN0IDMgcm93cyBpbiB0aGUgc3RhdGUgKHdoZXJlXG4gKiB0aGUgc3RhdGUgaXMgNCB3b3JkcyB3aXRoIDQgYnl0ZXMgcGVyIHdvcmQpIGJ5IHNoaWZ0aW5nIGJ5dGVzIGN5Y2xpY2FsbHkuXG4gKiBUaGUgMXN0IGJ5dGUgaW4gdGhlIHNlY29uZCByb3cgaXMgbW92ZWQgdG8gdGhlIGVuZCBvZiB0aGUgcm93LiBUaGUgMXN0XG4gKiBhbmQgMm5kIGJ5dGVzIGluIHRoZSB0aGlyZCByb3cgYXJlIG1vdmVkIHRvIHRoZSBlbmQgb2YgdGhlIHJvdy4gVGhlIDFzdCxcbiAqIDJuZCwgYW5kIDNyZCBieXRlcyBhcmUgbW92ZWQgaW4gdGhlIGZvdXJ0aCByb3cuXG4gKlxuICogTW9yZSBkZXRhaWxzIG9uIGhvdyBBRVMgYXJpdGhtZXRpYyB3b3JrczpcbiAqXG4gKiBJbiB0aGUgcG9seW5vbWlhbCByZXByZXNlbnRhdGlvbiBvZiBiaW5hcnkgbnVtYmVycywgWE9SIHBlcmZvcm1zIGFkZGl0aW9uXG4gKiBhbmQgc3VidHJhY3Rpb24gYW5kIG11bHRpcGxpY2F0aW9uIGluIEdGKDJeOCkgZGVub3RlZCBhcyBHRihhLCBiKVxuICogY29ycmVzcG9uZHMgd2l0aCB0aGUgbXVsdGlwbGljYXRpb24gb2YgcG9seW5vbWlhbHMgbW9kdWxvIGFuIGlycmVkdWNpYmxlXG4gKiBwb2x5bm9taWFsIG9mIGRlZ3JlZSA4LiBJbiBvdGhlciB3b3JkcywgZm9yIEFFUywgR0YoYSwgYikgd2lsbCBtdWx0aXBseVxuICogcG9seW5vbWlhbCAnYScgd2l0aCBwb2x5bm9taWFsICdiJyBhbmQgdGhlbiBkbyBhIG1vZHVsYXIgcmVkdWN0aW9uIGJ5XG4gKiBhbiBBRVMtc3BlY2lmaWMgaXJyZWR1Y2libGUgcG9seW5vbWlhbCBvZiBkZWdyZWUgOC5cbiAqXG4gKiBBIHBvbHlub21pYWwgaXMgaXJyZWR1Y2libGUgaWYgaXRzIG9ubHkgZGl2aXNvcnMgYXJlIG9uZSBhbmQgaXRzZWxmLiBGb3JcbiAqIHRoZSBBRVMgYWxnb3JpdGhtLCB0aGlzIGlycmVkdWNpYmxlIHBvbHlub21pYWwgaXM6XG4gKlxuICogbSh4KSA9IHheOCArIHheNCArIHheMyArIHggKyAxLFxuICpcbiAqIG9yIHswMX17MWJ9IGluIGhleGFkZWNpbWFsIG5vdGF0aW9uLCB3aGVyZSBlYWNoIGNvZWZmaWNpZW50IGlzIGEgYml0OlxuICogMTAwMDExMDExID0gMjgzID0gMHgxMWIuXG4gKlxuICogRm9yIGV4YW1wbGUsIEdGKDB4NTcsIDB4ODMpID0gMHhjMSBiZWNhdXNlXG4gKlxuICogMHg1NyA9IDg3ICA9IDAxMDEwMTExID0geF42ICsgeF40ICsgeF4yICsgeCArIDFcbiAqIDB4ODUgPSAxMzEgPSAxMDAwMDEwMSA9IHheNyArIHggKyAxXG4gKlxuICogKHheNiArIHheNCArIHheMiArIHggKyAxKSAqICh4XjcgKyB4ICsgMSlcbiAqID0gIHheMTMgKyB4XjExICsgeF45ICsgeF44ICsgeF43ICtcbiAqICAgIHheNyArIHheNSArIHheMyArIHheMiArIHggK1xuICogICAgeF42ICsgeF40ICsgeF4yICsgeCArIDFcbiAqID0gIHheMTMgKyB4XjExICsgeF45ICsgeF44ICsgeF42ICsgeF41ICsgeF40ICsgeF4zICsgMSA9IHlcbiAqICAgIHkgbW9kdWxvICh4XjggKyB4XjQgKyB4XjMgKyB4ICsgMSlcbiAqID0gIHheNyArIHheNiArIDEuXG4gKlxuICogVGhlIG1vZHVsYXIgcmVkdWN0aW9uIGJ5IG0oeCkgZ3VhcmFudGVlcyB0aGUgcmVzdWx0IHdpbGwgYmUgYSBiaW5hcnlcbiAqIHBvbHlub21pYWwgb2YgbGVzcyB0aGFuIGRlZ3JlZSA4LCBzbyB0aGF0IGl0IGNhbiBmaXQgaW4gYSBieXRlLlxuICpcbiAqIFRoZSBvcGVyYXRpb24gdG8gbXVsdGlwbHkgYSBiaW5hcnkgcG9seW5vbWlhbCBiIHdpdGggeCAodGhlIHBvbHlub21pYWxcbiAqIHggaW4gYmluYXJ5IHJlcHJlc2VudGF0aW9uIGlzIDAwMDAwMDEwKSBpczpcbiAqXG4gKiBiXzd4XjggKyBiXzZ4XjcgKyBiXzV4XjYgKyBiXzR4XjUgKyBiXzN4XjQgKyBiXzJ4XjMgKyBiXzF4XjIgKyBiXzB4XjFcbiAqXG4gKiBUbyBnZXQgR0YoYiwgeCkgd2UgbXVzdCByZWR1Y2UgdGhhdCBieSBtKHgpLiBJZiBiXzcgaXMgMCAodGhhdCBpcyB0aGVcbiAqIG1vc3Qgc2lnbmlmaWNhbnQgYml0IGlzIDAgaW4gYikgdGhlbiB0aGUgcmVzdWx0IGlzIGFscmVhZHkgcmVkdWNlZC4gSWZcbiAqIGl0IGlzIDEsIHRoZW4gd2UgY2FuIHJlZHVjZSBpdCBieSBzdWJ0cmFjdGluZyBtKHgpIHZpYSBhbiBYT1IuXG4gKlxuICogSXQgZm9sbG93cyB0aGF0IG11bHRpcGxpY2F0aW9uIGJ5IHggKDAwMDAwMDEwIG9yIDB4MDIpIGNhbiBiZSBpbXBsZW1lbnRlZFxuICogYnkgcGVyZm9ybWluZyBhIGxlZnQgc2hpZnQgZm9sbG93ZWQgYnkgYSBjb25kaXRpb25hbCBiaXR3aXNlIFhPUiB3aXRoXG4gKiAweDFiLiBUaGlzIG9wZXJhdGlvbiBvbiBieXRlcyBpcyBkZW5vdGVkIGJ5IHh0aW1lKCkuIE11bHRpcGxpY2F0aW9uIGJ5XG4gKiBoaWdoZXIgcG93ZXJzIG9mIHggY2FuIGJlIGltcGxlbWVudGVkIGJ5IHJlcGVhdGVkIGFwcGxpY2F0aW9uIG9mIHh0aW1lKCkuXG4gKlxuICogQnkgYWRkaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLCBtdWx0aXBsaWNhdGlvbiBieSBhbnkgY29uc3RhbnQgY2FuIGJlXG4gKiBpbXBsZW1lbnRlZC4gRm9yIGluc3RhbmNlOlxuICpcbiAqIEdGKDB4NTcsIDB4MTMpID0gMHhmZSBiZWNhdXNlOlxuICpcbiAqIHh0aW1lKGIpID0gKGIgJiAxMjgpID8gKGIgPDwgMSBeIDB4MTFiKSA6IChiIDw8IDEpXG4gKlxuICogTm90ZTogV2UgWE9SIHdpdGggMHgxMWIgaW5zdGVhZCBvZiAweDFiIGJlY2F1c2UgaW4gamF2YXNjcmlwdCBvdXJcbiAqIGRhdGF0eXBlIGZvciBiIGNhbiBiZSBsYXJnZXIgdGhhbiAxIGJ5dGUsIHNvIGEgbGVmdCBzaGlmdCB3aWxsIG5vdFxuICogYXV0b21hdGljYWxseSBlbGltaW5hdGUgYml0cyB0aGF0IG92ZXJmbG93IGEgYnl0ZSAuLi4gYnkgWE9SJ2luZyB0aGVcbiAqIG92ZXJmbG93IGJpdCB3aXRoIDEgKHRoZSBleHRyYSBvbmUgZnJvbSAweDExYikgd2UgemVybyBpdCBvdXQuXG4gKlxuICogR0YoMHg1NywgMHgwMikgPSB4dGltZSgweDU3KSA9IDB4YWVcbiAqIEdGKDB4NTcsIDB4MDQpID0geHRpbWUoMHhhZSkgPSAweDQ3XG4gKiBHRigweDU3LCAweDA4KSA9IHh0aW1lKDB4NDcpID0gMHg4ZVxuICogR0YoMHg1NywgMHgxMCkgPSB4dGltZSgweDhlKSA9IDB4MDdcbiAqXG4gKiBHRigweDU3LCAweDEzKSA9IEdGKDB4NTcsICgweDAxIF4gMHgwMiBeIDB4MTApKVxuICpcbiAqIEFuZCBieSB0aGUgZGlzdHJpYnV0aXZlIHByb3BlcnR5IChzaW5jZSBYT1IgaXMgYWRkaXRpb24gYW5kIEdGKCkgaXNcbiAqIG11bHRpcGxpY2F0aW9uKTpcbiAqXG4gKiA9IEdGKDB4NTcsIDB4MDEpIF4gR0YoMHg1NywgMHgwMikgXiBHRigweDU3LCAweDEwKVxuICogPSAweDU3IF4gMHhhZSBeIDB4MDdcbiAqID0gMHhmZS5cbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgaW5pdCA9IHRydWU7XG5cbiAgLyogUG9wdWxhdGUgdGhlIFJjb24gdGFibGUuIFRoZXNlIGFyZSB0aGUgdmFsdWVzIGdpdmVuIGJ5XG4gICAgW3heKGktMSksezAwfSx7MDB9LHswMH1dIHdoZXJlIHheKGktMSkgYXJlIHBvd2VycyBvZiB4IChhbmQgeCA9IDB4MDIpXG4gICAgaW4gdGhlIGZpZWxkIG9mIEdGKDJeOCksIHdoZXJlIGkgc3RhcnRzIGF0IDEuXG5cbiAgICByY29uWzBdID0gWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDBdXG4gICAgcmNvblsxXSA9IFsweDAxLCAweDAwLCAweDAwLCAweDAwXSAyXigxLTEpID0gMl4wID0gMVxuICAgIHJjb25bMl0gPSBbMHgwMiwgMHgwMCwgMHgwMCwgMHgwMF0gMl4oMi0xKSA9IDJeMSA9IDJcbiAgICAuLi5cbiAgICByY29uWzldICA9IFsweDFCLCAweDAwLCAweDAwLCAweDAwXSAyXig5LTEpICA9IDJeOCA9IDB4MUJcbiAgICByY29uWzEwXSA9IFsweDM2LCAweDAwLCAweDAwLCAweDAwXSAyXigxMC0xKSA9IDJeOSA9IDB4MzZcblxuICAgIFdlIG9ubHkgc3RvcmUgdGhlIGZpcnN0IGJ5dGUgYmVjYXVzZSBpdCBpcyB0aGUgb25seSBvbmUgdXNlZC5cbiAgKi9cbiAgcmNvbiA9IFsweDAwLCAweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFCLCAweDM2XTtcblxuICAvLyBjb21wdXRlIHh0aW1lIHRhYmxlIHdoaWNoIG1hcHMgaSBvbnRvIEdGKGksIDB4MDIpXG4gIHZhciB4dGltZSA9IG5ldyBBcnJheSgyNTYpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgMTI4OyArK2kpIHtcbiAgICB4dGltZVtpXSA9IGkgPDwgMTtcbiAgICB4dGltZVtpICsgMTI4XSA9IChpICsgMTI4KSA8PCAxIF4gMHgxMUI7XG4gIH1cblxuICAvLyBjb21wdXRlIGFsbCBvdGhlciB0YWJsZXNcbiAgc2JveCA9IG5ldyBBcnJheSgyNTYpO1xuICBpc2JveCA9IG5ldyBBcnJheSgyNTYpO1xuICBtaXggPSBuZXcgQXJyYXkoNCk7XG4gIGltaXggPSBuZXcgQXJyYXkoNCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICBtaXhbaV0gPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBpbWl4W2ldID0gbmV3IEFycmF5KDI1Nik7XG4gIH1cbiAgdmFyIGUgPSAwLCBlaSA9IDAsIGUyLCBlNCwgZTgsIHN4LCBzeDIsIG1lLCBpbWU7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgIC8qIFdlIG5lZWQgdG8gZ2VuZXJhdGUgdGhlIFN1YkJ5dGVzKCkgc2JveCBhbmQgaXNib3ggdGFibGVzIHNvIHRoYXRcbiAgICAgIHdlIGNhbiBwZXJmb3JtIGJ5dGUgc3Vic3RpdHV0aW9ucy4gVGhpcyByZXF1aXJlcyB1cyB0byB0cmF2ZXJzZVxuICAgICAgYWxsIG9mIHRoZSBlbGVtZW50cyBpbiBHRiwgZmluZCB0aGVpciBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlcyxcbiAgICAgIGFuZCBhcHBseSB0byBlYWNoIHRoZSBmb2xsb3dpbmcgYWZmaW5lIHRyYW5zZm9ybWF0aW9uOlxuXG4gICAgICBiaScgPSBiaSBeIGIoaSArIDQpIG1vZCA4IF4gYihpICsgNSkgbW9kIDggXiBiKGkgKyA2KSBtb2QgOCBeXG4gICAgICAgICAgICBiKGkgKyA3KSBtb2QgOCBeIGNpXG4gICAgICBmb3IgMCA8PSBpIDwgOCwgd2hlcmUgYmkgaXMgdGhlIGl0aCBiaXQgb2YgdGhlIGJ5dGUsIGFuZCBjaSBpcyB0aGVcbiAgICAgIGl0aCBiaXQgb2YgYSBieXRlIGMgd2l0aCB0aGUgdmFsdWUgezYzfSBvciB7MDExMDAwMTF9LlxuXG4gICAgICBJdCBpcyBwb3NzaWJsZSB0byB0cmF2ZXJzZSBldmVyeSBwb3NzaWJsZSB2YWx1ZSBpbiBhIEdhbG9pcyBmaWVsZFxuICAgICAgdXNpbmcgd2hhdCBpcyByZWZlcnJlZCB0byBhcyBhICdnZW5lcmF0b3InLiBUaGVyZSBhcmUgbWFueVxuICAgICAgZ2VuZXJhdG9ycyAoMTI4IG91dCBvZiAyNTYpOiAzLDUsNiw5LDExLDgyIHRvIG5hbWUgYSBmZXcuIFRvIGZ1bGx5XG4gICAgICB0cmF2ZXJzZSBHRiB3ZSBpdGVyYXRlIDI1NSB0aW1lcywgbXVsdGlwbHlpbmcgYnkgb3VyIGdlbmVyYXRvclxuICAgICAgZWFjaCB0aW1lLlxuXG4gICAgICBPbiBlYWNoIGl0ZXJhdGlvbiB3ZSBjYW4gZGV0ZXJtaW5lIHRoZSBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlIGZvclxuICAgICAgdGhlIGN1cnJlbnQgZWxlbWVudC5cblxuICAgICAgU3VwcG9zZSB0aGVyZSBpcyBhbiBlbGVtZW50IGluIEdGICdlJy4gRm9yIGEgZ2l2ZW4gZ2VuZXJhdG9yICdnJyxcbiAgICAgIGUgPSBnXnguIFRoZSBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlIG9mIGUgaXMgZ14oMjU1IC0geCkuIEl0IHR1cm5zXG4gICAgICBvdXQgdGhhdCBpZiB1c2UgdGhlIGludmVyc2Ugb2YgYSBnZW5lcmF0b3IgYXMgYW5vdGhlciBnZW5lcmF0b3JcbiAgICAgIGl0IHdpbGwgcHJvZHVjZSBhbGwgb2YgdGhlIGNvcnJlc3BvbmRpbmcgbXVsdGlwbGljYXRpdmUgaW52ZXJzZXNcbiAgICAgIGF0IHRoZSBzYW1lIHRpbWUuIEZvciB0aGlzIHJlYXNvbiwgd2UgY2hvb3NlIDUgYXMgb3VyIGludmVyc2VcbiAgICAgIGdlbmVyYXRvciBiZWNhdXNlIGl0IG9ubHkgcmVxdWlyZXMgMiBtdWx0aXBsaWVzIGFuZCAxIGFkZCBhbmQgaXRzXG4gICAgICBpbnZlcnNlLCA4MiwgcmVxdWlyZXMgcmVsYXRpdmVseSBmZXcgb3BlcmF0aW9ucyBhcyB3ZWxsLlxuXG4gICAgICBJbiBvcmRlciB0byBhcHBseSB0aGUgYWZmaW5lIHRyYW5zZm9ybWF0aW9uLCB0aGUgbXVsdGlwbGljYXRpdmVcbiAgICAgIGludmVyc2UgJ2VpJyBvZiAnZScgY2FuIGJlIHJlcGVhdGVkbHkgWE9SJ2QgKDQgdGltZXMpIHdpdGggYVxuICAgICAgYml0LWN5Y2xpbmcgb2YgJ2VpJy4gVG8gZG8gdGhpcyAnZWknIGlzIGZpcnN0IHN0b3JlZCBpbiAncycgYW5kXG4gICAgICAneCcuIFRoZW4gJ3MnIGlzIGxlZnQgc2hpZnRlZCBhbmQgdGhlIGhpZ2ggYml0IG9mICdzJyBpcyBtYWRlIHRoZVxuICAgICAgbG93IGJpdC4gVGhlIHJlc3VsdGluZyB2YWx1ZSBpcyBzdG9yZWQgaW4gJ3MnLiBUaGVuICd4JyBpcyBYT1InZFxuICAgICAgd2l0aCAncycgYW5kIHN0b3JlZCBpbiAneCcuIE9uIGVhY2ggc3Vic2VxdWVudCBpdGVyYXRpb24gdGhlIHNhbWVcbiAgICAgIG9wZXJhdGlvbiBpcyBwZXJmb3JtZWQuIFdoZW4gNCBpdGVyYXRpb25zIGFyZSBjb21wbGV0ZSwgJ3gnIGlzXG4gICAgICBYT1InZCB3aXRoICdjJyAoMHg2MykgYW5kIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZSBpcyBzdG9yZWQgaW4gJ3gnLlxuICAgICAgRm9yIGV4YW1wbGU6XG5cbiAgICAgIHMgPSAwMTAwMDAwMVxuICAgICAgeCA9IDAxMDAwMDAxXG5cbiAgICAgIGl0ZXJhdGlvbiAxOiBzID0gMTAwMDAwMTAsIHggXj0gc1xuICAgICAgaXRlcmF0aW9uIDI6IHMgPSAwMDAwMDEwMSwgeCBePSBzXG4gICAgICBpdGVyYXRpb24gMzogcyA9IDAwMDAxMDEwLCB4IF49IHNcbiAgICAgIGl0ZXJhdGlvbiA0OiBzID0gMDAwMTAxMDAsIHggXj0gc1xuICAgICAgeCBePSAweDYzXG5cbiAgICAgIFRoaXMgY2FuIGJlIGRvbmUgd2l0aCBhIGxvb3Agd2hlcmUgcyA9IChzIDw8IDEpIHwgKHMgPj4gNykuIEhvd2V2ZXIsXG4gICAgICBpdCBjYW4gYWxzbyBiZSBkb25lIGJ5IHVzaW5nIGEgc2luZ2xlIDE2LWJpdCAoaW4gdGhpcyBjYXNlIDMyLWJpdClcbiAgICAgIG51bWJlciAnc3gnLiBTaW5jZSBYT1IgaXMgYW4gYXNzb2NpYXRpdmUgb3BlcmF0aW9uLCB3ZSBjYW4gc2V0ICdzeCdcbiAgICAgIHRvICdlaScgYW5kIHRoZW4gWE9SIGl0IHdpdGggJ3N4JyBsZWZ0LXNoaWZ0ZWQgMSwyLDMsIGFuZCA0IHRpbWVzLlxuICAgICAgVGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0cyB3aWxsIGZsb3cgaW50byB0aGUgaGlnaCA4IGJpdCBwb3NpdGlvbnNcbiAgICAgIGFuZCBiZSBjb3JyZWN0bHkgWE9SJ2Qgd2l0aCBvbmUgYW5vdGhlci4gQWxsIHRoYXQgcmVtYWlucyB3aWxsIGJlXG4gICAgICB0byBjeWNsZSB0aGUgaGlnaCA4IGJpdHMgYnkgWE9SJ2luZyB0aGVtIGFsbCB3aXRoIHRoZSBsb3dlciA4IGJpdHNcbiAgICAgIGFmdGVyd2FyZHMuXG5cbiAgICAgIEF0IHRoZSBzYW1lIHRpbWUgd2UncmUgcG9wdWxhdGluZyBzYm94IGFuZCBpc2JveCB3ZSBjYW4gcHJlY29tcHV0ZVxuICAgICAgdGhlIG11bHRpcGxpY2F0aW9uIHdlJ2xsIG5lZWQgdG8gZG8gdG8gZG8gTWl4Q29sdW1ucygpIGxhdGVyLlxuICAgICovXG5cbiAgICAvLyBhcHBseSBhZmZpbmUgdHJhbnNmb3JtYXRpb25cbiAgICBzeCA9IGVpIF4gKGVpIDw8IDEpIF4gKGVpIDw8IDIpIF4gKGVpIDw8IDMpIF4gKGVpIDw8IDQpO1xuICAgIHN4ID0gKHN4ID4+IDgpIF4gKHN4ICYgMjU1KSBeIDB4NjM7XG5cbiAgICAvLyB1cGRhdGUgdGFibGVzXG4gICAgc2JveFtlXSA9IHN4O1xuICAgIGlzYm94W3N4XSA9IGU7XG5cbiAgICAvKiBNaXhpbmcgY29sdW1ucyBpcyBkb25lIHVzaW5nIG1hdHJpeCBtdWx0aXBsaWNhdGlvbi4gVGhlIGNvbHVtbnNcbiAgICAgIHRoYXQgYXJlIHRvIGJlIG1peGVkIGFyZSBlYWNoIGEgc2luZ2xlIHdvcmQgaW4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAgICBUaGUgc3RhdGUgaGFzIE5iIGNvbHVtbnMgKDQgY29sdW1ucykuIFRoZXJlZm9yZSBlYWNoIGNvbHVtbiBpcyBhXG4gICAgICA0IGJ5dGUgd29yZC4gU28gdG8gbWl4IHRoZSBjb2x1bW5zIGluIGEgc2luZ2xlIGNvbHVtbiAnYycgd2hlcmVcbiAgICAgIGl0cyByb3dzIGFyZSByMCwgcjEsIHIyLCBhbmQgcjMsIHdlIHVzZSB0aGUgZm9sbG93aW5nIG1hdHJpeFxuICAgICAgbXVsdGlwbGljYXRpb246XG5cbiAgICAgIFsyIDMgMSAxXSpbcjAsY109W3InMCxjXVxuICAgICAgWzEgMiAzIDFdIFtyMSxjXSBbcicxLGNdXG4gICAgICBbMSAxIDIgM10gW3IyLGNdIFtyJzIsY11cbiAgICAgIFszIDEgMSAyXSBbcjMsY10gW3InMyxjXVxuXG4gICAgICByMCwgcjEsIHIyLCBhbmQgcjMgYXJlIGVhY2ggMSBieXRlIG9mIG9uZSBvZiB0aGUgd29yZHMgaW4gdGhlXG4gICAgICBzdGF0ZSAoYSBjb2x1bW4pLiBUbyBkbyBtYXRyaXggbXVsdGlwbGljYXRpb24gZm9yIGVhY2ggbWl4ZWRcbiAgICAgIGNvbHVtbiBjJyB3ZSBtdWx0aXBseSB0aGUgY29ycmVzcG9uZGluZyByb3cgZnJvbSB0aGUgbGVmdCBtYXRyaXhcbiAgICAgIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgY29sdW1uIGZyb20gdGhlIHJpZ2h0IG1hdHJpeC4gSW4gdG90YWwsIHdlXG4gICAgICBnZXQgNCBlcXVhdGlvbnM6XG5cbiAgICAgIHIwLGMnID0gMipyMCxjICsgMypyMSxjICsgMSpyMixjICsgMSpyMyxjXG4gICAgICByMSxjJyA9IDEqcjAsYyArIDIqcjEsYyArIDMqcjIsYyArIDEqcjMsY1xuICAgICAgcjIsYycgPSAxKnIwLGMgKyAxKnIxLGMgKyAyKnIyLGMgKyAzKnIzLGNcbiAgICAgIHIzLGMnID0gMypyMCxjICsgMSpyMSxjICsgMSpyMixjICsgMipyMyxjXG5cbiAgICAgIEFzIHVzdWFsLCB0aGUgbXVsdGlwbGljYXRpb24gaXMgYXMgcHJldmlvdXNseSBkZWZpbmVkIGFuZCB0aGVcbiAgICAgIGFkZGl0aW9uIGlzIFhPUi4gSW4gb3JkZXIgdG8gb3B0aW1pemUgbWl4aW5nIGNvbHVtbnMgd2UgY2FuIHN0b3JlXG4gICAgICB0aGUgbXVsdGlwbGljYXRpb24gcmVzdWx0cyBpbiB0YWJsZXMuIElmIHlvdSB0aGluayBvZiB0aGUgd2hvbGVcbiAgICAgIGNvbHVtbiBhcyBhIHdvcmQgKGl0IG1pZ2h0IGhlbHAgdG8gdmlzdWFsaXplIGJ5IG1lbnRhbGx5IHJvdGF0aW5nXG4gICAgICB0aGUgZXF1YXRpb25zIGFib3ZlIGJ5IGNvdW50ZXJjbG9ja3dpc2UgOTAgZGVncmVlcykgdGhlbiB5b3UgY2FuXG4gICAgICBzZWUgdGhhdCBpdCB3b3VsZCBiZSB1c2VmdWwgdG8gbWFwIHRoZSBtdWx0aXBsaWNhdGlvbnMgcGVyZm9ybWVkIG9uXG4gICAgICBlYWNoIGJ5dGUgKHIwLCByMSwgcjIsIHIzKSBvbnRvIGEgd29yZCBhcyB3ZWxsLiBGb3IgaW5zdGFuY2UsIHdlXG4gICAgICBjb3VsZCBtYXAgMipyMCwxKnIwLDEqcjAsMypyMCBvbnRvIGEgd29yZCBieSBzdG9yaW5nIDIqcjAgaW4gdGhlXG4gICAgICBoaWdoZXN0IDggYml0cyBhbmQgMypyMCBpbiB0aGUgbG93ZXN0IDggYml0cyAod2l0aCB0aGUgb3RoZXIgdHdvXG4gICAgICByZXNwZWN0aXZlbHkgaW4gdGhlIG1pZGRsZSkuIFRoaXMgbWVhbnMgdGhhdCBhIHRhYmxlIGNhbiBiZVxuICAgICAgY29uc3RydWN0ZWQgdGhhdCB1c2VzIHIwIGFzIGFuIGluZGV4IHRvIHRoZSB3b3JkLiBXZSBjYW4gZG8gdGhlXG4gICAgICBzYW1lIHdpdGggcjEsIHIyLCBhbmQgcjMsIGNyZWF0aW5nIGEgdG90YWwgb2YgNCB0YWJsZXMuXG5cbiAgICAgIFRvIGNvbnN0cnVjdCBhIGZ1bGwgYycsIHdlIGNhbiBqdXN0IGxvb2sgdXAgZWFjaCBieXRlIG9mIGMgaW5cbiAgICAgIHRoZWlyIHJlc3BlY3RpdmUgdGFibGVzIGFuZCBYT1IgdGhlIHJlc3VsdHMgdG9nZXRoZXIuXG5cbiAgICAgIEFsc28sIHRvIGJ1aWxkIGVhY2ggdGFibGUgd2Ugb25seSBoYXZlIHRvIGNhbGN1bGF0ZSB0aGUgd29yZFxuICAgICAgZm9yIDIsMSwxLDMgZm9yIGV2ZXJ5IGJ5dGUgLi4uIHdoaWNoIHdlIGNhbiBkbyBvbiBlYWNoIGl0ZXJhdGlvblxuICAgICAgb2YgdGhpcyBsb29wIHNpbmNlIHdlIHdpbGwgaXRlcmF0ZSBvdmVyIGV2ZXJ5IGJ5dGUuIEFmdGVyIHdlIGhhdmVcbiAgICAgIGNhbGN1bGF0ZWQgMiwxLDEsMyB3ZSBjYW4gZ2V0IHRoZSByZXN1bHRzIGZvciB0aGUgb3RoZXIgdGFibGVzXG4gICAgICBieSBjeWNsaW5nIHRoZSBieXRlIGF0IHRoZSBlbmQgdG8gdGhlIGJlZ2lubmluZy4gRm9yIGluc3RhbmNlXG4gICAgICB3ZSBjYW4gdGFrZSB0aGUgcmVzdWx0IG9mIHRhYmxlIDIsMSwxLDMgYW5kIHByb2R1Y2UgdGFibGUgMywyLDEsMVxuICAgICAgYnkgbW92aW5nIHRoZSByaWdodCBtb3N0IGJ5dGUgdG8gdGhlIGxlZnQgbW9zdCBwb3NpdGlvbiBqdXN0IGxpa2VcbiAgICAgIGhvdyB5b3UgY2FuIGltYWdpbmUgdGhlIDMgbW92ZWQgb3V0IG9mIDIsMSwxLDMgYW5kIHRvIHRoZSBmcm9udFxuICAgICAgdG8gcHJvZHVjZSAzLDIsMSwxLlxuXG4gICAgICBUaGVyZSBpcyBhbm90aGVyIG9wdGltaXphdGlvbiBpbiB0aGF0IHRoZSBzYW1lIG11bHRpcGxlcyBvZlxuICAgICAgdGhlIGN1cnJlbnQgZWxlbWVudCB3ZSBuZWVkIGluIG9yZGVyIHRvIGFkdmFuY2Ugb3VyIGdlbmVyYXRvclxuICAgICAgdG8gdGhlIG5leHQgaXRlcmF0aW9uIGNhbiBiZSByZXVzZWQgaW4gcGVyZm9ybWluZyB0aGUgMiwxLDEsM1xuICAgICAgY2FsY3VsYXRpb24uIFdlIGFsc28gY2FsY3VsYXRlIHRoZSBpbnZlcnNlIG1peCBjb2x1bW4gdGFibGVzLFxuICAgICAgd2l0aCBlLDksZCxiIGJlaW5nIHRoZSBpbnZlcnNlIG9mIDIsMSwxLDMuXG5cbiAgICAgIFdoZW4gd2UncmUgZG9uZSwgYW5kIHdlIG5lZWQgdG8gYWN0dWFsbHkgbWl4IGNvbHVtbnMsIHRoZSBmaXJzdFxuICAgICAgYnl0ZSBvZiBlYWNoIHN0YXRlIHdvcmQgc2hvdWxkIGJlIHB1dCB0aHJvdWdoIG1peFswXSAoMiwxLDEsMyksXG4gICAgICB0aGUgc2Vjb25kIHRocm91Z2ggbWl4WzFdICgzLDIsMSwxKSBhbmQgc28gZm9ydGguIFRoZW4gdGhleSBzaG91bGRcbiAgICAgIGJlIFhPUidkIHRvZ2V0aGVyIHRvIHByb2R1Y2UgdGhlIGZ1bGx5IG1peGVkIGNvbHVtbi5cbiAgICAqL1xuXG4gICAgLy8gY2FsY3VsYXRlIG1peCBhbmQgaW1peCB0YWJsZSB2YWx1ZXNcbiAgICBzeDIgPSB4dGltZVtzeF07XG4gICAgZTIgPSB4dGltZVtlXTtcbiAgICBlNCA9IHh0aW1lW2UyXTtcbiAgICBlOCA9IHh0aW1lW2U0XTtcbiAgICBtZSA9XG4gICAgICAoc3gyIDw8IDI0KSBeICAvLyAyXG4gICAgICAoc3ggPDwgMTYpIF4gICAvLyAxXG4gICAgICAoc3ggPDwgOCkgXiAgICAvLyAxXG4gICAgICAoc3ggXiBzeDIpOyAgICAvLyAzXG4gICAgaW1lID1cbiAgICAgIChlMiBeIGU0IF4gZTgpIDw8IDI0IF4gIC8vIEUgKDE0KVxuICAgICAgKGUgXiBlOCkgPDwgMTYgXiAgICAgICAgLy8gOVxuICAgICAgKGUgXiBlNCBeIGU4KSA8PCA4IF4gICAgLy8gRCAoMTMpXG4gICAgICAoZSBeIGUyIF4gZTgpOyAgICAgICAgICAvLyBCICgxMSlcbiAgICAvLyBwcm9kdWNlIGVhY2ggb2YgdGhlIG1peCB0YWJsZXMgYnkgcm90YXRpbmcgdGhlIDIsMSwxLDMgdmFsdWVcbiAgICBmb3IodmFyIG4gPSAwOyBuIDwgNDsgKytuKSB7XG4gICAgICBtaXhbbl1bZV0gPSBtZTtcbiAgICAgIGltaXhbbl1bc3hdID0gaW1lO1xuICAgICAgLy8gY3ljbGUgdGhlIHJpZ2h0IG1vc3QgYnl0ZSB0byB0aGUgbGVmdCBtb3N0IHBvc2l0aW9uXG4gICAgICAvLyBpZTogMiwxLDEsMyBiZWNvbWVzIDMsMiwxLDFcbiAgICAgIG1lID0gbWUgPDwgMjQgfCBtZSA+Pj4gODtcbiAgICAgIGltZSA9IGltZSA8PCAyNCB8IGltZSA+Pj4gODtcbiAgICB9XG5cbiAgICAvLyBnZXQgbmV4dCBlbGVtZW50IGFuZCBpbnZlcnNlXG4gICAgaWYoZSA9PT0gMCkge1xuICAgICAgLy8gMSBpcyB0aGUgaW52ZXJzZSBvZiAxXG4gICAgICBlID0gZWkgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlID0gMmUgKyAyKjIqMiooMTBlKSkgPSBtdWx0aXBseSBlIGJ5IDgyIChjaG9zZW4gZ2VuZXJhdG9yKVxuICAgICAgLy8gZWkgPSBlaSArIDIqMiplaSA9IG11bHRpcGx5IGVpIGJ5IDUgKGludmVyc2UgZ2VuZXJhdG9yKVxuICAgICAgZSA9IGUyIF4geHRpbWVbeHRpbWVbeHRpbWVbZTIgXiBlOF1dXTtcbiAgICAgIGVpIF49IHh0aW1lW3h0aW1lW2VpXV07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEga2V5IHNjaGVkdWxlIHVzaW5nIHRoZSBBRVMga2V5IGV4cGFuc2lvbiBhbGdvcml0aG0uXG4gKlxuICogVGhlIEFFUyBhbGdvcml0aG0gdGFrZXMgdGhlIENpcGhlciBLZXksIEssIGFuZCBwZXJmb3JtcyBhIEtleSBFeHBhbnNpb25cbiAqIHJvdXRpbmUgdG8gZ2VuZXJhdGUgYSBrZXkgc2NoZWR1bGUuIFRoZSBLZXkgRXhwYW5zaW9uIGdlbmVyYXRlcyBhIHRvdGFsXG4gKiBvZiBOYiooTnIgKyAxKSB3b3JkczogdGhlIGFsZ29yaXRobSByZXF1aXJlcyBhbiBpbml0aWFsIHNldCBvZiBOYiB3b3JkcyxcbiAqIGFuZCBlYWNoIG9mIHRoZSBOciByb3VuZHMgcmVxdWlyZXMgTmIgd29yZHMgb2Yga2V5IGRhdGEuIFRoZSByZXN1bHRpbmdcbiAqIGtleSBzY2hlZHVsZSBjb25zaXN0cyBvZiBhIGxpbmVhciBhcnJheSBvZiA0LWJ5dGUgd29yZHMsIGRlbm90ZWQgW3dpIF0sXG4gKiB3aXRoIGkgaW4gdGhlIHJhbmdlIDAgPD0gaSA8IE5iKE5yICsgMSkuXG4gKlxuICogS2V5RXhwYW5zaW9uKGJ5dGUga2V5WzQqTmtdLCB3b3JkIHdbTmIqKE5yKzEpXSwgTmspXG4gKiBBRVMtMTI4IChOYj00LCBOaz00LCBOcj0xMClcbiAqIEFFUy0xOTIgKE5iPTQsIE5rPTYsIE5yPTEyKVxuICogQUVTLTI1NiAoTmI9NCwgTms9OCwgTnI9MTQpXG4gKiBOb3RlOiBOcj1Oays2LlxuICpcbiAqIE5iIGlzIHRoZSBudW1iZXIgb2YgY29sdW1ucyAoMzItYml0IHdvcmRzKSBjb21wcmlzaW5nIHRoZSBTdGF0ZSAob3JcbiAqIG51bWJlciBvZiBieXRlcyBpbiBhIGJsb2NrKS4gRm9yIEFFUywgTmI9NC5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gc2NoZWR1bGUgKGFzIGFuIGFycmF5IG9mIDMyLWJpdCB3b3JkcykuXG4gKiBAcGFyYW0gZGVjcnlwdCB0cnVlIHRvIG1vZGlmeSB0aGUga2V5IHNjaGVkdWxlIHRvIGRlY3J5cHQsIGZhbHNlIG5vdCB0by5cbiAqXG4gKiBAcmV0dXJuIHRoZSBnZW5lcmF0ZWQga2V5IHNjaGVkdWxlLlxuICovXG5mdW5jdGlvbiBfZXhwYW5kS2V5KGtleSwgZGVjcnlwdCkge1xuICAvLyBjb3B5IHRoZSBrZXkncyB3b3JkcyB0byBpbml0aWFsaXplIHRoZSBrZXkgc2NoZWR1bGVcbiAgdmFyIHcgPSBrZXkuc2xpY2UoMCk7XG5cbiAgLyogUm90V29yZCgpIHdpbGwgcm90YXRlIGEgd29yZCwgbW92aW5nIHRoZSBmaXJzdCBieXRlIHRvIHRoZSBsYXN0XG4gICAgYnl0ZSdzIHBvc2l0aW9uIChzaGlmdGluZyB0aGUgb3RoZXIgYnl0ZXMgbGVmdCkuXG5cbiAgICBXZSB3aWxsIGJlIGdldHRpbmcgdGhlIHZhbHVlIG9mIFJjb24gYXQgaSAvIE5rLiAnaScgd2lsbCBpdGVyYXRlXG4gICAgZnJvbSBOayB0byAoTmIgKiBOcisxKS4gTmsgPSA0ICg0IGJ5dGUga2V5KSwgTmIgPSA0ICg0IHdvcmRzIGluXG4gICAgYSBibG9jayksIE5yID0gTmsgKyA2ICgxMCkuIFRoZXJlZm9yZSAnaScgd2lsbCBpdGVyYXRlIGZyb21cbiAgICA0IHRvIDQ0IChleGNsdXNpdmUpLiBFYWNoIHRpbWUgd2UgaXRlcmF0ZSA0IHRpbWVzLCBpIC8gTmsgd2lsbFxuICAgIGluY3JlYXNlIGJ5IDEuIFdlIHVzZSBhIGNvdW50ZXIgaU5rIHRvIGtlZXAgdHJhY2sgb2YgdGhpcy5cbiAgICovXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgcm91bmRzIGV4cGFuZGluZyB0aGUga2V5XG4gIHZhciB0ZW1wLCBpTmsgPSAxO1xuICB2YXIgTmsgPSB3Lmxlbmd0aDtcbiAgdmFyIE5yMSA9IE5rICsgNiArIDE7XG4gIHZhciBlbmQgPSBOYiAqIE5yMTtcbiAgZm9yKHZhciBpID0gTms7IGkgPCBlbmQ7ICsraSkge1xuICAgIHRlbXAgPSB3W2kgLSAxXTtcbiAgICBpZihpICUgTmsgPT09IDApIHtcbiAgICAgIC8vIHRlbXAgPSBTdWJXb3JkKFJvdFdvcmQodGVtcCkpIF4gUmNvbltpIC8gTmtdXG4gICAgICB0ZW1wID1cbiAgICAgICAgc2JveFt0ZW1wID4+PiAxNiAmIDI1NV0gPDwgMjQgXlxuICAgICAgICBzYm94W3RlbXAgPj4+IDggJiAyNTVdIDw8IDE2IF5cbiAgICAgICAgc2JveFt0ZW1wICYgMjU1XSA8PCA4IF5cbiAgICAgICAgc2JveFt0ZW1wID4+PiAyNF0gXiAocmNvbltpTmtdIDw8IDI0KTtcbiAgICAgIGlOaysrO1xuICAgIH0gZWxzZSBpZihOayA+IDYgJiYgKGkgJSBOayA9PT0gNCkpIHtcbiAgICAgIC8vIHRlbXAgPSBTdWJXb3JkKHRlbXApXG4gICAgICB0ZW1wID1cbiAgICAgICAgc2JveFt0ZW1wID4+PiAyNF0gPDwgMjQgXlxuICAgICAgICBzYm94W3RlbXAgPj4+IDE2ICYgMjU1XSA8PCAxNiBeXG4gICAgICAgIHNib3hbdGVtcCA+Pj4gOCAmIDI1NV0gPDwgOCBeXG4gICAgICAgIHNib3hbdGVtcCAmIDI1NV07XG4gICAgfVxuICAgIHdbaV0gPSB3W2kgLSBOa10gXiB0ZW1wO1xuICB9XG5cbiAgLyogV2hlbiB3ZSBhcmUgdXBkYXRpbmcgYSBjaXBoZXIgYmxvY2sgd2UgYWx3YXlzIHVzZSB0aGUgY29kZSBwYXRoIGZvclxuICAgICBlbmNyeXB0aW9uIHdoZXRoZXIgd2UgYXJlIGRlY3J5cHRpbmcgb3Igbm90ICh0byBzaG9ydGVuIGNvZGUgYW5kXG4gICAgIHNpbXBsaWZ5IHRoZSBnZW5lcmF0aW9uIG9mIGxvb2sgdXAgdGFibGVzKS4gSG93ZXZlciwgYmVjYXVzZSB0aGVyZVxuICAgICBhcmUgZGlmZmVyZW5jZXMgaW4gdGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtLCBvdGhlciB0aGFuIGp1c3Qgc3dhcHBpbmdcbiAgICAgaW4gZGlmZmVyZW50IGxvb2sgdXAgdGFibGVzLCB3ZSBtdXN0IHRyYW5zZm9ybSBvdXIga2V5IHNjaGVkdWxlIHRvXG4gICAgIGFjY291bnQgZm9yIHRoZXNlIGNoYW5nZXM6XG5cbiAgICAgMS4gVGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtIGdldHMgaXRzIGtleSByb3VuZHMgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICAgMi4gVGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtIGFkZHMgdGhlIHJvdW5kIGtleSBiZWZvcmUgbWl4aW5nIGNvbHVtbnNcbiAgICAgICBpbnN0ZWFkIG9mIGFmdGVyd2FyZHMuXG5cbiAgICAgV2UgZG9uJ3QgbmVlZCB0byBtb2RpZnkgb3VyIGtleSBzY2hlZHVsZSB0byBoYW5kbGUgdGhlIGZpcnN0IGNhc2UsXG4gICAgIHdlIGNhbiBqdXN0IHRyYXZlcnNlIHRoZSBrZXkgc2NoZWR1bGUgaW4gcmV2ZXJzZSBvcmRlciB3aGVuIGRlY3J5cHRpbmcuXG5cbiAgICAgVGhlIHNlY29uZCBjYXNlIHJlcXVpcmVzIGEgbGl0dGxlIHdvcmsuXG5cbiAgICAgVGhlIHRhYmxlcyB3ZSBidWlsdCBmb3IgcGVyZm9ybWluZyByb3VuZHMgd2lsbCB0YWtlIGFuIGlucHV0IGFuZCB0aGVuXG4gICAgIHBlcmZvcm0gU3ViQnl0ZXMoKSBhbmQgTWl4Q29sdW1ucygpIG9yLCBmb3IgdGhlIGRlY3J5cHQgdmVyc2lvbixcbiAgICAgSW52U3ViQnl0ZXMoKSBhbmQgSW52TWl4Q29sdW1ucygpLiBCdXQgdGhlIGRlY3J5cHQgYWxnb3JpdGhtIHJlcXVpcmVzXG4gICAgIHVzIHRvIEFkZFJvdW5kS2V5KCkgYmVmb3JlIEludk1peENvbHVtbnMoKS4gVGhpcyBtZWFucyB3ZSdsbCBuZWVkIHRvXG4gICAgIGFwcGx5IHNvbWUgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSByb3VuZCBrZXkgdG8gaW52ZXJzZS1taXggaXRzIGNvbHVtbnNcbiAgICAgc28gdGhleSdsbCBiZSBjb3JyZWN0IGZvciBtb3ZpbmcgQWRkUm91bmRLZXkoKSB0byBhZnRlciB0aGUgc3RhdGUgaGFzXG4gICAgIGhhZCBpdHMgY29sdW1ucyBpbnZlcnNlLW1peGVkLlxuXG4gICAgIFRvIGludmVyc2UtbWl4IHRoZSBjb2x1bW5zIG9mIHRoZSBzdGF0ZSB3aGVuIHdlJ3JlIGRlY3J5cHRpbmcgd2UgdXNlIGFcbiAgICAgbG9va3VwIHRhYmxlIHRoYXQgd2lsbCBhcHBseSBJbnZTdWJCeXRlcygpIGFuZCBJbnZNaXhDb2x1bW5zKCkgYXQgdGhlXG4gICAgIHNhbWUgdGltZS4gSG93ZXZlciwgdGhlIHJvdW5kIGtleSdzIGJ5dGVzIGFyZSBub3QgaW52ZXJzZS1zdWJzdGl0dXRlZFxuICAgICBpbiB0aGUgZGVjcnlwdGlvbiBhbGdvcml0aG0uIFRvIGdldCBhcm91bmQgdGhpcyBwcm9ibGVtLCB3ZSBjYW4gZmlyc3RcbiAgICAgc3Vic3RpdHV0ZSB0aGUgYnl0ZXMgaW4gdGhlIHJvdW5kIGtleSBzbyB0aGF0IHdoZW4gd2UgYXBwbHkgdGhlXG4gICAgIHRyYW5zZm9ybWF0aW9uIHZpYSB0aGUgSW52U3ViQnl0ZXMoKStJbnZNaXhDb2x1bW5zKCkgdGFibGUsIGl0IHdpbGxcbiAgICAgdW5kbyBvdXIgc3Vic3RpdHV0aW9uIGxlYXZpbmcgdXMgd2l0aCB0aGUgb3JpZ2luYWwgdmFsdWUgdGhhdCB3ZVxuICAgICB3YW50IC0tIGFuZCB0aGVuIGludmVyc2UtbWl4IHRoYXQgdmFsdWUuXG5cbiAgICAgVGhpcyBjaGFuZ2Ugd2lsbCBjb3JyZWN0bHkgYWx0ZXIgb3VyIGtleSBzY2hlZHVsZSBzbyB0aGF0IHdlIGNhbiBYT1JcbiAgICAgZWFjaCByb3VuZCBrZXkgd2l0aCBvdXIgYWxyZWFkeSB0cmFuc2Zvcm1lZCBkZWNyeXB0aW9uIHN0YXRlLiBUaGlzXG4gICAgIGFsbG93cyB1cyB0byB1c2UgdGhlIHNhbWUgY29kZSBwYXRoIGFzIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobS5cblxuICAgICBXZSBtYWtlIG9uZSBtb3JlIGNoYW5nZSB0byB0aGUgZGVjcnlwdGlvbiBrZXkuIFNpbmNlIHRoZSBkZWNyeXB0aW9uXG4gICAgIGFsZ29yaXRobSBydW5zIGluIHJldmVyc2UgZnJvbSB0aGUgZW5jcnlwdGlvbiBhbGdvcml0aG0sIHdlIHJldmVyc2VcbiAgICAgdGhlIG9yZGVyIG9mIHRoZSByb3VuZCBrZXlzIHRvIGF2b2lkIGhhdmluZyB0byBpdGVyYXRlIG92ZXIgdGhlIGtleVxuICAgICBzY2hlZHVsZSBiYWNrd2FyZHMgd2hlbiBydW5uaW5nIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSBsYXRlciBpblxuICAgICBkZWNyeXB0aW9uIG1vZGUuIEluIGFkZGl0aW9uIHRvIHJldmVyc2luZyB0aGUgb3JkZXIgb2YgdGhlIHJvdW5kIGtleXMsXG4gICAgIHdlIGFsc28gc3dhcCBlYWNoIHJvdW5kIGtleSdzIDJuZCBhbmQgNHRoIHJvd3MuIFNlZSB0aGUgY29tbWVudHNcbiAgICAgc2VjdGlvbiB3aGVyZSByb3VuZHMgYXJlIHBlcmZvcm1lZCBmb3IgbW9yZSBkZXRhaWxzIGFib3V0IHdoeSB0aGlzIGlzXG4gICAgIGRvbmUuIFRoZXNlIGNoYW5nZXMgYXJlIGRvbmUgaW5saW5lIHdpdGggdGhlIG90aGVyIHN1YnN0aXR1dGlvblxuICAgICBkZXNjcmliZWQgYWJvdmUuXG4gICovXG4gIGlmKGRlY3J5cHQpIHtcbiAgICB2YXIgdG1wO1xuICAgIHZhciBtMCA9IGltaXhbMF07XG4gICAgdmFyIG0xID0gaW1peFsxXTtcbiAgICB2YXIgbTIgPSBpbWl4WzJdO1xuICAgIHZhciBtMyA9IGltaXhbM107XG4gICAgdmFyIHduZXcgPSB3LnNsaWNlKDApO1xuICAgIGVuZCA9IHcubGVuZ3RoO1xuICAgIGZvcih2YXIgaSA9IDAsIHdpID0gZW5kIC0gTmI7IGkgPCBlbmQ7IGkgKz0gTmIsIHdpIC09IE5iKSB7XG4gICAgICAvLyBkbyBub3Qgc3ViIHRoZSBmaXJzdCBvciBsYXN0IHJvdW5kIGtleSAocm91bmQga2V5cyBhcmUgTmJcbiAgICAgIC8vIHdvcmRzKSBhcyBubyBjb2x1bW4gbWl4aW5nIGlzIHBlcmZvcm1lZCBiZWZvcmUgdGhleSBhcmUgYWRkZWQsXG4gICAgICAvLyBidXQgZG8gY2hhbmdlIHRoZSBrZXkgb3JkZXJcbiAgICAgIGlmKGkgPT09IDAgfHwgaSA9PT0gKGVuZCAtIE5iKSkge1xuICAgICAgICB3bmV3W2ldID0gd1t3aV07XG4gICAgICAgIHduZXdbaSArIDFdID0gd1t3aSArIDNdO1xuICAgICAgICB3bmV3W2kgKyAyXSA9IHdbd2kgKyAyXTtcbiAgICAgICAgd25ld1tpICsgM10gPSB3W3dpICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdWJzdGl0dXRlIGVhY2ggcm91bmQga2V5IGJ5dGUgYmVjYXVzZSB0aGUgaW52ZXJzZS1taXhcbiAgICAgICAgLy8gdGFibGUgd2lsbCBpbnZlcnNlLXN1YnN0aXR1dGUgaXQgKGVmZmVjdGl2ZWx5IGNhbmNlbCB0aGVcbiAgICAgICAgLy8gc3Vic3RpdHV0aW9uIGJlY2F1c2Ugcm91bmQga2V5IGJ5dGVzIGFyZW4ndCBzdWInZCBpblxuICAgICAgICAvLyBkZWNyeXB0aW9uIG1vZGUpIGFuZCBzd2FwIGluZGV4ZXMgMyBhbmQgMVxuICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgTmI7ICsrbikge1xuICAgICAgICAgIHRtcCA9IHdbd2kgKyBuXTtcbiAgICAgICAgICB3bmV3W2kgKyAoMyYtbildID1cbiAgICAgICAgICAgIG0wW3Nib3hbdG1wID4+PiAyNF1dIF5cbiAgICAgICAgICAgIG0xW3Nib3hbdG1wID4+PiAxNiAmIDI1NV1dIF5cbiAgICAgICAgICAgIG0yW3Nib3hbdG1wID4+PiA4ICYgMjU1XV0gXlxuICAgICAgICAgICAgbTNbc2JveFt0bXAgJiAyNTVdXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB3ID0gd25ldztcbiAgfVxuXG4gIHJldHVybiB3O1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBzaW5nbGUgYmxvY2sgKDE2IGJ5dGVzKSB1c2luZyBBRVMuIFRoZSB1cGRhdGUgd2lsbCBlaXRoZXJcbiAqIGVuY3J5cHQgb3IgZGVjcnlwdCB0aGUgYmxvY2suXG4gKlxuICogQHBhcmFtIHcgdGhlIGtleSBzY2hlZHVsZS5cbiAqIEBwYXJhbSBpbnB1dCB0aGUgaW5wdXQgYmxvY2sgKGFuIGFycmF5IG9mIDMyLWJpdCB3b3JkcykuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSB1cGRhdGVkIG91dHB1dCBibG9jay5cbiAqIEBwYXJhbSBkZWNyeXB0IHRydWUgdG8gZGVjcnlwdCB0aGUgYmxvY2ssIGZhbHNlIHRvIGVuY3J5cHQgaXQuXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGVCbG9jayh3LCBpbnB1dCwgb3V0cHV0LCBkZWNyeXB0KSB7XG4gIC8qXG4gIENpcGhlcihieXRlIGluWzQqTmJdLCBieXRlIG91dFs0Kk5iXSwgd29yZCB3W05iKihOcisxKV0pXG4gIGJlZ2luXG4gICAgYnl0ZSBzdGF0ZVs0LE5iXVxuICAgIHN0YXRlID0gaW5cbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1swLCBOYi0xXSlcbiAgICBmb3Igcm91bmQgPSAxIHN0ZXAgMSB0byBOci0xXG4gICAgICBTdWJCeXRlcyhzdGF0ZSlcbiAgICAgIFNoaWZ0Um93cyhzdGF0ZSlcbiAgICAgIE1peENvbHVtbnMoc3RhdGUpXG4gICAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tyb3VuZCpOYiwgKHJvdW5kKzEpKk5iLTFdKVxuICAgIGVuZCBmb3JcbiAgICBTdWJCeXRlcyhzdGF0ZSlcbiAgICBTaGlmdFJvd3Moc3RhdGUpXG4gICAgQWRkUm91bmRLZXkoc3RhdGUsIHdbTnIqTmIsIChOcisxKSpOYi0xXSlcbiAgICBvdXQgPSBzdGF0ZVxuICBlbmRcblxuICBJbnZDaXBoZXIoYnl0ZSBpbls0Kk5iXSwgYnl0ZSBvdXRbNCpOYl0sIHdvcmQgd1tOYiooTnIrMSldKVxuICBiZWdpblxuICAgIGJ5dGUgc3RhdGVbNCxOYl1cbiAgICBzdGF0ZSA9IGluXG4gICAgQWRkUm91bmRLZXkoc3RhdGUsIHdbTnIqTmIsIChOcisxKSpOYi0xXSlcbiAgICBmb3Igcm91bmQgPSBOci0xIHN0ZXAgLTEgZG93bnRvIDFcbiAgICAgIEludlNoaWZ0Um93cyhzdGF0ZSlcbiAgICAgIEludlN1YkJ5dGVzKHN0YXRlKVxuICAgICAgQWRkUm91bmRLZXkoc3RhdGUsIHdbcm91bmQqTmIsIChyb3VuZCsxKSpOYi0xXSlcbiAgICAgIEludk1peENvbHVtbnMoc3RhdGUpXG4gICAgZW5kIGZvclxuICAgIEludlNoaWZ0Um93cyhzdGF0ZSlcbiAgICBJbnZTdWJCeXRlcyhzdGF0ZSlcbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1swLCBOYi0xXSlcbiAgICBvdXQgPSBzdGF0ZVxuICBlbmRcbiAgKi9cblxuICAvLyBFbmNyeXB0OiBBZGRSb3VuZEtleShzdGF0ZSwgd1swLCBOYi0xXSlcbiAgLy8gRGVjcnlwdDogQWRkUm91bmRLZXkoc3RhdGUsIHdbTnIqTmIsIChOcisxKSpOYi0xXSlcbiAgdmFyIE5yID0gdy5sZW5ndGggLyA0IC0gMTtcbiAgdmFyIG0wLCBtMSwgbTIsIG0zLCBzdWI7XG4gIGlmKGRlY3J5cHQpIHtcbiAgICBtMCA9IGltaXhbMF07XG4gICAgbTEgPSBpbWl4WzFdO1xuICAgIG0yID0gaW1peFsyXTtcbiAgICBtMyA9IGltaXhbM107XG4gICAgc3ViID0gaXNib3g7XG4gIH0gZWxzZSB7XG4gICAgbTAgPSBtaXhbMF07XG4gICAgbTEgPSBtaXhbMV07XG4gICAgbTIgPSBtaXhbMl07XG4gICAgbTMgPSBtaXhbM107XG4gICAgc3ViID0gc2JveDtcbiAgfVxuICB2YXIgYSwgYiwgYywgZCwgYTIsIGIyLCBjMjtcbiAgYSA9IGlucHV0WzBdIF4gd1swXTtcbiAgYiA9IGlucHV0W2RlY3J5cHQgPyAzIDogMV0gXiB3WzFdO1xuICBjID0gaW5wdXRbMl0gXiB3WzJdO1xuICBkID0gaW5wdXRbZGVjcnlwdCA/IDEgOiAzXSBeIHdbM107XG4gIHZhciBpID0gMztcblxuICAvKiBJbiBvcmRlciB0byBzaGFyZSBjb2RlIHdlIGZvbGxvdyB0aGUgZW5jcnlwdGlvbiBhbGdvcml0aG0gd2hlbiBib3RoXG4gICAgZW5jcnlwdGluZyBhbmQgZGVjcnlwdGluZy4gVG8gYWNjb3VudCBmb3IgdGhlIGNoYW5nZXMgcmVxdWlyZWQgaW4gdGhlXG4gICAgZGVjcnlwdGlvbiBhbGdvcml0aG0sIHdlIHVzZSBkaWZmZXJlbnQgbG9va3VwIHRhYmxlcyB3aGVuIGRlY3J5cHRpbmdcbiAgICBhbmQgdXNlIGEgbW9kaWZpZWQga2V5IHNjaGVkdWxlIHRvIGFjY291bnQgZm9yIHRoZSBkaWZmZXJlbmNlIGluIHRoZVxuICAgIG9yZGVyIG9mIHRyYW5zZm9ybWF0aW9ucyBhcHBsaWVkIHdoZW4gcGVyZm9ybWluZyByb3VuZHMuIFdlIGFsc28gZ2V0XG4gICAga2V5IHJvdW5kcyBpbiByZXZlcnNlIG9yZGVyIChyZWxhdGl2ZSB0byBlbmNyeXB0aW9uKS4gKi9cbiAgZm9yKHZhciByb3VuZCA9IDE7IHJvdW5kIDwgTnI7ICsrcm91bmQpIHtcbiAgICAvKiBBcyBkZXNjcmliZWQgYWJvdmUsIHdlJ2xsIGJlIHVzaW5nIHRhYmxlIGxvb2t1cHMgdG8gcGVyZm9ybSB0aGVcbiAgICAgIGNvbHVtbiBtaXhpbmcuIEVhY2ggY29sdW1uIGlzIHN0b3JlZCBhcyBhIHdvcmQgaW4gdGhlIHN0YXRlICh0aGVcbiAgICAgIGFycmF5ICdpbnB1dCcgaGFzIG9uZSBjb2x1bW4gYXMgYSB3b3JkIGF0IGVhY2ggaW5kZXgpLiBJbiBvcmRlciB0b1xuICAgICAgbWl4IGEgY29sdW1uLCB3ZSBwZXJmb3JtIHRoZXNlIHRyYW5zZm9ybWF0aW9ucyBvbiBlYWNoIHJvdyBpbiBjLFxuICAgICAgd2hpY2ggaXMgMSBieXRlIGluIGVhY2ggd29yZC4gVGhlIG5ldyBjb2x1bW4gZm9yIGMwIGlzIGMnMDpcblxuICAgICAgICAgICAgICAgbTAgICAgICBtMSAgICAgIG0yICAgICAgbTNcbiAgICAgIHIwLGMnMCA9IDIqcjAsYzAgKyAzKnIxLGMwICsgMSpyMixjMCArIDEqcjMsYzBcbiAgICAgIHIxLGMnMCA9IDEqcjAsYzAgKyAyKnIxLGMwICsgMypyMixjMCArIDEqcjMsYzBcbiAgICAgIHIyLGMnMCA9IDEqcjAsYzAgKyAxKnIxLGMwICsgMipyMixjMCArIDMqcjMsYzBcbiAgICAgIHIzLGMnMCA9IDMqcjAsYzAgKyAxKnIxLGMwICsgMSpyMixjMCArIDIqcjMsYzBcblxuICAgICAgU28gdXNpbmcgbWl4IHRhYmxlcyB3aGVyZSBjMCBpcyBhIHdvcmQgd2l0aCByMCBiZWluZyBpdHMgdXBwZXJcbiAgICAgIDggYml0cyBhbmQgcjMgYmVpbmcgaXRzIGxvd2VyIDggYml0czpcblxuICAgICAgbTBbYzAgPj4gMjRdIHdpbGwgeWllbGQgdGhpcyB3b3JkOiBbMipyMCwxKnIwLDEqcjAsMypyMF1cbiAgICAgIC4uLlxuICAgICAgbTNbYzAgJiAyNTVdIHdpbGwgeWllbGQgdGhpcyB3b3JkOiBbMSpyMywxKnIzLDMqcjMsMipyM11cblxuICAgICAgVGhlcmVmb3JlIHRvIG1peCB0aGUgY29sdW1ucyBpbiBlYWNoIHdvcmQgaW4gdGhlIHN0YXRlIHdlXG4gICAgICBkbyB0aGUgZm9sbG93aW5nICgmIDI1NSBvbWl0dGVkIGZvciBicmV2aXR5KTpcbiAgICAgIGMnMCxyMCA9IG0wW2MwID4+IDI0XSBeIG0xW2MxID4+IDE2XSBeIG0yW2MyID4+IDhdIF4gbTNbYzNdXG4gICAgICBjJzAscjEgPSBtMFtjMCA+PiAyNF0gXiBtMVtjMSA+PiAxNl0gXiBtMltjMiA+PiA4XSBeIG0zW2MzXVxuICAgICAgYycwLHIyID0gbTBbYzAgPj4gMjRdIF4gbTFbYzEgPj4gMTZdIF4gbTJbYzIgPj4gOF0gXiBtM1tjM11cbiAgICAgIGMnMCxyMyA9IG0wW2MwID4+IDI0XSBeIG0xW2MxID4+IDE2XSBeIG0yW2MyID4+IDhdIF4gbTNbYzNdXG5cbiAgICAgIEhvd2V2ZXIsIGJlZm9yZSBtaXhpbmcsIHRoZSBhbGdvcml0aG0gcmVxdWlyZXMgdXMgdG8gcGVyZm9ybVxuICAgICAgU2hpZnRSb3dzKCkuIFRoZSBTaGlmdFJvd3MoKSB0cmFuc2Zvcm1hdGlvbiBjeWNsaWNhbGx5IHNoaWZ0cyB0aGVcbiAgICAgIGxhc3QgMyByb3dzIG9mIHRoZSBzdGF0ZSBvdmVyIGRpZmZlcmVudCBvZmZzZXRzLiBUaGUgZmlyc3Qgcm93XG4gICAgICAociA9IDApIGlzIG5vdCBzaGlmdGVkLlxuXG4gICAgICBzJ19yLGMgPSBzX3IsKGMgKyBzaGlmdChyLCBOYikgbW9kIE5iXG4gICAgICBmb3IgMCA8IHIgPCA0IGFuZCAwIDw9IGMgPCBOYiBhbmRcbiAgICAgIHNoaWZ0KDEsIDQpID0gMVxuICAgICAgc2hpZnQoMiwgNCkgPSAyXG4gICAgICBzaGlmdCgzLCA0KSA9IDMuXG5cbiAgICAgIFRoaXMgY2F1c2VzIHRoZSBmaXJzdCBieXRlIGluIHIgPSAxIHRvIGJlIG1vdmVkIHRvIHRoZSBlbmQgb2ZcbiAgICAgIHRoZSByb3csIHRoZSBmaXJzdCAyIGJ5dGVzIGluIHIgPSAyIHRvIGJlIG1vdmVkIHRvIHRoZSBlbmQgb2ZcbiAgICAgIHRoZSByb3csIHRoZSBmaXJzdCAzIGJ5dGVzIGluIHIgPSAzIHRvIGJlIG1vdmVkIHRvIHRoZSBlbmQgb2ZcbiAgICAgIHRoZSByb3c6XG5cbiAgICAgIHIxOiBbYzAgYzEgYzIgYzNdID0+IFtjMSBjMiBjMyBjMF1cbiAgICAgIHIyOiBbYzAgYzEgYzIgYzNdICAgIFtjMiBjMyBjMCBjMV1cbiAgICAgIHIzOiBbYzAgYzEgYzIgYzNdICAgIFtjMyBjMCBjMSBjMl1cblxuICAgICAgV2UgY2FuIG1ha2UgdGhlc2Ugc3Vic3RpdHV0aW9ucyBpbmxpbmUgd2l0aCBvdXIgY29sdW1uIG1peGluZyB0b1xuICAgICAgZ2VuZXJhdGUgYW4gdXBkYXRlZCBzZXQgb2YgZXF1YXRpb25zIHRvIHByb2R1Y2UgZWFjaCB3b3JkIGluIHRoZVxuICAgICAgc3RhdGUgKG5vdGUgdGhlIGNvbHVtbnMgaGF2ZSBjaGFuZ2VkIHBvc2l0aW9ucyk6XG5cbiAgICAgIGMwIGMxIGMyIGMzID0+IGMwIGMxIGMyIGMzXG4gICAgICBjMCBjMSBjMiBjMyAgICBjMSBjMiBjMyBjMCAgKGN5Y2xlZCAxIGJ5dGUpXG4gICAgICBjMCBjMSBjMiBjMyAgICBjMiBjMyBjMCBjMSAgKGN5Y2xlZCAyIGJ5dGVzKVxuICAgICAgYzAgYzEgYzIgYzMgICAgYzMgYzAgYzEgYzIgIChjeWNsZWQgMyBieXRlcylcblxuICAgICAgVGhlcmVmb3JlOlxuXG4gICAgICBjJzAgPSAyKnIwLGMwICsgMypyMSxjMSArIDEqcjIsYzIgKyAxKnIzLGMzXG4gICAgICBjJzAgPSAxKnIwLGMwICsgMipyMSxjMSArIDMqcjIsYzIgKyAxKnIzLGMzXG4gICAgICBjJzAgPSAxKnIwLGMwICsgMSpyMSxjMSArIDIqcjIsYzIgKyAzKnIzLGMzXG4gICAgICBjJzAgPSAzKnIwLGMwICsgMSpyMSxjMSArIDEqcjIsYzIgKyAyKnIzLGMzXG5cbiAgICAgIGMnMSA9IDIqcjAsYzEgKyAzKnIxLGMyICsgMSpyMixjMyArIDEqcjMsYzBcbiAgICAgIGMnMSA9IDEqcjAsYzEgKyAyKnIxLGMyICsgMypyMixjMyArIDEqcjMsYzBcbiAgICAgIGMnMSA9IDEqcjAsYzEgKyAxKnIxLGMyICsgMipyMixjMyArIDMqcjMsYzBcbiAgICAgIGMnMSA9IDMqcjAsYzEgKyAxKnIxLGMyICsgMSpyMixjMyArIDIqcjMsYzBcblxuICAgICAgLi4uIGFuZCBzbyBmb3J0aCBmb3IgYycyIGFuZCBjJzMuIFRoZSBpbXBvcnRhbnQgZGlzdGluY3Rpb24gaXNcbiAgICAgIHRoYXQgdGhlIGNvbHVtbnMgYXJlIGN5Y2xpbmcsIHdpdGggYzAgYmVpbmcgdXNlZCB3aXRoIHRoZSBtMFxuICAgICAgbWFwIHdoZW4gY2FsY3VsYXRpbmcgYzAsIGJ1dCBjMSBiZWluZyB1c2VkIHdpdGggdGhlIG0wIG1hcCB3aGVuXG4gICAgICBjYWxjdWxhdGluZyBjMSAuLi4gYW5kIHNvIGZvcnRoLlxuXG4gICAgICBXaGVuIHBlcmZvcm1pbmcgdGhlIGludmVyc2Ugd2UgdHJhbnNmb3JtIHRoZSBtaXJyb3IgaW1hZ2UgYW5kXG4gICAgICBza2lwIHRoZSBib3R0b20gcm93LCBpbnN0ZWFkIG9mIHRoZSB0b3Agb25lLCBhbmQgbW92ZSB1cHdhcmRzOlxuXG4gICAgICBjMyBjMiBjMSBjMCA9PiBjMCBjMyBjMiBjMSAgKGN5Y2xlZCAzIGJ5dGVzKSAqc2FtZSBhcyBlbmNyeXB0aW9uXG4gICAgICBjMyBjMiBjMSBjMCAgICBjMSBjMCBjMyBjMiAgKGN5Y2xlZCAyIGJ5dGVzKVxuICAgICAgYzMgYzIgYzEgYzAgICAgYzIgYzEgYzAgYzMgIChjeWNsZWQgMSBieXRlKSAgKnNhbWUgYXMgZW5jcnlwdGlvblxuICAgICAgYzMgYzIgYzEgYzAgICAgYzMgYzIgYzEgYzBcblxuICAgICAgSWYgeW91IGNvbXBhcmUgdGhlIHJlc3VsdGluZyBtYXRyaWNlcyBmb3IgU2hpZnRSb3dzKCkrTWl4Q29sdW1ucygpXG4gICAgICBhbmQgZm9yIEludlNoaWZ0Um93cygpK0ludk1peENvbHVtbnMoKSB0aGUgMm5kIGFuZCA0dGggY29sdW1ucyBhcmVcbiAgICAgIGRpZmZlcmVudCAoaW4gZW5jcnlwdCBtb2RlIHZzLiBkZWNyeXB0IG1vZGUpLiBTbyBpbiBvcmRlciB0byB1c2VcbiAgICAgIHRoZSBzYW1lIGNvZGUgdG8gaGFuZGxlIGJvdGggZW5jcnlwdGlvbiBhbmQgZGVjcnlwdGlvbiwgd2Ugd2lsbFxuICAgICAgbmVlZCB0byBkbyBzb21lIG1hcHBpbmcuXG5cbiAgICAgIElmIGluIGVuY3J5cHRpb24gbW9kZSB3ZSBsZXQgYT1jMCwgYj1jMSwgYz1jMiwgZD1jMywgYW5kIHI8Tj4gYmVcbiAgICAgIGEgcm93IG51bWJlciBpbiB0aGUgc3RhdGUsIHRoZW4gdGhlIHJlc3VsdGluZyBtYXRyaXggaW4gZW5jcnlwdGlvblxuICAgICAgbW9kZSBmb3IgYXBwbHlpbmcgdGhlIGFib3ZlIHRyYW5zZm9ybWF0aW9ucyB3b3VsZCBiZTpcblxuICAgICAgcjE6IGEgYiBjIGRcbiAgICAgIHIyOiBiIGMgZCBhXG4gICAgICByMzogYyBkIGEgYlxuICAgICAgcjQ6IGQgYSBiIGNcblxuICAgICAgSWYgd2UgZGlkIHRoZSBzYW1lIGluIGRlY3J5cHRpb24gbW9kZSB3ZSB3b3VsZCBnZXQ6XG5cbiAgICAgIHIxOiBhIGQgYyBiXG4gICAgICByMjogYiBhIGQgY1xuICAgICAgcjM6IGMgYiBhIGRcbiAgICAgIHI0OiBkIGMgYiBhXG5cbiAgICAgIElmIGluc3RlYWQgd2Ugc3dhcCBkIGFuZCBiIChzZXQgYj1jMyBhbmQgZD1jMSksIHRoZW4gd2UgZ2V0OlxuXG4gICAgICByMTogYSBiIGMgZFxuICAgICAgcjI6IGQgYSBiIGNcbiAgICAgIHIzOiBjIGQgYSBiXG4gICAgICByNDogYiBjIGQgYVxuXG4gICAgICBOb3cgdGhlIDFzdCBhbmQgM3JkIHJvd3MgYXJlIHRoZSBzYW1lIGFzIHRoZSBlbmNyeXB0aW9uIG1hdHJpeC4gQWxsXG4gICAgICB3ZSBuZWVkIHRvIGRvIHRoZW4gdG8gbWFrZSB0aGUgbWFwcGluZyBleGFjdGx5IHRoZSBzYW1lIGlzIHRvIHN3YXBcbiAgICAgIHRoZSAybmQgYW5kIDR0aCByb3dzIHdoZW4gaW4gZGVjcnlwdGlvbiBtb2RlLiBUbyBkbyB0aGlzIHdpdGhvdXRcbiAgICAgIGhhdmluZyB0byBkbyBpdCBvbiBlYWNoIGl0ZXJhdGlvbiwgd2Ugc3dhcHBlZCB0aGUgMm5kIGFuZCA0dGggcm93c1xuICAgICAgaW4gdGhlIGRlY3J5cHRpb24ga2V5IHNjaGVkdWxlLiBXZSBhbHNvIGhhdmUgdG8gZG8gdGhlIHN3YXAgYWJvdmVcbiAgICAgIHdoZW4gd2UgZmlyc3QgcHVsbCBpbiB0aGUgaW5wdXQgYW5kIHdoZW4gd2Ugc2V0IHRoZSBmaW5hbCBvdXRwdXQuICovXG4gICAgYTIgPVxuICAgICAgbTBbYSA+Pj4gMjRdIF5cbiAgICAgIG0xW2IgPj4+IDE2ICYgMjU1XSBeXG4gICAgICBtMltjID4+PiA4ICYgMjU1XSBeXG4gICAgICBtM1tkICYgMjU1XSBeIHdbKytpXTtcbiAgICBiMiA9XG4gICAgICBtMFtiID4+PiAyNF0gXlxuICAgICAgbTFbYyA+Pj4gMTYgJiAyNTVdIF5cbiAgICAgIG0yW2QgPj4+IDggJiAyNTVdIF5cbiAgICAgIG0zW2EgJiAyNTVdIF4gd1srK2ldO1xuICAgIGMyID1cbiAgICAgIG0wW2MgPj4+IDI0XSBeXG4gICAgICBtMVtkID4+PiAxNiAmIDI1NV0gXlxuICAgICAgbTJbYSA+Pj4gOCAmIDI1NV0gXlxuICAgICAgbTNbYiAmIDI1NV0gXiB3WysraV07XG4gICAgZCA9XG4gICAgICBtMFtkID4+PiAyNF0gXlxuICAgICAgbTFbYSA+Pj4gMTYgJiAyNTVdIF5cbiAgICAgIG0yW2IgPj4+IDggJiAyNTVdIF5cbiAgICAgIG0zW2MgJiAyNTVdIF4gd1srK2ldO1xuICAgIGEgPSBhMjtcbiAgICBiID0gYjI7XG4gICAgYyA9IGMyO1xuICB9XG5cbiAgLypcbiAgICBFbmNyeXB0OlxuICAgIFN1YkJ5dGVzKHN0YXRlKVxuICAgIFNoaWZ0Um93cyhzdGF0ZSlcbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tOcipOYiwgKE5yKzEpKk5iLTFdKVxuXG4gICAgRGVjcnlwdDpcbiAgICBJbnZTaGlmdFJvd3Moc3RhdGUpXG4gICAgSW52U3ViQnl0ZXMoc3RhdGUpXG4gICAgQWRkUm91bmRLZXkoc3RhdGUsIHdbMCwgTmItMV0pXG4gICAqL1xuICAvLyBOb3RlOiByb3dzIGFyZSBzaGlmdGVkIGlubGluZVxuICBvdXRwdXRbMF0gPVxuICAgIChzdWJbYSA+Pj4gMjRdIDw8IDI0KSBeXG4gICAgKHN1YltiID4+PiAxNiAmIDI1NV0gPDwgMTYpIF5cbiAgICAoc3ViW2MgPj4+IDggJiAyNTVdIDw8IDgpIF5cbiAgICAoc3ViW2QgJiAyNTVdKSBeIHdbKytpXTtcbiAgb3V0cHV0W2RlY3J5cHQgPyAzIDogMV0gPVxuICAgIChzdWJbYiA+Pj4gMjRdIDw8IDI0KSBeXG4gICAgKHN1YltjID4+PiAxNiAmIDI1NV0gPDwgMTYpIF5cbiAgICAoc3ViW2QgPj4+IDggJiAyNTVdIDw8IDgpIF5cbiAgICAoc3ViW2EgJiAyNTVdKSBeIHdbKytpXTtcbiAgb3V0cHV0WzJdID1cbiAgICAoc3ViW2MgPj4+IDI0XSA8PCAyNCkgXlxuICAgIChzdWJbZCA+Pj4gMTYgJiAyNTVdIDw8IDE2KSBeXG4gICAgKHN1YlthID4+PiA4ICYgMjU1XSA8PCA4KSBeXG4gICAgKHN1YltiICYgMjU1XSkgXiB3WysraV07XG4gIG91dHB1dFtkZWNyeXB0ID8gMSA6IDNdID1cbiAgICAoc3ViW2QgPj4+IDI0XSA8PCAyNCkgXlxuICAgIChzdWJbYSA+Pj4gMTYgJiAyNTVdIDw8IDE2KSBeXG4gICAgKHN1YltiID4+PiA4ICYgMjU1XSA8PCA4KSBeXG4gICAgKHN1YltjICYgMjU1XSkgXiB3WysraV07XG59XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0FFUy08bW9kZT4nLCBrZXkpO1xuICogZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGEgZGVwcmVjYXRlZCBBRVMgY2lwaGVyIG9iamVjdC4gVGhpcyBvYmplY3QncyBtb2RlIHdpbGwgZGVmYXVsdCB0b1xuICogQ0JDIChjaXBoZXItYmxvY2stY2hhaW5pbmcpLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXkgb2YgYnl0ZXMsIGFcbiAqIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqICAgICAgICAgIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLlxuICogICAgICAgICAgZGVjcnlwdCB0cnVlIGZvciBkZWNyeXB0aW9uLCBmYWxzZSBmb3IgZW5jcnlwdGlvbi5cbiAqICAgICAgICAgIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZUNpcGhlcihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbW9kZSA9IChvcHRpb25zLm1vZGUgfHwgJ0NCQycpLnRvVXBwZXJDYXNlKCk7XG4gIHZhciBhbGdvcml0aG0gPSAnQUVTLScgKyBtb2RlO1xuXG4gIHZhciBjaXBoZXI7XG4gIGlmKG9wdGlvbnMuZGVjcnlwdCkge1xuICAgIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcihhbGdvcml0aG0sIG9wdGlvbnMua2V5KTtcbiAgfSBlbHNlIHtcbiAgICBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKGFsZ29yaXRobSwgb3B0aW9ucy5rZXkpO1xuICB9XG5cbiAgLy8gYmFja3dhcmRzIGNvbXBhdGlibGUgc3RhcnQgQVBJXG4gIHZhciBzdGFydCA9IGNpcGhlci5zdGFydDtcbiAgY2lwaGVyLnN0YXJ0ID0gZnVuY3Rpb24oaXYsIG9wdGlvbnMpIHtcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogc3VwcG9ydCBzZWNvbmQgYXJnIGFzIG91dHB1dCBidWZmZXJcbiAgICB2YXIgb3V0cHV0ID0gbnVsbDtcbiAgICBpZihvcHRpb25zIGluc3RhbmNlb2YgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKSB7XG4gICAgICBvdXRwdXQgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLm91dHB1dCA9IG91dHB1dDtcbiAgICBvcHRpb25zLml2ID0gaXY7XG4gICAgc3RhcnQuY2FsbChjaXBoZXIsIG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBjaXBoZXI7XG59XG4iXSwibmFtZXMiOlsiZm9yZ2UiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsImFlcyIsInN0YXJ0RW5jcnlwdGluZyIsImtleSIsIml2Iiwib3V0cHV0IiwibW9kZSIsImNpcGhlciIsIl9jcmVhdGVDaXBoZXIiLCJkZWNyeXB0Iiwic3RhcnQiLCJjcmVhdGVFbmNyeXB0aW9uQ2lwaGVyIiwic3RhcnREZWNyeXB0aW5nIiwiY3JlYXRlRGVjcnlwdGlvbkNpcGhlciIsIkFsZ29yaXRobSIsIm5hbWUiLCJpbml0IiwiaW5pdGlhbGl6ZSIsInNlbGYiLCJibG9ja1NpemUiLCJlbmNyeXB0IiwiaW5CbG9jayIsIm91dEJsb2NrIiwiX3VwZGF0ZUJsb2NrIiwiX3ciLCJfaW5pdCIsInByb3RvdHlwZSIsIm9wdGlvbnMiLCJ0bXAiLCJsZW5ndGgiLCJ1dGlsIiwiY3JlYXRlQnVmZmVyIiwiaXNBcnJheSIsImkiLCJwdXRCeXRlIiwibGVuIiwicHVzaCIsImdldEludDMyIiwiRXJyb3IiLCJlbmNyeXB0T3AiLCJpbmRleE9mIiwiX2V4cGFuZEtleSIsInJlZ2lzdGVyQWxnb3JpdGhtIiwibW9kZXMiLCJlY2IiLCJjYmMiLCJjZmIiLCJvZmIiLCJjdHIiLCJnY20iLCJmYWN0b3J5IiwiTmIiLCJzYm94IiwiaXNib3giLCJyY29uIiwibWl4IiwiaW1peCIsInh0aW1lIiwiQXJyYXkiLCJlIiwiZWkiLCJlMiIsImU0IiwiZTgiLCJzeCIsInN4MiIsIm1lIiwiaW1lIiwibiIsInciLCJzbGljZSIsInRlbXAiLCJpTmsiLCJOayIsIk5yMSIsImVuZCIsIm0wIiwibTEiLCJtMiIsIm0zIiwid25ldyIsIndpIiwiaW5wdXQiLCJOciIsInN1YiIsImEiLCJiIiwiYyIsImQiLCJhMiIsImIyIiwiYzIiLCJyb3VuZCIsInRvVXBwZXJDYXNlIiwiYWxnb3JpdGhtIiwiY3JlYXRlRGVjaXBoZXIiLCJjcmVhdGVDaXBoZXIiLCJCeXRlQnVmZmVyIiwiY2FsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/aes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/aesCipherSuites.js":
/*!********************************************************!*\
  !*** ./node_modules/node-forge/lib/aesCipherSuites.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * A Javascript implementation of AES Cipher Suites for TLS.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2009-2015 Digital Bazaar, Inc.\n *\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./aes */ \"(rsc)/./node_modules/node-forge/lib/aes.js\");\n__webpack_require__(/*! ./tls */ \"(rsc)/./node_modules/node-forge/lib/tls.js\");\nvar tls = module.exports = forge.tls;\n/**\n * Supported cipher suites.\n */ tls.CipherSuites[\"TLS_RSA_WITH_AES_128_CBC_SHA\"] = {\n    id: [\n        0x00,\n        0x2f\n    ],\n    name: \"TLS_RSA_WITH_AES_128_CBC_SHA\",\n    initSecurityParameters: function(sp) {\n        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;\n        sp.cipher_type = tls.CipherType.block;\n        sp.enc_key_length = 16;\n        sp.block_length = 16;\n        sp.fixed_iv_length = 16;\n        sp.record_iv_length = 16;\n        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;\n        sp.mac_length = 20;\n        sp.mac_key_length = 20;\n    },\n    initConnectionState: initConnectionState\n};\ntls.CipherSuites[\"TLS_RSA_WITH_AES_256_CBC_SHA\"] = {\n    id: [\n        0x00,\n        0x35\n    ],\n    name: \"TLS_RSA_WITH_AES_256_CBC_SHA\",\n    initSecurityParameters: function(sp) {\n        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;\n        sp.cipher_type = tls.CipherType.block;\n        sp.enc_key_length = 32;\n        sp.block_length = 16;\n        sp.fixed_iv_length = 16;\n        sp.record_iv_length = 16;\n        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;\n        sp.mac_length = 20;\n        sp.mac_key_length = 20;\n    },\n    initConnectionState: initConnectionState\n};\nfunction initConnectionState(state, c, sp) {\n    var client = c.entity === forge.tls.ConnectionEnd.client;\n    // cipher setup\n    state.read.cipherState = {\n        init: false,\n        cipher: forge.cipher.createDecipher(\"AES-CBC\", client ? sp.keys.server_write_key : sp.keys.client_write_key),\n        iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV\n    };\n    state.write.cipherState = {\n        init: false,\n        cipher: forge.cipher.createCipher(\"AES-CBC\", client ? sp.keys.client_write_key : sp.keys.server_write_key),\n        iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV\n    };\n    state.read.cipherFunction = decrypt_aes_cbc_sha1;\n    state.write.cipherFunction = encrypt_aes_cbc_sha1;\n    // MAC setup\n    state.read.macLength = state.write.macLength = sp.mac_length;\n    state.read.macFunction = state.write.macFunction = tls.hmac_sha1;\n}\n/**\n * Encrypts the TLSCompressed record into a TLSCipherText record using AES\n * in CBC mode.\n *\n * @param record the TLSCompressed record to encrypt.\n * @param s the ConnectionState to use.\n *\n * @return true on success, false on failure.\n */ function encrypt_aes_cbc_sha1(record, s) {\n    var rval = false;\n    // append MAC to fragment, update sequence number\n    var mac = s.macFunction(s.macKey, s.sequenceNumber, record);\n    record.fragment.putBytes(mac);\n    s.updateSequenceNumber();\n    // TLS 1.1+ use an explicit IV every time to protect against CBC attacks\n    var iv;\n    if (record.version.minor === tls.Versions.TLS_1_0.minor) {\n        // use the pre-generated IV when initializing for TLS 1.0, otherwise use\n        // the residue from the previous encryption\n        iv = s.cipherState.init ? null : s.cipherState.iv;\n    } else {\n        iv = forge.random.getBytesSync(16);\n    }\n    s.cipherState.init = true;\n    // start cipher\n    var cipher = s.cipherState.cipher;\n    cipher.start({\n        iv: iv\n    });\n    // TLS 1.1+ write IV into output\n    if (record.version.minor >= tls.Versions.TLS_1_1.minor) {\n        cipher.output.putBytes(iv);\n    }\n    // do encryption (default padding is appropriate)\n    cipher.update(record.fragment);\n    if (cipher.finish(encrypt_aes_cbc_sha1_padding)) {\n        // set record fragment to encrypted output\n        record.fragment = cipher.output;\n        record.length = record.fragment.length();\n        rval = true;\n    }\n    return rval;\n}\n/**\n * Handles padding for aes_cbc_sha1 in encrypt mode.\n *\n * @param blockSize the block size.\n * @param input the input buffer.\n * @param decrypt true in decrypt mode, false in encrypt mode.\n *\n * @return true on success, false on failure.\n */ function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {\n    /* The encrypted data length (TLSCiphertext.length) is one more than the sum\n   of SecurityParameters.block_length, TLSCompressed.length,\n   SecurityParameters.mac_length, and padding_length.\n\n   The padding may be any length up to 255 bytes long, as long as it results in\n   the TLSCiphertext.length being an integral multiple of the block length.\n   Lengths longer than necessary might be desirable to frustrate attacks on a\n   protocol based on analysis of the lengths of exchanged messages. Each uint8\n   in the padding data vector must be filled with the padding length value.\n\n   The padding length should be such that the total size of the\n   GenericBlockCipher structure is a multiple of the cipher's block length.\n   Legal values range from zero to 255, inclusive. This length specifies the\n   length of the padding field exclusive of the padding_length field itself.\n\n   This is slightly different from PKCS#7 because the padding value is 1\n   less than the actual number of padding bytes if you include the\n   padding_length uint8 itself as a padding byte. */ if (!decrypt) {\n        // get the number of padding bytes required to reach the blockSize and\n        // subtract 1 for the padding value (to make room for the padding_length\n        // uint8)\n        var padding = blockSize - input.length() % blockSize;\n        input.fillWithByte(padding - 1, padding);\n    }\n    return true;\n}\n/**\n * Handles padding for aes_cbc_sha1 in decrypt mode.\n *\n * @param blockSize the block size.\n * @param output the output buffer.\n * @param decrypt true in decrypt mode, false in encrypt mode.\n *\n * @return true on success, false on failure.\n */ function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {\n    var rval = true;\n    if (decrypt) {\n        /* The last byte in the output specifies the number of padding bytes not\n      including itself. Each of the padding bytes has the same value as that\n      last byte (known as the padding_length). Here we check all padding\n      bytes to ensure they have the value of padding_length even if one of\n      them is bad in order to ward-off timing attacks. */ var len = output.length();\n        var paddingLength = output.last();\n        for(var i = len - 1 - paddingLength; i < len - 1; ++i){\n            rval = rval && output.at(i) == paddingLength;\n        }\n        if (rval) {\n            // trim off padding bytes and last padding length byte\n            output.truncate(paddingLength + 1);\n        }\n    }\n    return rval;\n}\n/**\n * Decrypts a TLSCipherText record into a TLSCompressed record using\n * AES in CBC mode.\n *\n * @param record the TLSCipherText record to decrypt.\n * @param s the ConnectionState to use.\n *\n * @return true on success, false on failure.\n */ function decrypt_aes_cbc_sha1(record, s) {\n    var rval = false;\n    var iv;\n    if (record.version.minor === tls.Versions.TLS_1_0.minor) {\n        // use pre-generated IV when initializing for TLS 1.0, otherwise use the\n        // residue from the previous decryption\n        iv = s.cipherState.init ? null : s.cipherState.iv;\n    } else {\n        // TLS 1.1+ use an explicit IV every time to protect against CBC attacks\n        // that is appended to the record fragment\n        iv = record.fragment.getBytes(16);\n    }\n    s.cipherState.init = true;\n    // start cipher\n    var cipher = s.cipherState.cipher;\n    cipher.start({\n        iv: iv\n    });\n    // do decryption\n    cipher.update(record.fragment);\n    rval = cipher.finish(decrypt_aes_cbc_sha1_padding);\n    // even if decryption fails, keep going to minimize timing attacks\n    // decrypted data:\n    // first (len - 20) bytes = application data\n    // last 20 bytes          = MAC\n    var macLen = s.macLength;\n    // create a random MAC to check against should the mac length check fail\n    // Note: do this regardless of the failure to keep timing consistent\n    var mac = forge.random.getBytesSync(macLen);\n    // get fragment and mac\n    var len = cipher.output.length();\n    if (len >= macLen) {\n        record.fragment = cipher.output.getBytes(len - macLen);\n        mac = cipher.output.getBytes(macLen);\n    } else {\n        // bad data, but get bytes anyway to try to keep timing consistent\n        record.fragment = cipher.output.getBytes();\n    }\n    record.fragment = forge.util.createBuffer(record.fragment);\n    record.length = record.fragment.length();\n    // see if data integrity checks out, update sequence number\n    var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record);\n    s.updateSequenceNumber();\n    rval = compareMacs(s.macKey, mac, mac2) && rval;\n    return rval;\n}\n/**\n * Safely compare two MACs. This function will compare two MACs in a way\n * that protects against timing attacks.\n *\n * TODO: Expose elsewhere as a utility API.\n *\n * See: https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/february/double-hmac-verification/\n *\n * @param key the MAC key to use.\n * @param mac1 as a binary-encoded string of bytes.\n * @param mac2 as a binary-encoded string of bytes.\n *\n * @return true if the MACs are the same, false if not.\n */ function compareMacs(key, mac1, mac2) {\n    var hmac = forge.hmac.create();\n    hmac.start(\"SHA1\", key);\n    hmac.update(mac1);\n    mac1 = hmac.digest().getBytes();\n    hmac.start(null, null);\n    hmac.update(mac2);\n    mac2 = hmac.digest().getBytes();\n    return mac1 === mac2;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvYWVzQ2lwaGVyU3VpdGVzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0NBT0M7QUFDRCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixJQUFJQyxNQUFNQyxPQUFPQyxPQUFPLEdBQUdKLE1BQU1FLEdBQUc7QUFFcEM7O0NBRUMsR0FDREEsSUFBSUcsWUFBWSxDQUFDLCtCQUErQixHQUFHO0lBQ2pEQyxJQUFJO1FBQUM7UUFBTTtLQUFLO0lBQ2hCQyxNQUFNO0lBQ05DLHdCQUF3QixTQUFTQyxFQUFFO1FBQ2pDQSxHQUFHQyxxQkFBcUIsR0FBR1IsSUFBSVMsbUJBQW1CLENBQUNDLEdBQUc7UUFDdERILEdBQUdJLFdBQVcsR0FBR1gsSUFBSVksVUFBVSxDQUFDQyxLQUFLO1FBQ3JDTixHQUFHTyxjQUFjLEdBQUc7UUFDcEJQLEdBQUdRLFlBQVksR0FBRztRQUNsQlIsR0FBR1MsZUFBZSxHQUFHO1FBQ3JCVCxHQUFHVSxnQkFBZ0IsR0FBRztRQUN0QlYsR0FBR1csYUFBYSxHQUFHbEIsSUFBSW1CLFlBQVksQ0FBQ0MsU0FBUztRQUM3Q2IsR0FBR2MsVUFBVSxHQUFHO1FBQ2hCZCxHQUFHZSxjQUFjLEdBQUc7SUFDdEI7SUFDQUMscUJBQXFCQTtBQUN2QjtBQUNBdkIsSUFBSUcsWUFBWSxDQUFDLCtCQUErQixHQUFHO0lBQ2pEQyxJQUFJO1FBQUM7UUFBTTtLQUFLO0lBQ2hCQyxNQUFNO0lBQ05DLHdCQUF3QixTQUFTQyxFQUFFO1FBQ2pDQSxHQUFHQyxxQkFBcUIsR0FBR1IsSUFBSVMsbUJBQW1CLENBQUNDLEdBQUc7UUFDdERILEdBQUdJLFdBQVcsR0FBR1gsSUFBSVksVUFBVSxDQUFDQyxLQUFLO1FBQ3JDTixHQUFHTyxjQUFjLEdBQUc7UUFDcEJQLEdBQUdRLFlBQVksR0FBRztRQUNsQlIsR0FBR1MsZUFBZSxHQUFHO1FB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TSxRQUFRO0lBQ3pETixPQUFPcUIsTUFBTSxHQUFHckIsT0FBT00sUUFBUSxDQUFDZSxNQUFNO0lBRXRDLDJEQUEyRDtJQUMzRCxJQUFJaUIsT0FBT3JDLEVBQUVGLFdBQVcsQ0FBQ0UsRUFBRUcsTUFBTSxFQUFFSCxFQUFFSSxjQUFjLEVBQUVMO0lBQ3JEQyxFQUFFTyxvQkFBb0I7SUFDdEJOLE9BQU9xQyxZQUFZdEMsRUFBRUcsTUFBTSxFQUFFRCxLQUFLbUMsU0FBU3BDO0lBQzNDLE9BQU9BO0FBQ1Q7QUFFQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ0QsU0FBU3FDLFlBQVlDLEdBQUcsRUFBRUMsSUFBSSxFQUFFSCxJQUFJO0lBQ2xDLElBQUlJLE9BQU8zRixNQUFNMkYsSUFBSSxDQUFDQyxNQUFNO0lBRTVCRCxLQUFLM0IsS0FBSyxDQUFDLFFBQVF5QjtJQUNuQkUsS0FBS3hCLE1BQU0sQ0FBQ3VCO0lBQ1pBLE9BQU9DLEtBQUtFLE1BQU0sR0FBR1YsUUFBUTtJQUU3QlEsS0FBSzNCLEtBQUssQ0FBQyxNQUFNO0lBQ2pCMkIsS0FBS3hCLE1BQU0sQ0FBQ29CO0lBQ1pBLE9BQU9JLEtBQUtFLE1BQU0sR0FBR1YsUUFBUTtJQUU3QixPQUFPTyxTQUFTSDtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9hZXNDaXBoZXJTdWl0ZXMuanM/MTNmZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBBRVMgQ2lwaGVyIFN1aXRlcyBmb3IgVExTLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDA5LTIwMTUgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vYWVzJyk7XG5yZXF1aXJlKCcuL3RscycpO1xuXG52YXIgdGxzID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS50bHM7XG5cbi8qKlxuICogU3VwcG9ydGVkIGNpcGhlciBzdWl0ZXMuXG4gKi9cbnRscy5DaXBoZXJTdWl0ZXNbJ1RMU19SU0FfV0lUSF9BRVNfMTI4X0NCQ19TSEEnXSA9IHtcbiAgaWQ6IFsweDAwLCAweDJmXSxcbiAgbmFtZTogJ1RMU19SU0FfV0lUSF9BRVNfMTI4X0NCQ19TSEEnLFxuICBpbml0U2VjdXJpdHlQYXJhbWV0ZXJzOiBmdW5jdGlvbihzcCkge1xuICAgIHNwLmJ1bGtfY2lwaGVyX2FsZ29yaXRobSA9IHRscy5CdWxrQ2lwaGVyQWxnb3JpdGhtLmFlcztcbiAgICBzcC5jaXBoZXJfdHlwZSA9IHRscy5DaXBoZXJUeXBlLmJsb2NrO1xuICAgIHNwLmVuY19rZXlfbGVuZ3RoID0gMTY7XG4gICAgc3AuYmxvY2tfbGVuZ3RoID0gMTY7XG4gICAgc3AuZml4ZWRfaXZfbGVuZ3RoID0gMTY7XG4gICAgc3AucmVjb3JkX2l2X2xlbmd0aCA9IDE2O1xuICAgIHNwLm1hY19hbGdvcml0aG0gPSB0bHMuTUFDQWxnb3JpdGhtLmhtYWNfc2hhMTtcbiAgICBzcC5tYWNfbGVuZ3RoID0gMjA7XG4gICAgc3AubWFjX2tleV9sZW5ndGggPSAyMDtcbiAgfSxcbiAgaW5pdENvbm5lY3Rpb25TdGF0ZTogaW5pdENvbm5lY3Rpb25TdGF0ZVxufTtcbnRscy5DaXBoZXJTdWl0ZXNbJ1RMU19SU0FfV0lUSF9BRVNfMjU2X0NCQ19TSEEnXSA9IHtcbiAgaWQ6IFsweDAwLCAweDM1XSxcbiAgbmFtZTogJ1RMU19SU0FfV0lUSF9BRVNfMjU2X0NCQ19TSEEnLFxuICBpbml0U2VjdXJpdHlQYXJhbWV0ZXJzOiBmdW5jdGlvbihzcCkge1xuICAgIHNwLmJ1bGtfY2lwaGVyX2FsZ29yaXRobSA9IHRscy5CdWxrQ2lwaGVyQWxnb3JpdGhtLmFlcztcbiAgICBzcC5jaXBoZXJfdHlwZSA9IHRscy5DaXBoZXJUeXBlLmJsb2NrO1xuICAgIHNwLmVuY19rZXlfbGVuZ3RoID0gMzI7XG4gICAgc3AuYmxvY2tfbGVuZ3RoID0gMTY7XG4gICAgc3AuZml4ZWRfaXZfbGVuZ3RoID0gMTY7XG4gICAgc3AucmVjb3JkX2l2X2xlbmd0aCA9IDE2O1xuICAgIHNwLm1hY19hbGdvcml0aG0gPSB0bHMuTUFDQWxnb3JpdGhtLmhtYWNfc2hhMTtcbiAgICBzcC5tYWNfbGVuZ3RoID0gMjA7XG4gICAgc3AubWFjX2tleV9sZW5ndGggPSAyMDtcbiAgfSxcbiAgaW5pdENvbm5lY3Rpb25TdGF0ZTogaW5pdENvbm5lY3Rpb25TdGF0ZVxufTtcblxuZnVuY3Rpb24gaW5pdENvbm5lY3Rpb25TdGF0ZShzdGF0ZSwgYywgc3ApIHtcbiAgdmFyIGNsaWVudCA9IChjLmVudGl0eSA9PT0gZm9yZ2UudGxzLkNvbm5lY3Rpb25FbmQuY2xpZW50KTtcblxuICAvLyBjaXBoZXIgc2V0dXBcbiAgc3RhdGUucmVhZC5jaXBoZXJTdGF0ZSA9IHtcbiAgICBpbml0OiBmYWxzZSxcbiAgICBjaXBoZXI6IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcignQUVTLUNCQycsIGNsaWVudCA/XG4gICAgICBzcC5rZXlzLnNlcnZlcl93cml0ZV9rZXkgOiBzcC5rZXlzLmNsaWVudF93cml0ZV9rZXkpLFxuICAgIGl2OiBjbGllbnQgPyBzcC5rZXlzLnNlcnZlcl93cml0ZV9JViA6IHNwLmtleXMuY2xpZW50X3dyaXRlX0lWXG4gIH07XG4gIHN0YXRlLndyaXRlLmNpcGhlclN0YXRlID0ge1xuICAgIGluaXQ6IGZhbHNlLFxuICAgIGNpcGhlcjogZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcignQUVTLUNCQycsIGNsaWVudCA/XG4gICAgICBzcC5rZXlzLmNsaWVudF93cml0ZV9rZXkgOiBzcC5rZXlzLnNlcnZlcl93cml0ZV9rZXkpLFxuICAgIGl2OiBjbGllbnQgPyBzcC5rZXlzLmNsaWVudF93cml0ZV9JViA6IHNwLmtleXMuc2VydmVyX3dyaXRlX0lWXG4gIH07XG4gIHN0YXRlLnJlYWQuY2lwaGVyRnVuY3Rpb24gPSBkZWNyeXB0X2Flc19jYmNfc2hhMTtcbiAgc3RhdGUud3JpdGUuY2lwaGVyRnVuY3Rpb24gPSBlbmNyeXB0X2Flc19jYmNfc2hhMTtcblxuICAvLyBNQUMgc2V0dXBcbiAgc3RhdGUucmVhZC5tYWNMZW5ndGggPSBzdGF0ZS53cml0ZS5tYWNMZW5ndGggPSBzcC5tYWNfbGVuZ3RoO1xuICBzdGF0ZS5yZWFkLm1hY0Z1bmN0aW9uID0gc3RhdGUud3JpdGUubWFjRnVuY3Rpb24gPSB0bHMuaG1hY19zaGExO1xufVxuXG4vKipcbiAqIEVuY3J5cHRzIHRoZSBUTFNDb21wcmVzc2VkIHJlY29yZCBpbnRvIGEgVExTQ2lwaGVyVGV4dCByZWNvcmQgdXNpbmcgQUVTXG4gKiBpbiBDQkMgbW9kZS5cbiAqXG4gKiBAcGFyYW0gcmVjb3JkIHRoZSBUTFNDb21wcmVzc2VkIHJlY29yZCB0byBlbmNyeXB0LlxuICogQHBhcmFtIHMgdGhlIENvbm5lY3Rpb25TdGF0ZSB0byB1c2UuXG4gKlxuICogQHJldHVybiB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmUuXG4gKi9cbmZ1bmN0aW9uIGVuY3J5cHRfYWVzX2NiY19zaGExKHJlY29yZCwgcykge1xuICB2YXIgcnZhbCA9IGZhbHNlO1xuXG4gIC8vIGFwcGVuZCBNQUMgdG8gZnJhZ21lbnQsIHVwZGF0ZSBzZXF1ZW5jZSBudW1iZXJcbiAgdmFyIG1hYyA9IHMubWFjRnVuY3Rpb24ocy5tYWNLZXksIHMuc2VxdWVuY2VOdW1iZXIsIHJlY29yZCk7XG4gIHJlY29yZC5mcmFnbWVudC5wdXRCeXRlcyhtYWMpO1xuICBzLnVwZGF0ZVNlcXVlbmNlTnVtYmVyKCk7XG5cbiAgLy8gVExTIDEuMSsgdXNlIGFuIGV4cGxpY2l0IElWIGV2ZXJ5IHRpbWUgdG8gcHJvdGVjdCBhZ2FpbnN0IENCQyBhdHRhY2tzXG4gIHZhciBpdjtcbiAgaWYocmVjb3JkLnZlcnNpb24ubWlub3IgPT09IHRscy5WZXJzaW9ucy5UTFNfMV8wLm1pbm9yKSB7XG4gICAgLy8gdXNlIHRoZSBwcmUtZ2VuZXJhdGVkIElWIHdoZW4gaW5pdGlhbGl6aW5nIGZvciBUTFMgMS4wLCBvdGhlcndpc2UgdXNlXG4gICAgLy8gdGhlIHJlc2lkdWUgZnJvbSB0aGUgcHJldmlvdXMgZW5jcnlwdGlvblxuICAgIGl2ID0gcy5jaXBoZXJTdGF0ZS5pbml0ID8gbnVsbCA6IHMuY2lwaGVyU3RhdGUuaXY7XG4gIH0gZWxzZSB7XG4gICAgaXYgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKDE2KTtcbiAgfVxuXG4gIHMuY2lwaGVyU3RhdGUuaW5pdCA9IHRydWU7XG5cbiAgLy8gc3RhcnQgY2lwaGVyXG4gIHZhciBjaXBoZXIgPSBzLmNpcGhlclN0YXRlLmNpcGhlcjtcbiAgY2lwaGVyLnN0YXJ0KHtpdjogaXZ9KTtcblxuICAvLyBUTFMgMS4xKyB3cml0ZSBJViBpbnRvIG91dHB1dFxuICBpZihyZWNvcmQudmVyc2lvbi5taW5vciA+PSB0bHMuVmVyc2lvbnMuVExTXzFfMS5taW5vcikge1xuICAgIGNpcGhlci5vdXRwdXQucHV0Qnl0ZXMoaXYpO1xuICB9XG5cbiAgLy8gZG8gZW5jcnlwdGlvbiAoZGVmYXVsdCBwYWRkaW5nIGlzIGFwcHJvcHJpYXRlKVxuICBjaXBoZXIudXBkYXRlKHJlY29yZC5mcmFnbWVudCk7XG4gIGlmKGNpcGhlci5maW5pc2goZW5jcnlwdF9hZXNfY2JjX3NoYTFfcGFkZGluZykpIHtcbiAgICAvLyBzZXQgcmVjb3JkIGZyYWdtZW50IHRvIGVuY3J5cHRlZCBvdXRwdXRcbiAgICByZWNvcmQuZnJhZ21lbnQgPSBjaXBoZXIub3V0cHV0O1xuICAgIHJlY29yZC5sZW5ndGggPSByZWNvcmQuZnJhZ21lbnQubGVuZ3RoKCk7XG4gICAgcnZhbCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIHBhZGRpbmcgZm9yIGFlc19jYmNfc2hhMSBpbiBlbmNyeXB0IG1vZGUuXG4gKlxuICogQHBhcmFtIGJsb2NrU2l6ZSB0aGUgYmxvY2sgc2l6ZS5cbiAqIEBwYXJhbSBpbnB1dCB0aGUgaW5wdXQgYnVmZmVyLlxuICogQHBhcmFtIGRlY3J5cHQgdHJ1ZSBpbiBkZWNyeXB0IG1vZGUsIGZhbHNlIGluIGVuY3J5cHQgbW9kZS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZS5cbiAqL1xuZnVuY3Rpb24gZW5jcnlwdF9hZXNfY2JjX3NoYTFfcGFkZGluZyhibG9ja1NpemUsIGlucHV0LCBkZWNyeXB0KSB7XG4gIC8qIFRoZSBlbmNyeXB0ZWQgZGF0YSBsZW5ndGggKFRMU0NpcGhlcnRleHQubGVuZ3RoKSBpcyBvbmUgbW9yZSB0aGFuIHRoZSBzdW1cbiAgIG9mIFNlY3VyaXR5UGFyYW1ldGVycy5ibG9ja19sZW5ndGgsIFRMU0NvbXByZXNzZWQubGVuZ3RoLFxuICAgU2VjdXJpdHlQYXJhbWV0ZXJzLm1hY19sZW5ndGgsIGFuZCBwYWRkaW5nX2xlbmd0aC5cblxuICAgVGhlIHBhZGRpbmcgbWF5IGJlIGFueSBsZW5ndGggdXAgdG8gMjU1IGJ5dGVzIGxvbmcsIGFzIGxvbmcgYXMgaXQgcmVzdWx0cyBpblxuICAgdGhlIFRMU0NpcGhlcnRleHQubGVuZ3RoIGJlaW5nIGFuIGludGVncmFsIG11bHRpcGxlIG9mIHRoZSBibG9jayBsZW5ndGguXG4gICBMZW5ndGhzIGxvbmdlciB0aGFuIG5lY2Vzc2FyeSBtaWdodCBiZSBkZXNpcmFibGUgdG8gZnJ1c3RyYXRlIGF0dGFja3Mgb24gYVxuICAgcHJvdG9jb2wgYmFzZWQgb24gYW5hbHlzaXMgb2YgdGhlIGxlbmd0aHMgb2YgZXhjaGFuZ2VkIG1lc3NhZ2VzLiBFYWNoIHVpbnQ4XG4gICBpbiB0aGUgcGFkZGluZyBkYXRhIHZlY3RvciBtdXN0IGJlIGZpbGxlZCB3aXRoIHRoZSBwYWRkaW5nIGxlbmd0aCB2YWx1ZS5cblxuICAgVGhlIHBhZGRpbmcgbGVuZ3RoIHNob3VsZCBiZSBzdWNoIHRoYXQgdGhlIHRvdGFsIHNpemUgb2YgdGhlXG4gICBHZW5lcmljQmxvY2tDaXBoZXIgc3RydWN0dXJlIGlzIGEgbXVsdGlwbGUgb2YgdGhlIGNpcGhlcidzIGJsb2NrIGxlbmd0aC5cbiAgIExlZ2FsIHZhbHVlcyByYW5nZSBmcm9tIHplcm8gdG8gMjU1LCBpbmNsdXNpdmUuIFRoaXMgbGVuZ3RoIHNwZWNpZmllcyB0aGVcbiAgIGxlbmd0aCBvZiB0aGUgcGFkZGluZyBmaWVsZCBleGNsdXNpdmUgb2YgdGhlIHBhZGRpbmdfbGVuZ3RoIGZpZWxkIGl0c2VsZi5cblxuICAgVGhpcyBpcyBzbGlnaHRseSBkaWZmZXJlbnQgZnJvbSBQS0NTIzcgYmVjYXVzZSB0aGUgcGFkZGluZyB2YWx1ZSBpcyAxXG4gICBsZXNzIHRoYW4gdGhlIGFjdHVhbCBudW1iZXIgb2YgcGFkZGluZyBieXRlcyBpZiB5b3UgaW5jbHVkZSB0aGVcbiAgIHBhZGRpbmdfbGVuZ3RoIHVpbnQ4IGl0c2VsZiBhcyBhIHBhZGRpbmcgYnl0ZS4gKi9cbiAgaWYoIWRlY3J5cHQpIHtcbiAgICAvLyBnZXQgdGhlIG51bWJlciBvZiBwYWRkaW5nIGJ5dGVzIHJlcXVpcmVkIHRvIHJlYWNoIHRoZSBibG9ja1NpemUgYW5kXG4gICAgLy8gc3VidHJhY3QgMSBmb3IgdGhlIHBhZGRpbmcgdmFsdWUgKHRvIG1ha2Ugcm9vbSBmb3IgdGhlIHBhZGRpbmdfbGVuZ3RoXG4gICAgLy8gdWludDgpXG4gICAgdmFyIHBhZGRpbmcgPSBibG9ja1NpemUgLSAoaW5wdXQubGVuZ3RoKCkgJSBibG9ja1NpemUpO1xuICAgIGlucHV0LmZpbGxXaXRoQnl0ZShwYWRkaW5nIC0gMSwgcGFkZGluZyk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogSGFuZGxlcyBwYWRkaW5nIGZvciBhZXNfY2JjX3NoYTEgaW4gZGVjcnlwdCBtb2RlLlxuICpcbiAqIEBwYXJhbSBibG9ja1NpemUgdGhlIGJsb2NrIHNpemUuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSBvdXRwdXQgYnVmZmVyLlxuICogQHBhcmFtIGRlY3J5cHQgdHJ1ZSBpbiBkZWNyeXB0IG1vZGUsIGZhbHNlIGluIGVuY3J5cHQgbW9kZS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZS5cbiAqL1xuZnVuY3Rpb24gZGVjcnlwdF9hZXNfY2JjX3NoYTFfcGFkZGluZyhibG9ja1NpemUsIG91dHB1dCwgZGVjcnlwdCkge1xuICB2YXIgcnZhbCA9IHRydWU7XG4gIGlmKGRlY3J5cHQpIHtcbiAgICAvKiBUaGUgbGFzdCBieXRlIGluIHRoZSBvdXRwdXQgc3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgcGFkZGluZyBieXRlcyBub3RcbiAgICAgIGluY2x1ZGluZyBpdHNlbGYuIEVhY2ggb2YgdGhlIHBhZGRpbmcgYnl0ZXMgaGFzIHRoZSBzYW1lIHZhbHVlIGFzIHRoYXRcbiAgICAgIGxhc3QgYnl0ZSAoa25vd24gYXMgdGhlIHBhZGRpbmdfbGVuZ3RoKS4gSGVyZSB3ZSBjaGVjayBhbGwgcGFkZGluZ1xuICAgICAgYnl0ZXMgdG8gZW5zdXJlIHRoZXkgaGF2ZSB0aGUgdmFsdWUgb2YgcGFkZGluZ19sZW5ndGggZXZlbiBpZiBvbmUgb2ZcbiAgICAgIHRoZW0gaXMgYmFkIGluIG9yZGVyIHRvIHdhcmQtb2ZmIHRpbWluZyBhdHRhY2tzLiAqL1xuICAgIHZhciBsZW4gPSBvdXRwdXQubGVuZ3RoKCk7XG4gICAgdmFyIHBhZGRpbmdMZW5ndGggPSBvdXRwdXQubGFzdCgpO1xuICAgIGZvcih2YXIgaSA9IGxlbiAtIDEgLSBwYWRkaW5nTGVuZ3RoOyBpIDwgbGVuIC0gMTsgKytpKSB7XG4gICAgICBydmFsID0gcnZhbCAmJiAob3V0cHV0LmF0KGkpID09IHBhZGRpbmdMZW5ndGgpO1xuICAgIH1cbiAgICBpZihydmFsKSB7XG4gICAgICAvLyB0cmltIG9mZiBwYWRkaW5nIGJ5dGVzIGFuZCBsYXN0IHBhZGRpbmcgbGVuZ3RoIGJ5dGVcbiAgICAgIG91dHB1dC50cnVuY2F0ZShwYWRkaW5nTGVuZ3RoICsgMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIERlY3J5cHRzIGEgVExTQ2lwaGVyVGV4dCByZWNvcmQgaW50byBhIFRMU0NvbXByZXNzZWQgcmVjb3JkIHVzaW5nXG4gKiBBRVMgaW4gQ0JDIG1vZGUuXG4gKlxuICogQHBhcmFtIHJlY29yZCB0aGUgVExTQ2lwaGVyVGV4dCByZWNvcmQgdG8gZGVjcnlwdC5cbiAqIEBwYXJhbSBzIHRoZSBDb25uZWN0aW9uU3RhdGUgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvbiBmYWlsdXJlLlxuICovXG5mdW5jdGlvbiBkZWNyeXB0X2Flc19jYmNfc2hhMShyZWNvcmQsIHMpIHtcbiAgdmFyIHJ2YWwgPSBmYWxzZTtcblxuICB2YXIgaXY7XG4gIGlmKHJlY29yZC52ZXJzaW9uLm1pbm9yID09PSB0bHMuVmVyc2lvbnMuVExTXzFfMC5taW5vcikge1xuICAgIC8vIHVzZSBwcmUtZ2VuZXJhdGVkIElWIHdoZW4gaW5pdGlhbGl6aW5nIGZvciBUTFMgMS4wLCBvdGhlcndpc2UgdXNlIHRoZVxuICAgIC8vIHJlc2lkdWUgZnJvbSB0aGUgcHJldmlvdXMgZGVjcnlwdGlvblxuICAgIGl2ID0gcy5jaXBoZXJTdGF0ZS5pbml0ID8gbnVsbCA6IHMuY2lwaGVyU3RhdGUuaXY7XG4gIH0gZWxzZSB7XG4gICAgLy8gVExTIDEuMSsgdXNlIGFuIGV4cGxpY2l0IElWIGV2ZXJ5IHRpbWUgdG8gcHJvdGVjdCBhZ2FpbnN0IENCQyBhdHRhY2tzXG4gICAgLy8gdGhhdCBpcyBhcHBlbmRlZCB0byB0aGUgcmVjb3JkIGZyYWdtZW50XG4gICAgaXYgPSByZWNvcmQuZnJhZ21lbnQuZ2V0Qnl0ZXMoMTYpO1xuICB9XG5cbiAgcy5jaXBoZXJTdGF0ZS5pbml0ID0gdHJ1ZTtcblxuICAvLyBzdGFydCBjaXBoZXJcbiAgdmFyIGNpcGhlciA9IHMuY2lwaGVyU3RhdGUuY2lwaGVyO1xuICBjaXBoZXIuc3RhcnQoe2l2OiBpdn0pO1xuXG4gIC8vIGRvIGRlY3J5cHRpb25cbiAgY2lwaGVyLnVwZGF0ZShyZWNvcmQuZnJhZ21lbnQpO1xuICBydmFsID0gY2lwaGVyLmZpbmlzaChkZWNyeXB0X2Flc19jYmNfc2hhMV9wYWRkaW5nKTtcblxuICAvLyBldmVuIGlmIGRlY3J5cHRpb24gZmFpbHMsIGtlZXAgZ29pbmcgdG8gbWluaW1pemUgdGltaW5nIGF0dGFja3NcblxuICAvLyBkZWNyeXB0ZWQgZGF0YTpcbiAgLy8gZmlyc3QgKGxlbiAtIDIwKSBieXRlcyA9IGFwcGxpY2F0aW9uIGRhdGFcbiAgLy8gbGFzdCAyMCBieXRlcyAgICAgICAgICA9IE1BQ1xuICB2YXIgbWFjTGVuID0gcy5tYWNMZW5ndGg7XG5cbiAgLy8gY3JlYXRlIGEgcmFuZG9tIE1BQyB0byBjaGVjayBhZ2FpbnN0IHNob3VsZCB0aGUgbWFjIGxlbmd0aCBjaGVjayBmYWlsXG4gIC8vIE5vdGU6IGRvIHRoaXMgcmVnYXJkbGVzcyBvZiB0aGUgZmFpbHVyZSB0byBrZWVwIHRpbWluZyBjb25zaXN0ZW50XG4gIHZhciBtYWMgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKG1hY0xlbik7XG5cbiAgLy8gZ2V0IGZyYWdtZW50IGFuZCBtYWNcbiAgdmFyIGxlbiA9IGNpcGhlci5vdXRwdXQubGVuZ3RoKCk7XG4gIGlmKGxlbiA+PSBtYWNMZW4pIHtcbiAgICByZWNvcmQuZnJhZ21lbnQgPSBjaXBoZXIub3V0cHV0LmdldEJ5dGVzKGxlbiAtIG1hY0xlbik7XG4gICAgbWFjID0gY2lwaGVyLm91dHB1dC5nZXRCeXRlcyhtYWNMZW4pO1xuICB9IGVsc2Uge1xuICAgIC8vIGJhZCBkYXRhLCBidXQgZ2V0IGJ5dGVzIGFueXdheSB0byB0cnkgdG8ga2VlcCB0aW1pbmcgY29uc2lzdGVudFxuICAgIHJlY29yZC5mcmFnbWVudCA9IGNpcGhlci5vdXRwdXQuZ2V0Qnl0ZXMoKTtcbiAgfVxuICByZWNvcmQuZnJhZ21lbnQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihyZWNvcmQuZnJhZ21lbnQpO1xuICByZWNvcmQubGVuZ3RoID0gcmVjb3JkLmZyYWdtZW50Lmxlbmd0aCgpO1xuXG4gIC8vIHNlZSBpZiBkYXRhIGludGVncml0eSBjaGVja3Mgb3V0LCB1cGRhdGUgc2VxdWVuY2UgbnVtYmVyXG4gIHZhciBtYWMyID0gcy5tYWNGdW5jdGlvbihzLm1hY0tleSwgcy5zZXF1ZW5jZU51bWJlciwgcmVjb3JkKTtcbiAgcy51cGRhdGVTZXF1ZW5jZU51bWJlcigpO1xuICBydmFsID0gY29tcGFyZU1hY3Mocy5tYWNLZXksIG1hYywgbWFjMikgJiYgcnZhbDtcbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogU2FmZWx5IGNvbXBhcmUgdHdvIE1BQ3MuIFRoaXMgZnVuY3Rpb24gd2lsbCBjb21wYXJlIHR3byBNQUNzIGluIGEgd2F5XG4gKiB0aGF0IHByb3RlY3RzIGFnYWluc3QgdGltaW5nIGF0dGFja3MuXG4gKlxuICogVE9ETzogRXhwb3NlIGVsc2V3aGVyZSBhcyBhIHV0aWxpdHkgQVBJLlxuICpcbiAqIFNlZTogaHR0cHM6Ly93d3cubmNjZ3JvdXAudHJ1c3QvdXMvYWJvdXQtdXMvbmV3c3Jvb20tYW5kLWV2ZW50cy9ibG9nLzIwMTEvZmVicnVhcnkvZG91YmxlLWhtYWMtdmVyaWZpY2F0aW9uL1xuICpcbiAqIEBwYXJhbSBrZXkgdGhlIE1BQyBrZXkgdG8gdXNlLlxuICogQHBhcmFtIG1hYzEgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKiBAcGFyYW0gbWFjMiBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIE1BQ3MgYXJlIHRoZSBzYW1lLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVNYWNzKGtleSwgbWFjMSwgbWFjMikge1xuICB2YXIgaG1hYyA9IGZvcmdlLmhtYWMuY3JlYXRlKCk7XG5cbiAgaG1hYy5zdGFydCgnU0hBMScsIGtleSk7XG4gIGhtYWMudXBkYXRlKG1hYzEpO1xuICBtYWMxID0gaG1hYy5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gIGhtYWMuc3RhcnQobnVsbCwgbnVsbCk7XG4gIGhtYWMudXBkYXRlKG1hYzIpO1xuICBtYWMyID0gaG1hYy5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gIHJldHVybiBtYWMxID09PSBtYWMyO1xufVxuIl0sIm5hbWVzIjpbImZvcmdlIiwicmVxdWlyZSIsInRscyIsIm1vZHVsZSIsImV4cG9ydHMiLCJDaXBoZXJTdWl0ZXMiLCJpZCIsIm5hbWUiLCJpbml0U2VjdXJpdHlQYXJhbWV0ZXJzIiwic3AiLCJidWxrX2NpcGhlcl9hbGdvcml0aG0iLCJCdWxrQ2lwaGVyQWxnb3JpdGhtIiwiYWVzIiwiY2lwaGVyX3R5cGUiLCJDaXBoZXJUeXBlIiwiYmxvY2siLCJlbmNfa2V5X2xlbmd0aCIsImJsb2NrX2xlbmd0aCIsImZpeGVkX2l2X2xlbmd0aCIsInJlY29yZF9pdl9sZW5ndGgiLCJtYWNfYWxnb3JpdGhtIiwiTUFDQWxnb3JpdGhtIiwiaG1hY19zaGExIiwibWFjX2xlbmd0aCIsIm1hY19rZXlfbGVuZ3RoIiwiaW5pdENvbm5lY3Rpb25TdGF0ZSIsInN0YXRlIiwiYyIsImNsaWVudCIsImVudGl0eSIsIkNvbm5lY3Rpb25FbmQiLCJyZWFkIiwiY2lwaGVyU3RhdGUiLCJpbml0IiwiY2lwaGVyIiwiY3JlYXRlRGVjaXBoZXIiLCJrZXlzIiwic2VydmVyX3dyaXRlX2tleSIsImNsaWVudF93cml0ZV9rZXkiLCJpdiIsInNlcnZlcl93cml0ZV9JViIsImNsaWVudF93cml0ZV9JViIsIndyaXRlIiwiY3JlYXRlQ2lwaGVyIiwiY2lwaGVyRnVuY3Rpb24iLCJkZWNyeXB0X2Flc19jYmNfc2hhMSIsImVuY3J5cHRfYWVzX2NiY19zaGExIiwibWFjTGVuZ3RoIiwibWFjRnVuY3Rpb24iLCJyZWNvcmQiLCJzIiwicnZhbCIsIm1hYyIsIm1hY0tleSIsInNlcXVlbmNlTnVtYmVyIiwiZnJhZ21lbnQiLCJwdXRCeXRlcyIsInVwZGF0ZVNlcXVlbmNlTnVtYmVyIiwidmVyc2lvbiIsIm1pbm9yIiwiVmVyc2lvbnMiLCJUTFNfMV8wIiwicmFuZG9tIiwiZ2V0Qnl0ZXNTeW5jIiwic3RhcnQiLCJUTFNfMV8xIiwib3V0cHV0IiwidXBkYXRlIiwiZmluaXNoIiwiZW5jcnlwdF9hZXNfY2JjX3NoYTFfcGFkZGluZyIsImxlbmd0aCIsImJsb2NrU2l6ZSIsImlucHV0IiwiZGVjcnlwdCIsInBhZGRpbmciLCJmaWxsV2l0aEJ5dGUiLCJkZWNyeXB0X2Flc19jYmNfc2hhMV9wYWRkaW5nIiwibGVuIiwicGFkZGluZ0xlbmd0aCIsImxhc3QiLCJpIiwiYXQiLCJ0cnVuY2F0ZSIsImdldEJ5dGVzIiwibWFjTGVuIiwidXRpbCIsImNyZWF0ZUJ1ZmZlciIsIm1hYzIiLCJjb21wYXJlTWFjcyIsImtleSIsIm1hYzEiLCJobWFjIiwiY3JlYXRlIiwiZGlnZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/aesCipherSuites.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/asn1-validator.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-forge/lib/asn1-validator.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) 2019 Digital Bazaar, Inc.\n */ var forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./asn1 */ \"(rsc)/./node_modules/node-forge/lib/asn1.js\");\nvar asn1 = forge.asn1;\nexports.privateKeyValidator = {\n    // PrivateKeyInfo\n    name: \"PrivateKeyInfo\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            // Version (INTEGER)\n            name: \"PrivateKeyInfo.version\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyVersion\"\n        },\n        {\n            // privateKeyAlgorithm\n            name: \"PrivateKeyInfo.privateKeyAlgorithm\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    name: \"AlgorithmIdentifier.algorithm\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OID,\n                    constructed: false,\n                    capture: \"privateKeyOid\"\n                }\n            ]\n        },\n        {\n            // PrivateKey\n            name: \"PrivateKeyInfo\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OCTETSTRING,\n            constructed: false,\n            capture: \"privateKey\"\n        }\n    ]\n};\nexports.publicKeyValidator = {\n    name: \"SubjectPublicKeyInfo\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    captureAsn1: \"subjectPublicKeyInfo\",\n    value: [\n        {\n            name: \"SubjectPublicKeyInfo.AlgorithmIdentifier\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    name: \"AlgorithmIdentifier.algorithm\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OID,\n                    constructed: false,\n                    capture: \"publicKeyOid\"\n                }\n            ]\n        },\n        // capture group for ed25519PublicKey\n        {\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.BITSTRING,\n            constructed: false,\n            composed: true,\n            captureBitStringValue: \"ed25519PublicKey\"\n        }\n    ]\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvYXNuMS12YWxpZGF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUMsR0FFRCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQkEsbUJBQU9BLENBQUM7QUFDUixJQUFJQyxPQUFPRixNQUFNRSxJQUFJO0FBRXJCQywyQkFBMkIsR0FBRztJQUM1QixpQkFBaUI7SUFDakJFLE1BQU07SUFDTkMsVUFBVUosS0FBS0ssS0FBSyxDQUFDQyxTQUFTO0lBQzlCQyxNQUFNUCxLQUFLUSxJQUFJLENBQUNDLFFBQVE7SUFDeEJDLGFBQWE7SUFDYkMsT0FBTztRQUFDO1lBQ04sb0JBQW9CO1lBQ3BCUixNQUFNO1lBQ05DLFVBQVVKLEtBQUtLLEtBQUssQ0FBQ0MsU0FBUztZQUM5QkMsTUFBTVAsS0FBS1EsSUFBSSxDQUFDSSxPQUFPO1lBQ3ZCRixhQUFhO1lBQ2JHLFNBQVM7UUFDWDtRQUFHO1lBQ0Qsc0JBQXNCO1lBQ3RCVixNQUFNO1lBQ05DLFVBQVVKLEtBQUtLLEtBQUssQ0FBQ0MsU0FBUztZQUM5QkMsTUFBTVAsS0FBS1EsSUFBSSxDQUFDQyxRQUFRO1lBQ3hCQyxhQUFhO1lBQ2JDLE9BQU87Z0JBQUM7b0JBQ05SLE1BQU07b0JBQ05DLFVBQVVKLEtBQUtLLEtBQUssQ0FBQ0MsU0FBUztvQkFDOUJDLE1BQU1QLEtBQUtRLElBQUksQ0FBQ00sR0FBRztvQkFDbkJKLGFBQWE7b0JBQ2JHLFNBQVM7Z0JBQ1g7YUFBRTtRQUNKO1FBQUc7WUFDRCxhQUFhO1lBQ2JWLE1BQU07WUFDTkMsVUFBVUosS0FBS0ssS0FBSyxDQUFDQyxTQUFTO1lBQzlCQyxNQUFNUCxLQUFLUSxJQUFJLENBQUNPLFdBQVc7WUFDM0JMLGFBQWE7WUFDYkcsU0FBUztRQUNYO0tBQUU7QUFDSjtBQUVBWiwwQkFBMEIsR0FBRztJQUMzQkUsTUFBTTtJQUNOQyxVQUFVSixLQUFLSyxLQUFLLENBQUNDLFNBQVM7SUFDOUJDLE1BQU1QLEtBQUtRLElBQUksQ0FBQ0MsUUFBUTtJQUN4QkMsYUFBYTtJQUNiTyxhQUFhO0lBQ2JOLE9BQU87UUFBQztZQUNOUixNQUFNO1lBQ05DLFVBQVVKLEtBQUtLLEtBQUssQ0FBQ0MsU0FBUztZQUM5QkMsTUFBTVAsS0FBS1EsSUFBSSxDQUFDQyxRQUFRO1lBQ3hCQyxhQUFhO1lBQ2JDLE9BQU87Z0JBQUM7b0JBQ05SLE1BQU07b0JBQ05DLFVBQVVKLEtBQUtLLEtBQUssQ0FBQ0MsU0FBUztvQkFDOUJDLE1BQU1QLEtBQUtRLElBQUksQ0FBQ00sR0FBRztvQkFDbkJKLGFBQWE7b0JBQ2JHLFNBQVM7Z0JBQ1g7YUFBRTtRQUNKO1FBQ0EscUNBQXFDO1FBQ3JDO1lBQ0VULFVBQVVKLEtBQUtLLEtBQUssQ0FBQ0MsU0FBUztZQUM5QkMsTUFBTVAsS0FBS1EsSUFBSSxDQUFDVSxTQUFTO1lBQ3pCUixhQUFhO1lBQ2JTLFVBQVU7WUFDVkMsdUJBQXVCO1FBQ3pCO0tBbUJDO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvYXNuMS12YWxpZGF0b3IuanM/M2VlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxOSBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG5cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vYXNuMScpO1xudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG5leHBvcnRzLnByaXZhdGVLZXlWYWxpZGF0b3IgPSB7XG4gIC8vIFByaXZhdGVLZXlJbmZvXG4gIG5hbWU6ICdQcml2YXRlS2V5SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgLy8gVmVyc2lvbiAoSU5URUdFUilcbiAgICBuYW1lOiAnUHJpdmF0ZUtleUluZm8udmVyc2lvbicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleVZlcnNpb24nXG4gIH0sIHtcbiAgICAvLyBwcml2YXRlS2V5QWxnb3JpdGhtXG4gICAgbmFtZTogJ1ByaXZhdGVLZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5T2lkJ1xuICAgIH1dXG4gIH0sIHtcbiAgICAvLyBQcml2YXRlS2V5XG4gICAgbmFtZTogJ1ByaXZhdGVLZXlJbmZvJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleSdcbiAgfV1cbn07XG5cbmV4cG9ydHMucHVibGljS2V5VmFsaWRhdG9yID0ge1xuICBuYW1lOiAnU3ViamVjdFB1YmxpY0tleUluZm8nLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIGNhcHR1cmVBc24xOiAnc3ViamVjdFB1YmxpY0tleUluZm8nLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnU3ViamVjdFB1YmxpY0tleUluZm8uQWxnb3JpdGhtSWRlbnRpZmllcicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdBbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3B1YmxpY0tleU9pZCdcbiAgICB9XVxuICB9LFxuICAvLyBjYXB0dXJlIGdyb3VwIGZvciBlZDI1NTE5UHVibGljS2V5XG4gIHtcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY29tcG9zZWQ6IHRydWUsXG4gICAgY2FwdHVyZUJpdFN0cmluZ1ZhbHVlOiAnZWQyNTUxOVB1YmxpY0tleSdcbiAgfVxuICAvLyBGSVhNRTogdGhpcyBpcyBjYXB0dXJlIGdyb3VwIGZvciByc2FQdWJsaWNLZXksIHVzZSBpdCBpbiB0aGlzIEFQSSBvclxuICAvLyBkaXNjYXJkP1xuICAvKiB7XG4gICAgLy8gc3ViamVjdFB1YmxpY0tleVxuICAgIG5hbWU6ICdTdWJqZWN0UHVibGljS2V5SW5mby5zdWJqZWN0UHVibGljS2V5JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgdmFsdWU6IFt7XG4gICAgICAvLyBSU0FQdWJsaWNLZXlcbiAgICAgIG5hbWU6ICdTdWJqZWN0UHVibGljS2V5SW5mby5zdWJqZWN0UHVibGljS2V5LlJTQVB1YmxpY0tleScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdyc2FQdWJsaWNLZXknXG4gICAgfV1cbiAgfSAqL1xuICBdXG59O1xuIl0sIm5hbWVzIjpbImZvcmdlIiwicmVxdWlyZSIsImFzbjEiLCJleHBvcnRzIiwicHJpdmF0ZUtleVZhbGlkYXRvciIsIm5hbWUiLCJ0YWdDbGFzcyIsIkNsYXNzIiwiVU5JVkVSU0FMIiwidHlwZSIsIlR5cGUiLCJTRVFVRU5DRSIsImNvbnN0cnVjdGVkIiwidmFsdWUiLCJJTlRFR0VSIiwiY2FwdHVyZSIsIk9JRCIsIk9DVEVUU1RSSU5HIiwicHVibGljS2V5VmFsaWRhdG9yIiwiY2FwdHVyZUFzbjEiLCJCSVRTVFJJTkciLCJjb21wb3NlZCIsImNhcHR1cmVCaXRTdHJpbmdWYWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/asn1-validator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/asn1.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/asn1.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Javascript implementation of Abstract Syntax Notation Number One.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2015 Digital Bazaar, Inc.\n *\n * An API for storing data using the Abstract Syntax Notation Number One\n * format using DER (Distinguished Encoding Rules) encoding. This encoding is\n * commonly used to store data for PKI, i.e. X.509 Certificates, and this\n * implementation exists for that purpose.\n *\n * Abstract Syntax Notation Number One (ASN.1) is used to define the abstract\n * syntax of information without restricting the way the information is encoded\n * for transmission. It provides a standard that allows for open systems\n * communication. ASN.1 defines the syntax of information data and a number of\n * simple data types as well as a notation for describing them and specifying\n * values for them.\n *\n * The RSA algorithm creates public and private keys that are often stored in\n * X.509 or PKCS#X formats -- which use ASN.1 (encoded in DER format). This\n * class provides the most basic functionality required to store and load DSA\n * keys that are encoded according to ASN.1.\n *\n * The most common binary encodings for ASN.1 are BER (Basic Encoding Rules)\n * and DER (Distinguished Encoding Rules). DER is just a subset of BER that\n * has stricter requirements for how data must be encoded.\n *\n * Each ASN.1 structure has a tag (a byte identifying the ASN.1 structure type)\n * and a byte array for the value of this ASN1 structure which may be data or a\n * list of ASN.1 structures.\n *\n * Each ASN.1 structure using BER is (Tag-Length-Value):\n *\n * | byte 0 | bytes X | bytes Y |\n * |--------|---------|----------\n * |  tag   | length  |  value  |\n *\n * ASN.1 allows for tags to be of \"High-tag-number form\" which allows a tag to\n * be two or more octets, but that is not supported by this class. A tag is\n * only 1 byte. Bits 1-5 give the tag number (ie the data type within a\n * particular 'class'), 6 indicates whether or not the ASN.1 value is\n * constructed from other ASN.1 values, and bits 7 and 8 give the 'class'. If\n * bits 7 and 8 are both zero, the class is UNIVERSAL. If only bit 7 is set,\n * then the class is APPLICATION. If only bit 8 is set, then the class is\n * CONTEXT_SPECIFIC. If both bits 7 and 8 are set, then the class is PRIVATE.\n * The tag numbers for the data types for the class UNIVERSAL are listed below:\n *\n * UNIVERSAL 0 Reserved for use by the encoding rules\n * UNIVERSAL 1 Boolean type\n * UNIVERSAL 2 Integer type\n * UNIVERSAL 3 Bitstring type\n * UNIVERSAL 4 Octetstring type\n * UNIVERSAL 5 Null type\n * UNIVERSAL 6 Object identifier type\n * UNIVERSAL 7 Object descriptor type\n * UNIVERSAL 8 External type and Instance-of type\n * UNIVERSAL 9 Real type\n * UNIVERSAL 10 Enumerated type\n * UNIVERSAL 11 Embedded-pdv type\n * UNIVERSAL 12 UTF8String type\n * UNIVERSAL 13 Relative object identifier type\n * UNIVERSAL 14-15 Reserved for future editions\n * UNIVERSAL 16 Sequence and Sequence-of types\n * UNIVERSAL 17 Set and Set-of types\n * UNIVERSAL 18-22, 25-30 Character string types\n * UNIVERSAL 23-24 Time types\n *\n * The length of an ASN.1 structure is specified after the tag identifier.\n * There is a definite form and an indefinite form. The indefinite form may\n * be used if the encoding is constructed and not all immediately available.\n * The indefinite form is encoded using a length byte with only the 8th bit\n * set. The end of the constructed object is marked using end-of-contents\n * octets (two zero bytes).\n *\n * The definite form looks like this:\n *\n * The length may take up 1 or more bytes, it depends on the length of the\n * value of the ASN.1 structure. DER encoding requires that if the ASN.1\n * structure has a value that has a length greater than 127, more than 1 byte\n * will be used to store its length, otherwise just one byte will be used.\n * This is strict.\n *\n * In the case that the length of the ASN.1 value is less than 127, 1 octet\n * (byte) is used to store the \"short form\" length. The 8th bit has a value of\n * 0 indicating the length is \"short form\" and not \"long form\" and bits 7-1\n * give the length of the data. (The 8th bit is the left-most, most significant\n * bit: also known as big endian or network format).\n *\n * In the case that the length of the ASN.1 value is greater than 127, 2 to\n * 127 octets (bytes) are used to store the \"long form\" length. The first\n * byte's 8th bit is set to 1 to indicate the length is \"long form.\" Bits 7-1\n * give the number of additional octets. All following octets are in base 256\n * with the most significant digit first (typical big-endian binary unsigned\n * integer storage). So, for instance, if the length of a value was 257, the\n * first byte would be set to:\n *\n * 10000010 = 130 = 0x82.\n *\n * This indicates there are 2 octets (base 256) for the length. The second and\n * third bytes (the octets just mentioned) would store the length in base 256:\n *\n * octet 2: 00000001 = 1 * 256^1 = 256\n * octet 3: 00000001 = 1 * 256^0 = 1\n * total = 257\n *\n * The algorithm for converting a js integer value of 257 to base-256 is:\n *\n * var value = 257;\n * var bytes = [];\n * bytes[0] = (value >>> 8) & 0xFF; // most significant byte first\n * bytes[1] = value & 0xFF;        // least significant byte last\n *\n * On the ASN.1 UNIVERSAL Object Identifier (OID) type:\n *\n * An OID can be written like: \"value1.value2.value3...valueN\"\n *\n * The DER encoding rules:\n *\n * The first byte has the value 40 * value1 + value2.\n * The following bytes, if any, encode the remaining values. Each value is\n * encoded in base 128, most significant digit first (big endian), with as\n * few digits as possible, and the most significant bit of each byte set\n * to 1 except the last in each value's encoding. For example: Given the\n * OID \"1.2.840.113549\", its DER encoding is (remember each byte except the\n * last one in each encoding is OR'd with 0x80):\n *\n * byte 1: 40 * 1 + 2 = 42 = 0x2A.\n * bytes 2-3: 128 * 6 + 72 = 840 = 6 72 = 6 72 = 0x0648 = 0x8648\n * bytes 4-6: 16384 * 6 + 128 * 119 + 13 = 6 119 13 = 0x06770D = 0x86F70D\n *\n * The final value is: 0x2A864886F70D.\n * The full OID (including ASN.1 tag and length of 6 bytes) is:\n * 0x06062A864886F70D\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\n__webpack_require__(/*! ./oids */ \"(rsc)/./node_modules/node-forge/lib/oids.js\");\n/* ASN.1 API */ var asn1 = module.exports = forge.asn1 = forge.asn1 || {};\n/**\n * ASN.1 classes.\n */ asn1.Class = {\n    UNIVERSAL: 0x00,\n    APPLICATION: 0x40,\n    CONTEXT_SPECIFIC: 0x80,\n    PRIVATE: 0xC0\n};\n/**\n * ASN.1 types. Not all types are supported by this implementation, only\n * those necessary to implement a simple PKI are implemented.\n */ asn1.Type = {\n    NONE: 0,\n    BOOLEAN: 1,\n    INTEGER: 2,\n    BITSTRING: 3,\n    OCTETSTRING: 4,\n    NULL: 5,\n    OID: 6,\n    ODESC: 7,\n    EXTERNAL: 8,\n    REAL: 9,\n    ENUMERATED: 10,\n    EMBEDDED: 11,\n    UTF8: 12,\n    ROID: 13,\n    SEQUENCE: 16,\n    SET: 17,\n    PRINTABLESTRING: 19,\n    IA5STRING: 22,\n    UTCTIME: 23,\n    GENERALIZEDTIME: 24,\n    BMPSTRING: 30\n};\n/**\n * Creates a new asn1 object.\n *\n * @param tagClass the tag class for the object.\n * @param type the data type (tag number) for the object.\n * @param constructed true if the asn1 object is in constructed form.\n * @param value the value for the object, if it is not constructed.\n * @param [options] the options to use:\n *          [bitStringContents] the plain BIT STRING content including padding\n *            byte.\n *\n * @return the asn1 object.\n */ asn1.create = function(tagClass, type, constructed, value, options) {\n    /* An asn1 object has a tagClass, a type, a constructed flag, and a\n    value. The value's type depends on the constructed flag. If\n    constructed, it will contain a list of other asn1 objects. If not,\n    it will contain the ASN.1 value as an array of bytes formatted\n    according to the ASN.1 data type. */ // remove undefined values\n    if (forge.util.isArray(value)) {\n        var tmp = [];\n        for(var i = 0; i < value.length; ++i){\n            if (value[i] !== undefined) {\n                tmp.push(value[i]);\n            }\n        }\n        value = tmp;\n    }\n    var obj = {\n        tagClass: tagClass,\n        type: type,\n        constructed: constructed,\n        composed: constructed || forge.util.isArray(value),\n        value: value\n    };\n    if (options && \"bitStringContents\" in options) {\n        // TODO: copy byte buffer if it's a buffer not a string\n        obj.bitStringContents = options.bitStringContents;\n        // TODO: add readonly flag to avoid this overhead\n        // save copy to detect changes\n        obj.original = asn1.copy(obj);\n    }\n    return obj;\n};\n/**\n * Copies an asn1 object.\n *\n * @param obj the asn1 object.\n * @param [options] copy options:\n *          [excludeBitStringContents] true to not copy bitStringContents\n *\n * @return the a copy of the asn1 object.\n */ asn1.copy = function(obj, options) {\n    var copy;\n    if (forge.util.isArray(obj)) {\n        copy = [];\n        for(var i = 0; i < obj.length; ++i){\n            copy.push(asn1.copy(obj[i], options));\n        }\n        return copy;\n    }\n    if (typeof obj === \"string\") {\n        // TODO: copy byte buffer if it's a buffer not a string\n        return obj;\n    }\n    copy = {\n        tagClass: obj.tagClass,\n        type: obj.type,\n        constructed: obj.constructed,\n        composed: obj.composed,\n        value: asn1.copy(obj.value, options)\n    };\n    if (options && !options.excludeBitStringContents) {\n        // TODO: copy byte buffer if it's a buffer not a string\n        copy.bitStringContents = obj.bitStringContents;\n    }\n    return copy;\n};\n/**\n * Compares asn1 objects for equality.\n *\n * Note this function does not run in constant time.\n *\n * @param obj1 the first asn1 object.\n * @param obj2 the second asn1 object.\n * @param [options] compare options:\n *          [includeBitStringContents] true to compare bitStringContents\n *\n * @return true if the asn1 objects are equal.\n */ asn1.equals = function(obj1, obj2, options) {\n    if (forge.util.isArray(obj1)) {\n        if (!forge.util.isArray(obj2)) {\n            return false;\n        }\n        if (obj1.length !== obj2.length) {\n            return false;\n        }\n        for(var i = 0; i < obj1.length; ++i){\n            if (!asn1.equals(obj1[i], obj2[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (typeof obj1 !== typeof obj2) {\n        return false;\n    }\n    if (typeof obj1 === \"string\") {\n        return obj1 === obj2;\n    }\n    var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);\n    if (options && options.includeBitStringContents) {\n        equal = equal && obj1.bitStringContents === obj2.bitStringContents;\n    }\n    return equal;\n};\n/**\n * Gets the length of a BER-encoded ASN.1 value.\n *\n * In case the length is not specified, undefined is returned.\n *\n * @param b the BER-encoded ASN.1 byte buffer, starting with the first\n *          length byte.\n *\n * @return the length of the BER-encoded ASN.1 value or undefined.\n */ asn1.getBerValueLength = function(b) {\n    // TODO: move this function and related DER/BER functions to a der.js\n    // file; better abstract ASN.1 away from der/ber.\n    var b2 = b.getByte();\n    if (b2 === 0x80) {\n        return undefined;\n    }\n    // see if the length is \"short form\" or \"long form\" (bit 8 set)\n    var length;\n    var longForm = b2 & 0x80;\n    if (!longForm) {\n        // length is just the first byte\n        length = b2;\n    } else {\n        // the number of bytes the length is specified in bits 7 through 1\n        // and each length byte is in big-endian base-256\n        length = b.getInt((b2 & 0x7F) << 3);\n    }\n    return length;\n};\n/**\n * Check if the byte buffer has enough bytes. Throws an Error if not.\n *\n * @param bytes the byte buffer to parse from.\n * @param remaining the bytes remaining in the current parsing state.\n * @param n the number of bytes the buffer must have.\n */ function _checkBufferLength(bytes, remaining, n) {\n    if (n > remaining) {\n        var error = new Error(\"Too few bytes to parse DER.\");\n        error.available = bytes.length();\n        error.remaining = remaining;\n        error.requested = n;\n        throw error;\n    }\n}\n/**\n * Gets the length of a BER-encoded ASN.1 value.\n *\n * In case the length is not specified, undefined is returned.\n *\n * @param bytes the byte buffer to parse from.\n * @param remaining the bytes remaining in the current parsing state.\n *\n * @return the length of the BER-encoded ASN.1 value or undefined.\n */ var _getValueLength = function(bytes, remaining) {\n    // TODO: move this function and related DER/BER functions to a der.js\n    // file; better abstract ASN.1 away from der/ber.\n    // fromDer already checked that this byte exists\n    var b2 = bytes.getByte();\n    remaining--;\n    if (b2 === 0x80) {\n        return undefined;\n    }\n    // see if the length is \"short form\" or \"long form\" (bit 8 set)\n    var length;\n    var longForm = b2 & 0x80;\n    if (!longForm) {\n        // length is just the first byte\n        length = b2;\n    } else {\n        // the number of bytes the length is specified in bits 7 through 1\n        // and each length byte is in big-endian base-256\n        var longFormBytes = b2 & 0x7F;\n        _checkBufferLength(bytes, remaining, longFormBytes);\n        length = bytes.getInt(longFormBytes << 3);\n    }\n    // FIXME: this will only happen for 32 bit getInt with high bit set\n    if (length < 0) {\n        throw new Error(\"Negative length: \" + length);\n    }\n    return length;\n};\n/**\n * Parses an asn1 object from a byte buffer in DER format.\n *\n * @param bytes the byte buffer to parse from.\n * @param [strict] true to be strict when checking value lengths, false to\n *          allow truncated values (default: true).\n * @param [options] object with options or boolean strict flag\n *          [strict] true to be strict when checking value lengths, false to\n *            allow truncated values (default: true).\n *          [parseAllBytes] true to ensure all bytes are parsed\n *            (default: true)\n *          [decodeBitStrings] true to attempt to decode the content of\n *            BIT STRINGs (not OCTET STRINGs) using strict mode. Note that\n *            without schema support to understand the data context this can\n *            erroneously decode values that happen to be valid ASN.1. This\n *            flag will be deprecated or removed as soon as schema support is\n *            available. (default: true)\n *\n * @throws Will throw an error for various malformed input conditions.\n *\n * @return the parsed asn1 object.\n */ asn1.fromDer = function(bytes, options) {\n    if (options === undefined) {\n        options = {\n            strict: true,\n            parseAllBytes: true,\n            decodeBitStrings: true\n        };\n    }\n    if (typeof options === \"boolean\") {\n        options = {\n            strict: options,\n            parseAllBytes: true,\n            decodeBitStrings: true\n        };\n    }\n    if (!(\"strict\" in options)) {\n        options.strict = true;\n    }\n    if (!(\"parseAllBytes\" in options)) {\n        options.parseAllBytes = true;\n    }\n    if (!(\"decodeBitStrings\" in options)) {\n        options.decodeBitStrings = true;\n    }\n    // wrap in buffer if needed\n    if (typeof bytes === \"string\") {\n        bytes = forge.util.createBuffer(bytes);\n    }\n    var byteCount = bytes.length();\n    var value = _fromDer(bytes, bytes.length(), 0, options);\n    if (options.parseAllBytes && bytes.length() !== 0) {\n        var error = new Error(\"Unparsed DER bytes remain after ASN.1 parsing.\");\n        error.byteCount = byteCount;\n        error.remaining = bytes.length();\n        throw error;\n    }\n    return value;\n};\n/**\n * Internal function to parse an asn1 object from a byte buffer in DER format.\n *\n * @param bytes the byte buffer to parse from.\n * @param remaining the number of bytes remaining for this chunk.\n * @param depth the current parsing depth.\n * @param options object with same options as fromDer().\n *\n * @return the parsed asn1 object.\n */ function _fromDer(bytes, remaining, depth, options) {\n    // temporary storage for consumption calculations\n    var start;\n    // minimum length for ASN.1 DER structure is 2\n    _checkBufferLength(bytes, remaining, 2);\n    // get the first byte\n    var b1 = bytes.getByte();\n    // consumed one byte\n    remaining--;\n    // get the tag class\n    var tagClass = b1 & 0xC0;\n    // get the type (bits 1-5)\n    var type = b1 & 0x1F;\n    // get the variable value length and adjust remaining bytes\n    start = bytes.length();\n    var length = _getValueLength(bytes, remaining);\n    remaining -= start - bytes.length();\n    // ensure there are enough bytes to get the value\n    if (length !== undefined && length > remaining) {\n        if (options.strict) {\n            var error = new Error(\"Too few bytes to read ASN.1 value.\");\n            error.available = bytes.length();\n            error.remaining = remaining;\n            error.requested = length;\n            throw error;\n        }\n        // Note: be lenient with truncated values and use remaining state bytes\n        length = remaining;\n    }\n    // value storage\n    var value;\n    // possible BIT STRING contents storage\n    var bitStringContents;\n    // constructed flag is bit 6 (32 = 0x20) of the first byte\n    var constructed = (b1 & 0x20) === 0x20;\n    if (constructed) {\n        // parse child asn1 objects from the value\n        value = [];\n        if (length === undefined) {\n            // asn1 object of indefinite length, read until end tag\n            for(;;){\n                _checkBufferLength(bytes, remaining, 2);\n                if (bytes.bytes(2) === String.fromCharCode(0, 0)) {\n                    bytes.getBytes(2);\n                    remaining -= 2;\n                    break;\n                }\n                start = bytes.length();\n                value.push(_fromDer(bytes, remaining, depth + 1, options));\n                remaining -= start - bytes.length();\n            }\n        } else {\n            // parsing asn1 object of definite length\n            while(length > 0){\n                start = bytes.length();\n                value.push(_fromDer(bytes, length, depth + 1, options));\n                remaining -= start - bytes.length();\n                length -= start - bytes.length();\n            }\n        }\n    }\n    // if a BIT STRING, save the contents including padding\n    if (value === undefined && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {\n        bitStringContents = bytes.bytes(length);\n    }\n    // determine if a non-constructed value should be decoded as a composed\n    // value that contains other ASN.1 objects. BIT STRINGs (and OCTET STRINGs)\n    // can be used this way.\n    if (value === undefined && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here\n    // .. other parts of forge expect to decode OCTET STRINGs manually\n    type === asn1.Type.BITSTRING /*|| type === asn1.Type.OCTETSTRING*/  && length > 1) {\n        // save read position\n        var savedRead = bytes.read;\n        var savedRemaining = remaining;\n        var unused = 0;\n        if (type === asn1.Type.BITSTRING) {\n            /* The first octet gives the number of bits by which the length of the\n        bit string is less than the next multiple of eight (this is called\n        the \"number of unused bits\").\n\n        The second and following octets give the value of the bit string\n        converted to an octet string. */ _checkBufferLength(bytes, remaining, 1);\n            unused = bytes.getByte();\n            remaining--;\n        }\n        // if all bits are used, maybe the BIT/OCTET STRING holds ASN.1 objs\n        if (unused === 0) {\n            try {\n                // attempt to parse child asn1 object from the value\n                // (stored in array to signal composed value)\n                start = bytes.length();\n                var subOptions = {\n                    // enforce strict mode to avoid parsing ASN.1 from plain data\n                    strict: true,\n                    decodeBitStrings: true\n                };\n                var composed = _fromDer(bytes, remaining, depth + 1, subOptions);\n                var used = start - bytes.length();\n                remaining -= used;\n                if (type == asn1.Type.BITSTRING) {\n                    used++;\n                }\n                // if the data all decoded and the class indicates UNIVERSAL or\n                // CONTEXT_SPECIFIC then assume we've got an encapsulated ASN.1 object\n                var tc = composed.tagClass;\n                if (used === length && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {\n                    value = [\n                        composed\n                    ];\n                }\n            } catch (ex) {}\n        }\n        if (value === undefined) {\n            // restore read position\n            bytes.read = savedRead;\n            remaining = savedRemaining;\n        }\n    }\n    if (value === undefined) {\n        // asn1 not constructed or composed, get raw value\n        // TODO: do DER to OID conversion and vice-versa in .toDer?\n        if (length === undefined) {\n            if (options.strict) {\n                throw new Error(\"Non-constructed ASN.1 object of indefinite length.\");\n            }\n            // be lenient and use remaining state bytes\n            length = remaining;\n        }\n        if (type === asn1.Type.BMPSTRING) {\n            value = \"\";\n            for(; length > 0; length -= 2){\n                _checkBufferLength(bytes, remaining, 2);\n                value += String.fromCharCode(bytes.getInt16());\n                remaining -= 2;\n            }\n        } else {\n            value = bytes.getBytes(length);\n            remaining -= length;\n        }\n    }\n    // add BIT STRING contents if available\n    var asn1Options = bitStringContents === undefined ? null : {\n        bitStringContents: bitStringContents\n    };\n    // create and return asn1 object\n    return asn1.create(tagClass, type, constructed, value, asn1Options);\n}\n/**\n * Converts the given asn1 object to a buffer of bytes in DER format.\n *\n * @param asn1 the asn1 object to convert to bytes.\n *\n * @return the buffer of bytes.\n */ asn1.toDer = function(obj) {\n    var bytes = forge.util.createBuffer();\n    // build the first byte\n    var b1 = obj.tagClass | obj.type;\n    // for storing the ASN.1 value\n    var value = forge.util.createBuffer();\n    // use BIT STRING contents if available and data not changed\n    var useBitStringContents = false;\n    if (\"bitStringContents\" in obj) {\n        useBitStringContents = true;\n        if (obj.original) {\n            useBitStringContents = asn1.equals(obj, obj.original);\n        }\n    }\n    if (useBitStringContents) {\n        value.putBytes(obj.bitStringContents);\n    } else if (obj.composed) {\n        // if composed, use each child asn1 object's DER bytes as value\n        // turn on 6th bit (0x20 = 32) to indicate asn1 is constructed\n        // from other asn1 objects\n        if (obj.constructed) {\n            b1 |= 0x20;\n        } else {\n            // type is a bit string, add unused bits of 0x00\n            value.putByte(0x00);\n        }\n        // add all of the child DER bytes together\n        for(var i = 0; i < obj.value.length; ++i){\n            if (obj.value[i] !== undefined) {\n                value.putBuffer(asn1.toDer(obj.value[i]));\n            }\n        }\n    } else {\n        // use asn1.value directly\n        if (obj.type === asn1.Type.BMPSTRING) {\n            for(var i = 0; i < obj.value.length; ++i){\n                value.putInt16(obj.value.charCodeAt(i));\n            }\n        } else {\n            // ensure integer is minimally-encoded\n            // TODO: should all leading bytes be stripped vs just one?\n            // .. ex '00 00 01' => '01'?\n            if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && // leading 0x00 for positive integer\n            (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 0x80) === 0 || // leading 0xFF for negative integer\n            obj.value.charCodeAt(0) === 0xFF && (obj.value.charCodeAt(1) & 0x80) === 0x80)) {\n                value.putBytes(obj.value.substr(1));\n            } else {\n                value.putBytes(obj.value);\n            }\n        }\n    }\n    // add tag byte\n    bytes.putByte(b1);\n    // use \"short form\" encoding\n    if (value.length() <= 127) {\n        // one byte describes the length\n        // bit 8 = 0 and bits 7-1 = length\n        bytes.putByte(value.length() & 0x7F);\n    } else {\n        // use \"long form\" encoding\n        // 2 to 127 bytes describe the length\n        // first byte: bit 8 = 1 and bits 7-1 = # of additional bytes\n        // other bytes: length in base 256, big-endian\n        var len = value.length();\n        var lenBytes = \"\";\n        do {\n            lenBytes += String.fromCharCode(len & 0xFF);\n            len = len >>> 8;\n        }while (len > 0);\n        // set first byte to # bytes used to store the length and turn on\n        // bit 8 to indicate long-form length is used\n        bytes.putByte(lenBytes.length | 0x80);\n        // concatenate length bytes in reverse since they were generated\n        // little endian and we need big endian\n        for(var i = lenBytes.length - 1; i >= 0; --i){\n            bytes.putByte(lenBytes.charCodeAt(i));\n        }\n    }\n    // concatenate value bytes\n    bytes.putBuffer(value);\n    return bytes;\n};\n/**\n * Converts an OID dot-separated string to a byte buffer. The byte buffer\n * contains only the DER-encoded value, not any tag or length bytes.\n *\n * @param oid the OID dot-separated string.\n *\n * @return the byte buffer.\n */ asn1.oidToDer = function(oid) {\n    // split OID into individual values\n    var values = oid.split(\".\");\n    var bytes = forge.util.createBuffer();\n    // first byte is 40 * value1 + value2\n    bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));\n    // other bytes are each value in base 128 with 8th bit set except for\n    // the last byte for each value\n    var last, valueBytes, value, b;\n    for(var i = 2; i < values.length; ++i){\n        // produce value bytes in reverse because we don't know how many\n        // bytes it will take to store the value\n        last = true;\n        valueBytes = [];\n        value = parseInt(values[i], 10);\n        do {\n            b = value & 0x7F;\n            value = value >>> 7;\n            // if value is not last, then turn on 8th bit\n            if (!last) {\n                b |= 0x80;\n            }\n            valueBytes.push(b);\n            last = false;\n        }while (value > 0);\n        // add value bytes in reverse (needs to be in big endian)\n        for(var n = valueBytes.length - 1; n >= 0; --n){\n            bytes.putByte(valueBytes[n]);\n        }\n    }\n    return bytes;\n};\n/**\n * Converts a DER-encoded byte buffer to an OID dot-separated string. The\n * byte buffer should contain only the DER-encoded value, not any tag or\n * length bytes.\n *\n * @param bytes the byte buffer.\n *\n * @return the OID dot-separated string.\n */ asn1.derToOid = function(bytes) {\n    var oid;\n    // wrap in buffer if needed\n    if (typeof bytes === \"string\") {\n        bytes = forge.util.createBuffer(bytes);\n    }\n    // first byte is 40 * value1 + value2\n    var b = bytes.getByte();\n    oid = Math.floor(b / 40) + \".\" + b % 40;\n    // other bytes are each value in base 128 with 8th bit set except for\n    // the last byte for each value\n    var value = 0;\n    while(bytes.length() > 0){\n        b = bytes.getByte();\n        value = value << 7;\n        // not the last byte for the value\n        if (b & 0x80) {\n            value += b & 0x7F;\n        } else {\n            // last byte\n            oid += \".\" + (value + b);\n            value = 0;\n        }\n    }\n    return oid;\n};\n/**\n * Converts a UTCTime value to a date.\n *\n * Note: GeneralizedTime has 4 digits for the year and is used for X.509\n * dates past 2049. Parsing that structure hasn't been implemented yet.\n *\n * @param utc the UTCTime value to convert.\n *\n * @return the date.\n */ asn1.utcTimeToDate = function(utc) {\n    /* The following formats can be used:\n\n    YYMMDDhhmmZ\n    YYMMDDhhmm+hh'mm'\n    YYMMDDhhmm-hh'mm'\n    YYMMDDhhmmssZ\n    YYMMDDhhmmss+hh'mm'\n    YYMMDDhhmmss-hh'mm'\n\n    Where:\n\n    YY is the least significant two digits of the year\n    MM is the month (01 to 12)\n    DD is the day (01 to 31)\n    hh is the hour (00 to 23)\n    mm are the minutes (00 to 59)\n    ss are the seconds (00 to 59)\n    Z indicates that local time is GMT, + indicates that local time is\n    later than GMT, and - indicates that local time is earlier than GMT\n    hh' is the absolute value of the offset from GMT in hours\n    mm' is the absolute value of the offset from GMT in minutes */ var date = new Date();\n    // if YY >= 50 use 19xx, if YY < 50 use 20xx\n    var year = parseInt(utc.substr(0, 2), 10);\n    year = year >= 50 ? 1900 + year : 2000 + year;\n    var MM = parseInt(utc.substr(2, 2), 10) - 1; // use 0-11 for month\n    var DD = parseInt(utc.substr(4, 2), 10);\n    var hh = parseInt(utc.substr(6, 2), 10);\n    var mm = parseInt(utc.substr(8, 2), 10);\n    var ss = 0;\n    // not just YYMMDDhhmmZ\n    if (utc.length > 11) {\n        // get character after minutes\n        var c = utc.charAt(10);\n        var end = 10;\n        // see if seconds are present\n        if (c !== \"+\" && c !== \"-\") {\n            // get seconds\n            ss = parseInt(utc.substr(10, 2), 10);\n            end += 2;\n        }\n    }\n    // update date\n    date.setUTCFullYear(year, MM, DD);\n    date.setUTCHours(hh, mm, ss, 0);\n    if (end) {\n        // get +/- after end of time\n        c = utc.charAt(end);\n        if (c === \"+\" || c === \"-\") {\n            // get hours+minutes offset\n            var hhoffset = parseInt(utc.substr(end + 1, 2), 10);\n            var mmoffset = parseInt(utc.substr(end + 4, 2), 10);\n            // calculate offset in milliseconds\n            var offset = hhoffset * 60 + mmoffset;\n            offset *= 60000;\n            // apply offset\n            if (c === \"+\") {\n                date.setTime(+date - offset);\n            } else {\n                date.setTime(+date + offset);\n            }\n        }\n    }\n    return date;\n};\n/**\n * Converts a GeneralizedTime value to a date.\n *\n * @param gentime the GeneralizedTime value to convert.\n *\n * @return the date.\n */ asn1.generalizedTimeToDate = function(gentime) {\n    /* The following formats can be used:\n\n    YYYYMMDDHHMMSS\n    YYYYMMDDHHMMSS.fff\n    YYYYMMDDHHMMSSZ\n    YYYYMMDDHHMMSS.fffZ\n    YYYYMMDDHHMMSS+hh'mm'\n    YYYYMMDDHHMMSS.fff+hh'mm'\n    YYYYMMDDHHMMSS-hh'mm'\n    YYYYMMDDHHMMSS.fff-hh'mm'\n\n    Where:\n\n    YYYY is the year\n    MM is the month (01 to 12)\n    DD is the day (01 to 31)\n    hh is the hour (00 to 23)\n    mm are the minutes (00 to 59)\n    ss are the seconds (00 to 59)\n    .fff is the second fraction, accurate to three decimal places\n    Z indicates that local time is GMT, + indicates that local time is\n    later than GMT, and - indicates that local time is earlier than GMT\n    hh' is the absolute value of the offset from GMT in hours\n    mm' is the absolute value of the offset from GMT in minutes */ var date = new Date();\n    var YYYY = parseInt(gentime.substr(0, 4), 10);\n    var MM = parseInt(gentime.substr(4, 2), 10) - 1; // use 0-11 for month\n    var DD = parseInt(gentime.substr(6, 2), 10);\n    var hh = parseInt(gentime.substr(8, 2), 10);\n    var mm = parseInt(gentime.substr(10, 2), 10);\n    var ss = parseInt(gentime.substr(12, 2), 10);\n    var fff = 0;\n    var offset = 0;\n    var isUTC = false;\n    if (gentime.charAt(gentime.length - 1) === \"Z\") {\n        isUTC = true;\n    }\n    var end = gentime.length - 5, c = gentime.charAt(end);\n    if (c === \"+\" || c === \"-\") {\n        // get hours+minutes offset\n        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);\n        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);\n        // calculate offset in milliseconds\n        offset = hhoffset * 60 + mmoffset;\n        offset *= 60000;\n        // apply offset\n        if (c === \"+\") {\n            offset *= -1;\n        }\n        isUTC = true;\n    }\n    // check for second fraction\n    if (gentime.charAt(14) === \".\") {\n        fff = parseFloat(gentime.substr(14), 10) * 1000;\n    }\n    if (isUTC) {\n        date.setUTCFullYear(YYYY, MM, DD);\n        date.setUTCHours(hh, mm, ss, fff);\n        // apply offset\n        date.setTime(+date + offset);\n    } else {\n        date.setFullYear(YYYY, MM, DD);\n        date.setHours(hh, mm, ss, fff);\n    }\n    return date;\n};\n/**\n * Converts a date to a UTCTime value.\n *\n * Note: GeneralizedTime has 4 digits for the year and is used for X.509\n * dates past 2049. Converting to a GeneralizedTime hasn't been\n * implemented yet.\n *\n * @param date the date to convert.\n *\n * @return the UTCTime value.\n */ asn1.dateToUtcTime = function(date) {\n    // TODO: validate; currently assumes proper format\n    if (typeof date === \"string\") {\n        return date;\n    }\n    var rval = \"\";\n    // create format YYMMDDhhmmssZ\n    var format = [];\n    format.push((\"\" + date.getUTCFullYear()).substr(2));\n    format.push(\"\" + (date.getUTCMonth() + 1));\n    format.push(\"\" + date.getUTCDate());\n    format.push(\"\" + date.getUTCHours());\n    format.push(\"\" + date.getUTCMinutes());\n    format.push(\"\" + date.getUTCSeconds());\n    // ensure 2 digits are used for each format entry\n    for(var i = 0; i < format.length; ++i){\n        if (format[i].length < 2) {\n            rval += \"0\";\n        }\n        rval += format[i];\n    }\n    rval += \"Z\";\n    return rval;\n};\n/**\n * Converts a date to a GeneralizedTime value.\n *\n * @param date the date to convert.\n *\n * @return the GeneralizedTime value as a string.\n */ asn1.dateToGeneralizedTime = function(date) {\n    // TODO: validate; currently assumes proper format\n    if (typeof date === \"string\") {\n        return date;\n    }\n    var rval = \"\";\n    // create format YYYYMMDDHHMMSSZ\n    var format = [];\n    format.push(\"\" + date.getUTCFullYear());\n    format.push(\"\" + (date.getUTCMonth() + 1));\n    format.push(\"\" + date.getUTCDate());\n    format.push(\"\" + date.getUTCHours());\n    format.push(\"\" + date.getUTCMinutes());\n    format.push(\"\" + date.getUTCSeconds());\n    // ensure 2 digits are used for each format entry\n    for(var i = 0; i < format.length; ++i){\n        if (format[i].length < 2) {\n            rval += \"0\";\n        }\n        rval += format[i];\n    }\n    rval += \"Z\";\n    return rval;\n};\n/**\n * Converts a javascript integer to a DER-encoded byte buffer to be used\n * as the value for an INTEGER type.\n *\n * @param x the integer.\n *\n * @return the byte buffer.\n */ asn1.integerToDer = function(x) {\n    var rval = forge.util.createBuffer();\n    if (x >= -0x80 && x < 0x80) {\n        return rval.putSignedInt(x, 8);\n    }\n    if (x >= -0x8000 && x < 0x8000) {\n        return rval.putSignedInt(x, 16);\n    }\n    if (x >= -0x800000 && x < 0x800000) {\n        return rval.putSignedInt(x, 24);\n    }\n    if (x >= -0x80000000 && x < 0x80000000) {\n        return rval.putSignedInt(x, 32);\n    }\n    var error = new Error(\"Integer too large; max is 32-bits.\");\n    error.integer = x;\n    throw error;\n};\n/**\n * Converts a DER-encoded byte buffer to a javascript integer. This is\n * typically used to decode the value of an INTEGER type.\n *\n * @param bytes the byte buffer.\n *\n * @return the integer.\n */ asn1.derToInteger = function(bytes) {\n    // wrap in buffer if needed\n    if (typeof bytes === \"string\") {\n        bytes = forge.util.createBuffer(bytes);\n    }\n    var n = bytes.length() * 8;\n    if (n > 32) {\n        throw new Error(\"Integer too large; max is 32-bits.\");\n    }\n    return bytes.getSignedInt(n);\n};\n/**\n * Validates that the given ASN.1 object is at least a super set of the\n * given ASN.1 structure. Only tag classes and types are checked. An\n * optional map may also be provided to capture ASN.1 values while the\n * structure is checked.\n *\n * To capture an ASN.1 value, set an object in the validator's 'capture'\n * parameter to the key to use in the capture map. To capture the full\n * ASN.1 object, specify 'captureAsn1'. To capture BIT STRING bytes, including\n * the leading unused bits counter byte, specify 'captureBitStringContents'.\n * To capture BIT STRING bytes, without the leading unused bits counter byte,\n * specify 'captureBitStringValue'.\n *\n * Objects in the validator may set a field 'optional' to true to indicate\n * that it isn't necessary to pass validation.\n *\n * @param obj the ASN.1 object to validate.\n * @param v the ASN.1 structure validator.\n * @param capture an optional map to capture values in.\n * @param errors an optional array for storing validation errors.\n *\n * @return true on success, false on failure.\n */ asn1.validate = function(obj, v, capture, errors) {\n    var rval = false;\n    // ensure tag class and type are the same if specified\n    if ((obj.tagClass === v.tagClass || typeof v.tagClass === \"undefined\") && (obj.type === v.type || typeof v.type === \"undefined\")) {\n        // ensure constructed flag is the same if specified\n        if (obj.constructed === v.constructed || typeof v.constructed === \"undefined\") {\n            rval = true;\n            // handle sub values\n            if (v.value && forge.util.isArray(v.value)) {\n                var j = 0;\n                for(var i = 0; rval && i < v.value.length; ++i){\n                    rval = v.value[i].optional || false;\n                    if (obj.value[j]) {\n                        rval = asn1.validate(obj.value[j], v.value[i], capture, errors);\n                        if (rval) {\n                            ++j;\n                        } else if (v.value[i].optional) {\n                            rval = true;\n                        }\n                    }\n                    if (!rval && errors) {\n                        errors.push(\"[\" + v.name + \"] \" + 'Tag class \"' + v.tagClass + '\", type \"' + v.type + '\" expected value length \"' + v.value.length + '\", got \"' + obj.value.length + '\"');\n                    }\n                }\n            }\n            if (rval && capture) {\n                if (v.capture) {\n                    capture[v.capture] = obj.value;\n                }\n                if (v.captureAsn1) {\n                    capture[v.captureAsn1] = obj;\n                }\n                if (v.captureBitStringContents && \"bitStringContents\" in obj) {\n                    capture[v.captureBitStringContents] = obj.bitStringContents;\n                }\n                if (v.captureBitStringValue && \"bitStringContents\" in obj) {\n                    var value;\n                    if (obj.bitStringContents.length < 2) {\n                        capture[v.captureBitStringValue] = \"\";\n                    } else {\n                        // FIXME: support unused bits with data shifting\n                        var unused = obj.bitStringContents.charCodeAt(0);\n                        if (unused !== 0) {\n                            throw new Error(\"captureBitStringValue only supported for zero unused bits\");\n                        }\n                        capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);\n                    }\n                }\n            }\n        } else if (errors) {\n            errors.push(\"[\" + v.name + \"] \" + 'Expected constructed \"' + v.constructed + '\", got \"' + obj.constructed + '\"');\n        }\n    } else if (errors) {\n        if (obj.tagClass !== v.tagClass) {\n            errors.push(\"[\" + v.name + \"] \" + 'Expected tag class \"' + v.tagClass + '\", got \"' + obj.tagClass + '\"');\n        }\n        if (obj.type !== v.type) {\n            errors.push(\"[\" + v.name + \"] \" + 'Expected type \"' + v.type + '\", got \"' + obj.type + '\"');\n        }\n    }\n    return rval;\n};\n// regex for testing for non-latin characters\nvar _nonLatinRegex = /[^\\\\u0000-\\\\u00ff]/;\n/**\n * Pretty prints an ASN.1 object to a string.\n *\n * @param obj the object to write out.\n * @param level the level in the tree.\n * @param indentation the indentation to use.\n *\n * @return the string.\n */ asn1.prettyPrint = function(obj, level, indentation) {\n    var rval = \"\";\n    // set default level and indentation\n    level = level || 0;\n    indentation = indentation || 2;\n    // start new line for deep levels\n    if (level > 0) {\n        rval += \"\\n\";\n    }\n    // create indent\n    var indent = \"\";\n    for(var i = 0; i < level * indentation; ++i){\n        indent += \" \";\n    }\n    // print class:type\n    rval += indent + \"Tag: \";\n    switch(obj.tagClass){\n        case asn1.Class.UNIVERSAL:\n            rval += \"Universal:\";\n            break;\n        case asn1.Class.APPLICATION:\n            rval += \"Application:\";\n            break;\n        case asn1.Class.CONTEXT_SPECIFIC:\n            rval += \"Context-Specific:\";\n            break;\n        case asn1.Class.PRIVATE:\n            rval += \"Private:\";\n            break;\n    }\n    if (obj.tagClass === asn1.Class.UNIVERSAL) {\n        rval += obj.type;\n        // known types\n        switch(obj.type){\n            case asn1.Type.NONE:\n                rval += \" (None)\";\n                break;\n            case asn1.Type.BOOLEAN:\n                rval += \" (Boolean)\";\n                break;\n            case asn1.Type.INTEGER:\n                rval += \" (Integer)\";\n                break;\n            case asn1.Type.BITSTRING:\n                rval += \" (Bit string)\";\n                break;\n            case asn1.Type.OCTETSTRING:\n                rval += \" (Octet string)\";\n                break;\n            case asn1.Type.NULL:\n                rval += \" (Null)\";\n                break;\n            case asn1.Type.OID:\n                rval += \" (Object Identifier)\";\n                break;\n            case asn1.Type.ODESC:\n                rval += \" (Object Descriptor)\";\n                break;\n            case asn1.Type.EXTERNAL:\n                rval += \" (External or Instance of)\";\n                break;\n            case asn1.Type.REAL:\n                rval += \" (Real)\";\n                break;\n            case asn1.Type.ENUMERATED:\n                rval += \" (Enumerated)\";\n                break;\n            case asn1.Type.EMBEDDED:\n                rval += \" (Embedded PDV)\";\n                break;\n            case asn1.Type.UTF8:\n                rval += \" (UTF8)\";\n                break;\n            case asn1.Type.ROID:\n                rval += \" (Relative Object Identifier)\";\n                break;\n            case asn1.Type.SEQUENCE:\n                rval += \" (Sequence)\";\n                break;\n            case asn1.Type.SET:\n                rval += \" (Set)\";\n                break;\n            case asn1.Type.PRINTABLESTRING:\n                rval += \" (Printable String)\";\n                break;\n            case asn1.Type.IA5String:\n                rval += \" (IA5String (ASCII))\";\n                break;\n            case asn1.Type.UTCTIME:\n                rval += \" (UTC time)\";\n                break;\n            case asn1.Type.GENERALIZEDTIME:\n                rval += \" (Generalized time)\";\n                break;\n            case asn1.Type.BMPSTRING:\n                rval += \" (BMP String)\";\n                break;\n        }\n    } else {\n        rval += obj.type;\n    }\n    rval += \"\\n\";\n    rval += indent + \"Constructed: \" + obj.constructed + \"\\n\";\n    if (obj.composed) {\n        var subvalues = 0;\n        var sub = \"\";\n        for(var i = 0; i < obj.value.length; ++i){\n            if (obj.value[i] !== undefined) {\n                subvalues += 1;\n                sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);\n                if (i + 1 < obj.value.length) {\n                    sub += \",\";\n                }\n            }\n        }\n        rval += indent + \"Sub values: \" + subvalues + sub;\n    } else {\n        rval += indent + \"Value: \";\n        if (obj.type === asn1.Type.OID) {\n            var oid = asn1.derToOid(obj.value);\n            rval += oid;\n            if (forge.pki && forge.pki.oids) {\n                if (oid in forge.pki.oids) {\n                    rval += \" (\" + forge.pki.oids[oid] + \") \";\n                }\n            }\n        }\n        if (obj.type === asn1.Type.INTEGER) {\n            try {\n                rval += asn1.derToInteger(obj.value);\n            } catch (ex) {\n                rval += \"0x\" + forge.util.bytesToHex(obj.value);\n            }\n        } else if (obj.type === asn1.Type.BITSTRING) {\n            // TODO: shift bits as needed to display without padding\n            if (obj.value.length > 1) {\n                // remove unused bits field\n                rval += \"0x\" + forge.util.bytesToHex(obj.value.slice(1));\n            } else {\n                rval += \"(none)\";\n            }\n            // show unused bit count\n            if (obj.value.length > 0) {\n                var unused = obj.value.charCodeAt(0);\n                if (unused == 1) {\n                    rval += \" (1 unused bit shown)\";\n                } else if (unused > 1) {\n                    rval += \" (\" + unused + \" unused bits shown)\";\n                }\n            }\n        } else if (obj.type === asn1.Type.OCTETSTRING) {\n            if (!_nonLatinRegex.test(obj.value)) {\n                rval += \"(\" + obj.value + \") \";\n            }\n            rval += \"0x\" + forge.util.bytesToHex(obj.value);\n        } else if (obj.type === asn1.Type.UTF8) {\n            try {\n                rval += forge.util.decodeUtf8(obj.value);\n            } catch (e) {\n                if (e.message === \"URI malformed\") {\n                    rval += \"0x\" + forge.util.bytesToHex(obj.value) + \" (malformed UTF8)\";\n                } else {\n                    throw e;\n                }\n            }\n        } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {\n            rval += obj.value;\n        } else if (_nonLatinRegex.test(obj.value)) {\n            rval += \"0x\" + forge.util.bytesToHex(obj.value);\n        } else if (obj.value.length === 0) {\n            rval += \"[null]\";\n        } else {\n            rval += obj.value;\n        }\n    }\n    return rval;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvYXNuMS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzSUM7QUFDRCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixhQUFhLEdBQ2IsSUFBSUMsT0FBT0MsT0FBT0MsT0FBTyxHQUFHSixNQUFNRSxJQUFJLEdBQUdGLE1BQU1FLElBQUksSUFBSSxDQUFDO0FBRXhEOztDQUVDLEdBQ0RBLEtBQUtHLEtBQUssR0FBRztJQUNYQyxXQUFrQjtJQUNsQkMsYUFBa0I7SUFDbEJDLGtCQUFrQjtJQUNsQkMsU0FBa0I7QUFDcEI7QUFFQTs7O0NBR0MsR0FDRFAsS0FBS1EsSUFBSSxHQUFHO0lBQ1ZDLE1BQWtCO0lBQ2xCQyxTQUFrQjtJQUNsQkMsU0FBa0I7SUFDbEJDLFdBQWtCO0lBQ2xCQyxhQUFrQjtJQUNsQkMsTUFBa0I7SUFDbEJDLEtBQWtCO0lBQ2xCQyxPQUFrQjtJQUNsQkMsVUFBa0I7SUFDbEJDLE1BQWtCO0lBQ2xCQyxZQUFpQjtJQUNqQkMsVUFBaUI7SUFDakJDLE1BQWlCO0lBQ2pCQyxNQUFpQjtJQUNqQkMsVUFBaUI7SUFDakJDLEtBQWlCO0lBQ2pCQyxpQkFBaUI7SUFDakJDLFdBQWlCO0lBQ2pCQyxTQUFpQjtJQUNqQkMsaUJBQWlCO0lBQ2pCQyxXQUFpQjtBQUNuQjtBQUVBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNEN0IsS0FBSzhCLE1BQU0sR0FBRyxTQUFTQyxRQUFRLEVBQUVDLElBQUksRUFBRUMsV0FBVyxFQUFFQyxLQUFLLEVBQUVDLE9BQU87SUFDaEU7Ozs7c0NBSW9DLEdBRXBDLDBC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R1MsSUFBSVgsSUFBSSxLQUFLaEMsS0FBS1EsSUFBSSxDQUFDYSxJQUFJLEVBQUU7WUFDckMsSUFBSTtnQkFDRndILFFBQVEvSSxNQUFNc0MsSUFBSSxDQUFDK0ksVUFBVSxDQUFDeEksSUFBSVQsS0FBSztZQUN6QyxFQUFFLE9BQU1rSixHQUFHO2dCQUNULElBQUdBLEVBQUVDLE9BQU8sS0FBSyxpQkFBaUI7b0JBQ2hDeEMsUUFDRSxPQUFPL0ksTUFBTXNDLElBQUksQ0FBQzZJLFVBQVUsQ0FBQ3RJLElBQUlULEtBQUssSUFBSTtnQkFDOUMsT0FBTztvQkFDTCxNQUFNa0o7Z0JBQ1I7WUFDRjtRQUNGLE9BQU8sSUFBR3pJLElBQUlYLElBQUksS0FBS2hDLEtBQUtRLElBQUksQ0FBQ2lCLGVBQWUsSUFDOUNrQixJQUFJWCxJQUFJLEtBQUtoQyxLQUFLUSxJQUFJLENBQUNvSyxTQUFTLEVBQUU7WUFDbEMvQixRQUFRbEcsSUFBSVQsS0FBSztRQUNuQixPQUFPLElBQUdxSSxlQUFlVyxJQUFJLENBQUN2SSxJQUFJVCxLQUFLLEdBQUc7WUFDeEMyRyxRQUFRLE9BQU8vSSxNQUFNc0MsSUFBSSxDQUFDNkksVUFBVSxDQUFDdEksSUFBSVQsS0FBSztRQUNoRCxPQUFPLElBQUdTLElBQUlULEtBQUssQ0FBQ00sTUFBTSxLQUFLLEdBQUc7WUFDaENxRyxRQUFRO1FBQ1YsT0FBTztZQUNMQSxRQUFRbEcsSUFBSVQsS0FBSztRQUNuQjtJQUNGO0lBRUEsT0FBTzJHO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvYXNuMS5qcz84YTFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBBYnN0cmFjdCBTeW50YXggTm90YXRpb24gTnVtYmVyIE9uZS5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKlxuICogQW4gQVBJIGZvciBzdG9yaW5nIGRhdGEgdXNpbmcgdGhlIEFic3RyYWN0IFN5bnRheCBOb3RhdGlvbiBOdW1iZXIgT25lXG4gKiBmb3JtYXQgdXNpbmcgREVSIChEaXN0aW5ndWlzaGVkIEVuY29kaW5nIFJ1bGVzKSBlbmNvZGluZy4gVGhpcyBlbmNvZGluZyBpc1xuICogY29tbW9ubHkgdXNlZCB0byBzdG9yZSBkYXRhIGZvciBQS0ksIGkuZS4gWC41MDkgQ2VydGlmaWNhdGVzLCBhbmQgdGhpc1xuICogaW1wbGVtZW50YXRpb24gZXhpc3RzIGZvciB0aGF0IHB1cnBvc2UuXG4gKlxuICogQWJzdHJhY3QgU3ludGF4IE5vdGF0aW9uIE51bWJlciBPbmUgKEFTTi4xKSBpcyB1c2VkIHRvIGRlZmluZSB0aGUgYWJzdHJhY3RcbiAqIHN5bnRheCBvZiBpbmZvcm1hdGlvbiB3aXRob3V0IHJlc3RyaWN0aW5nIHRoZSB3YXkgdGhlIGluZm9ybWF0aW9uIGlzIGVuY29kZWRcbiAqIGZvciB0cmFuc21pc3Npb24uIEl0IHByb3ZpZGVzIGEgc3RhbmRhcmQgdGhhdCBhbGxvd3MgZm9yIG9wZW4gc3lzdGVtc1xuICogY29tbXVuaWNhdGlvbi4gQVNOLjEgZGVmaW5lcyB0aGUgc3ludGF4IG9mIGluZm9ybWF0aW9uIGRhdGEgYW5kIGEgbnVtYmVyIG9mXG4gKiBzaW1wbGUgZGF0YSB0eXBlcyBhcyB3ZWxsIGFzIGEgbm90YXRpb24gZm9yIGRlc2NyaWJpbmcgdGhlbSBhbmQgc3BlY2lmeWluZ1xuICogdmFsdWVzIGZvciB0aGVtLlxuICpcbiAqIFRoZSBSU0EgYWxnb3JpdGhtIGNyZWF0ZXMgcHVibGljIGFuZCBwcml2YXRlIGtleXMgdGhhdCBhcmUgb2Z0ZW4gc3RvcmVkIGluXG4gKiBYLjUwOSBvciBQS0NTI1ggZm9ybWF0cyAtLSB3aGljaCB1c2UgQVNOLjEgKGVuY29kZWQgaW4gREVSIGZvcm1hdCkuIFRoaXNcbiAqIGNsYXNzIHByb3ZpZGVzIHRoZSBtb3N0IGJhc2ljIGZ1bmN0aW9uYWxpdHkgcmVxdWlyZWQgdG8gc3RvcmUgYW5kIGxvYWQgRFNBXG4gKiBrZXlzIHRoYXQgYXJlIGVuY29kZWQgYWNjb3JkaW5nIHRvIEFTTi4xLlxuICpcbiAqIFRoZSBtb3N0IGNvbW1vbiBiaW5hcnkgZW5jb2RpbmdzIGZvciBBU04uMSBhcmUgQkVSIChCYXNpYyBFbmNvZGluZyBSdWxlcylcbiAqIGFuZCBERVIgKERpc3Rpbmd1aXNoZWQgRW5jb2RpbmcgUnVsZXMpLiBERVIgaXMganVzdCBhIHN1YnNldCBvZiBCRVIgdGhhdFxuICogaGFzIHN0cmljdGVyIHJlcXVpcmVtZW50cyBmb3IgaG93IGRhdGEgbXVzdCBiZSBlbmNvZGVkLlxuICpcbiAqIEVhY2ggQVNOLjEgc3RydWN0dXJlIGhhcyBhIHRhZyAoYSBieXRlIGlkZW50aWZ5aW5nIHRoZSBBU04uMSBzdHJ1Y3R1cmUgdHlwZSlcbiAqIGFuZCBhIGJ5dGUgYXJyYXkgZm9yIHRoZSB2YWx1ZSBvZiB0aGlzIEFTTjEgc3RydWN0dXJlIHdoaWNoIG1heSBiZSBkYXRhIG9yIGFcbiAqIGxpc3Qgb2YgQVNOLjEgc3RydWN0dXJlcy5cbiAqXG4gKiBFYWNoIEFTTi4xIHN0cnVjdHVyZSB1c2luZyBCRVIgaXMgKFRhZy1MZW5ndGgtVmFsdWUpOlxuICpcbiAqIHwgYnl0ZSAwIHwgYnl0ZXMgWCB8IGJ5dGVzIFkgfFxuICogfC0tLS0tLS0tfC0tLS0tLS0tLXwtLS0tLS0tLS0tXG4gKiB8ICB0YWcgICB8IGxlbmd0aCAgfCAgdmFsdWUgIHxcbiAqXG4gKiBBU04uMSBhbGxvd3MgZm9yIHRhZ3MgdG8gYmUgb2YgXCJIaWdoLXRhZy1udW1iZXIgZm9ybVwiIHdoaWNoIGFsbG93cyBhIHRhZyB0b1xuICogYmUgdHdvIG9yIG1vcmUgb2N0ZXRzLCBidXQgdGhhdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgY2xhc3MuIEEgdGFnIGlzXG4gKiBvbmx5IDEgYnl0ZS4gQml0cyAxLTUgZ2l2ZSB0aGUgdGFnIG51bWJlciAoaWUgdGhlIGRhdGEgdHlwZSB3aXRoaW4gYVxuICogcGFydGljdWxhciAnY2xhc3MnKSwgNiBpbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlIEFTTi4xIHZhbHVlIGlzXG4gKiBjb25zdHJ1Y3RlZCBmcm9tIG90aGVyIEFTTi4xIHZhbHVlcywgYW5kIGJpdHMgNyBhbmQgOCBnaXZlIHRoZSAnY2xhc3MnLiBJZlxuICogYml0cyA3IGFuZCA4IGFyZSBib3RoIHplcm8sIHRoZSBjbGFzcyBpcyBVTklWRVJTQUwuIElmIG9ubHkgYml0IDcgaXMgc2V0LFxuICogdGhlbiB0aGUgY2xhc3MgaXMgQVBQTElDQVRJT04uIElmIG9ubHkgYml0IDggaXMgc2V0LCB0aGVuIHRoZSBjbGFzcyBpc1xuICogQ09OVEVYVF9TUEVDSUZJQy4gSWYgYm90aCBiaXRzIDcgYW5kIDggYXJlIHNldCwgdGhlbiB0aGUgY2xhc3MgaXMgUFJJVkFURS5cbiAqIFRoZSB0YWcgbnVtYmVycyBmb3IgdGhlIGRhdGEgdHlwZXMgZm9yIHRoZSBjbGFzcyBVTklWRVJTQUwgYXJlIGxpc3RlZCBiZWxvdzpcbiAqXG4gKiBVTklWRVJTQUwgMCBSZXNlcnZlZCBmb3IgdXNlIGJ5IHRoZSBlbmNvZGluZyBydWxlc1xuICogVU5JVkVSU0FMIDEgQm9vbGVhbiB0eXBlXG4gKiBVTklWRVJTQUwgMiBJbnRlZ2VyIHR5cGVcbiAqIFVOSVZFUlNBTCAzIEJpdHN0cmluZyB0eXBlXG4gKiBVTklWRVJTQUwgNCBPY3RldHN0cmluZyB0eXBlXG4gKiBVTklWRVJTQUwgNSBOdWxsIHR5cGVcbiAqIFVOSVZFUlNBTCA2IE9iamVjdCBpZGVudGlmaWVyIHR5cGVcbiAqIFVOSVZFUlNBTCA3IE9iamVjdCBkZXNjcmlwdG9yIHR5cGVcbiAqIFVOSVZFUlNBTCA4IEV4dGVybmFsIHR5cGUgYW5kIEluc3RhbmNlLW9mIHR5cGVcbiAqIFVOSVZFUlNBTCA5IFJlYWwgdHlwZVxuICogVU5JVkVSU0FMIDEwIEVudW1lcmF0ZWQgdHlwZVxuICogVU5JVkVSU0FMIDExIEVtYmVkZGVkLXBkdiB0eXBlXG4gKiBVTklWRVJTQUwgMTIgVVRGOFN0cmluZyB0eXBlXG4gKiBVTklWRVJTQUwgMTMgUmVsYXRpdmUgb2JqZWN0IGlkZW50aWZpZXIgdHlwZVxuICogVU5JVkVSU0FMIDE0LTE1IFJlc2VydmVkIGZvciBmdXR1cmUgZWRpdGlvbnNcbiAqIFVOSVZFUlNBTCAxNiBTZXF1ZW5jZSBhbmQgU2VxdWVuY2Utb2YgdHlwZXNcbiAqIFVOSVZFUlNBTCAxNyBTZXQgYW5kIFNldC1vZiB0eXBlc1xuICogVU5JVkVSU0FMIDE4LTIyLCAyNS0zMCBDaGFyYWN0ZXIgc3RyaW5nIHR5cGVzXG4gKiBVTklWRVJTQUwgMjMtMjQgVGltZSB0eXBlc1xuICpcbiAqIFRoZSBsZW5ndGggb2YgYW4gQVNOLjEgc3RydWN0dXJlIGlzIHNwZWNpZmllZCBhZnRlciB0aGUgdGFnIGlkZW50aWZpZXIuXG4gKiBUaGVyZSBpcyBhIGRlZmluaXRlIGZvcm0gYW5kIGFuIGluZGVmaW5pdGUgZm9ybS4gVGhlIGluZGVmaW5pdGUgZm9ybSBtYXlcbiAqIGJlIHVzZWQgaWYgdGhlIGVuY29kaW5nIGlzIGNvbnN0cnVjdGVkIGFuZCBub3QgYWxsIGltbWVkaWF0ZWx5IGF2YWlsYWJsZS5cbiAqIFRoZSBpbmRlZmluaXRlIGZvcm0gaXMgZW5jb2RlZCB1c2luZyBhIGxlbmd0aCBieXRlIHdpdGggb25seSB0aGUgOHRoIGJpdFxuICogc2V0LiBUaGUgZW5kIG9mIHRoZSBjb25zdHJ1Y3RlZCBvYmplY3QgaXMgbWFya2VkIHVzaW5nIGVuZC1vZi1jb250ZW50c1xuICogb2N0ZXRzICh0d28gemVybyBieXRlcykuXG4gKlxuICogVGhlIGRlZmluaXRlIGZvcm0gbG9va3MgbGlrZSB0aGlzOlxuICpcbiAqIFRoZSBsZW5ndGggbWF5IHRha2UgdXAgMSBvciBtb3JlIGJ5dGVzLCBpdCBkZXBlbmRzIG9uIHRoZSBsZW5ndGggb2YgdGhlXG4gKiB2YWx1ZSBvZiB0aGUgQVNOLjEgc3RydWN0dXJlLiBERVIgZW5jb2RpbmcgcmVxdWlyZXMgdGhhdCBpZiB0aGUgQVNOLjFcbiAqIHN0cnVjdHVyZSBoYXMgYSB2YWx1ZSB0aGF0IGhhcyBhIGxlbmd0aCBncmVhdGVyIHRoYW4gMTI3LCBtb3JlIHRoYW4gMSBieXRlXG4gKiB3aWxsIGJlIHVzZWQgdG8gc3RvcmUgaXRzIGxlbmd0aCwgb3RoZXJ3aXNlIGp1c3Qgb25lIGJ5dGUgd2lsbCBiZSB1c2VkLlxuICogVGhpcyBpcyBzdHJpY3QuXG4gKlxuICogSW4gdGhlIGNhc2UgdGhhdCB0aGUgbGVuZ3RoIG9mIHRoZSBBU04uMSB2YWx1ZSBpcyBsZXNzIHRoYW4gMTI3LCAxIG9jdGV0XG4gKiAoYnl0ZSkgaXMgdXNlZCB0byBzdG9yZSB0aGUgXCJzaG9ydCBmb3JtXCIgbGVuZ3RoLiBUaGUgOHRoIGJpdCBoYXMgYSB2YWx1ZSBvZlxuICogMCBpbmRpY2F0aW5nIHRoZSBsZW5ndGggaXMgXCJzaG9ydCBmb3JtXCIgYW5kIG5vdCBcImxvbmcgZm9ybVwiIGFuZCBiaXRzIDctMVxuICogZ2l2ZSB0aGUgbGVuZ3RoIG9mIHRoZSBkYXRhLiAoVGhlIDh0aCBiaXQgaXMgdGhlIGxlZnQtbW9zdCwgbW9zdCBzaWduaWZpY2FudFxuICogYml0OiBhbHNvIGtub3duIGFzIGJpZyBlbmRpYW4gb3IgbmV0d29yayBmb3JtYXQpLlxuICpcbiAqIEluIHRoZSBjYXNlIHRoYXQgdGhlIGxlbmd0aCBvZiB0aGUgQVNOLjEgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIDEyNywgMiB0b1xuICogMTI3IG9jdGV0cyAoYnl0ZXMpIGFyZSB1c2VkIHRvIHN0b3JlIHRoZSBcImxvbmcgZm9ybVwiIGxlbmd0aC4gVGhlIGZpcnN0XG4gKiBieXRlJ3MgOHRoIGJpdCBpcyBzZXQgdG8gMSB0byBpbmRpY2F0ZSB0aGUgbGVuZ3RoIGlzIFwibG9uZyBmb3JtLlwiIEJpdHMgNy0xXG4gKiBnaXZlIHRoZSBudW1iZXIgb2YgYWRkaXRpb25hbCBvY3RldHMuIEFsbCBmb2xsb3dpbmcgb2N0ZXRzIGFyZSBpbiBiYXNlIDI1NlxuICogd2l0aCB0aGUgbW9zdCBzaWduaWZpY2FudCBkaWdpdCBmaXJzdCAodHlwaWNhbCBiaWctZW5kaWFuIGJpbmFyeSB1bnNpZ25lZFxuICogaW50ZWdlciBzdG9yYWdlKS4gU28sIGZvciBpbnN0YW5jZSwgaWYgdGhlIGxlbmd0aCBvZiBhIHZhbHVlIHdhcyAyNTcsIHRoZVxuICogZmlyc3QgYnl0ZSB3b3VsZCBiZSBzZXQgdG86XG4gKlxuICogMTAwMDAwMTAgPSAxMzAgPSAweDgyLlxuICpcbiAqIFRoaXMgaW5kaWNhdGVzIHRoZXJlIGFyZSAyIG9jdGV0cyAoYmFzZSAyNTYpIGZvciB0aGUgbGVuZ3RoLiBUaGUgc2Vjb25kIGFuZFxuICogdGhpcmQgYnl0ZXMgKHRoZSBvY3RldHMganVzdCBtZW50aW9uZWQpIHdvdWxkIHN0b3JlIHRoZSBsZW5ndGggaW4gYmFzZSAyNTY6XG4gKlxuICogb2N0ZXQgMjogMDAwMDAwMDEgPSAxICogMjU2XjEgPSAyNTZcbiAqIG9jdGV0IDM6IDAwMDAwMDAxID0gMSAqIDI1Nl4wID0gMVxuICogdG90YWwgPSAyNTdcbiAqXG4gKiBUaGUgYWxnb3JpdGhtIGZvciBjb252ZXJ0aW5nIGEganMgaW50ZWdlciB2YWx1ZSBvZiAyNTcgdG8gYmFzZS0yNTYgaXM6XG4gKlxuICogdmFyIHZhbHVlID0gMjU3O1xuICogdmFyIGJ5dGVzID0gW107XG4gKiBieXRlc1swXSA9ICh2YWx1ZSA+Pj4gOCkgJiAweEZGOyAvLyBtb3N0IHNpZ25pZmljYW50IGJ5dGUgZmlyc3RcbiAqIGJ5dGVzWzFdID0gdmFsdWUgJiAweEZGOyAgICAgICAgLy8gbGVhc3Qgc2lnbmlmaWNhbnQgYnl0ZSBsYXN0XG4gKlxuICogT24gdGhlIEFTTi4xIFVOSVZFUlNBTCBPYmplY3QgSWRlbnRpZmllciAoT0lEKSB0eXBlOlxuICpcbiAqIEFuIE9JRCBjYW4gYmUgd3JpdHRlbiBsaWtlOiBcInZhbHVlMS52YWx1ZTIudmFsdWUzLi4udmFsdWVOXCJcbiAqXG4gKiBUaGUgREVSIGVuY29kaW5nIHJ1bGVzOlxuICpcbiAqIFRoZSBmaXJzdCBieXRlIGhhcyB0aGUgdmFsdWUgNDAgKiB2YWx1ZTEgKyB2YWx1ZTIuXG4gKiBUaGUgZm9sbG93aW5nIGJ5dGVzLCBpZiBhbnksIGVuY29kZSB0aGUgcmVtYWluaW5nIHZhbHVlcy4gRWFjaCB2YWx1ZSBpc1xuICogZW5jb2RlZCBpbiBiYXNlIDEyOCwgbW9zdCBzaWduaWZpY2FudCBkaWdpdCBmaXJzdCAoYmlnIGVuZGlhbiksIHdpdGggYXNcbiAqIGZldyBkaWdpdHMgYXMgcG9zc2libGUsIGFuZCB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgb2YgZWFjaCBieXRlIHNldFxuICogdG8gMSBleGNlcHQgdGhlIGxhc3QgaW4gZWFjaCB2YWx1ZSdzIGVuY29kaW5nLiBGb3IgZXhhbXBsZTogR2l2ZW4gdGhlXG4gKiBPSUQgXCIxLjIuODQwLjExMzU0OVwiLCBpdHMgREVSIGVuY29kaW5nIGlzIChyZW1lbWJlciBlYWNoIGJ5dGUgZXhjZXB0IHRoZVxuICogbGFzdCBvbmUgaW4gZWFjaCBlbmNvZGluZyBpcyBPUidkIHdpdGggMHg4MCk6XG4gKlxuICogYnl0ZSAxOiA0MCAqIDEgKyAyID0gNDIgPSAweDJBLlxuICogYnl0ZXMgMi0zOiAxMjggKiA2ICsgNzIgPSA4NDAgPSA2IDcyID0gNiA3MiA9IDB4MDY0OCA9IDB4ODY0OFxuICogYnl0ZXMgNC02OiAxNjM4NCAqIDYgKyAxMjggKiAxMTkgKyAxMyA9IDYgMTE5IDEzID0gMHgwNjc3MEQgPSAweDg2RjcwRFxuICpcbiAqIFRoZSBmaW5hbCB2YWx1ZSBpczogMHgyQTg2NDg4NkY3MEQuXG4gKiBUaGUgZnVsbCBPSUQgKGluY2x1ZGluZyBBU04uMSB0YWcgYW5kIGxlbmd0aCBvZiA2IGJ5dGVzKSBpczpcbiAqIDB4MDYwNjJBODY0ODg2RjcwRFxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcbnJlcXVpcmUoJy4vb2lkcycpO1xuXG4vKiBBU04uMSBBUEkgKi9cbnZhciBhc24xID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5hc24xID0gZm9yZ2UuYXNuMSB8fCB7fTtcblxuLyoqXG4gKiBBU04uMSBjbGFzc2VzLlxuICovXG5hc24xLkNsYXNzID0ge1xuICBVTklWRVJTQUw6ICAgICAgICAweDAwLFxuICBBUFBMSUNBVElPTjogICAgICAweDQwLFxuICBDT05URVhUX1NQRUNJRklDOiAweDgwLFxuICBQUklWQVRFOiAgICAgICAgICAweEMwXG59O1xuXG4vKipcbiAqIEFTTi4xIHR5cGVzLiBOb3QgYWxsIHR5cGVzIGFyZSBzdXBwb3J0ZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvbiwgb25seVxuICogdGhvc2UgbmVjZXNzYXJ5IHRvIGltcGxlbWVudCBhIHNpbXBsZSBQS0kgYXJlIGltcGxlbWVudGVkLlxuICovXG5hc24xLlR5cGUgPSB7XG4gIE5PTkU6ICAgICAgICAgICAgIDAsXG4gIEJPT0xFQU46ICAgICAgICAgIDEsXG4gIElOVEVHRVI6ICAgICAgICAgIDIsXG4gIEJJVFNUUklORzogICAgICAgIDMsXG4gIE9DVEVUU1RSSU5HOiAgICAgIDQsXG4gIE5VTEw6ICAgICAgICAgICAgIDUsXG4gIE9JRDogICAgICAgICAgICAgIDYsXG4gIE9ERVNDOiAgICAgICAgICAgIDcsXG4gIEVYVEVSTkFMOiAgICAgICAgIDgsXG4gIFJFQUw6ICAgICAgICAgICAgIDksXG4gIEVOVU1FUkFURUQ6ICAgICAgMTAsXG4gIEVNQkVEREVEOiAgICAgICAgMTEsXG4gIFVURjg6ICAgICAgICAgICAgMTIsXG4gIFJPSUQ6ICAgICAgICAgICAgMTMsXG4gIFNFUVVFTkNFOiAgICAgICAgMTYsXG4gIFNFVDogICAgICAgICAgICAgMTcsXG4gIFBSSU5UQUJMRVNUUklORzogMTksXG4gIElBNVNUUklORzogICAgICAgMjIsXG4gIFVUQ1RJTUU6ICAgICAgICAgMjMsXG4gIEdFTkVSQUxJWkVEVElNRTogMjQsXG4gIEJNUFNUUklORzogICAgICAgMzBcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBhc24xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdGFnQ2xhc3MgdGhlIHRhZyBjbGFzcyBmb3IgdGhlIG9iamVjdC5cbiAqIEBwYXJhbSB0eXBlIHRoZSBkYXRhIHR5cGUgKHRhZyBudW1iZXIpIGZvciB0aGUgb2JqZWN0LlxuICogQHBhcmFtIGNvbnN0cnVjdGVkIHRydWUgaWYgdGhlIGFzbjEgb2JqZWN0IGlzIGluIGNvbnN0cnVjdGVkIGZvcm0uXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIGZvciB0aGUgb2JqZWN0LCBpZiBpdCBpcyBub3QgY29uc3RydWN0ZWQuXG4gKiBAcGFyYW0gW29wdGlvbnNdIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIFtiaXRTdHJpbmdDb250ZW50c10gdGhlIHBsYWluIEJJVCBTVFJJTkcgY29udGVudCBpbmNsdWRpbmcgcGFkZGluZ1xuICogICAgICAgICAgICBieXRlLlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgb2JqZWN0LlxuICovXG5hc24xLmNyZWF0ZSA9IGZ1bmN0aW9uKHRhZ0NsYXNzLCB0eXBlLCBjb25zdHJ1Y3RlZCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgLyogQW4gYXNuMSBvYmplY3QgaGFzIGEgdGFnQ2xhc3MsIGEgdHlwZSwgYSBjb25zdHJ1Y3RlZCBmbGFnLCBhbmQgYVxuICAgIHZhbHVlLiBUaGUgdmFsdWUncyB0eXBlIGRlcGVuZHMgb24gdGhlIGNvbnN0cnVjdGVkIGZsYWcuIElmXG4gICAgY29uc3RydWN0ZWQsIGl0IHdpbGwgY29udGFpbiBhIGxpc3Qgb2Ygb3RoZXIgYXNuMSBvYmplY3RzLiBJZiBub3QsXG4gICAgaXQgd2lsbCBjb250YWluIHRoZSBBU04uMSB2YWx1ZSBhcyBhbiBhcnJheSBvZiBieXRlcyBmb3JtYXR0ZWRcbiAgICBhY2NvcmRpbmcgdG8gdGhlIEFTTi4xIGRhdGEgdHlwZS4gKi9cblxuICAvLyByZW1vdmUgdW5kZWZpbmVkIHZhbHVlc1xuICBpZihmb3JnZS51dGlsLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIHRtcCA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYodmFsdWVbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0bXAucHVzaCh2YWx1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhbHVlID0gdG1wO1xuICB9XG5cbiAgdmFyIG9iaiA9IHtcbiAgICB0YWdDbGFzczogdGFnQ2xhc3MsXG4gICAgdHlwZTogdHlwZSxcbiAgICBjb25zdHJ1Y3RlZDogY29uc3RydWN0ZWQsXG4gICAgY29tcG9zZWQ6IGNvbnN0cnVjdGVkIHx8IGZvcmdlLnV0aWwuaXNBcnJheSh2YWx1ZSksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG4gIGlmKG9wdGlvbnMgJiYgJ2JpdFN0cmluZ0NvbnRlbnRzJyBpbiBvcHRpb25zKSB7XG4gICAgLy8gVE9ETzogY29weSBieXRlIGJ1ZmZlciBpZiBpdCdzIGEgYnVmZmVyIG5vdCBhIHN0cmluZ1xuICAgIG9iai5iaXRTdHJpbmdDb250ZW50cyA9IG9wdGlvbnMuYml0U3RyaW5nQ29udGVudHM7XG4gICAgLy8gVE9ETzogYWRkIHJlYWRvbmx5IGZsYWcgdG8gYXZvaWQgdGhpcyBvdmVyaGVhZFxuICAgIC8vIHNhdmUgY29weSB0byBkZXRlY3QgY2hhbmdlc1xuICAgIG9iai5vcmlnaW5hbCA9IGFzbjEuY29weShvYmopO1xuICB9XG4gIHJldHVybiBvYmo7XG59O1xuXG4vKipcbiAqIENvcGllcyBhbiBhc24xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBhc24xIG9iamVjdC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gY29weSBvcHRpb25zOlxuICogICAgICAgICAgW2V4Y2x1ZGVCaXRTdHJpbmdDb250ZW50c10gdHJ1ZSB0byBub3QgY29weSBiaXRTdHJpbmdDb250ZW50c1xuICpcbiAqIEByZXR1cm4gdGhlIGEgY29weSBvZiB0aGUgYXNuMSBvYmplY3QuXG4gKi9cbmFzbjEuY29weSA9IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucykge1xuICB2YXIgY29weTtcblxuICBpZihmb3JnZS51dGlsLmlzQXJyYXkob2JqKSkge1xuICAgIGNvcHkgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb3B5LnB1c2goYXNuMS5jb3B5KG9ialtpXSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbiAgfVxuXG4gIGlmKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gVE9ETzogY29weSBieXRlIGJ1ZmZlciBpZiBpdCdzIGEgYnVmZmVyIG5vdCBhIHN0cmluZ1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBjb3B5ID0ge1xuICAgIHRhZ0NsYXNzOiBvYmoudGFnQ2xhc3MsXG4gICAgdHlwZTogb2JqLnR5cGUsXG4gICAgY29uc3RydWN0ZWQ6IG9iai5jb25zdHJ1Y3RlZCxcbiAgICBjb21wb3NlZDogb2JqLmNvbXBvc2VkLFxuICAgIHZhbHVlOiBhc24xLmNvcHkob2JqLnZhbHVlLCBvcHRpb25zKVxuICB9O1xuICBpZihvcHRpb25zICYmICFvcHRpb25zLmV4Y2x1ZGVCaXRTdHJpbmdDb250ZW50cykge1xuICAgIC8vIFRPRE86IGNvcHkgYnl0ZSBidWZmZXIgaWYgaXQncyBhIGJ1ZmZlciBub3QgYSBzdHJpbmdcbiAgICBjb3B5LmJpdFN0cmluZ0NvbnRlbnRzID0gb2JqLmJpdFN0cmluZ0NvbnRlbnRzO1xuICB9XG4gIHJldHVybiBjb3B5O1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyBhc24xIG9iamVjdHMgZm9yIGVxdWFsaXR5LlxuICpcbiAqIE5vdGUgdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBydW4gaW4gY29uc3RhbnQgdGltZS5cbiAqXG4gKiBAcGFyYW0gb2JqMSB0aGUgZmlyc3QgYXNuMSBvYmplY3QuXG4gKiBAcGFyYW0gb2JqMiB0aGUgc2Vjb25kIGFzbjEgb2JqZWN0LlxuICogQHBhcmFtIFtvcHRpb25zXSBjb21wYXJlIG9wdGlvbnM6XG4gKiAgICAgICAgICBbaW5jbHVkZUJpdFN0cmluZ0NvbnRlbnRzXSB0cnVlIHRvIGNvbXBhcmUgYml0U3RyaW5nQ29udGVudHNcbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIGFzbjEgb2JqZWN0cyBhcmUgZXF1YWwuXG4gKi9cbmFzbjEuZXF1YWxzID0gZnVuY3Rpb24ob2JqMSwgb2JqMiwgb3B0aW9ucykge1xuICBpZihmb3JnZS51dGlsLmlzQXJyYXkob2JqMSkpIHtcbiAgICBpZighZm9yZ2UudXRpbC5pc0FycmF5KG9iajIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmKG9iajEubGVuZ3RoICE9PSBvYmoyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgb2JqMS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYoIWFzbjEuZXF1YWxzKG9iajFbaV0sIG9iajJbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZih0eXBlb2Ygb2JqMSAhPT0gdHlwZW9mIG9iajIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZih0eXBlb2Ygb2JqMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gb2JqMSA9PT0gb2JqMjtcbiAgfVxuXG4gIHZhciBlcXVhbCA9IG9iajEudGFnQ2xhc3MgPT09IG9iajIudGFnQ2xhc3MgJiZcbiAgICBvYmoxLnR5cGUgPT09IG9iajIudHlwZSAmJlxuICAgIG9iajEuY29uc3RydWN0ZWQgPT09IG9iajIuY29uc3RydWN0ZWQgJiZcbiAgICBvYmoxLmNvbXBvc2VkID09PSBvYmoyLmNvbXBvc2VkICYmXG4gICAgYXNuMS5lcXVhbHMob2JqMS52YWx1ZSwgb2JqMi52YWx1ZSk7XG4gIGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5pbmNsdWRlQml0U3RyaW5nQ29udGVudHMpIHtcbiAgICBlcXVhbCA9IGVxdWFsICYmIChvYmoxLmJpdFN0cmluZ0NvbnRlbnRzID09PSBvYmoyLmJpdFN0cmluZ0NvbnRlbnRzKTtcbiAgfVxuXG4gIHJldHVybiBlcXVhbDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgbGVuZ3RoIG9mIGEgQkVSLWVuY29kZWQgQVNOLjEgdmFsdWUuXG4gKlxuICogSW4gY2FzZSB0aGUgbGVuZ3RoIGlzIG5vdCBzcGVjaWZpZWQsIHVuZGVmaW5lZCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gYiB0aGUgQkVSLWVuY29kZWQgQVNOLjEgYnl0ZSBidWZmZXIsIHN0YXJ0aW5nIHdpdGggdGhlIGZpcnN0XG4gKiAgICAgICAgICBsZW5ndGggYnl0ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIEJFUi1lbmNvZGVkIEFTTi4xIHZhbHVlIG9yIHVuZGVmaW5lZC5cbiAqL1xuYXNuMS5nZXRCZXJWYWx1ZUxlbmd0aCA9IGZ1bmN0aW9uKGIpIHtcbiAgLy8gVE9ETzogbW92ZSB0aGlzIGZ1bmN0aW9uIGFuZCByZWxhdGVkIERFUi9CRVIgZnVuY3Rpb25zIHRvIGEgZGVyLmpzXG4gIC8vIGZpbGU7IGJldHRlciBhYnN0cmFjdCBBU04uMSBhd2F5IGZyb20gZGVyL2Jlci5cbiAgdmFyIGIyID0gYi5nZXRCeXRlKCk7XG4gIGlmKGIyID09PSAweDgwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIHNlZSBpZiB0aGUgbGVuZ3RoIGlzIFwic2hvcnQgZm9ybVwiIG9yIFwibG9uZyBmb3JtXCIgKGJpdCA4IHNldClcbiAgdmFyIGxlbmd0aDtcbiAgdmFyIGxvbmdGb3JtID0gYjIgJiAweDgwO1xuICBpZighbG9uZ0Zvcm0pIHtcbiAgICAvLyBsZW5ndGggaXMganVzdCB0aGUgZmlyc3QgYnl0ZVxuICAgIGxlbmd0aCA9IGIyO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGxlbmd0aCBpcyBzcGVjaWZpZWQgaW4gYml0cyA3IHRocm91Z2ggMVxuICAgIC8vIGFuZCBlYWNoIGxlbmd0aCBieXRlIGlzIGluIGJpZy1lbmRpYW4gYmFzZS0yNTZcbiAgICBsZW5ndGggPSBiLmdldEludCgoYjIgJiAweDdGKSA8PCAzKTtcbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYnl0ZSBidWZmZXIgaGFzIGVub3VnaCBieXRlcy4gVGhyb3dzIGFuIEVycm9yIGlmIG5vdC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyIHRvIHBhcnNlIGZyb20uXG4gKiBAcGFyYW0gcmVtYWluaW5nIHRoZSBieXRlcyByZW1haW5pbmcgaW4gdGhlIGN1cnJlbnQgcGFyc2luZyBzdGF0ZS5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGJ1ZmZlciBtdXN0IGhhdmUuXG4gKi9cbmZ1bmN0aW9uIF9jaGVja0J1ZmZlckxlbmd0aChieXRlcywgcmVtYWluaW5nLCBuKSB7XG4gIGlmKG4gPiByZW1haW5pbmcpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1RvbyBmZXcgYnl0ZXMgdG8gcGFyc2UgREVSLicpO1xuICAgIGVycm9yLmF2YWlsYWJsZSA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgIGVycm9yLnJlbWFpbmluZyA9IHJlbWFpbmluZztcbiAgICBlcnJvci5yZXF1ZXN0ZWQgPSBuO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGVuZ3RoIG9mIGEgQkVSLWVuY29kZWQgQVNOLjEgdmFsdWUuXG4gKlxuICogSW4gY2FzZSB0aGUgbGVuZ3RoIGlzIG5vdCBzcGVjaWZpZWQsIHVuZGVmaW5lZCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyIHRvIHBhcnNlIGZyb20uXG4gKiBAcGFyYW0gcmVtYWluaW5nIHRoZSBieXRlcyByZW1haW5pbmcgaW4gdGhlIGN1cnJlbnQgcGFyc2luZyBzdGF0ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIEJFUi1lbmNvZGVkIEFTTi4xIHZhbHVlIG9yIHVuZGVmaW5lZC5cbiAqL1xudmFyIF9nZXRWYWx1ZUxlbmd0aCA9IGZ1bmN0aW9uKGJ5dGVzLCByZW1haW5pbmcpIHtcbiAgLy8gVE9ETzogbW92ZSB0aGlzIGZ1bmN0aW9uIGFuZCByZWxhdGVkIERFUi9CRVIgZnVuY3Rpb25zIHRvIGEgZGVyLmpzXG4gIC8vIGZpbGU7IGJldHRlciBhYnN0cmFjdCBBU04uMSBhd2F5IGZyb20gZGVyL2Jlci5cbiAgLy8gZnJvbURlciBhbHJlYWR5IGNoZWNrZWQgdGhhdCB0aGlzIGJ5dGUgZXhpc3RzXG4gIHZhciBiMiA9IGJ5dGVzLmdldEJ5dGUoKTtcbiAgcmVtYWluaW5nLS07XG4gIGlmKGIyID09PSAweDgwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIHNlZSBpZiB0aGUgbGVuZ3RoIGlzIFwic2hvcnQgZm9ybVwiIG9yIFwibG9uZyBmb3JtXCIgKGJpdCA4IHNldClcbiAgdmFyIGxlbmd0aDtcbiAgdmFyIGxvbmdGb3JtID0gYjIgJiAweDgwO1xuICBpZighbG9uZ0Zvcm0pIHtcbiAgICAvLyBsZW5ndGggaXMganVzdCB0aGUgZmlyc3QgYnl0ZVxuICAgIGxlbmd0aCA9IGIyO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGxlbmd0aCBpcyBzcGVjaWZpZWQgaW4gYml0cyA3IHRocm91Z2ggMVxuICAgIC8vIGFuZCBlYWNoIGxlbmd0aCBieXRlIGlzIGluIGJpZy1lbmRpYW4gYmFzZS0yNTZcbiAgICB2YXIgbG9uZ0Zvcm1CeXRlcyA9IGIyICYgMHg3RjtcbiAgICBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgbG9uZ0Zvcm1CeXRlcyk7XG4gICAgbGVuZ3RoID0gYnl0ZXMuZ2V0SW50KGxvbmdGb3JtQnl0ZXMgPDwgMyk7XG4gIH1cbiAgLy8gRklYTUU6IHRoaXMgd2lsbCBvbmx5IGhhcHBlbiBmb3IgMzIgYml0IGdldEludCB3aXRoIGhpZ2ggYml0IHNldFxuICBpZihsZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOZWdhdGl2ZSBsZW5ndGg6ICcgKyBsZW5ndGgpO1xuICB9XG4gIHJldHVybiBsZW5ndGg7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhbiBhc24xIG9iamVjdCBmcm9tIGEgYnl0ZSBidWZmZXIgaW4gREVSIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyIHRvIHBhcnNlIGZyb20uXG4gKiBAcGFyYW0gW3N0cmljdF0gdHJ1ZSB0byBiZSBzdHJpY3Qgd2hlbiBjaGVja2luZyB2YWx1ZSBsZW5ndGhzLCBmYWxzZSB0b1xuICogICAgICAgICAgYWxsb3cgdHJ1bmNhdGVkIHZhbHVlcyAoZGVmYXVsdDogdHJ1ZSkuXG4gKiBAcGFyYW0gW29wdGlvbnNdIG9iamVjdCB3aXRoIG9wdGlvbnMgb3IgYm9vbGVhbiBzdHJpY3QgZmxhZ1xuICogICAgICAgICAgW3N0cmljdF0gdHJ1ZSB0byBiZSBzdHJpY3Qgd2hlbiBjaGVja2luZyB2YWx1ZSBsZW5ndGhzLCBmYWxzZSB0b1xuICogICAgICAgICAgICBhbGxvdyB0cnVuY2F0ZWQgdmFsdWVzIChkZWZhdWx0OiB0cnVlKS5cbiAqICAgICAgICAgIFtwYXJzZUFsbEJ5dGVzXSB0cnVlIHRvIGVuc3VyZSBhbGwgYnl0ZXMgYXJlIHBhcnNlZFxuICogICAgICAgICAgICAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgICAgIFtkZWNvZGVCaXRTdHJpbmdzXSB0cnVlIHRvIGF0dGVtcHQgdG8gZGVjb2RlIHRoZSBjb250ZW50IG9mXG4gKiAgICAgICAgICAgIEJJVCBTVFJJTkdzIChub3QgT0NURVQgU1RSSU5HcykgdXNpbmcgc3RyaWN0IG1vZGUuIE5vdGUgdGhhdFxuICogICAgICAgICAgICB3aXRob3V0IHNjaGVtYSBzdXBwb3J0IHRvIHVuZGVyc3RhbmQgdGhlIGRhdGEgY29udGV4dCB0aGlzIGNhblxuICogICAgICAgICAgICBlcnJvbmVvdXNseSBkZWNvZGUgdmFsdWVzIHRoYXQgaGFwcGVuIHRvIGJlIHZhbGlkIEFTTi4xLiBUaGlzXG4gKiAgICAgICAgICAgIGZsYWcgd2lsbCBiZSBkZXByZWNhdGVkIG9yIHJlbW92ZWQgYXMgc29vbiBhcyBzY2hlbWEgc3VwcG9ydCBpc1xuICogICAgICAgICAgICBhdmFpbGFibGUuIChkZWZhdWx0OiB0cnVlKVxuICpcbiAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBmb3IgdmFyaW91cyBtYWxmb3JtZWQgaW5wdXQgY29uZGl0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwYXJzZWQgYXNuMSBvYmplY3QuXG4gKi9cbmFzbjEuZnJvbURlciA9IGZ1bmN0aW9uKGJ5dGVzLCBvcHRpb25zKSB7XG4gIGlmKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICBwYXJzZUFsbEJ5dGVzOiB0cnVlLFxuICAgICAgZGVjb2RlQml0U3RyaW5nczogdHJ1ZVxuICAgIH07XG4gIH1cbiAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBzdHJpY3Q6IG9wdGlvbnMsXG4gICAgICBwYXJzZUFsbEJ5dGVzOiB0cnVlLFxuICAgICAgZGVjb2RlQml0U3RyaW5nczogdHJ1ZVxuICAgIH07XG4gIH1cbiAgaWYoISgnc3RyaWN0JyBpbiBvcHRpb25zKSkge1xuICAgIG9wdGlvbnMuc3RyaWN0ID0gdHJ1ZTtcbiAgfVxuICBpZighKCdwYXJzZUFsbEJ5dGVzJyBpbiBvcHRpb25zKSkge1xuICAgIG9wdGlvbnMucGFyc2VBbGxCeXRlcyA9IHRydWU7XG4gIH1cbiAgaWYoISgnZGVjb2RlQml0U3RyaW5ncycgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmRlY29kZUJpdFN0cmluZ3MgPSB0cnVlO1xuICB9XG5cbiAgLy8gd3JhcCBpbiBidWZmZXIgaWYgbmVlZGVkXG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKTtcbiAgfVxuXG4gIHZhciBieXRlQ291bnQgPSBieXRlcy5sZW5ndGgoKTtcbiAgdmFyIHZhbHVlID0gX2Zyb21EZXIoYnl0ZXMsIGJ5dGVzLmxlbmd0aCgpLCAwLCBvcHRpb25zKTtcbiAgaWYob3B0aW9ucy5wYXJzZUFsbEJ5dGVzICYmIGJ5dGVzLmxlbmd0aCgpICE9PSAwKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdVbnBhcnNlZCBERVIgYnl0ZXMgcmVtYWluIGFmdGVyIEFTTi4xIHBhcnNpbmcuJyk7XG4gICAgZXJyb3IuYnl0ZUNvdW50ID0gYnl0ZUNvdW50O1xuICAgIGVycm9yLnJlbWFpbmluZyA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gcGFyc2UgYW4gYXNuMSBvYmplY3QgZnJvbSBhIGJ5dGUgYnVmZmVyIGluIERFUiBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byBwYXJzZSBmcm9tLlxuICogQHBhcmFtIHJlbWFpbmluZyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHJlbWFpbmluZyBmb3IgdGhpcyBjaHVuay5cbiAqIEBwYXJhbSBkZXB0aCB0aGUgY3VycmVudCBwYXJzaW5nIGRlcHRoLlxuICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHdpdGggc2FtZSBvcHRpb25zIGFzIGZyb21EZXIoKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwYXJzZWQgYXNuMSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIF9mcm9tRGVyKGJ5dGVzLCByZW1haW5pbmcsIGRlcHRoLCBvcHRpb25zKSB7XG4gIC8vIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb25zdW1wdGlvbiBjYWxjdWxhdGlvbnNcbiAgdmFyIHN0YXJ0O1xuXG4gIC8vIG1pbmltdW0gbGVuZ3RoIGZvciBBU04uMSBERVIgc3RydWN0dXJlIGlzIDJcbiAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIDIpO1xuXG4gIC8vIGdldCB0aGUgZmlyc3QgYnl0ZVxuICB2YXIgYjEgPSBieXRlcy5nZXRCeXRlKCk7XG4gIC8vIGNvbnN1bWVkIG9uZSBieXRlXG4gIHJlbWFpbmluZy0tO1xuXG4gIC8vIGdldCB0aGUgdGFnIGNsYXNzXG4gIHZhciB0YWdDbGFzcyA9IChiMSAmIDB4QzApO1xuXG4gIC8vIGdldCB0aGUgdHlwZSAoYml0cyAxLTUpXG4gIHZhciB0eXBlID0gYjEgJiAweDFGO1xuXG4gIC8vIGdldCB0aGUgdmFyaWFibGUgdmFsdWUgbGVuZ3RoIGFuZCBhZGp1c3QgcmVtYWluaW5nIGJ5dGVzXG4gIHN0YXJ0ID0gYnl0ZXMubGVuZ3RoKCk7XG4gIHZhciBsZW5ndGggPSBfZ2V0VmFsdWVMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZyk7XG4gIHJlbWFpbmluZyAtPSBzdGFydCAtIGJ5dGVzLmxlbmd0aCgpO1xuXG4gIC8vIGVuc3VyZSB0aGVyZSBhcmUgZW5vdWdoIGJ5dGVzIHRvIGdldCB0aGUgdmFsdWVcbiAgaWYobGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgbGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgaWYob3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVG9vIGZldyBieXRlcyB0byByZWFkIEFTTi4xIHZhbHVlLicpO1xuICAgICAgZXJyb3IuYXZhaWxhYmxlID0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICBlcnJvci5yZW1haW5pbmcgPSByZW1haW5pbmc7XG4gICAgICBlcnJvci5yZXF1ZXN0ZWQgPSBsZW5ndGg7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgLy8gTm90ZTogYmUgbGVuaWVudCB3aXRoIHRydW5jYXRlZCB2YWx1ZXMgYW5kIHVzZSByZW1haW5pbmcgc3RhdGUgYnl0ZXNcbiAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gIH1cblxuICAvLyB2YWx1ZSBzdG9yYWdlXG4gIHZhciB2YWx1ZTtcbiAgLy8gcG9zc2libGUgQklUIFNUUklORyBjb250ZW50cyBzdG9yYWdlXG4gIHZhciBiaXRTdHJpbmdDb250ZW50cztcblxuICAvLyBjb25zdHJ1Y3RlZCBmbGFnIGlzIGJpdCA2ICgzMiA9IDB4MjApIG9mIHRoZSBmaXJzdCBieXRlXG4gIHZhciBjb25zdHJ1Y3RlZCA9ICgoYjEgJiAweDIwKSA9PT0gMHgyMCk7XG4gIGlmKGNvbnN0cnVjdGVkKSB7XG4gICAgLy8gcGFyc2UgY2hpbGQgYXNuMSBvYmplY3RzIGZyb20gdGhlIHZhbHVlXG4gICAgdmFsdWUgPSBbXTtcbiAgICBpZihsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gYXNuMSBvYmplY3Qgb2YgaW5kZWZpbml0ZSBsZW5ndGgsIHJlYWQgdW50aWwgZW5kIHRhZ1xuICAgICAgZm9yKDs7KSB7XG4gICAgICAgIF9jaGVja0J1ZmZlckxlbmd0aChieXRlcywgcmVtYWluaW5nLCAyKTtcbiAgICAgICAgaWYoYnl0ZXMuYnl0ZXMoMikgPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMCwgMCkpIHtcbiAgICAgICAgICBieXRlcy5nZXRCeXRlcygyKTtcbiAgICAgICAgICByZW1haW5pbmcgLT0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGFydCA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICB2YWx1ZS5wdXNoKF9mcm9tRGVyKGJ5dGVzLCByZW1haW5pbmcsIGRlcHRoICsgMSwgb3B0aW9ucykpO1xuICAgICAgICByZW1haW5pbmcgLT0gc3RhcnQgLSBieXRlcy5sZW5ndGgoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcGFyc2luZyBhc24xIG9iamVjdCBvZiBkZWZpbml0ZSBsZW5ndGhcbiAgICAgIHdoaWxlKGxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RhcnQgPSBieXRlcy5sZW5ndGgoKTtcbiAgICAgICAgdmFsdWUucHVzaChfZnJvbURlcihieXRlcywgbGVuZ3RoLCBkZXB0aCArIDEsIG9wdGlvbnMpKTtcbiAgICAgICAgcmVtYWluaW5nIC09IHN0YXJ0IC0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICAgIGxlbmd0aCAtPSBzdGFydCAtIGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGlmIGEgQklUIFNUUklORywgc2F2ZSB0aGUgY29udGVudHMgaW5jbHVkaW5nIHBhZGRpbmdcbiAgaWYodmFsdWUgPT09IHVuZGVmaW5lZCAmJiB0YWdDbGFzcyA9PT0gYXNuMS5DbGFzcy5VTklWRVJTQUwgJiZcbiAgICB0eXBlID09PSBhc24xLlR5cGUuQklUU1RSSU5HKSB7XG4gICAgYml0U3RyaW5nQ29udGVudHMgPSBieXRlcy5ieXRlcyhsZW5ndGgpO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGlmIGEgbm9uLWNvbnN0cnVjdGVkIHZhbHVlIHNob3VsZCBiZSBkZWNvZGVkIGFzIGEgY29tcG9zZWRcbiAgLy8gdmFsdWUgdGhhdCBjb250YWlucyBvdGhlciBBU04uMSBvYmplY3RzLiBCSVQgU1RSSU5HcyAoYW5kIE9DVEVUIFNUUklOR3MpXG4gIC8vIGNhbiBiZSB1c2VkIHRoaXMgd2F5LlxuICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuZGVjb2RlQml0U3RyaW5ncyAmJlxuICAgIHRhZ0NsYXNzID09PSBhc24xLkNsYXNzLlVOSVZFUlNBTCAmJlxuICAgIC8vIEZJWE1FOiBPQ1RFVCBTVFJJTkdzIG5vdCB5ZXQgc3VwcG9ydGVkIGhlcmVcbiAgICAvLyAuLiBvdGhlciBwYXJ0cyBvZiBmb3JnZSBleHBlY3QgdG8gZGVjb2RlIE9DVEVUIFNUUklOR3MgbWFudWFsbHlcbiAgICAodHlwZSA9PT0gYXNuMS5UeXBlLkJJVFNUUklORyAvKnx8IHR5cGUgPT09IGFzbjEuVHlwZS5PQ1RFVFNUUklORyovKSAmJlxuICAgIGxlbmd0aCA+IDEpIHtcbiAgICAvLyBzYXZlIHJlYWQgcG9zaXRpb25cbiAgICB2YXIgc2F2ZWRSZWFkID0gYnl0ZXMucmVhZDtcbiAgICB2YXIgc2F2ZWRSZW1haW5pbmcgPSByZW1haW5pbmc7XG4gICAgdmFyIHVudXNlZCA9IDA7XG4gICAgaWYodHlwZSA9PT0gYXNuMS5UeXBlLkJJVFNUUklORykge1xuICAgICAgLyogVGhlIGZpcnN0IG9jdGV0IGdpdmVzIHRoZSBudW1iZXIgb2YgYml0cyBieSB3aGljaCB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgICAgICBiaXQgc3RyaW5nIGlzIGxlc3MgdGhhbiB0aGUgbmV4dCBtdWx0aXBsZSBvZiBlaWdodCAodGhpcyBpcyBjYWxsZWRcbiAgICAgICAgdGhlIFwibnVtYmVyIG9mIHVudXNlZCBiaXRzXCIpLlxuXG4gICAgICAgIFRoZSBzZWNvbmQgYW5kIGZvbGxvd2luZyBvY3RldHMgZ2l2ZSB0aGUgdmFsdWUgb2YgdGhlIGJpdCBzdHJpbmdcbiAgICAgICAgY29udmVydGVkIHRvIGFuIG9jdGV0IHN0cmluZy4gKi9cbiAgICAgIF9jaGVja0J1ZmZlckxlbmd0aChieXRlcywgcmVtYWluaW5nLCAxKTtcbiAgICAgIHVudXNlZCA9IGJ5dGVzLmdldEJ5dGUoKTtcbiAgICAgIHJlbWFpbmluZy0tO1xuICAgIH1cbiAgICAvLyBpZiBhbGwgYml0cyBhcmUgdXNlZCwgbWF5YmUgdGhlIEJJVC9PQ1RFVCBTVFJJTkcgaG9sZHMgQVNOLjEgb2Jqc1xuICAgIGlmKHVudXNlZCA9PT0gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gYXR0ZW1wdCB0byBwYXJzZSBjaGlsZCBhc24xIG9iamVjdCBmcm9tIHRoZSB2YWx1ZVxuICAgICAgICAvLyAoc3RvcmVkIGluIGFycmF5IHRvIHNpZ25hbCBjb21wb3NlZCB2YWx1ZSlcbiAgICAgICAgc3RhcnQgPSBieXRlcy5sZW5ndGgoKTtcbiAgICAgICAgdmFyIHN1Yk9wdGlvbnMgPSB7XG4gICAgICAgICAgLy8gZW5mb3JjZSBzdHJpY3QgbW9kZSB0byBhdm9pZCBwYXJzaW5nIEFTTi4xIGZyb20gcGxhaW4gZGF0YVxuICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICBkZWNvZGVCaXRTdHJpbmdzOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb21wb3NlZCA9IF9mcm9tRGVyKGJ5dGVzLCByZW1haW5pbmcsIGRlcHRoICsgMSwgc3ViT3B0aW9ucyk7XG4gICAgICAgIHZhciB1c2VkID0gc3RhcnQgLSBieXRlcy5sZW5ndGgoKTtcbiAgICAgICAgcmVtYWluaW5nIC09IHVzZWQ7XG4gICAgICAgIGlmKHR5cGUgPT0gYXNuMS5UeXBlLkJJVFNUUklORykge1xuICAgICAgICAgIHVzZWQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBkYXRhIGFsbCBkZWNvZGVkIGFuZCB0aGUgY2xhc3MgaW5kaWNhdGVzIFVOSVZFUlNBTCBvclxuICAgICAgICAvLyBDT05URVhUX1NQRUNJRklDIHRoZW4gYXNzdW1lIHdlJ3ZlIGdvdCBhbiBlbmNhcHN1bGF0ZWQgQVNOLjEgb2JqZWN0XG4gICAgICAgIHZhciB0YyA9IGNvbXBvc2VkLnRhZ0NsYXNzO1xuICAgICAgICBpZih1c2VkID09PSBsZW5ndGggJiZcbiAgICAgICAgICAodGMgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8IHRjID09PSBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMpKSB7XG4gICAgICAgICAgdmFsdWUgPSBbY29tcG9zZWRdO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJlc3RvcmUgcmVhZCBwb3NpdGlvblxuICAgICAgYnl0ZXMucmVhZCA9IHNhdmVkUmVhZDtcbiAgICAgIHJlbWFpbmluZyA9IHNhdmVkUmVtYWluaW5nO1xuICAgIH1cbiAgfVxuXG4gIGlmKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBhc24xIG5vdCBjb25zdHJ1Y3RlZCBvciBjb21wb3NlZCwgZ2V0IHJhdyB2YWx1ZVxuICAgIC8vIFRPRE86IGRvIERFUiB0byBPSUQgY29udmVyc2lvbiBhbmQgdmljZS12ZXJzYSBpbiAudG9EZXI/XG5cbiAgICBpZihsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYob3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24tY29uc3RydWN0ZWQgQVNOLjEgb2JqZWN0IG9mIGluZGVmaW5pdGUgbGVuZ3RoLicpO1xuICAgICAgfVxuICAgICAgLy8gYmUgbGVuaWVudCBhbmQgdXNlIHJlbWFpbmluZyBzdGF0ZSBieXRlc1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cblxuICAgIGlmKHR5cGUgPT09IGFzbjEuVHlwZS5CTVBTVFJJTkcpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgICBmb3IoOyBsZW5ndGggPiAwOyBsZW5ndGggLT0gMikge1xuICAgICAgICBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgMik7XG4gICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXMuZ2V0SW50MTYoKSk7XG4gICAgICAgIHJlbWFpbmluZyAtPSAyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGJ5dGVzLmdldEJ5dGVzKGxlbmd0aCk7XG4gICAgICByZW1haW5pbmcgLT0gbGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCBCSVQgU1RSSU5HIGNvbnRlbnRzIGlmIGF2YWlsYWJsZVxuICB2YXIgYXNuMU9wdGlvbnMgPSBiaXRTdHJpbmdDb250ZW50cyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHtcbiAgICBiaXRTdHJpbmdDb250ZW50czogYml0U3RyaW5nQ29udGVudHNcbiAgfTtcblxuICAvLyBjcmVhdGUgYW5kIHJldHVybiBhc24xIG9iamVjdFxuICByZXR1cm4gYXNuMS5jcmVhdGUodGFnQ2xhc3MsIHR5cGUsIGNvbnN0cnVjdGVkLCB2YWx1ZSwgYXNuMU9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBhc24xIG9iamVjdCB0byBhIGJ1ZmZlciBvZiBieXRlcyBpbiBERVIgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBhc24xIHRoZSBhc24xIG9iamVjdCB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ1ZmZlciBvZiBieXRlcy5cbiAqL1xuYXNuMS50b0RlciA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgYnl0ZXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIGJ1aWxkIHRoZSBmaXJzdCBieXRlXG4gIHZhciBiMSA9IG9iai50YWdDbGFzcyB8IG9iai50eXBlO1xuXG4gIC8vIGZvciBzdG9yaW5nIHRoZSBBU04uMSB2YWx1ZVxuICB2YXIgdmFsdWUgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIHVzZSBCSVQgU1RSSU5HIGNvbnRlbnRzIGlmIGF2YWlsYWJsZSBhbmQgZGF0YSBub3QgY2hhbmdlZFxuICB2YXIgdXNlQml0U3RyaW5nQ29udGVudHMgPSBmYWxzZTtcbiAgaWYoJ2JpdFN0cmluZ0NvbnRlbnRzJyBpbiBvYmopIHtcbiAgICB1c2VCaXRTdHJpbmdDb250ZW50cyA9IHRydWU7XG4gICAgaWYob2JqLm9yaWdpbmFsKSB7XG4gICAgICB1c2VCaXRTdHJpbmdDb250ZW50cyA9IGFzbjEuZXF1YWxzKG9iaiwgb2JqLm9yaWdpbmFsKTtcbiAgICB9XG4gIH1cblxuICBpZih1c2VCaXRTdHJpbmdDb250ZW50cykge1xuICAgIHZhbHVlLnB1dEJ5dGVzKG9iai5iaXRTdHJpbmdDb250ZW50cyk7XG4gIH0gZWxzZSBpZihvYmouY29tcG9zZWQpIHtcbiAgICAvLyBpZiBjb21wb3NlZCwgdXNlIGVhY2ggY2hpbGQgYXNuMSBvYmplY3QncyBERVIgYnl0ZXMgYXMgdmFsdWVcbiAgICAvLyB0dXJuIG9uIDZ0aCBiaXQgKDB4MjAgPSAzMikgdG8gaW5kaWNhdGUgYXNuMSBpcyBjb25zdHJ1Y3RlZFxuICAgIC8vIGZyb20gb3RoZXIgYXNuMSBvYmplY3RzXG4gICAgaWYob2JqLmNvbnN0cnVjdGVkKSB7XG4gICAgICBiMSB8PSAweDIwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0eXBlIGlzIGEgYml0IHN0cmluZywgYWRkIHVudXNlZCBiaXRzIG9mIDB4MDBcbiAgICAgIHZhbHVlLnB1dEJ5dGUoMHgwMCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGFsbCBvZiB0aGUgY2hpbGQgREVSIGJ5dGVzIHRvZ2V0aGVyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9iai52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYob2JqLnZhbHVlW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUucHV0QnVmZmVyKGFzbjEudG9EZXIob2JqLnZhbHVlW2ldKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBhc24xLnZhbHVlIGRpcmVjdGx5XG4gICAgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5CTVBTVFJJTkcpIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmoudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFsdWUucHV0SW50MTYob2JqLnZhbHVlLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbnN1cmUgaW50ZWdlciBpcyBtaW5pbWFsbHktZW5jb2RlZFxuICAgICAgLy8gVE9ETzogc2hvdWxkIGFsbCBsZWFkaW5nIGJ5dGVzIGJlIHN0cmlwcGVkIHZzIGp1c3Qgb25lP1xuICAgICAgLy8gLi4gZXggJzAwIDAwIDAxJyA9PiAnMDEnP1xuICAgICAgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5JTlRFR0VSICYmXG4gICAgICAgIG9iai52YWx1ZS5sZW5ndGggPiAxICYmXG4gICAgICAgIC8vIGxlYWRpbmcgMHgwMCBmb3IgcG9zaXRpdmUgaW50ZWdlclxuICAgICAgICAoKG9iai52YWx1ZS5jaGFyQ29kZUF0KDApID09PSAwICYmXG4gICAgICAgIChvYmoudmFsdWUuY2hhckNvZGVBdCgxKSAmIDB4ODApID09PSAwKSB8fFxuICAgICAgICAvLyBsZWFkaW5nIDB4RkYgZm9yIG5lZ2F0aXZlIGludGVnZXJcbiAgICAgICAgKG9iai52YWx1ZS5jaGFyQ29kZUF0KDApID09PSAweEZGICYmXG4gICAgICAgIChvYmoudmFsdWUuY2hhckNvZGVBdCgxKSAmIDB4ODApID09PSAweDgwKSkpIHtcbiAgICAgICAgdmFsdWUucHV0Qnl0ZXMob2JqLnZhbHVlLnN1YnN0cigxKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZS5wdXRCeXRlcyhvYmoudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCB0YWcgYnl0ZVxuICBieXRlcy5wdXRCeXRlKGIxKTtcblxuICAvLyB1c2UgXCJzaG9ydCBmb3JtXCIgZW5jb2RpbmdcbiAgaWYodmFsdWUubGVuZ3RoKCkgPD0gMTI3KSB7XG4gICAgLy8gb25lIGJ5dGUgZGVzY3JpYmVzIHRoZSBsZW5ndGhcbiAgICAvLyBiaXQgOCA9IDAgYW5kIGJpdHMgNy0xID0gbGVuZ3RoXG4gICAgYnl0ZXMucHV0Qnl0ZSh2YWx1ZS5sZW5ndGgoKSAmIDB4N0YpO1xuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBcImxvbmcgZm9ybVwiIGVuY29kaW5nXG4gICAgLy8gMiB0byAxMjcgYnl0ZXMgZGVzY3JpYmUgdGhlIGxlbmd0aFxuICAgIC8vIGZpcnN0IGJ5dGU6IGJpdCA4ID0gMSBhbmQgYml0cyA3LTEgPSAjIG9mIGFkZGl0aW9uYWwgYnl0ZXNcbiAgICAvLyBvdGhlciBieXRlczogbGVuZ3RoIGluIGJhc2UgMjU2LCBiaWctZW5kaWFuXG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCgpO1xuICAgIHZhciBsZW5CeXRlcyA9ICcnO1xuICAgIGRvIHtcbiAgICAgIGxlbkJ5dGVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuICYgMHhGRik7XG4gICAgICBsZW4gPSBsZW4gPj4+IDg7XG4gICAgfSB3aGlsZShsZW4gPiAwKTtcblxuICAgIC8vIHNldCBmaXJzdCBieXRlIHRvICMgYnl0ZXMgdXNlZCB0byBzdG9yZSB0aGUgbGVuZ3RoIGFuZCB0dXJuIG9uXG4gICAgLy8gYml0IDggdG8gaW5kaWNhdGUgbG9uZy1mb3JtIGxlbmd0aCBpcyB1c2VkXG4gICAgYnl0ZXMucHV0Qnl0ZShsZW5CeXRlcy5sZW5ndGggfCAweDgwKTtcblxuICAgIC8vIGNvbmNhdGVuYXRlIGxlbmd0aCBieXRlcyBpbiByZXZlcnNlIHNpbmNlIHRoZXkgd2VyZSBnZW5lcmF0ZWRcbiAgICAvLyBsaXR0bGUgZW5kaWFuIGFuZCB3ZSBuZWVkIGJpZyBlbmRpYW5cbiAgICBmb3IodmFyIGkgPSBsZW5CeXRlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgYnl0ZXMucHV0Qnl0ZShsZW5CeXRlcy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH1cblxuICAvLyBjb25jYXRlbmF0ZSB2YWx1ZSBieXRlc1xuICBieXRlcy5wdXRCdWZmZXIodmFsdWUpO1xuICByZXR1cm4gYnl0ZXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIE9JRCBkb3Qtc2VwYXJhdGVkIHN0cmluZyB0byBhIGJ5dGUgYnVmZmVyLiBUaGUgYnl0ZSBidWZmZXJcbiAqIGNvbnRhaW5zIG9ubHkgdGhlIERFUi1lbmNvZGVkIHZhbHVlLCBub3QgYW55IHRhZyBvciBsZW5ndGggYnl0ZXMuXG4gKlxuICogQHBhcmFtIG9pZCB0aGUgT0lEIGRvdC1zZXBhcmF0ZWQgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUgYnVmZmVyLlxuICovXG5hc24xLm9pZFRvRGVyID0gZnVuY3Rpb24ob2lkKSB7XG4gIC8vIHNwbGl0IE9JRCBpbnRvIGluZGl2aWR1YWwgdmFsdWVzXG4gIHZhciB2YWx1ZXMgPSBvaWQuc3BsaXQoJy4nKTtcbiAgdmFyIGJ5dGVzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcblxuICAvLyBmaXJzdCBieXRlIGlzIDQwICogdmFsdWUxICsgdmFsdWUyXG4gIGJ5dGVzLnB1dEJ5dGUoNDAgKiBwYXJzZUludCh2YWx1ZXNbMF0sIDEwKSArIHBhcnNlSW50KHZhbHVlc1sxXSwgMTApKTtcbiAgLy8gb3RoZXIgYnl0ZXMgYXJlIGVhY2ggdmFsdWUgaW4gYmFzZSAxMjggd2l0aCA4dGggYml0IHNldCBleGNlcHQgZm9yXG4gIC8vIHRoZSBsYXN0IGJ5dGUgZm9yIGVhY2ggdmFsdWVcbiAgdmFyIGxhc3QsIHZhbHVlQnl0ZXMsIHZhbHVlLCBiO1xuICBmb3IodmFyIGkgPSAyOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gcHJvZHVjZSB2YWx1ZSBieXRlcyBpbiByZXZlcnNlIGJlY2F1c2Ugd2UgZG9uJ3Qga25vdyBob3cgbWFueVxuICAgIC8vIGJ5dGVzIGl0IHdpbGwgdGFrZSB0byBzdG9yZSB0aGUgdmFsdWVcbiAgICBsYXN0ID0gdHJ1ZTtcbiAgICB2YWx1ZUJ5dGVzID0gW107XG4gICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZXNbaV0sIDEwKTtcbiAgICBkbyB7XG4gICAgICBiID0gdmFsdWUgJiAweDdGO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA+Pj4gNztcbiAgICAgIC8vIGlmIHZhbHVlIGlzIG5vdCBsYXN0LCB0aGVuIHR1cm4gb24gOHRoIGJpdFxuICAgICAgaWYoIWxhc3QpIHtcbiAgICAgICAgYiB8PSAweDgwO1xuICAgICAgfVxuICAgICAgdmFsdWVCeXRlcy5wdXNoKGIpO1xuICAgICAgbGFzdCA9IGZhbHNlO1xuICAgIH0gd2hpbGUodmFsdWUgPiAwKTtcblxuICAgIC8vIGFkZCB2YWx1ZSBieXRlcyBpbiByZXZlcnNlIChuZWVkcyB0byBiZSBpbiBiaWcgZW5kaWFuKVxuICAgIGZvcih2YXIgbiA9IHZhbHVlQnl0ZXMubGVuZ3RoIC0gMTsgbiA+PSAwOyAtLW4pIHtcbiAgICAgIGJ5dGVzLnB1dEJ5dGUodmFsdWVCeXRlc1tuXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIERFUi1lbmNvZGVkIGJ5dGUgYnVmZmVyIHRvIGFuIE9JRCBkb3Qtc2VwYXJhdGVkIHN0cmluZy4gVGhlXG4gKiBieXRlIGJ1ZmZlciBzaG91bGQgY29udGFpbiBvbmx5IHRoZSBERVItZW5jb2RlZCB2YWx1ZSwgbm90IGFueSB0YWcgb3JcbiAqIGxlbmd0aCBieXRlcy5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIE9JRCBkb3Qtc2VwYXJhdGVkIHN0cmluZy5cbiAqL1xuYXNuMS5kZXJUb09pZCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHZhciBvaWQ7XG5cbiAgLy8gd3JhcCBpbiBidWZmZXIgaWYgbmVlZGVkXG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKTtcbiAgfVxuXG4gIC8vIGZpcnN0IGJ5dGUgaXMgNDAgKiB2YWx1ZTEgKyB2YWx1ZTJcbiAgdmFyIGIgPSBieXRlcy5nZXRCeXRlKCk7XG4gIG9pZCA9IE1hdGguZmxvb3IoYiAvIDQwKSArICcuJyArIChiICUgNDApO1xuXG4gIC8vIG90aGVyIGJ5dGVzIGFyZSBlYWNoIHZhbHVlIGluIGJhc2UgMTI4IHdpdGggOHRoIGJpdCBzZXQgZXhjZXB0IGZvclxuICAvLyB0aGUgbGFzdCBieXRlIGZvciBlYWNoIHZhbHVlXG4gIHZhciB2YWx1ZSA9IDA7XG4gIHdoaWxlKGJ5dGVzLmxlbmd0aCgpID4gMCkge1xuICAgIGIgPSBieXRlcy5nZXRCeXRlKCk7XG4gICAgdmFsdWUgPSB2YWx1ZSA8PCA3O1xuICAgIC8vIG5vdCB0aGUgbGFzdCBieXRlIGZvciB0aGUgdmFsdWVcbiAgICBpZihiICYgMHg4MCkge1xuICAgICAgdmFsdWUgKz0gYiAmIDB4N0Y7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxhc3QgYnl0ZVxuICAgICAgb2lkICs9ICcuJyArICh2YWx1ZSArIGIpO1xuICAgICAgdmFsdWUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvaWQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVVRDVGltZSB2YWx1ZSB0byBhIGRhdGUuXG4gKlxuICogTm90ZTogR2VuZXJhbGl6ZWRUaW1lIGhhcyA0IGRpZ2l0cyBmb3IgdGhlIHllYXIgYW5kIGlzIHVzZWQgZm9yIFguNTA5XG4gKiBkYXRlcyBwYXN0IDIwNDkuIFBhcnNpbmcgdGhhdCBzdHJ1Y3R1cmUgaGFzbid0IGJlZW4gaW1wbGVtZW50ZWQgeWV0LlxuICpcbiAqIEBwYXJhbSB1dGMgdGhlIFVUQ1RpbWUgdmFsdWUgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkYXRlLlxuICovXG5hc24xLnV0Y1RpbWVUb0RhdGUgPSBmdW5jdGlvbih1dGMpIHtcbiAgLyogVGhlIGZvbGxvd2luZyBmb3JtYXRzIGNhbiBiZSB1c2VkOlxuXG4gICAgWVlNTUREaGhtbVpcbiAgICBZWU1NRERoaG1tK2hoJ21tJ1xuICAgIFlZTU1ERGhobW0taGgnbW0nXG4gICAgWVlNTUREaGhtbXNzWlxuICAgIFlZTU1ERGhobW1zcytoaCdtbSdcbiAgICBZWU1NRERoaG1tc3MtaGgnbW0nXG5cbiAgICBXaGVyZTpcblxuICAgIFlZIGlzIHRoZSBsZWFzdCBzaWduaWZpY2FudCB0d28gZGlnaXRzIG9mIHRoZSB5ZWFyXG4gICAgTU0gaXMgdGhlIG1vbnRoICgwMSB0byAxMilcbiAgICBERCBpcyB0aGUgZGF5ICgwMSB0byAzMSlcbiAgICBoaCBpcyB0aGUgaG91ciAoMDAgdG8gMjMpXG4gICAgbW0gYXJlIHRoZSBtaW51dGVzICgwMCB0byA1OSlcbiAgICBzcyBhcmUgdGhlIHNlY29uZHMgKDAwIHRvIDU5KVxuICAgIFogaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpcyBHTVQsICsgaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpc1xuICAgIGxhdGVyIHRoYW4gR01ULCBhbmQgLSBpbmRpY2F0ZXMgdGhhdCBsb2NhbCB0aW1lIGlzIGVhcmxpZXIgdGhhbiBHTVRcbiAgICBoaCcgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBvZmZzZXQgZnJvbSBHTVQgaW4gaG91cnNcbiAgICBtbScgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBvZmZzZXQgZnJvbSBHTVQgaW4gbWludXRlcyAqL1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgLy8gaWYgWVkgPj0gNTAgdXNlIDE5eHgsIGlmIFlZIDwgNTAgdXNlIDIweHhcbiAgdmFyIHllYXIgPSBwYXJzZUludCh1dGMuc3Vic3RyKDAsIDIpLCAxMCk7XG4gIHllYXIgPSAoeWVhciA+PSA1MCkgPyAxOTAwICsgeWVhciA6IDIwMDAgKyB5ZWFyO1xuICB2YXIgTU0gPSBwYXJzZUludCh1dGMuc3Vic3RyKDIsIDIpLCAxMCkgLSAxOyAvLyB1c2UgMC0xMSBmb3IgbW9udGhcbiAgdmFyIEREID0gcGFyc2VJbnQodXRjLnN1YnN0cig0LCAyKSwgMTApO1xuICB2YXIgaGggPSBwYXJzZUludCh1dGMuc3Vic3RyKDYsIDIpLCAxMCk7XG4gIHZhciBtbSA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoOCwgMiksIDEwKTtcbiAgdmFyIHNzID0gMDtcblxuICAvLyBub3QganVzdCBZWU1NRERoaG1tWlxuICBpZih1dGMubGVuZ3RoID4gMTEpIHtcbiAgICAvLyBnZXQgY2hhcmFjdGVyIGFmdGVyIG1pbnV0ZXNcbiAgICB2YXIgYyA9IHV0Yy5jaGFyQXQoMTApO1xuICAgIHZhciBlbmQgPSAxMDtcblxuICAgIC8vIHNlZSBpZiBzZWNvbmRzIGFyZSBwcmVzZW50XG4gICAgaWYoYyAhPT0gJysnICYmIGMgIT09ICctJykge1xuICAgICAgLy8gZ2V0IHNlY29uZHNcbiAgICAgIHNzID0gcGFyc2VJbnQodXRjLnN1YnN0cigxMCwgMiksIDEwKTtcbiAgICAgIGVuZCArPSAyO1xuICAgIH1cbiAgfVxuXG4gIC8vIHVwZGF0ZSBkYXRlXG4gIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgTU0sIEREKTtcbiAgZGF0ZS5zZXRVVENIb3VycyhoaCwgbW0sIHNzLCAwKTtcblxuICBpZihlbmQpIHtcbiAgICAvLyBnZXQgKy8tIGFmdGVyIGVuZCBvZiB0aW1lXG4gICAgYyA9IHV0Yy5jaGFyQXQoZW5kKTtcbiAgICBpZihjID09PSAnKycgfHwgYyA9PT0gJy0nKSB7XG4gICAgICAvLyBnZXQgaG91cnMrbWludXRlcyBvZmZzZXRcbiAgICAgIHZhciBoaG9mZnNldCA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoZW5kICsgMSwgMiksIDEwKTtcbiAgICAgIHZhciBtbW9mZnNldCA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoZW5kICsgNCwgMiksIDEwKTtcblxuICAgICAgLy8gY2FsY3VsYXRlIG9mZnNldCBpbiBtaWxsaXNlY29uZHNcbiAgICAgIHZhciBvZmZzZXQgPSBoaG9mZnNldCAqIDYwICsgbW1vZmZzZXQ7XG4gICAgICBvZmZzZXQgKj0gNjAwMDA7XG5cbiAgICAgIC8vIGFwcGx5IG9mZnNldFxuICAgICAgaWYoYyA9PT0gJysnKSB7XG4gICAgICAgIGRhdGUuc2V0VGltZSgrZGF0ZSAtIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBvZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIEdlbmVyYWxpemVkVGltZSB2YWx1ZSB0byBhIGRhdGUuXG4gKlxuICogQHBhcmFtIGdlbnRpbWUgdGhlIEdlbmVyYWxpemVkVGltZSB2YWx1ZSB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGRhdGUuXG4gKi9cbmFzbjEuZ2VuZXJhbGl6ZWRUaW1lVG9EYXRlID0gZnVuY3Rpb24oZ2VudGltZSkge1xuICAvKiBUaGUgZm9sbG93aW5nIGZvcm1hdHMgY2FuIGJlIHVzZWQ6XG5cbiAgICBZWVlZTU1EREhITU1TU1xuICAgIFlZWVlNTURESEhNTVNTLmZmZlxuICAgIFlZWVlNTURESEhNTVNTWlxuICAgIFlZWVlNTURESEhNTVNTLmZmZlpcbiAgICBZWVlZTU1EREhITU1TUytoaCdtbSdcbiAgICBZWVlZTU1EREhITU1TUy5mZmYraGgnbW0nXG4gICAgWVlZWU1NRERISE1NU1MtaGgnbW0nXG4gICAgWVlZWU1NRERISE1NU1MuZmZmLWhoJ21tJ1xuXG4gICAgV2hlcmU6XG5cbiAgICBZWVlZIGlzIHRoZSB5ZWFyXG4gICAgTU0gaXMgdGhlIG1vbnRoICgwMSB0byAxMilcbiAgICBERCBpcyB0aGUgZGF5ICgwMSB0byAzMSlcbiAgICBoaCBpcyB0aGUgaG91ciAoMDAgdG8gMjMpXG4gICAgbW0gYXJlIHRoZSBtaW51dGVzICgwMCB0byA1OSlcbiAgICBzcyBhcmUgdGhlIHNlY29uZHMgKDAwIHRvIDU5KVxuICAgIC5mZmYgaXMgdGhlIHNlY29uZCBmcmFjdGlvbiwgYWNjdXJhdGUgdG8gdGhyZWUgZGVjaW1hbCBwbGFjZXNcbiAgICBaIGluZGljYXRlcyB0aGF0IGxvY2FsIHRpbWUgaXMgR01ULCArIGluZGljYXRlcyB0aGF0IGxvY2FsIHRpbWUgaXNcbiAgICBsYXRlciB0aGFuIEdNVCwgYW5kIC0gaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpcyBlYXJsaWVyIHRoYW4gR01UXG4gICAgaGgnIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgb2Zmc2V0IGZyb20gR01UIGluIGhvdXJzXG4gICAgbW0nIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgb2Zmc2V0IGZyb20gR01UIGluIG1pbnV0ZXMgKi9cbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gIHZhciBZWVlZID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoMCwgNCksIDEwKTtcbiAgdmFyIE1NID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoNCwgMiksIDEwKSAtIDE7IC8vIHVzZSAwLTExIGZvciBtb250aFxuICB2YXIgREQgPSBwYXJzZUludChnZW50aW1lLnN1YnN0cig2LCAyKSwgMTApO1xuICB2YXIgaGggPSBwYXJzZUludChnZW50aW1lLnN1YnN0cig4LCAyKSwgMTApO1xuICB2YXIgbW0gPSBwYXJzZUludChnZW50aW1lLnN1YnN0cigxMCwgMiksIDEwKTtcbiAgdmFyIHNzID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoMTIsIDIpLCAxMCk7XG4gIHZhciBmZmYgPSAwO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIGlzVVRDID0gZmFsc2U7XG5cbiAgaWYoZ2VudGltZS5jaGFyQXQoZ2VudGltZS5sZW5ndGggLSAxKSA9PT0gJ1onKSB7XG4gICAgaXNVVEMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGVuZCA9IGdlbnRpbWUubGVuZ3RoIC0gNSwgYyA9IGdlbnRpbWUuY2hhckF0KGVuZCk7XG4gIGlmKGMgPT09ICcrJyB8fCBjID09PSAnLScpIHtcbiAgICAvLyBnZXQgaG91cnMrbWludXRlcyBvZmZzZXRcbiAgICB2YXIgaGhvZmZzZXQgPSBwYXJzZUludChnZW50aW1lLnN1YnN0cihlbmQgKyAxLCAyKSwgMTApO1xuICAgIHZhciBtbW9mZnNldCA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKGVuZCArIDQsIDIpLCAxMCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgb2Zmc2V0IGluIG1pbGxpc2Vjb25kc1xuICAgIG9mZnNldCA9IGhob2Zmc2V0ICogNjAgKyBtbW9mZnNldDtcbiAgICBvZmZzZXQgKj0gNjAwMDA7XG5cbiAgICAvLyBhcHBseSBvZmZzZXRcbiAgICBpZihjID09PSAnKycpIHtcbiAgICAgIG9mZnNldCAqPSAtMTtcbiAgICB9XG5cbiAgICBpc1VUQyA9IHRydWU7XG4gIH1cblxuICAvLyBjaGVjayBmb3Igc2Vjb25kIGZyYWN0aW9uXG4gIGlmKGdlbnRpbWUuY2hhckF0KDE0KSA9PT0gJy4nKSB7XG4gICAgZmZmID0gcGFyc2VGbG9hdChnZW50aW1lLnN1YnN0cigxNCksIDEwKSAqIDEwMDA7XG4gIH1cblxuICBpZihpc1VUQykge1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoWVlZWSwgTU0sIEREKTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKGhoLCBtbSwgc3MsIGZmZik7XG5cbiAgICAvLyBhcHBseSBvZmZzZXRcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBvZmZzZXQpO1xuICB9IGVsc2Uge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoWVlZWSwgTU0sIEREKTtcbiAgICBkYXRlLnNldEhvdXJzKGhoLCBtbSwgc3MsIGZmZik7XG4gIH1cblxuICByZXR1cm4gZGF0ZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBkYXRlIHRvIGEgVVRDVGltZSB2YWx1ZS5cbiAqXG4gKiBOb3RlOiBHZW5lcmFsaXplZFRpbWUgaGFzIDQgZGlnaXRzIGZvciB0aGUgeWVhciBhbmQgaXMgdXNlZCBmb3IgWC41MDlcbiAqIGRhdGVzIHBhc3QgMjA0OS4gQ29udmVydGluZyB0byBhIEdlbmVyYWxpemVkVGltZSBoYXNuJ3QgYmVlblxuICogaW1wbGVtZW50ZWQgeWV0LlxuICpcbiAqIEBwYXJhbSBkYXRlIHRoZSBkYXRlIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgVVRDVGltZSB2YWx1ZS5cbiAqL1xuYXNuMS5kYXRlVG9VdGNUaW1lID0gZnVuY3Rpb24oZGF0ZSkge1xuICAvLyBUT0RPOiB2YWxpZGF0ZTsgY3VycmVudGx5IGFzc3VtZXMgcHJvcGVyIGZvcm1hdFxuICBpZih0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIHZhciBydmFsID0gJyc7XG5cbiAgLy8gY3JlYXRlIGZvcm1hdCBZWU1NRERoaG1tc3NaXG4gIHZhciBmb3JtYXQgPSBbXTtcbiAgZm9ybWF0LnB1c2goKCcnICsgZGF0ZS5nZXRVVENGdWxsWWVhcigpKS5zdWJzdHIoMikpO1xuICBmb3JtYXQucHVzaCgnJyArIChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENEYXRlKCkpO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDSG91cnMoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENNaW51dGVzKCkpO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDU2Vjb25kcygpKTtcblxuICAvLyBlbnN1cmUgMiBkaWdpdHMgYXJlIHVzZWQgZm9yIGVhY2ggZm9ybWF0IGVudHJ5XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBmb3JtYXQubGVuZ3RoOyArK2kpIHtcbiAgICBpZihmb3JtYXRbaV0ubGVuZ3RoIDwgMikge1xuICAgICAgcnZhbCArPSAnMCc7XG4gICAgfVxuICAgIHJ2YWwgKz0gZm9ybWF0W2ldO1xuICB9XG4gIHJ2YWwgKz0gJ1onO1xuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGRhdGUgdG8gYSBHZW5lcmFsaXplZFRpbWUgdmFsdWUuXG4gKlxuICogQHBhcmFtIGRhdGUgdGhlIGRhdGUgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBHZW5lcmFsaXplZFRpbWUgdmFsdWUgYXMgYSBzdHJpbmcuXG4gKi9cbmFzbjEuZGF0ZVRvR2VuZXJhbGl6ZWRUaW1lID0gZnVuY3Rpb24oZGF0ZSkge1xuICAvLyBUT0RPOiB2YWxpZGF0ZTsgY3VycmVudGx5IGFzc3VtZXMgcHJvcGVyIGZvcm1hdFxuICBpZih0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIHZhciBydmFsID0gJyc7XG5cbiAgLy8gY3JlYXRlIGZvcm1hdCBZWVlZTU1EREhITU1TU1pcbiAgdmFyIGZvcm1hdCA9IFtdO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ0RhdGUoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENIb3VycygpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ01pbnV0ZXMoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENTZWNvbmRzKCkpO1xuXG4gIC8vIGVuc3VyZSAyIGRpZ2l0cyBhcmUgdXNlZCBmb3IgZWFjaCBmb3JtYXQgZW50cnlcbiAgZm9yKHZhciBpID0gMDsgaSA8IGZvcm1hdC5sZW5ndGg7ICsraSkge1xuICAgIGlmKGZvcm1hdFtpXS5sZW5ndGggPCAyKSB7XG4gICAgICBydmFsICs9ICcwJztcbiAgICB9XG4gICAgcnZhbCArPSBmb3JtYXRbaV07XG4gIH1cbiAgcnZhbCArPSAnWic7XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgamF2YXNjcmlwdCBpbnRlZ2VyIHRvIGEgREVSLWVuY29kZWQgYnl0ZSBidWZmZXIgdG8gYmUgdXNlZFxuICogYXMgdGhlIHZhbHVlIGZvciBhbiBJTlRFR0VSIHR5cGUuXG4gKlxuICogQHBhcmFtIHggdGhlIGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZSBidWZmZXIuXG4gKi9cbmFzbjEuaW50ZWdlclRvRGVyID0gZnVuY3Rpb24oeCkge1xuICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIGlmKHggPj0gLTB4ODAgJiYgeCA8IDB4ODApIHtcbiAgICByZXR1cm4gcnZhbC5wdXRTaWduZWRJbnQoeCwgOCk7XG4gIH1cbiAgaWYoeCA+PSAtMHg4MDAwICYmIHggPCAweDgwMDApIHtcbiAgICByZXR1cm4gcnZhbC5wdXRTaWduZWRJbnQoeCwgMTYpO1xuICB9XG4gIGlmKHggPj0gLTB4ODAwMDAwICYmIHggPCAweDgwMDAwMCkge1xuICAgIHJldHVybiBydmFsLnB1dFNpZ25lZEludCh4LCAyNCk7XG4gIH1cbiAgaWYoeCA+PSAtMHg4MDAwMDAwMCAmJiB4IDwgMHg4MDAwMDAwMCkge1xuICAgIHJldHVybiBydmFsLnB1dFNpZ25lZEludCh4LCAzMik7XG4gIH1cbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdJbnRlZ2VyIHRvbyBsYXJnZTsgbWF4IGlzIDMyLWJpdHMuJyk7XG4gIGVycm9yLmludGVnZXIgPSB4O1xuICB0aHJvdyBlcnJvcjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBERVItZW5jb2RlZCBieXRlIGJ1ZmZlciB0byBhIGphdmFzY3JpcHQgaW50ZWdlci4gVGhpcyBpc1xuICogdHlwaWNhbGx5IHVzZWQgdG8gZGVjb2RlIHRoZSB2YWx1ZSBvZiBhbiBJTlRFR0VSIHR5cGUuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbnRlZ2VyLlxuICovXG5hc24xLmRlclRvSW50ZWdlciA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIC8vIHdyYXAgaW4gYnVmZmVyIGlmIG5lZWRlZFxuICBpZih0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgYnl0ZXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihieXRlcyk7XG4gIH1cblxuICB2YXIgbiA9IGJ5dGVzLmxlbmd0aCgpICogODtcbiAgaWYobiA+IDMyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlZ2VyIHRvbyBsYXJnZTsgbWF4IGlzIDMyLWJpdHMuJyk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzLmdldFNpZ25lZEludChuKTtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgdGhlIGdpdmVuIEFTTi4xIG9iamVjdCBpcyBhdCBsZWFzdCBhIHN1cGVyIHNldCBvZiB0aGVcbiAqIGdpdmVuIEFTTi4xIHN0cnVjdHVyZS4gT25seSB0YWcgY2xhc3NlcyBhbmQgdHlwZXMgYXJlIGNoZWNrZWQuIEFuXG4gKiBvcHRpb25hbCBtYXAgbWF5IGFsc28gYmUgcHJvdmlkZWQgdG8gY2FwdHVyZSBBU04uMSB2YWx1ZXMgd2hpbGUgdGhlXG4gKiBzdHJ1Y3R1cmUgaXMgY2hlY2tlZC5cbiAqXG4gKiBUbyBjYXB0dXJlIGFuIEFTTi4xIHZhbHVlLCBzZXQgYW4gb2JqZWN0IGluIHRoZSB2YWxpZGF0b3IncyAnY2FwdHVyZSdcbiAqIHBhcmFtZXRlciB0byB0aGUga2V5IHRvIHVzZSBpbiB0aGUgY2FwdHVyZSBtYXAuIFRvIGNhcHR1cmUgdGhlIGZ1bGxcbiAqIEFTTi4xIG9iamVjdCwgc3BlY2lmeSAnY2FwdHVyZUFzbjEnLiBUbyBjYXB0dXJlIEJJVCBTVFJJTkcgYnl0ZXMsIGluY2x1ZGluZ1xuICogdGhlIGxlYWRpbmcgdW51c2VkIGJpdHMgY291bnRlciBieXRlLCBzcGVjaWZ5ICdjYXB0dXJlQml0U3RyaW5nQ29udGVudHMnLlxuICogVG8gY2FwdHVyZSBCSVQgU1RSSU5HIGJ5dGVzLCB3aXRob3V0IHRoZSBsZWFkaW5nIHVudXNlZCBiaXRzIGNvdW50ZXIgYnl0ZSxcbiAqIHNwZWNpZnkgJ2NhcHR1cmVCaXRTdHJpbmdWYWx1ZScuXG4gKlxuICogT2JqZWN0cyBpbiB0aGUgdmFsaWRhdG9yIG1heSBzZXQgYSBmaWVsZCAnb3B0aW9uYWwnIHRvIHRydWUgdG8gaW5kaWNhdGVcbiAqIHRoYXQgaXQgaXNuJ3QgbmVjZXNzYXJ5IHRvIHBhc3MgdmFsaWRhdGlvbi5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBBU04uMSBvYmplY3QgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gdiB0aGUgQVNOLjEgc3RydWN0dXJlIHZhbGlkYXRvci5cbiAqIEBwYXJhbSBjYXB0dXJlIGFuIG9wdGlvbmFsIG1hcCB0byBjYXB0dXJlIHZhbHVlcyBpbi5cbiAqIEBwYXJhbSBlcnJvcnMgYW4gb3B0aW9uYWwgYXJyYXkgZm9yIHN0b3JpbmcgdmFsaWRhdGlvbiBlcnJvcnMuXG4gKlxuICogQHJldHVybiB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmUuXG4gKi9cbmFzbjEudmFsaWRhdGUgPSBmdW5jdGlvbihvYmosIHYsIGNhcHR1cmUsIGVycm9ycykge1xuICB2YXIgcnZhbCA9IGZhbHNlO1xuXG4gIC8vIGVuc3VyZSB0YWcgY2xhc3MgYW5kIHR5cGUgYXJlIHRoZSBzYW1lIGlmIHNwZWNpZmllZFxuICBpZigob2JqLnRhZ0NsYXNzID09PSB2LnRhZ0NsYXNzIHx8IHR5cGVvZih2LnRhZ0NsYXNzKSA9PT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgKG9iai50eXBlID09PSB2LnR5cGUgfHwgdHlwZW9mKHYudHlwZSkgPT09ICd1bmRlZmluZWQnKSkge1xuICAgIC8vIGVuc3VyZSBjb25zdHJ1Y3RlZCBmbGFnIGlzIHRoZSBzYW1lIGlmIHNwZWNpZmllZFxuICAgIGlmKG9iai5jb25zdHJ1Y3RlZCA9PT0gdi5jb25zdHJ1Y3RlZCB8fFxuICAgICAgdHlwZW9mKHYuY29uc3RydWN0ZWQpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcnZhbCA9IHRydWU7XG5cbiAgICAgIC8vIGhhbmRsZSBzdWIgdmFsdWVzXG4gICAgICBpZih2LnZhbHVlICYmIGZvcmdlLnV0aWwuaXNBcnJheSh2LnZhbHVlKSkge1xuICAgICAgICB2YXIgaiA9IDA7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IHJ2YWwgJiYgaSA8IHYudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBydmFsID0gdi52YWx1ZVtpXS5vcHRpb25hbCB8fCBmYWxzZTtcbiAgICAgICAgICBpZihvYmoudmFsdWVbal0pIHtcbiAgICAgICAgICAgIHJ2YWwgPSBhc24xLnZhbGlkYXRlKG9iai52YWx1ZVtqXSwgdi52YWx1ZVtpXSwgY2FwdHVyZSwgZXJyb3JzKTtcbiAgICAgICAgICAgIGlmKHJ2YWwpIHtcbiAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHYudmFsdWVbaV0ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgcnZhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKCFydmFsICYmIGVycm9ycykge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAgICAgICAnVGFnIGNsYXNzIFwiJyArIHYudGFnQ2xhc3MgKyAnXCIsIHR5cGUgXCInICtcbiAgICAgICAgICAgICAgdi50eXBlICsgJ1wiIGV4cGVjdGVkIHZhbHVlIGxlbmd0aCBcIicgK1xuICAgICAgICAgICAgICB2LnZhbHVlLmxlbmd0aCArICdcIiwgZ290IFwiJyArXG4gICAgICAgICAgICAgIG9iai52YWx1ZS5sZW5ndGggKyAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYocnZhbCAmJiBjYXB0dXJlKSB7XG4gICAgICAgIGlmKHYuY2FwdHVyZSkge1xuICAgICAgICAgIGNhcHR1cmVbdi5jYXB0dXJlXSA9IG9iai52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZih2LmNhcHR1cmVBc24xKSB7XG4gICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVBc24xXSA9IG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZih2LmNhcHR1cmVCaXRTdHJpbmdDb250ZW50cyAmJiAnYml0U3RyaW5nQ29udGVudHMnIGluIG9iaikge1xuICAgICAgICAgIGNhcHR1cmVbdi5jYXB0dXJlQml0U3RyaW5nQ29udGVudHNdID0gb2JqLmJpdFN0cmluZ0NvbnRlbnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmKHYuY2FwdHVyZUJpdFN0cmluZ1ZhbHVlICYmICdiaXRTdHJpbmdDb250ZW50cycgaW4gb2JqKSB7XG4gICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgIGlmKG9iai5iaXRTdHJpbmdDb250ZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBjYXB0dXJlW3YuY2FwdHVyZUJpdFN0cmluZ1ZhbHVlXSA9ICcnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogc3VwcG9ydCB1bnVzZWQgYml0cyB3aXRoIGRhdGEgc2hpZnRpbmdcbiAgICAgICAgICAgIHZhciB1bnVzZWQgPSBvYmouYml0U3RyaW5nQ29udGVudHMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGlmKHVudXNlZCAhPT0gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ2NhcHR1cmVCaXRTdHJpbmdWYWx1ZSBvbmx5IHN1cHBvcnRlZCBmb3IgemVybyB1bnVzZWQgYml0cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVCaXRTdHJpbmdWYWx1ZV0gPSBvYmouYml0U3RyaW5nQ29udGVudHMuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGVycm9ycykge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAnRXhwZWN0ZWQgY29uc3RydWN0ZWQgXCInICsgdi5jb25zdHJ1Y3RlZCArICdcIiwgZ290IFwiJyArXG4gICAgICAgIG9iai5jb25zdHJ1Y3RlZCArICdcIicpO1xuICAgIH1cbiAgfSBlbHNlIGlmKGVycm9ycykge1xuICAgIGlmKG9iai50YWdDbGFzcyAhPT0gdi50YWdDbGFzcykge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAnRXhwZWN0ZWQgdGFnIGNsYXNzIFwiJyArIHYudGFnQ2xhc3MgKyAnXCIsIGdvdCBcIicgK1xuICAgICAgICBvYmoudGFnQ2xhc3MgKyAnXCInKTtcbiAgICB9XG4gICAgaWYob2JqLnR5cGUgIT09IHYudHlwZSkge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAnRXhwZWN0ZWQgdHlwZSBcIicgKyB2LnR5cGUgKyAnXCIsIGdvdCBcIicgKyBvYmoudHlwZSArICdcIicpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8vIHJlZ2V4IGZvciB0ZXN0aW5nIGZvciBub24tbGF0aW4gY2hhcmFjdGVyc1xudmFyIF9ub25MYXRpblJlZ2V4ID0gL1teXFxcXHUwMDAwLVxcXFx1MDBmZl0vO1xuXG4vKipcbiAqIFByZXR0eSBwcmludHMgYW4gQVNOLjEgb2JqZWN0IHRvIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIG9iamVjdCB0byB3cml0ZSBvdXQuXG4gKiBAcGFyYW0gbGV2ZWwgdGhlIGxldmVsIGluIHRoZSB0cmVlLlxuICogQHBhcmFtIGluZGVudGF0aW9uIHRoZSBpbmRlbnRhdGlvbiB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgc3RyaW5nLlxuICovXG5hc24xLnByZXR0eVByaW50ID0gZnVuY3Rpb24ob2JqLCBsZXZlbCwgaW5kZW50YXRpb24pIHtcbiAgdmFyIHJ2YWwgPSAnJztcblxuICAvLyBzZXQgZGVmYXVsdCBsZXZlbCBhbmQgaW5kZW50YXRpb25cbiAgbGV2ZWwgPSBsZXZlbCB8fCAwO1xuICBpbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uIHx8IDI7XG5cbiAgLy8gc3RhcnQgbmV3IGxpbmUgZm9yIGRlZXAgbGV2ZWxzXG4gIGlmKGxldmVsID4gMCkge1xuICAgIHJ2YWwgKz0gJ1xcbic7XG4gIH1cblxuICAvLyBjcmVhdGUgaW5kZW50XG4gIHZhciBpbmRlbnQgPSAnJztcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxldmVsICogaW5kZW50YXRpb247ICsraSkge1xuICAgIGluZGVudCArPSAnICc7XG4gIH1cblxuICAvLyBwcmludCBjbGFzczp0eXBlXG4gIHJ2YWwgKz0gaW5kZW50ICsgJ1RhZzogJztcbiAgc3dpdGNoKG9iai50YWdDbGFzcykge1xuICBjYXNlIGFzbjEuQ2xhc3MuVU5JVkVSU0FMOlxuICAgIHJ2YWwgKz0gJ1VuaXZlcnNhbDonO1xuICAgIGJyZWFrO1xuICBjYXNlIGFzbjEuQ2xhc3MuQVBQTElDQVRJT046XG4gICAgcnZhbCArPSAnQXBwbGljYXRpb246JztcbiAgICBicmVhaztcbiAgY2FzZSBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUM6XG4gICAgcnZhbCArPSAnQ29udGV4dC1TcGVjaWZpYzonO1xuICAgIGJyZWFrO1xuICBjYXNlIGFzbjEuQ2xhc3MuUFJJVkFURTpcbiAgICBydmFsICs9ICdQcml2YXRlOic7XG4gICAgYnJlYWs7XG4gIH1cblxuICBpZihvYmoudGFnQ2xhc3MgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMKSB7XG4gICAgcnZhbCArPSBvYmoudHlwZTtcblxuICAgIC8vIGtub3duIHR5cGVzXG4gICAgc3dpdGNoKG9iai50eXBlKSB7XG4gICAgY2FzZSBhc24xLlR5cGUuTk9ORTpcbiAgICAgIHJ2YWwgKz0gJyAoTm9uZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuQk9PTEVBTjpcbiAgICAgIHJ2YWwgKz0gJyAoQm9vbGVhbiknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuSU5URUdFUjpcbiAgICAgIHJ2YWwgKz0gJyAoSW50ZWdlciknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuQklUU1RSSU5HOlxuICAgICAgcnZhbCArPSAnIChCaXQgc3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5PQ1RFVFNUUklORzpcbiAgICAgIHJ2YWwgKz0gJyAoT2N0ZXQgc3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5OVUxMOlxuICAgICAgcnZhbCArPSAnIChOdWxsKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5PSUQ6XG4gICAgICBydmFsICs9ICcgKE9iamVjdCBJZGVudGlmaWVyKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5PREVTQzpcbiAgICAgIHJ2YWwgKz0gJyAoT2JqZWN0IERlc2NyaXB0b3IpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLkVYVEVSTkFMOlxuICAgICAgcnZhbCArPSAnIChFeHRlcm5hbCBvciBJbnN0YW5jZSBvZiknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuUkVBTDpcbiAgICAgIHJ2YWwgKz0gJyAoUmVhbCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuRU5VTUVSQVRFRDpcbiAgICAgIHJ2YWwgKz0gJyAoRW51bWVyYXRlZCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuRU1CRURERUQ6XG4gICAgICBydmFsICs9ICcgKEVtYmVkZGVkIFBEViknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuVVRGODpcbiAgICAgIHJ2YWwgKz0gJyAoVVRGOCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuUk9JRDpcbiAgICAgIHJ2YWwgKz0gJyAoUmVsYXRpdmUgT2JqZWN0IElkZW50aWZpZXIpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLlNFUVVFTkNFOlxuICAgICAgcnZhbCArPSAnIChTZXF1ZW5jZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuU0VUOlxuICAgICAgcnZhbCArPSAnIChTZXQpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLlBSSU5UQUJMRVNUUklORzpcbiAgICAgIHJ2YWwgKz0gJyAoUHJpbnRhYmxlIFN0cmluZyknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuSUE1U3RyaW5nOlxuICAgICAgcnZhbCArPSAnIChJQTVTdHJpbmcgKEFTQ0lJKSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuVVRDVElNRTpcbiAgICAgIHJ2YWwgKz0gJyAoVVRDIHRpbWUpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLkdFTkVSQUxJWkVEVElNRTpcbiAgICAgIHJ2YWwgKz0gJyAoR2VuZXJhbGl6ZWQgdGltZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuQk1QU1RSSU5HOlxuICAgICAgcnZhbCArPSAnIChCTVAgU3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcnZhbCArPSBvYmoudHlwZTtcbiAgfVxuXG4gIHJ2YWwgKz0gJ1xcbic7XG4gIHJ2YWwgKz0gaW5kZW50ICsgJ0NvbnN0cnVjdGVkOiAnICsgb2JqLmNvbnN0cnVjdGVkICsgJ1xcbic7XG5cbiAgaWYob2JqLmNvbXBvc2VkKSB7XG4gICAgdmFyIHN1YnZhbHVlcyA9IDA7XG4gICAgdmFyIHN1YiA9ICcnO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmoudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKG9iai52YWx1ZVtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN1YnZhbHVlcyArPSAxO1xuICAgICAgICBzdWIgKz0gYXNuMS5wcmV0dHlQcmludChvYmoudmFsdWVbaV0sIGxldmVsICsgMSwgaW5kZW50YXRpb24pO1xuICAgICAgICBpZigoaSArIDEpIDwgb2JqLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgIHN1YiArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcnZhbCArPSBpbmRlbnQgKyAnU3ViIHZhbHVlczogJyArIHN1YnZhbHVlcyArIHN1YjtcbiAgfSBlbHNlIHtcbiAgICBydmFsICs9IGluZGVudCArICdWYWx1ZTogJztcbiAgICBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLk9JRCkge1xuICAgICAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQob2JqLnZhbHVlKTtcbiAgICAgIHJ2YWwgKz0gb2lkO1xuICAgICAgaWYoZm9yZ2UucGtpICYmIGZvcmdlLnBraS5vaWRzKSB7XG4gICAgICAgIGlmKG9pZCBpbiBmb3JnZS5wa2kub2lkcykge1xuICAgICAgICAgIHJ2YWwgKz0gJyAoJyArIGZvcmdlLnBraS5vaWRzW29pZF0gKyAnKSAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmKG9iai50eXBlID09PSBhc24xLlR5cGUuSU5URUdFUikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnZhbCArPSBhc24xLmRlclRvSW50ZWdlcihvYmoudmFsdWUpO1xuICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICBydmFsICs9ICcweCcgKyBmb3JnZS51dGlsLmJ5dGVzVG9IZXgob2JqLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5CSVRTVFJJTkcpIHtcbiAgICAgIC8vIFRPRE86IHNoaWZ0IGJpdHMgYXMgbmVlZGVkIHRvIGRpc3BsYXkgd2l0aG91dCBwYWRkaW5nXG4gICAgICBpZihvYmoudmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyByZW1vdmUgdW51c2VkIGJpdHMgZmllbGRcbiAgICAgICAgcnZhbCArPSAnMHgnICsgZm9yZ2UudXRpbC5ieXRlc1RvSGV4KG9iai52YWx1ZS5zbGljZSgxKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsICs9ICcobm9uZSknO1xuICAgICAgfVxuICAgICAgLy8gc2hvdyB1bnVzZWQgYml0IGNvdW50XG4gICAgICBpZihvYmoudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdW51c2VkID0gb2JqLnZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmKHVudXNlZCA9PSAxKSB7XG4gICAgICAgICAgcnZhbCArPSAnICgxIHVudXNlZCBiaXQgc2hvd24pJztcbiAgICAgICAgfSBlbHNlIGlmKHVudXNlZCA+IDEpIHtcbiAgICAgICAgICBydmFsICs9ICcgKCcgKyB1bnVzZWQgKyAnIHVudXNlZCBiaXRzIHNob3duKSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5PQ1RFVFNUUklORykge1xuICAgICAgaWYoIV9ub25MYXRpblJlZ2V4LnRlc3Qob2JqLnZhbHVlKSkge1xuICAgICAgICBydmFsICs9ICcoJyArIG9iai52YWx1ZSArICcpICc7XG4gICAgICB9XG4gICAgICBydmFsICs9ICcweCcgKyBmb3JnZS51dGlsLmJ5dGVzVG9IZXgob2JqLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5VVEY4KSB7XG4gICAgICB0cnkge1xuICAgICAgICBydmFsICs9IGZvcmdlLnV0aWwuZGVjb2RlVXRmOChvYmoudmFsdWUpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGlmKGUubWVzc2FnZSA9PT0gJ1VSSSBtYWxmb3JtZWQnKSB7XG4gICAgICAgICAgcnZhbCArPVxuICAgICAgICAgICAgJzB4JyArIGZvcmdlLnV0aWwuYnl0ZXNUb0hleChvYmoudmFsdWUpICsgJyAobWFsZm9ybWVkIFVURjgpJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKG9iai50eXBlID09PSBhc24xLlR5cGUuUFJJTlRBQkxFU1RSSU5HIHx8XG4gICAgICBvYmoudHlwZSA9PT0gYXNuMS5UeXBlLklBNVN0cmluZykge1xuICAgICAgcnZhbCArPSBvYmoudmFsdWU7XG4gICAgfSBlbHNlIGlmKF9ub25MYXRpblJlZ2V4LnRlc3Qob2JqLnZhbHVlKSkge1xuICAgICAgcnZhbCArPSAnMHgnICsgZm9yZ2UudXRpbC5ieXRlc1RvSGV4KG9iai52YWx1ZSk7XG4gICAgfSBlbHNlIGlmKG9iai52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJ2YWwgKz0gJ1tudWxsXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ2YWwgKz0gb2JqLnZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJhc24xIiwibW9kdWxlIiwiZXhwb3J0cyIsIkNsYXNzIiwiVU5JVkVSU0FMIiwiQVBQTElDQVRJT04iLCJDT05URVhUX1NQRUNJRklDIiwiUFJJVkFURSIsIlR5cGUiLCJOT05FIiwiQk9PTEVBTiIsIklOVEVHRVIiLCJCSVRTVFJJTkciLCJPQ1RFVFNUUklORyIsIk5VTEwiLCJPSUQiLCJPREVTQyIsIkVYVEVSTkFMIiwiUkVBTCIsIkVOVU1FUkFURUQiLCJFTUJFRERFRCIsIlVURjgiLCJST0lEIiwiU0VRVUVOQ0UiLCJTRVQiLCJQUklOVEFCTEVTVFJJTkciLCJJQTVTVFJJTkciLCJVVENUSU1FIiwiR0VORVJBTElaRURUSU1FIiwiQk1QU1RSSU5HIiwiY3JlYXRlIiwidGFnQ2xhc3MiLCJ0eXBlIiwiY29uc3RydWN0ZWQiLCJ2YWx1ZSIsIm9wdGlvbnMiLCJ1dGlsIiwiaXNBcnJheSIsInRtcCIsImkiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJwdXNoIiwib2JqIiwiY29tcG9zZWQiLCJiaXRTdHJpbmdDb250ZW50cyIsIm9yaWdpbmFsIiwiY29weSIsImV4Y2x1ZGVCaXRTdHJpbmdDb250ZW50cyIsImVxdWFscyIsIm9iajEiLCJvYmoyIiwiZXF1YWwiLCJpbmNsdWRlQml0U3RyaW5nQ29udGVudHMiLCJnZXRCZXJWYWx1ZUxlbmd0aCIsImIiLCJiMiIsImdldEJ5dGUiLCJsb25nRm9ybSIsImdldEludCIsIl9jaGVja0J1ZmZlckxlbmd0aCIsImJ5dGVzIiwicmVtYWluaW5nIiwibiIsImVycm9yIiwiRXJyb3IiLCJhdmFpbGFibGUiLCJyZXF1ZXN0ZWQiLCJfZ2V0VmFsdWVMZW5ndGgiLCJsb25nRm9ybUJ5dGVzIiwiZnJvbURlciIsInN0cmljdCIsInBhcnNlQWxsQnl0ZXMiLCJkZWNvZGVCaXRTdHJpbmdzIiwiY3JlYXRlQnVmZmVyIiwiYnl0ZUNvdW50IiwiX2Zyb21EZXIiLCJkZXB0aCIsInN0YXJ0IiwiYjEiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJnZXRCeXRlcyIsInNhdmVkUmVhZCIsInJlYWQiLCJzYXZlZFJlbWFpbmluZyIsInVudXNlZCIsInN1Yk9wdGlvbnMiLCJ1c2VkIiwidGMiLCJleCIsImdldEludDE2IiwiYXNuMU9wdGlvbnMiLCJ0b0RlciIsInVzZUJpdFN0cmluZ0NvbnRlbnRzIiwicHV0Qnl0ZXMiLCJwdXRCeXRlIiwicHV0QnVmZmVyIiwicHV0SW50MTYiLCJjaGFyQ29kZUF0Iiwic3Vic3RyIiwibGVuIiwibGVuQnl0ZXMiLCJvaWRUb0RlciIsIm9pZCIsInZhbHVlcyIsInNwbGl0IiwicGFyc2VJbnQiLCJsYXN0IiwidmFsdWVCeXRlcyIsImRlclRvT2lkIiwiTWF0aCIsImZsb29yIiwidXRjVGltZVRvRGF0ZSIsInV0YyIsImRhdGUiLCJEYXRlIiwieWVhciIsIk1NIiwiREQiLCJoaCIsIm1tIiwic3MiLCJjIiwiY2hhckF0IiwiZW5kIiwic2V0VVRDRnVsbFllYXIiLCJzZXRVVENIb3VycyIsImhob2Zmc2V0IiwibW1vZmZzZXQiLCJvZmZzZXQiLCJzZXRUaW1lIiwiZ2VuZXJhbGl6ZWRUaW1lVG9EYXRlIiwiZ2VudGltZSIsIllZWVkiLCJmZmYiLCJpc1VUQyIsInBhcnNlRmxvYXQiLCJzZXRGdWxsWWVhciIsInNldEhvdXJzIiwiZGF0ZVRvVXRjVGltZSIsInJ2YWwiLCJmb3JtYXQiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJkYXRlVG9HZW5lcmFsaXplZFRpbWUiLCJpbnRlZ2VyVG9EZXIiLCJ4IiwicHV0U2lnbmVkSW50IiwiaW50ZWdlciIsImRlclRvSW50ZWdlciIsImdldFNpZ25lZEludCIsInZhbGlkYXRlIiwidiIsImNhcHR1cmUiLCJlcnJvcnMiLCJqIiwib3B0aW9uYWwiLCJuYW1lIiwiY2FwdHVyZUFzbjEiLCJjYXB0dXJlQml0U3RyaW5nQ29udGVudHMiLCJjYXB0dXJlQml0U3RyaW5nVmFsdWUiLCJzbGljZSIsIl9ub25MYXRpblJlZ2V4IiwicHJldHR5UHJpbnQiLCJsZXZlbCIsImluZGVudGF0aW9uIiwiaW5kZW50IiwiSUE1U3RyaW5nIiwic3VidmFsdWVzIiwic3ViIiwicGtpIiwib2lkcyIsImJ5dGVzVG9IZXgiLCJ0ZXN0IiwiZGVjb2RlVXRmOCIsImUiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/asn1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/baseN.js":
/*!**********************************************!*\
  !*** ./node_modules/node-forge/lib/baseN.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("/**\n * Base-N/Base-X encoding/decoding functions.\n *\n * Original implementation from base-x:\n * https://github.com/cryptocoinjs/base-x\n *\n * Which is MIT licensed:\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */ \nvar api = {};\nmodule.exports = api;\n// baseN alphabet indexes\nvar _reverseAlphabets = {};\n/**\n * BaseN-encodes a Uint8Array using the given alphabet.\n *\n * @param input the Uint8Array to encode.\n * @param maxline the maximum number of encoded characters per line to use,\n *          defaults to none.\n *\n * @return the baseN-encoded output string.\n */ api.encode = function(input, alphabet, maxline) {\n    if (typeof alphabet !== \"string\") {\n        throw new TypeError('\"alphabet\" must be a string.');\n    }\n    if (maxline !== undefined && typeof maxline !== \"number\") {\n        throw new TypeError('\"maxline\" must be a number.');\n    }\n    var output = \"\";\n    if (!(input instanceof Uint8Array)) {\n        // assume forge byte buffer\n        output = _encodeWithByteBuffer(input, alphabet);\n    } else {\n        var i = 0;\n        var base = alphabet.length;\n        var first = alphabet.charAt(0);\n        var digits = [\n            0\n        ];\n        for(i = 0; i < input.length; ++i){\n            for(var j = 0, carry = input[i]; j < digits.length; ++j){\n                carry += digits[j] << 8;\n                digits[j] = carry % base;\n                carry = carry / base | 0;\n            }\n            while(carry > 0){\n                digits.push(carry % base);\n                carry = carry / base | 0;\n            }\n        }\n        // deal with leading zeros\n        for(i = 0; input[i] === 0 && i < input.length - 1; ++i){\n            output += first;\n        }\n        // convert digits to a string\n        for(i = digits.length - 1; i >= 0; --i){\n            output += alphabet[digits[i]];\n        }\n    }\n    if (maxline) {\n        var regex = new RegExp(\".{1,\" + maxline + \"}\", \"g\");\n        output = output.match(regex).join(\"\\r\\n\");\n    }\n    return output;\n};\n/**\n * Decodes a baseN-encoded (using the given alphabet) string to a\n * Uint8Array.\n *\n * @param input the baseN-encoded input string.\n *\n * @return the Uint8Array.\n */ api.decode = function(input, alphabet) {\n    if (typeof input !== \"string\") {\n        throw new TypeError('\"input\" must be a string.');\n    }\n    if (typeof alphabet !== \"string\") {\n        throw new TypeError('\"alphabet\" must be a string.');\n    }\n    var table = _reverseAlphabets[alphabet];\n    if (!table) {\n        // compute reverse alphabet\n        table = _reverseAlphabets[alphabet] = [];\n        for(var i = 0; i < alphabet.length; ++i){\n            table[alphabet.charCodeAt(i)] = i;\n        }\n    }\n    // remove whitespace characters\n    input = input.replace(/\\s/g, \"\");\n    var base = alphabet.length;\n    var first = alphabet.charAt(0);\n    var bytes = [\n        0\n    ];\n    for(var i = 0; i < input.length; i++){\n        var value = table[input.charCodeAt(i)];\n        if (value === undefined) {\n            return;\n        }\n        for(var j = 0, carry = value; j < bytes.length; ++j){\n            carry += bytes[j] * base;\n            bytes[j] = carry & 0xff;\n            carry >>= 8;\n        }\n        while(carry > 0){\n            bytes.push(carry & 0xff);\n            carry >>= 8;\n        }\n    }\n    // deal with leading zeros\n    for(var k = 0; input[k] === first && k < input.length - 1; ++k){\n        bytes.push(0);\n    }\n    if (typeof Buffer !== \"undefined\") {\n        return Buffer.from(bytes.reverse());\n    }\n    return new Uint8Array(bytes.reverse());\n};\nfunction _encodeWithByteBuffer(input, alphabet) {\n    var i = 0;\n    var base = alphabet.length;\n    var first = alphabet.charAt(0);\n    var digits = [\n        0\n    ];\n    for(i = 0; i < input.length(); ++i){\n        for(var j = 0, carry = input.at(i); j < digits.length; ++j){\n            carry += digits[j] << 8;\n            digits[j] = carry % base;\n            carry = carry / base | 0;\n        }\n        while(carry > 0){\n            digits.push(carry % base);\n            carry = carry / base | 0;\n        }\n    }\n    var output = \"\";\n    // deal with leading zeros\n    for(i = 0; input.at(i) === 0 && i < input.length() - 1; ++i){\n        output += first;\n    }\n    // convert digits to a string\n    for(i = digits.length - 1; i >= 0; --i){\n        output += alphabet[digits[i]];\n    }\n    return output;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvYmFzZU4uanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkJDO0FBQ0QsSUFBSUEsTUFBTSxDQUFDO0FBQ1hDLE9BQU9DLE9BQU8sR0FBR0Y7QUFFakIseUJBQXlCO0FBQ3pCLElBQUlHLG9CQUFvQixDQUFDO0FBRXpCOzs7Ozs7OztDQVFDLEdBQ0RILElBQUlJLE1BQU0sR0FBRyxTQUFTQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsT0FBTztJQUM1QyxJQUFHLE9BQU9ELGFBQWEsVUFBVTtRQUMvQixNQUFNLElBQUlFLFVBQVU7SUFDdEI7SUFDQSxJQUFHRCxZQUFZRSxhQUFhLE9BQU9GLFlBQVksVUFBVTtRQUN2RCxNQUFNLElBQUlDLFVBQVU7SUFDdEI7SUFFQSxJQUFJRSxTQUFTO0lBRWIsSUFBRyxDQUFFTCxDQUFBQSxpQkFBaUJNLFVBQVMsR0FBSTtRQUNqQywyQkFBMkI7UUFDM0JELFNBQVNFLHNCQUFzQlAsT0FBT0M7SUFDeEMsT0FBTztRQUNMLElBQUlPLElBQUk7UUFDUixJQUFJQyxPQUFPUixTQUFTUyxNQUFNO1FBQzFCLElBQUlDLFFBQVFWLFNBQVNXLE1BQU0sQ0FBQztRQUM1QixJQUFJQyxTQUFTO1lBQUM7U0FBRTtRQUNoQixJQUFJTCxJQUFJLEdBQUdBLElBQUlSLE1BQU1VLE1BQU0sRUFBRSxFQUFFRixFQUFHO1lBQ2hDLElBQUksSUFBSU0sSUFBSSxHQUFHQyxRQUFRZixLQUFLLENBQUNRLEVBQUUsRUFBRU0sSUFBSUQsT0FBT0gsTUFBTSxFQUFFLEVBQUVJLEVBQUc7Z0JBQ3ZEQyxTQUFTRixNQUFNLENBQUNDLEVBQUUsSUFBSTtnQkFDdEJELE1BQU0sQ0FBQ0MsRUFBRSxHQUFHQyxRQUFRTjtnQkFDcEJNLFFBQVEsUUFBU04sT0FBUTtZQUMzQjtZQUVBLE1BQU1NLFFBQVEsRUFBRztnQkFDZkYsT0FBT0csSUFBSSxDQUFDRCxRQUFR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QUksR0FBR0MsUUFBUWYsTUFBTStCLEVBQUUsQ0FBQ3ZCLElBQUlNLElBQUlELE9BQU9ILE1BQU0sRUFBRSxFQUFFSSxFQUFHO1lBQzFEQyxTQUFTRixNQUFNLENBQUNDLEVBQUUsSUFBSTtZQUN0QkQsTUFBTSxDQUFDQyxFQUFFLEdBQUdDLFFBQVFOO1lBQ3BCTSxRQUFRLFFBQVNOLE9BQVE7UUFDM0I7UUFFQSxNQUFNTSxRQUFRLEVBQUc7WUFDZkYsT0FBT0csSUFBSSxDQUFDRCxRQUFRTjtZQUNwQk0sUUFBUSxRQUFTTixPQUFRO1FBQzNCO0lBQ0Y7SUFFQSxJQUFJSixTQUFTO0lBRWIsMEJBQTBCO0lBQzFCLElBQUlHLElBQUksR0FBR1IsTUFBTStCLEVBQUUsQ0FBQ3ZCLE9BQU8sS0FBS0EsSUFBSVIsTUFBTVUsTUFBTSxLQUFLLEdBQUcsRUFBRUYsRUFBRztRQUMzREgsVUFBVU07SUFDWjtJQUNBLDZCQUE2QjtJQUM3QixJQUFJSCxJQUFJSyxPQUFPSCxNQUFNLEdBQUcsR0FBR0YsS0FBSyxHQUFHLEVBQUVBLEVBQUc7UUFDdENILFVBQVVKLFFBQVEsQ0FBQ1ksTUFBTSxDQUFDTCxFQUFFLENBQUM7SUFDL0I7SUFFQSxPQUFPSDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2Jhc2VOLmpzPzc3NDEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBCYXNlLU4vQmFzZS1YIGVuY29kaW5nL2RlY29kaW5nIGZ1bmN0aW9ucy5cbiAqXG4gKiBPcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBmcm9tIGJhc2UteDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvYmFzZS14XG4gKlxuICogV2hpY2ggaXMgTUlUIGxpY2Vuc2VkOlxuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCBiYXNlLXggY29udHJpYnV0b3JzIChjKSAyMDE2XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xudmFyIGFwaSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cbi8vIGJhc2VOIGFscGhhYmV0IGluZGV4ZXNcbnZhciBfcmV2ZXJzZUFscGhhYmV0cyA9IHt9O1xuXG4vKipcbiAqIEJhc2VOLWVuY29kZXMgYSBVaW50OEFycmF5IHVzaW5nIHRoZSBnaXZlbiBhbHBoYWJldC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIFVpbnQ4QXJyYXkgdG8gZW5jb2RlLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVuY29kZWQgY2hhcmFjdGVycyBwZXIgbGluZSB0byB1c2UsXG4gKiAgICAgICAgICBkZWZhdWx0cyB0byBub25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGJhc2VOLWVuY29kZWQgb3V0cHV0IHN0cmluZy5cbiAqL1xuYXBpLmVuY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBhbHBoYWJldCwgbWF4bGluZSkge1xuICBpZih0eXBlb2YgYWxwaGFiZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhbHBoYWJldFwiIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gIH1cbiAgaWYobWF4bGluZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBtYXhsaW5lICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibWF4bGluZVwiIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gIH1cblxuICB2YXIgb3V0cHV0ID0gJyc7XG5cbiAgaWYoIShpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgLy8gYXNzdW1lIGZvcmdlIGJ5dGUgYnVmZmVyXG4gICAgb3V0cHV0ID0gX2VuY29kZVdpdGhCeXRlQnVmZmVyKGlucHV0LCBhbHBoYWJldCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBiYXNlID0gYWxwaGFiZXQubGVuZ3RoO1xuICAgIHZhciBmaXJzdCA9IGFscGhhYmV0LmNoYXJBdCgwKTtcbiAgICB2YXIgZGlnaXRzID0gWzBdO1xuICAgIGZvcihpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBmb3IodmFyIGogPSAwLCBjYXJyeSA9IGlucHV0W2ldOyBqIDwgZGlnaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGNhcnJ5ICs9IGRpZ2l0c1tqXSA8PCA4O1xuICAgICAgICBkaWdpdHNbal0gPSBjYXJyeSAlIGJhc2U7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgICAgfVxuXG4gICAgICB3aGlsZShjYXJyeSA+IDApIHtcbiAgICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSBiYXNlKTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBiYXNlKSB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICBmb3IoaSA9IDA7IGlucHV0W2ldID09PSAwICYmIGkgPCBpbnB1dC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIG91dHB1dCArPSBmaXJzdDtcbiAgICB9XG4gICAgLy8gY29udmVydCBkaWdpdHMgdG8gYSBzdHJpbmdcbiAgICBmb3IoaSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgb3V0cHV0ICs9IGFscGhhYmV0W2RpZ2l0c1tpXV07XG4gICAgfVxuICB9XG5cbiAgaWYobWF4bGluZSkge1xuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJy57MSwnICsgbWF4bGluZSArICd9JywgJ2cnKTtcbiAgICBvdXRwdXQgPSBvdXRwdXQubWF0Y2gocmVnZXgpLmpvaW4oJ1xcclxcbicpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIGJhc2VOLWVuY29kZWQgKHVzaW5nIHRoZSBnaXZlbiBhbHBoYWJldCkgc3RyaW5nIHRvIGFcbiAqIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBiYXNlTi1lbmNvZGVkIGlucHV0IHN0cmluZy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5LlxuICovXG5hcGkuZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQsIGFscGhhYmV0KSB7XG4gIGlmKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImlucHV0XCIgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgfVxuICBpZih0eXBlb2YgYWxwaGFiZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhbHBoYWJldFwiIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gIH1cblxuICB2YXIgdGFibGUgPSBfcmV2ZXJzZUFscGhhYmV0c1thbHBoYWJldF07XG4gIGlmKCF0YWJsZSkge1xuICAgIC8vIGNvbXB1dGUgcmV2ZXJzZSBhbHBoYWJldFxuICAgIHRhYmxlID0gX3JldmVyc2VBbHBoYWJldHNbYWxwaGFiZXRdID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICB0YWJsZVthbHBoYWJldC5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVtb3ZlIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1xccy9nLCAnJyk7XG5cbiAgdmFyIGJhc2UgPSBhbHBoYWJldC5sZW5ndGg7XG4gIHZhciBmaXJzdCA9IGFscGhhYmV0LmNoYXJBdCgwKTtcbiAgdmFyIGJ5dGVzID0gWzBdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsdWUgPSB0YWJsZVtpbnB1dC5jaGFyQ29kZUF0KGkpXTtcbiAgICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yKHZhciBqID0gMCwgY2FycnkgPSB2YWx1ZTsgaiA8IGJ5dGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBjYXJyeSArPSBieXRlc1tqXSAqIGJhc2U7XG4gICAgICBieXRlc1tqXSA9IGNhcnJ5ICYgMHhmZjtcbiAgICAgIGNhcnJ5ID4+PSA4O1xuICAgIH1cblxuICAgIHdoaWxlKGNhcnJ5ID4gMCkge1xuICAgICAgYnl0ZXMucHVzaChjYXJyeSAmIDB4ZmYpO1xuICAgICAgY2FycnkgPj49IDg7XG4gICAgfVxuICB9XG5cbiAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgZm9yKHZhciBrID0gMDsgaW5wdXRba10gPT09IGZpcnN0ICYmIGsgPCBpbnB1dC5sZW5ndGggLSAxOyArK2spIHtcbiAgICBieXRlcy5wdXNoKDApO1xuICB9XG5cbiAgaWYodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMucmV2ZXJzZSgpKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcy5yZXZlcnNlKCkpO1xufTtcblxuZnVuY3Rpb24gX2VuY29kZVdpdGhCeXRlQnVmZmVyKGlucHV0LCBhbHBoYWJldCkge1xuICB2YXIgaSA9IDA7XG4gIHZhciBiYXNlID0gYWxwaGFiZXQubGVuZ3RoO1xuICB2YXIgZmlyc3QgPSBhbHBoYWJldC5jaGFyQXQoMCk7XG4gIHZhciBkaWdpdHMgPSBbMF07XG4gIGZvcihpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCgpOyArK2kpIHtcbiAgICBmb3IodmFyIGogPSAwLCBjYXJyeSA9IGlucHV0LmF0KGkpOyBqIDwgZGlnaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICBjYXJyeSArPSBkaWdpdHNbal0gPDwgODtcbiAgICAgIGRpZ2l0c1tqXSA9IGNhcnJ5ICUgYmFzZTtcbiAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgIH1cblxuICAgIHdoaWxlKGNhcnJ5ID4gMCkge1xuICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSBiYXNlKTtcbiAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXQgPSAnJztcblxuICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuICBmb3IoaSA9IDA7IGlucHV0LmF0KGkpID09PSAwICYmIGkgPCBpbnB1dC5sZW5ndGgoKSAtIDE7ICsraSkge1xuICAgIG91dHB1dCArPSBmaXJzdDtcbiAgfVxuICAvLyBjb252ZXJ0IGRpZ2l0cyB0byBhIHN0cmluZ1xuICBmb3IoaSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIG91dHB1dCArPSBhbHBoYWJldFtkaWdpdHNbaV1dO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbiJdLCJuYW1lcyI6WyJhcGkiLCJtb2R1bGUiLCJleHBvcnRzIiwiX3JldmVyc2VBbHBoYWJldHMiLCJlbmNvZGUiLCJpbnB1dCIsImFscGhhYmV0IiwibWF4bGluZSIsIlR5cGVFcnJvciIsInVuZGVmaW5lZCIsIm91dHB1dCIsIlVpbnQ4QXJyYXkiLCJfZW5jb2RlV2l0aEJ5dGVCdWZmZXIiLCJpIiwiYmFzZSIsImxlbmd0aCIsImZpcnN0IiwiY2hhckF0IiwiZGlnaXRzIiwiaiIsImNhcnJ5IiwicHVzaCIsInJlZ2V4IiwiUmVnRXhwIiwibWF0Y2giLCJqb2luIiwiZGVjb2RlIiwidGFibGUiLCJjaGFyQ29kZUF0IiwicmVwbGFjZSIsImJ5dGVzIiwidmFsdWUiLCJrIiwiQnVmZmVyIiwiZnJvbSIsInJldmVyc2UiLCJhdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/baseN.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/cipher.js":
/*!***********************************************!*\
  !*** ./node_modules/node-forge/lib/cipher.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Cipher base API.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\nmodule.exports = forge.cipher = forge.cipher || {};\n// registered algorithms\nforge.cipher.algorithms = forge.cipher.algorithms || {};\n/**\n * Creates a cipher object that can be used to encrypt data using the given\n * algorithm and key. The algorithm may be provided as a string value for a\n * previously registered algorithm or it may be given as a cipher algorithm\n * API object.\n *\n * @param algorithm the algorithm to use, either a string or an algorithm API\n *          object.\n * @param key the key to use, as a binary-encoded string of bytes or a\n *          byte buffer.\n *\n * @return the cipher.\n */ forge.cipher.createCipher = function(algorithm, key) {\n    var api = algorithm;\n    if (typeof api === \"string\") {\n        api = forge.cipher.getAlgorithm(api);\n        if (api) {\n            api = api();\n        }\n    }\n    if (!api) {\n        throw new Error(\"Unsupported algorithm: \" + algorithm);\n    }\n    // assume block cipher\n    return new forge.cipher.BlockCipher({\n        algorithm: api,\n        key: key,\n        decrypt: false\n    });\n};\n/**\n * Creates a decipher object that can be used to decrypt data using the given\n * algorithm and key. The algorithm may be provided as a string value for a\n * previously registered algorithm or it may be given as a cipher algorithm\n * API object.\n *\n * @param algorithm the algorithm to use, either a string or an algorithm API\n *          object.\n * @param key the key to use, as a binary-encoded string of bytes or a\n *          byte buffer.\n *\n * @return the cipher.\n */ forge.cipher.createDecipher = function(algorithm, key) {\n    var api = algorithm;\n    if (typeof api === \"string\") {\n        api = forge.cipher.getAlgorithm(api);\n        if (api) {\n            api = api();\n        }\n    }\n    if (!api) {\n        throw new Error(\"Unsupported algorithm: \" + algorithm);\n    }\n    // assume block cipher\n    return new forge.cipher.BlockCipher({\n        algorithm: api,\n        key: key,\n        decrypt: true\n    });\n};\n/**\n * Registers an algorithm by name. If the name was already registered, the\n * algorithm API object will be overwritten.\n *\n * @param name the name of the algorithm.\n * @param algorithm the algorithm API object.\n */ forge.cipher.registerAlgorithm = function(name, algorithm) {\n    name = name.toUpperCase();\n    forge.cipher.algorithms[name] = algorithm;\n};\n/**\n * Gets a registered algorithm by name.\n *\n * @param name the name of the algorithm.\n *\n * @return the algorithm, if found, null if not.\n */ forge.cipher.getAlgorithm = function(name) {\n    name = name.toUpperCase();\n    if (name in forge.cipher.algorithms) {\n        return forge.cipher.algorithms[name];\n    }\n    return null;\n};\nvar BlockCipher = forge.cipher.BlockCipher = function(options) {\n    this.algorithm = options.algorithm;\n    this.mode = this.algorithm.mode;\n    this.blockSize = this.mode.blockSize;\n    this._finish = false;\n    this._input = null;\n    this.output = null;\n    this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;\n    this._decrypt = options.decrypt;\n    this.algorithm.initialize(options);\n};\n/**\n * Starts or restarts the encryption or decryption process, whichever\n * was previously configured.\n *\n * For non-GCM mode, the IV may be a binary-encoded string of bytes, an array\n * of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in\n * bytes, then it must be Nb (16) bytes in length. If the IV is given in as\n * 32-bit integers, then it must be 4 integers long.\n *\n * Note: an IV is not required or used in ECB mode.\n *\n * For GCM-mode, the IV must be given as a binary-encoded string of bytes or\n * a byte buffer. The number of bytes should be 12 (96 bits) as recommended\n * by NIST SP-800-38D but another length may be given.\n *\n * @param options the options to use:\n *          iv the initialization vector to use as a binary-encoded string of\n *            bytes, null to reuse the last ciphered block from a previous\n *            update() (this \"residue\" method is for legacy support only).\n *          additionalData additional authentication data as a binary-encoded\n *            string of bytes, for 'GCM' mode, (default: none).\n *          tagLength desired length of authentication tag, in bits, for\n *            'GCM' mode (0-128, default: 128).\n *          tag the authentication tag to check if decrypting, as a\n *             binary-encoded string of bytes.\n *          output the output the buffer to write to, null to create one.\n */ BlockCipher.prototype.start = function(options) {\n    options = options || {};\n    var opts = {};\n    for(var key in options){\n        opts[key] = options[key];\n    }\n    opts.decrypt = this._decrypt;\n    this._finish = false;\n    this._input = forge.util.createBuffer();\n    this.output = options.output || forge.util.createBuffer();\n    this.mode.start(opts);\n};\n/**\n * Updates the next block according to the cipher mode.\n *\n * @param input the buffer to read from.\n */ BlockCipher.prototype.update = function(input) {\n    if (input) {\n        // input given, so empty it into the input buffer\n        this._input.putBuffer(input);\n    }\n    // do cipher operation until it needs more input and not finished\n    while(!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish){}\n    // free consumed memory from input buffer\n    this._input.compact();\n};\n/**\n * Finishes encrypting or decrypting.\n *\n * @param pad a padding function to use in CBC mode, null for default,\n *          signature(blockSize, buffer, decrypt).\n *\n * @return true if successful, false on error.\n */ BlockCipher.prototype.finish = function(pad) {\n    // backwards-compatibility w/deprecated padding API\n    // Note: will overwrite padding functions even after another start() call\n    if (pad && (this.mode.name === \"ECB\" || this.mode.name === \"CBC\")) {\n        this.mode.pad = function(input) {\n            return pad(this.blockSize, input, false);\n        };\n        this.mode.unpad = function(output) {\n            return pad(this.blockSize, output, true);\n        };\n    }\n    // build options for padding and afterFinish functions\n    var options = {};\n    options.decrypt = this._decrypt;\n    // get # of bytes that won't fill a block\n    options.overflow = this._input.length() % this.blockSize;\n    if (!this._decrypt && this.mode.pad) {\n        if (!this.mode.pad(this._input, options)) {\n            return false;\n        }\n    }\n    // do final update\n    this._finish = true;\n    this.update();\n    if (this._decrypt && this.mode.unpad) {\n        if (!this.mode.unpad(this.output, options)) {\n            return false;\n        }\n    }\n    if (this.mode.afterFinish) {\n        if (!this.mode.afterFinish(this.output, options)) {\n            return false;\n        }\n    }\n    return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvY2lwaGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Q0FNQztBQUNELElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCQSxtQkFBT0EsQ0FBQztBQUVSQyxPQUFPQyxPQUFPLEdBQUdILE1BQU1JLE1BQU0sR0FBR0osTUFBTUksTUFBTSxJQUFJLENBQUM7QUFFakQsd0JBQXdCO0FBQ3hCSixNQUFNSSxNQUFNLENBQUNDLFVBQVUsR0FBR0wsTUFBTUksTUFBTSxDQUFDQyxVQUFVLElBQUksQ0FBQztBQUV0RDs7Ozs7Ozs7Ozs7O0NBWUMsR0FDREwsTUFBTUksTUFBTSxDQUFDRSxZQUFZLEdBQUcsU0FBU0MsU0FBUyxFQUFFQyxHQUFHO0lBQ2pELElBQUlDLE1BQU1GO0lBQ1YsSUFBRyxPQUFPRSxRQUFRLFVBQVU7UUFDMUJBLE1BQU1ULE1BQU1JLE1BQU0sQ0FBQ00sWUFBWSxDQUFDRDtRQUNoQyxJQUFHQSxLQUFLO1lBQ05BLE1BQU1BO1FBQ1I7SUFDRjtJQUNBLElBQUcsQ0FBQ0EsS0FBSztRQUNQLE1BQU0sSUFBSUUsTUFBTSw0QkFBNEJKO0lBQzlDO0lBRUEsc0JBQXNCO0lBQ3RCLE9BQU8sSUFBSVAsTUFBTUksTUFBTSxDQUFDUSxXQUFXLENBQUM7UUFDbENMLFdBQVdFO1FBQ1hELEtBQUtBO1FBQ0xLLFNBQVM7SUFDWDtBQUNGO0FBRUE7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0RiLE1BQU1JLE1BQU0sQ0FBQ1UsY0FBYyxHQUFHLFNBQVNQLFNBQVMsRUFBRUMsR0FBRztJQUNuRCxJQUFJQyxNQUFNRjtJQUNWLElBQUcsT0FBT0UsUUFBUSxVQUFVO1FBQzFCQSxNQUFNVCxNQUFNSSxNQUFNLENBQUNNLFlBQVksQ0FBQ0Q7UUFDaEMsSUFBR0EsS0FBSztZQUNOQSxNQUFNQTtRQUNSO0lBQ0Y7SUFDQSxJQUFHLENBQUNBLEtBQUs7UUFDUCxNQUFNLElBQUlFLE1BQU0sNEJBQTRCSjtJQUM5QztJ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O1FBQ3hCLElBQUcsQ0FBQyxJQUFJLENBQUN4QixJQUFJLENBQUN3QixXQUFXLENBQUMsSUFBSSxDQUFDcEIsTUFBTSxFQUFFTCxVQUFVO1lBQy9DLE9BQU87UUFDVDtJQUNGO0lBRUEsT0FBTztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2NpcGhlci5qcz84MjE4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2lwaGVyIGJhc2UgQVBJLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UuY2lwaGVyID0gZm9yZ2UuY2lwaGVyIHx8IHt9O1xuXG4vLyByZWdpc3RlcmVkIGFsZ29yaXRobXNcbmZvcmdlLmNpcGhlci5hbGdvcml0aG1zID0gZm9yZ2UuY2lwaGVyLmFsZ29yaXRobXMgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNpcGhlciBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBlbmNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuXG4gKiBhbGdvcml0aG0gYW5kIGtleS4gVGhlIGFsZ29yaXRobSBtYXkgYmUgcHJvdmlkZWQgYXMgYSBzdHJpbmcgdmFsdWUgZm9yIGFcbiAqIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBhbGdvcml0aG0gb3IgaXQgbWF5IGJlIGdpdmVuIGFzIGEgY2lwaGVyIGFsZ29yaXRobVxuICogQVBJIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYWxnb3JpdGhtIHRoZSBhbGdvcml0aG0gdG8gdXNlLCBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gYWxnb3JpdGhtIEFQSVxuICogICAgICAgICAgb2JqZWN0LlxuICogQHBhcmFtIGtleSB0aGUga2V5IHRvIHVzZSwgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3IgYVxuICogICAgICAgICAgYnl0ZSBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyID0gZnVuY3Rpb24oYWxnb3JpdGhtLCBrZXkpIHtcbiAgdmFyIGFwaSA9IGFsZ29yaXRobTtcbiAgaWYodHlwZW9mIGFwaSA9PT0gJ3N0cmluZycpIHtcbiAgICBhcGkgPSBmb3JnZS5jaXBoZXIuZ2V0QWxnb3JpdGhtKGFwaSk7XG4gICAgaWYoYXBpKSB7XG4gICAgICBhcGkgPSBhcGkoKTtcbiAgICB9XG4gIH1cbiAgaWYoIWFwaSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiAnICsgYWxnb3JpdGhtKTtcbiAgfVxuXG4gIC8vIGFzc3VtZSBibG9jayBjaXBoZXJcbiAgcmV0dXJuIG5ldyBmb3JnZS5jaXBoZXIuQmxvY2tDaXBoZXIoe1xuICAgIGFsZ29yaXRobTogYXBpLFxuICAgIGtleToga2V5LFxuICAgIGRlY3J5cHQ6IGZhbHNlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVjaXBoZXIgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZGVjcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlblxuICogYWxnb3JpdGhtIGFuZCBrZXkuIFRoZSBhbGdvcml0aG0gbWF5IGJlIHByb3ZpZGVkIGFzIGEgc3RyaW5nIHZhbHVlIGZvciBhXG4gKiBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgYWxnb3JpdGhtIG9yIGl0IG1heSBiZSBnaXZlbiBhcyBhIGNpcGhlciBhbGdvcml0aG1cbiAqIEFQSSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGFsZ29yaXRobSB0aGUgYWxnb3JpdGhtIHRvIHVzZSwgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIGFsZ29yaXRobSBBUElcbiAqICAgICAgICAgIG9iamVjdC5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1c2UsIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIG9yIGFcbiAqICAgICAgICAgIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyID0gZnVuY3Rpb24oYWxnb3JpdGhtLCBrZXkpIHtcbiAgdmFyIGFwaSA9IGFsZ29yaXRobTtcbiAgaWYodHlwZW9mIGFwaSA9PT0gJ3N0cmluZycpIHtcbiAgICBhcGkgPSBmb3JnZS5jaXBoZXIuZ2V0QWxnb3JpdGhtKGFwaSk7XG4gICAgaWYoYXBpKSB7XG4gICAgICBhcGkgPSBhcGkoKTtcbiAgICB9XG4gIH1cbiAgaWYoIWFwaSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiAnICsgYWxnb3JpdGhtKTtcbiAgfVxuXG4gIC8vIGFzc3VtZSBibG9jayBjaXBoZXJcbiAgcmV0dXJuIG5ldyBmb3JnZS5jaXBoZXIuQmxvY2tDaXBoZXIoe1xuICAgIGFsZ29yaXRobTogYXBpLFxuICAgIGtleToga2V5LFxuICAgIGRlY3J5cHQ6IHRydWVcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBhbGdvcml0aG0gYnkgbmFtZS4gSWYgdGhlIG5hbWUgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZCwgdGhlXG4gKiBhbGdvcml0aG0gQVBJIG9iamVjdCB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuICpcbiAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBhbGdvcml0aG0uXG4gKiBAcGFyYW0gYWxnb3JpdGhtIHRoZSBhbGdvcml0aG0gQVBJIG9iamVjdC5cbiAqL1xuZm9yZ2UuY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtID0gZnVuY3Rpb24obmFtZSwgYWxnb3JpdGhtKSB7XG4gIG5hbWUgPSBuYW1lLnRvVXBwZXJDYXNlKCk7XG4gIGZvcmdlLmNpcGhlci5hbGdvcml0aG1zW25hbWVdID0gYWxnb3JpdGhtO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgcmVnaXN0ZXJlZCBhbGdvcml0aG0gYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgYWxnb3JpdGhtLlxuICpcbiAqIEByZXR1cm4gdGhlIGFsZ29yaXRobSwgaWYgZm91bmQsIG51bGwgaWYgbm90LlxuICovXG5mb3JnZS5jaXBoZXIuZ2V0QWxnb3JpdGhtID0gZnVuY3Rpb24obmFtZSkge1xuICBuYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICBpZihuYW1lIGluIGZvcmdlLmNpcGhlci5hbGdvcml0aG1zKSB7XG4gICAgcmV0dXJuIGZvcmdlLmNpcGhlci5hbGdvcml0aG1zW25hbWVdO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIEJsb2NrQ2lwaGVyID0gZm9yZ2UuY2lwaGVyLkJsb2NrQ2lwaGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB0aGlzLmFsZ29yaXRobSA9IG9wdGlvbnMuYWxnb3JpdGhtO1xuICB0aGlzLm1vZGUgPSB0aGlzLmFsZ29yaXRobS5tb2RlO1xuICB0aGlzLmJsb2NrU2l6ZSA9IHRoaXMubW9kZS5ibG9ja1NpemU7XG4gIHRoaXMuX2ZpbmlzaCA9IGZhbHNlO1xuICB0aGlzLl9pbnB1dCA9IG51bGw7XG4gIHRoaXMub3V0cHV0ID0gbnVsbDtcbiAgdGhpcy5fb3AgPSBvcHRpb25zLmRlY3J5cHQgPyB0aGlzLm1vZGUuZGVjcnlwdCA6IHRoaXMubW9kZS5lbmNyeXB0O1xuICB0aGlzLl9kZWNyeXB0ID0gb3B0aW9ucy5kZWNyeXB0O1xuICB0aGlzLmFsZ29yaXRobS5pbml0aWFsaXplKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBTdGFydHMgb3IgcmVzdGFydHMgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBwcm9jZXNzLCB3aGljaGV2ZXJcbiAqIHdhcyBwcmV2aW91c2x5IGNvbmZpZ3VyZWQuXG4gKlxuICogRm9yIG5vbi1HQ00gbW9kZSwgdGhlIElWIG1heSBiZSBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXlcbiAqIG9mIGJ5dGVzLCBhIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgaW50ZWdlcnMuIElmIHRoZSBJViBpcyBpblxuICogYnl0ZXMsIHRoZW4gaXQgbXVzdCBiZSBOYiAoMTYpIGJ5dGVzIGluIGxlbmd0aC4gSWYgdGhlIElWIGlzIGdpdmVuIGluIGFzXG4gKiAzMi1iaXQgaW50ZWdlcnMsIHRoZW4gaXQgbXVzdCBiZSA0IGludGVnZXJzIGxvbmcuXG4gKlxuICogTm90ZTogYW4gSVYgaXMgbm90IHJlcXVpcmVkIG9yIHVzZWQgaW4gRUNCIG1vZGUuXG4gKlxuICogRm9yIEdDTS1tb2RlLCB0aGUgSVYgbXVzdCBiZSBnaXZlbiBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcyBvclxuICogYSBieXRlIGJ1ZmZlci4gVGhlIG51bWJlciBvZiBieXRlcyBzaG91bGQgYmUgMTIgKDk2IGJpdHMpIGFzIHJlY29tbWVuZGVkXG4gKiBieSBOSVNUIFNQLTgwMC0zOEQgYnV0IGFub3RoZXIgbGVuZ3RoIG1heSBiZSBnaXZlbi5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZSBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZlxuICogICAgICAgICAgICBieXRlcywgbnVsbCB0byByZXVzZSB0aGUgbGFzdCBjaXBoZXJlZCBibG9jayBmcm9tIGEgcHJldmlvdXNcbiAqICAgICAgICAgICAgdXBkYXRlKCkgKHRoaXMgXCJyZXNpZHVlXCIgbWV0aG9kIGlzIGZvciBsZWdhY3kgc3VwcG9ydCBvbmx5KS5cbiAqICAgICAgICAgIGFkZGl0aW9uYWxEYXRhIGFkZGl0aW9uYWwgYXV0aGVudGljYXRpb24gZGF0YSBhcyBhIGJpbmFyeS1lbmNvZGVkXG4gKiAgICAgICAgICAgIHN0cmluZyBvZiBieXRlcywgZm9yICdHQ00nIG1vZGUsIChkZWZhdWx0OiBub25lKS5cbiAqICAgICAgICAgIHRhZ0xlbmd0aCBkZXNpcmVkIGxlbmd0aCBvZiBhdXRoZW50aWNhdGlvbiB0YWcsIGluIGJpdHMsIGZvclxuICogICAgICAgICAgICAnR0NNJyBtb2RlICgwLTEyOCwgZGVmYXVsdDogMTI4KS5cbiAqICAgICAgICAgIHRhZyB0aGUgYXV0aGVudGljYXRpb24gdGFnIHRvIGNoZWNrIGlmIGRlY3J5cHRpbmcsIGFzIGFcbiAqICAgICAgICAgICAgIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqICAgICAgICAgIG91dHB1dCB0aGUgb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8sIG51bGwgdG8gY3JlYXRlIG9uZS5cbiAqL1xuQmxvY2tDaXBoZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIG9wdHMgPSB7fTtcbiAgZm9yKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgIG9wdHNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgfVxuICBvcHRzLmRlY3J5cHQgPSB0aGlzLl9kZWNyeXB0O1xuICB0aGlzLl9maW5pc2ggPSBmYWxzZTtcbiAgdGhpcy5faW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLm91dHB1dCA9IG9wdGlvbnMub3V0cHV0IHx8IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIHRoaXMubW9kZS5zdGFydChvcHRzKTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgbmV4dCBibG9jayBhY2NvcmRpbmcgdG8gdGhlIGNpcGhlciBtb2RlLlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgYnVmZmVyIHRvIHJlYWQgZnJvbS5cbiAqL1xuQmxvY2tDaXBoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGlmKGlucHV0KSB7XG4gICAgLy8gaW5wdXQgZ2l2ZW4sIHNvIGVtcHR5IGl0IGludG8gdGhlIGlucHV0IGJ1ZmZlclxuICAgIHRoaXMuX2lucHV0LnB1dEJ1ZmZlcihpbnB1dCk7XG4gIH1cblxuICAvLyBkbyBjaXBoZXIgb3BlcmF0aW9uIHVudGlsIGl0IG5lZWRzIG1vcmUgaW5wdXQgYW5kIG5vdCBmaW5pc2hlZFxuICB3aGlsZSghdGhpcy5fb3AuY2FsbCh0aGlzLm1vZGUsIHRoaXMuX2lucHV0LCB0aGlzLm91dHB1dCwgdGhpcy5fZmluaXNoKSAmJlxuICAgICF0aGlzLl9maW5pc2gpIHt9XG5cbiAgLy8gZnJlZSBjb25zdW1lZCBtZW1vcnkgZnJvbSBpbnB1dCBidWZmZXJcbiAgdGhpcy5faW5wdXQuY29tcGFjdCgpO1xufTtcblxuLyoqXG4gKiBGaW5pc2hlcyBlbmNyeXB0aW5nIG9yIGRlY3J5cHRpbmcuXG4gKlxuICogQHBhcmFtIHBhZCBhIHBhZGRpbmcgZnVuY3Rpb24gdG8gdXNlIGluIENCQyBtb2RlLCBudWxsIGZvciBkZWZhdWx0LFxuICogICAgICAgICAgc2lnbmF0dXJlKGJsb2NrU2l6ZSwgYnVmZmVyLCBkZWNyeXB0KS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgc3VjY2Vzc2Z1bCwgZmFsc2Ugb24gZXJyb3IuXG4gKi9cbkJsb2NrQ2lwaGVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbihwYWQpIHtcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgdy9kZXByZWNhdGVkIHBhZGRpbmcgQVBJXG4gIC8vIE5vdGU6IHdpbGwgb3ZlcndyaXRlIHBhZGRpbmcgZnVuY3Rpb25zIGV2ZW4gYWZ0ZXIgYW5vdGhlciBzdGFydCgpIGNhbGxcbiAgaWYocGFkICYmICh0aGlzLm1vZGUubmFtZSA9PT0gJ0VDQicgfHwgdGhpcy5tb2RlLm5hbWUgPT09ICdDQkMnKSkge1xuICAgIHRoaXMubW9kZS5wYWQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgcmV0dXJuIHBhZCh0aGlzLmJsb2NrU2l6ZSwgaW5wdXQsIGZhbHNlKTtcbiAgICB9O1xuICAgIHRoaXMubW9kZS51bnBhZCA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgcmV0dXJuIHBhZCh0aGlzLmJsb2NrU2l6ZSwgb3V0cHV0LCB0cnVlKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gYnVpbGQgb3B0aW9ucyBmb3IgcGFkZGluZyBhbmQgYWZ0ZXJGaW5pc2ggZnVuY3Rpb25zXG4gIHZhciBvcHRpb25zID0ge307XG4gIG9wdGlvbnMuZGVjcnlwdCA9IHRoaXMuX2RlY3J5cHQ7XG5cbiAgLy8gZ2V0ICMgb2YgYnl0ZXMgdGhhdCB3b24ndCBmaWxsIGEgYmxvY2tcbiAgb3B0aW9ucy5vdmVyZmxvdyA9IHRoaXMuX2lucHV0Lmxlbmd0aCgpICUgdGhpcy5ibG9ja1NpemU7XG5cbiAgaWYoIXRoaXMuX2RlY3J5cHQgJiYgdGhpcy5tb2RlLnBhZCkge1xuICAgIGlmKCF0aGlzLm1vZGUucGFkKHRoaXMuX2lucHV0LCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGRvIGZpbmFsIHVwZGF0ZVxuICB0aGlzLl9maW5pc2ggPSB0cnVlO1xuICB0aGlzLnVwZGF0ZSgpO1xuXG4gIGlmKHRoaXMuX2RlY3J5cHQgJiYgdGhpcy5tb2RlLnVucGFkKSB7XG4gICAgaWYoIXRoaXMubW9kZS51bnBhZCh0aGlzLm91dHB1dCwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZih0aGlzLm1vZGUuYWZ0ZXJGaW5pc2gpIHtcbiAgICBpZighdGhpcy5tb2RlLmFmdGVyRmluaXNoKHRoaXMub3V0cHV0LCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiY2lwaGVyIiwiYWxnb3JpdGhtcyIsImNyZWF0ZUNpcGhlciIsImFsZ29yaXRobSIsImtleSIsImFwaSIsImdldEFsZ29yaXRobSIsIkVycm9yIiwiQmxvY2tDaXBoZXIiLCJkZWNyeXB0IiwiY3JlYXRlRGVjaXBoZXIiLCJyZWdpc3RlckFsZ29yaXRobSIsIm5hbWUiLCJ0b1VwcGVyQ2FzZSIsIm9wdGlvbnMiLCJtb2RlIiwiYmxvY2tTaXplIiwiX2ZpbmlzaCIsIl9pbnB1dCIsIm91dHB1dCIsIl9vcCIsImVuY3J5cHQiLCJfZGVjcnlwdCIsImluaXRpYWxpemUiLCJwcm90b3R5cGUiLCJzdGFydCIsIm9wdHMiLCJ1dGlsIiwiY3JlYXRlQnVmZmVyIiwidXBkYXRlIiwiaW5wdXQiLCJwdXRCdWZmZXIiLCJjYWxsIiwiY29tcGFjdCIsImZpbmlzaCIsInBhZCIsInVucGFkIiwib3ZlcmZsb3ciLCJsZW5ndGgiLCJhZnRlckZpbmlzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/cipher.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/cipherModes.js":
/*!****************************************************!*\
  !*** ./node_modules/node-forge/lib/cipherModes.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Supported cipher modes.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\nforge.cipher = forge.cipher || {};\n// supported cipher modes\nvar modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};\n/** Electronic codebook (ECB) (Don't use this; it's not secure) **/ modes.ecb = function(options) {\n    options = options || {};\n    this.name = \"ECB\";\n    this.cipher = options.cipher;\n    this.blockSize = options.blockSize || 16;\n    this._ints = this.blockSize / 4;\n    this._inBlock = new Array(this._ints);\n    this._outBlock = new Array(this._ints);\n};\nmodes.ecb.prototype.start = function(options) {};\nmodes.ecb.prototype.encrypt = function(input, output, finish) {\n    // not enough input to encrypt\n    if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n        return true;\n    }\n    // get next block\n    for(var i = 0; i < this._ints; ++i){\n        this._inBlock[i] = input.getInt32();\n    }\n    // encrypt block\n    this.cipher.encrypt(this._inBlock, this._outBlock);\n    // write output\n    for(var i = 0; i < this._ints; ++i){\n        output.putInt32(this._outBlock[i]);\n    }\n};\nmodes.ecb.prototype.decrypt = function(input, output, finish) {\n    // not enough input to decrypt\n    if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n        return true;\n    }\n    // get next block\n    for(var i = 0; i < this._ints; ++i){\n        this._inBlock[i] = input.getInt32();\n    }\n    // decrypt block\n    this.cipher.decrypt(this._inBlock, this._outBlock);\n    // write output\n    for(var i = 0; i < this._ints; ++i){\n        output.putInt32(this._outBlock[i]);\n    }\n};\nmodes.ecb.prototype.pad = function(input, options) {\n    // add PKCS#7 padding to block (each pad byte is the\n    // value of the number of pad bytes)\n    var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();\n    input.fillWithByte(padding, padding);\n    return true;\n};\nmodes.ecb.prototype.unpad = function(output, options) {\n    // check for error: input data not a multiple of blockSize\n    if (options.overflow > 0) {\n        return false;\n    }\n    // ensure padding byte count is valid\n    var len = output.length();\n    var count = output.at(len - 1);\n    if (count > this.blockSize << 2) {\n        return false;\n    }\n    // trim off padding bytes\n    output.truncate(count);\n    return true;\n};\n/** Cipher-block Chaining (CBC) **/ modes.cbc = function(options) {\n    options = options || {};\n    this.name = \"CBC\";\n    this.cipher = options.cipher;\n    this.blockSize = options.blockSize || 16;\n    this._ints = this.blockSize / 4;\n    this._inBlock = new Array(this._ints);\n    this._outBlock = new Array(this._ints);\n};\nmodes.cbc.prototype.start = function(options) {\n    // Note: legacy support for using IV residue (has security flaws)\n    // if IV is null, reuse block from previous processing\n    if (options.iv === null) {\n        // must have a previous block\n        if (!this._prev) {\n            throw new Error(\"Invalid IV parameter.\");\n        }\n        this._iv = this._prev.slice(0);\n    } else if (!(\"iv\" in options)) {\n        throw new Error(\"Invalid IV parameter.\");\n    } else {\n        // save IV as \"previous\" block\n        this._iv = transformIV(options.iv, this.blockSize);\n        this._prev = this._iv.slice(0);\n    }\n};\nmodes.cbc.prototype.encrypt = function(input, output, finish) {\n    // not enough input to encrypt\n    if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n        return true;\n    }\n    // get next block\n    // CBC XOR's IV (or previous block) with plaintext\n    for(var i = 0; i < this._ints; ++i){\n        this._inBlock[i] = this._prev[i] ^ input.getInt32();\n    }\n    // encrypt block\n    this.cipher.encrypt(this._inBlock, this._outBlock);\n    // write output, save previous block\n    for(var i = 0; i < this._ints; ++i){\n        output.putInt32(this._outBlock[i]);\n    }\n    this._prev = this._outBlock;\n};\nmodes.cbc.prototype.decrypt = function(input, output, finish) {\n    // not enough input to decrypt\n    if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n        return true;\n    }\n    // get next block\n    for(var i = 0; i < this._ints; ++i){\n        this._inBlock[i] = input.getInt32();\n    }\n    // decrypt block\n    this.cipher.decrypt(this._inBlock, this._outBlock);\n    // write output, save previous ciphered block\n    // CBC XOR's IV (or previous block) with ciphertext\n    for(var i = 0; i < this._ints; ++i){\n        output.putInt32(this._prev[i] ^ this._outBlock[i]);\n    }\n    this._prev = this._inBlock.slice(0);\n};\nmodes.cbc.prototype.pad = function(input, options) {\n    // add PKCS#7 padding to block (each pad byte is the\n    // value of the number of pad bytes)\n    var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();\n    input.fillWithByte(padding, padding);\n    return true;\n};\nmodes.cbc.prototype.unpad = function(output, options) {\n    // check for error: input data not a multiple of blockSize\n    if (options.overflow > 0) {\n        return false;\n    }\n    // ensure padding byte count is valid\n    var len = output.length();\n    var count = output.at(len - 1);\n    if (count > this.blockSize << 2) {\n        return false;\n    }\n    // trim off padding bytes\n    output.truncate(count);\n    return true;\n};\n/** Cipher feedback (CFB) **/ modes.cfb = function(options) {\n    options = options || {};\n    this.name = \"CFB\";\n    this.cipher = options.cipher;\n    this.blockSize = options.blockSize || 16;\n    this._ints = this.blockSize / 4;\n    this._inBlock = null;\n    this._outBlock = new Array(this._ints);\n    this._partialBlock = new Array(this._ints);\n    this._partialOutput = forge.util.createBuffer();\n    this._partialBytes = 0;\n};\nmodes.cfb.prototype.start = function(options) {\n    if (!(\"iv\" in options)) {\n        throw new Error(\"Invalid IV parameter.\");\n    }\n    // use IV as first input\n    this._iv = transformIV(options.iv, this.blockSize);\n    this._inBlock = this._iv.slice(0);\n    this._partialBytes = 0;\n};\nmodes.cfb.prototype.encrypt = function(input, output, finish) {\n    // not enough input to encrypt\n    var inputLength = input.length();\n    if (inputLength === 0) {\n        return true;\n    }\n    // encrypt block\n    this.cipher.encrypt(this._inBlock, this._outBlock);\n    // handle full block\n    if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n        // XOR input with output, write input as output\n        for(var i = 0; i < this._ints; ++i){\n            this._inBlock[i] = input.getInt32() ^ this._outBlock[i];\n            output.putInt32(this._inBlock[i]);\n        }\n        return;\n    }\n    // handle partial block\n    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n    if (partialBytes > 0) {\n        partialBytes = this.blockSize - partialBytes;\n    }\n    // XOR input with output, write input as partial output\n    this._partialOutput.clear();\n    for(var i = 0; i < this._ints; ++i){\n        this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];\n        this._partialOutput.putInt32(this._partialBlock[i]);\n    }\n    if (partialBytes > 0) {\n        // block still incomplete, restore input buffer\n        input.read -= this.blockSize;\n    } else {\n        // block complete, update input block\n        for(var i = 0; i < this._ints; ++i){\n            this._inBlock[i] = this._partialBlock[i];\n        }\n    }\n    // skip any previous partial bytes\n    if (this._partialBytes > 0) {\n        this._partialOutput.getBytes(this._partialBytes);\n    }\n    if (partialBytes > 0 && !finish) {\n        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n        this._partialBytes = partialBytes;\n        return true;\n    }\n    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n    this._partialBytes = 0;\n};\nmodes.cfb.prototype.decrypt = function(input, output, finish) {\n    // not enough input to decrypt\n    var inputLength = input.length();\n    if (inputLength === 0) {\n        return true;\n    }\n    // encrypt block (CFB always uses encryption mode)\n    this.cipher.encrypt(this._inBlock, this._outBlock);\n    // handle full block\n    if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n        // XOR input with output, write input as output\n        for(var i = 0; i < this._ints; ++i){\n            this._inBlock[i] = input.getInt32();\n            output.putInt32(this._inBlock[i] ^ this._outBlock[i]);\n        }\n        return;\n    }\n    // handle partial block\n    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n    if (partialBytes > 0) {\n        partialBytes = this.blockSize - partialBytes;\n    }\n    // XOR input with output, write input as partial output\n    this._partialOutput.clear();\n    for(var i = 0; i < this._ints; ++i){\n        this._partialBlock[i] = input.getInt32();\n        this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);\n    }\n    if (partialBytes > 0) {\n        // block still incomplete, restore input buffer\n        input.read -= this.blockSize;\n    } else {\n        // block complete, update input block\n        for(var i = 0; i < this._ints; ++i){\n            this._inBlock[i] = this._partialBlock[i];\n        }\n    }\n    // skip any previous partial bytes\n    if (this._partialBytes > 0) {\n        this._partialOutput.getBytes(this._partialBytes);\n    }\n    if (partialBytes > 0 && !finish) {\n        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n        this._partialBytes = partialBytes;\n        return true;\n    }\n    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n    this._partialBytes = 0;\n};\n/** Output feedback (OFB) **/ modes.ofb = function(options) {\n    options = options || {};\n    this.name = \"OFB\";\n    this.cipher = options.cipher;\n    this.blockSize = options.blockSize || 16;\n    this._ints = this.blockSize / 4;\n    this._inBlock = null;\n    this._outBlock = new Array(this._ints);\n    this._partialOutput = forge.util.createBuffer();\n    this._partialBytes = 0;\n};\nmodes.ofb.prototype.start = function(options) {\n    if (!(\"iv\" in options)) {\n        throw new Error(\"Invalid IV parameter.\");\n    }\n    // use IV as first input\n    this._iv = transformIV(options.iv, this.blockSize);\n    this._inBlock = this._iv.slice(0);\n    this._partialBytes = 0;\n};\nmodes.ofb.prototype.encrypt = function(input, output, finish) {\n    // not enough input to encrypt\n    var inputLength = input.length();\n    if (input.length() === 0) {\n        return true;\n    }\n    // encrypt block (OFB always uses encryption mode)\n    this.cipher.encrypt(this._inBlock, this._outBlock);\n    // handle full block\n    if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n        // XOR input with output and update next input\n        for(var i = 0; i < this._ints; ++i){\n            output.putInt32(input.getInt32() ^ this._outBlock[i]);\n            this._inBlock[i] = this._outBlock[i];\n        }\n        return;\n    }\n    // handle partial block\n    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n    if (partialBytes > 0) {\n        partialBytes = this.blockSize - partialBytes;\n    }\n    // XOR input with output\n    this._partialOutput.clear();\n    for(var i = 0; i < this._ints; ++i){\n        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n    if (partialBytes > 0) {\n        // block still incomplete, restore input buffer\n        input.read -= this.blockSize;\n    } else {\n        // block complete, update input block\n        for(var i = 0; i < this._ints; ++i){\n            this._inBlock[i] = this._outBlock[i];\n        }\n    }\n    // skip any previous partial bytes\n    if (this._partialBytes > 0) {\n        this._partialOutput.getBytes(this._partialBytes);\n    }\n    if (partialBytes > 0 && !finish) {\n        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n        this._partialBytes = partialBytes;\n        return true;\n    }\n    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n    this._partialBytes = 0;\n};\nmodes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;\n/** Counter (CTR) **/ modes.ctr = function(options) {\n    options = options || {};\n    this.name = \"CTR\";\n    this.cipher = options.cipher;\n    this.blockSize = options.blockSize || 16;\n    this._ints = this.blockSize / 4;\n    this._inBlock = null;\n    this._outBlock = new Array(this._ints);\n    this._partialOutput = forge.util.createBuffer();\n    this._partialBytes = 0;\n};\nmodes.ctr.prototype.start = function(options) {\n    if (!(\"iv\" in options)) {\n        throw new Error(\"Invalid IV parameter.\");\n    }\n    // use IV as first input\n    this._iv = transformIV(options.iv, this.blockSize);\n    this._inBlock = this._iv.slice(0);\n    this._partialBytes = 0;\n};\nmodes.ctr.prototype.encrypt = function(input, output, finish) {\n    // not enough input to encrypt\n    var inputLength = input.length();\n    if (inputLength === 0) {\n        return true;\n    }\n    // encrypt block (CTR always uses encryption mode)\n    this.cipher.encrypt(this._inBlock, this._outBlock);\n    // handle full block\n    if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n        // XOR input with output\n        for(var i = 0; i < this._ints; ++i){\n            output.putInt32(input.getInt32() ^ this._outBlock[i]);\n        }\n    } else {\n        // handle partial block\n        var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n        if (partialBytes > 0) {\n            partialBytes = this.blockSize - partialBytes;\n        }\n        // XOR input with output\n        this._partialOutput.clear();\n        for(var i = 0; i < this._ints; ++i){\n            this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n        }\n        if (partialBytes > 0) {\n            // block still incomplete, restore input buffer\n            input.read -= this.blockSize;\n        }\n        // skip any previous partial bytes\n        if (this._partialBytes > 0) {\n            this._partialOutput.getBytes(this._partialBytes);\n        }\n        if (partialBytes > 0 && !finish) {\n            output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n            this._partialBytes = partialBytes;\n            return true;\n        }\n        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n        this._partialBytes = 0;\n    }\n    // block complete, increment counter (input block)\n    inc32(this._inBlock);\n};\nmodes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;\n/** Galois/Counter Mode (GCM) **/ modes.gcm = function(options) {\n    options = options || {};\n    this.name = \"GCM\";\n    this.cipher = options.cipher;\n    this.blockSize = options.blockSize || 16;\n    this._ints = this.blockSize / 4;\n    this._inBlock = new Array(this._ints);\n    this._outBlock = new Array(this._ints);\n    this._partialOutput = forge.util.createBuffer();\n    this._partialBytes = 0;\n    // R is actually this value concatenated with 120 more zero bits, but\n    // we only XOR against R so the other zeros have no effect -- we just\n    // apply this value to the first integer in a block\n    this._R = 0xE1000000;\n};\nmodes.gcm.prototype.start = function(options) {\n    if (!(\"iv\" in options)) {\n        throw new Error(\"Invalid IV parameter.\");\n    }\n    // ensure IV is a byte buffer\n    var iv = forge.util.createBuffer(options.iv);\n    // no ciphered data processed yet\n    this._cipherLength = 0;\n    // default additional data is none\n    var additionalData;\n    if (\"additionalData\" in options) {\n        additionalData = forge.util.createBuffer(options.additionalData);\n    } else {\n        additionalData = forge.util.createBuffer();\n    }\n    // default tag length is 128 bits\n    if (\"tagLength\" in options) {\n        this._tagLength = options.tagLength;\n    } else {\n        this._tagLength = 128;\n    }\n    // if tag is given, ensure tag matches tag length\n    this._tag = null;\n    if (options.decrypt) {\n        // save tag to check later\n        this._tag = forge.util.createBuffer(options.tag).getBytes();\n        if (this._tag.length !== this._tagLength / 8) {\n            throw new Error(\"Authentication tag does not match tag length.\");\n        }\n    }\n    // create tmp storage for hash calculation\n    this._hashBlock = new Array(this._ints);\n    // no tag generated yet\n    this.tag = null;\n    // generate hash subkey\n    // (apply block cipher to \"zero\" block)\n    this._hashSubkey = new Array(this._ints);\n    this.cipher.encrypt([\n        0,\n        0,\n        0,\n        0\n    ], this._hashSubkey);\n    // generate table M\n    // use 4-bit tables (32 component decomposition of a 16 byte value)\n    // 8-bit tables take more space and are known to have security\n    // vulnerabilities (in native implementations)\n    this.componentBits = 4;\n    this._m = this.generateHashTable(this._hashSubkey, this.componentBits);\n    // Note: support IV length different from 96 bits? (only supporting\n    // 96 bits is recommended by NIST SP-800-38D)\n    // generate J_0\n    var ivLength = iv.length();\n    if (ivLength === 12) {\n        // 96-bit IV\n        this._j0 = [\n            iv.getInt32(),\n            iv.getInt32(),\n            iv.getInt32(),\n            1\n        ];\n    } else {\n        // IV is NOT 96-bits\n        this._j0 = [\n            0,\n            0,\n            0,\n            0\n        ];\n        while(iv.length() > 0){\n            this._j0 = this.ghash(this._hashSubkey, this._j0, [\n                iv.getInt32(),\n                iv.getInt32(),\n                iv.getInt32(),\n                iv.getInt32()\n            ]);\n        }\n        this._j0 = this.ghash(this._hashSubkey, this._j0, [\n            0,\n            0\n        ].concat(from64To32(ivLength * 8)));\n    }\n    // generate ICB (initial counter block)\n    this._inBlock = this._j0.slice(0);\n    inc32(this._inBlock);\n    this._partialBytes = 0;\n    // consume authentication data\n    additionalData = forge.util.createBuffer(additionalData);\n    // save additional data length as a BE 64-bit number\n    this._aDataLength = from64To32(additionalData.length() * 8);\n    // pad additional data to 128 bit (16 byte) block size\n    var overflow = additionalData.length() % this.blockSize;\n    if (overflow) {\n        additionalData.fillWithByte(0, this.blockSize - overflow);\n    }\n    this._s = [\n        0,\n        0,\n        0,\n        0\n    ];\n    while(additionalData.length() > 0){\n        this._s = this.ghash(this._hashSubkey, this._s, [\n            additionalData.getInt32(),\n            additionalData.getInt32(),\n            additionalData.getInt32(),\n            additionalData.getInt32()\n        ]);\n    }\n};\nmodes.gcm.prototype.encrypt = function(input, output, finish) {\n    // not enough input to encrypt\n    var inputLength = input.length();\n    if (inputLength === 0) {\n        return true;\n    }\n    // encrypt block\n    this.cipher.encrypt(this._inBlock, this._outBlock);\n    // handle full block\n    if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n        // XOR input with output\n        for(var i = 0; i < this._ints; ++i){\n            output.putInt32(this._outBlock[i] ^= input.getInt32());\n        }\n        this._cipherLength += this.blockSize;\n    } else {\n        // handle partial block\n        var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n        if (partialBytes > 0) {\n            partialBytes = this.blockSize - partialBytes;\n        }\n        // XOR input with output\n        this._partialOutput.clear();\n        for(var i = 0; i < this._ints; ++i){\n            this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n        }\n        if (partialBytes <= 0 || finish) {\n            // handle overflow prior to hashing\n            if (finish) {\n                // get block overflow\n                var overflow = inputLength % this.blockSize;\n                this._cipherLength += overflow;\n                // truncate for hash function\n                this._partialOutput.truncate(this.blockSize - overflow);\n            } else {\n                this._cipherLength += this.blockSize;\n            }\n            // get output block for hashing\n            for(var i = 0; i < this._ints; ++i){\n                this._outBlock[i] = this._partialOutput.getInt32();\n            }\n            this._partialOutput.read -= this.blockSize;\n        }\n        // skip any previous partial bytes\n        if (this._partialBytes > 0) {\n            this._partialOutput.getBytes(this._partialBytes);\n        }\n        if (partialBytes > 0 && !finish) {\n            // block still incomplete, restore input buffer, get partial output,\n            // and return early\n            input.read -= this.blockSize;\n            output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n            this._partialBytes = partialBytes;\n            return true;\n        }\n        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n        this._partialBytes = 0;\n    }\n    // update hash block S\n    this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);\n    // increment counter (input block)\n    inc32(this._inBlock);\n};\nmodes.gcm.prototype.decrypt = function(input, output, finish) {\n    // not enough input to decrypt\n    var inputLength = input.length();\n    if (inputLength < this.blockSize && !(finish && inputLength > 0)) {\n        return true;\n    }\n    // encrypt block (GCM always uses encryption mode)\n    this.cipher.encrypt(this._inBlock, this._outBlock);\n    // increment counter (input block)\n    inc32(this._inBlock);\n    // update hash block S\n    this._hashBlock[0] = input.getInt32();\n    this._hashBlock[1] = input.getInt32();\n    this._hashBlock[2] = input.getInt32();\n    this._hashBlock[3] = input.getInt32();\n    this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);\n    // XOR hash input with output\n    for(var i = 0; i < this._ints; ++i){\n        output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);\n    }\n    // increment cipher data length\n    if (inputLength < this.blockSize) {\n        this._cipherLength += inputLength % this.blockSize;\n    } else {\n        this._cipherLength += this.blockSize;\n    }\n};\nmodes.gcm.prototype.afterFinish = function(output, options) {\n    var rval = true;\n    // handle overflow\n    if (options.decrypt && options.overflow) {\n        output.truncate(this.blockSize - options.overflow);\n    }\n    // handle authentication tag\n    this.tag = forge.util.createBuffer();\n    // concatenate additional data length with cipher length\n    var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));\n    // include lengths in hash\n    this._s = this.ghash(this._hashSubkey, this._s, lengths);\n    // do GCTR(J_0, S)\n    var tag = [];\n    this.cipher.encrypt(this._j0, tag);\n    for(var i = 0; i < this._ints; ++i){\n        this.tag.putInt32(this._s[i] ^ tag[i]);\n    }\n    // trim tag to length\n    this.tag.truncate(this.tag.length() % (this._tagLength / 8));\n    // check authentication tag\n    if (options.decrypt && this.tag.bytes() !== this._tag) {\n        rval = false;\n    }\n    return rval;\n};\n/**\n * See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois\n * field multiplication. The field, GF(2^128), is defined by the polynomial:\n *\n * x^128 + x^7 + x^2 + x + 1\n *\n * Which is represented in little-endian binary form as: 11100001 (0xe1). When\n * the value of a coefficient is 1, a bit is set. The value R, is the\n * concatenation of this value and 120 zero bits, yielding a 128-bit value\n * which matches the block size.\n *\n * This function will multiply two elements (vectors of bytes), X and Y, in\n * the field GF(2^128). The result is initialized to zero. For each bit of\n * X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)\n * by the current value of Y. For each bit, the value of Y will be raised by\n * a power of x (multiplied by the polynomial x). This can be achieved by\n * shifting Y once to the right. If the current value of Y, prior to being\n * multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.\n * Otherwise, we must divide by R after shifting to find the remainder.\n *\n * @param x the first block to multiply by the second.\n * @param y the second block to multiply by the first.\n *\n * @return the block result of the multiplication.\n */ modes.gcm.prototype.multiply = function(x, y) {\n    var z_i = [\n        0,\n        0,\n        0,\n        0\n    ];\n    var v_i = y.slice(0);\n    // calculate Z_128 (block has 128 bits)\n    for(var i = 0; i < 128; ++i){\n        // if x_i is 0, Z_{i+1} = Z_i (unchanged)\n        // else Z_{i+1} = Z_i ^ V_i\n        // get x_i by finding 32-bit int position, then left shift 1 by remainder\n        var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;\n        if (x_i) {\n            z_i[0] ^= v_i[0];\n            z_i[1] ^= v_i[1];\n            z_i[2] ^= v_i[2];\n            z_i[3] ^= v_i[3];\n        }\n        // if LSB(V_i) is 1, V_i = V_i >> 1\n        // else V_i = (V_i >> 1) ^ R\n        this.pow(v_i, v_i);\n    }\n    return z_i;\n};\nmodes.gcm.prototype.pow = function(x, out) {\n    // if LSB(x) is 1, x = x >>> 1\n    // else x = (x >>> 1) ^ R\n    var lsb = x[3] & 1;\n    // always do x >>> 1:\n    // starting with the rightmost integer, shift each integer to the right\n    // one bit, pulling in the bit from the integer to the left as its top\n    // most bit (do this for the last 3 integers)\n    for(var i = 3; i > 0; --i){\n        out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;\n    }\n    // shift the first integer normally\n    out[0] = x[0] >>> 1;\n    // if lsb was not set, then polynomial had a degree of 127 and doesn't\n    // need to divided; otherwise, XOR with R to find the remainder; we only\n    // need to XOR the first integer since R technically ends w/120 zero bits\n    if (lsb) {\n        out[0] ^= this._R;\n    }\n};\nmodes.gcm.prototype.tableMultiply = function(x) {\n    // assumes 4-bit tables are used\n    var z = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for(var i = 0; i < 32; ++i){\n        var idx = i / 8 | 0;\n        var x_i = x[idx] >>> (7 - i % 8) * 4 & 0xF;\n        var ah = this._m[i][x_i];\n        z[0] ^= ah[0];\n        z[1] ^= ah[1];\n        z[2] ^= ah[2];\n        z[3] ^= ah[3];\n    }\n    return z;\n};\n/**\n * A continuing version of the GHASH algorithm that operates on a single\n * block. The hash block, last hash value (Ym) and the new block to hash\n * are given.\n *\n * @param h the hash block.\n * @param y the previous value for Ym, use [0, 0, 0, 0] for a new hash.\n * @param x the block to hash.\n *\n * @return the hashed value (Ym).\n */ modes.gcm.prototype.ghash = function(h, y, x) {\n    y[0] ^= x[0];\n    y[1] ^= x[1];\n    y[2] ^= x[2];\n    y[3] ^= x[3];\n    return this.tableMultiply(y);\n//return this.multiply(y, h);\n};\n/**\n * Precomputes a table for multiplying against the hash subkey. This\n * mechanism provides a substantial speed increase over multiplication\n * performed without a table. The table-based multiplication this table is\n * for solves X * H by multiplying each component of X by H and then\n * composing the results together using XOR.\n *\n * This function can be used to generate tables with different bit sizes\n * for the components, however, this implementation assumes there are\n * 32 components of X (which is a 16 byte vector), therefore each component\n * takes 4-bits (so the table is constructed with bits=4).\n *\n * @param h the hash subkey.\n * @param bits the bit size for a component.\n */ modes.gcm.prototype.generateHashTable = function(h, bits) {\n    // TODO: There are further optimizations that would use only the\n    // first table M_0 (or some variant) along with a remainder table;\n    // this can be explored in the future\n    var multiplier = 8 / bits;\n    var perInt = 4 * multiplier;\n    var size = 16 * multiplier;\n    var m = new Array(size);\n    for(var i = 0; i < size; ++i){\n        var tmp = [\n            0,\n            0,\n            0,\n            0\n        ];\n        var idx = i / perInt | 0;\n        var shft = (perInt - 1 - i % perInt) * bits;\n        tmp[idx] = 1 << bits - 1 << shft;\n        m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);\n    }\n    return m;\n};\n/**\n * Generates a table for multiplying against the hash subkey for one\n * particular component (out of all possible component values).\n *\n * @param mid the pre-multiplied value for the middle key of the table.\n * @param bits the bit size for a component.\n */ modes.gcm.prototype.generateSubHashTable = function(mid, bits) {\n    // compute the table quickly by minimizing the number of\n    // POW operations -- they only need to be performed for powers of 2,\n    // all other entries can be composed from those powers using XOR\n    var size = 1 << bits;\n    var half = size >>> 1;\n    var m = new Array(size);\n    m[half] = mid.slice(0);\n    var i = half >>> 1;\n    while(i > 0){\n        // raise m0[2 * i] and store in m0[i]\n        this.pow(m[2 * i], m[i] = []);\n        i >>= 1;\n    }\n    i = 2;\n    while(i < half){\n        for(var j = 1; j < i; ++j){\n            var m_i = m[i];\n            var m_j = m[j];\n            m[i + j] = [\n                m_i[0] ^ m_j[0],\n                m_i[1] ^ m_j[1],\n                m_i[2] ^ m_j[2],\n                m_i[3] ^ m_j[3]\n            ];\n        }\n        i *= 2;\n    }\n    m[0] = [\n        0,\n        0,\n        0,\n        0\n    ];\n    /* Note: We could avoid storing these by doing composition during multiply\n  calculate top half using composition by speed is preferred. */ for(i = half + 1; i < size; ++i){\n        var c = m[i ^ half];\n        m[i] = [\n            mid[0] ^ c[0],\n            mid[1] ^ c[1],\n            mid[2] ^ c[2],\n            mid[3] ^ c[3]\n        ];\n    }\n    return m;\n};\n/** Utility functions */ function transformIV(iv, blockSize) {\n    if (typeof iv === \"string\") {\n        // convert iv string into byte buffer\n        iv = forge.util.createBuffer(iv);\n    }\n    if (forge.util.isArray(iv) && iv.length > 4) {\n        // convert iv byte array into byte buffer\n        var tmp = iv;\n        iv = forge.util.createBuffer();\n        for(var i = 0; i < tmp.length; ++i){\n            iv.putByte(tmp[i]);\n        }\n    }\n    if (iv.length() < blockSize) {\n        throw new Error(\"Invalid IV length; got \" + iv.length() + \" bytes and expected \" + blockSize + \" bytes.\");\n    }\n    if (!forge.util.isArray(iv)) {\n        // convert iv byte buffer into 32-bit integer array\n        var ints = [];\n        var blocks = blockSize / 4;\n        for(var i = 0; i < blocks; ++i){\n            ints.push(iv.getInt32());\n        }\n        iv = ints;\n    }\n    return iv;\n}\nfunction inc32(block) {\n    // increment last 32 bits of block only\n    block[block.length - 1] = block[block.length - 1] + 1 & 0xFFFFFFFF;\n}\nfunction from64To32(num) {\n    // convert 64-bit number to two BE Int32s\n    return [\n        num / 0x100000000 | 0,\n        num & 0xFFFFFFFF\n    ];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvY2lwaGVyTW9kZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBRVJELE1BQU1FLE1BQU0sR0FBR0YsTUFBTUUsTUFBTSxJQUFJLENBQUM7QUFFaEMseUJBQXlCO0FBQ3pCLElBQUlDLFFBQVFDLE9BQU9DLE9BQU8sR0FBR0wsTUFBTUUsTUFBTSxDQUFDQyxLQUFLLEdBQUdILE1BQU1FLE1BQU0sQ0FBQ0MsS0FBSyxJQUFJLENBQUM7QUFFekUsaUVBQWlFLEdBRWpFQSxNQUFNRyxHQUFHLEdBQUcsU0FBU0MsT0FBTztJQUMxQkEsVUFBVUEsV0FBVyxDQUFDO0lBQ3RCLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ1osSUFBSSxDQUFDTixNQUFNLEdBQUdLLFFBQVFMLE1BQU07SUFDNUIsSUFBSSxDQUFDTyxTQUFTLEdBQUdGLFFBQVFFLFNBQVMsSUFBSTtJQUN0QyxJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJLENBQUNELFNBQVMsR0FBRztJQUM5QixJQUFJLENBQUNFLFFBQVEsR0FBRyxJQUFJQyxNQUFNLElBQUksQ0FBQ0YsS0FBSztJQUNwQyxJQUFJLENBQUNHLFNBQVMsR0FBRyxJQUFJRCxNQUFNLElBQUksQ0FBQ0YsS0FBSztBQUN2QztBQUVBUCxNQUFNRyxHQUFHLENBQUNRLFNBQVMsQ0FBQ0MsS0FBSyxHQUFHLFNBQVNSLE9BQU8sR0FBRztBQUUvQ0osTUFBTUcsR0FBRyxDQUFDUSxTQUFTLENBQUNFLE9BQU8sR0FBRyxTQUFTQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsTUFBTTtJQUMxRCw4QkFBOEI7SUFDOUIsSUFBR0YsTUFBTUcsTUFBTSxLQUFLLElBQUksQ0FBQ1gsU0FBUyxJQUFJLENBQUVVLENBQUFBLFVBQVVGLE1BQU1HLE1BQU0sS0FBSyxJQUFJO1FBQ3JFLE9BQU87SUFDVDtJQUVB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QUVBLElBQUduQyxNQUFNNEMsSUFBSSxDQUFDZ0UsT0FBTyxDQUFDekUsT0FBT0EsR0FBR2YsTUFBTSxHQUFHLEdBQUc7UUFDMUMseUNBQXlDO1FBQ3pDLElBQUkrRSxNQUFNaEU7UUFDVkEsS0FBS25DLE1BQU00QyxJQUFJLENBQUNDLFlBQVk7UUFDNUIsSUFBSSxJQUFJeEIsSUFBSSxHQUFHQSxJQUFJOEUsSUFBSS9FLE1BQU0sRUFBRSxFQUFFQyxFQUFHO1lBQ2xDYyxHQUFHMEUsT0FBTyxDQUFDVixHQUFHLENBQUM5RSxFQUFFO1FBQ25CO0lBQ0Y7SUFFQSxJQUFHYyxHQUFHZixNQUFNLEtBQUtYLFdBQVc7UUFDMUIsTUFBTSxJQUFJNEIsTUFDUiw0QkFBNEJGLEdBQUdmLE1BQU0sS0FDckMseUJBQXlCWCxZQUFZO0lBQ3pDO0lBRUEsSUFBRyxDQUFDVCxNQUFNNEMsSUFBSSxDQUFDZ0UsT0FBTyxDQUFDekUsS0FBSztRQUMxQixtREFBbUQ7UUFDbkQsSUFBSTJFLE9BQU8sRUFBRTtRQUNiLElBQUlDLFNBQVN0RyxZQUFZO1FBQ3pCLElBQUksSUFBSVksSUFBSSxHQUFHQSxJQUFJMEYsUUFBUSxFQUFFMUYsRUFBRztZQUM5QnlGLEtBQUtFLElBQUksQ0FBQzdFLEdBQUdiLFFBQVE7UUFDdkI7UUFDQWEsS0FBSzJFO0lBQ1A7SUFFQSxPQUFPM0U7QUFDVDtBQUVBLFNBQVNvQixNQUFNMEQsS0FBSztJQUNsQix1Q0FBdUM7SUFDdkNBLEtBQUssQ0FBQ0EsTUFBTTdGLE1BQU0sR0FBRyxFQUFFLEdBQUcsS0FBTSxDQUFDNkYsTUFBTTdGLE1BQU0sR0FBRyxFQUFFLEdBQUcsSUFBSztBQUM1RDtBQUVBLFNBQVNxRCxXQUFXeUMsR0FBRztJQUNyQix5Q0FBeUM7SUFDekMsT0FBTztRQUFFQSxNQUFNLGNBQWU7UUFBR0EsTUFBTTtLQUFXO0FBQ3BEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2NpcGhlck1vZGVzLmpzPzA5MDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTdXBwb3J0ZWQgY2lwaGVyIG1vZGVzLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbmZvcmdlLmNpcGhlciA9IGZvcmdlLmNpcGhlciB8fCB7fTtcblxuLy8gc3VwcG9ydGVkIGNpcGhlciBtb2Rlc1xudmFyIG1vZGVzID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5jaXBoZXIubW9kZXMgPSBmb3JnZS5jaXBoZXIubW9kZXMgfHwge307XG5cbi8qKiBFbGVjdHJvbmljIGNvZGVib29rIChFQ0IpIChEb24ndCB1c2UgdGhpczsgaXQncyBub3Qgc2VjdXJlKSAqKi9cblxubW9kZXMuZWNiID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5uYW1lID0gJ0VDQic7XG4gIHRoaXMuY2lwaGVyID0gb3B0aW9ucy5jaXBoZXI7XG4gIHRoaXMuYmxvY2tTaXplID0gb3B0aW9ucy5ibG9ja1NpemUgfHwgMTY7XG4gIHRoaXMuX2ludHMgPSB0aGlzLmJsb2NrU2l6ZSAvIDQ7XG4gIHRoaXMuX2luQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX291dEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xufTtcblxubW9kZXMuZWNiLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHt9O1xuXG5tb2Rlcy5lY2IucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBlbmNyeXB0XG4gIGlmKGlucHV0Lmxlbmd0aCgpIDwgdGhpcy5ibG9ja1NpemUgJiYgIShmaW5pc2ggJiYgaW5wdXQubGVuZ3RoKCkgPiAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZ2V0IG5leHQgYmxvY2tcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIHRoaXMuX2luQmxvY2tbaV0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB9XG5cbiAgLy8gZW5jcnlwdCBibG9ja1xuICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyB3cml0ZSBvdXRwdXRcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9vdXRCbG9ja1tpXSk7XG4gIH1cbn07XG5cbm1vZGVzLmVjYi5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGRlY3J5cHRcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPCB0aGlzLmJsb2NrU2l6ZSAmJiAhKGZpbmlzaCAmJiBpbnB1dC5sZW5ndGgoKSA+IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBnZXQgbmV4dCBibG9ja1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gIH1cblxuICAvLyBkZWNyeXB0IGJsb2NrXG4gIHRoaXMuY2lwaGVyLmRlY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIHdyaXRlIG91dHB1dFxuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX291dEJsb2NrW2ldKTtcbiAgfVxufTtcblxubW9kZXMuZWNiLnByb3RvdHlwZS5wYWQgPSBmdW5jdGlvbihpbnB1dCwgb3B0aW9ucykge1xuICAvLyBhZGQgUEtDUyM3IHBhZGRpbmcgdG8gYmxvY2sgKGVhY2ggcGFkIGJ5dGUgaXMgdGhlXG4gIC8vIHZhbHVlIG9mIHRoZSBudW1iZXIgb2YgcGFkIGJ5dGVzKVxuICB2YXIgcGFkZGluZyA9IChpbnB1dC5sZW5ndGgoKSA9PT0gdGhpcy5ibG9ja1NpemUgP1xuICAgIHRoaXMuYmxvY2tTaXplIDogKHRoaXMuYmxvY2tTaXplIC0gaW5wdXQubGVuZ3RoKCkpKTtcbiAgaW5wdXQuZmlsbFdpdGhCeXRlKHBhZGRpbmcsIHBhZGRpbmcpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZGVzLmVjYi5wcm90b3R5cGUudW5wYWQgPSBmdW5jdGlvbihvdXRwdXQsIG9wdGlvbnMpIHtcbiAgLy8gY2hlY2sgZm9yIGVycm9yOiBpbnB1dCBkYXRhIG5vdCBhIG11bHRpcGxlIG9mIGJsb2NrU2l6ZVxuICBpZihvcHRpb25zLm92ZXJmbG93ID4gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBwYWRkaW5nIGJ5dGUgY291bnQgaXMgdmFsaWRcbiAgdmFyIGxlbiA9IG91dHB1dC5sZW5ndGgoKTtcbiAgdmFyIGNvdW50ID0gb3V0cHV0LmF0KGxlbiAtIDEpO1xuICBpZihjb3VudCA+ICh0aGlzLmJsb2NrU2l6ZSA8PCAyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIHRyaW0gb2ZmIHBhZGRpbmcgYnl0ZXNcbiAgb3V0cHV0LnRydW5jYXRlKGNvdW50KTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKiogQ2lwaGVyLWJsb2NrIENoYWluaW5nIChDQkMpICoqL1xuXG5tb2Rlcy5jYmMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm5hbWUgPSAnQ0JDJztcbiAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgdGhpcy5faW50cyA9IHRoaXMuYmxvY2tTaXplIC8gNDtcbiAgdGhpcy5faW5CbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG59O1xuXG5tb2Rlcy5jYmMucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAvLyBOb3RlOiBsZWdhY3kgc3VwcG9ydCBmb3IgdXNpbmcgSVYgcmVzaWR1ZSAoaGFzIHNlY3VyaXR5IGZsYXdzKVxuICAvLyBpZiBJViBpcyBudWxsLCByZXVzZSBibG9jayBmcm9tIHByZXZpb3VzIHByb2Nlc3NpbmdcbiAgaWYob3B0aW9ucy5pdiA9PT0gbnVsbCkge1xuICAgIC8vIG11c3QgaGF2ZSBhIHByZXZpb3VzIGJsb2NrXG4gICAgaWYoIXRoaXMuX3ByZXYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJViBwYXJhbWV0ZXIuJyk7XG4gICAgfVxuICAgIHRoaXMuX2l2ID0gdGhpcy5fcHJldi5zbGljZSgwKTtcbiAgfSBlbHNlIGlmKCEoJ2l2JyBpbiBvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJViBwYXJhbWV0ZXIuJyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gc2F2ZSBJViBhcyBcInByZXZpb3VzXCIgYmxvY2tcbiAgICB0aGlzLl9pdiA9IHRyYW5zZm9ybUlWKG9wdGlvbnMuaXYsIHRoaXMuYmxvY2tTaXplKTtcbiAgICB0aGlzLl9wcmV2ID0gdGhpcy5faXYuc2xpY2UoMCk7XG4gIH1cbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGVuY3J5cHRcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPCB0aGlzLmJsb2NrU2l6ZSAmJiAhKGZpbmlzaCAmJiBpbnB1dC5sZW5ndGgoKSA+IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBnZXQgbmV4dCBibG9ja1xuICAvLyBDQkMgWE9SJ3MgSVYgKG9yIHByZXZpb3VzIGJsb2NrKSB3aXRoIHBsYWludGV4dFxuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5faW5CbG9ja1tpXSA9IHRoaXMuX3ByZXZbaV0gXiBpbnB1dC5nZXRJbnQzMigpO1xuICB9XG5cbiAgLy8gZW5jcnlwdCBibG9ja1xuICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyB3cml0ZSBvdXRwdXQsIHNhdmUgcHJldmlvdXMgYmxvY2tcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9vdXRCbG9ja1tpXSk7XG4gIH1cbiAgdGhpcy5fcHJldiA9IHRoaXMuX291dEJsb2NrO1xufTtcblxubW9kZXMuY2JjLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZGVjcnlwdFxuICBpZihpbnB1dC5sZW5ndGgoKSA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0Lmxlbmd0aCgpID4gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGdldCBuZXh0IGJsb2NrXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgfVxuXG4gIC8vIGRlY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZGVjcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gd3JpdGUgb3V0cHV0LCBzYXZlIHByZXZpb3VzIGNpcGhlcmVkIGJsb2NrXG4gIC8vIENCQyBYT1IncyBJViAob3IgcHJldmlvdXMgYmxvY2spIHdpdGggY2lwaGVydGV4dFxuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX3ByZXZbaV0gXiB0aGlzLl9vdXRCbG9ja1tpXSk7XG4gIH1cbiAgdGhpcy5fcHJldiA9IHRoaXMuX2luQmxvY2suc2xpY2UoMCk7XG59O1xuXG5tb2Rlcy5jYmMucHJvdG90eXBlLnBhZCA9IGZ1bmN0aW9uKGlucHV0LCBvcHRpb25zKSB7XG4gIC8vIGFkZCBQS0NTIzcgcGFkZGluZyB0byBibG9jayAoZWFjaCBwYWQgYnl0ZSBpcyB0aGVcbiAgLy8gdmFsdWUgb2YgdGhlIG51bWJlciBvZiBwYWQgYnl0ZXMpXG4gIHZhciBwYWRkaW5nID0gKGlucHV0Lmxlbmd0aCgpID09PSB0aGlzLmJsb2NrU2l6ZSA/XG4gICAgdGhpcy5ibG9ja1NpemUgOiAodGhpcy5ibG9ja1NpemUgLSBpbnB1dC5sZW5ndGgoKSkpO1xuICBpbnB1dC5maWxsV2l0aEJ5dGUocGFkZGluZywgcGFkZGluZyk7XG4gIHJldHVybiB0cnVlO1xufTtcblxubW9kZXMuY2JjLnByb3RvdHlwZS51bnBhZCA9IGZ1bmN0aW9uKG91dHB1dCwgb3B0aW9ucykge1xuICAvLyBjaGVjayBmb3IgZXJyb3I6IGlucHV0IGRhdGEgbm90IGEgbXVsdGlwbGUgb2YgYmxvY2tTaXplXG4gIGlmKG9wdGlvbnMub3ZlcmZsb3cgPiAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZW5zdXJlIHBhZGRpbmcgYnl0ZSBjb3VudCBpcyB2YWxpZFxuICB2YXIgbGVuID0gb3V0cHV0Lmxlbmd0aCgpO1xuICB2YXIgY291bnQgPSBvdXRwdXQuYXQobGVuIC0gMSk7XG4gIGlmKGNvdW50ID4gKHRoaXMuYmxvY2tTaXplIDw8IDIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gdHJpbSBvZmYgcGFkZGluZyBieXRlc1xuICBvdXRwdXQudHJ1bmNhdGUoY291bnQpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKiBDaXBoZXIgZmVlZGJhY2sgKENGQikgKiovXG5cbm1vZGVzLmNmYiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdDRkInO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbnVsbDtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgdGhpcy5fcGFydGlhbE91dHB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG59O1xuXG5tb2Rlcy5jZmIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZighKCdpdicgaW4gb3B0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSVYgcGFyYW1ldGVyLicpO1xuICB9XG4gIC8vIHVzZSBJViBhcyBmaXJzdCBpbnB1dFxuICB0aGlzLl9pdiA9IHRyYW5zZm9ybUlWKG9wdGlvbnMuaXYsIHRoaXMuYmxvY2tTaXplKTtcbiAgdGhpcy5faW5CbG9jayA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY2ZiLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gaGFuZGxlIGZ1bGwgYmxvY2tcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID09PSAwICYmIGlucHV0TGVuZ3RoID49IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgLy8gWE9SIGlucHV0IHdpdGggb3V0cHV0LCB3cml0ZSBpbnB1dCBhcyBvdXRwdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldO1xuICAgICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX2luQmxvY2tbaV0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICB2YXIgcGFydGlhbEJ5dGVzID0gKHRoaXMuYmxvY2tTaXplIC0gaW5wdXRMZW5ndGgpICUgdGhpcy5ibG9ja1NpemU7XG4gIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgfVxuXG4gIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCwgd3JpdGUgaW5wdXQgYXMgcGFydGlhbCBvdXRwdXRcbiAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5fcGFydGlhbEJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldO1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQucHV0SW50MzIodGhpcy5fcGFydGlhbEJsb2NrW2ldKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAvLyBibG9jayBzdGlsbCBpbmNvbXBsZXRlLCByZXN0b3JlIGlucHV0IGJ1ZmZlclxuICAgIGlucHV0LnJlYWQgLT0gdGhpcy5ibG9ja1NpemU7XG4gIH0gZWxzZSB7XG4gICAgLy8gYmxvY2sgY29tcGxldGUsIHVwZGF0ZSBpbnB1dCBibG9ja1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9wYXJ0aWFsQmxvY2tbaV07XG4gICAgfVxuICB9XG5cbiAgLy8gc2tpcCBhbnkgcHJldmlvdXMgcGFydGlhbCBieXRlc1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyh0aGlzLl9wYXJ0aWFsQnl0ZXMpO1xuICB9XG5cbiAgaWYocGFydGlhbEJ5dGVzID4gMCAmJiAhZmluaXNoKSB7XG4gICAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgICBwYXJ0aWFsQnl0ZXMgLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICBpbnB1dExlbmd0aCAtIHRoaXMuX3BhcnRpYWxCeXRlcykpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY2ZiLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZGVjcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKENGQiBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCwgd3JpdGUgaW5wdXQgYXMgb3V0cHV0XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gICAgICBvdXRwdXQucHV0SW50MzIodGhpcy5faW5CbG9ja1tpXSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaGFuZGxlIHBhcnRpYWwgYmxvY2tcbiAgdmFyIHBhcnRpYWxCeXRlcyA9ICh0aGlzLmJsb2NrU2l6ZSAtIGlucHV0TGVuZ3RoKSAlIHRoaXMuYmxvY2tTaXplO1xuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgcGFydGlhbEJ5dGVzID0gdGhpcy5ibG9ja1NpemUgLSBwYXJ0aWFsQnl0ZXM7XG4gIH1cblxuICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXQsIHdyaXRlIGlucHV0IGFzIHBhcnRpYWwgb3V0cHV0XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQuY2xlYXIoKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIHRoaXMuX3BhcnRpYWxCbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMih0aGlzLl9wYXJ0aWFsQmxvY2tbaV0gXiB0aGlzLl9vdXRCbG9ja1tpXSk7XG4gIH1cblxuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgLy8gYmxvY2sgc3RpbGwgaW5jb21wbGV0ZSwgcmVzdG9yZSBpbnB1dCBidWZmZXJcbiAgICBpbnB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICB9IGVsc2Uge1xuICAgIC8vIGJsb2NrIGNvbXBsZXRlLCB1cGRhdGUgaW5wdXQgYmxvY2tcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICB0aGlzLl9pbkJsb2NrW2ldID0gdGhpcy5fcGFydGlhbEJsb2NrW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXModGhpcy5fcGFydGlhbEJ5dGVzKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gcGFydGlhbEJ5dGVzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgaW5wdXRMZW5ndGggLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbi8qKiBPdXRwdXQgZmVlZGJhY2sgKE9GQikgKiovXG5cbm1vZGVzLm9mYiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdPRkInO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbnVsbDtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMub2ZiLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfVxuICAvLyB1c2UgSVYgYXMgZmlyc3QgaW5wdXRcbiAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2LCB0aGlzLmJsb2NrU2l6ZSk7XG4gIHRoaXMuX2luQmxvY2sgPSB0aGlzLl9pdi5zbGljZSgwKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbm1vZGVzLm9mYi5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGVuY3J5cHRcbiAgdmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoKCk7XG4gIGlmKGlucHV0Lmxlbmd0aCgpID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBlbmNyeXB0IGJsb2NrIChPRkIgYWx3YXlzIHVzZXMgZW5jcnlwdGlvbiBtb2RlKVxuICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyBoYW5kbGUgZnVsbCBibG9ja1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPT09IDAgJiYgaW5wdXRMZW5ndGggPj0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXQgYW5kIHVwZGF0ZSBuZXh0IGlucHV0XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgb3V0cHV0LnB1dEludDMyKGlucHV0LmdldEludDMyKCkgXiB0aGlzLl9vdXRCbG9ja1tpXSk7XG4gICAgICB0aGlzLl9pbkJsb2NrW2ldID0gdGhpcy5fb3V0QmxvY2tbaV07XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGhhbmRsZSBwYXJ0aWFsIGJsb2NrXG4gIHZhciBwYXJ0aWFsQnl0ZXMgPSAodGhpcy5ibG9ja1NpemUgLSBpbnB1dExlbmd0aCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgaWYocGFydGlhbEJ5dGVzID4gMCkge1xuICAgIHBhcnRpYWxCeXRlcyA9IHRoaXMuYmxvY2tTaXplIC0gcGFydGlhbEJ5dGVzO1xuICB9XG5cbiAgLy8gWE9SIGlucHV0IHdpdGggb3V0cHV0XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQuY2xlYXIoKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQucHV0SW50MzIoaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAvLyBibG9jayBzdGlsbCBpbmNvbXBsZXRlLCByZXN0b3JlIGlucHV0IGJ1ZmZlclxuICAgIGlucHV0LnJlYWQgLT0gdGhpcy5ibG9ja1NpemU7XG4gIH0gZWxzZSB7XG4gICAgLy8gYmxvY2sgY29tcGxldGUsIHVwZGF0ZSBpbnB1dCBibG9ja1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9vdXRCbG9ja1tpXTtcbiAgICB9XG4gIH1cblxuICAvLyBza2lwIGFueSBwcmV2aW91cyBwYXJ0aWFsIGJ5dGVzXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA+IDApIHtcbiAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKHRoaXMuX3BhcnRpYWxCeXRlcyk7XG4gIH1cblxuICBpZihwYXJ0aWFsQnl0ZXMgPiAwICYmICFmaW5pc2gpIHtcbiAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgIHBhcnRpYWxCeXRlcyAtIHRoaXMuX3BhcnRpYWxCeXRlcykpO1xuICAgIHRoaXMuX3BhcnRpYWxCeXRlcyA9IHBhcnRpYWxCeXRlcztcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgIGlucHV0TGVuZ3RoIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG59O1xuXG5tb2Rlcy5vZmIucHJvdG90eXBlLmRlY3J5cHQgPSBtb2Rlcy5vZmIucHJvdG90eXBlLmVuY3J5cHQ7XG5cbi8qKiBDb3VudGVyIChDVFIpICoqL1xuXG5tb2Rlcy5jdHIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm5hbWUgPSAnQ1RSJztcbiAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgdGhpcy5faW50cyA9IHRoaXMuYmxvY2tTaXplIC8gNDtcbiAgdGhpcy5faW5CbG9jayA9IG51bGw7XG4gIHRoaXMuX291dEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9wYXJ0aWFsT3V0cHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbm1vZGVzLmN0ci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmKCEoJ2l2JyBpbiBvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJViBwYXJhbWV0ZXIuJyk7XG4gIH1cbiAgLy8gdXNlIElWIGFzIGZpcnN0IGlucHV0XG4gIHRoaXMuX2l2ID0gdHJhbnNmb3JtSVYob3B0aW9ucy5pdiwgdGhpcy5ibG9ja1NpemUpO1xuICB0aGlzLl9pbkJsb2NrID0gdGhpcy5faXYuc2xpY2UoMCk7XG4gIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG59O1xuXG5tb2Rlcy5jdHIucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBlbmNyeXB0XG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCgpO1xuICBpZihpbnB1dExlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZW5jcnlwdCBibG9jayAoQ1RSIGFsd2F5cyB1c2VzIGVuY3J5cHRpb24gbW9kZSlcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gaGFuZGxlIGZ1bGwgYmxvY2tcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID09PSAwICYmIGlucHV0TGVuZ3RoID49IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgLy8gWE9SIGlucHV0IHdpdGggb3V0cHV0XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgb3V0cHV0LnB1dEludDMyKGlucHV0LmdldEludDMyKCkgXiB0aGlzLl9vdXRCbG9ja1tpXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGhhbmRsZSBwYXJ0aWFsIGJsb2NrXG4gICAgdmFyIHBhcnRpYWxCeXRlcyA9ICh0aGlzLmJsb2NrU2l6ZSAtIGlucHV0TGVuZ3RoKSAlIHRoaXMuYmxvY2tTaXplO1xuICAgIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAgIHBhcnRpYWxCeXRlcyA9IHRoaXMuYmxvY2tTaXplIC0gcGFydGlhbEJ5dGVzO1xuICAgIH1cblxuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dFxuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuY2xlYXIoKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LnB1dEludDMyKGlucHV0LmdldEludDMyKCkgXiB0aGlzLl9vdXRCbG9ja1tpXSk7XG4gICAgfVxuXG4gICAgaWYocGFydGlhbEJ5dGVzID4gMCkge1xuICAgICAgLy8gYmxvY2sgc3RpbGwgaW5jb21wbGV0ZSwgcmVzdG9yZSBpbnB1dCBidWZmZXJcbiAgICAgIGlucHV0LnJlYWQgLT0gdGhpcy5ibG9ja1NpemU7XG4gICAgfVxuXG4gICAgLy8gc2tpcCBhbnkgcHJldmlvdXMgcGFydGlhbCBieXRlc1xuICAgIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXModGhpcy5fcGFydGlhbEJ5dGVzKTtcbiAgICB9XG5cbiAgICBpZihwYXJ0aWFsQnl0ZXMgPiAwICYmICFmaW5pc2gpIHtcbiAgICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgICBwYXJ0aWFsQnl0ZXMgLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgICAgIHRoaXMuX3BhcnRpYWxCeXRlcyA9IHBhcnRpYWxCeXRlcztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgaW5wdXRMZW5ndGggLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xuICB9XG5cbiAgLy8gYmxvY2sgY29tcGxldGUsIGluY3JlbWVudCBjb3VudGVyIChpbnB1dCBibG9jaylcbiAgaW5jMzIodGhpcy5faW5CbG9jayk7XG59O1xuXG5tb2Rlcy5jdHIucHJvdG90eXBlLmRlY3J5cHQgPSBtb2Rlcy5jdHIucHJvdG90eXBlLmVuY3J5cHQ7XG5cbi8qKiBHYWxvaXMvQ291bnRlciBNb2RlIChHQ00pICoqL1xuXG5tb2Rlcy5nY20gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm5hbWUgPSAnR0NNJztcbiAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgdGhpcy5faW50cyA9IHRoaXMuYmxvY2tTaXplIC8gNDtcbiAgdGhpcy5faW5CbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xuXG4gIC8vIFIgaXMgYWN0dWFsbHkgdGhpcyB2YWx1ZSBjb25jYXRlbmF0ZWQgd2l0aCAxMjAgbW9yZSB6ZXJvIGJpdHMsIGJ1dFxuICAvLyB3ZSBvbmx5IFhPUiBhZ2FpbnN0IFIgc28gdGhlIG90aGVyIHplcm9zIGhhdmUgbm8gZWZmZWN0IC0tIHdlIGp1c3RcbiAgLy8gYXBwbHkgdGhpcyB2YWx1ZSB0byB0aGUgZmlyc3QgaW50ZWdlciBpbiBhIGJsb2NrXG4gIHRoaXMuX1IgPSAweEUxMDAwMDAwO1xufTtcblxubW9kZXMuZ2NtLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfVxuICAvLyBlbnN1cmUgSVYgaXMgYSBieXRlIGJ1ZmZlclxuICB2YXIgaXYgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihvcHRpb25zLml2KTtcblxuICAvLyBubyBjaXBoZXJlZCBkYXRhIHByb2Nlc3NlZCB5ZXRcbiAgdGhpcy5fY2lwaGVyTGVuZ3RoID0gMDtcblxuICAvLyBkZWZhdWx0IGFkZGl0aW9uYWwgZGF0YSBpcyBub25lXG4gIHZhciBhZGRpdGlvbmFsRGF0YTtcbiAgaWYoJ2FkZGl0aW9uYWxEYXRhJyBpbiBvcHRpb25zKSB7XG4gICAgYWRkaXRpb25hbERhdGEgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihvcHRpb25zLmFkZGl0aW9uYWxEYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBhZGRpdGlvbmFsRGF0YSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIH1cblxuICAvLyBkZWZhdWx0IHRhZyBsZW5ndGggaXMgMTI4IGJpdHNcbiAgaWYoJ3RhZ0xlbmd0aCcgaW4gb3B0aW9ucykge1xuICAgIHRoaXMuX3RhZ0xlbmd0aCA9IG9wdGlvbnMudGFnTGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3RhZ0xlbmd0aCA9IDEyODtcbiAgfVxuXG4gIC8vIGlmIHRhZyBpcyBnaXZlbiwgZW5zdXJlIHRhZyBtYXRjaGVzIHRhZyBsZW5ndGhcbiAgdGhpcy5fdGFnID0gbnVsbDtcbiAgaWYob3B0aW9ucy5kZWNyeXB0KSB7XG4gICAgLy8gc2F2ZSB0YWcgdG8gY2hlY2sgbGF0ZXJcbiAgICB0aGlzLl90YWcgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihvcHRpb25zLnRhZykuZ2V0Qnl0ZXMoKTtcbiAgICBpZih0aGlzLl90YWcubGVuZ3RoICE9PSAodGhpcy5fdGFnTGVuZ3RoIC8gOCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXV0aGVudGljYXRpb24gdGFnIGRvZXMgbm90IG1hdGNoIHRhZyBsZW5ndGguJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gY3JlYXRlIHRtcCBzdG9yYWdlIGZvciBoYXNoIGNhbGN1bGF0aW9uXG4gIHRoaXMuX2hhc2hCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcblxuICAvLyBubyB0YWcgZ2VuZXJhdGVkIHlldFxuICB0aGlzLnRhZyA9IG51bGw7XG5cbiAgLy8gZ2VuZXJhdGUgaGFzaCBzdWJrZXlcbiAgLy8gKGFwcGx5IGJsb2NrIGNpcGhlciB0byBcInplcm9cIiBibG9jaylcbiAgdGhpcy5faGFzaFN1YmtleSA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdChbMCwgMCwgMCwgMF0sIHRoaXMuX2hhc2hTdWJrZXkpO1xuXG4gIC8vIGdlbmVyYXRlIHRhYmxlIE1cbiAgLy8gdXNlIDQtYml0IHRhYmxlcyAoMzIgY29tcG9uZW50IGRlY29tcG9zaXRpb24gb2YgYSAxNiBieXRlIHZhbHVlKVxuICAvLyA4LWJpdCB0YWJsZXMgdGFrZSBtb3JlIHNwYWNlIGFuZCBhcmUga25vd24gdG8gaGF2ZSBzZWN1cml0eVxuICAvLyB2dWxuZXJhYmlsaXRpZXMgKGluIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbnMpXG4gIHRoaXMuY29tcG9uZW50Qml0cyA9IDQ7XG4gIHRoaXMuX20gPSB0aGlzLmdlbmVyYXRlSGFzaFRhYmxlKHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuY29tcG9uZW50Qml0cyk7XG5cbiAgLy8gTm90ZTogc3VwcG9ydCBJViBsZW5ndGggZGlmZmVyZW50IGZyb20gOTYgYml0cz8gKG9ubHkgc3VwcG9ydGluZ1xuICAvLyA5NiBiaXRzIGlzIHJlY29tbWVuZGVkIGJ5IE5JU1QgU1AtODAwLTM4RClcbiAgLy8gZ2VuZXJhdGUgSl8wXG4gIHZhciBpdkxlbmd0aCA9IGl2Lmxlbmd0aCgpO1xuICBpZihpdkxlbmd0aCA9PT0gMTIpIHtcbiAgICAvLyA5Ni1iaXQgSVZcbiAgICB0aGlzLl9qMCA9IFtpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpLCAxXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJViBpcyBOT1QgOTYtYml0c1xuICAgIHRoaXMuX2owID0gWzAsIDAsIDAsIDBdO1xuICAgIHdoaWxlKGl2Lmxlbmd0aCgpID4gMCkge1xuICAgICAgdGhpcy5fajAgPSB0aGlzLmdoYXNoKFxuICAgICAgICB0aGlzLl9oYXNoU3Via2V5LCB0aGlzLl9qMCxcbiAgICAgICAgW2l2LmdldEludDMyKCksIGl2LmdldEludDMyKCksIGl2LmdldEludDMyKCksIGl2LmdldEludDMyKCldKTtcbiAgICB9XG4gICAgdGhpcy5fajAgPSB0aGlzLmdoYXNoKFxuICAgICAgdGhpcy5faGFzaFN1YmtleSwgdGhpcy5fajAsIFswLCAwXS5jb25jYXQoZnJvbTY0VG8zMihpdkxlbmd0aCAqIDgpKSk7XG4gIH1cblxuICAvLyBnZW5lcmF0ZSBJQ0IgKGluaXRpYWwgY291bnRlciBibG9jaylcbiAgdGhpcy5faW5CbG9jayA9IHRoaXMuX2owLnNsaWNlKDApO1xuICBpbmMzMih0aGlzLl9pbkJsb2NrKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcblxuICAvLyBjb25zdW1lIGF1dGhlbnRpY2F0aW9uIGRhdGFcbiAgYWRkaXRpb25hbERhdGEgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihhZGRpdGlvbmFsRGF0YSk7XG4gIC8vIHNhdmUgYWRkaXRpb25hbCBkYXRhIGxlbmd0aCBhcyBhIEJFIDY0LWJpdCBudW1iZXJcbiAgdGhpcy5fYURhdGFMZW5ndGggPSBmcm9tNjRUbzMyKGFkZGl0aW9uYWxEYXRhLmxlbmd0aCgpICogOCk7XG4gIC8vIHBhZCBhZGRpdGlvbmFsIGRhdGEgdG8gMTI4IGJpdCAoMTYgYnl0ZSkgYmxvY2sgc2l6ZVxuICB2YXIgb3ZlcmZsb3cgPSBhZGRpdGlvbmFsRGF0YS5sZW5ndGgoKSAlIHRoaXMuYmxvY2tTaXplO1xuICBpZihvdmVyZmxvdykge1xuICAgIGFkZGl0aW9uYWxEYXRhLmZpbGxXaXRoQnl0ZSgwLCB0aGlzLmJsb2NrU2l6ZSAtIG92ZXJmbG93KTtcbiAgfVxuICB0aGlzLl9zID0gWzAsIDAsIDAsIDBdO1xuICB3aGlsZShhZGRpdGlvbmFsRGF0YS5sZW5ndGgoKSA+IDApIHtcbiAgICB0aGlzLl9zID0gdGhpcy5naGFzaCh0aGlzLl9oYXNoU3Via2V5LCB0aGlzLl9zLCBbXG4gICAgICBhZGRpdGlvbmFsRGF0YS5nZXRJbnQzMigpLFxuICAgICAgYWRkaXRpb25hbERhdGEuZ2V0SW50MzIoKSxcbiAgICAgIGFkZGl0aW9uYWxEYXRhLmdldEludDMyKCksXG4gICAgICBhZGRpdGlvbmFsRGF0YS5nZXRJbnQzMigpXG4gICAgXSk7XG4gIH1cbn07XG5cbm1vZGVzLmdjbS5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGVuY3J5cHRcbiAgdmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoKCk7XG4gIGlmKGlucHV0TGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBlbmNyeXB0IGJsb2NrXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dFxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9vdXRCbG9ja1tpXSBePSBpbnB1dC5nZXRJbnQzMigpKTtcbiAgICB9XG4gICAgdGhpcy5fY2lwaGVyTGVuZ3RoICs9IHRoaXMuYmxvY2tTaXplO1xuICB9IGVsc2Uge1xuICAgIC8vIGhhbmRsZSBwYXJ0aWFsIGJsb2NrXG4gICAgdmFyIHBhcnRpYWxCeXRlcyA9ICh0aGlzLmJsb2NrU2l6ZSAtIGlucHV0TGVuZ3RoKSAlIHRoaXMuYmxvY2tTaXplO1xuICAgIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAgIHBhcnRpYWxCeXRlcyA9IHRoaXMuYmxvY2tTaXplIC0gcGFydGlhbEJ5dGVzO1xuICAgIH1cblxuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dFxuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuY2xlYXIoKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LnB1dEludDMyKGlucHV0LmdldEludDMyKCkgXiB0aGlzLl9vdXRCbG9ja1tpXSk7XG4gICAgfVxuXG4gICAgaWYocGFydGlhbEJ5dGVzIDw9IDAgfHwgZmluaXNoKSB7XG4gICAgICAvLyBoYW5kbGUgb3ZlcmZsb3cgcHJpb3IgdG8gaGFzaGluZ1xuICAgICAgaWYoZmluaXNoKSB7XG4gICAgICAgIC8vIGdldCBibG9jayBvdmVyZmxvd1xuICAgICAgICB2YXIgb3ZlcmZsb3cgPSBpbnB1dExlbmd0aCAlIHRoaXMuYmxvY2tTaXplO1xuICAgICAgICB0aGlzLl9jaXBoZXJMZW5ndGggKz0gb3ZlcmZsb3c7XG4gICAgICAgIC8vIHRydW5jYXRlIGZvciBoYXNoIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQudHJ1bmNhdGUodGhpcy5ibG9ja1NpemUgLSBvdmVyZmxvdyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jaXBoZXJMZW5ndGggKz0gdGhpcy5ibG9ja1NpemU7XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCBvdXRwdXQgYmxvY2sgZm9yIGhhc2hpbmdcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgICAgdGhpcy5fb3V0QmxvY2tbaV0gPSB0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEludDMyKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LnJlYWQgLT0gdGhpcy5ibG9ja1NpemU7XG4gICAgfVxuXG4gICAgLy8gc2tpcCBhbnkgcHJldmlvdXMgcGFydGlhbCBieXRlc1xuICAgIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXModGhpcy5fcGFydGlhbEJ5dGVzKTtcbiAgICB9XG5cbiAgICBpZihwYXJ0aWFsQnl0ZXMgPiAwICYmICFmaW5pc2gpIHtcbiAgICAgIC8vIGJsb2NrIHN0aWxsIGluY29tcGxldGUsIHJlc3RvcmUgaW5wdXQgYnVmZmVyLCBnZXQgcGFydGlhbCBvdXRwdXQsXG4gICAgICAvLyBhbmQgcmV0dXJuIGVhcmx5XG4gICAgICBpbnB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICAgICAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgICAgIHBhcnRpYWxCeXRlcyAtIHRoaXMuX3BhcnRpYWxCeXRlcykpO1xuICAgICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gcGFydGlhbEJ5dGVzO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgICBpbnB1dExlbmd0aCAtIHRoaXMuX3BhcnRpYWxCeXRlcykpO1xuICAgIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG4gIH1cblxuICAvLyB1cGRhdGUgaGFzaCBibG9jayBTXG4gIHRoaXMuX3MgPSB0aGlzLmdoYXNoKHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuX3MsIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyBpbmNyZW1lbnQgY291bnRlciAoaW5wdXQgYmxvY2spXG4gIGluYzMyKHRoaXMuX2luQmxvY2spO1xufTtcblxubW9kZXMuZ2NtLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZGVjcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPCB0aGlzLmJsb2NrU2l6ZSAmJiAhKGZpbmlzaCAmJiBpbnB1dExlbmd0aCA+IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBlbmNyeXB0IGJsb2NrIChHQ00gYWx3YXlzIHVzZXMgZW5jcnlwdGlvbiBtb2RlKVxuICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyBpbmNyZW1lbnQgY291bnRlciAoaW5wdXQgYmxvY2spXG4gIGluYzMyKHRoaXMuX2luQmxvY2spO1xuXG4gIC8vIHVwZGF0ZSBoYXNoIGJsb2NrIFNcbiAgdGhpcy5faGFzaEJsb2NrWzBdID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgdGhpcy5faGFzaEJsb2NrWzFdID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgdGhpcy5faGFzaEJsb2NrWzJdID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgdGhpcy5faGFzaEJsb2NrWzNdID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgdGhpcy5fcyA9IHRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSwgdGhpcy5fcywgdGhpcy5faGFzaEJsb2NrKTtcblxuICAvLyBYT1IgaGFzaCBpbnB1dCB3aXRoIG91dHB1dFxuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX291dEJsb2NrW2ldIF4gdGhpcy5faGFzaEJsb2NrW2ldKTtcbiAgfVxuXG4gIC8vIGluY3JlbWVudCBjaXBoZXIgZGF0YSBsZW5ndGhcbiAgaWYoaW5wdXRMZW5ndGggPCB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSBpbnB1dExlbmd0aCAlIHRoaXMuYmxvY2tTaXplO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgfVxufTtcblxubW9kZXMuZ2NtLnByb3RvdHlwZS5hZnRlckZpbmlzaCA9IGZ1bmN0aW9uKG91dHB1dCwgb3B0aW9ucykge1xuICB2YXIgcnZhbCA9IHRydWU7XG5cbiAgLy8gaGFuZGxlIG92ZXJmbG93XG4gIGlmKG9wdGlvbnMuZGVjcnlwdCAmJiBvcHRpb25zLm92ZXJmbG93KSB7XG4gICAgb3V0cHV0LnRydW5jYXRlKHRoaXMuYmxvY2tTaXplIC0gb3B0aW9ucy5vdmVyZmxvdyk7XG4gIH1cblxuICAvLyBoYW5kbGUgYXV0aGVudGljYXRpb24gdGFnXG4gIHRoaXMudGFnID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcblxuICAvLyBjb25jYXRlbmF0ZSBhZGRpdGlvbmFsIGRhdGEgbGVuZ3RoIHdpdGggY2lwaGVyIGxlbmd0aFxuICB2YXIgbGVuZ3RocyA9IHRoaXMuX2FEYXRhTGVuZ3RoLmNvbmNhdChmcm9tNjRUbzMyKHRoaXMuX2NpcGhlckxlbmd0aCAqIDgpKTtcblxuICAvLyBpbmNsdWRlIGxlbmd0aHMgaW4gaGFzaFxuICB0aGlzLl9zID0gdGhpcy5naGFzaCh0aGlzLl9oYXNoU3Via2V5LCB0aGlzLl9zLCBsZW5ndGhzKTtcblxuICAvLyBkbyBHQ1RSKEpfMCwgUylcbiAgdmFyIHRhZyA9IFtdO1xuICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2owLCB0YWcpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy50YWcucHV0SW50MzIodGhpcy5fc1tpXSBeIHRhZ1tpXSk7XG4gIH1cblxuICAvLyB0cmltIHRhZyB0byBsZW5ndGhcbiAgdGhpcy50YWcudHJ1bmNhdGUodGhpcy50YWcubGVuZ3RoKCkgJSAodGhpcy5fdGFnTGVuZ3RoIC8gOCkpO1xuXG4gIC8vIGNoZWNrIGF1dGhlbnRpY2F0aW9uIHRhZ1xuICBpZihvcHRpb25zLmRlY3J5cHQgJiYgdGhpcy50YWcuYnl0ZXMoKSAhPT0gdGhpcy5fdGFnKSB7XG4gICAgcnZhbCA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIFNlZSBOSVNUIFNQLTgwMC0zOEQgNi4zIChBbGdvcml0aG0gMSkuIFRoaXMgZnVuY3Rpb24gcGVyZm9ybXMgR2Fsb2lzXG4gKiBmaWVsZCBtdWx0aXBsaWNhdGlvbi4gVGhlIGZpZWxkLCBHRigyXjEyOCksIGlzIGRlZmluZWQgYnkgdGhlIHBvbHlub21pYWw6XG4gKlxuICogeF4xMjggKyB4XjcgKyB4XjIgKyB4ICsgMVxuICpcbiAqIFdoaWNoIGlzIHJlcHJlc2VudGVkIGluIGxpdHRsZS1lbmRpYW4gYmluYXJ5IGZvcm0gYXM6IDExMTAwMDAxICgweGUxKS4gV2hlblxuICogdGhlIHZhbHVlIG9mIGEgY29lZmZpY2llbnQgaXMgMSwgYSBiaXQgaXMgc2V0LiBUaGUgdmFsdWUgUiwgaXMgdGhlXG4gKiBjb25jYXRlbmF0aW9uIG9mIHRoaXMgdmFsdWUgYW5kIDEyMCB6ZXJvIGJpdHMsIHlpZWxkaW5nIGEgMTI4LWJpdCB2YWx1ZVxuICogd2hpY2ggbWF0Y2hlcyB0aGUgYmxvY2sgc2l6ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgbXVsdGlwbHkgdHdvIGVsZW1lbnRzICh2ZWN0b3JzIG9mIGJ5dGVzKSwgWCBhbmQgWSwgaW5cbiAqIHRoZSBmaWVsZCBHRigyXjEyOCkuIFRoZSByZXN1bHQgaXMgaW5pdGlhbGl6ZWQgdG8gemVyby4gRm9yIGVhY2ggYml0IG9mXG4gKiBYIChvdXQgb2YgMTI4KSwgeF9pLCBpZiB4X2kgaXMgc2V0LCB0aGVuIHRoZSByZXN1bHQgaXMgbXVsdGlwbGllZCAoWE9SJ2QpXG4gKiBieSB0aGUgY3VycmVudCB2YWx1ZSBvZiBZLiBGb3IgZWFjaCBiaXQsIHRoZSB2YWx1ZSBvZiBZIHdpbGwgYmUgcmFpc2VkIGJ5XG4gKiBhIHBvd2VyIG9mIHggKG11bHRpcGxpZWQgYnkgdGhlIHBvbHlub21pYWwgeCkuIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5XG4gKiBzaGlmdGluZyBZIG9uY2UgdG8gdGhlIHJpZ2h0LiBJZiB0aGUgY3VycmVudCB2YWx1ZSBvZiBZLCBwcmlvciB0byBiZWluZ1xuICogbXVsdGlwbGllZCBieSB4LCBoYXMgMCBhcyBpdHMgTFNCLCB0aGVuIGl0IGlzIGEgMTI3dGggZGVncmVlIHBvbHlub21pYWwuXG4gKiBPdGhlcndpc2UsIHdlIG11c3QgZGl2aWRlIGJ5IFIgYWZ0ZXIgc2hpZnRpbmcgdG8gZmluZCB0aGUgcmVtYWluZGVyLlxuICpcbiAqIEBwYXJhbSB4IHRoZSBmaXJzdCBibG9jayB0byBtdWx0aXBseSBieSB0aGUgc2Vjb25kLlxuICogQHBhcmFtIHkgdGhlIHNlY29uZCBibG9jayB0byBtdWx0aXBseSBieSB0aGUgZmlyc3QuXG4gKlxuICogQHJldHVybiB0aGUgYmxvY2sgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi5cbiAqL1xubW9kZXMuZ2NtLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgdmFyIHpfaSA9IFswLCAwLCAwLCAwXTtcbiAgdmFyIHZfaSA9IHkuc2xpY2UoMCk7XG5cbiAgLy8gY2FsY3VsYXRlIFpfMTI4IChibG9jayBoYXMgMTI4IGJpdHMpXG4gIGZvcih2YXIgaSA9IDA7IGkgPCAxMjg7ICsraSkge1xuICAgIC8vIGlmIHhfaSBpcyAwLCBaX3tpKzF9ID0gWl9pICh1bmNoYW5nZWQpXG4gICAgLy8gZWxzZSBaX3tpKzF9ID0gWl9pIF4gVl9pXG4gICAgLy8gZ2V0IHhfaSBieSBmaW5kaW5nIDMyLWJpdCBpbnQgcG9zaXRpb24sIHRoZW4gbGVmdCBzaGlmdCAxIGJ5IHJlbWFpbmRlclxuICAgIHZhciB4X2kgPSB4WyhpIC8gMzIpIHwgMF0gJiAoMSA8PCAoMzEgLSBpICUgMzIpKTtcbiAgICBpZih4X2kpIHtcbiAgICAgIHpfaVswXSBePSB2X2lbMF07XG4gICAgICB6X2lbMV0gXj0gdl9pWzFdO1xuICAgICAgel9pWzJdIF49IHZfaVsyXTtcbiAgICAgIHpfaVszXSBePSB2X2lbM107XG4gICAgfVxuXG4gICAgLy8gaWYgTFNCKFZfaSkgaXMgMSwgVl9pID0gVl9pID4+IDFcbiAgICAvLyBlbHNlIFZfaSA9IChWX2kgPj4gMSkgXiBSXG4gICAgdGhpcy5wb3codl9pLCB2X2kpO1xuICB9XG5cbiAgcmV0dXJuIHpfaTtcbn07XG5cbm1vZGVzLmdjbS5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24oeCwgb3V0KSB7XG4gIC8vIGlmIExTQih4KSBpcyAxLCB4ID0geCA+Pj4gMVxuICAvLyBlbHNlIHggPSAoeCA+Pj4gMSkgXiBSXG4gIHZhciBsc2IgPSB4WzNdICYgMTtcblxuICAvLyBhbHdheXMgZG8geCA+Pj4gMTpcbiAgLy8gc3RhcnRpbmcgd2l0aCB0aGUgcmlnaHRtb3N0IGludGVnZXIsIHNoaWZ0IGVhY2ggaW50ZWdlciB0byB0aGUgcmlnaHRcbiAgLy8gb25lIGJpdCwgcHVsbGluZyBpbiB0aGUgYml0IGZyb20gdGhlIGludGVnZXIgdG8gdGhlIGxlZnQgYXMgaXRzIHRvcFxuICAvLyBtb3N0IGJpdCAoZG8gdGhpcyBmb3IgdGhlIGxhc3QgMyBpbnRlZ2VycylcbiAgZm9yKHZhciBpID0gMzsgaSA+IDA7IC0taSkge1xuICAgIG91dFtpXSA9ICh4W2ldID4+PiAxKSB8ICgoeFtpIC0gMV0gJiAxKSA8PCAzMSk7XG4gIH1cbiAgLy8gc2hpZnQgdGhlIGZpcnN0IGludGVnZXIgbm9ybWFsbHlcbiAgb3V0WzBdID0geFswXSA+Pj4gMTtcblxuICAvLyBpZiBsc2Igd2FzIG5vdCBzZXQsIHRoZW4gcG9seW5vbWlhbCBoYWQgYSBkZWdyZWUgb2YgMTI3IGFuZCBkb2Vzbid0XG4gIC8vIG5lZWQgdG8gZGl2aWRlZDsgb3RoZXJ3aXNlLCBYT1Igd2l0aCBSIHRvIGZpbmQgdGhlIHJlbWFpbmRlcjsgd2Ugb25seVxuICAvLyBuZWVkIHRvIFhPUiB0aGUgZmlyc3QgaW50ZWdlciBzaW5jZSBSIHRlY2huaWNhbGx5IGVuZHMgdy8xMjAgemVybyBiaXRzXG4gIGlmKGxzYikge1xuICAgIG91dFswXSBePSB0aGlzLl9SO1xuICB9XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLnRhYmxlTXVsdGlwbHkgPSBmdW5jdGlvbih4KSB7XG4gIC8vIGFzc3VtZXMgNC1iaXQgdGFibGVzIGFyZSB1c2VkXG4gIHZhciB6ID0gWzAsIDAsIDAsIDBdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgMzI7ICsraSkge1xuICAgIHZhciBpZHggPSAoaSAvIDgpIHwgMDtcbiAgICB2YXIgeF9pID0gKHhbaWR4XSA+Pj4gKCg3IC0gKGkgJSA4KSkgKiA0KSkgJiAweEY7XG4gICAgdmFyIGFoID0gdGhpcy5fbVtpXVt4X2ldO1xuICAgIHpbMF0gXj0gYWhbMF07XG4gICAgelsxXSBePSBhaFsxXTtcbiAgICB6WzJdIF49IGFoWzJdO1xuICAgIHpbM10gXj0gYWhbM107XG4gIH1cbiAgcmV0dXJuIHo7XG59O1xuXG4vKipcbiAqIEEgY29udGludWluZyB2ZXJzaW9uIG9mIHRoZSBHSEFTSCBhbGdvcml0aG0gdGhhdCBvcGVyYXRlcyBvbiBhIHNpbmdsZVxuICogYmxvY2suIFRoZSBoYXNoIGJsb2NrLCBsYXN0IGhhc2ggdmFsdWUgKFltKSBhbmQgdGhlIG5ldyBibG9jayB0byBoYXNoXG4gKiBhcmUgZ2l2ZW4uXG4gKlxuICogQHBhcmFtIGggdGhlIGhhc2ggYmxvY2suXG4gKiBAcGFyYW0geSB0aGUgcHJldmlvdXMgdmFsdWUgZm9yIFltLCB1c2UgWzAsIDAsIDAsIDBdIGZvciBhIG5ldyBoYXNoLlxuICogQHBhcmFtIHggdGhlIGJsb2NrIHRvIGhhc2guXG4gKlxuICogQHJldHVybiB0aGUgaGFzaGVkIHZhbHVlIChZbSkuXG4gKi9cbm1vZGVzLmdjbS5wcm90b3R5cGUuZ2hhc2ggPSBmdW5jdGlvbihoLCB5LCB4KSB7XG4gIHlbMF0gXj0geFswXTtcbiAgeVsxXSBePSB4WzFdO1xuICB5WzJdIF49IHhbMl07XG4gIHlbM10gXj0geFszXTtcbiAgcmV0dXJuIHRoaXMudGFibGVNdWx0aXBseSh5KTtcbiAgLy9yZXR1cm4gdGhpcy5tdWx0aXBseSh5LCBoKTtcbn07XG5cbi8qKlxuICogUHJlY29tcHV0ZXMgYSB0YWJsZSBmb3IgbXVsdGlwbHlpbmcgYWdhaW5zdCB0aGUgaGFzaCBzdWJrZXkuIFRoaXNcbiAqIG1lY2hhbmlzbSBwcm92aWRlcyBhIHN1YnN0YW50aWFsIHNwZWVkIGluY3JlYXNlIG92ZXIgbXVsdGlwbGljYXRpb25cbiAqIHBlcmZvcm1lZCB3aXRob3V0IGEgdGFibGUuIFRoZSB0YWJsZS1iYXNlZCBtdWx0aXBsaWNhdGlvbiB0aGlzIHRhYmxlIGlzXG4gKiBmb3Igc29sdmVzIFggKiBIIGJ5IG11bHRpcGx5aW5nIGVhY2ggY29tcG9uZW50IG9mIFggYnkgSCBhbmQgdGhlblxuICogY29tcG9zaW5nIHRoZSByZXN1bHRzIHRvZ2V0aGVyIHVzaW5nIFhPUi5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIHRhYmxlcyB3aXRoIGRpZmZlcmVudCBiaXQgc2l6ZXNcbiAqIGZvciB0aGUgY29tcG9uZW50cywgaG93ZXZlciwgdGhpcyBpbXBsZW1lbnRhdGlvbiBhc3N1bWVzIHRoZXJlIGFyZVxuICogMzIgY29tcG9uZW50cyBvZiBYICh3aGljaCBpcyBhIDE2IGJ5dGUgdmVjdG9yKSwgdGhlcmVmb3JlIGVhY2ggY29tcG9uZW50XG4gKiB0YWtlcyA0LWJpdHMgKHNvIHRoZSB0YWJsZSBpcyBjb25zdHJ1Y3RlZCB3aXRoIGJpdHM9NCkuXG4gKlxuICogQHBhcmFtIGggdGhlIGhhc2ggc3Via2V5LlxuICogQHBhcmFtIGJpdHMgdGhlIGJpdCBzaXplIGZvciBhIGNvbXBvbmVudC5cbiAqL1xubW9kZXMuZ2NtLnByb3RvdHlwZS5nZW5lcmF0ZUhhc2hUYWJsZSA9IGZ1bmN0aW9uKGgsIGJpdHMpIHtcbiAgLy8gVE9ETzogVGhlcmUgYXJlIGZ1cnRoZXIgb3B0aW1pemF0aW9ucyB0aGF0IHdvdWxkIHVzZSBvbmx5IHRoZVxuICAvLyBmaXJzdCB0YWJsZSBNXzAgKG9yIHNvbWUgdmFyaWFudCkgYWxvbmcgd2l0aCBhIHJlbWFpbmRlciB0YWJsZTtcbiAgLy8gdGhpcyBjYW4gYmUgZXhwbG9yZWQgaW4gdGhlIGZ1dHVyZVxuICB2YXIgbXVsdGlwbGllciA9IDggLyBiaXRzO1xuICB2YXIgcGVySW50ID0gNCAqIG11bHRpcGxpZXI7XG4gIHZhciBzaXplID0gMTYgKiBtdWx0aXBsaWVyO1xuICB2YXIgbSA9IG5ldyBBcnJheShzaXplKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgIHZhciB0bXAgPSBbMCwgMCwgMCwgMF07XG4gICAgdmFyIGlkeCA9IChpIC8gcGVySW50KSB8IDA7XG4gICAgdmFyIHNoZnQgPSAoKHBlckludCAtIDEgLSAoaSAlIHBlckludCkpICogYml0cyk7XG4gICAgdG1wW2lkeF0gPSAoMSA8PCAoYml0cyAtIDEpKSA8PCBzaGZ0O1xuICAgIG1baV0gPSB0aGlzLmdlbmVyYXRlU3ViSGFzaFRhYmxlKHRoaXMubXVsdGlwbHkodG1wLCBoKSwgYml0cyk7XG4gIH1cbiAgcmV0dXJuIG07XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHRhYmxlIGZvciBtdWx0aXBseWluZyBhZ2FpbnN0IHRoZSBoYXNoIHN1YmtleSBmb3Igb25lXG4gKiBwYXJ0aWN1bGFyIGNvbXBvbmVudCAob3V0IG9mIGFsbCBwb3NzaWJsZSBjb21wb25lbnQgdmFsdWVzKS5cbiAqXG4gKiBAcGFyYW0gbWlkIHRoZSBwcmUtbXVsdGlwbGllZCB2YWx1ZSBmb3IgdGhlIG1pZGRsZSBrZXkgb2YgdGhlIHRhYmxlLlxuICogQHBhcmFtIGJpdHMgdGhlIGJpdCBzaXplIGZvciBhIGNvbXBvbmVudC5cbiAqL1xubW9kZXMuZ2NtLnByb3RvdHlwZS5nZW5lcmF0ZVN1Ykhhc2hUYWJsZSA9IGZ1bmN0aW9uKG1pZCwgYml0cykge1xuICAvLyBjb21wdXRlIHRoZSB0YWJsZSBxdWlja2x5IGJ5IG1pbmltaXppbmcgdGhlIG51bWJlciBvZlxuICAvLyBQT1cgb3BlcmF0aW9ucyAtLSB0aGV5IG9ubHkgbmVlZCB0byBiZSBwZXJmb3JtZWQgZm9yIHBvd2VycyBvZiAyLFxuICAvLyBhbGwgb3RoZXIgZW50cmllcyBjYW4gYmUgY29tcG9zZWQgZnJvbSB0aG9zZSBwb3dlcnMgdXNpbmcgWE9SXG4gIHZhciBzaXplID0gMSA8PCBiaXRzO1xuICB2YXIgaGFsZiA9IHNpemUgPj4+IDE7XG4gIHZhciBtID0gbmV3IEFycmF5KHNpemUpO1xuICBtW2hhbGZdID0gbWlkLnNsaWNlKDApO1xuICB2YXIgaSA9IGhhbGYgPj4+IDE7XG4gIHdoaWxlKGkgPiAwKSB7XG4gICAgLy8gcmFpc2UgbTBbMiAqIGldIGFuZCBzdG9yZSBpbiBtMFtpXVxuICAgIHRoaXMucG93KG1bMiAqIGldLCBtW2ldID0gW10pO1xuICAgIGkgPj49IDE7XG4gIH1cbiAgaSA9IDI7XG4gIHdoaWxlKGkgPCBoYWxmKSB7XG4gICAgZm9yKHZhciBqID0gMTsgaiA8IGk7ICsraikge1xuICAgICAgdmFyIG1faSA9IG1baV07XG4gICAgICB2YXIgbV9qID0gbVtqXTtcbiAgICAgIG1baSArIGpdID0gW1xuICAgICAgICBtX2lbMF0gXiBtX2pbMF0sXG4gICAgICAgIG1faVsxXSBeIG1falsxXSxcbiAgICAgICAgbV9pWzJdIF4gbV9qWzJdLFxuICAgICAgICBtX2lbM10gXiBtX2pbM11cbiAgICAgIF07XG4gICAgfVxuICAgIGkgKj0gMjtcbiAgfVxuICBtWzBdID0gWzAsIDAsIDAsIDBdO1xuICAvKiBOb3RlOiBXZSBjb3VsZCBhdm9pZCBzdG9yaW5nIHRoZXNlIGJ5IGRvaW5nIGNvbXBvc2l0aW9uIGR1cmluZyBtdWx0aXBseVxuICBjYWxjdWxhdGUgdG9wIGhhbGYgdXNpbmcgY29tcG9zaXRpb24gYnkgc3BlZWQgaXMgcHJlZmVycmVkLiAqL1xuICBmb3IoaSA9IGhhbGYgKyAxOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgdmFyIGMgPSBtW2kgXiBoYWxmXTtcbiAgICBtW2ldID0gW21pZFswXSBeIGNbMF0sIG1pZFsxXSBeIGNbMV0sIG1pZFsyXSBeIGNbMl0sIG1pZFszXSBeIGNbM11dO1xuICB9XG4gIHJldHVybiBtO1xufTtcblxuLyoqIFV0aWxpdHkgZnVuY3Rpb25zICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUlWKGl2LCBibG9ja1NpemUpIHtcbiAgaWYodHlwZW9mIGl2ID09PSAnc3RyaW5nJykge1xuICAgIC8vIGNvbnZlcnQgaXYgc3RyaW5nIGludG8gYnl0ZSBidWZmZXJcbiAgICBpdiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGl2KTtcbiAgfVxuXG4gIGlmKGZvcmdlLnV0aWwuaXNBcnJheShpdikgJiYgaXYubGVuZ3RoID4gNCkge1xuICAgIC8vIGNvbnZlcnQgaXYgYnl0ZSBhcnJheSBpbnRvIGJ5dGUgYnVmZmVyXG4gICAgdmFyIHRtcCA9IGl2O1xuICAgIGl2ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgKytpKSB7XG4gICAgICBpdi5wdXRCeXRlKHRtcFtpXSk7XG4gICAgfVxuICB9XG5cbiAgaWYoaXYubGVuZ3RoKCkgPCBibG9ja1NpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnSW52YWxpZCBJViBsZW5ndGg7IGdvdCAnICsgaXYubGVuZ3RoKCkgK1xuICAgICAgJyBieXRlcyBhbmQgZXhwZWN0ZWQgJyArIGJsb2NrU2l6ZSArICcgYnl0ZXMuJyk7XG4gIH1cblxuICBpZighZm9yZ2UudXRpbC5pc0FycmF5KGl2KSkge1xuICAgIC8vIGNvbnZlcnQgaXYgYnl0ZSBidWZmZXIgaW50byAzMi1iaXQgaW50ZWdlciBhcnJheVxuICAgIHZhciBpbnRzID0gW107XG4gICAgdmFyIGJsb2NrcyA9IGJsb2NrU2l6ZSAvIDQ7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJsb2NrczsgKytpKSB7XG4gICAgICBpbnRzLnB1c2goaXYuZ2V0SW50MzIoKSk7XG4gICAgfVxuICAgIGl2ID0gaW50cztcbiAgfVxuXG4gIHJldHVybiBpdjtcbn1cblxuZnVuY3Rpb24gaW5jMzIoYmxvY2spIHtcbiAgLy8gaW5jcmVtZW50IGxhc3QgMzIgYml0cyBvZiBibG9jayBvbmx5XG4gIGJsb2NrW2Jsb2NrLmxlbmd0aCAtIDFdID0gKGJsb2NrW2Jsb2NrLmxlbmd0aCAtIDFdICsgMSkgJiAweEZGRkZGRkZGO1xufVxuXG5mdW5jdGlvbiBmcm9tNjRUbzMyKG51bSkge1xuICAvLyBjb252ZXJ0IDY0LWJpdCBudW1iZXIgdG8gdHdvIEJFIEludDMyc1xuICByZXR1cm4gWyhudW0gLyAweDEwMDAwMDAwMCkgfCAwLCBudW0gJiAweEZGRkZGRkZGXTtcbn1cbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJjaXBoZXIiLCJtb2RlcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJlY2IiLCJvcHRpb25zIiwibmFtZSIsImJsb2NrU2l6ZSIsIl9pbnRzIiwiX2luQmxvY2siLCJBcnJheSIsIl9vdXRCbG9jayIsInByb3RvdHlwZSIsInN0YXJ0IiwiZW5jcnlwdCIsImlucHV0Iiwib3V0cHV0IiwiZmluaXNoIiwibGVuZ3RoIiwiaSIsImdldEludDMyIiwicHV0SW50MzIiLCJkZWNyeXB0IiwicGFkIiwicGFkZGluZyIsImZpbGxXaXRoQnl0ZSIsInVucGFkIiwib3ZlcmZsb3ciLCJsZW4iLCJjb3VudCIsImF0IiwidHJ1bmNhdGUiLCJjYmMiLCJpdiIsIl9wcmV2IiwiRXJyb3IiLCJfaXYiLCJzbGljZSIsInRyYW5zZm9ybUlWIiwiY2ZiIiwiX3BhcnRpYWxCbG9jayIsIl9wYXJ0aWFsT3V0cHV0IiwidXRpbCIsImNyZWF0ZUJ1ZmZlciIsIl9wYXJ0aWFsQnl0ZXMiLCJpbnB1dExlbmd0aCIsInBhcnRpYWxCeXRlcyIsImNsZWFyIiwicmVhZCIsImdldEJ5dGVzIiwicHV0Qnl0ZXMiLCJvZmIiLCJjdHIiLCJpbmMzMiIsImdjbSIsIl9SIiwiX2NpcGhlckxlbmd0aCIsImFkZGl0aW9uYWxEYXRhIiwiX3RhZ0xlbmd0aCIsInRhZ0xlbmd0aCIsIl90YWciLCJ0YWciLCJfaGFzaEJsb2NrIiwiX2hhc2hTdWJrZXkiLCJjb21wb25lbnRCaXRzIiwiX20iLCJnZW5lcmF0ZUhhc2hUYWJsZSIsIml2TGVuZ3RoIiwiX2owIiwiZ2hhc2giLCJjb25jYXQiLCJmcm9tNjRUbzMyIiwiX2FEYXRhTGVuZ3RoIiwiX3MiLCJhZnRlckZpbmlzaCIsInJ2YWwiLCJsZW5ndGhzIiwiYnl0ZXMiLCJtdWx0aXBseSIsIngiLCJ5Iiwiel9pIiwidl9pIiwieF9pIiwicG93Iiwib3V0IiwibHNiIiwidGFibGVNdWx0aXBseSIsInoiLCJpZHgiLCJhaCIsImgiLCJiaXRzIiwibXVsdGlwbGllciIsInBlckludCIsInNpemUiLCJtIiwidG1wIiwic2hmdCIsImdlbmVyYXRlU3ViSGFzaFRhYmxlIiwibWlkIiwiaGFsZiIsImoiLCJtX2kiLCJtX2oiLCJjIiwiaXNBcnJheSIsInB1dEJ5dGUiLCJpbnRzIiwiYmxvY2tzIiwicHVzaCIsImJsb2NrIiwibnVtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/cipherModes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/des.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/des.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * DES (Data Encryption Standard) implementation.\n *\n * This implementation supports DES as well as 3DES-EDE in ECB and CBC mode.\n * It is based on the BSD-licensed implementation by Paul Tero:\n *\n * Paul Tero, July 2001\n * http://www.tero.co.uk/des/\n *\n * Optimised for performance with large blocks by\n * Michael Hayworth, November 2001\n * http://www.netdealing.com\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * @author Stefan Siegl\n * @author Dave Longley\n *\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n * Copyright (c) 2012-2014 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./cipher */ \"(rsc)/./node_modules/node-forge/lib/cipher.js\");\n__webpack_require__(/*! ./cipherModes */ \"(rsc)/./node_modules/node-forge/lib/cipherModes.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\n/* DES API */ module.exports = forge.des = forge.des || {};\n/**\n * Deprecated. Instead, use:\n *\n * var cipher = forge.cipher.createCipher('DES-<mode>', key);\n * cipher.start({iv: iv});\n *\n * Creates an DES cipher object to encrypt data using the given symmetric key.\n * The output will be stored in the 'output' member of the returned cipher.\n *\n * The key and iv may be given as binary-encoded strings of bytes or\n * byte buffers.\n *\n * @param key the symmetric key to use (64 or 192 bits).\n * @param iv the initialization vector to use.\n * @param output the buffer to write to, null to create one.\n * @param mode the cipher mode to use (default: 'CBC' if IV is\n *          given, 'ECB' if null).\n *\n * @return the cipher.\n */ forge.des.startEncrypting = function(key, iv, output, mode) {\n    var cipher = _createCipher({\n        key: key,\n        output: output,\n        decrypt: false,\n        mode: mode || (iv === null ? \"ECB\" : \"CBC\")\n    });\n    cipher.start(iv);\n    return cipher;\n};\n/**\n * Deprecated. Instead, use:\n *\n * var cipher = forge.cipher.createCipher('DES-<mode>', key);\n *\n * Creates an DES cipher object to encrypt data using the given symmetric key.\n *\n * The key may be given as a binary-encoded string of bytes or a byte buffer.\n *\n * @param key the symmetric key to use (64 or 192 bits).\n * @param mode the cipher mode to use (default: 'CBC').\n *\n * @return the cipher.\n */ forge.des.createEncryptionCipher = function(key, mode) {\n    return _createCipher({\n        key: key,\n        output: null,\n        decrypt: false,\n        mode: mode\n    });\n};\n/**\n * Deprecated. Instead, use:\n *\n * var decipher = forge.cipher.createDecipher('DES-<mode>', key);\n * decipher.start({iv: iv});\n *\n * Creates an DES cipher object to decrypt data using the given symmetric key.\n * The output will be stored in the 'output' member of the returned cipher.\n *\n * The key and iv may be given as binary-encoded strings of bytes or\n * byte buffers.\n *\n * @param key the symmetric key to use (64 or 192 bits).\n * @param iv the initialization vector to use.\n * @param output the buffer to write to, null to create one.\n * @param mode the cipher mode to use (default: 'CBC' if IV is\n *          given, 'ECB' if null).\n *\n * @return the cipher.\n */ forge.des.startDecrypting = function(key, iv, output, mode) {\n    var cipher = _createCipher({\n        key: key,\n        output: output,\n        decrypt: true,\n        mode: mode || (iv === null ? \"ECB\" : \"CBC\")\n    });\n    cipher.start(iv);\n    return cipher;\n};\n/**\n * Deprecated. Instead, use:\n *\n * var decipher = forge.cipher.createDecipher('DES-<mode>', key);\n *\n * Creates an DES cipher object to decrypt data using the given symmetric key.\n *\n * The key may be given as a binary-encoded string of bytes or a byte buffer.\n *\n * @param key the symmetric key to use (64 or 192 bits).\n * @param mode the cipher mode to use (default: 'CBC').\n *\n * @return the cipher.\n */ forge.des.createDecryptionCipher = function(key, mode) {\n    return _createCipher({\n        key: key,\n        output: null,\n        decrypt: true,\n        mode: mode\n    });\n};\n/**\n * Creates a new DES cipher algorithm object.\n *\n * @param name the name of the algorithm.\n * @param mode the mode factory function.\n *\n * @return the DES algorithm object.\n */ forge.des.Algorithm = function(name, mode) {\n    var self = this;\n    self.name = name;\n    self.mode = new mode({\n        blockSize: 8,\n        cipher: {\n            encrypt: function(inBlock, outBlock) {\n                return _updateBlock(self._keys, inBlock, outBlock, false);\n            },\n            decrypt: function(inBlock, outBlock) {\n                return _updateBlock(self._keys, inBlock, outBlock, true);\n            }\n        }\n    });\n    self._init = false;\n};\n/**\n * Initializes this DES algorithm by expanding its key.\n *\n * @param options the options to use.\n *          key the key to use with this algorithm.\n *          decrypt true if the algorithm should be initialized for decryption,\n *            false for encryption.\n */ forge.des.Algorithm.prototype.initialize = function(options) {\n    if (this._init) {\n        return;\n    }\n    var key = forge.util.createBuffer(options.key);\n    if (this.name.indexOf(\"3DES\") === 0) {\n        if (key.length() !== 24) {\n            throw new Error(\"Invalid Triple-DES key size: \" + key.length() * 8);\n        }\n    }\n    // do key expansion to 16 or 48 subkeys (single or triple DES)\n    this._keys = _createKeys(key);\n    this._init = true;\n};\n/** Register DES algorithms **/ registerAlgorithm(\"DES-ECB\", forge.cipher.modes.ecb);\nregisterAlgorithm(\"DES-CBC\", forge.cipher.modes.cbc);\nregisterAlgorithm(\"DES-CFB\", forge.cipher.modes.cfb);\nregisterAlgorithm(\"DES-OFB\", forge.cipher.modes.ofb);\nregisterAlgorithm(\"DES-CTR\", forge.cipher.modes.ctr);\nregisterAlgorithm(\"3DES-ECB\", forge.cipher.modes.ecb);\nregisterAlgorithm(\"3DES-CBC\", forge.cipher.modes.cbc);\nregisterAlgorithm(\"3DES-CFB\", forge.cipher.modes.cfb);\nregisterAlgorithm(\"3DES-OFB\", forge.cipher.modes.ofb);\nregisterAlgorithm(\"3DES-CTR\", forge.cipher.modes.ctr);\nfunction registerAlgorithm(name, mode) {\n    var factory = function() {\n        return new forge.des.Algorithm(name, mode);\n    };\n    forge.cipher.registerAlgorithm(name, factory);\n}\n/** DES implementation **/ var spfunction1 = [\n    0x1010400,\n    0,\n    0x10000,\n    0x1010404,\n    0x1010004,\n    0x10404,\n    0x4,\n    0x10000,\n    0x400,\n    0x1010400,\n    0x1010404,\n    0x400,\n    0x1000404,\n    0x1010004,\n    0x1000000,\n    0x4,\n    0x404,\n    0x1000400,\n    0x1000400,\n    0x10400,\n    0x10400,\n    0x1010000,\n    0x1010000,\n    0x1000404,\n    0x10004,\n    0x1000004,\n    0x1000004,\n    0x10004,\n    0,\n    0x404,\n    0x10404,\n    0x1000000,\n    0x10000,\n    0x1010404,\n    0x4,\n    0x1010000,\n    0x1010400,\n    0x1000000,\n    0x1000000,\n    0x400,\n    0x1010004,\n    0x10000,\n    0x10400,\n    0x1000004,\n    0x400,\n    0x4,\n    0x1000404,\n    0x10404,\n    0x1010404,\n    0x10004,\n    0x1010000,\n    0x1000404,\n    0x1000004,\n    0x404,\n    0x10404,\n    0x1010400,\n    0x404,\n    0x1000400,\n    0x1000400,\n    0,\n    0x10004,\n    0x10400,\n    0,\n    0x1010004\n];\nvar spfunction2 = [\n    -0x7fef7fe0,\n    -0x7fff8000,\n    0x8000,\n    0x108020,\n    0x100000,\n    0x20,\n    -0x7fefffe0,\n    -0x7fff7fe0,\n    -0x7fffffe0,\n    -0x7fef7fe0,\n    -0x7fef8000,\n    -0x80000000,\n    -0x7fff8000,\n    0x100000,\n    0x20,\n    -0x7fefffe0,\n    0x108000,\n    0x100020,\n    -0x7fff7fe0,\n    0,\n    -0x80000000,\n    0x8000,\n    0x108020,\n    -0x7ff00000,\n    0x100020,\n    -0x7fffffe0,\n    0,\n    0x108000,\n    0x8020,\n    -0x7fef8000,\n    -0x7ff00000,\n    0x8020,\n    0,\n    0x108020,\n    -0x7fefffe0,\n    0x100000,\n    -0x7fff7fe0,\n    -0x7ff00000,\n    -0x7fef8000,\n    0x8000,\n    -0x7ff00000,\n    -0x7fff8000,\n    0x20,\n    -0x7fef7fe0,\n    0x108020,\n    0x20,\n    0x8000,\n    -0x80000000,\n    0x8020,\n    -0x7fef8000,\n    0x100000,\n    -0x7fffffe0,\n    0x100020,\n    -0x7fff7fe0,\n    -0x7fffffe0,\n    0x100020,\n    0x108000,\n    0,\n    -0x7fff8000,\n    0x8020,\n    -0x80000000,\n    -0x7fefffe0,\n    -0x7fef7fe0,\n    0x108000\n];\nvar spfunction3 = [\n    0x208,\n    0x8020200,\n    0,\n    0x8020008,\n    0x8000200,\n    0,\n    0x20208,\n    0x8000200,\n    0x20008,\n    0x8000008,\n    0x8000008,\n    0x20000,\n    0x8020208,\n    0x20008,\n    0x8020000,\n    0x208,\n    0x8000000,\n    0x8,\n    0x8020200,\n    0x200,\n    0x20200,\n    0x8020000,\n    0x8020008,\n    0x20208,\n    0x8000208,\n    0x20200,\n    0x20000,\n    0x8000208,\n    0x8,\n    0x8020208,\n    0x200,\n    0x8000000,\n    0x8020200,\n    0x8000000,\n    0x20008,\n    0x208,\n    0x20000,\n    0x8020200,\n    0x8000200,\n    0,\n    0x200,\n    0x20008,\n    0x8020208,\n    0x8000200,\n    0x8000008,\n    0x200,\n    0,\n    0x8020008,\n    0x8000208,\n    0x20000,\n    0x8000000,\n    0x8020208,\n    0x8,\n    0x20208,\n    0x20200,\n    0x8000008,\n    0x8020000,\n    0x8000208,\n    0x208,\n    0x8020000,\n    0x20208,\n    0x8,\n    0x8020008,\n    0x20200\n];\nvar spfunction4 = [\n    0x802001,\n    0x2081,\n    0x2081,\n    0x80,\n    0x802080,\n    0x800081,\n    0x800001,\n    0x2001,\n    0,\n    0x802000,\n    0x802000,\n    0x802081,\n    0x81,\n    0,\n    0x800080,\n    0x800001,\n    0x1,\n    0x2000,\n    0x800000,\n    0x802001,\n    0x80,\n    0x800000,\n    0x2001,\n    0x2080,\n    0x800081,\n    0x1,\n    0x2080,\n    0x800080,\n    0x2000,\n    0x802080,\n    0x802081,\n    0x81,\n    0x800080,\n    0x800001,\n    0x802000,\n    0x802081,\n    0x81,\n    0,\n    0,\n    0x802000,\n    0x2080,\n    0x800080,\n    0x800081,\n    0x1,\n    0x802001,\n    0x2081,\n    0x2081,\n    0x80,\n    0x802081,\n    0x81,\n    0x1,\n    0x2000,\n    0x800001,\n    0x2001,\n    0x802080,\n    0x800081,\n    0x2001,\n    0x2080,\n    0x800000,\n    0x802001,\n    0x80,\n    0x800000,\n    0x2000,\n    0x802080\n];\nvar spfunction5 = [\n    0x100,\n    0x2080100,\n    0x2080000,\n    0x42000100,\n    0x80000,\n    0x100,\n    0x40000000,\n    0x2080000,\n    0x40080100,\n    0x80000,\n    0x2000100,\n    0x40080100,\n    0x42000100,\n    0x42080000,\n    0x80100,\n    0x40000000,\n    0x2000000,\n    0x40080000,\n    0x40080000,\n    0,\n    0x40000100,\n    0x42080100,\n    0x42080100,\n    0x2000100,\n    0x42080000,\n    0x40000100,\n    0,\n    0x42000000,\n    0x2080100,\n    0x2000000,\n    0x42000000,\n    0x80100,\n    0x80000,\n    0x42000100,\n    0x100,\n    0x2000000,\n    0x40000000,\n    0x2080000,\n    0x42000100,\n    0x40080100,\n    0x2000100,\n    0x40000000,\n    0x42080000,\n    0x2080100,\n    0x40080100,\n    0x100,\n    0x2000000,\n    0x42080000,\n    0x42080100,\n    0x80100,\n    0x42000000,\n    0x42080100,\n    0x2080000,\n    0,\n    0x40080000,\n    0x42000000,\n    0x80100,\n    0x2000100,\n    0x40000100,\n    0x80000,\n    0,\n    0x40080000,\n    0x2080100,\n    0x40000100\n];\nvar spfunction6 = [\n    0x20000010,\n    0x20400000,\n    0x4000,\n    0x20404010,\n    0x20400000,\n    0x10,\n    0x20404010,\n    0x400000,\n    0x20004000,\n    0x404010,\n    0x400000,\n    0x20000010,\n    0x400010,\n    0x20004000,\n    0x20000000,\n    0x4010,\n    0,\n    0x400010,\n    0x20004010,\n    0x4000,\n    0x404000,\n    0x20004010,\n    0x10,\n    0x20400010,\n    0x20400010,\n    0,\n    0x404010,\n    0x20404000,\n    0x4010,\n    0x404000,\n    0x20404000,\n    0x20000000,\n    0x20004000,\n    0x10,\n    0x20400010,\n    0x404000,\n    0x20404010,\n    0x400000,\n    0x4010,\n    0x20000010,\n    0x400000,\n    0x20004000,\n    0x20000000,\n    0x4010,\n    0x20000010,\n    0x20404010,\n    0x404000,\n    0x20400000,\n    0x404010,\n    0x20404000,\n    0,\n    0x20400010,\n    0x10,\n    0x4000,\n    0x20400000,\n    0x404010,\n    0x4000,\n    0x400010,\n    0x20004010,\n    0,\n    0x20404000,\n    0x20000000,\n    0x400010,\n    0x20004010\n];\nvar spfunction7 = [\n    0x200000,\n    0x4200002,\n    0x4000802,\n    0,\n    0x800,\n    0x4000802,\n    0x200802,\n    0x4200800,\n    0x4200802,\n    0x200000,\n    0,\n    0x4000002,\n    0x2,\n    0x4000000,\n    0x4200002,\n    0x802,\n    0x4000800,\n    0x200802,\n    0x200002,\n    0x4000800,\n    0x4000002,\n    0x4200000,\n    0x4200800,\n    0x200002,\n    0x4200000,\n    0x800,\n    0x802,\n    0x4200802,\n    0x200800,\n    0x2,\n    0x4000000,\n    0x200800,\n    0x4000000,\n    0x200800,\n    0x200000,\n    0x4000802,\n    0x4000802,\n    0x4200002,\n    0x4200002,\n    0x2,\n    0x200002,\n    0x4000000,\n    0x4000800,\n    0x200000,\n    0x4200800,\n    0x802,\n    0x200802,\n    0x4200800,\n    0x802,\n    0x4000002,\n    0x4200802,\n    0x4200000,\n    0x200800,\n    0,\n    0x2,\n    0x4200802,\n    0,\n    0x200802,\n    0x4200000,\n    0x800,\n    0x4000002,\n    0x4000800,\n    0x800,\n    0x200002\n];\nvar spfunction8 = [\n    0x10001040,\n    0x1000,\n    0x40000,\n    0x10041040,\n    0x10000000,\n    0x10001040,\n    0x40,\n    0x10000000,\n    0x40040,\n    0x10040000,\n    0x10041040,\n    0x41000,\n    0x10041000,\n    0x41040,\n    0x1000,\n    0x40,\n    0x10040000,\n    0x10000040,\n    0x10001000,\n    0x1040,\n    0x41000,\n    0x40040,\n    0x10040040,\n    0x10041000,\n    0x1040,\n    0,\n    0,\n    0x10040040,\n    0x10000040,\n    0x10001000,\n    0x41040,\n    0x40000,\n    0x41040,\n    0x40000,\n    0x10041000,\n    0x1000,\n    0x40,\n    0x10040040,\n    0x1000,\n    0x41040,\n    0x10001000,\n    0x40,\n    0x10000040,\n    0x10040000,\n    0x10040040,\n    0x10000000,\n    0x40000,\n    0x10001040,\n    0,\n    0x10041040,\n    0x40040,\n    0x10000040,\n    0x10040000,\n    0x10001000,\n    0x10001040,\n    0,\n    0x10041040,\n    0x41000,\n    0x41000,\n    0x1040,\n    0x1040,\n    0x40040,\n    0x10000000,\n    0x10041000\n];\n/**\n * Create necessary sub keys.\n *\n * @param key the 64-bit or 192-bit key.\n *\n * @return the expanded keys.\n */ function _createKeys(key) {\n    var pc2bytes0 = [\n        0,\n        0x4,\n        0x20000000,\n        0x20000004,\n        0x10000,\n        0x10004,\n        0x20010000,\n        0x20010004,\n        0x200,\n        0x204,\n        0x20000200,\n        0x20000204,\n        0x10200,\n        0x10204,\n        0x20010200,\n        0x20010204\n    ], pc2bytes1 = [\n        0,\n        0x1,\n        0x100000,\n        0x100001,\n        0x4000000,\n        0x4000001,\n        0x4100000,\n        0x4100001,\n        0x100,\n        0x101,\n        0x100100,\n        0x100101,\n        0x4000100,\n        0x4000101,\n        0x4100100,\n        0x4100101\n    ], pc2bytes2 = [\n        0,\n        0x8,\n        0x800,\n        0x808,\n        0x1000000,\n        0x1000008,\n        0x1000800,\n        0x1000808,\n        0,\n        0x8,\n        0x800,\n        0x808,\n        0x1000000,\n        0x1000008,\n        0x1000800,\n        0x1000808\n    ], pc2bytes3 = [\n        0,\n        0x200000,\n        0x8000000,\n        0x8200000,\n        0x2000,\n        0x202000,\n        0x8002000,\n        0x8202000,\n        0x20000,\n        0x220000,\n        0x8020000,\n        0x8220000,\n        0x22000,\n        0x222000,\n        0x8022000,\n        0x8222000\n    ], pc2bytes4 = [\n        0,\n        0x40000,\n        0x10,\n        0x40010,\n        0,\n        0x40000,\n        0x10,\n        0x40010,\n        0x1000,\n        0x41000,\n        0x1010,\n        0x41010,\n        0x1000,\n        0x41000,\n        0x1010,\n        0x41010\n    ], pc2bytes5 = [\n        0,\n        0x400,\n        0x20,\n        0x420,\n        0,\n        0x400,\n        0x20,\n        0x420,\n        0x2000000,\n        0x2000400,\n        0x2000020,\n        0x2000420,\n        0x2000000,\n        0x2000400,\n        0x2000020,\n        0x2000420\n    ], pc2bytes6 = [\n        0,\n        0x10000000,\n        0x80000,\n        0x10080000,\n        0x2,\n        0x10000002,\n        0x80002,\n        0x10080002,\n        0,\n        0x10000000,\n        0x80000,\n        0x10080000,\n        0x2,\n        0x10000002,\n        0x80002,\n        0x10080002\n    ], pc2bytes7 = [\n        0,\n        0x10000,\n        0x800,\n        0x10800,\n        0x20000000,\n        0x20010000,\n        0x20000800,\n        0x20010800,\n        0x20000,\n        0x30000,\n        0x20800,\n        0x30800,\n        0x20020000,\n        0x20030000,\n        0x20020800,\n        0x20030800\n    ], pc2bytes8 = [\n        0,\n        0x40000,\n        0,\n        0x40000,\n        0x2,\n        0x40002,\n        0x2,\n        0x40002,\n        0x2000000,\n        0x2040000,\n        0x2000000,\n        0x2040000,\n        0x2000002,\n        0x2040002,\n        0x2000002,\n        0x2040002\n    ], pc2bytes9 = [\n        0,\n        0x10000000,\n        0x8,\n        0x10000008,\n        0,\n        0x10000000,\n        0x8,\n        0x10000008,\n        0x400,\n        0x10000400,\n        0x408,\n        0x10000408,\n        0x400,\n        0x10000400,\n        0x408,\n        0x10000408\n    ], pc2bytes10 = [\n        0,\n        0x20,\n        0,\n        0x20,\n        0x100000,\n        0x100020,\n        0x100000,\n        0x100020,\n        0x2000,\n        0x2020,\n        0x2000,\n        0x2020,\n        0x102000,\n        0x102020,\n        0x102000,\n        0x102020\n    ], pc2bytes11 = [\n        0,\n        0x1000000,\n        0x200,\n        0x1000200,\n        0x200000,\n        0x1200000,\n        0x200200,\n        0x1200200,\n        0x4000000,\n        0x5000000,\n        0x4000200,\n        0x5000200,\n        0x4200000,\n        0x5200000,\n        0x4200200,\n        0x5200200\n    ], pc2bytes12 = [\n        0,\n        0x1000,\n        0x8000000,\n        0x8001000,\n        0x80000,\n        0x81000,\n        0x8080000,\n        0x8081000,\n        0x10,\n        0x1010,\n        0x8000010,\n        0x8001010,\n        0x80010,\n        0x81010,\n        0x8080010,\n        0x8081010\n    ], pc2bytes13 = [\n        0,\n        0x4,\n        0x100,\n        0x104,\n        0,\n        0x4,\n        0x100,\n        0x104,\n        0x1,\n        0x5,\n        0x101,\n        0x105,\n        0x1,\n        0x5,\n        0x101,\n        0x105\n    ];\n    // how many iterations (1 for des, 3 for triple des)\n    // changed by Paul 16/6/2007 to use Triple DES for 9+ byte keys\n    var iterations = key.length() > 8 ? 3 : 1;\n    // stores the return keys\n    var keys = [];\n    // now define the left shifts which need to be done\n    var shifts = [\n        0,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        0\n    ];\n    var n = 0, tmp;\n    for(var j = 0; j < iterations; j++){\n        var left = key.getInt32();\n        var right = key.getInt32();\n        tmp = (left >>> 4 ^ right) & 0x0f0f0f0f;\n        right ^= tmp;\n        left ^= tmp << 4;\n        tmp = (right >>> -16 ^ left) & 0x0000ffff;\n        left ^= tmp;\n        right ^= tmp << -16;\n        tmp = (left >>> 2 ^ right) & 0x33333333;\n        right ^= tmp;\n        left ^= tmp << 2;\n        tmp = (right >>> -16 ^ left) & 0x0000ffff;\n        left ^= tmp;\n        right ^= tmp << -16;\n        tmp = (left >>> 1 ^ right) & 0x55555555;\n        right ^= tmp;\n        left ^= tmp << 1;\n        tmp = (right >>> 8 ^ left) & 0x00ff00ff;\n        left ^= tmp;\n        right ^= tmp << 8;\n        tmp = (left >>> 1 ^ right) & 0x55555555;\n        right ^= tmp;\n        left ^= tmp << 1;\n        // right needs to be shifted and OR'd with last four bits of left\n        tmp = left << 8 | right >>> 20 & 0x000000f0;\n        // left needs to be put upside down\n        left = right << 24 | right << 8 & 0xff0000 | right >>> 8 & 0xff00 | right >>> 24 & 0xf0;\n        right = tmp;\n        // now go through and perform these shifts on the left and right keys\n        for(var i = 0; i < shifts.length; ++i){\n            //shift the keys either one or two bits to the left\n            if (shifts[i]) {\n                left = left << 2 | left >>> 26;\n                right = right << 2 | right >>> 26;\n            } else {\n                left = left << 1 | left >>> 27;\n                right = right << 1 | right >>> 27;\n            }\n            left &= -0xf;\n            right &= -0xf;\n            // now apply PC-2, in such a way that E is easier when encrypting or\n            // decrypting this conversion will look like PC-2 except only the last 6\n            // bits of each byte are used rather than 48 consecutive bits and the\n            // order of lines will be according to how the S selection functions will\n            // be applied: S2, S4, S6, S8, S1, S3, S5, S7\n            var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 0xf] | pc2bytes2[left >>> 20 & 0xf] | pc2bytes3[left >>> 16 & 0xf] | pc2bytes4[left >>> 12 & 0xf] | pc2bytes5[left >>> 8 & 0xf] | pc2bytes6[left >>> 4 & 0xf];\n            var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 0xf] | pc2bytes9[right >>> 20 & 0xf] | pc2bytes10[right >>> 16 & 0xf] | pc2bytes11[right >>> 12 & 0xf] | pc2bytes12[right >>> 8 & 0xf] | pc2bytes13[right >>> 4 & 0xf];\n            tmp = (righttmp >>> 16 ^ lefttmp) & 0x0000ffff;\n            keys[n++] = lefttmp ^ tmp;\n            keys[n++] = righttmp ^ tmp << 16;\n        }\n    }\n    return keys;\n}\n/**\n * Updates a single block (1 byte) using DES. The update will either\n * encrypt or decrypt the block.\n *\n * @param keys the expanded keys.\n * @param input the input block (an array of 32-bit words).\n * @param output the updated output block.\n * @param decrypt true to decrypt the block, false to encrypt it.\n */ function _updateBlock(keys, input, output, decrypt) {\n    // set up loops for single or triple DES\n    var iterations = keys.length === 32 ? 3 : 9;\n    var looping;\n    if (iterations === 3) {\n        looping = decrypt ? [\n            30,\n            -2,\n            -2\n        ] : [\n            0,\n            32,\n            2\n        ];\n    } else {\n        looping = decrypt ? [\n            94,\n            62,\n            -2,\n            32,\n            64,\n            2,\n            30,\n            -2,\n            -2\n        ] : [\n            0,\n            32,\n            2,\n            62,\n            30,\n            -2,\n            64,\n            96,\n            2\n        ];\n    }\n    var tmp;\n    var left = input[0];\n    var right = input[1];\n    // first each 64 bit chunk of the message must be permuted according to IP\n    tmp = (left >>> 4 ^ right) & 0x0f0f0f0f;\n    right ^= tmp;\n    left ^= tmp << 4;\n    tmp = (left >>> 16 ^ right) & 0x0000ffff;\n    right ^= tmp;\n    left ^= tmp << 16;\n    tmp = (right >>> 2 ^ left) & 0x33333333;\n    left ^= tmp;\n    right ^= tmp << 2;\n    tmp = (right >>> 8 ^ left) & 0x00ff00ff;\n    left ^= tmp;\n    right ^= tmp << 8;\n    tmp = (left >>> 1 ^ right) & 0x55555555;\n    right ^= tmp;\n    left ^= tmp << 1;\n    // rotate left 1 bit\n    left = left << 1 | left >>> 31;\n    right = right << 1 | right >>> 31;\n    for(var j = 0; j < iterations; j += 3){\n        var endloop = looping[j + 1];\n        var loopinc = looping[j + 2];\n        // now go through and perform the encryption or decryption\n        for(var i = looping[j]; i != endloop; i += loopinc){\n            var right1 = right ^ keys[i];\n            var right2 = (right >>> 4 | right << 28) ^ keys[i + 1];\n            // passing these bytes through the S selection functions\n            tmp = left;\n            left = right;\n            right = tmp ^ (spfunction2[right1 >>> 24 & 0x3f] | spfunction4[right1 >>> 16 & 0x3f] | spfunction6[right1 >>> 8 & 0x3f] | spfunction8[right1 & 0x3f] | spfunction1[right2 >>> 24 & 0x3f] | spfunction3[right2 >>> 16 & 0x3f] | spfunction5[right2 >>> 8 & 0x3f] | spfunction7[right2 & 0x3f]);\n        }\n        // unreverse left and right\n        tmp = left;\n        left = right;\n        right = tmp;\n    }\n    // rotate right 1 bit\n    left = left >>> 1 | left << 31;\n    right = right >>> 1 | right << 31;\n    // now perform IP-1, which is IP in the opposite direction\n    tmp = (left >>> 1 ^ right) & 0x55555555;\n    right ^= tmp;\n    left ^= tmp << 1;\n    tmp = (right >>> 8 ^ left) & 0x00ff00ff;\n    left ^= tmp;\n    right ^= tmp << 8;\n    tmp = (right >>> 2 ^ left) & 0x33333333;\n    left ^= tmp;\n    right ^= tmp << 2;\n    tmp = (left >>> 16 ^ right) & 0x0000ffff;\n    right ^= tmp;\n    left ^= tmp << 16;\n    tmp = (left >>> 4 ^ right) & 0x0f0f0f0f;\n    right ^= tmp;\n    left ^= tmp << 4;\n    output[0] = left;\n    output[1] = right;\n}\n/**\n * Deprecated. Instead, use:\n *\n * forge.cipher.createCipher('DES-<mode>', key);\n * forge.cipher.createDecipher('DES-<mode>', key);\n *\n * Creates a deprecated DES cipher object. This object's mode will default to\n * CBC (cipher-block-chaining).\n *\n * The key may be given as a binary-encoded string of bytes or a byte buffer.\n *\n * @param options the options to use.\n *          key the symmetric key to use (64 or 192 bits).\n *          output the buffer to write to.\n *          decrypt true for decryption, false for encryption.\n *          mode the cipher mode to use (default: 'CBC').\n *\n * @return the cipher.\n */ function _createCipher(options) {\n    options = options || {};\n    var mode = (options.mode || \"CBC\").toUpperCase();\n    var algorithm = \"DES-\" + mode;\n    var cipher;\n    if (options.decrypt) {\n        cipher = forge.cipher.createDecipher(algorithm, options.key);\n    } else {\n        cipher = forge.cipher.createCipher(algorithm, options.key);\n    }\n    // backwards compatible start API\n    var start = cipher.start;\n    cipher.start = function(iv, options) {\n        // backwards compatibility: support second arg as output buffer\n        var output = null;\n        if (options instanceof forge.util.ByteBuffer) {\n            output = options;\n            options = {};\n        }\n        options = options || {};\n        options.output = output;\n        options.iv = iv;\n        start.call(cipher, options);\n    };\n    return cipher;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvZGVzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E4QkM7QUFDRCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixXQUFXLEdBQ1hDLE9BQU9DLE9BQU8sR0FBR0gsTUFBTUksR0FBRyxHQUFHSixNQUFNSSxHQUFHLElBQUksQ0FBQztBQUUzQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNESixNQUFNSSxHQUFHLENBQUNDLGVBQWUsR0FBRyxTQUFTQyxHQUFHLEVBQUVDLEVBQUUsRUFBRUMsTUFBTSxFQUFFQyxJQUFJO0lBQ3hELElBQUlDLFNBQVNDLGNBQWM7UUFDekJMLEtBQUtBO1FBQ0xFLFFBQVFBO1FBQ1JJLFNBQVM7UUFDVEgsTUFBTUEsUUFBU0YsQ0FBQUEsT0FBTyxPQUFPLFFBQVEsS0FBSTtJQUMzQztJQUNBRyxPQUFPRyxLQUFLLENBQUNOO0lBQ2IsT0FBT0c7QUFDVDtBQUVBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDRFYsTUFBTUksR0FBRyxDQUFDVSxzQkFBc0IsR0FBRyxTQUFTUixHQUFHLEVBQUVHLElBQUk7SUFDbkQsT0FBT0UsY0FBYztRQUNuQkwsS0FBS0E7UUFDTEUsUUFBUTtRQUNSSSxTQUFTO1FBQ1RILE1BQU1BO0lBQ1I7QUFDRjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ0RULE1BQU1JLEdBQUcsQ0FBQ1csZUFBZSxHQUFHLFNBQVNULEdBQUcsRUFBRUMsRUFBRSxFQUFFQyxNQUFNLEVBQUVDLElBQUk7SUFDeEQsSUFBSUMsU0FBU0MsY0FBYztRQUN6QkwsS0FBS0E7UUFDTEUsUUFBUUE7UUFDUkksU0FBUztRQUNUSCxNQUFNQSxRQUFTRixDQUFBQSxPQUFPLE9BQU8sUUFBUSxLQUFJO0lBQzNDO0lBQ0FH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QVU7SUFBVTtJQUFVO0lBQUk7SUFBTTtJQUFVO0lBQVU7SUFBUTtJQUFRO0lBQVU7SUFBVTtJQUFVO0lBQVE7SUFBVTtJQUFVO0lBQVE7SUFBRTtJQUFNO0lBQVE7SUFBVTtJQUFRO0lBQVU7SUFBSTtJQUFVO0lBQVU7SUFBVTtJQUFVO0lBQU07SUFBVTtJQUFRO0lBQVE7SUFBVTtJQUFNO0lBQUk7SUFBVTtJQUFRO0lBQVU7SUFBUTtJQUFVO0lBQVU7SUFBVTtJQUFNO0lBQVE7SUFBVTtJQUFNO0lBQVU7SUFBVTtJQUFFO0lBQVE7SUFBUTtJQUFFO0NBQVU7QUFDM2hCLElBQUlDLGNBQWM7SUFBQyxDQUFDO0lBQVcsQ0FBQztJQUFXO0lBQU87SUFBUztJQUFTO0lBQUssQ0FBQztJQUFXLENBQUM7SUFBVyxDQUFDO0lBQVcsQ0FBQztJQUFXLENBQUM7SUFBVyxDQUFDO0lBQVcsQ0FBQztJQUFXO0lBQVM7SUFBSyxDQUFDO0lBQVc7SUFBUztJQUFTLENBQUM7SUFBVztJQUFFLENBQUM7SUFBVztJQUFPO0lBQVMsQ0FBQztJQUFXO0lBQVMsQ0FBQztJQUFXO0lBQUU7SUFBUztJQUFPLENBQUM7SUFBVyxDQUFDO0lBQVc7SUFBTztJQUFFO0lBQVMsQ0FBQztJQUFXO0lBQVMsQ0FBQztJQUFXLENBQUM7SUFBVyxDQUFDO0lBQVc7SUFBTyxDQUFDO0lBQVcsQ0FBQztJQUFXO0lBQUssQ0FBQztJQUFXO0lBQVM7SUFBSztJQUFPLENBQUM7SUFBVztJQUFPLENBQUM7SUFBVztJQUFTLENBQUM7SUFBVztJQUFTLENBQUM7SUFBVyxDQUFDO0lBQVc7SUFBUztJQUFTO0lBQUUsQ0FBQztJQUFXO0lBQU8sQ0FBQztJQUFXLENBQUM7SUFBVyxDQUFDO0lBQVc7Q0FBUztBQUN2bkIsSUFBSUMsY0FBYztJQUFDO0lBQU07SUFBVTtJQUFFO0lBQVU7SUFBVTtJQUFFO0lBQVE7SUFBVTtJQUFRO0lBQVU7SUFBVTtJQUFRO0lBQVU7SUFBUTtJQUFVO0lBQU07SUFBVTtJQUFJO0lBQVU7SUFBTTtJQUFRO0lBQVU7SUFBVTtJQUFRO0lBQVU7SUFBUTtJQUFRO0lBQVU7SUFBSTtJQUFVO0lBQU07SUFBVTtJQUFVO0lBQVU7SUFBUTtJQUFNO0lBQVE7SUFBVTtJQUFVO0lBQUU7SUFBTTtJQUFRO0lBQVU7SUFBVTtJQUFVO0lBQU07SUFBRTtJQUFVO0lBQVU7SUFBUTtJQUFVO0lBQVU7SUFBSTtJQUFRO0lBQVE7SUFBVTtJQUFVO0lBQVU7SUFBTTtJQUFVO0lBQVE7SUFBSTtJQUFVO0NBQVE7QUFDM2hCLElBQUlDLGNBQWM7SUFBQztJQUFTO0lBQU87SUFBTztJQUFLO0lBQVM7SUFBUztJQUFTO0lBQU87SUFBRTtJQUFTO0lBQVM7SUFBUztJQUFLO0lBQUU7SUFBUztJQUFTO0lBQUk7SUFBTztJQUFTO0lBQVM7SUFBSztJQUFTO0lBQU87SUFBTztJQUFTO0lBQUk7SUFBTztJQUFTO0lBQU87SUFBUztJQUFTO0lBQUs7SUFBUztJQUFTO0lBQVM7SUFBUztJQUFLO0lBQUU7SUFBRTtJQUFTO0lBQU87SUFBUztJQUFTO0lBQUk7SUFBUztJQUFPO0lBQU87SUFBSztJQUFTO0lBQUs7SUFBSTtJQUFPO0lBQVM7SUFBTztJQUFTO0lBQVM7SUFBTztJQUFPO0lBQVM7SUFBUztJQUFLO0lBQVM7SUFBTztDQUFTO0FBQ25lLElBQUlDLGNBQWM7SUFBQztJQUFNO0lBQVU7SUFBVTtJQUFXO0lBQVE7SUFBTTtJQUFXO0lBQVU7SUFBVztJQUFRO0lBQVU7SUFBVztJQUFXO0lBQVc7SUFBUTtJQUFXO0lBQVU7SUFBVztJQUFXO0lBQUU7SUFBVztJQUFXO0lBQVc7SUFBVTtJQUFXO0lBQVc7SUFBRTtJQUFXO0lBQVU7SUFBVTtJQUFXO0lBQVE7SUFBUTtJQUFXO0lBQU07SUFBVTtJQUFXO0lBQVU7SUFBVztJQUFXO0lBQVU7SUFBVztJQUFXO0lBQVU7SUFBVztJQUFNO0lBQVU7SUFBVztJQUFXO0lBQVE7SUFBVztJQUFXO0lBQVU7SUFBRTtJQUFXO0lBQVc7SUFBUTtJQUFVO0lBQVc7SUFBUTtJQUFFO0lBQVc7SUFBVTtDQUFXO0FBQ25uQixJQUFJQyxjQUFjO0lBQUM7SUFBVztJQUFXO0lBQU87SUFBVztJQUFXO0lBQUs7SUFBVztJQUFTO0lBQVc7SUFBUztJQUFTO0lBQVc7SUFBUztJQUFXO0lBQVc7SUFBTztJQUFFO0lBQVM7SUFBVztJQUFPO0lBQVM7SUFBVztJQUFLO0lBQVc7SUFBVztJQUFFO0lBQVM7SUFBVztJQUFPO0lBQVM7SUFBVztJQUFXO0lBQVc7SUFBSztJQUFXO0lBQVM7SUFBVztJQUFTO0lBQU87SUFBVztJQUFTO0lBQVc7SUFBVztJQUFPO0lBQVc7SUFBVztJQUFTO0lBQVc7SUFBUztJQUFXO0lBQUU7SUFBVztJQUFLO0lBQU87SUFBVztJQUFTO0lBQU87SUFBUztJQUFXO0lBQUU7SUFBVztJQUFXO0lBQVM7Q0FBVztBQUN2bEIsSUFBSUMsY0FBYztJQUFDO0lBQVM7SUFBVTtJQUFVO0lBQUU7SUFBTTtJQUFVO0lBQVM7SUFBVTtJQUFVO0lBQVM7SUFBRTtJQUFVO0lBQUk7SUFBVTtJQUFVO0lBQU07SUFBVTtJQUFTO0lBQVM7SUFBVTtJQUFVO0lBQVU7SUFBVTtJQUFTO0lBQVU7SUFBTTtJQUFNO0lBQVU7SUFBUztJQUFJO0lBQVU7SUFBUztJQUFVO0lBQVM7SUFBUztJQUFVO0lBQVU7SUFBVTtJQUFVO0lBQUk7SUFBUztJQUFVO0lBQVU7SUFBUztJQUFVO0lBQU07SUFBUztJQUFVO0lBQU07SUFBVTtJQUFVO0lBQVU7SUFBUztJQUFFO0lBQUk7SUFBVTtJQUFFO0lBQVM7SUFBVTtJQUFNO0lBQVU7SUFBVTtJQUFNO0NBQVM7QUFDM2lCLElBQUlDLGNBQWM7SUFBQztJQUFXO0lBQU87SUFBUTtJQUFXO0lBQVc7SUFBVztJQUFLO0lBQVc7SUFBUTtJQUFXO0lBQVc7SUFBUTtJQUFXO0lBQVE7SUFBTztJQUFLO0lBQVc7SUFBVztJQUFXO0lBQU87SUFBUTtJQUFRO0lBQVc7SUFBVztJQUFPO0lBQUU7SUFBRTtJQUFXO0lBQVc7SUFBVztJQUFRO0lBQVE7SUFBUTtJQUFRO0lBQVc7SUFBTztJQUFLO0lBQVc7SUFBTztJQUFRO0lB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QSxNQUFNLENBQUMsU0FBVSxJQUFLSSxLQUFJLElBQUs7SUFDL0JBLFNBQVNKO0lBQ1RFLFFBQVNGLE9BQU87SUFFaEI5RCxNQUFNLENBQUMsRUFBRSxHQUFHZ0U7SUFDWmhFLE1BQU0sQ0FBQyxFQUFFLEdBQUdrRTtBQUNkO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNELFNBQVMvRCxjQUFja0IsT0FBTztJQUM1QkEsVUFBVUEsV0FBVyxDQUFDO0lBQ3RCLElBQUlwQixPQUFPLENBQUNvQixRQUFRcEIsSUFBSSxJQUFJLEtBQUksRUFBRzJFLFdBQVc7SUFDOUMsSUFBSUMsWUFBWSxTQUFTNUU7SUFFekIsSUFBSUM7SUFDSixJQUFHbUIsUUFBUWpCLE9BQU8sRUFBRTtRQUNsQkYsU0FBU1YsTUFBTVUsTUFBTSxDQUFDNEUsY0FBYyxDQUFDRCxXQUFXeEQsUUFBUXZCLEdBQUc7SUFDN0QsT0FBTztRQUNMSSxTQUFTVixNQUFNVSxNQUFNLENBQUM2RSxZQUFZLENBQUNGLFdBQVd4RCxRQUFRdkIsR0FBRztJQUMzRDtJQUVBLGlDQUFpQztJQUNqQyxJQUFJTyxRQUFRSCxPQUFPRyxLQUFLO0lBQ3hCSCxPQUFPRyxLQUFLLEdBQUcsU0FBU04sRUFBRSxFQUFFc0IsT0FBTztRQUNqQywrREFBK0Q7UUFDL0QsSUFBSXJCLFNBQVM7UUFDYixJQUFHcUIsbUJBQW1CN0IsTUFBTThCLElBQUksQ0FBQzBELFVBQVUsRUFBRTtZQUMzQ2hGLFNBQVNxQjtZQUNUQSxVQUFVLENBQUM7UUFDYjtRQUNBQSxVQUFVQSxXQUFXLENBQUM7UUFDdEJBLFFBQVFyQixNQUFNLEdBQUdBO1FBQ2pCcUIsUUFBUXRCLEVBQUUsR0FBR0E7UUFDYk0sTUFBTTRFLElBQUksQ0FBQy9FLFFBQVFtQjtJQUNyQjtJQUVBLE9BQU9uQjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2Rlcy5qcz81MzdlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogREVTIChEYXRhIEVuY3J5cHRpb24gU3RhbmRhcmQpIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gc3VwcG9ydHMgREVTIGFzIHdlbGwgYXMgM0RFUy1FREUgaW4gRUNCIGFuZCBDQkMgbW9kZS5cbiAqIEl0IGlzIGJhc2VkIG9uIHRoZSBCU0QtbGljZW5zZWQgaW1wbGVtZW50YXRpb24gYnkgUGF1bCBUZXJvOlxuICpcbiAqIFBhdWwgVGVybywgSnVseSAyMDAxXG4gKiBodHRwOi8vd3d3LnRlcm8uY28udWsvZGVzL1xuICpcbiAqIE9wdGltaXNlZCBmb3IgcGVyZm9ybWFuY2Ugd2l0aCBsYXJnZSBibG9ja3MgYnlcbiAqIE1pY2hhZWwgSGF5d29ydGgsIE5vdmVtYmVyIDIwMDFcbiAqIGh0dHA6Ly93d3cubmV0ZGVhbGluZy5jb21cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFXG4gKiBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICogREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFNcbiAqIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICogSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1RcbiAqIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVlcbiAqIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAqIFNVQ0ggREFNQUdFLlxuICpcbiAqIEBhdXRob3IgU3RlZmFuIFNpZWdsXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9jaXBoZXInKTtcbnJlcXVpcmUoJy4vY2lwaGVyTW9kZXMnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vKiBERVMgQVBJICovXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmRlcyA9IGZvcmdlLmRlcyB8fCB7fTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0RFUy08bW9kZT4nLCBrZXkpO1xuICogY2lwaGVyLnN0YXJ0KHtpdjogaXZ9KTtcbiAqXG4gKiBDcmVhdGVzIGFuIERFUyBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlciBvZiB0aGUgcmV0dXJuZWQgY2lwaGVyLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBiaW5hcnktZW5jb2RlZCBzdHJpbmdzIG9mIGJ5dGVzIG9yXG4gKiBieXRlIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKDY0IG9yIDE5MiBiaXRzKS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycgaWYgSVYgaXNcbiAqICAgICAgICAgIGdpdmVuLCAnRUNCJyBpZiBudWxsKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmRlcy5zdGFydEVuY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQsIG1vZGUpIHtcbiAgdmFyIGNpcGhlciA9IF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogb3V0cHV0LFxuICAgIGRlY3J5cHQ6IGZhbHNlLFxuICAgIG1vZGU6IG1vZGUgfHwgKGl2ID09PSBudWxsID8gJ0VDQicgOiAnQ0JDJylcbiAgfSk7XG4gIGNpcGhlci5zdGFydChpdik7XG4gIHJldHVybiBjaXBoZXI7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcignREVTLTxtb2RlPicsIGtleSk7XG4gKlxuICogQ3JlYXRlcyBhbiBERVMgY2lwaGVyIG9iamVjdCB0byBlbmNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIG1vZGUpIHtcbiAgcmV0dXJuIF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogbnVsbCxcbiAgICBkZWNyeXB0OiBmYWxzZSxcbiAgICBtb2RlOiBtb2RlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGRlY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdERVMtPG1vZGU+Jywga2V5KTtcbiAqIGRlY2lwaGVyLnN0YXJ0KHtpdjogaXZ9KTtcbiAqXG4gKiBDcmVhdGVzIGFuIERFUyBjaXBoZXIgb2JqZWN0IHRvIGRlY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlciBvZiB0aGUgcmV0dXJuZWQgY2lwaGVyLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBiaW5hcnktZW5jb2RlZCBzdHJpbmdzIG9mIGJ5dGVzIG9yXG4gKiBieXRlIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKDY0IG9yIDE5MiBiaXRzKS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycgaWYgSVYgaXNcbiAqICAgICAgICAgIGdpdmVuLCAnRUNCJyBpZiBudWxsKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmRlcy5zdGFydERlY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQsIG1vZGUpIHtcbiAgdmFyIGNpcGhlciA9IF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogb3V0cHV0LFxuICAgIGRlY3J5cHQ6IHRydWUsXG4gICAgbW9kZTogbW9kZSB8fCAoaXYgPT09IG51bGwgPyAnRUNCJyA6ICdDQkMnKVxuICB9KTtcbiAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBkZWNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcignREVTLTxtb2RlPicsIGtleSk7XG4gKlxuICogQ3JlYXRlcyBhbiBERVMgY2lwaGVyIG9iamVjdCB0byBkZWNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuZGVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIG1vZGUpIHtcbiAgcmV0dXJuIF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogbnVsbCxcbiAgICBkZWNyeXB0OiB0cnVlLFxuICAgIG1vZGU6IG1vZGVcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgREVTIGNpcGhlciBhbGdvcml0aG0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBhbGdvcml0aG0uXG4gKiBAcGFyYW0gbW9kZSB0aGUgbW9kZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm4gdGhlIERFUyBhbGdvcml0aG0gb2JqZWN0LlxuICovXG5mb3JnZS5kZXMuQWxnb3JpdGhtID0gZnVuY3Rpb24obmFtZSwgbW9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYubmFtZSA9IG5hbWU7XG4gIHNlbGYubW9kZSA9IG5ldyBtb2RlKHtcbiAgICBibG9ja1NpemU6IDgsXG4gICAgY2lwaGVyOiB7XG4gICAgICBlbmNyeXB0OiBmdW5jdGlvbihpbkJsb2NrLCBvdXRCbG9jaykge1xuICAgICAgICByZXR1cm4gX3VwZGF0ZUJsb2NrKHNlbGYuX2tleXMsIGluQmxvY2ssIG91dEJsb2NrLCBmYWxzZSk7XG4gICAgICB9LFxuICAgICAgZGVjcnlwdDogZnVuY3Rpb24oaW5CbG9jaywgb3V0QmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF91cGRhdGVCbG9jayhzZWxmLl9rZXlzLCBpbkJsb2NrLCBvdXRCbG9jaywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc2VsZi5faW5pdCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGlzIERFUyBhbGdvcml0aG0gYnkgZXhwYW5kaW5nIGl0cyBrZXkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBrZXkgdG8gdXNlIHdpdGggdGhpcyBhbGdvcml0aG0uXG4gKiAgICAgICAgICBkZWNyeXB0IHRydWUgaWYgdGhlIGFsZ29yaXRobSBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgZm9yIGRlY3J5cHRpb24sXG4gKiAgICAgICAgICAgIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICovXG5mb3JnZS5kZXMuQWxnb3JpdGhtLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZih0aGlzLl9pbml0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG9wdGlvbnMua2V5KTtcbiAgaWYodGhpcy5uYW1lLmluZGV4T2YoJzNERVMnKSA9PT0gMCkge1xuICAgIGlmKGtleS5sZW5ndGgoKSAhPT0gMjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBUcmlwbGUtREVTIGtleSBzaXplOiAnICsga2V5Lmxlbmd0aCgpICogOCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZG8ga2V5IGV4cGFuc2lvbiB0byAxNiBvciA0OCBzdWJrZXlzIChzaW5nbGUgb3IgdHJpcGxlIERFUylcbiAgdGhpcy5fa2V5cyA9IF9jcmVhdGVLZXlzKGtleSk7XG4gIHRoaXMuX2luaXQgPSB0cnVlO1xufTtcblxuLyoqIFJlZ2lzdGVyIERFUyBhbGdvcml0aG1zICoqL1xuXG5yZWdpc3RlckFsZ29yaXRobSgnREVTLUVDQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5lY2IpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0RFUy1DQkMnLCBmb3JnZS5jaXBoZXIubW9kZXMuY2JjKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdERVMtQ0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmNmYik7XG5yZWdpc3RlckFsZ29yaXRobSgnREVTLU9GQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5vZmIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0RFUy1DVFInLCBmb3JnZS5jaXBoZXIubW9kZXMuY3RyKTtcblxucmVnaXN0ZXJBbGdvcml0aG0oJzNERVMtRUNCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmVjYik7XG5yZWdpc3RlckFsZ29yaXRobSgnM0RFUy1DQkMnLCBmb3JnZS5jaXBoZXIubW9kZXMuY2JjKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCczREVTLUNGQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5jZmIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJzNERVMtT0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLm9mYik7XG5yZWdpc3RlckFsZ29yaXRobSgnM0RFUy1DVFInLCBmb3JnZS5jaXBoZXIubW9kZXMuY3RyKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJBbGdvcml0aG0obmFtZSwgbW9kZSkge1xuICB2YXIgZmFjdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgZm9yZ2UuZGVzLkFsZ29yaXRobShuYW1lLCBtb2RlKTtcbiAgfTtcbiAgZm9yZ2UuY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtKG5hbWUsIGZhY3RvcnkpO1xufVxuXG4vKiogREVTIGltcGxlbWVudGF0aW9uICoqL1xuXG52YXIgc3BmdW5jdGlvbjEgPSBbMHgxMDEwNDAwLDAsMHgxMDAwMCwweDEwMTA0MDQsMHgxMDEwMDA0LDB4MTA0MDQsMHg0LDB4MTAwMDAsMHg0MDAsMHgxMDEwNDAwLDB4MTAxMDQwNCwweDQwMCwweDEwMDA0MDQsMHgxMDEwMDA0LDB4MTAwMDAwMCwweDQsMHg0MDQsMHgxMDAwNDAwLDB4MTAwMDQwMCwweDEwNDAwLDB4MTA0MDAsMHgxMDEwMDAwLDB4MTAxMDAwMCwweDEwMDA0MDQsMHgxMDAwNCwweDEwMDAwMDQsMHgxMDAwMDA0LDB4MTAwMDQsMCwweDQwNCwweDEwNDA0LDB4MTAwMDAwMCwweDEwMDAwLDB4MTAxMDQwNCwweDQsMHgxMDEwMDAwLDB4MTAxMDQwMCwweDEwMDAwMDAsMHgxMDAwMDAwLDB4NDAwLDB4MTAxMDAwNCwweDEwMDAwLDB4MTA0MDAsMHgxMDAwMDA0LDB4NDAwLDB4NCwweDEwMDA0MDQsMHgxMDQwNCwweDEwMTA0MDQsMHgxMDAwNCwweDEwMTAwMDAsMHgxMDAwNDA0LDB4MTAwMDAwNCwweDQwNCwweDEwNDA0LDB4MTAxMDQwMCwweDQwNCwweDEwMDA0MDAsMHgxMDAwNDAwLDAsMHgxMDAwNCwweDEwNDAwLDAsMHgxMDEwMDA0XTtcbnZhciBzcGZ1bmN0aW9uMiA9IFstMHg3ZmVmN2ZlMCwtMHg3ZmZmODAwMCwweDgwMDAsMHgxMDgwMjAsMHgxMDAwMDAsMHgyMCwtMHg3ZmVmZmZlMCwtMHg3ZmZmN2ZlMCwtMHg3ZmZmZmZlMCwtMHg3ZmVmN2ZlMCwtMHg3ZmVmODAwMCwtMHg4MDAwMDAwMCwtMHg3ZmZmODAwMCwweDEwMDAwMCwweDIwLC0weDdmZWZmZmUwLDB4MTA4MDAwLDB4MTAwMDIwLC0weDdmZmY3ZmUwLDAsLTB4ODAwMDAwMDAsMHg4MDAwLDB4MTA4MDIwLC0weDdmZjAwMDAwLDB4MTAwMDIwLC0weDdmZmZmZmUwLDAsMHgxMDgwMDAsMHg4MDIwLC0weDdmZWY4MDAwLC0weDdmZjAwMDAwLDB4ODAyMCwwLDB4MTA4MDIwLC0weDdmZWZmZmUwLDB4MTAwMDAwLC0weDdmZmY3ZmUwLC0weDdmZjAwMDAwLC0weDdmZWY4MDAwLDB4ODAwMCwtMHg3ZmYwMDAwMCwtMHg3ZmZmODAwMCwweDIwLC0weDdmZWY3ZmUwLDB4MTA4MDIwLDB4MjAsMHg4MDAwLC0weDgwMDAwMDAwLDB4ODAyMCwtMHg3ZmVmODAwMCwweDEwMDAwMCwtMHg3ZmZmZmZlMCwweDEwMDAyMCwtMHg3ZmZmN2ZlMCwtMHg3ZmZmZmZlMCwweDEwMDAyMCwweDEwODAwMCwwLC0weDdmZmY4MDAwLDB4ODAyMCwtMHg4MDAwMDAwMCwtMHg3ZmVmZmZlMCwtMHg3ZmVmN2ZlMCwweDEwODAwMF07XG52YXIgc3BmdW5jdGlvbjMgPSBbMHgyMDgsMHg4MDIwMjAwLDAsMHg4MDIwMDA4LDB4ODAwMDIwMCwwLDB4MjAyMDgsMHg4MDAwMjAwLDB4MjAwMDgsMHg4MDAwMDA4LDB4ODAwMDAwOCwweDIwMDAwLDB4ODAyMDIwOCwweDIwMDA4LDB4ODAyMDAwMCwweDIwOCwweDgwMDAwMDAsMHg4LDB4ODAyMDIwMCwweDIwMCwweDIwMjAwLDB4ODAyMDAwMCwweDgwMjAwMDgsMHgyMDIwOCwweDgwMDAyMDgsMHgyMDIwMCwweDIwMDAwLDB4ODAwMDIwOCwweDgsMHg4MDIwMjA4LDB4MjAwLDB4ODAwMDAwMCwweDgwMjAyMDAsMHg4MDAwMDAwLDB4MjAwMDgsMHgyMDgsMHgyMDAwMCwweDgwMjAyMDAsMHg4MDAwMjAwLDAsMHgyMDAsMHgyMDAwOCwweDgwMjAyMDgsMHg4MDAwMjAwLDB4ODAwMDAwOCwweDIwMCwwLDB4ODAyMDAwOCwweDgwMDAyMDgsMHgyMDAwMCwweDgwMDAwMDAsMHg4MDIwMjA4LDB4OCwweDIwMjA4LDB4MjAyMDAsMHg4MDAwMDA4LDB4ODAyMDAwMCwweDgwMDAyMDgsMHgyMDgsMHg4MDIwMDAwLDB4MjAyMDgsMHg4LDB4ODAyMDAwOCwweDIwMjAwXTtcbnZhciBzcGZ1bmN0aW9uNCA9IFsweDgwMjAwMSwweDIwODEsMHgyMDgxLDB4ODAsMHg4MDIwODAsMHg4MDAwODEsMHg4MDAwMDEsMHgyMDAxLDAsMHg4MDIwMDAsMHg4MDIwMDAsMHg4MDIwODEsMHg4MSwwLDB4ODAwMDgwLDB4ODAwMDAxLDB4MSwweDIwMDAsMHg4MDAwMDAsMHg4MDIwMDEsMHg4MCwweDgwMDAwMCwweDIwMDEsMHgyMDgwLDB4ODAwMDgxLDB4MSwweDIwODAsMHg4MDAwODAsMHgyMDAwLDB4ODAyMDgwLDB4ODAyMDgxLDB4ODEsMHg4MDAwODAsMHg4MDAwMDEsMHg4MDIwMDAsMHg4MDIwODEsMHg4MSwwLDAsMHg4MDIwMDAsMHgyMDgwLDB4ODAwMDgwLDB4ODAwMDgxLDB4MSwweDgwMjAwMSwweDIwODEsMHgyMDgxLDB4ODAsMHg4MDIwODEsMHg4MSwweDEsMHgyMDAwLDB4ODAwMDAxLDB4MjAwMSwweDgwMjA4MCwweDgwMDA4MSwweDIwMDEsMHgyMDgwLDB4ODAwMDAwLDB4ODAyMDAxLDB4ODAsMHg4MDAwMDAsMHgyMDAwLDB4ODAyMDgwXTtcbnZhciBzcGZ1bmN0aW9uNSA9IFsweDEwMCwweDIwODAxMDAsMHgyMDgwMDAwLDB4NDIwMDAxMDAsMHg4MDAwMCwweDEwMCwweDQwMDAwMDAwLDB4MjA4MDAwMCwweDQwMDgwMTAwLDB4ODAwMDAsMHgyMDAwMTAwLDB4NDAwODAxMDAsMHg0MjAwMDEwMCwweDQyMDgwMDAwLDB4ODAxMDAsMHg0MDAwMDAwMCwweDIwMDAwMDAsMHg0MDA4MDAwMCwweDQwMDgwMDAwLDAsMHg0MDAwMDEwMCwweDQyMDgwMTAwLDB4NDIwODAxMDAsMHgyMDAwMTAwLDB4NDIwODAwMDAsMHg0MDAwMDEwMCwwLDB4NDIwMDAwMDAsMHgyMDgwMTAwLDB4MjAwMDAwMCwweDQyMDAwMDAwLDB4ODAxMDAsMHg4MDAwMCwweDQyMDAwMTAwLDB4MTAwLDB4MjAwMDAwMCwweDQwMDAwMDAwLDB4MjA4MDAwMCwweDQyMDAwMTAwLDB4NDAwODAxMDAsMHgyMDAwMTAwLDB4NDAwMDAwMDAsMHg0MjA4MDAwMCwweDIwODAxMDAsMHg0MDA4MDEwMCwweDEwMCwweDIwMDAwMDAsMHg0MjA4MDAwMCwweDQyMDgwMTAwLDB4ODAxMDAsMHg0MjAwMDAwMCwweDQyMDgwMTAwLDB4MjA4MDAwMCwwLDB4NDAwODAwMDAsMHg0MjAwMDAwMCwweDgwMTAwLDB4MjAwMDEwMCwweDQwMDAwMTAwLDB4ODAwMDAsMCwweDQwMDgwMDAwLDB4MjA4MDEwMCwweDQwMDAwMTAwXTtcbnZhciBzcGZ1bmN0aW9uNiA9IFsweDIwMDAwMDEwLDB4MjA0MDAwMDAsMHg0MDAwLDB4MjA0MDQwMTAsMHgyMDQwMDAwMCwweDEwLDB4MjA0MDQwMTAsMHg0MDAwMDAsMHgyMDAwNDAwMCwweDQwNDAxMCwweDQwMDAwMCwweDIwMDAwMDEwLDB4NDAwMDEwLDB4MjAwMDQwMDAsMHgyMDAwMDAwMCwweDQwMTAsMCwweDQwMDAxMCwweDIwMDA0MDEwLDB4NDAwMCwweDQwNDAwMCwweDIwMDA0MDEwLDB4MTAsMHgyMDQwMDAxMCwweDIwNDAwMDEwLDAsMHg0MDQwMTAsMHgyMDQwNDAwMCwweDQwMTAsMHg0MDQwMDAsMHgyMDQwNDAwMCwweDIwMDAwMDAwLDB4MjAwMDQwMDAsMHgxMCwweDIwNDAwMDEwLDB4NDA0MDAwLDB4MjA0MDQwMTAsMHg0MDAwMDAsMHg0MDEwLDB4MjAwMDAwMTAsMHg0MDAwMDAsMHgyMDAwNDAwMCwweDIwMDAwMDAwLDB4NDAxMCwweDIwMDAwMDEwLDB4MjA0MDQwMTAsMHg0MDQwMDAsMHgyMDQwMDAwMCwweDQwNDAxMCwweDIwNDA0MDAwLDAsMHgyMDQwMDAxMCwweDEwLDB4NDAwMCwweDIwNDAwMDAwLDB4NDA0MDEwLDB4NDAwMCwweDQwMDAxMCwweDIwMDA0MDEwLDAsMHgyMDQwNDAwMCwweDIwMDAwMDAwLDB4NDAwMDEwLDB4MjAwMDQwMTBdO1xudmFyIHNwZnVuY3Rpb243ID0gWzB4MjAwMDAwLDB4NDIwMDAwMiwweDQwMDA4MDIsMCwweDgwMCwweDQwMDA4MDIsMHgyMDA4MDIsMHg0MjAwODAwLDB4NDIwMDgwMiwweDIwMDAwMCwwLDB4NDAwMDAwMiwweDIsMHg0MDAwMDAwLDB4NDIwMDAwMiwweDgwMiwweDQwMDA4MDAsMHgyMDA4MDIsMHgyMDAwMDIsMHg0MDAwODAwLDB4NDAwMDAwMiwweDQyMDAwMDAsMHg0MjAwODAwLDB4MjAwMDAyLDB4NDIwMDAwMCwweDgwMCwweDgwMiwweDQyMDA4MDIsMHgyMDA4MDAsMHgyLDB4NDAwMDAwMCwweDIwMDgwMCwweDQwMDAwMDAsMHgyMDA4MDAsMHgyMDAwMDAsMHg0MDAwODAyLDB4NDAwMDgwMiwweDQyMDAwMDIsMHg0MjAwMDAyLDB4MiwweDIwMDAwMiwweDQwMDAwMDAsMHg0MDAwODAwLDB4MjAwMDAwLDB4NDIwMDgwMCwweDgwMiwweDIwMDgwMiwweDQyMDA4MDAsMHg4MDIsMHg0MDAwMDAyLDB4NDIwMDgwMiwweDQyMDAwMDAsMHgyMDA4MDAsMCwweDIsMHg0MjAwODAyLDAsMHgyMDA4MDIsMHg0MjAwMDAwLDB4ODAwLDB4NDAwMDAwMiwweDQwMDA4MDAsMHg4MDAsMHgyMDAwMDJdO1xudmFyIHNwZnVuY3Rpb244ID0gWzB4MTAwMDEwNDAsMHgxMDAwLDB4NDAwMDAsMHgxMDA0MTA0MCwweDEwMDAwMDAwLDB4MTAwMDEwNDAsMHg0MCwweDEwMDAwMDAwLDB4NDAwNDAsMHgxMDA0MDAwMCwweDEwMDQxMDQwLDB4NDEwMDAsMHgxMDA0MTAwMCwweDQxMDQwLDB4MTAwMCwweDQwLDB4MTAwNDAwMDAsMHgxMDAwMDA0MCwweDEwMDAxMDAwLDB4MTA0MCwweDQxMDAwLDB4NDAwNDAsMHgxMDA0MDA0MCwweDEwMDQxMDAwLDB4MTA0MCwwLDAsMHgxMDA0MDA0MCwweDEwMDAwMDQwLDB4MTAwMDEwMDAsMHg0MTA0MCwweDQwMDAwLDB4NDEwNDAsMHg0MDAwMCwweDEwMDQxMDAwLDB4MTAwMCwweDQwLDB4MTAwNDAwNDAsMHgxMDAwLDB4NDEwNDAsMHgxMDAwMTAwMCwweDQwLDB4MTAwMDAwNDAsMHgxMDA0MDAwMCwweDEwMDQwMDQwLDB4MTAwMDAwMDAsMHg0MDAwMCwweDEwMDAxMDQwLDAsMHgxMDA0MTA0MCwweDQwMDQwLDB4MTAwMDAwNDAsMHgxMDA0MDAwMCwweDEwMDAxMDAwLDB4MTAwMDEwNDAsMCwweDEwMDQxMDQwLDB4NDEwMDAsMHg0MTAwMCwweDEwNDAsMHgxMDQwLDB4NDAwNDAsMHgxMDAwMDAwMCwweDEwMDQxMDAwXTtcblxuLyoqXG4gKiBDcmVhdGUgbmVjZXNzYXJ5IHN1YiBrZXlzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIDY0LWJpdCBvciAxOTItYml0IGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBleHBhbmRlZCBrZXlzLlxuICovXG5mdW5jdGlvbiBfY3JlYXRlS2V5cyhrZXkpIHtcbiAgdmFyIHBjMmJ5dGVzMCAgPSBbMCwweDQsMHgyMDAwMDAwMCwweDIwMDAwMDA0LDB4MTAwMDAsMHgxMDAwNCwweDIwMDEwMDAwLDB4MjAwMTAwMDQsMHgyMDAsMHgyMDQsMHgyMDAwMDIwMCwweDIwMDAwMjA0LDB4MTAyMDAsMHgxMDIwNCwweDIwMDEwMjAwLDB4MjAwMTAyMDRdLFxuICAgICAgcGMyYnl0ZXMxICA9IFswLDB4MSwweDEwMDAwMCwweDEwMDAwMSwweDQwMDAwMDAsMHg0MDAwMDAxLDB4NDEwMDAwMCwweDQxMDAwMDEsMHgxMDAsMHgxMDEsMHgxMDAxMDAsMHgxMDAxMDEsMHg0MDAwMTAwLDB4NDAwMDEwMSwweDQxMDAxMDAsMHg0MTAwMTAxXSxcbiAgICAgIHBjMmJ5dGVzMiAgPSBbMCwweDgsMHg4MDAsMHg4MDgsMHgxMDAwMDAwLDB4MTAwMDAwOCwweDEwMDA4MDAsMHgxMDAwODA4LDAsMHg4LDB4ODAwLDB4ODA4LDB4MTAwMDAwMCwweDEwMDAwMDgsMHgxMDAwODAwLDB4MTAwMDgwOF0sXG4gICAgICBwYzJieXRlczMgID0gWzAsMHgyMDAwMDAsMHg4MDAwMDAwLDB4ODIwMDAwMCwweDIwMDAsMHgyMDIwMDAsMHg4MDAyMDAwLDB4ODIwMjAwMCwweDIwMDAwLDB4MjIwMDAwLDB4ODAyMDAwMCwweDgyMjAwMDAsMHgyMjAwMCwweDIyMjAwMCwweDgwMjIwMDAsMHg4MjIyMDAwXSxcbiAgICAgIHBjMmJ5dGVzNCAgPSBbMCwweDQwMDAwLDB4MTAsMHg0MDAxMCwwLDB4NDAwMDAsMHgxMCwweDQwMDEwLDB4MTAwMCwweDQxMDAwLDB4MTAxMCwweDQxMDEwLDB4MTAwMCwweDQxMDAwLDB4MTAxMCwweDQxMDEwXSxcbiAgICAgIHBjMmJ5dGVzNSAgPSBbMCwweDQwMCwweDIwLDB4NDIwLDAsMHg0MDAsMHgyMCwweDQyMCwweDIwMDAwMDAsMHgyMDAwNDAwLDB4MjAwMDAyMCwweDIwMDA0MjAsMHgyMDAwMDAwLDB4MjAwMDQwMCwweDIwMDAwMjAsMHgyMDAwNDIwXSxcbiAgICAgIHBjMmJ5dGVzNiAgPSBbMCwweDEwMDAwMDAwLDB4ODAwMDAsMHgxMDA4MDAwMCwweDIsMHgxMDAwMDAwMiwweDgwMDAyLDB4MTAwODAwMDIsMCwweDEwMDAwMDAwLDB4ODAwMDAsMHgxMDA4MDAwMCwweDIsMHgxMDAwMDAwMiwweDgwMDAyLDB4MTAwODAwMDJdLFxuICAgICAgcGMyYnl0ZXM3ICA9IFswLDB4MTAwMDAsMHg4MDAsMHgxMDgwMCwweDIwMDAwMDAwLDB4MjAwMTAwMDAsMHgyMDAwMDgwMCwweDIwMDEwODAwLDB4MjAwMDAsMHgzMDAwMCwweDIwODAwLDB4MzA4MDAsMHgyMDAyMDAwMCwweDIwMDMwMDAwLDB4MjAwMjA4MDAsMHgyMDAzMDgwMF0sXG4gICAgICBwYzJieXRlczggID0gWzAsMHg0MDAwMCwwLDB4NDAwMDAsMHgyLDB4NDAwMDIsMHgyLDB4NDAwMDIsMHgyMDAwMDAwLDB4MjA0MDAwMCwweDIwMDAwMDAsMHgyMDQwMDAwLDB4MjAwMDAwMiwweDIwNDAwMDIsMHgyMDAwMDAyLDB4MjA0MDAwMl0sXG4gICAgICBwYzJieXRlczkgID0gWzAsMHgxMDAwMDAwMCwweDgsMHgxMDAwMDAwOCwwLDB4MTAwMDAwMDAsMHg4LDB4MTAwMDAwMDgsMHg0MDAsMHgxMDAwMDQwMCwweDQwOCwweDEwMDAwNDA4LDB4NDAwLDB4MTAwMDA0MDAsMHg0MDgsMHgxMDAwMDQwOF0sXG4gICAgICBwYzJieXRlczEwID0gWzAsMHgyMCwwLDB4MjAsMHgxMDAwMDAsMHgxMDAwMjAsMHgxMDAwMDAsMHgxMDAwMjAsMHgyMDAwLDB4MjAyMCwweDIwMDAsMHgyMDIwLDB4MTAyMDAwLDB4MTAyMDIwLDB4MTAyMDAwLDB4MTAyMDIwXSxcbiAgICAgIHBjMmJ5dGVzMTEgPSBbMCwweDEwMDAwMDAsMHgyMDAsMHgxMDAwMjAwLDB4MjAwMDAwLDB4MTIwMDAwMCwweDIwMDIwMCwweDEyMDAyMDAsMHg0MDAwMDAwLDB4NTAwMDAwMCwweDQwMDAyMDAsMHg1MDAwMjAwLDB4NDIwMDAwMCwweDUyMDAwMDAsMHg0MjAwMjAwLDB4NTIwMDIwMF0sXG4gICAgICBwYzJieXRlczEyID0gWzAsMHgxMDAwLDB4ODAwMDAwMCwweDgwMDEwMDAsMHg4MDAwMCwweDgxMDAwLDB4ODA4MDAwMCwweDgwODEwMDAsMHgxMCwweDEwMTAsMHg4MDAwMDEwLDB4ODAwMTAxMCwweDgwMDEwLDB4ODEwMTAsMHg4MDgwMDEwLDB4ODA4MTAxMF0sXG4gICAgICBwYzJieXRlczEzID0gWzAsMHg0LDB4MTAwLDB4MTA0LDAsMHg0LDB4MTAwLDB4MTA0LDB4MSwweDUsMHgxMDEsMHgxMDUsMHgxLDB4NSwweDEwMSwweDEwNV07XG5cbiAgLy8gaG93IG1hbnkgaXRlcmF0aW9ucyAoMSBmb3IgZGVzLCAzIGZvciB0cmlwbGUgZGVzKVxuICAvLyBjaGFuZ2VkIGJ5IFBhdWwgMTYvNi8yMDA3IHRvIHVzZSBUcmlwbGUgREVTIGZvciA5KyBieXRlIGtleXNcbiAgdmFyIGl0ZXJhdGlvbnMgPSBrZXkubGVuZ3RoKCkgPiA4ID8gMyA6IDE7XG5cbiAgLy8gc3RvcmVzIHRoZSByZXR1cm4ga2V5c1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIC8vIG5vdyBkZWZpbmUgdGhlIGxlZnQgc2hpZnRzIHdoaWNoIG5lZWQgdG8gYmUgZG9uZVxuICB2YXIgc2hpZnRzID0gWzAsIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDBdO1xuXG4gIHZhciBuID0gMCwgdG1wO1xuICBmb3IodmFyIGogPSAwOyBqIDwgaXRlcmF0aW9uczsgaisrKSB7XG4gICAgdmFyIGxlZnQgPSBrZXkuZ2V0SW50MzIoKTtcbiAgICB2YXIgcmlnaHQgPSBrZXkuZ2V0SW50MzIoKTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gNCkgXiByaWdodCkgJiAweDBmMGYwZjBmO1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgNCk7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiAtMTYpIF4gbGVmdCkgJiAweDAwMDBmZmZmO1xuICAgIGxlZnQgXj0gdG1wO1xuICAgIHJpZ2h0IF49ICh0bXAgPDwgLTE2KTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gMikgXiByaWdodCkgJiAweDMzMzMzMzMzO1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgMik7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiAtMTYpIF4gbGVmdCkgJiAweDAwMDBmZmZmO1xuICAgIGxlZnQgXj0gdG1wO1xuICAgIHJpZ2h0IF49ICh0bXAgPDwgLTE2KTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gMSkgXiByaWdodCkgJiAweDU1NTU1NTU1O1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgMSk7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiA4KSBeIGxlZnQpICYgMHgwMGZmMDBmZjtcbiAgICBsZWZ0IF49IHRtcDtcbiAgICByaWdodCBePSAodG1wIDw8IDgpO1xuXG4gICAgdG1wID0gKChsZWZ0ID4+PiAxKSBeIHJpZ2h0KSAmIDB4NTU1NTU1NTU7XG4gICAgcmlnaHQgXj0gdG1wO1xuICAgIGxlZnQgXj0gKHRtcCA8PCAxKTtcblxuICAgIC8vIHJpZ2h0IG5lZWRzIHRvIGJlIHNoaWZ0ZWQgYW5kIE9SJ2Qgd2l0aCBsYXN0IGZvdXIgYml0cyBvZiBsZWZ0XG4gICAgdG1wID0gKGxlZnQgPDwgOCkgfCAoKHJpZ2h0ID4+PiAyMCkgJiAweDAwMDAwMGYwKTtcblxuICAgIC8vIGxlZnQgbmVlZHMgdG8gYmUgcHV0IHVwc2lkZSBkb3duXG4gICAgbGVmdCA9ICgocmlnaHQgPDwgMjQpIHwgKChyaWdodCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAoKHJpZ2h0ID4+PiA4KSAmIDB4ZmYwMCkgfCAoKHJpZ2h0ID4+PiAyNCkgJiAweGYwKSk7XG4gICAgcmlnaHQgPSB0bXA7XG5cbiAgICAvLyBub3cgZ28gdGhyb3VnaCBhbmQgcGVyZm9ybSB0aGVzZSBzaGlmdHMgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IGtleXNcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2hpZnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAvL3NoaWZ0IHRoZSBrZXlzIGVpdGhlciBvbmUgb3IgdHdvIGJpdHMgdG8gdGhlIGxlZnRcbiAgICAgIGlmKHNoaWZ0c1tpXSkge1xuICAgICAgICBsZWZ0ID0gKGxlZnQgPDwgMikgfCAobGVmdCA+Pj4gMjYpO1xuICAgICAgICByaWdodCA9IChyaWdodCA8PCAyKSB8IChyaWdodCA+Pj4gMjYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IChsZWZ0IDw8IDEpIHwgKGxlZnQgPj4+IDI3KTtcbiAgICAgICAgcmlnaHQgPSAocmlnaHQgPDwgMSkgfCAocmlnaHQgPj4+IDI3KTtcbiAgICAgIH1cbiAgICAgIGxlZnQgJj0gLTB4ZjtcbiAgICAgIHJpZ2h0ICY9IC0weGY7XG5cbiAgICAgIC8vIG5vdyBhcHBseSBQQy0yLCBpbiBzdWNoIGEgd2F5IHRoYXQgRSBpcyBlYXNpZXIgd2hlbiBlbmNyeXB0aW5nIG9yXG4gICAgICAvLyBkZWNyeXB0aW5nIHRoaXMgY29udmVyc2lvbiB3aWxsIGxvb2sgbGlrZSBQQy0yIGV4Y2VwdCBvbmx5IHRoZSBsYXN0IDZcbiAgICAgIC8vIGJpdHMgb2YgZWFjaCBieXRlIGFyZSB1c2VkIHJhdGhlciB0aGFuIDQ4IGNvbnNlY3V0aXZlIGJpdHMgYW5kIHRoZVxuICAgICAgLy8gb3JkZXIgb2YgbGluZXMgd2lsbCBiZSBhY2NvcmRpbmcgdG8gaG93IHRoZSBTIHNlbGVjdGlvbiBmdW5jdGlvbnMgd2lsbFxuICAgICAgLy8gYmUgYXBwbGllZDogUzIsIFM0LCBTNiwgUzgsIFMxLCBTMywgUzUsIFM3XG4gICAgICB2YXIgbGVmdHRtcCA9IChcbiAgICAgICAgcGMyYnl0ZXMwW2xlZnQgPj4+IDI4XSB8IHBjMmJ5dGVzMVsobGVmdCA+Pj4gMjQpICYgMHhmXSB8XG4gICAgICAgIHBjMmJ5dGVzMlsobGVmdCA+Pj4gMjApICYgMHhmXSB8IHBjMmJ5dGVzM1sobGVmdCA+Pj4gMTYpICYgMHhmXSB8XG4gICAgICAgIHBjMmJ5dGVzNFsobGVmdCA+Pj4gMTIpICYgMHhmXSB8IHBjMmJ5dGVzNVsobGVmdCA+Pj4gOCkgJiAweGZdIHxcbiAgICAgICAgcGMyYnl0ZXM2WyhsZWZ0ID4+PiA0KSAmIDB4Zl0pO1xuICAgICAgdmFyIHJpZ2h0dG1wID0gKFxuICAgICAgICBwYzJieXRlczdbcmlnaHQgPj4+IDI4XSB8IHBjMmJ5dGVzOFsocmlnaHQgPj4+IDI0KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczlbKHJpZ2h0ID4+PiAyMCkgJiAweGZdIHwgcGMyYnl0ZXMxMFsocmlnaHQgPj4+IDE2KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczExWyhyaWdodCA+Pj4gMTIpICYgMHhmXSB8IHBjMmJ5dGVzMTJbKHJpZ2h0ID4+PiA4KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczEzWyhyaWdodCA+Pj4gNCkgJiAweGZdKTtcbiAgICAgIHRtcCA9ICgocmlnaHR0bXAgPj4+IDE2KSBeIGxlZnR0bXApICYgMHgwMDAwZmZmZjtcbiAgICAgIGtleXNbbisrXSA9IGxlZnR0bXAgXiB0bXA7XG4gICAgICBrZXlzW24rK10gPSByaWdodHRtcCBeICh0bXAgPDwgMTYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBzaW5nbGUgYmxvY2sgKDEgYnl0ZSkgdXNpbmcgREVTLiBUaGUgdXBkYXRlIHdpbGwgZWl0aGVyXG4gKiBlbmNyeXB0IG9yIGRlY3J5cHQgdGhlIGJsb2NrLlxuICpcbiAqIEBwYXJhbSBrZXlzIHRoZSBleHBhbmRlZCBrZXlzLlxuICogQHBhcmFtIGlucHV0IHRoZSBpbnB1dCBibG9jayAoYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzKS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIHVwZGF0ZWQgb3V0cHV0IGJsb2NrLlxuICogQHBhcmFtIGRlY3J5cHQgdHJ1ZSB0byBkZWNyeXB0IHRoZSBibG9jaywgZmFsc2UgdG8gZW5jcnlwdCBpdC5cbiAqL1xuZnVuY3Rpb24gX3VwZGF0ZUJsb2NrKGtleXMsIGlucHV0LCBvdXRwdXQsIGRlY3J5cHQpIHtcbiAgLy8gc2V0IHVwIGxvb3BzIGZvciBzaW5nbGUgb3IgdHJpcGxlIERFU1xuICB2YXIgaXRlcmF0aW9ucyA9IGtleXMubGVuZ3RoID09PSAzMiA/IDMgOiA5O1xuICB2YXIgbG9vcGluZztcbiAgaWYoaXRlcmF0aW9ucyA9PT0gMykge1xuICAgIGxvb3BpbmcgPSBkZWNyeXB0ID8gWzMwLCAtMiwgLTJdIDogWzAsIDMyLCAyXTtcbiAgfSBlbHNlIHtcbiAgICBsb29waW5nID0gKGRlY3J5cHQgP1xuICAgICAgWzk0LCA2MiwgLTIsIDMyLCA2NCwgMiwgMzAsIC0yLCAtMl0gOlxuICAgICAgWzAsIDMyLCAyLCA2MiwgMzAsIC0yLCA2NCwgOTYsIDJdKTtcbiAgfVxuXG4gIHZhciB0bXA7XG5cbiAgdmFyIGxlZnQgPSBpbnB1dFswXTtcbiAgdmFyIHJpZ2h0ID0gaW5wdXRbMV07XG5cbiAgLy8gZmlyc3QgZWFjaCA2NCBiaXQgY2h1bmsgb2YgdGhlIG1lc3NhZ2UgbXVzdCBiZSBwZXJtdXRlZCBhY2NvcmRpbmcgdG8gSVBcbiAgdG1wID0gKChsZWZ0ID4+PiA0KSBeIHJpZ2h0KSAmIDB4MGYwZjBmMGY7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDQpO1xuXG4gIHRtcCA9ICgobGVmdCA+Pj4gMTYpIF4gcmlnaHQpICYgMHgwMDAwZmZmZjtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgMTYpO1xuXG4gIHRtcCA9ICgocmlnaHQgPj4+IDIpIF4gbGVmdCkgJiAweDMzMzMzMzMzO1xuICBsZWZ0IF49IHRtcDtcbiAgcmlnaHQgXj0gKHRtcCA8PCAyKTtcblxuICB0bXAgPSAoKHJpZ2h0ID4+PiA4KSBeIGxlZnQpICYgMHgwMGZmMDBmZjtcbiAgbGVmdCBePSB0bXA7XG4gIHJpZ2h0IF49ICh0bXAgPDwgOCk7XG5cbiAgdG1wID0gKChsZWZ0ID4+PiAxKSBeIHJpZ2h0KSAmIDB4NTU1NTU1NTU7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDEpO1xuXG4gIC8vIHJvdGF0ZSBsZWZ0IDEgYml0XG4gIGxlZnQgPSAoKGxlZnQgPDwgMSkgfCAobGVmdCA+Pj4gMzEpKTtcbiAgcmlnaHQgPSAoKHJpZ2h0IDw8IDEpIHwgKHJpZ2h0ID4+PiAzMSkpO1xuXG4gIGZvcih2YXIgaiA9IDA7IGogPCBpdGVyYXRpb25zOyBqICs9IDMpIHtcbiAgICB2YXIgZW5kbG9vcCA9IGxvb3BpbmdbaiArIDFdO1xuICAgIHZhciBsb29waW5jID0gbG9vcGluZ1tqICsgMl07XG5cbiAgICAvLyBub3cgZ28gdGhyb3VnaCBhbmQgcGVyZm9ybSB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uXG4gICAgZm9yKHZhciBpID0gbG9vcGluZ1tqXTsgaSAhPSBlbmRsb29wOyBpICs9IGxvb3BpbmMpIHtcbiAgICAgIHZhciByaWdodDEgPSByaWdodCBeIGtleXNbaV07XG4gICAgICB2YXIgcmlnaHQyID0gKChyaWdodCA+Pj4gNCkgfCAocmlnaHQgPDwgMjgpKSBeIGtleXNbaSArIDFdO1xuXG4gICAgICAvLyBwYXNzaW5nIHRoZXNlIGJ5dGVzIHRocm91Z2ggdGhlIFMgc2VsZWN0aW9uIGZ1bmN0aW9uc1xuICAgICAgdG1wID0gbGVmdDtcbiAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgIHJpZ2h0ID0gdG1wIF4gKFxuICAgICAgICBzcGZ1bmN0aW9uMlsocmlnaHQxID4+PiAyNCkgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb240WyhyaWdodDEgPj4+IDE2KSAmIDB4M2ZdIHxcbiAgICAgICAgc3BmdW5jdGlvbjZbKHJpZ2h0MSA+Pj4gIDgpICYgMHgzZl0gfFxuICAgICAgICBzcGZ1bmN0aW9uOFtyaWdodDEgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb24xWyhyaWdodDIgPj4+IDI0KSAmIDB4M2ZdIHxcbiAgICAgICAgc3BmdW5jdGlvbjNbKHJpZ2h0MiA+Pj4gMTYpICYgMHgzZl0gfFxuICAgICAgICBzcGZ1bmN0aW9uNVsocmlnaHQyID4+PiAgOCkgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb243W3JpZ2h0MiAmIDB4M2ZdKTtcbiAgICB9XG4gICAgLy8gdW5yZXZlcnNlIGxlZnQgYW5kIHJpZ2h0XG4gICAgdG1wID0gbGVmdDtcbiAgICBsZWZ0ID0gcmlnaHQ7XG4gICAgcmlnaHQgPSB0bXA7XG4gIH1cblxuICAvLyByb3RhdGUgcmlnaHQgMSBiaXRcbiAgbGVmdCA9ICgobGVmdCA+Pj4gMSkgfCAobGVmdCA8PCAzMSkpO1xuICByaWdodCA9ICgocmlnaHQgPj4+IDEpIHwgKHJpZ2h0IDw8IDMxKSk7XG5cbiAgLy8gbm93IHBlcmZvcm0gSVAtMSwgd2hpY2ggaXMgSVAgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICB0bXAgPSAoKGxlZnQgPj4+IDEpIF4gcmlnaHQpICYgMHg1NTU1NTU1NTtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgMSk7XG5cbiAgdG1wID0gKChyaWdodCA+Pj4gOCkgXiBsZWZ0KSAmIDB4MDBmZjAwZmY7XG4gIGxlZnQgXj0gdG1wO1xuICByaWdodCBePSAodG1wIDw8IDgpO1xuXG4gIHRtcCA9ICgocmlnaHQgPj4+IDIpIF4gbGVmdCkgJiAweDMzMzMzMzMzO1xuICBsZWZ0IF49IHRtcDtcbiAgcmlnaHQgXj0gKHRtcCA8PCAyKTtcblxuICB0bXAgPSAoKGxlZnQgPj4+IDE2KSBeIHJpZ2h0KSAmIDB4MDAwMGZmZmY7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDE2KTtcblxuICB0bXAgPSAoKGxlZnQgPj4+IDQpIF4gcmlnaHQpICYgMHgwZjBmMGYwZjtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgNCk7XG5cbiAgb3V0cHV0WzBdID0gbGVmdDtcbiAgb3V0cHV0WzFdID0gcmlnaHQ7XG59XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0RFUy08bW9kZT4nLCBrZXkpO1xuICogZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdERVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGEgZGVwcmVjYXRlZCBERVMgY2lwaGVyIG9iamVjdC4gVGhpcyBvYmplY3QncyBtb2RlIHdpbGwgZGVmYXVsdCB0b1xuICogQ0JDIChjaXBoZXItYmxvY2stY2hhaW5pbmcpLlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogICAgICAgICAgb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8uXG4gKiAgICAgICAgICBkZWNyeXB0IHRydWUgZm9yIGRlY3J5cHRpb24sIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICogICAgICAgICAgbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mdW5jdGlvbiBfY3JlYXRlQ2lwaGVyKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBtb2RlID0gKG9wdGlvbnMubW9kZSB8fCAnQ0JDJykudG9VcHBlckNhc2UoKTtcbiAgdmFyIGFsZ29yaXRobSA9ICdERVMtJyArIG1vZGU7XG5cbiAgdmFyIGNpcGhlcjtcbiAgaWYob3B0aW9ucy5kZWNyeXB0KSB7XG4gICAgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKGFsZ29yaXRobSwgb3B0aW9ucy5rZXkpO1xuICB9IGVsc2Uge1xuICAgIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoYWxnb3JpdGhtLCBvcHRpb25zLmtleSk7XG4gIH1cblxuICAvLyBiYWNrd2FyZHMgY29tcGF0aWJsZSBzdGFydCBBUElcbiAgdmFyIHN0YXJ0ID0gY2lwaGVyLnN0YXJ0O1xuICBjaXBoZXIuc3RhcnQgPSBmdW5jdGlvbihpdiwgb3B0aW9ucykge1xuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBzdXBwb3J0IHNlY29uZCBhcmcgYXMgb3V0cHV0IGJ1ZmZlclxuICAgIHZhciBvdXRwdXQgPSBudWxsO1xuICAgIGlmKG9wdGlvbnMgaW5zdGFuY2VvZiBmb3JnZS51dGlsLkJ5dGVCdWZmZXIpIHtcbiAgICAgIG91dHB1dCA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMub3V0cHV0ID0gb3V0cHV0O1xuICAgIG9wdGlvbnMuaXYgPSBpdjtcbiAgICBzdGFydC5jYWxsKGNpcGhlciwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIGNpcGhlcjtcbn1cbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiZGVzIiwic3RhcnRFbmNyeXB0aW5nIiwia2V5IiwiaXYiLCJvdXRwdXQiLCJtb2RlIiwiY2lwaGVyIiwiX2NyZWF0ZUNpcGhlciIsImRlY3J5cHQiLCJzdGFydCIsImNyZWF0ZUVuY3J5cHRpb25DaXBoZXIiLCJzdGFydERlY3J5cHRpbmciLCJjcmVhdGVEZWNyeXB0aW9uQ2lwaGVyIiwiQWxnb3JpdGhtIiwibmFtZSIsInNlbGYiLCJibG9ja1NpemUiLCJlbmNyeXB0IiwiaW5CbG9jayIsIm91dEJsb2NrIiwiX3VwZGF0ZUJsb2NrIiwiX2tleXMiLCJfaW5pdCIsInByb3RvdHlwZSIsImluaXRpYWxpemUiLCJvcHRpb25zIiwidXRpbCIsImNyZWF0ZUJ1ZmZlciIsImluZGV4T2YiLCJsZW5ndGgiLCJFcnJvciIsIl9jcmVhdGVLZXlzIiwicmVnaXN0ZXJBbGdvcml0aG0iLCJtb2RlcyIsImVjYiIsImNiYyIsImNmYiIsIm9mYiIsImN0ciIsImZhY3RvcnkiLCJzcGZ1bmN0aW9uMSIsInNwZnVuY3Rpb24yIiwic3BmdW5jdGlvbjMiLCJzcGZ1bmN0aW9uNCIsInNwZnVuY3Rpb241Iiwic3BmdW5jdGlvbjYiLCJzcGZ1bmN0aW9uNyIsInNwZnVuY3Rpb244IiwicGMyYnl0ZXMwIiwicGMyYnl0ZXMxIiwicGMyYnl0ZXMyIiwicGMyYnl0ZXMzIiwicGMyYnl0ZXM0IiwicGMyYnl0ZXM1IiwicGMyYnl0ZXM2IiwicGMyYnl0ZXM3IiwicGMyYnl0ZXM4IiwicGMyYnl0ZXM5IiwicGMyYnl0ZXMxMCIsInBjMmJ5dGVzMTEiLCJwYzJieXRlczEyIiwicGMyYnl0ZXMxMyIsIml0ZXJhdGlvbnMiLCJrZXlzIiwic2hpZnRzIiwibiIsInRtcCIsImoiLCJsZWZ0IiwiZ2V0SW50MzIiLCJyaWdodCIsImkiLCJsZWZ0dG1wIiwicmlnaHR0bXAiLCJpbnB1dCIsImxvb3BpbmciLCJlbmRsb29wIiwibG9vcGluYyIsInJpZ2h0MSIsInJpZ2h0MiIsInRvVXBwZXJDYXNlIiwiYWxnb3JpdGhtIiwiY3JlYXRlRGVjaXBoZXIiLCJjcmVhdGVDaXBoZXIiLCJCeXRlQnVmZmVyIiwiY2FsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/des.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/ed25519.js":
/*!************************************************!*\
  !*** ./node_modules/node-forge/lib/ed25519.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * JavaScript implementation of Ed25519.\n *\n * Copyright (c) 2017-2019 Digital Bazaar, Inc.\n *\n * This implementation is based on the most excellent TweetNaCl which is\n * in the public domain. Many thanks to its contributors:\n *\n * https://github.com/dchest/tweetnacl-js\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./jsbn */ \"(rsc)/./node_modules/node-forge/lib/jsbn.js\");\n__webpack_require__(/*! ./random */ \"(rsc)/./node_modules/node-forge/lib/random.js\");\n__webpack_require__(/*! ./sha512 */ \"(rsc)/./node_modules/node-forge/lib/sha512.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\nvar asn1Validator = __webpack_require__(/*! ./asn1-validator */ \"(rsc)/./node_modules/node-forge/lib/asn1-validator.js\");\nvar publicKeyValidator = asn1Validator.publicKeyValidator;\nvar privateKeyValidator = asn1Validator.privateKeyValidator;\nif (typeof BigInteger === \"undefined\") {\n    var BigInteger = forge.jsbn.BigInteger;\n}\nvar ByteBuffer = forge.util.ByteBuffer;\nvar NativeBuffer = typeof Buffer === \"undefined\" ? Uint8Array : Buffer;\n/*\n * Ed25519 algorithms, see RFC 8032:\n * https://tools.ietf.org/html/rfc8032\n */ forge.pki = forge.pki || {};\nmodule.exports = forge.pki.ed25519 = forge.ed25519 = forge.ed25519 || {};\nvar ed25519 = forge.ed25519;\ned25519.constants = {};\ned25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;\ned25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;\ned25519.constants.SEED_BYTE_LENGTH = 32;\ned25519.constants.SIGN_BYTE_LENGTH = 64;\ned25519.constants.HASH_BYTE_LENGTH = 64;\ned25519.generateKeyPair = function(options) {\n    options = options || {};\n    var seed = options.seed;\n    if (seed === undefined) {\n        // generate seed\n        seed = forge.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);\n    } else if (typeof seed === \"string\") {\n        if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {\n            throw new TypeError('\"seed\" must be ' + ed25519.constants.SEED_BYTE_LENGTH + \" bytes in length.\");\n        }\n    } else if (!(seed instanceof Uint8Array)) {\n        throw new TypeError('\"seed\" must be a node.js Buffer, Uint8Array, or a binary string.');\n    }\n    seed = messageToNativeBuffer({\n        message: seed,\n        encoding: \"binary\"\n    });\n    var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);\n    var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);\n    for(var i = 0; i < 32; ++i){\n        sk[i] = seed[i];\n    }\n    crypto_sign_keypair(pk, sk);\n    return {\n        publicKey: pk,\n        privateKey: sk\n    };\n};\n/**\n * Converts a private key from a RFC8410 ASN.1 encoding.\n *\n * @param obj - The asn1 representation of a private key.\n *\n * @returns {Object} keyInfo - The key information.\n * @returns {Buffer|Uint8Array} keyInfo.privateKeyBytes - 32 private key bytes.\n */ ed25519.privateKeyFromAsn1 = function(obj) {\n    var capture = {};\n    var errors = [];\n    var valid = forge.asn1.validate(obj, privateKeyValidator, capture, errors);\n    if (!valid) {\n        var error = new Error(\"Invalid Key.\");\n        error.errors = errors;\n        throw error;\n    }\n    var oid = forge.asn1.derToOid(capture.privateKeyOid);\n    var ed25519Oid = forge.oids.EdDSA25519;\n    if (oid !== ed25519Oid) {\n        throw new Error('Invalid OID \"' + oid + '\"; OID must be \"' + ed25519Oid + '\".');\n    }\n    var privateKey = capture.privateKey;\n    // manually extract the private key bytes from nested octet string, see FIXME:\n    // https://github.com/digitalbazaar/forge/blob/master/lib/asn1.js#L542\n    var privateKeyBytes = messageToNativeBuffer({\n        message: forge.asn1.fromDer(privateKey).value,\n        encoding: \"binary\"\n    });\n    // TODO: RFC8410 specifies a format for encoding the public key bytes along\n    // with the private key bytes. `publicKeyBytes` can be returned in the\n    // future. https://tools.ietf.org/html/rfc8410#section-10.3\n    return {\n        privateKeyBytes: privateKeyBytes\n    };\n};\n/**\n * Converts a public key from a RFC8410 ASN.1 encoding.\n *\n * @param obj - The asn1 representation of a public key.\n *\n * @return {Buffer|Uint8Array} - 32 public key bytes.\n */ ed25519.publicKeyFromAsn1 = function(obj) {\n    // get SubjectPublicKeyInfo\n    var capture = {};\n    var errors = [];\n    var valid = forge.asn1.validate(obj, publicKeyValidator, capture, errors);\n    if (!valid) {\n        var error = new Error(\"Invalid Key.\");\n        error.errors = errors;\n        throw error;\n    }\n    var oid = forge.asn1.derToOid(capture.publicKeyOid);\n    var ed25519Oid = forge.oids.EdDSA25519;\n    if (oid !== ed25519Oid) {\n        throw new Error('Invalid OID \"' + oid + '\"; OID must be \"' + ed25519Oid + '\".');\n    }\n    var publicKeyBytes = capture.ed25519PublicKey;\n    if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {\n        throw new Error(\"Key length is invalid.\");\n    }\n    return messageToNativeBuffer({\n        message: publicKeyBytes,\n        encoding: \"binary\"\n    });\n};\ned25519.publicKeyFromPrivateKey = function(options) {\n    options = options || {};\n    var privateKey = messageToNativeBuffer({\n        message: options.privateKey,\n        encoding: \"binary\"\n    });\n    if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {\n        throw new TypeError('\"options.privateKey\" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);\n    }\n    var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);\n    for(var i = 0; i < pk.length; ++i){\n        pk[i] = privateKey[32 + i];\n    }\n    return pk;\n};\ned25519.sign = function(options) {\n    options = options || {};\n    var msg = messageToNativeBuffer(options);\n    var privateKey = messageToNativeBuffer({\n        message: options.privateKey,\n        encoding: \"binary\"\n    });\n    if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {\n        var keyPair = ed25519.generateKeyPair({\n            seed: privateKey\n        });\n        privateKey = keyPair.privateKey;\n    } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {\n        throw new TypeError('\"options.privateKey\" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + \" or \" + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);\n    }\n    var signedMsg = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);\n    crypto_sign(signedMsg, msg, msg.length, privateKey);\n    var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);\n    for(var i = 0; i < sig.length; ++i){\n        sig[i] = signedMsg[i];\n    }\n    return sig;\n};\ned25519.verify = function(options) {\n    options = options || {};\n    var msg = messageToNativeBuffer(options);\n    if (options.signature === undefined) {\n        throw new TypeError('\"options.signature\" must be a node.js Buffer, a Uint8Array, a forge ' + \"ByteBuffer, or a binary string.\");\n    }\n    var sig = messageToNativeBuffer({\n        message: options.signature,\n        encoding: \"binary\"\n    });\n    if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {\n        throw new TypeError('\"options.signature\" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH);\n    }\n    var publicKey = messageToNativeBuffer({\n        message: options.publicKey,\n        encoding: \"binary\"\n    });\n    if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {\n        throw new TypeError('\"options.publicKey\" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);\n    }\n    var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);\n    var m = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);\n    var i;\n    for(i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i){\n        sm[i] = sig[i];\n    }\n    for(i = 0; i < msg.length; ++i){\n        sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i];\n    }\n    return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;\n};\nfunction messageToNativeBuffer(options) {\n    var message = options.message;\n    if (message instanceof Uint8Array || message instanceof NativeBuffer) {\n        return message;\n    }\n    var encoding = options.encoding;\n    if (message === undefined) {\n        if (options.md) {\n            // TODO: more rigorous validation that `md` is a MessageDigest\n            message = options.md.digest().getBytes();\n            encoding = \"binary\";\n        } else {\n            throw new TypeError('\"options.message\" or \"options.md\" not specified.');\n        }\n    }\n    if (typeof message === \"string\" && !encoding) {\n        throw new TypeError('\"options.encoding\" must be \"binary\" or \"utf8\".');\n    }\n    if (typeof message === \"string\") {\n        if (typeof Buffer !== \"undefined\") {\n            return Buffer.from(message, encoding);\n        }\n        message = new ByteBuffer(message, encoding);\n    } else if (!(message instanceof ByteBuffer)) {\n        throw new TypeError('\"options.message\" must be a node.js Buffer, a Uint8Array, a forge ' + 'ByteBuffer, or a string with \"options.encoding\" specifying its ' + \"encoding.\");\n    }\n    // convert to native buffer\n    var buffer = new NativeBuffer(message.length());\n    for(var i = 0; i < buffer.length; ++i){\n        buffer[i] = message.at(i);\n    }\n    return buffer;\n}\nvar gf0 = gf();\nvar gf1 = gf([\n    1\n]);\nvar D = gf([\n    0x78a3,\n    0x1359,\n    0x4dca,\n    0x75eb,\n    0xd8ab,\n    0x4141,\n    0x0a4d,\n    0x0070,\n    0xe898,\n    0x7779,\n    0x4079,\n    0x8cc7,\n    0xfe73,\n    0x2b6f,\n    0x6cee,\n    0x5203\n]);\nvar D2 = gf([\n    0xf159,\n    0x26b2,\n    0x9b94,\n    0xebd6,\n    0xb156,\n    0x8283,\n    0x149a,\n    0x00e0,\n    0xd130,\n    0xeef3,\n    0x80f2,\n    0x198e,\n    0xfce7,\n    0x56df,\n    0xd9dc,\n    0x2406\n]);\nvar X = gf([\n    0xd51a,\n    0x8f25,\n    0x2d60,\n    0xc956,\n    0xa7b2,\n    0x9525,\n    0xc760,\n    0x692c,\n    0xdc5c,\n    0xfdd6,\n    0xe231,\n    0xc0a4,\n    0x53fe,\n    0xcd6e,\n    0x36d3,\n    0x2169\n]);\nvar Y = gf([\n    0x6658,\n    0x6666,\n    0x6666,\n    0x6666,\n    0x6666,\n    0x6666,\n    0x6666,\n    0x6666,\n    0x6666,\n    0x6666,\n    0x6666,\n    0x6666,\n    0x6666,\n    0x6666,\n    0x6666,\n    0x6666\n]);\nvar L = new Float64Array([\n    0xed,\n    0xd3,\n    0xf5,\n    0x5c,\n    0x1a,\n    0x63,\n    0x12,\n    0x58,\n    0xd6,\n    0x9c,\n    0xf7,\n    0xa2,\n    0xde,\n    0xf9,\n    0xde,\n    0x14,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0x10\n]);\nvar I = gf([\n    0xa0b0,\n    0x4a0e,\n    0x1b27,\n    0xc4ee,\n    0xe478,\n    0xad2f,\n    0x1806,\n    0x2f43,\n    0xd7a7,\n    0x3dfb,\n    0x0099,\n    0x2b4d,\n    0xdf0b,\n    0x4fc1,\n    0x2480,\n    0x2b83\n]);\n// TODO: update forge buffer implementation to use `Buffer` or `Uint8Array`,\n// whichever is available, to improve performance\nfunction sha512(msg, msgLen) {\n    // Note: `out` and `msg` are NativeBuffer\n    var md = forge.md.sha512.create();\n    var buffer = new ByteBuffer(msg);\n    md.update(buffer.getBytes(msgLen), \"binary\");\n    var hash = md.digest().getBytes();\n    if (typeof Buffer !== \"undefined\") {\n        return Buffer.from(hash, \"binary\");\n    }\n    var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);\n    for(var i = 0; i < 64; ++i){\n        out[i] = hash.charCodeAt(i);\n    }\n    return out;\n}\nfunction crypto_sign_keypair(pk, sk) {\n    var p = [\n        gf(),\n        gf(),\n        gf(),\n        gf()\n    ];\n    var i;\n    var d = sha512(sk, 32);\n    d[0] &= 248;\n    d[31] &= 127;\n    d[31] |= 64;\n    scalarbase(p, d);\n    pack(pk, p);\n    for(i = 0; i < 32; ++i){\n        sk[i + 32] = pk[i];\n    }\n    return 0;\n}\n// Note: difference from C - smlen returned, not passed as argument.\nfunction crypto_sign(sm, m, n, sk) {\n    var i, j, x = new Float64Array(64);\n    var p = [\n        gf(),\n        gf(),\n        gf(),\n        gf()\n    ];\n    var d = sha512(sk, 32);\n    d[0] &= 248;\n    d[31] &= 127;\n    d[31] |= 64;\n    var smlen = n + 64;\n    for(i = 0; i < n; ++i){\n        sm[64 + i] = m[i];\n    }\n    for(i = 0; i < 32; ++i){\n        sm[32 + i] = d[32 + i];\n    }\n    var r = sha512(sm.subarray(32), n + 32);\n    reduce(r);\n    scalarbase(p, r);\n    pack(sm, p);\n    for(i = 32; i < 64; ++i){\n        sm[i] = sk[i];\n    }\n    var h = sha512(sm, n + 64);\n    reduce(h);\n    for(i = 32; i < 64; ++i){\n        x[i] = 0;\n    }\n    for(i = 0; i < 32; ++i){\n        x[i] = r[i];\n    }\n    for(i = 0; i < 32; ++i){\n        for(j = 0; j < 32; j++){\n            x[i + j] += h[i] * d[j];\n        }\n    }\n    modL(sm.subarray(32), x);\n    return smlen;\n}\nfunction crypto_sign_open(m, sm, n, pk) {\n    var i, mlen;\n    var t = new NativeBuffer(32);\n    var p = [\n        gf(),\n        gf(),\n        gf(),\n        gf()\n    ], q = [\n        gf(),\n        gf(),\n        gf(),\n        gf()\n    ];\n    mlen = -1;\n    if (n < 64) {\n        return -1;\n    }\n    if (unpackneg(q, pk)) {\n        return -1;\n    }\n    for(i = 0; i < n; ++i){\n        m[i] = sm[i];\n    }\n    for(i = 0; i < 32; ++i){\n        m[i + 32] = pk[i];\n    }\n    var h = sha512(m, n);\n    reduce(h);\n    scalarmult(p, q, h);\n    scalarbase(q, sm.subarray(32));\n    add(p, q);\n    pack(t, p);\n    n -= 64;\n    if (crypto_verify_32(sm, 0, t, 0)) {\n        for(i = 0; i < n; ++i){\n            m[i] = 0;\n        }\n        return -1;\n    }\n    for(i = 0; i < n; ++i){\n        m[i] = sm[i + 64];\n    }\n    mlen = n;\n    return mlen;\n}\nfunction modL(r, x) {\n    var carry, i, j, k;\n    for(i = 63; i >= 32; --i){\n        carry = 0;\n        for(j = i - 32, k = i - 12; j < k; ++j){\n            x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n            carry = x[j] + 128 >> 8;\n            x[j] -= carry * 256;\n        }\n        x[j] += carry;\n        x[i] = 0;\n    }\n    carry = 0;\n    for(j = 0; j < 32; ++j){\n        x[j] += carry - (x[31] >> 4) * L[j];\n        carry = x[j] >> 8;\n        x[j] &= 255;\n    }\n    for(j = 0; j < 32; ++j){\n        x[j] -= carry * L[j];\n    }\n    for(i = 0; i < 32; ++i){\n        x[i + 1] += x[i] >> 8;\n        r[i] = x[i] & 255;\n    }\n}\nfunction reduce(r) {\n    var x = new Float64Array(64);\n    for(var i = 0; i < 64; ++i){\n        x[i] = r[i];\n        r[i] = 0;\n    }\n    modL(r, x);\n}\nfunction add(p, q) {\n    var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();\n    Z(a, p[1], p[0]);\n    Z(t, q[1], q[0]);\n    M(a, a, t);\n    A(b, p[0], p[1]);\n    A(t, q[0], q[1]);\n    M(b, b, t);\n    M(c, p[3], q[3]);\n    M(c, c, D2);\n    M(d, p[2], q[2]);\n    A(d, d, d);\n    Z(e, b, a);\n    Z(f, d, c);\n    A(g, d, c);\n    A(h, b, a);\n    M(p[0], e, f);\n    M(p[1], h, g);\n    M(p[2], g, f);\n    M(p[3], e, h);\n}\nfunction cswap(p, q, b) {\n    for(var i = 0; i < 4; ++i){\n        sel25519(p[i], q[i], b);\n    }\n}\nfunction pack(r, p) {\n    var tx = gf(), ty = gf(), zi = gf();\n    inv25519(zi, p[2]);\n    M(tx, p[0], zi);\n    M(ty, p[1], zi);\n    pack25519(r, ty);\n    r[31] ^= par25519(tx) << 7;\n}\nfunction pack25519(o, n) {\n    var i, j, b;\n    var m = gf(), t = gf();\n    for(i = 0; i < 16; ++i){\n        t[i] = n[i];\n    }\n    car25519(t);\n    car25519(t);\n    car25519(t);\n    for(j = 0; j < 2; ++j){\n        m[0] = t[0] - 0xffed;\n        for(i = 1; i < 15; ++i){\n            m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);\n            m[i - 1] &= 0xffff;\n        }\n        m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);\n        b = m[15] >> 16 & 1;\n        m[14] &= 0xffff;\n        sel25519(t, m, 1 - b);\n    }\n    for(i = 0; i < 16; i++){\n        o[2 * i] = t[i] & 0xff;\n        o[2 * i + 1] = t[i] >> 8;\n    }\n}\nfunction unpackneg(r, p) {\n    var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();\n    set25519(r[2], gf1);\n    unpack25519(r[1], p);\n    S(num, r[1]);\n    M(den, num, D);\n    Z(num, num, r[2]);\n    A(den, r[2], den);\n    S(den2, den);\n    S(den4, den2);\n    M(den6, den4, den2);\n    M(t, den6, num);\n    M(t, t, den);\n    pow2523(t, t);\n    M(t, t, num);\n    M(t, t, den);\n    M(t, t, den);\n    M(r[0], t, den);\n    S(chk, r[0]);\n    M(chk, chk, den);\n    if (neq25519(chk, num)) {\n        M(r[0], r[0], I);\n    }\n    S(chk, r[0]);\n    M(chk, chk, den);\n    if (neq25519(chk, num)) {\n        return -1;\n    }\n    if (par25519(r[0]) === p[31] >> 7) {\n        Z(r[0], gf0, r[0]);\n    }\n    M(r[3], r[0], r[1]);\n    return 0;\n}\nfunction unpack25519(o, n) {\n    var i;\n    for(i = 0; i < 16; ++i){\n        o[i] = n[2 * i] + (n[2 * i + 1] << 8);\n    }\n    o[15] &= 0x7fff;\n}\nfunction pow2523(o, i) {\n    var c = gf();\n    var a;\n    for(a = 0; a < 16; ++a){\n        c[a] = i[a];\n    }\n    for(a = 250; a >= 0; --a){\n        S(c, c);\n        if (a !== 1) {\n            M(c, c, i);\n        }\n    }\n    for(a = 0; a < 16; ++a){\n        o[a] = c[a];\n    }\n}\nfunction neq25519(a, b) {\n    var c = new NativeBuffer(32);\n    var d = new NativeBuffer(32);\n    pack25519(c, a);\n    pack25519(d, b);\n    return crypto_verify_32(c, 0, d, 0);\n}\nfunction crypto_verify_32(x, xi, y, yi) {\n    return vn(x, xi, y, yi, 32);\n}\nfunction vn(x, xi, y, yi, n) {\n    var i, d = 0;\n    for(i = 0; i < n; ++i){\n        d |= x[xi + i] ^ y[yi + i];\n    }\n    return (1 & d - 1 >>> 8) - 1;\n}\nfunction par25519(a) {\n    var d = new NativeBuffer(32);\n    pack25519(d, a);\n    return d[0] & 1;\n}\nfunction scalarmult(p, q, s) {\n    var b, i;\n    set25519(p[0], gf0);\n    set25519(p[1], gf1);\n    set25519(p[2], gf1);\n    set25519(p[3], gf0);\n    for(i = 255; i >= 0; --i){\n        b = s[i / 8 | 0] >> (i & 7) & 1;\n        cswap(p, q, b);\n        add(q, p);\n        add(p, p);\n        cswap(p, q, b);\n    }\n}\nfunction scalarbase(p, s) {\n    var q = [\n        gf(),\n        gf(),\n        gf(),\n        gf()\n    ];\n    set25519(q[0], X);\n    set25519(q[1], Y);\n    set25519(q[2], gf1);\n    M(q[3], X, Y);\n    scalarmult(p, q, s);\n}\nfunction set25519(r, a) {\n    var i;\n    for(i = 0; i < 16; i++){\n        r[i] = a[i] | 0;\n    }\n}\nfunction inv25519(o, i) {\n    var c = gf();\n    var a;\n    for(a = 0; a < 16; ++a){\n        c[a] = i[a];\n    }\n    for(a = 253; a >= 0; --a){\n        S(c, c);\n        if (a !== 2 && a !== 4) {\n            M(c, c, i);\n        }\n    }\n    for(a = 0; a < 16; ++a){\n        o[a] = c[a];\n    }\n}\nfunction car25519(o) {\n    var i, v, c = 1;\n    for(i = 0; i < 16; ++i){\n        v = o[i] + c + 65535;\n        c = Math.floor(v / 65536);\n        o[i] = v - c * 65536;\n    }\n    o[0] += c - 1 + 37 * (c - 1);\n}\nfunction sel25519(p, q, b) {\n    var t, c = ~(b - 1);\n    for(var i = 0; i < 16; ++i){\n        t = c & (p[i] ^ q[i]);\n        p[i] ^= t;\n        q[i] ^= t;\n    }\n}\nfunction gf(init) {\n    var i, r = new Float64Array(16);\n    if (init) {\n        for(i = 0; i < init.length; ++i){\n            r[i] = init[i];\n        }\n    }\n    return r;\n}\nfunction A(o, a, b) {\n    for(var i = 0; i < 16; ++i){\n        o[i] = a[i] + b[i];\n    }\n}\nfunction Z(o, a, b) {\n    for(var i = 0; i < 16; ++i){\n        o[i] = a[i] - b[i];\n    }\n}\nfunction S(o, a) {\n    M(o, a, a);\n}\nfunction M(o, a, b) {\n    var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];\n    v = a[0];\n    t0 += v * b0;\n    t1 += v * b1;\n    t2 += v * b2;\n    t3 += v * b3;\n    t4 += v * b4;\n    t5 += v * b5;\n    t6 += v * b6;\n    t7 += v * b7;\n    t8 += v * b8;\n    t9 += v * b9;\n    t10 += v * b10;\n    t11 += v * b11;\n    t12 += v * b12;\n    t13 += v * b13;\n    t14 += v * b14;\n    t15 += v * b15;\n    v = a[1];\n    t1 += v * b0;\n    t2 += v * b1;\n    t3 += v * b2;\n    t4 += v * b3;\n    t5 += v * b4;\n    t6 += v * b5;\n    t7 += v * b6;\n    t8 += v * b7;\n    t9 += v * b8;\n    t10 += v * b9;\n    t11 += v * b10;\n    t12 += v * b11;\n    t13 += v * b12;\n    t14 += v * b13;\n    t15 += v * b14;\n    t16 += v * b15;\n    v = a[2];\n    t2 += v * b0;\n    t3 += v * b1;\n    t4 += v * b2;\n    t5 += v * b3;\n    t6 += v * b4;\n    t7 += v * b5;\n    t8 += v * b6;\n    t9 += v * b7;\n    t10 += v * b8;\n    t11 += v * b9;\n    t12 += v * b10;\n    t13 += v * b11;\n    t14 += v * b12;\n    t15 += v * b13;\n    t16 += v * b14;\n    t17 += v * b15;\n    v = a[3];\n    t3 += v * b0;\n    t4 += v * b1;\n    t5 += v * b2;\n    t6 += v * b3;\n    t7 += v * b4;\n    t8 += v * b5;\n    t9 += v * b6;\n    t10 += v * b7;\n    t11 += v * b8;\n    t12 += v * b9;\n    t13 += v * b10;\n    t14 += v * b11;\n    t15 += v * b12;\n    t16 += v * b13;\n    t17 += v * b14;\n    t18 += v * b15;\n    v = a[4];\n    t4 += v * b0;\n    t5 += v * b1;\n    t6 += v * b2;\n    t7 += v * b3;\n    t8 += v * b4;\n    t9 += v * b5;\n    t10 += v * b6;\n    t11 += v * b7;\n    t12 += v * b8;\n    t13 += v * b9;\n    t14 += v * b10;\n    t15 += v * b11;\n    t16 += v * b12;\n    t17 += v * b13;\n    t18 += v * b14;\n    t19 += v * b15;\n    v = a[5];\n    t5 += v * b0;\n    t6 += v * b1;\n    t7 += v * b2;\n    t8 += v * b3;\n    t9 += v * b4;\n    t10 += v * b5;\n    t11 += v * b6;\n    t12 += v * b7;\n    t13 += v * b8;\n    t14 += v * b9;\n    t15 += v * b10;\n    t16 += v * b11;\n    t17 += v * b12;\n    t18 += v * b13;\n    t19 += v * b14;\n    t20 += v * b15;\n    v = a[6];\n    t6 += v * b0;\n    t7 += v * b1;\n    t8 += v * b2;\n    t9 += v * b3;\n    t10 += v * b4;\n    t11 += v * b5;\n    t12 += v * b6;\n    t13 += v * b7;\n    t14 += v * b8;\n    t15 += v * b9;\n    t16 += v * b10;\n    t17 += v * b11;\n    t18 += v * b12;\n    t19 += v * b13;\n    t20 += v * b14;\n    t21 += v * b15;\n    v = a[7];\n    t7 += v * b0;\n    t8 += v * b1;\n    t9 += v * b2;\n    t10 += v * b3;\n    t11 += v * b4;\n    t12 += v * b5;\n    t13 += v * b6;\n    t14 += v * b7;\n    t15 += v * b8;\n    t16 += v * b9;\n    t17 += v * b10;\n    t18 += v * b11;\n    t19 += v * b12;\n    t20 += v * b13;\n    t21 += v * b14;\n    t22 += v * b15;\n    v = a[8];\n    t8 += v * b0;\n    t9 += v * b1;\n    t10 += v * b2;\n    t11 += v * b3;\n    t12 += v * b4;\n    t13 += v * b5;\n    t14 += v * b6;\n    t15 += v * b7;\n    t16 += v * b8;\n    t17 += v * b9;\n    t18 += v * b10;\n    t19 += v * b11;\n    t20 += v * b12;\n    t21 += v * b13;\n    t22 += v * b14;\n    t23 += v * b15;\n    v = a[9];\n    t9 += v * b0;\n    t10 += v * b1;\n    t11 += v * b2;\n    t12 += v * b3;\n    t13 += v * b4;\n    t14 += v * b5;\n    t15 += v * b6;\n    t16 += v * b7;\n    t17 += v * b8;\n    t18 += v * b9;\n    t19 += v * b10;\n    t20 += v * b11;\n    t21 += v * b12;\n    t22 += v * b13;\n    t23 += v * b14;\n    t24 += v * b15;\n    v = a[10];\n    t10 += v * b0;\n    t11 += v * b1;\n    t12 += v * b2;\n    t13 += v * b3;\n    t14 += v * b4;\n    t15 += v * b5;\n    t16 += v * b6;\n    t17 += v * b7;\n    t18 += v * b8;\n    t19 += v * b9;\n    t20 += v * b10;\n    t21 += v * b11;\n    t22 += v * b12;\n    t23 += v * b13;\n    t24 += v * b14;\n    t25 += v * b15;\n    v = a[11];\n    t11 += v * b0;\n    t12 += v * b1;\n    t13 += v * b2;\n    t14 += v * b3;\n    t15 += v * b4;\n    t16 += v * b5;\n    t17 += v * b6;\n    t18 += v * b7;\n    t19 += v * b8;\n    t20 += v * b9;\n    t21 += v * b10;\n    t22 += v * b11;\n    t23 += v * b12;\n    t24 += v * b13;\n    t25 += v * b14;\n    t26 += v * b15;\n    v = a[12];\n    t12 += v * b0;\n    t13 += v * b1;\n    t14 += v * b2;\n    t15 += v * b3;\n    t16 += v * b4;\n    t17 += v * b5;\n    t18 += v * b6;\n    t19 += v * b7;\n    t20 += v * b8;\n    t21 += v * b9;\n    t22 += v * b10;\n    t23 += v * b11;\n    t24 += v * b12;\n    t25 += v * b13;\n    t26 += v * b14;\n    t27 += v * b15;\n    v = a[13];\n    t13 += v * b0;\n    t14 += v * b1;\n    t15 += v * b2;\n    t16 += v * b3;\n    t17 += v * b4;\n    t18 += v * b5;\n    t19 += v * b6;\n    t20 += v * b7;\n    t21 += v * b8;\n    t22 += v * b9;\n    t23 += v * b10;\n    t24 += v * b11;\n    t25 += v * b12;\n    t26 += v * b13;\n    t27 += v * b14;\n    t28 += v * b15;\n    v = a[14];\n    t14 += v * b0;\n    t15 += v * b1;\n    t16 += v * b2;\n    t17 += v * b3;\n    t18 += v * b4;\n    t19 += v * b5;\n    t20 += v * b6;\n    t21 += v * b7;\n    t22 += v * b8;\n    t23 += v * b9;\n    t24 += v * b10;\n    t25 += v * b11;\n    t26 += v * b12;\n    t27 += v * b13;\n    t28 += v * b14;\n    t29 += v * b15;\n    v = a[15];\n    t15 += v * b0;\n    t16 += v * b1;\n    t17 += v * b2;\n    t18 += v * b3;\n    t19 += v * b4;\n    t20 += v * b5;\n    t21 += v * b6;\n    t22 += v * b7;\n    t23 += v * b8;\n    t24 += v * b9;\n    t25 += v * b10;\n    t26 += v * b11;\n    t27 += v * b12;\n    t28 += v * b13;\n    t29 += v * b14;\n    t30 += v * b15;\n    t0 += 38 * t16;\n    t1 += 38 * t17;\n    t2 += 38 * t18;\n    t3 += 38 * t19;\n    t4 += 38 * t20;\n    t5 += 38 * t21;\n    t6 += 38 * t22;\n    t7 += 38 * t23;\n    t8 += 38 * t24;\n    t9 += 38 * t25;\n    t10 += 38 * t26;\n    t11 += 38 * t27;\n    t12 += 38 * t28;\n    t13 += 38 * t29;\n    t14 += 38 * t30;\n    // t15 left as is\n    // first car\n    c = 1;\n    v = t0 + c + 65535;\n    c = Math.floor(v / 65536);\n    t0 = v - c * 65536;\n    v = t1 + c + 65535;\n    c = Math.floor(v / 65536);\n    t1 = v - c * 65536;\n    v = t2 + c + 65535;\n    c = Math.floor(v / 65536);\n    t2 = v - c * 65536;\n    v = t3 + c + 65535;\n    c = Math.floor(v / 65536);\n    t3 = v - c * 65536;\n    v = t4 + c + 65535;\n    c = Math.floor(v / 65536);\n    t4 = v - c * 65536;\n    v = t5 + c + 65535;\n    c = Math.floor(v / 65536);\n    t5 = v - c * 65536;\n    v = t6 + c + 65535;\n    c = Math.floor(v / 65536);\n    t6 = v - c * 65536;\n    v = t7 + c + 65535;\n    c = Math.floor(v / 65536);\n    t7 = v - c * 65536;\n    v = t8 + c + 65535;\n    c = Math.floor(v / 65536);\n    t8 = v - c * 65536;\n    v = t9 + c + 65535;\n    c = Math.floor(v / 65536);\n    t9 = v - c * 65536;\n    v = t10 + c + 65535;\n    c = Math.floor(v / 65536);\n    t10 = v - c * 65536;\n    v = t11 + c + 65535;\n    c = Math.floor(v / 65536);\n    t11 = v - c * 65536;\n    v = t12 + c + 65535;\n    c = Math.floor(v / 65536);\n    t12 = v - c * 65536;\n    v = t13 + c + 65535;\n    c = Math.floor(v / 65536);\n    t13 = v - c * 65536;\n    v = t14 + c + 65535;\n    c = Math.floor(v / 65536);\n    t14 = v - c * 65536;\n    v = t15 + c + 65535;\n    c = Math.floor(v / 65536);\n    t15 = v - c * 65536;\n    t0 += c - 1 + 37 * (c - 1);\n    // second car\n    c = 1;\n    v = t0 + c + 65535;\n    c = Math.floor(v / 65536);\n    t0 = v - c * 65536;\n    v = t1 + c + 65535;\n    c = Math.floor(v / 65536);\n    t1 = v - c * 65536;\n    v = t2 + c + 65535;\n    c = Math.floor(v / 65536);\n    t2 = v - c * 65536;\n    v = t3 + c + 65535;\n    c = Math.floor(v / 65536);\n    t3 = v - c * 65536;\n    v = t4 + c + 65535;\n    c = Math.floor(v / 65536);\n    t4 = v - c * 65536;\n    v = t5 + c + 65535;\n    c = Math.floor(v / 65536);\n    t5 = v - c * 65536;\n    v = t6 + c + 65535;\n    c = Math.floor(v / 65536);\n    t6 = v - c * 65536;\n    v = t7 + c + 65535;\n    c = Math.floor(v / 65536);\n    t7 = v - c * 65536;\n    v = t8 + c + 65535;\n    c = Math.floor(v / 65536);\n    t8 = v - c * 65536;\n    v = t9 + c + 65535;\n    c = Math.floor(v / 65536);\n    t9 = v - c * 65536;\n    v = t10 + c + 65535;\n    c = Math.floor(v / 65536);\n    t10 = v - c * 65536;\n    v = t11 + c + 65535;\n    c = Math.floor(v / 65536);\n    t11 = v - c * 65536;\n    v = t12 + c + 65535;\n    c = Math.floor(v / 65536);\n    t12 = v - c * 65536;\n    v = t13 + c + 65535;\n    c = Math.floor(v / 65536);\n    t13 = v - c * 65536;\n    v = t14 + c + 65535;\n    c = Math.floor(v / 65536);\n    t14 = v - c * 65536;\n    v = t15 + c + 65535;\n    c = Math.floor(v / 65536);\n    t15 = v - c * 65536;\n    t0 += c - 1 + 37 * (c - 1);\n    o[0] = t0;\n    o[1] = t1;\n    o[2] = t2;\n    o[3] = t3;\n    o[4] = t4;\n    o[5] = t5;\n    o[6] = t6;\n    o[7] = t7;\n    o[8] = t8;\n    o[9] = t9;\n    o[10] = t10;\n    o[11] = t11;\n    o[12] = t12;\n    o[13] = t13;\n    o[14] = t14;\n    o[15] = t15;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvZWQyNTUxOS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7O0NBU0M7QUFDRCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUixJQUFJQyxnQkFBZ0JELG1CQUFPQSxDQUFDO0FBQzVCLElBQUlFLHFCQUFxQkQsY0FBY0Msa0JBQWtCO0FBQ3pELElBQUlDLHNCQUFzQkYsY0FBY0UsbUJBQW1CO0FBRTNELElBQUcsT0FBT0MsZUFBZSxhQUFhO0lBQ3BDLElBQUlBLGFBQWFMLE1BQU1NLElBQUksQ0FBQ0QsVUFBVTtBQUN4QztBQUVBLElBQUlFLGFBQWFQLE1BQU1RLElBQUksQ0FBQ0QsVUFBVTtBQUN0QyxJQUFJRSxlQUFlLE9BQU9DLFdBQVcsY0FBY0MsYUFBYUQ7QUFFaEU7OztDQUdDLEdBQ0RWLE1BQU1ZLEdBQUcsR0FBR1osTUFBTVksR0FBRyxJQUFJLENBQUM7QUFDMUJDLE9BQU9DLE9BQU8sR0FBR2QsTUFBTVksR0FBRyxDQUFDRyxPQUFPLEdBQUdmLE1BQU1lLE9BQU8sR0FBR2YsTUFBTWUsT0FBTyxJQUFJLENBQUM7QUFDdkUsSUFBSUEsVUFBVWYsTUFBTWUsT0FBTztBQUUzQkEsUUFBUUMsU0FBUyxHQUFHLENBQUM7QUFDckJELFFBQVFDLFNBQVMsQ0FBQ0Msc0JBQXNCLEdBQUc7QUFDM0NGLFFBQVFDLFNBQVMsQ0FBQ0UsdUJBQXVCLEdBQUc7QUFDNUNILFFBQVFDLFNBQVMsQ0FBQ0csZ0JBQWdCLEdBQUc7QUFDckNKLFFBQVFDLFNBQVMsQ0FBQ0ksZ0JBQWdCLEdBQUc7QUFDckNMLFFBQVFDLFNBQVMsQ0FBQ0ssZ0JBQWdCLEdBQUc7QUFFckNOLFFBQVFPLGVBQWUsR0FBRyxTQUFTQyxPQUFPO0lBQ3hDQSxVQUFVQSxXQUFXLENBQUM7SUFDdEIsSUFB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ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2VkMjU1MTkuanM/NDhkOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgRWQyNTUxOS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctMjAxOSBEaWdpdGFsIEJhemFhciwgSW5jLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdGhlIG1vc3QgZXhjZWxsZW50IFR3ZWV0TmFDbCB3aGljaCBpc1xuICogaW4gdGhlIHB1YmxpYyBkb21haW4uIE1hbnkgdGhhbmtzIHRvIGl0cyBjb250cmlidXRvcnM6XG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2RjaGVzdC90d2VldG5hY2wtanNcbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9qc2JuJyk7XG5yZXF1aXJlKCcuL3JhbmRvbScpO1xucmVxdWlyZSgnLi9zaGE1MTInKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGFzbjFWYWxpZGF0b3IgPSByZXF1aXJlKCcuL2FzbjEtdmFsaWRhdG9yJyk7XG52YXIgcHVibGljS2V5VmFsaWRhdG9yID0gYXNuMVZhbGlkYXRvci5wdWJsaWNLZXlWYWxpZGF0b3I7XG52YXIgcHJpdmF0ZUtleVZhbGlkYXRvciA9IGFzbjFWYWxpZGF0b3IucHJpdmF0ZUtleVZhbGlkYXRvcjtcblxuaWYodHlwZW9mIEJpZ0ludGVnZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gIHZhciBCaWdJbnRlZ2VyID0gZm9yZ2UuanNibi5CaWdJbnRlZ2VyO1xufVxuXG52YXIgQnl0ZUJ1ZmZlciA9IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcjtcbnZhciBOYXRpdmVCdWZmZXIgPSB0eXBlb2YgQnVmZmVyID09PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBCdWZmZXI7XG5cbi8qXG4gKiBFZDI1NTE5IGFsZ29yaXRobXMsIHNlZSBSRkMgODAzMjpcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM4MDMyXG4gKi9cbmZvcmdlLnBraSA9IGZvcmdlLnBraSB8fCB7fTtcbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtpLmVkMjU1MTkgPSBmb3JnZS5lZDI1NTE5ID0gZm9yZ2UuZWQyNTUxOSB8fCB7fTtcbnZhciBlZDI1NTE5ID0gZm9yZ2UuZWQyNTUxOTtcblxuZWQyNTUxOS5jb25zdGFudHMgPSB7fTtcbmVkMjU1MTkuY29uc3RhbnRzLlBVQkxJQ19LRVlfQllURV9MRU5HVEggPSAzMjtcbmVkMjU1MTkuY29uc3RhbnRzLlBSSVZBVEVfS0VZX0JZVEVfTEVOR1RIID0gNjQ7XG5lZDI1NTE5LmNvbnN0YW50cy5TRUVEX0JZVEVfTEVOR1RIID0gMzI7XG5lZDI1NTE5LmNvbnN0YW50cy5TSUdOX0JZVEVfTEVOR1RIID0gNjQ7XG5lZDI1NTE5LmNvbnN0YW50cy5IQVNIX0JZVEVfTEVOR1RIID0gNjQ7XG5cbmVkMjU1MTkuZ2VuZXJhdGVLZXlQYWlyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHNlZWQgPSBvcHRpb25zLnNlZWQ7XG4gIGlmKHNlZWQgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGdlbmVyYXRlIHNlZWRcbiAgICBzZWVkID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzU3luYyhlZDI1NTE5LmNvbnN0YW50cy5TRUVEX0JZVEVfTEVOR1RIKTtcbiAgfSBlbHNlIGlmKHR5cGVvZiBzZWVkID09PSAnc3RyaW5nJykge1xuICAgIGlmKHNlZWQubGVuZ3RoICE9PSBlZDI1NTE5LmNvbnN0YW50cy5TRUVEX0JZVEVfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnXCJzZWVkXCIgbXVzdCBiZSAnICsgZWQyNTUxOS5jb25zdGFudHMuU0VFRF9CWVRFX0xFTkdUSCArXG4gICAgICAgICcgYnl0ZXMgaW4gbGVuZ3RoLicpO1xuICAgIH1cbiAgfSBlbHNlIGlmKCEoc2VlZCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdcInNlZWRcIiBtdXN0IGJlIGEgbm9kZS5qcyBCdWZmZXIsIFVpbnQ4QXJyYXksIG9yIGEgYmluYXJ5IHN0cmluZy4nKTtcbiAgfVxuXG4gIHNlZWQgPSBtZXNzYWdlVG9OYXRpdmVCdWZmZXIoe21lc3NhZ2U6IHNlZWQsIGVuY29kaW5nOiAnYmluYXJ5J30pO1xuXG4gIHZhciBwayA9IG5ldyBOYXRpdmVCdWZmZXIoZWQyNTUxOS5jb25zdGFudHMuUFVCTElDX0tFWV9CWVRFX0xFTkdUSCk7XG4gIHZhciBzayA9IG5ldyBOYXRpdmVCdWZmZXIoZWQyNTUxOS5jb25zdGFudHMuUFJJVkFURV9LRVlfQllURV9MRU5HVEgpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgMzI7ICsraSkge1xuICAgIHNrW2ldID0gc2VlZFtpXTtcbiAgfVxuICBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzayk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgcHJpdmF0ZUtleTogc2t9O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHByaXZhdGUga2V5IGZyb20gYSBSRkM4NDEwIEFTTi4xIGVuY29kaW5nLlxuICpcbiAqIEBwYXJhbSBvYmogLSBUaGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhIHByaXZhdGUga2V5LlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IGtleUluZm8gLSBUaGUga2V5IGluZm9ybWF0aW9uLlxuICogQHJldHVybnMge0J1ZmZlcnxVaW50OEFycmF5fSBrZXlJbmZvLnByaXZhdGVLZXlCeXRlcyAtIDMyIHByaXZhdGUga2V5IGJ5dGVzLlxuICovXG5lZDI1NTE5LnByaXZhdGVLZXlGcm9tQXNuMSA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB2YWxpZCA9IGZvcmdlLmFzbjEudmFsaWRhdGUob2JqLCBwcml2YXRlS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpO1xuICBpZighdmFsaWQpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0ludmFsaWQgS2V5LicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICB2YXIgb2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLnByaXZhdGVLZXlPaWQpO1xuICB2YXIgZWQyNTUxOU9pZCA9IGZvcmdlLm9pZHMuRWREU0EyNTUxOTtcbiAgaWYob2lkICE9PSBlZDI1NTE5T2lkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIE9JRCBcIicgKyBvaWQgKyAnXCI7IE9JRCBtdXN0IGJlIFwiJyArXG4gICAgICBlZDI1NTE5T2lkICsgJ1wiLicpO1xuICB9XG4gIHZhciBwcml2YXRlS2V5ID0gY2FwdHVyZS5wcml2YXRlS2V5O1xuICAvLyBtYW51YWxseSBleHRyYWN0IHRoZSBwcml2YXRlIGtleSBieXRlcyBmcm9tIG5lc3RlZCBvY3RldCBzdHJpbmcsIHNlZSBGSVhNRTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RpZ2l0YWxiYXphYXIvZm9yZ2UvYmxvYi9tYXN0ZXIvbGliL2FzbjEuanMjTDU0MlxuICB2YXIgcHJpdmF0ZUtleUJ5dGVzID0gbWVzc2FnZVRvTmF0aXZlQnVmZmVyKHtcbiAgICBtZXNzYWdlOiBmb3JnZS5hc24xLmZyb21EZXIocHJpdmF0ZUtleSkudmFsdWUsXG4gICAgZW5jb2Rpbmc6ICdiaW5hcnknXG4gIH0pO1xuICAvLyBUT0RPOiBSRkM4NDEwIHNwZWNpZmllcyBhIGZvcm1hdCBmb3IgZW5jb2RpbmcgdGhlIHB1YmxpYyBrZXkgYnl0ZXMgYWxvbmdcbiAgLy8gd2l0aCB0aGUgcHJpdmF0ZSBrZXkgYnl0ZXMuIGBwdWJsaWNLZXlCeXRlc2AgY2FuIGJlIHJldHVybmVkIGluIHRoZVxuICAvLyBmdXR1cmUuIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM4NDEwI3NlY3Rpb24tMTAuM1xuICByZXR1cm4ge3ByaXZhdGVLZXlCeXRlczogcHJpdmF0ZUtleUJ5dGVzfTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IGZyb20gYSBSRkM4NDEwIEFTTi4xIGVuY29kaW5nLlxuICpcbiAqIEBwYXJhbSBvYmogLSBUaGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhIHB1YmxpYyBrZXkuXG4gKlxuICogQHJldHVybiB7QnVmZmVyfFVpbnQ4QXJyYXl9IC0gMzIgcHVibGljIGtleSBieXRlcy5cbiAqL1xuZWQyNTUxOS5wdWJsaWNLZXlGcm9tQXNuMSA9IGZ1bmN0aW9uKG9iaikge1xuICAvLyBnZXQgU3ViamVjdFB1YmxpY0tleUluZm9cbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdmFsaWQgPSBmb3JnZS5hc24xLnZhbGlkYXRlKG9iaiwgcHVibGljS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpO1xuICBpZighdmFsaWQpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0ludmFsaWQgS2V5LicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICB2YXIgb2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLnB1YmxpY0tleU9pZCk7XG4gIHZhciBlZDI1NTE5T2lkID0gZm9yZ2Uub2lkcy5FZERTQTI1NTE5O1xuICBpZihvaWQgIT09IGVkMjU1MTlPaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgT0lEIFwiJyArIG9pZCArICdcIjsgT0lEIG11c3QgYmUgXCInICtcbiAgICAgIGVkMjU1MTlPaWQgKyAnXCIuJyk7XG4gIH1cbiAgdmFyIHB1YmxpY0tleUJ5dGVzID0gY2FwdHVyZS5lZDI1NTE5UHVibGljS2V5O1xuICBpZihwdWJsaWNLZXlCeXRlcy5sZW5ndGggIT09IGVkMjU1MTkuY29uc3RhbnRzLlBVQkxJQ19LRVlfQllURV9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBsZW5ndGggaXMgaW52YWxpZC4nKTtcbiAgfVxuICByZXR1cm4gbWVzc2FnZVRvTmF0aXZlQnVmZmVyKHtcbiAgICBtZXNzYWdlOiBwdWJsaWNLZXlCeXRlcyxcbiAgICBlbmNvZGluZzogJ2JpbmFyeSdcbiAgfSk7XG59O1xuXG5lZDI1NTE5LnB1YmxpY0tleUZyb21Qcml2YXRlS2V5ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHByaXZhdGVLZXkgPSBtZXNzYWdlVG9OYXRpdmVCdWZmZXIoe1xuICAgIG1lc3NhZ2U6IG9wdGlvbnMucHJpdmF0ZUtleSwgZW5jb2Rpbmc6ICdiaW5hcnknXG4gIH0pO1xuICBpZihwcml2YXRlS2V5Lmxlbmd0aCAhPT0gZWQyNTUxOS5jb25zdGFudHMuUFJJVkFURV9LRVlfQllURV9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1wib3B0aW9ucy5wcml2YXRlS2V5XCIgbXVzdCBoYXZlIGEgYnl0ZSBsZW5ndGggb2YgJyArXG4gICAgICBlZDI1NTE5LmNvbnN0YW50cy5QUklWQVRFX0tFWV9CWVRFX0xFTkdUSCk7XG4gIH1cblxuICB2YXIgcGsgPSBuZXcgTmF0aXZlQnVmZmVyKGVkMjU1MTkuY29uc3RhbnRzLlBVQkxJQ19LRVlfQllURV9MRU5HVEgpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgcGsubGVuZ3RoOyArK2kpIHtcbiAgICBwa1tpXSA9IHByaXZhdGVLZXlbMzIgKyBpXTtcbiAgfVxuICByZXR1cm4gcGs7XG59O1xuXG5lZDI1NTE5LnNpZ24gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbXNnID0gbWVzc2FnZVRvTmF0aXZlQnVmZmVyKG9wdGlvbnMpO1xuICB2YXIgcHJpdmF0ZUtleSA9IG1lc3NhZ2VUb05hdGl2ZUJ1ZmZlcih7XG4gICAgbWVzc2FnZTogb3B0aW9ucy5wcml2YXRlS2V5LFxuICAgIGVuY29kaW5nOiAnYmluYXJ5J1xuICB9KTtcbiAgaWYocHJpdmF0ZUtleS5sZW5ndGggPT09IGVkMjU1MTkuY29uc3RhbnRzLlNFRURfQllURV9MRU5HVEgpIHtcbiAgICB2YXIga2V5UGFpciA9IGVkMjU1MTkuZ2VuZXJhdGVLZXlQYWlyKHtzZWVkOiBwcml2YXRlS2V5fSk7XG4gICAgcHJpdmF0ZUtleSA9IGtleVBhaXIucHJpdmF0ZUtleTtcbiAgfSBlbHNlIGlmKHByaXZhdGVLZXkubGVuZ3RoICE9PSBlZDI1NTE5LmNvbnN0YW50cy5QUklWQVRFX0tFWV9CWVRFX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnXCJvcHRpb25zLnByaXZhdGVLZXlcIiBtdXN0IGhhdmUgYSBieXRlIGxlbmd0aCBvZiAnICtcbiAgICAgIGVkMjU1MTkuY29uc3RhbnRzLlNFRURfQllURV9MRU5HVEggKyAnIG9yICcgK1xuICAgICAgZWQyNTUxOS5jb25zdGFudHMuUFJJVkFURV9LRVlfQllURV9MRU5HVEgpO1xuICB9XG5cbiAgdmFyIHNpZ25lZE1zZyA9IG5ldyBOYXRpdmVCdWZmZXIoXG4gICAgZWQyNTUxOS5jb25zdGFudHMuU0lHTl9CWVRFX0xFTkdUSCArIG1zZy5sZW5ndGgpO1xuICBjcnlwdG9fc2lnbihzaWduZWRNc2csIG1zZywgbXNnLmxlbmd0aCwgcHJpdmF0ZUtleSk7XG5cbiAgdmFyIHNpZyA9IG5ldyBOYXRpdmVCdWZmZXIoZWQyNTUxOS5jb25zdGFudHMuU0lHTl9CWVRFX0xFTkdUSCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzaWcubGVuZ3RoOyArK2kpIHtcbiAgICBzaWdbaV0gPSBzaWduZWRNc2dbaV07XG4gIH1cbiAgcmV0dXJuIHNpZztcbn07XG5cbmVkMjU1MTkudmVyaWZ5ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIG1zZyA9IG1lc3NhZ2VUb05hdGl2ZUJ1ZmZlcihvcHRpb25zKTtcbiAgaWYob3B0aW9ucy5zaWduYXR1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnXCJvcHRpb25zLnNpZ25hdHVyZVwiIG11c3QgYmUgYSBub2RlLmpzIEJ1ZmZlciwgYSBVaW50OEFycmF5LCBhIGZvcmdlICcgK1xuICAgICAgJ0J5dGVCdWZmZXIsIG9yIGEgYmluYXJ5IHN0cmluZy4nKTtcbiAgfVxuICB2YXIgc2lnID0gbWVzc2FnZVRvTmF0aXZlQnVmZmVyKHtcbiAgICBtZXNzYWdlOiBvcHRpb25zLnNpZ25hdHVyZSxcbiAgICBlbmNvZGluZzogJ2JpbmFyeSdcbiAgfSk7XG4gIGlmKHNpZy5sZW5ndGggIT09IGVkMjU1MTkuY29uc3RhbnRzLlNJR05fQllURV9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1wib3B0aW9ucy5zaWduYXR1cmVcIiBtdXN0IGhhdmUgYSBieXRlIGxlbmd0aCBvZiAnICtcbiAgICAgIGVkMjU1MTkuY29uc3RhbnRzLlNJR05fQllURV9MRU5HVEgpO1xuICB9XG4gIHZhciBwdWJsaWNLZXkgPSBtZXNzYWdlVG9OYXRpdmVCdWZmZXIoe1xuICAgIG1lc3NhZ2U6IG9wdGlvbnMucHVibGljS2V5LFxuICAgIGVuY29kaW5nOiAnYmluYXJ5J1xuICB9KTtcbiAgaWYocHVibGljS2V5Lmxlbmd0aCAhPT0gZWQyNTUxOS5jb25zdGFudHMuUFVCTElDX0tFWV9CWVRFX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnXCJvcHRpb25zLnB1YmxpY0tleVwiIG11c3QgaGF2ZSBhIGJ5dGUgbGVuZ3RoIG9mICcgK1xuICAgICAgZWQyNTUxOS5jb25zdGFudHMuUFVCTElDX0tFWV9CWVRFX0xFTkdUSCk7XG4gIH1cblxuICB2YXIgc20gPSBuZXcgTmF0aXZlQnVmZmVyKGVkMjU1MTkuY29uc3RhbnRzLlNJR05fQllURV9MRU5HVEggKyBtc2cubGVuZ3RoKTtcbiAgdmFyIG0gPSBuZXcgTmF0aXZlQnVmZmVyKGVkMjU1MTkuY29uc3RhbnRzLlNJR05fQllURV9MRU5HVEggKyBtc2cubGVuZ3RoKTtcbiAgdmFyIGk7XG4gIGZvcihpID0gMDsgaSA8IGVkMjU1MTkuY29uc3RhbnRzLlNJR05fQllURV9MRU5HVEg7ICsraSkge1xuICAgIHNtW2ldID0gc2lnW2ldO1xuICB9XG4gIGZvcihpID0gMDsgaSA8IG1zZy5sZW5ndGg7ICsraSkge1xuICAgIHNtW2kgKyBlZDI1NTE5LmNvbnN0YW50cy5TSUdOX0JZVEVfTEVOR1RIXSA9IG1zZ1tpXTtcbiAgfVxuICByZXR1cm4gKGNyeXB0b19zaWduX29wZW4obSwgc20sIHNtLmxlbmd0aCwgcHVibGljS2V5KSA+PSAwKTtcbn07XG5cbmZ1bmN0aW9uIG1lc3NhZ2VUb05hdGl2ZUJ1ZmZlcihvcHRpb25zKSB7XG4gIHZhciBtZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICBpZihtZXNzYWdlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBtZXNzYWdlIGluc3RhbmNlb2YgTmF0aXZlQnVmZmVyKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cblxuICB2YXIgZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICBpZihtZXNzYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICBpZihvcHRpb25zLm1kKSB7XG4gICAgICAvLyBUT0RPOiBtb3JlIHJpZ29yb3VzIHZhbGlkYXRpb24gdGhhdCBgbWRgIGlzIGEgTWVzc2FnZURpZ2VzdFxuICAgICAgbWVzc2FnZSA9IG9wdGlvbnMubWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcbiAgICAgIGVuY29kaW5nID0gJ2JpbmFyeSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9ucy5tZXNzYWdlXCIgb3IgXCJvcHRpb25zLm1kXCIgbm90IHNwZWNpZmllZC4nKTtcbiAgICB9XG4gIH1cblxuICBpZih0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgJiYgIWVuY29kaW5nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLmVuY29kaW5nXCIgbXVzdCBiZSBcImJpbmFyeVwiIG9yIFwidXRmOFwiLicpO1xuICB9XG5cbiAgaWYodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShtZXNzYWdlLCBlbmNvZGluZyk7XG4gICAgfVxuICAgIG1lc3NhZ2UgPSBuZXcgQnl0ZUJ1ZmZlcihtZXNzYWdlLCBlbmNvZGluZyk7XG4gIH0gZWxzZSBpZighKG1lc3NhZ2UgaW5zdGFuY2VvZiBCeXRlQnVmZmVyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnXCJvcHRpb25zLm1lc3NhZ2VcIiBtdXN0IGJlIGEgbm9kZS5qcyBCdWZmZXIsIGEgVWludDhBcnJheSwgYSBmb3JnZSAnICtcbiAgICAgICdCeXRlQnVmZmVyLCBvciBhIHN0cmluZyB3aXRoIFwib3B0aW9ucy5lbmNvZGluZ1wiIHNwZWNpZnlpbmcgaXRzICcgK1xuICAgICAgJ2VuY29kaW5nLicpO1xuICB9XG5cbiAgLy8gY29udmVydCB0byBuYXRpdmUgYnVmZmVyXG4gIHZhciBidWZmZXIgPSBuZXcgTmF0aXZlQnVmZmVyKG1lc3NhZ2UubGVuZ3RoKCkpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgKytpKSB7XG4gICAgYnVmZmVyW2ldID0gbWVzc2FnZS5hdChpKTtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufVxuXG52YXIgZ2YwID0gZ2YoKTtcbnZhciBnZjEgPSBnZihbMV0pO1xudmFyIEQgPSBnZihbXG4gIDB4NzhhMywgMHgxMzU5LCAweDRkY2EsIDB4NzVlYiwgMHhkOGFiLCAweDQxNDEsIDB4MGE0ZCwgMHgwMDcwLFxuICAweGU4OTgsIDB4Nzc3OSwgMHg0MDc5LCAweDhjYzcsIDB4ZmU3MywgMHgyYjZmLCAweDZjZWUsIDB4NTIwM10pO1xudmFyIEQyID0gZ2YoW1xuICAweGYxNTksIDB4MjZiMiwgMHg5Yjk0LCAweGViZDYsIDB4YjE1NiwgMHg4MjgzLCAweDE0OWEsIDB4MDBlMCxcbiAgMHhkMTMwLCAweGVlZjMsIDB4ODBmMiwgMHgxOThlLCAweGZjZTcsIDB4NTZkZiwgMHhkOWRjLCAweDI0MDZdKTtcbnZhciBYID0gZ2YoW1xuICAweGQ1MWEsIDB4OGYyNSwgMHgyZDYwLCAweGM5NTYsIDB4YTdiMiwgMHg5NTI1LCAweGM3NjAsIDB4NjkyYyxcbiAgMHhkYzVjLCAweGZkZDYsIDB4ZTIzMSwgMHhjMGE0LCAweDUzZmUsIDB4Y2Q2ZSwgMHgzNmQzLCAweDIxNjldKTtcbnZhciBZID0gZ2YoW1xuICAweDY2NTgsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NixcbiAgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjZdKTtcbnZhciBMID0gbmV3IEZsb2F0NjRBcnJheShbXG4gIDB4ZWQsIDB4ZDMsIDB4ZjUsIDB4NWMsIDB4MWEsIDB4NjMsIDB4MTIsIDB4NTgsXG4gIDB4ZDYsIDB4OWMsIDB4ZjcsIDB4YTIsIDB4ZGUsIDB4ZjksIDB4ZGUsIDB4MTQsXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDB4MTBdKTtcbnZhciBJID0gZ2YoW1xuICAweGEwYjAsIDB4NGEwZSwgMHgxYjI3LCAweGM0ZWUsIDB4ZTQ3OCwgMHhhZDJmLCAweDE4MDYsIDB4MmY0MyxcbiAgMHhkN2E3LCAweDNkZmIsIDB4MDA5OSwgMHgyYjRkLCAweGRmMGIsIDB4NGZjMSwgMHgyNDgwLCAweDJiODNdKTtcblxuLy8gVE9ETzogdXBkYXRlIGZvcmdlIGJ1ZmZlciBpbXBsZW1lbnRhdGlvbiB0byB1c2UgYEJ1ZmZlcmAgb3IgYFVpbnQ4QXJyYXlgLFxuLy8gd2hpY2hldmVyIGlzIGF2YWlsYWJsZSwgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZVxuZnVuY3Rpb24gc2hhNTEyKG1zZywgbXNnTGVuKSB7XG4gIC8vIE5vdGU6IGBvdXRgIGFuZCBgbXNnYCBhcmUgTmF0aXZlQnVmZmVyXG4gIHZhciBtZCA9IGZvcmdlLm1kLnNoYTUxMi5jcmVhdGUoKTtcbiAgdmFyIGJ1ZmZlciA9IG5ldyBCeXRlQnVmZmVyKG1zZyk7XG4gIG1kLnVwZGF0ZShidWZmZXIuZ2V0Qnl0ZXMobXNnTGVuKSwgJ2JpbmFyeScpO1xuICB2YXIgaGFzaCA9IG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG4gIGlmKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhhc2gsICdiaW5hcnknKTtcbiAgfVxuICB2YXIgb3V0ID0gbmV3IE5hdGl2ZUJ1ZmZlcihlZDI1NTE5LmNvbnN0YW50cy5IQVNIX0JZVEVfTEVOR1RIKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICBvdXRbaV0gPSBoYXNoLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NpZ25fa2V5cGFpcihwaywgc2spIHtcbiAgdmFyIHAgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG4gIHZhciBpO1xuXG4gIHZhciBkID0gc2hhNTEyKHNrLCAzMik7XG4gIGRbMF0gJj0gMjQ4O1xuICBkWzMxXSAmPSAxMjc7XG4gIGRbMzFdIHw9IDY0O1xuXG4gIHNjYWxhcmJhc2UocCwgZCk7XG4gIHBhY2socGssIHApO1xuXG4gIGZvcihpID0gMDsgaSA8IDMyOyArK2kpIHtcbiAgICBza1tpICsgMzJdID0gcGtbaV07XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIE5vdGU6IGRpZmZlcmVuY2UgZnJvbSBDIC0gc21sZW4gcmV0dXJuZWQsIG5vdCBwYXNzZWQgYXMgYXJndW1lbnQuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbihzbSwgbSwgbiwgc2spIHtcbiAgdmFyIGksIGosIHggPSBuZXcgRmxvYXQ2NEFycmF5KDY0KTtcbiAgdmFyIHAgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG5cbiAgdmFyIGQgPSBzaGE1MTIoc2ssIDMyKTtcbiAgZFswXSAmPSAyNDg7XG4gIGRbMzFdICY9IDEyNztcbiAgZFszMV0gfD0gNjQ7XG5cbiAgdmFyIHNtbGVuID0gbiArIDY0O1xuICBmb3IoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBzbVs2NCArIGldID0gbVtpXTtcbiAgfVxuICBmb3IoaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgc21bMzIgKyBpXSA9IGRbMzIgKyBpXTtcbiAgfVxuXG4gIHZhciByID0gc2hhNTEyKHNtLnN1YmFycmF5KDMyKSwgbiArIDMyKTtcbiAgcmVkdWNlKHIpO1xuICBzY2FsYXJiYXNlKHAsIHIpO1xuICBwYWNrKHNtLCBwKTtcblxuICBmb3IoaSA9IDMyOyBpIDwgNjQ7ICsraSkge1xuICAgIHNtW2ldID0gc2tbaV07XG4gIH1cbiAgdmFyIGggPSBzaGE1MTIoc20sIG4gKyA2NCk7XG4gIHJlZHVjZShoKTtcblxuICBmb3IoaSA9IDMyOyBpIDwgNjQ7ICsraSkge1xuICAgIHhbaV0gPSAwO1xuICB9XG4gIGZvcihpID0gMDsgaSA8IDMyOyArK2kpIHtcbiAgICB4W2ldID0gcltpXTtcbiAgfVxuICBmb3IoaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgZm9yKGogPSAwOyBqIDwgMzI7IGorKykge1xuICAgICAgeFtpICsgal0gKz0gaFtpXSAqIGRbal07XG4gICAgfVxuICB9XG5cbiAgbW9kTChzbS5zdWJhcnJheSgzMiksIHgpO1xuICByZXR1cm4gc21sZW47XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zaWduX29wZW4obSwgc20sIG4sIHBrKSB7XG4gIHZhciBpLCBtbGVuO1xuICB2YXIgdCA9IG5ldyBOYXRpdmVCdWZmZXIoMzIpO1xuICB2YXIgcCA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXSxcbiAgICAgIHEgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG5cbiAgbWxlbiA9IC0xO1xuICBpZihuIDwgNjQpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBpZih1bnBhY2tuZWcocSwgcGspKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZm9yKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgbVtpXSA9IHNtW2ldO1xuICB9XG4gIGZvcihpID0gMDsgaSA8IDMyOyArK2kpIHtcbiAgICBtW2kgKyAzMl0gPSBwa1tpXTtcbiAgfVxuICB2YXIgaCA9IHNoYTUxMihtLCBuKTtcbiAgcmVkdWNlKGgpO1xuICBzY2FsYXJtdWx0KHAsIHEsIGgpO1xuXG4gIHNjYWxhcmJhc2UocSwgc20uc3ViYXJyYXkoMzIpKTtcbiAgYWRkKHAsIHEpO1xuICBwYWNrKHQsIHApO1xuXG4gIG4gLT0gNjQ7XG4gIGlmKGNyeXB0b192ZXJpZnlfMzIoc20sIDAsIHQsIDApKSB7XG4gICAgZm9yKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBtW2ldID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZm9yKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgbVtpXSA9IHNtW2kgKyA2NF07XG4gIH1cbiAgbWxlbiA9IG47XG4gIHJldHVybiBtbGVuO1xufVxuXG5mdW5jdGlvbiBtb2RMKHIsIHgpIHtcbiAgdmFyIGNhcnJ5LCBpLCBqLCBrO1xuICBmb3IoaSA9IDYzOyBpID49IDMyOyAtLWkpIHtcbiAgICBjYXJyeSA9IDA7XG4gICAgZm9yKGogPSBpIC0gMzIsIGsgPSBpIC0gMTI7IGogPCBrOyArK2opIHtcbiAgICAgIHhbal0gKz0gY2FycnkgLSAxNiAqIHhbaV0gKiBMW2ogLSAoaSAtIDMyKV07XG4gICAgICBjYXJyeSA9ICh4W2pdICsgMTI4KSA+PiA4O1xuICAgICAgeFtqXSAtPSBjYXJyeSAqIDI1NjtcbiAgICB9XG4gICAgeFtqXSArPSBjYXJyeTtcbiAgICB4W2ldID0gMDtcbiAgfVxuICBjYXJyeSA9IDA7XG4gIGZvcihqID0gMDsgaiA8IDMyOyArK2opIHtcbiAgICB4W2pdICs9IGNhcnJ5IC0gKHhbMzFdID4+IDQpICogTFtqXTtcbiAgICBjYXJyeSA9IHhbal0gPj4gODtcbiAgICB4W2pdICY9IDI1NTtcbiAgfVxuICBmb3IoaiA9IDA7IGogPCAzMjsgKytqKSB7XG4gICAgeFtqXSAtPSBjYXJyeSAqIExbal07XG4gIH1cbiAgZm9yKGkgPSAwOyBpIDwgMzI7ICsraSkge1xuICAgIHhbaSArIDFdICs9IHhbaV0gPj4gODtcbiAgICByW2ldID0geFtpXSAmIDI1NTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2Uocikge1xuICB2YXIgeCA9IG5ldyBGbG9hdDY0QXJyYXkoNjQpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgNjQ7ICsraSkge1xuICAgIHhbaV0gPSByW2ldO1xuICAgIHJbaV0gPSAwO1xuICB9XG4gIG1vZEwociwgeCk7XG59XG5cbmZ1bmN0aW9uIGFkZChwLCBxKSB7XG4gIHZhciBhID0gZ2YoKSwgYiA9IGdmKCksIGMgPSBnZigpLFxuICAgICAgZCA9IGdmKCksIGUgPSBnZigpLCBmID0gZ2YoKSxcbiAgICAgIGcgPSBnZigpLCBoID0gZ2YoKSwgdCA9IGdmKCk7XG5cbiAgWihhLCBwWzFdLCBwWzBdKTtcbiAgWih0LCBxWzFdLCBxWzBdKTtcbiAgTShhLCBhLCB0KTtcbiAgQShiLCBwWzBdLCBwWzFdKTtcbiAgQSh0LCBxWzBdLCBxWzFdKTtcbiAgTShiLCBiLCB0KTtcbiAgTShjLCBwWzNdLCBxWzNdKTtcbiAgTShjLCBjLCBEMik7XG4gIE0oZCwgcFsyXSwgcVsyXSk7XG4gIEEoZCwgZCwgZCk7XG4gIFooZSwgYiwgYSk7XG4gIFooZiwgZCwgYyk7XG4gIEEoZywgZCwgYyk7XG4gIEEoaCwgYiwgYSk7XG5cbiAgTShwWzBdLCBlLCBmKTtcbiAgTShwWzFdLCBoLCBnKTtcbiAgTShwWzJdLCBnLCBmKTtcbiAgTShwWzNdLCBlLCBoKTtcbn1cblxuZnVuY3Rpb24gY3N3YXAocCwgcSwgYikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgc2VsMjU1MTkocFtpXSwgcVtpXSwgYik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFjayhyLCBwKSB7XG4gIHZhciB0eCA9IGdmKCksIHR5ID0gZ2YoKSwgemkgPSBnZigpO1xuICBpbnYyNTUxOSh6aSwgcFsyXSk7XG4gIE0odHgsIHBbMF0sIHppKTtcbiAgTSh0eSwgcFsxXSwgemkpO1xuICBwYWNrMjU1MTkociwgdHkpO1xuICByWzMxXSBePSBwYXIyNTUxOSh0eCkgPDwgNztcbn1cblxuZnVuY3Rpb24gcGFjazI1NTE5KG8sIG4pIHtcbiAgdmFyIGksIGosIGI7XG4gIHZhciBtID0gZ2YoKSwgdCA9IGdmKCk7XG4gIGZvcihpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICB0W2ldID0gbltpXTtcbiAgfVxuICBjYXIyNTUxOSh0KTtcbiAgY2FyMjU1MTkodCk7XG4gIGNhcjI1NTE5KHQpO1xuICBmb3IoaiA9IDA7IGogPCAyOyArK2opIHtcbiAgICBtWzBdID0gdFswXSAtIDB4ZmZlZDtcbiAgICBmb3IoaSA9IDE7IGkgPCAxNTsgKytpKSB7XG4gICAgICBtW2ldID0gdFtpXSAtIDB4ZmZmZiAtICgobVtpIC0gMV0gPj4gMTYpICYgMSk7XG4gICAgICBtW2ktMV0gJj0gMHhmZmZmO1xuICAgIH1cbiAgICBtWzE1XSA9IHRbMTVdIC0gMHg3ZmZmIC0gKChtWzE0XSA+PiAxNikgJiAxKTtcbiAgICBiID0gKG1bMTVdID4+IDE2KSAmIDE7XG4gICAgbVsxNF0gJj0gMHhmZmZmO1xuICAgIHNlbDI1NTE5KHQsIG0sIDEgLSBiKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIG9bMiAqIGldID0gdFtpXSAmIDB4ZmY7XG4gICAgb1syICogaSArIDFdID0gdFtpXSA+PiA4O1xuICB9XG59XG5cbmZ1bmN0aW9uIHVucGFja25lZyhyLCBwKSB7XG4gIHZhciB0ID0gZ2YoKSwgY2hrID0gZ2YoKSwgbnVtID0gZ2YoKSxcbiAgICAgIGRlbiA9IGdmKCksIGRlbjIgPSBnZigpLCBkZW40ID0gZ2YoKSxcbiAgICAgIGRlbjYgPSBnZigpO1xuXG4gIHNldDI1NTE5KHJbMl0sIGdmMSk7XG4gIHVucGFjazI1NTE5KHJbMV0sIHApO1xuICBTKG51bSwgclsxXSk7XG4gIE0oZGVuLCBudW0sIEQpO1xuICBaKG51bSwgbnVtLCByWzJdKTtcbiAgQShkZW4sIHJbMl0sIGRlbik7XG5cbiAgUyhkZW4yLCBkZW4pO1xuICBTKGRlbjQsIGRlbjIpO1xuICBNKGRlbjYsIGRlbjQsIGRlbjIpO1xuICBNKHQsIGRlbjYsIG51bSk7XG4gIE0odCwgdCwgZGVuKTtcblxuICBwb3cyNTIzKHQsIHQpO1xuICBNKHQsIHQsIG51bSk7XG4gIE0odCwgdCwgZGVuKTtcbiAgTSh0LCB0LCBkZW4pO1xuICBNKHJbMF0sIHQsIGRlbik7XG5cbiAgUyhjaGssIHJbMF0pO1xuICBNKGNoaywgY2hrLCBkZW4pO1xuICBpZihuZXEyNTUxOShjaGssIG51bSkpIHtcbiAgICBNKHJbMF0sIHJbMF0sIEkpO1xuICB9XG5cbiAgUyhjaGssIHJbMF0pO1xuICBNKGNoaywgY2hrLCBkZW4pO1xuICBpZihuZXEyNTUxOShjaGssIG51bSkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBpZihwYXIyNTUxOShyWzBdKSA9PT0gKHBbMzFdID4+IDcpKSB7XG4gICAgWihyWzBdLCBnZjAsIHJbMF0pO1xuICB9XG5cbiAgTShyWzNdLCByWzBdLCByWzFdKTtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIHVucGFjazI1NTE5KG8sIG4pIHtcbiAgdmFyIGk7XG4gIGZvcihpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICBvW2ldID0gblsyICogaV0gKyAoblsyICogaSArIDFdIDw8IDgpO1xuICB9XG4gIG9bMTVdICY9IDB4N2ZmZjtcbn1cblxuZnVuY3Rpb24gcG93MjUyMyhvLCBpKSB7XG4gIHZhciBjID0gZ2YoKTtcbiAgdmFyIGE7XG4gIGZvcihhID0gMDsgYSA8IDE2OyArK2EpIHtcbiAgICBjW2FdID0gaVthXTtcbiAgfVxuICBmb3IoYSA9IDI1MDsgYSA+PSAwOyAtLWEpIHtcbiAgICBTKGMsIGMpO1xuICAgIGlmKGEgIT09IDEpIHtcbiAgICAgIE0oYywgYywgaSk7XG4gICAgfVxuICB9XG4gIGZvcihhID0gMDsgYSA8IDE2OyArK2EpIHtcbiAgICBvW2FdID0gY1thXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXEyNTUxOShhLCBiKSB7XG4gIHZhciBjID0gbmV3IE5hdGl2ZUJ1ZmZlcigzMik7XG4gIHZhciBkID0gbmV3IE5hdGl2ZUJ1ZmZlcigzMik7XG4gIHBhY2syNTUxOShjLCBhKTtcbiAgcGFjazI1NTE5KGQsIGIpO1xuICByZXR1cm4gY3J5cHRvX3ZlcmlmeV8zMihjLCAwLCBkLCAwKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3ZlcmlmeV8zMih4LCB4aSwgeSwgeWkpIHtcbiAgcmV0dXJuIHZuKHgsIHhpLCB5LCB5aSwgMzIpO1xufVxuXG5mdW5jdGlvbiB2bih4LCB4aSwgeSwgeWksIG4pIHtcbiAgdmFyIGksIGQgPSAwO1xuICBmb3IoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBkIHw9IHhbeGkgKyBpXSBeIHlbeWkgKyBpXTtcbiAgfVxuICByZXR1cm4gKDEgJiAoKGQgLSAxKSA+Pj4gOCkpIC0gMTtcbn1cblxuZnVuY3Rpb24gcGFyMjU1MTkoYSkge1xuICB2YXIgZCA9IG5ldyBOYXRpdmVCdWZmZXIoMzIpO1xuICBwYWNrMjU1MTkoZCwgYSk7XG4gIHJldHVybiBkWzBdICYgMTtcbn1cblxuZnVuY3Rpb24gc2NhbGFybXVsdChwLCBxLCBzKSB7XG4gIHZhciBiLCBpO1xuICBzZXQyNTUxOShwWzBdLCBnZjApO1xuICBzZXQyNTUxOShwWzFdLCBnZjEpO1xuICBzZXQyNTUxOShwWzJdLCBnZjEpO1xuICBzZXQyNTUxOShwWzNdLCBnZjApO1xuICBmb3IoaSA9IDI1NTsgaSA+PSAwOyAtLWkpIHtcbiAgICBiID0gKHNbKGkgLyA4KXwwXSA+PiAoaSAmIDcpKSAmIDE7XG4gICAgY3N3YXAocCwgcSwgYik7XG4gICAgYWRkKHEsIHApO1xuICAgIGFkZChwLCBwKTtcbiAgICBjc3dhcChwLCBxLCBiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2FsYXJiYXNlKHAsIHMpIHtcbiAgdmFyIHEgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG4gIHNldDI1NTE5KHFbMF0sIFgpO1xuICBzZXQyNTUxOShxWzFdLCBZKTtcbiAgc2V0MjU1MTkocVsyXSwgZ2YxKTtcbiAgTShxWzNdLCBYLCBZKTtcbiAgc2NhbGFybXVsdChwLCBxLCBzKTtcbn1cblxuZnVuY3Rpb24gc2V0MjU1MTkociwgYSkge1xuICB2YXIgaTtcbiAgZm9yKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIHJbaV0gPSBhW2ldIHwgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnYyNTUxOShvLCBpKSB7XG4gIHZhciBjID0gZ2YoKTtcbiAgdmFyIGE7XG4gIGZvcihhID0gMDsgYSA8IDE2OyArK2EpIHtcbiAgICBjW2FdID0gaVthXTtcbiAgfVxuICBmb3IoYSA9IDI1MzsgYSA+PSAwOyAtLWEpIHtcbiAgICBTKGMsIGMpO1xuICAgIGlmKGEgIT09IDIgJiYgYSAhPT0gNCkge1xuICAgICAgTShjLCBjLCBpKTtcbiAgICB9XG4gIH1cbiAgZm9yKGEgPSAwOyBhIDwgMTY7ICsrYSkge1xuICAgIG9bYV0gPSBjW2FdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhcjI1NTE5KG8pIHtcbiAgdmFyIGksIHYsIGMgPSAxO1xuICBmb3IoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgdiA9IG9baV0gKyBjICsgNjU1MzU7XG4gICAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTtcbiAgICBvW2ldID0gdiAtIGMgKiA2NTUzNjtcbiAgfVxuICBvWzBdICs9IGMgLSAxICsgMzcgKiAoYyAtIDEpO1xufVxuXG5mdW5jdGlvbiBzZWwyNTUxOShwLCBxLCBiKSB7XG4gIHZhciB0LCBjID0gfihiIC0gMSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgdCA9IGMgJiAocFtpXSBeIHFbaV0pO1xuICAgIHBbaV0gXj0gdDtcbiAgICBxW2ldIF49IHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2YoaW5pdCkge1xuICB2YXIgaSwgciA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICBpZihpbml0KSB7XG4gICAgZm9yKGkgPSAwOyBpIDwgaW5pdC5sZW5ndGg7ICsraSkge1xuICAgICAgcltpXSA9IGluaXRbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBBKG8sIGEsIGIpIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICBvW2ldID0gYVtpXSArIGJbaV07XG4gIH1cbn1cblxuZnVuY3Rpb24gWihvLCBhLCBiKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgb1tpXSA9IGFbaV0gLSBiW2ldO1xuICB9XG59XG5cbmZ1bmN0aW9uIFMobywgYSkge1xuICBNKG8sIGEsIGEpO1xufVxuXG5mdW5jdGlvbiBNKG8sIGEsIGIpIHtcbiAgdmFyIHYsIGMsXG4gICAgIHQwID0gMCwgIHQxID0gMCwgIHQyID0gMCwgIHQzID0gMCwgIHQ0ID0gMCwgIHQ1ID0gMCwgIHQ2ID0gMCwgIHQ3ID0gMCxcbiAgICAgdDggPSAwLCAgdDkgPSAwLCB0MTAgPSAwLCB0MTEgPSAwLCB0MTIgPSAwLCB0MTMgPSAwLCB0MTQgPSAwLCB0MTUgPSAwLFxuICAgIHQxNiA9IDAsIHQxNyA9IDAsIHQxOCA9IDAsIHQxOSA9IDAsIHQyMCA9IDAsIHQyMSA9IDAsIHQyMiA9IDAsIHQyMyA9IDAsXG4gICAgdDI0ID0gMCwgdDI1ID0gMCwgdDI2ID0gMCwgdDI3ID0gMCwgdDI4ID0gMCwgdDI5ID0gMCwgdDMwID0gMCxcbiAgICBiMCA9IGJbMF0sXG4gICAgYjEgPSBiWzFdLFxuICAgIGIyID0gYlsyXSxcbiAgICBiMyA9IGJbM10sXG4gICAgYjQgPSBiWzRdLFxuICAgIGI1ID0gYls1XSxcbiAgICBiNiA9IGJbNl0sXG4gICAgYjcgPSBiWzddLFxuICAgIGI4ID0gYls4XSxcbiAgICBiOSA9IGJbOV0sXG4gICAgYjEwID0gYlsxMF0sXG4gICAgYjExID0gYlsxMV0sXG4gICAgYjEyID0gYlsxMl0sXG4gICAgYjEzID0gYlsxM10sXG4gICAgYjE0ID0gYlsxNF0sXG4gICAgYjE1ID0gYlsxNV07XG5cbiAgdiA9IGFbMF07XG4gIHQwICs9IHYgKiBiMDtcbiAgdDEgKz0gdiAqIGIxO1xuICB0MiArPSB2ICogYjI7XG4gIHQzICs9IHYgKiBiMztcbiAgdDQgKz0gdiAqIGI0O1xuICB0NSArPSB2ICogYjU7XG4gIHQ2ICs9IHYgKiBiNjtcbiAgdDcgKz0gdiAqIGI3O1xuICB0OCArPSB2ICogYjg7XG4gIHQ5ICs9IHYgKiBiOTtcbiAgdDEwICs9IHYgKiBiMTA7XG4gIHQxMSArPSB2ICogYjExO1xuICB0MTIgKz0gdiAqIGIxMjtcbiAgdDEzICs9IHYgKiBiMTM7XG4gIHQxNCArPSB2ICogYjE0O1xuICB0MTUgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMV07XG4gIHQxICs9IHYgKiBiMDtcbiAgdDIgKz0gdiAqIGIxO1xuICB0MyArPSB2ICogYjI7XG4gIHQ0ICs9IHYgKiBiMztcbiAgdDUgKz0gdiAqIGI0O1xuICB0NiArPSB2ICogYjU7XG4gIHQ3ICs9IHYgKiBiNjtcbiAgdDggKz0gdiAqIGI3O1xuICB0OSArPSB2ICogYjg7XG4gIHQxMCArPSB2ICogYjk7XG4gIHQxMSArPSB2ICogYjEwO1xuICB0MTIgKz0gdiAqIGIxMTtcbiAgdDEzICs9IHYgKiBiMTI7XG4gIHQxNCArPSB2ICogYjEzO1xuICB0MTUgKz0gdiAqIGIxNDtcbiAgdDE2ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzJdO1xuICB0MiArPSB2ICogYjA7XG4gIHQzICs9IHYgKiBiMTtcbiAgdDQgKz0gdiAqIGIyO1xuICB0NSArPSB2ICogYjM7XG4gIHQ2ICs9IHYgKiBiNDtcbiAgdDcgKz0gdiAqIGI1O1xuICB0OCArPSB2ICogYjY7XG4gIHQ5ICs9IHYgKiBiNztcbiAgdDEwICs9IHYgKiBiODtcbiAgdDExICs9IHYgKiBiOTtcbiAgdDEyICs9IHYgKiBiMTA7XG4gIHQxMyArPSB2ICogYjExO1xuICB0MTQgKz0gdiAqIGIxMjtcbiAgdDE1ICs9IHYgKiBiMTM7XG4gIHQxNiArPSB2ICogYjE0O1xuICB0MTcgKz0gdiAqIGIxNTtcbiAgdiA9IGFbM107XG4gIHQzICs9IHYgKiBiMDtcbiAgdDQgKz0gdiAqIGIxO1xuICB0NSArPSB2ICogYjI7XG4gIHQ2ICs9IHYgKiBiMztcbiAgdDcgKz0gdiAqIGI0O1xuICB0OCArPSB2ICogYjU7XG4gIHQ5ICs9IHYgKiBiNjtcbiAgdDEwICs9IHYgKiBiNztcbiAgdDExICs9IHYgKiBiODtcbiAgdDEyICs9IHYgKiBiOTtcbiAgdDEzICs9IHYgKiBiMTA7XG4gIHQxNCArPSB2ICogYjExO1xuICB0MTUgKz0gdiAqIGIxMjtcbiAgdDE2ICs9IHYgKiBiMTM7XG4gIHQxNyArPSB2ICogYjE0O1xuICB0MTggKz0gdiAqIGIxNTtcbiAgdiA9IGFbNF07XG4gIHQ0ICs9IHYgKiBiMDtcbiAgdDUgKz0gdiAqIGIxO1xuICB0NiArPSB2ICogYjI7XG4gIHQ3ICs9IHYgKiBiMztcbiAgdDggKz0gdiAqIGI0O1xuICB0OSArPSB2ICogYjU7XG4gIHQxMCArPSB2ICogYjY7XG4gIHQxMSArPSB2ICogYjc7XG4gIHQxMiArPSB2ICogYjg7XG4gIHQxMyArPSB2ICogYjk7XG4gIHQxNCArPSB2ICogYjEwO1xuICB0MTUgKz0gdiAqIGIxMTtcbiAgdDE2ICs9IHYgKiBiMTI7XG4gIHQxNyArPSB2ICogYjEzO1xuICB0MTggKz0gdiAqIGIxNDtcbiAgdDE5ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzVdO1xuICB0NSArPSB2ICogYjA7XG4gIHQ2ICs9IHYgKiBiMTtcbiAgdDcgKz0gdiAqIGIyO1xuICB0OCArPSB2ICogYjM7XG4gIHQ5ICs9IHYgKiBiNDtcbiAgdDEwICs9IHYgKiBiNTtcbiAgdDExICs9IHYgKiBiNjtcbiAgdDEyICs9IHYgKiBiNztcbiAgdDEzICs9IHYgKiBiODtcbiAgdDE0ICs9IHYgKiBiOTtcbiAgdDE1ICs9IHYgKiBiMTA7XG4gIHQxNiArPSB2ICogYjExO1xuICB0MTcgKz0gdiAqIGIxMjtcbiAgdDE4ICs9IHYgKiBiMTM7XG4gIHQxOSArPSB2ICogYjE0O1xuICB0MjAgKz0gdiAqIGIxNTtcbiAgdiA9IGFbNl07XG4gIHQ2ICs9IHYgKiBiMDtcbiAgdDcgKz0gdiAqIGIxO1xuICB0OCArPSB2ICogYjI7XG4gIHQ5ICs9IHYgKiBiMztcbiAgdDEwICs9IHYgKiBiNDtcbiAgdDExICs9IHYgKiBiNTtcbiAgdDEyICs9IHYgKiBiNjtcbiAgdDEzICs9IHYgKiBiNztcbiAgdDE0ICs9IHYgKiBiODtcbiAgdDE1ICs9IHYgKiBiOTtcbiAgdDE2ICs9IHYgKiBiMTA7XG4gIHQxNyArPSB2ICogYjExO1xuICB0MTggKz0gdiAqIGIxMjtcbiAgdDE5ICs9IHYgKiBiMTM7XG4gIHQyMCArPSB2ICogYjE0O1xuICB0MjEgKz0gdiAqIGIxNTtcbiAgdiA9IGFbN107XG4gIHQ3ICs9IHYgKiBiMDtcbiAgdDggKz0gdiAqIGIxO1xuICB0OSArPSB2ICogYjI7XG4gIHQxMCArPSB2ICogYjM7XG4gIHQxMSArPSB2ICogYjQ7XG4gIHQxMiArPSB2ICogYjU7XG4gIHQxMyArPSB2ICogYjY7XG4gIHQxNCArPSB2ICogYjc7XG4gIHQxNSArPSB2ICogYjg7XG4gIHQxNiArPSB2ICogYjk7XG4gIHQxNyArPSB2ICogYjEwO1xuICB0MTggKz0gdiAqIGIxMTtcbiAgdDE5ICs9IHYgKiBiMTI7XG4gIHQyMCArPSB2ICogYjEzO1xuICB0MjEgKz0gdiAqIGIxNDtcbiAgdDIyICs9IHYgKiBiMTU7XG4gIHYgPSBhWzhdO1xuICB0OCArPSB2ICogYjA7XG4gIHQ5ICs9IHYgKiBiMTtcbiAgdDEwICs9IHYgKiBiMjtcbiAgdDExICs9IHYgKiBiMztcbiAgdDEyICs9IHYgKiBiNDtcbiAgdDEzICs9IHYgKiBiNTtcbiAgdDE0ICs9IHYgKiBiNjtcbiAgdDE1ICs9IHYgKiBiNztcbiAgdDE2ICs9IHYgKiBiODtcbiAgdDE3ICs9IHYgKiBiOTtcbiAgdDE4ICs9IHYgKiBiMTA7XG4gIHQxOSArPSB2ICogYjExO1xuICB0MjAgKz0gdiAqIGIxMjtcbiAgdDIxICs9IHYgKiBiMTM7XG4gIHQyMiArPSB2ICogYjE0O1xuICB0MjMgKz0gdiAqIGIxNTtcbiAgdiA9IGFbOV07XG4gIHQ5ICs9IHYgKiBiMDtcbiAgdDEwICs9IHYgKiBiMTtcbiAgdDExICs9IHYgKiBiMjtcbiAgdDEyICs9IHYgKiBiMztcbiAgdDEzICs9IHYgKiBiNDtcbiAgdDE0ICs9IHYgKiBiNTtcbiAgdDE1ICs9IHYgKiBiNjtcbiAgdDE2ICs9IHYgKiBiNztcbiAgdDE3ICs9IHYgKiBiODtcbiAgdDE4ICs9IHYgKiBiOTtcbiAgdDE5ICs9IHYgKiBiMTA7XG4gIHQyMCArPSB2ICogYjExO1xuICB0MjEgKz0gdiAqIGIxMjtcbiAgdDIyICs9IHYgKiBiMTM7XG4gIHQyMyArPSB2ICogYjE0O1xuICB0MjQgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTBdO1xuICB0MTAgKz0gdiAqIGIwO1xuICB0MTEgKz0gdiAqIGIxO1xuICB0MTIgKz0gdiAqIGIyO1xuICB0MTMgKz0gdiAqIGIzO1xuICB0MTQgKz0gdiAqIGI0O1xuICB0MTUgKz0gdiAqIGI1O1xuICB0MTYgKz0gdiAqIGI2O1xuICB0MTcgKz0gdiAqIGI3O1xuICB0MTggKz0gdiAqIGI4O1xuICB0MTkgKz0gdiAqIGI5O1xuICB0MjAgKz0gdiAqIGIxMDtcbiAgdDIxICs9IHYgKiBiMTE7XG4gIHQyMiArPSB2ICogYjEyO1xuICB0MjMgKz0gdiAqIGIxMztcbiAgdDI0ICs9IHYgKiBiMTQ7XG4gIHQyNSArPSB2ICogYjE1O1xuICB2ID0gYVsxMV07XG4gIHQxMSArPSB2ICogYjA7XG4gIHQxMiArPSB2ICogYjE7XG4gIHQxMyArPSB2ICogYjI7XG4gIHQxNCArPSB2ICogYjM7XG4gIHQxNSArPSB2ICogYjQ7XG4gIHQxNiArPSB2ICogYjU7XG4gIHQxNyArPSB2ICogYjY7XG4gIHQxOCArPSB2ICogYjc7XG4gIHQxOSArPSB2ICogYjg7XG4gIHQyMCArPSB2ICogYjk7XG4gIHQyMSArPSB2ICogYjEwO1xuICB0MjIgKz0gdiAqIGIxMTtcbiAgdDIzICs9IHYgKiBiMTI7XG4gIHQyNCArPSB2ICogYjEzO1xuICB0MjUgKz0gdiAqIGIxNDtcbiAgdDI2ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzEyXTtcbiAgdDEyICs9IHYgKiBiMDtcbiAgdDEzICs9IHYgKiBiMTtcbiAgdDE0ICs9IHYgKiBiMjtcbiAgdDE1ICs9IHYgKiBiMztcbiAgdDE2ICs9IHYgKiBiNDtcbiAgdDE3ICs9IHYgKiBiNTtcbiAgdDE4ICs9IHYgKiBiNjtcbiAgdDE5ICs9IHYgKiBiNztcbiAgdDIwICs9IHYgKiBiODtcbiAgdDIxICs9IHYgKiBiOTtcbiAgdDIyICs9IHYgKiBiMTA7XG4gIHQyMyArPSB2ICogYjExO1xuICB0MjQgKz0gdiAqIGIxMjtcbiAgdDI1ICs9IHYgKiBiMTM7XG4gIHQyNiArPSB2ICogYjE0O1xuICB0MjcgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTNdO1xuICB0MTMgKz0gdiAqIGIwO1xuICB0MTQgKz0gdiAqIGIxO1xuICB0MTUgKz0gdiAqIGIyO1xuICB0MTYgKz0gdiAqIGIzO1xuICB0MTcgKz0gdiAqIGI0O1xuICB0MTggKz0gdiAqIGI1O1xuICB0MTkgKz0gdiAqIGI2O1xuICB0MjAgKz0gdiAqIGI3O1xuICB0MjEgKz0gdiAqIGI4O1xuICB0MjIgKz0gdiAqIGI5O1xuICB0MjMgKz0gdiAqIGIxMDtcbiAgdDI0ICs9IHYgKiBiMTE7XG4gIHQyNSArPSB2ICogYjEyO1xuICB0MjYgKz0gdiAqIGIxMztcbiAgdDI3ICs9IHYgKiBiMTQ7XG4gIHQyOCArPSB2ICogYjE1O1xuICB2ID0gYVsxNF07XG4gIHQxNCArPSB2ICogYjA7XG4gIHQxNSArPSB2ICogYjE7XG4gIHQxNiArPSB2ICogYjI7XG4gIHQxNyArPSB2ICogYjM7XG4gIHQxOCArPSB2ICogYjQ7XG4gIHQxOSArPSB2ICogYjU7XG4gIHQyMCArPSB2ICogYjY7XG4gIHQyMSArPSB2ICogYjc7XG4gIHQyMiArPSB2ICogYjg7XG4gIHQyMyArPSB2ICogYjk7XG4gIHQyNCArPSB2ICogYjEwO1xuICB0MjUgKz0gdiAqIGIxMTtcbiAgdDI2ICs9IHYgKiBiMTI7XG4gIHQyNyArPSB2ICogYjEzO1xuICB0MjggKz0gdiAqIGIxNDtcbiAgdDI5ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzE1XTtcbiAgdDE1ICs9IHYgKiBiMDtcbiAgdDE2ICs9IHYgKiBiMTtcbiAgdDE3ICs9IHYgKiBiMjtcbiAgdDE4ICs9IHYgKiBiMztcbiAgdDE5ICs9IHYgKiBiNDtcbiAgdDIwICs9IHYgKiBiNTtcbiAgdDIxICs9IHYgKiBiNjtcbiAgdDIyICs9IHYgKiBiNztcbiAgdDIzICs9IHYgKiBiODtcbiAgdDI0ICs9IHYgKiBiOTtcbiAgdDI1ICs9IHYgKiBiMTA7XG4gIHQyNiArPSB2ICogYjExO1xuICB0MjcgKz0gdiAqIGIxMjtcbiAgdDI4ICs9IHYgKiBiMTM7XG4gIHQyOSArPSB2ICogYjE0O1xuICB0MzAgKz0gdiAqIGIxNTtcblxuICB0MCAgKz0gMzggKiB0MTY7XG4gIHQxICArPSAzOCAqIHQxNztcbiAgdDIgICs9IDM4ICogdDE4O1xuICB0MyAgKz0gMzggKiB0MTk7XG4gIHQ0ICArPSAzOCAqIHQyMDtcbiAgdDUgICs9IDM4ICogdDIxO1xuICB0NiAgKz0gMzggKiB0MjI7XG4gIHQ3ICArPSAzOCAqIHQyMztcbiAgdDggICs9IDM4ICogdDI0O1xuICB0OSAgKz0gMzggKiB0MjU7XG4gIHQxMCArPSAzOCAqIHQyNjtcbiAgdDExICs9IDM4ICogdDI3O1xuICB0MTIgKz0gMzggKiB0Mjg7XG4gIHQxMyArPSAzOCAqIHQyOTtcbiAgdDE0ICs9IDM4ICogdDMwO1xuICAvLyB0MTUgbGVmdCBhcyBpc1xuXG4gIC8vIGZpcnN0IGNhclxuICBjID0gMTtcbiAgdiA9ICB0MCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQxID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ2ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ3ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ4ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ5ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDExID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdDAgKz0gYy0xICsgMzcgKiAoYy0xKTtcblxuICAvLyBzZWNvbmQgY2FyXG4gIGMgPSAxO1xuICB2ID0gIHQwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQxICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDUgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ2ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDYgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ3ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDcgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ4ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDggPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ5ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDkgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDExICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTUgPSB2IC0gYyAqIDY1NTM2O1xuICB0MCArPSBjLTEgKyAzNyAqIChjLTEpO1xuXG4gIG9bIDBdID0gdDA7XG4gIG9bIDFdID0gdDE7XG4gIG9bIDJdID0gdDI7XG4gIG9bIDNdID0gdDM7XG4gIG9bIDRdID0gdDQ7XG4gIG9bIDVdID0gdDU7XG4gIG9bIDZdID0gdDY7XG4gIG9bIDddID0gdDc7XG4gIG9bIDhdID0gdDg7XG4gIG9bIDldID0gdDk7XG4gIG9bMTBdID0gdDEwO1xuICBvWzExXSA9IHQxMTtcbiAgb1sxMl0gPSB0MTI7XG4gIG9bMTNdID0gdDEzO1xuICBvWzE0XSA9IHQxNDtcbiAgb1sxNV0gPSB0MTU7XG59XG4iXSwibmFtZXMiOlsiZm9yZ2UiLCJyZXF1aXJlIiwiYXNuMVZhbGlkYXRvciIsInB1YmxpY0tleVZhbGlkYXRvciIsInByaXZhdGVLZXlWYWxpZGF0b3IiLCJCaWdJbnRlZ2VyIiwianNibiIsIkJ5dGVCdWZmZXIiLCJ1dGlsIiwiTmF0aXZlQnVmZmVyIiwiQnVmZmVyIiwiVWludDhBcnJheSIsInBraSIsIm1vZHVsZSIsImV4cG9ydHMiLCJlZDI1NTE5IiwiY29uc3RhbnRzIiwiUFVCTElDX0tFWV9CWVRFX0xFTkdUSCIsIlBSSVZBVEVfS0VZX0JZVEVfTEVOR1RIIiwiU0VFRF9CWVRFX0xFTkdUSCIsIlNJR05fQllURV9MRU5HVEgiLCJIQVNIX0JZVEVfTEVOR1RIIiwiZ2VuZXJhdGVLZXlQYWlyIiwib3B0aW9ucyIsInNlZWQiLCJ1bmRlZmluZWQiLCJyYW5kb20iLCJnZXRCeXRlc1N5bmMiLCJsZW5ndGgiLCJUeXBlRXJyb3IiLCJtZXNzYWdlVG9OYXRpdmVCdWZmZXIiLCJtZXNzYWdlIiwiZW5jb2RpbmciLCJwayIsInNrIiwiaSIsImNyeXB0b19zaWduX2tleXBhaXIiLCJwdWJsaWNLZXkiLCJwcml2YXRlS2V5IiwicHJpdmF0ZUtleUZyb21Bc24xIiwib2JqIiwiY2FwdHVyZSIsImVycm9ycyIsInZhbGlkIiwiYXNuMSIsInZhbGlkYXRlIiwiZXJyb3IiLCJFcnJvciIsIm9pZCIsImRlclRvT2lkIiwicHJpdmF0ZUtleU9pZCIsImVkMjU1MTlPaWQiLCJvaWRzIiwiRWREU0EyNTUxOSIsInByaXZhdGVLZXlCeXRlcyIsImZyb21EZXIiLCJ2YWx1ZSIsInB1YmxpY0tleUZyb21Bc24xIiwicHVibGljS2V5T2lkIiwicHVibGljS2V5Qnl0ZXMiLCJlZDI1NTE5UHVibGljS2V5IiwicHVibGljS2V5RnJvbVByaXZhdGVLZXkiLCJzaWduIiwibXNnIiwia2V5UGFpciIsInNpZ25lZE1zZyIsImNyeXB0b19zaWduIiwic2lnIiwidmVyaWZ5Iiwic2lnbmF0dXJlIiwic20iLCJtIiwiY3J5cHRvX3NpZ25fb3BlbiIsIm1kIiwiZGlnZXN0IiwiZ2V0Qnl0ZXMiLCJmcm9tIiwiYnVmZmVyIiwiYXQiLCJnZjAiLCJnZiIsImdmMSIsIkQiLCJEMiIsIlgiLCJZIiwiTCIsIkZsb2F0NjRBcnJheSIsIkkiLCJzaGE1MTIiLCJtc2dMZW4iLCJjcmVhdGUiLCJ1cGRhdGUiLCJoYXNoIiwib3V0IiwiY2hhckNvZGVBdCIsInAiLCJkIiwic2NhbGFyYmFzZSIsInBhY2siLCJuIiwiaiIsIngiLCJzbWxlbiIsInIiLCJzdWJhcnJheSIsInJlZHVjZSIsImgiLCJtb2RMIiwibWxlbiIsInQiLCJxIiwidW5wYWNrbmVnIiwic2NhbGFybXVsdCIsImFkZCIsImNyeXB0b192ZXJpZnlfMzIiLCJjYXJyeSIsImsiLCJhIiwiYiIsImMiLCJlIiwiZiIsImciLCJaIiwiTSIsIkEiLCJjc3dhcCIsInNlbDI1NTE5IiwidHgiLCJ0eSIsInppIiwiaW52MjU1MTkiLCJwYWNrMjU1MTkiLCJwYXIyNTUxOSIsIm8iLCJjYXIyNTUxOSIsImNoayIsIm51bSIsImRlbiIsImRlbjIiLCJkZW40IiwiZGVuNiIsInNldDI1NTE5IiwidW5wYWNrMjU1MTkiLCJTIiwicG93MjUyMyIsIm5lcTI1NTE5IiwieGkiLCJ5IiwieWkiLCJ2biIsInMiLCJ2IiwiTWF0aCIsImZsb29yIiwiaW5pdCIsInQwIiwidDEiLCJ0MiIsInQzIiwidDQiLCJ0NSIsInQ2IiwidDciLCJ0OCIsInQ5IiwidDEwIiwidDExIiwidDEyIiwidDEzIiwidDE0IiwidDE1IiwidDE2IiwidDE3IiwidDE4IiwidDE5IiwidDIwIiwidDIxIiwidDIyIiwidDIzIiwidDI0IiwidDI1IiwidDI2IiwidDI3IiwidDI4IiwidDI5IiwidDMwIiwiYjAiLCJiMSIsImIyIiwiYjMiLCJiNCIsImI1IiwiYjYiLCJiNyIsImI4IiwiYjkiLCJiMTAiLCJiMTEiLCJiMTIiLCJiMTMiLCJiMTQiLCJiMTUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/ed25519.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/forge.js":
/*!**********************************************!*\
  !*** ./node_modules/node-forge/lib/forge.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("/**\n * Node.js module for Forge.\n *\n * @author Dave Longley\n *\n * Copyright 2011-2016 Digital Bazaar, Inc.\n */ \nmodule.exports = {\n    // default options\n    options: {\n        usePureJavaScript: false\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvZm9yZ2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DO0FBQ0RBLE9BQU9DLE9BQU8sR0FBRztJQUNmLGtCQUFrQjtJQUNsQkMsU0FBUztRQUNQQyxtQkFBbUI7SUFDckI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9mb3JnZS5qcz8wNDBlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTm9kZS5qcyBtb2R1bGUgZm9yIEZvcmdlLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IDIwMTEtMjAxNiBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnM6IHtcbiAgICB1c2VQdXJlSmF2YVNjcmlwdDogZmFsc2VcbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwib3B0aW9ucyIsInVzZVB1cmVKYXZhU2NyaXB0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/forge.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/hmac.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/hmac.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Hash-based Message Authentication Code implementation. Requires a message\n * digest object that can be obtained, for example, from forge.md.sha1 or\n * forge.md.md5.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2012 Digital Bazaar, Inc. All rights reserved.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./md */ \"(rsc)/./node_modules/node-forge/lib/md.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\n/* HMAC API */ var hmac = module.exports = forge.hmac = forge.hmac || {};\n/**\n * Creates an HMAC object that uses the given message digest object.\n *\n * @return an HMAC object.\n */ hmac.create = function() {\n    // the hmac key to use\n    var _key = null;\n    // the message digest to use\n    var _md = null;\n    // the inner padding\n    var _ipadding = null;\n    // the outer padding\n    var _opadding = null;\n    // hmac context\n    var ctx = {};\n    /**\n   * Starts or restarts the HMAC with the given key and message digest.\n   *\n   * @param md the message digest to use, null to reuse the previous one,\n   *           a string to use builtin 'sha1', 'md5', 'sha256'.\n   * @param key the key to use as a string, array of bytes, byte buffer,\n   *           or null to reuse the previous key.\n   */ ctx.start = function(md, key) {\n        if (md !== null) {\n            if (typeof md === \"string\") {\n                // create builtin message digest\n                md = md.toLowerCase();\n                if (md in forge.md.algorithms) {\n                    _md = forge.md.algorithms[md].create();\n                } else {\n                    throw new Error('Unknown hash algorithm \"' + md + '\"');\n                }\n            } else {\n                // store message digest\n                _md = md;\n            }\n        }\n        if (key === null) {\n            // reuse previous key\n            key = _key;\n        } else {\n            if (typeof key === \"string\") {\n                // convert string into byte buffer\n                key = forge.util.createBuffer(key);\n            } else if (forge.util.isArray(key)) {\n                // convert byte array into byte buffer\n                var tmp = key;\n                key = forge.util.createBuffer();\n                for(var i = 0; i < tmp.length; ++i){\n                    key.putByte(tmp[i]);\n                }\n            }\n            // if key is longer than blocksize, hash it\n            var keylen = key.length();\n            if (keylen > _md.blockLength) {\n                _md.start();\n                _md.update(key.bytes());\n                key = _md.digest();\n            }\n            // mix key into inner and outer padding\n            // ipadding = [0x36 * blocksize] ^ key\n            // opadding = [0x5C * blocksize] ^ key\n            _ipadding = forge.util.createBuffer();\n            _opadding = forge.util.createBuffer();\n            keylen = key.length();\n            for(var i = 0; i < keylen; ++i){\n                var tmp = key.at(i);\n                _ipadding.putByte(0x36 ^ tmp);\n                _opadding.putByte(0x5C ^ tmp);\n            }\n            // if key is shorter than blocksize, add additional padding\n            if (keylen < _md.blockLength) {\n                var tmp = _md.blockLength - keylen;\n                for(var i = 0; i < tmp; ++i){\n                    _ipadding.putByte(0x36);\n                    _opadding.putByte(0x5C);\n                }\n            }\n            _key = key;\n            _ipadding = _ipadding.bytes();\n            _opadding = _opadding.bytes();\n        }\n        // digest is done like so: hash(opadding | hash(ipadding | message))\n        // prepare to do inner hash\n        // hash(ipadding | message)\n        _md.start();\n        _md.update(_ipadding);\n    };\n    /**\n   * Updates the HMAC with the given message bytes.\n   *\n   * @param bytes the bytes to update with.\n   */ ctx.update = function(bytes) {\n        _md.update(bytes);\n    };\n    /**\n   * Produces the Message Authentication Code (MAC).\n   *\n   * @return a byte buffer containing the digest value.\n   */ ctx.getMac = function() {\n        // digest is done like so: hash(opadding | hash(ipadding | message))\n        // here we do the outer hashing\n        var inner = _md.digest().bytes();\n        _md.start();\n        _md.update(_opadding);\n        _md.update(inner);\n        return _md.digest();\n    };\n    // alias for getMac\n    ctx.digest = ctx.getMac;\n    return ctx;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvaG1hYy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQztBQUNELElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUVSLFlBQVksR0FDWixJQUFJQyxPQUFPQyxPQUFPQyxPQUFPLEdBQUdKLE1BQU1FLElBQUksR0FBR0YsTUFBTUUsSUFBSSxJQUFJLENBQUM7QUFFeEQ7Ozs7Q0FJQyxHQUNEQSxLQUFLRyxNQUFNLEdBQUc7SUFDWixzQkFBc0I7SUFDdEIsSUFBSUMsT0FBTztJQUVYLDRCQUE0QjtJQUM1QixJQUFJQyxNQUFNO0lBRVYsb0JBQW9CO0lBQ3BCLElBQUlDLFlBQVk7SUFFaEIsb0JBQW9CO0lBQ3BCLElBQUlDLFlBQVk7SUFFaEIsZUFBZTtJQUNmLElBQUlDLE1BQU0sQ0FBQztJQUVYOzs7Ozs7O0dBT0MsR0FDREEsSUFBSUMsS0FBSyxHQUFHLFNBQVNDLEVBQUUsRUFBRUMsR0FBRztRQUMxQixJQUFHRCxPQUFPLE1BQU07WUFDZCxJQUFHLE9BQU9BLE9BQU8sVUFBVTtnQkFDekIsZ0NBQWdDO2dCQUNoQ0EsS0FBS0EsR0FBR0UsV0FBVztnQkFDbkIsSUFBR0YsTUFBTVosTUFBTVksRUFBRSxDQUFDRyxVQUFVLEVBQUU7b0JBQzVCUixNQUFNUCxNQUFNWSxFQUFFLENBQUNHLFVBQVUsQ0FBQ0gsR0FBRyxDQUFDUCxNQUFNO2dCQUN0QyxPQUFPO29CQUNMLE1BQU0sSUFBSVcsTUFBTSw2QkFBNkJKLEtBQUs7Z0JBQ3BEO1lBQ0YsT0FBTztnQkFDTCx1QkFBdUI7Z0JBQ3ZCTCxNQUFNSztZQUNSO1FBQ0Y7UUFFQSxJQUFHQyxRQUFRLE1BQU07WUFDZixxQkFBcUI7WUFDckJBLE1BQU1QO1FBQ1IsT0FBTztZQUNMLElBQUcsT0FBT08sUUFBUSxVQUFVO2dCQUMxQixrQ0FBa0M7Z0JBQ2xDQSxNQUFNYixNQUFNaUIsSUFBSSxDQUFDQyxZQUFZLENBQUNMO1lBQ2hDLE9BQU8sSUFBR2IsTUFBTWlCLElBQUksQ0FBQ0UsT0FBTyxDQUFDTixNQUFNO2dCQUNqQyxzQ0FBc0M7Z0JBQ3RDLElBQUlPLE1BQU1QO2dCQUNWQSxNQUFNYixNQUFNaUIsSUFBSSxDQUFDQyxZQUFZO2dCQUM3QixJQUFJLElBQUlHLElBQUksR0FBR0EsSUFBSUQsSUFBSUUsTUFBTSxFQUFFLEVBQUVELEVBQUc7b0JBQ2xDUixJQUFJVSxPQUFPLENBQUNILEdBQUcsQ0FBQ0MsRUFBRTtnQkFDcEI7WUFDRjtZQUVBLDJDQUEyQztZQUMzQyxJQUFJRyxTQUFTWCxJQUFJUyxNQUFNO1lBQ3ZCLElBQUdFLFNBQVNqQixJQUFJa0IsV0FBVyxFQUFFO2dCQUMzQmxCLElBQUlJLEtBQUs7Z0JBQ1RKLElBQUltQixNQUFNLENBQUNiLElBQUljLEtBQUs7Z0JBQ3BCZCxNQUFNTixJQUFJcUIsTUFBTTtZQUNsQjtZQUVBLHVDQUF1QztZQUN2QyxzQ0FBc0M7WUFDdEMsc0NBQXNDO1lBQ3RDcEIsWUFBWVIsTUFBTWlCLElBQUksQ0FBQ0MsWUFBWTtZQUNuQ1QsWUFBWVQsTUFBTWlCLElBQUksQ0FBQ0MsWUFBWTtZQUNuQ00sU0FBU1gsSUFBSVMsTUFBTTtZQUNuQixJQUFJLElBQUlELElBQUksR0FBR0EsSUFBSUcsUUFBUSxFQUFFSCxFQUFHO2dCQUM5QixJQUFJRCxNQUFNUCxJQUFJZ0IsRUFBRSxDQUFDUjtnQkFDakJiLFVBQVVlLE9BQU8sQ0FBQyxPQUFPSDtnQkFDekJYLFVBQVVjLE9BQU8sQ0FBQyxPQUFPSDtZQUMzQjtZQUVBLDJEQUEyRDtZQUMzRCxJQUFHSSxTQUFTakIsSUFBSWtCLFdBQVcsRUFBRTtnQkFDM0IsSUFBSUwsTUFBTWIsSUFBSWtCLFdBQVcsR0FBR0Q7Z0JBQzVCLElBQUksSUFBSUgsSUFBSSxHQUFHQSxJQUFJRCxLQUFLLEVBQUVDLEVBQUc7b0JBQzNCYixVQUFVZSxPQUFPLENBQUM7b0JBQ2xCZCxVQUFVYyxPQUFPLENBQUM7Z0JBQ3BCO1lBQ0Y7WUFDQWpCLE9BQU9PO1lBQ1BMLFlBQVlBLFVBQVVtQixLQUFLO1lBQzNCbEIsWUFBWUEsVUFBVWtCLEtBQUs7UUFDN0I7UUFFQSxvRUFBb0U7UUFFcEUsMkJBQTJCO1FBQzNCLDJCQUEyQjtRQUMzQnBCLElBQUlJLEtBQUs7UUFDVEosSUFBSW1CLE1BQU0sQ0FBQ2xCO0lBQ2I7SUFFQTs7OztHQUlDLEdBQ0RFLElBQUlnQixNQUFNLEdBQUcsU0FBU0MsS0FBSztRQUN6QnBCLElBQUltQixNQUFNLENBQUNDO0lBQ2I7SUFFQTs7OztHQUlDLEdBQ0RqQixJQUFJb0IsTUFBTSxHQUFHO1FBQ1gsb0VBQW9FO1FBQ3BFLCtCQUErQjtRQUMvQixJQUFJQyxRQUFReEIsSUFBSXFCLE1BQU0sR0FBR0QsS0FBSztRQUM5QnBCLElBQUlJLEtBQUs7UUFDVEosSUFBSW1CLE1BQU0sQ0FBQ2pCO1FBQ1hGLElBQUltQixNQUFNLENBQUNLO1FBQ1gsT0FBT3hCLElBQUlxQixNQUFNO0lBQ25CO0lBQ0EsbUJBQW1CO0lBQ25CbEIsSUFBSWtCLE1BQU0sR0FBR2xCLElBQUlvQixNQUFNO0lBRXZCLE9BQU9wQjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2htYWMuanM/ZDhkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhhc2gtYmFzZWQgTWVzc2FnZSBBdXRoZW50aWNhdGlvbiBDb2RlIGltcGxlbWVudGF0aW9uLiBSZXF1aXJlcyBhIG1lc3NhZ2VcbiAqIGRpZ2VzdCBvYmplY3QgdGhhdCBjYW4gYmUgb2J0YWluZWQsIGZvciBleGFtcGxlLCBmcm9tIGZvcmdlLm1kLnNoYTEgb3JcbiAqIGZvcmdlLm1kLm1kNS5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEyIERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vbWQnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vKiBITUFDIEFQSSAqL1xudmFyIGhtYWMgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmhtYWMgPSBmb3JnZS5obWFjIHx8IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gSE1BQyBvYmplY3QgdGhhdCB1c2VzIHRoZSBnaXZlbiBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKlxuICogQHJldHVybiBhbiBITUFDIG9iamVjdC5cbiAqL1xuaG1hYy5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gdGhlIGhtYWMga2V5IHRvIHVzZVxuICB2YXIgX2tleSA9IG51bGw7XG5cbiAgLy8gdGhlIG1lc3NhZ2UgZGlnZXN0IHRvIHVzZVxuICB2YXIgX21kID0gbnVsbDtcblxuICAvLyB0aGUgaW5uZXIgcGFkZGluZ1xuICB2YXIgX2lwYWRkaW5nID0gbnVsbDtcblxuICAvLyB0aGUgb3V0ZXIgcGFkZGluZ1xuICB2YXIgX29wYWRkaW5nID0gbnVsbDtcblxuICAvLyBobWFjIGNvbnRleHRcbiAgdmFyIGN0eCA9IHt9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgb3IgcmVzdGFydHMgdGhlIEhNQUMgd2l0aCB0aGUgZ2l2ZW4ga2V5IGFuZCBtZXNzYWdlIGRpZ2VzdC5cbiAgICpcbiAgICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCB0byB1c2UsIG51bGwgdG8gcmV1c2UgdGhlIHByZXZpb3VzIG9uZSxcbiAgICogICAgICAgICAgIGEgc3RyaW5nIHRvIHVzZSBidWlsdGluICdzaGExJywgJ21kNScsICdzaGEyNTYnLlxuICAgKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdXNlIGFzIGEgc3RyaW5nLCBhcnJheSBvZiBieXRlcywgYnl0ZSBidWZmZXIsXG4gICAqICAgICAgICAgICBvciBudWxsIHRvIHJldXNlIHRoZSBwcmV2aW91cyBrZXkuXG4gICAqL1xuICBjdHguc3RhcnQgPSBmdW5jdGlvbihtZCwga2V5KSB7XG4gICAgaWYobWQgIT09IG51bGwpIHtcbiAgICAgIGlmKHR5cGVvZiBtZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gY3JlYXRlIGJ1aWx0aW4gbWVzc2FnZSBkaWdlc3RcbiAgICAgICAgbWQgPSBtZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZihtZCBpbiBmb3JnZS5tZC5hbGdvcml0aG1zKSB7XG4gICAgICAgICAgX21kID0gZm9yZ2UubWQuYWxnb3JpdGhtc1ttZF0uY3JlYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGhhc2ggYWxnb3JpdGhtIFwiJyArIG1kICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN0b3JlIG1lc3NhZ2UgZGlnZXN0XG4gICAgICAgIF9tZCA9IG1kO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGtleSA9PT0gbnVsbCkge1xuICAgICAgLy8gcmV1c2UgcHJldmlvdXMga2V5XG4gICAgICBrZXkgPSBfa2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZih0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBjb252ZXJ0IHN0cmluZyBpbnRvIGJ5dGUgYnVmZmVyXG4gICAgICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGtleSk7XG4gICAgICB9IGVsc2UgaWYoZm9yZ2UudXRpbC5pc0FycmF5KGtleSkpIHtcbiAgICAgICAgLy8gY29udmVydCBieXRlIGFycmF5IGludG8gYnl0ZSBidWZmZXJcbiAgICAgICAgdmFyIHRtcCA9IGtleTtcbiAgICAgICAga2V5ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleS5wdXRCeXRlKHRtcFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYga2V5IGlzIGxvbmdlciB0aGFuIGJsb2Nrc2l6ZSwgaGFzaCBpdFxuICAgICAgdmFyIGtleWxlbiA9IGtleS5sZW5ndGgoKTtcbiAgICAgIGlmKGtleWxlbiA+IF9tZC5ibG9ja0xlbmd0aCkge1xuICAgICAgICBfbWQuc3RhcnQoKTtcbiAgICAgICAgX21kLnVwZGF0ZShrZXkuYnl0ZXMoKSk7XG4gICAgICAgIGtleSA9IF9tZC5kaWdlc3QoKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWl4IGtleSBpbnRvIGlubmVyIGFuZCBvdXRlciBwYWRkaW5nXG4gICAgICAvLyBpcGFkZGluZyA9IFsweDM2ICogYmxvY2tzaXplXSBeIGtleVxuICAgICAgLy8gb3BhZGRpbmcgPSBbMHg1QyAqIGJsb2Nrc2l6ZV0gXiBrZXlcbiAgICAgIF9pcGFkZGluZyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBfb3BhZGRpbmcgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAga2V5bGVuID0ga2V5Lmxlbmd0aCgpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGtleWxlbjsgKytpKSB7XG4gICAgICAgIHZhciB0bXAgPSBrZXkuYXQoaSk7XG4gICAgICAgIF9pcGFkZGluZy5wdXRCeXRlKDB4MzYgXiB0bXApO1xuICAgICAgICBfb3BhZGRpbmcucHV0Qnl0ZSgweDVDIF4gdG1wKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYga2V5IGlzIHNob3J0ZXIgdGhhbiBibG9ja3NpemUsIGFkZCBhZGRpdGlvbmFsIHBhZGRpbmdcbiAgICAgIGlmKGtleWxlbiA8IF9tZC5ibG9ja0xlbmd0aCkge1xuICAgICAgICB2YXIgdG1wID0gX21kLmJsb2NrTGVuZ3RoIC0ga2V5bGVuO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wOyArK2kpIHtcbiAgICAgICAgICBfaXBhZGRpbmcucHV0Qnl0ZSgweDM2KTtcbiAgICAgICAgICBfb3BhZGRpbmcucHV0Qnl0ZSgweDVDKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX2tleSA9IGtleTtcbiAgICAgIF9pcGFkZGluZyA9IF9pcGFkZGluZy5ieXRlcygpO1xuICAgICAgX29wYWRkaW5nID0gX29wYWRkaW5nLmJ5dGVzKCk7XG4gICAgfVxuXG4gICAgLy8gZGlnZXN0IGlzIGRvbmUgbGlrZSBzbzogaGFzaChvcGFkZGluZyB8IGhhc2goaXBhZGRpbmcgfCBtZXNzYWdlKSlcblxuICAgIC8vIHByZXBhcmUgdG8gZG8gaW5uZXIgaGFzaFxuICAgIC8vIGhhc2goaXBhZGRpbmcgfCBtZXNzYWdlKVxuICAgIF9tZC5zdGFydCgpO1xuICAgIF9tZC51cGRhdGUoX2lwYWRkaW5nKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgSE1BQyB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIHVwZGF0ZSB3aXRoLlxuICAgKi9cbiAgY3R4LnVwZGF0ZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgX21kLnVwZGF0ZShieXRlcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIHRoZSBNZXNzYWdlIEF1dGhlbnRpY2F0aW9uIENvZGUgKE1BQykuXG4gICAqXG4gICAqIEByZXR1cm4gYSBieXRlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBkaWdlc3QgdmFsdWUuXG4gICAqL1xuICBjdHguZ2V0TWFjID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gZGlnZXN0IGlzIGRvbmUgbGlrZSBzbzogaGFzaChvcGFkZGluZyB8IGhhc2goaXBhZGRpbmcgfCBtZXNzYWdlKSlcbiAgICAvLyBoZXJlIHdlIGRvIHRoZSBvdXRlciBoYXNoaW5nXG4gICAgdmFyIGlubmVyID0gX21kLmRpZ2VzdCgpLmJ5dGVzKCk7XG4gICAgX21kLnN0YXJ0KCk7XG4gICAgX21kLnVwZGF0ZShfb3BhZGRpbmcpO1xuICAgIF9tZC51cGRhdGUoaW5uZXIpO1xuICAgIHJldHVybiBfbWQuZGlnZXN0KCk7XG4gIH07XG4gIC8vIGFsaWFzIGZvciBnZXRNYWNcbiAgY3R4LmRpZ2VzdCA9IGN0eC5nZXRNYWM7XG5cbiAgcmV0dXJuIGN0eDtcbn07XG4iXSwibmFtZXMiOlsiZm9yZ2UiLCJyZXF1aXJlIiwiaG1hYyIsIm1vZHVsZSIsImV4cG9ydHMiLCJjcmVhdGUiLCJfa2V5IiwiX21kIiwiX2lwYWRkaW5nIiwiX29wYWRkaW5nIiwiY3R4Iiwic3RhcnQiLCJtZCIsImtleSIsInRvTG93ZXJDYXNlIiwiYWxnb3JpdGhtcyIsIkVycm9yIiwidXRpbCIsImNyZWF0ZUJ1ZmZlciIsImlzQXJyYXkiLCJ0bXAiLCJpIiwibGVuZ3RoIiwicHV0Qnl0ZSIsImtleWxlbiIsImJsb2NrTGVuZ3RoIiwidXBkYXRlIiwiYnl0ZXMiLCJkaWdlc3QiLCJhdCIsImdldE1hYyIsImlubmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/hmac.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/node-forge/lib/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Node.js module for Forge.\n *\n * @author Dave Longley\n *\n * Copyright 2011-2016 Digital Bazaar, Inc.\n */ \nmodule.exports = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./aes */ \"(rsc)/./node_modules/node-forge/lib/aes.js\");\n__webpack_require__(/*! ./aesCipherSuites */ \"(rsc)/./node_modules/node-forge/lib/aesCipherSuites.js\");\n__webpack_require__(/*! ./asn1 */ \"(rsc)/./node_modules/node-forge/lib/asn1.js\");\n__webpack_require__(/*! ./cipher */ \"(rsc)/./node_modules/node-forge/lib/cipher.js\");\n__webpack_require__(/*! ./des */ \"(rsc)/./node_modules/node-forge/lib/des.js\");\n__webpack_require__(/*! ./ed25519 */ \"(rsc)/./node_modules/node-forge/lib/ed25519.js\");\n__webpack_require__(/*! ./hmac */ \"(rsc)/./node_modules/node-forge/lib/hmac.js\");\n__webpack_require__(/*! ./kem */ \"(rsc)/./node_modules/node-forge/lib/kem.js\");\n__webpack_require__(/*! ./log */ \"(rsc)/./node_modules/node-forge/lib/log.js\");\n__webpack_require__(/*! ./md.all */ \"(rsc)/./node_modules/node-forge/lib/md.all.js\");\n__webpack_require__(/*! ./mgf1 */ \"(rsc)/./node_modules/node-forge/lib/mgf1.js\");\n__webpack_require__(/*! ./pbkdf2 */ \"(rsc)/./node_modules/node-forge/lib/pbkdf2.js\");\n__webpack_require__(/*! ./pem */ \"(rsc)/./node_modules/node-forge/lib/pem.js\");\n__webpack_require__(/*! ./pkcs1 */ \"(rsc)/./node_modules/node-forge/lib/pkcs1.js\");\n__webpack_require__(/*! ./pkcs12 */ \"(rsc)/./node_modules/node-forge/lib/pkcs12.js\");\n__webpack_require__(/*! ./pkcs7 */ \"(rsc)/./node_modules/node-forge/lib/pkcs7.js\");\n__webpack_require__(/*! ./pki */ \"(rsc)/./node_modules/node-forge/lib/pki.js\");\n__webpack_require__(/*! ./prime */ \"(rsc)/./node_modules/node-forge/lib/prime.js\");\n__webpack_require__(/*! ./prng */ \"(rsc)/./node_modules/node-forge/lib/prng.js\");\n__webpack_require__(/*! ./pss */ \"(rsc)/./node_modules/node-forge/lib/pss.js\");\n__webpack_require__(/*! ./random */ \"(rsc)/./node_modules/node-forge/lib/random.js\");\n__webpack_require__(/*! ./rc2 */ \"(rsc)/./node_modules/node-forge/lib/rc2.js\");\n__webpack_require__(/*! ./ssh */ \"(rsc)/./node_modules/node-forge/lib/ssh.js\");\n__webpack_require__(/*! ./tls */ \"(rsc)/./node_modules/node-forge/lib/tls.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DO0FBQ0RBLG1HQUF5QjtBQUN6QkUsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvaW5kZXguanM/OGU0NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE5vZGUuanMgbW9kdWxlIGZvciBGb3JnZS5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAyMDExLTIwMTYgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL2FlcycpO1xucmVxdWlyZSgnLi9hZXNDaXBoZXJTdWl0ZXMnKTtcbnJlcXVpcmUoJy4vYXNuMScpO1xucmVxdWlyZSgnLi9jaXBoZXInKTtcbnJlcXVpcmUoJy4vZGVzJyk7XG5yZXF1aXJlKCcuL2VkMjU1MTknKTtcbnJlcXVpcmUoJy4vaG1hYycpO1xucmVxdWlyZSgnLi9rZW0nKTtcbnJlcXVpcmUoJy4vbG9nJyk7XG5yZXF1aXJlKCcuL21kLmFsbCcpO1xucmVxdWlyZSgnLi9tZ2YxJyk7XG5yZXF1aXJlKCcuL3Bia2RmMicpO1xucmVxdWlyZSgnLi9wZW0nKTtcbnJlcXVpcmUoJy4vcGtjczEnKTtcbnJlcXVpcmUoJy4vcGtjczEyJyk7XG5yZXF1aXJlKCcuL3BrY3M3Jyk7XG5yZXF1aXJlKCcuL3BraScpO1xucmVxdWlyZSgnLi9wcmltZScpO1xucmVxdWlyZSgnLi9wcm5nJyk7XG5yZXF1aXJlKCcuL3BzcycpO1xucmVxdWlyZSgnLi9yYW5kb20nKTtcbnJlcXVpcmUoJy4vcmMyJyk7XG5yZXF1aXJlKCcuL3NzaCcpO1xucmVxdWlyZSgnLi90bHMnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/jsbn.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/jsbn.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright (c) 2005  Tom Wu\n// All Rights Reserved.\n// See \"LICENSE\" for details.\n// Basic JavaScript BN library - subset useful for RSA encryption.\n/*\nLicensing (LICENSE)\n-------------------\n\nThis software is covered under the following copyright:\n*/ /*\n * Copyright (c) 2003-2005  Tom Wu\n * All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY\n * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n *\n * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,\n * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER\n * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF\n * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT\n * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n * In addition, the following condition applies:\n *\n * All redistributions must retain an intact copy of this copyright notice\n * and disclaimer.\n */ /*\nAddress all questions regarding this license to:\n\n  Tom Wu\n  tjw@cs.Stanford.EDU\n*/ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\nmodule.exports = forge.jsbn = forge.jsbn || {};\n// Bits per digit\nvar dbits;\n// JavaScript engine analysis\nvar canary = 0xdeadbeefcafe;\nvar j_lm = (canary & 0xffffff) == 0xefcafe;\n// (public) Constructor\nfunction BigInteger(a, b, c) {\n    this.data = [];\n    if (a != null) if (\"number\" == typeof a) this.fromNumber(a, b, c);\n    else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n    else this.fromString(a, b);\n}\nforge.jsbn.BigInteger = BigInteger;\n// return new, unset BigInteger\nfunction nbi() {\n    return new BigInteger(null);\n}\n// am: Compute w_j += (x*this_i), propagate carries,\n// c is initial carry, returns final carry.\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n// We need to select the fastest one that works in this environment.\n// am1: use a single mult and divide to get the high bits,\n// max digit bits should be 26 because\n// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\nfunction am1(i, x, w, j, c, n) {\n    while(--n >= 0){\n        var v = x * this.data[i++] + w.data[j] + c;\n        c = Math.floor(v / 0x4000000);\n        w.data[j++] = v & 0x3ffffff;\n    }\n    return c;\n}\n// am2 avoids a big mult-and-extract completely.\n// Max digit bits should be <= 30 because we do bitwise ops\n// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\nfunction am2(i, x, w, j, c, n) {\n    var xl = x & 0x7fff, xh = x >> 15;\n    while(--n >= 0){\n        var l = this.data[i] & 0x7fff;\n        var h = this.data[i++] >> 15;\n        var m = xh * l + h * xl;\n        l = xl * l + ((m & 0x7fff) << 15) + w.data[j] + (c & 0x3fffffff);\n        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n        w.data[j++] = l & 0x3fffffff;\n    }\n    return c;\n}\n// Alternately, set max digit bits to 28 since some\n// browsers slow down when dealing with 32-bit numbers.\nfunction am3(i, x, w, j, c, n) {\n    var xl = x & 0x3fff, xh = x >> 14;\n    while(--n >= 0){\n        var l = this.data[i] & 0x3fff;\n        var h = this.data[i++] >> 14;\n        var m = xh * l + h * xl;\n        l = xl * l + ((m & 0x3fff) << 14) + w.data[j] + c;\n        c = (l >> 28) + (m >> 14) + xh * h;\n        w.data[j++] = l & 0xfffffff;\n    }\n    return c;\n}\n// node.js (no browser)\nif (typeof navigator === \"undefined\") {\n    BigInteger.prototype.am = am3;\n    dbits = 28;\n} else if (j_lm && navigator.appName == \"Microsoft Internet Explorer\") {\n    BigInteger.prototype.am = am2;\n    dbits = 30;\n} else if (j_lm && navigator.appName != \"Netscape\") {\n    BigInteger.prototype.am = am1;\n    dbits = 26;\n} else {\n    BigInteger.prototype.am = am3;\n    dbits = 28;\n}\nBigInteger.prototype.DB = dbits;\nBigInteger.prototype.DM = (1 << dbits) - 1;\nBigInteger.prototype.DV = 1 << dbits;\nvar BI_FP = 52;\nBigInteger.prototype.FV = Math.pow(2, BI_FP);\nBigInteger.prototype.F1 = BI_FP - dbits;\nBigInteger.prototype.F2 = 2 * dbits - BI_FP;\n// Digit conversions\nvar BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\nvar BI_RC = new Array();\nvar rr, vv;\nrr = \"0\".charCodeAt(0);\nfor(vv = 0; vv <= 9; ++vv)BI_RC[rr++] = vv;\nrr = \"a\".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv)BI_RC[rr++] = vv;\nrr = \"A\".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv)BI_RC[rr++] = vv;\nfunction int2char(n) {\n    return BI_RM.charAt(n);\n}\nfunction intAt(s, i) {\n    var c = BI_RC[s.charCodeAt(i)];\n    return c == null ? -1 : c;\n}\n// (protected) copy this to r\nfunction bnpCopyTo(r) {\n    for(var i = this.t - 1; i >= 0; --i)r.data[i] = this.data[i];\n    r.t = this.t;\n    r.s = this.s;\n}\n// (protected) set from integer value x, -DV <= x < DV\nfunction bnpFromInt(x) {\n    this.t = 1;\n    this.s = x < 0 ? -1 : 0;\n    if (x > 0) this.data[0] = x;\n    else if (x < -1) this.data[0] = x + this.DV;\n    else this.t = 0;\n}\n// return bigint initialized to value\nfunction nbv(i) {\n    var r = nbi();\n    r.fromInt(i);\n    return r;\n}\n// (protected) set from string and radix\nfunction bnpFromString(s, b) {\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 256) k = 8; // byte array\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else {\n        this.fromRadix(s, b);\n        return;\n    }\n    this.t = 0;\n    this.s = 0;\n    var i = s.length, mi = false, sh = 0;\n    while(--i >= 0){\n        var x = k == 8 ? s[i] & 0xff : intAt(s, i);\n        if (x < 0) {\n            if (s.charAt(i) == \"-\") mi = true;\n            continue;\n        }\n        mi = false;\n        if (sh == 0) this.data[this.t++] = x;\n        else if (sh + k > this.DB) {\n            this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;\n            this.data[this.t++] = x >> this.DB - sh;\n        } else this.data[this.t - 1] |= x << sh;\n        sh += k;\n        if (sh >= this.DB) sh -= this.DB;\n    }\n    if (k == 8 && (s[0] & 0x80) != 0) {\n        this.s = -1;\n        if (sh > 0) this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;\n    }\n    this.clamp();\n    if (mi) BigInteger.ZERO.subTo(this, this);\n}\n// (protected) clamp off excess high words\nfunction bnpClamp() {\n    var c = this.s & this.DM;\n    while(this.t > 0 && this.data[this.t - 1] == c)--this.t;\n}\n// (public) return string representation in given radix\nfunction bnToString(b) {\n    if (this.s < 0) return \"-\" + this.negate().toString(b);\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else return this.toRadix(b);\n    var km = (1 << k) - 1, d, m = false, r = \"\", i = this.t;\n    var p = this.DB - i * this.DB % k;\n    if (i-- > 0) {\n        if (p < this.DB && (d = this.data[i] >> p) > 0) {\n            m = true;\n            r = int2char(d);\n        }\n        while(i >= 0){\n            if (p < k) {\n                d = (this.data[i] & (1 << p) - 1) << k - p;\n                d |= this.data[--i] >> (p += this.DB - k);\n            } else {\n                d = this.data[i] >> (p -= k) & km;\n                if (p <= 0) {\n                    p += this.DB;\n                    --i;\n                }\n            }\n            if (d > 0) m = true;\n            if (m) r += int2char(d);\n        }\n    }\n    return m ? r : \"0\";\n}\n// (public) -this\nfunction bnNegate() {\n    var r = nbi();\n    BigInteger.ZERO.subTo(this, r);\n    return r;\n}\n// (public) |this|\nfunction bnAbs() {\n    return this.s < 0 ? this.negate() : this;\n}\n// (public) return + if this > a, - if this < a, 0 if equal\nfunction bnCompareTo(a) {\n    var r = this.s - a.s;\n    if (r != 0) return r;\n    var i = this.t;\n    r = i - a.t;\n    if (r != 0) return this.s < 0 ? -r : r;\n    while(--i >= 0)if ((r = this.data[i] - a.data[i]) != 0) return r;\n    return 0;\n}\n// returns bit length of the integer x\nfunction nbits(x) {\n    var r = 1, t;\n    if ((t = x >>> 16) != 0) {\n        x = t;\n        r += 16;\n    }\n    if ((t = x >> 8) != 0) {\n        x = t;\n        r += 8;\n    }\n    if ((t = x >> 4) != 0) {\n        x = t;\n        r += 4;\n    }\n    if ((t = x >> 2) != 0) {\n        x = t;\n        r += 2;\n    }\n    if ((t = x >> 1) != 0) {\n        x = t;\n        r += 1;\n    }\n    return r;\n}\n// (public) return the number of bits in \"this\"\nfunction bnBitLength() {\n    if (this.t <= 0) return 0;\n    return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);\n}\n// (protected) r = this << n*DB\nfunction bnpDLShiftTo(n, r) {\n    var i;\n    for(i = this.t - 1; i >= 0; --i)r.data[i + n] = this.data[i];\n    for(i = n - 1; i >= 0; --i)r.data[i] = 0;\n    r.t = this.t + n;\n    r.s = this.s;\n}\n// (protected) r = this >> n*DB\nfunction bnpDRShiftTo(n, r) {\n    for(var i = n; i < this.t; ++i)r.data[i - n] = this.data[i];\n    r.t = Math.max(this.t - n, 0);\n    r.s = this.s;\n}\n// (protected) r = this << n\nfunction bnpLShiftTo(n, r) {\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << cbs) - 1;\n    var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;\n    for(i = this.t - 1; i >= 0; --i){\n        r.data[i + ds + 1] = this.data[i] >> cbs | c;\n        c = (this.data[i] & bm) << bs;\n    }\n    for(i = ds - 1; i >= 0; --i)r.data[i] = 0;\n    r.data[ds] = c;\n    r.t = this.t + ds + 1;\n    r.s = this.s;\n    r.clamp();\n}\n// (protected) r = this >> n\nfunction bnpRShiftTo(n, r) {\n    r.s = this.s;\n    var ds = Math.floor(n / this.DB);\n    if (ds >= this.t) {\n        r.t = 0;\n        return;\n    }\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << bs) - 1;\n    r.data[0] = this.data[ds] >> bs;\n    for(var i = ds + 1; i < this.t; ++i){\n        r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;\n        r.data[i - ds] = this.data[i] >> bs;\n    }\n    if (bs > 0) r.data[this.t - ds - 1] |= (this.s & bm) << cbs;\n    r.t = this.t - ds;\n    r.clamp();\n}\n// (protected) r = this - a\nfunction bnpSubTo(a, r) {\n    var i = 0, c = 0, m = Math.min(a.t, this.t);\n    while(i < m){\n        c += this.data[i] - a.data[i];\n        r.data[i++] = c & this.DM;\n        c >>= this.DB;\n    }\n    if (a.t < this.t) {\n        c -= a.s;\n        while(i < this.t){\n            c += this.data[i];\n            r.data[i++] = c & this.DM;\n            c >>= this.DB;\n        }\n        c += this.s;\n    } else {\n        c += this.s;\n        while(i < a.t){\n            c -= a.data[i];\n            r.data[i++] = c & this.DM;\n            c >>= this.DB;\n        }\n        c -= a.s;\n    }\n    r.s = c < 0 ? -1 : 0;\n    if (c < -1) r.data[i++] = this.DV + c;\n    else if (c > 0) r.data[i++] = c;\n    r.t = i;\n    r.clamp();\n}\n// (protected) r = this * a, r != this,a (HAC 14.12)\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyTo(a, r) {\n    var x = this.abs(), y = a.abs();\n    var i = x.t;\n    r.t = i + y.t;\n    while(--i >= 0)r.data[i] = 0;\n    for(i = 0; i < y.t; ++i)r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);\n    r.s = 0;\n    r.clamp();\n    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n}\n// (protected) r = this^2, r != this (HAC 14.16)\nfunction bnpSquareTo(r) {\n    var x = this.abs();\n    var i = r.t = 2 * x.t;\n    while(--i >= 0)r.data[i] = 0;\n    for(i = 0; i < x.t - 1; ++i){\n        var c = x.am(i, x.data[i], r, 2 * i, 0, 1);\n        if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {\n            r.data[i + x.t] -= x.DV;\n            r.data[i + x.t + 1] = 1;\n        }\n    }\n    if (r.t > 0) r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);\n    r.s = 0;\n    r.clamp();\n}\n// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n// r != q, this != m.  q or r may be null.\nfunction bnpDivRemTo(m, q, r) {\n    var pm = m.abs();\n    if (pm.t <= 0) return;\n    var pt = this.abs();\n    if (pt.t < pm.t) {\n        if (q != null) q.fromInt(0);\n        if (r != null) this.copyTo(r);\n        return;\n    }\n    if (r == null) r = nbi();\n    var y = nbi(), ts = this.s, ms = m.s;\n    var nsh = this.DB - nbits(pm.data[pm.t - 1]); // normalize modulus\n    if (nsh > 0) {\n        pm.lShiftTo(nsh, y);\n        pt.lShiftTo(nsh, r);\n    } else {\n        pm.copyTo(y);\n        pt.copyTo(r);\n    }\n    var ys = y.t;\n    var y0 = y.data[ys - 1];\n    if (y0 == 0) return;\n    var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);\n    var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;\n    var i = r.t, j = i - ys, t = q == null ? nbi() : q;\n    y.dlShiftTo(j, t);\n    if (r.compareTo(t) >= 0) {\n        r.data[r.t++] = 1;\n        r.subTo(t, r);\n    }\n    BigInteger.ONE.dlShiftTo(ys, t);\n    t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n    while(y.t < ys)y.data[y.t++] = 0;\n    while(--j >= 0){\n        // Estimate quotient digit\n        var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);\n        if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {\n            y.dlShiftTo(j, t);\n            r.subTo(t, r);\n            while(r.data[i] < --qd)r.subTo(t, r);\n        }\n    }\n    if (q != null) {\n        r.drShiftTo(ys, q);\n        if (ts != ms) BigInteger.ZERO.subTo(q, q);\n    }\n    r.t = ys;\n    r.clamp();\n    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n    if (ts < 0) BigInteger.ZERO.subTo(r, r);\n}\n// (public) this mod a\nfunction bnMod(a) {\n    var r = nbi();\n    this.abs().divRemTo(a, null, r);\n    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n    return r;\n}\n// Modular reduction using \"classic\" algorithm\nfunction Classic(m) {\n    this.m = m;\n}\nfunction cConvert(x) {\n    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n    else return x;\n}\nfunction cRevert(x) {\n    return x;\n}\nfunction cReduce(x) {\n    x.divRemTo(this.m, null, x);\n}\nfunction cMulTo(x, y, r) {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n}\nfunction cSqrTo(x, r) {\n    x.squareTo(r);\n    this.reduce(r);\n}\nClassic.prototype.convert = cConvert;\nClassic.prototype.revert = cRevert;\nClassic.prototype.reduce = cReduce;\nClassic.prototype.mulTo = cMulTo;\nClassic.prototype.sqrTo = cSqrTo;\n// (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n// justification:\n//         xy == 1 (mod m)\n//         xy =  1+km\n//   xy(2-xy) = (1+km)(1-km)\n// x[y(2-xy)] = 1-k^2m^2\n// x[y(2-xy)] == 1 (mod m^2)\n// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n// JS multiply \"overflows\" differently from C/C++, so care is needed here.\nfunction bnpInvDigit() {\n    if (this.t < 1) return 0;\n    var x = this.data[0];\n    if ((x & 1) == 0) return 0;\n    var y = x & 3; // y == 1/x mod 2^2\n    y = y * (2 - (x & 0xf) * y) & 0xf; // y == 1/x mod 2^4\n    y = y * (2 - (x & 0xff) * y) & 0xff; // y == 1/x mod 2^8\n    y = y * (2 - ((x & 0xffff) * y & 0xffff)) & 0xffff; // y == 1/x mod 2^16\n    // last step - calculate inverse mod DV directly;\n    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n    y = y * (2 - x * y % this.DV) % this.DV; // y == 1/x mod 2^dbits\n    // we really want the negative inverse, and -DV < y < DV\n    return y > 0 ? this.DV - y : -y;\n}\n// Montgomery reduction\nfunction Montgomery(m) {\n    this.m = m;\n    this.mp = m.invDigit();\n    this.mpl = this.mp & 0x7fff;\n    this.mph = this.mp >> 15;\n    this.um = (1 << m.DB - 15) - 1;\n    this.mt2 = 2 * m.t;\n}\n// xR mod m\nfunction montConvert(x) {\n    var r = nbi();\n    x.abs().dlShiftTo(this.m.t, r);\n    r.divRemTo(this.m, null, r);\n    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n    return r;\n}\n// x/R mod m\nfunction montRevert(x) {\n    var r = nbi();\n    x.copyTo(r);\n    this.reduce(r);\n    return r;\n}\n// x = x/R mod m (HAC 14.32)\nfunction montReduce(x) {\n    while(x.t <= this.mt2)x.data[x.t++] = 0;\n    for(var i = 0; i < this.m.t; ++i){\n        // faster way of calculating u0 = x.data[i]*mp mod DV\n        var j = x.data[i] & 0x7fff;\n        var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;\n        // use am to combine the multiply-shift-add into one call\n        j = i + this.m.t;\n        x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n        // propagate carry\n        while(x.data[j] >= x.DV){\n            x.data[j] -= x.DV;\n            x.data[++j]++;\n        }\n    }\n    x.clamp();\n    x.drShiftTo(this.m.t, x);\n    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n}\n// r = \"x^2/R mod m\"; x != r\nfunction montSqrTo(x, r) {\n    x.squareTo(r);\n    this.reduce(r);\n}\n// r = \"xy/R mod m\"; x,y != r\nfunction montMulTo(x, y, r) {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n}\nMontgomery.prototype.convert = montConvert;\nMontgomery.prototype.revert = montRevert;\nMontgomery.prototype.reduce = montReduce;\nMontgomery.prototype.mulTo = montMulTo;\nMontgomery.prototype.sqrTo = montSqrTo;\n// (protected) true iff this is even\nfunction bnpIsEven() {\n    return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;\n}\n// (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\nfunction bnpExp(e, z) {\n    if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n    var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;\n    g.copyTo(r);\n    while(--i >= 0){\n        z.sqrTo(r, r2);\n        if ((e & 1 << i) > 0) z.mulTo(r2, g, r);\n        else {\n            var t = r;\n            r = r2;\n            r2 = t;\n        }\n    }\n    return z.revert(r);\n}\n// (public) this^e % m, 0 <= e < 2^32\nfunction bnModPowInt(e, m) {\n    var z;\n    if (e < 256 || m.isEven()) z = new Classic(m);\n    else z = new Montgomery(m);\n    return this.exp(e, z);\n}\n// protected\nBigInteger.prototype.copyTo = bnpCopyTo;\nBigInteger.prototype.fromInt = bnpFromInt;\nBigInteger.prototype.fromString = bnpFromString;\nBigInteger.prototype.clamp = bnpClamp;\nBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\nBigInteger.prototype.drShiftTo = bnpDRShiftTo;\nBigInteger.prototype.lShiftTo = bnpLShiftTo;\nBigInteger.prototype.rShiftTo = bnpRShiftTo;\nBigInteger.prototype.subTo = bnpSubTo;\nBigInteger.prototype.multiplyTo = bnpMultiplyTo;\nBigInteger.prototype.squareTo = bnpSquareTo;\nBigInteger.prototype.divRemTo = bnpDivRemTo;\nBigInteger.prototype.invDigit = bnpInvDigit;\nBigInteger.prototype.isEven = bnpIsEven;\nBigInteger.prototype.exp = bnpExp;\n// public\nBigInteger.prototype.toString = bnToString;\nBigInteger.prototype.negate = bnNegate;\nBigInteger.prototype.abs = bnAbs;\nBigInteger.prototype.compareTo = bnCompareTo;\nBigInteger.prototype.bitLength = bnBitLength;\nBigInteger.prototype.mod = bnMod;\nBigInteger.prototype.modPowInt = bnModPowInt;\n// \"constants\"\nBigInteger.ZERO = nbv(0);\nBigInteger.ONE = nbv(1);\n// jsbn2 lib\n//Copyright (c) 2005-2009  Tom Wu\n//All Rights Reserved.\n//See \"LICENSE\" for details (See jsbn.js for LICENSE).\n//Extended JavaScript BN functions, required for RSA private ops.\n//Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n//(public)\nfunction bnClone() {\n    var r = nbi();\n    this.copyTo(r);\n    return r;\n}\n//(public) return value as integer\nfunction bnIntValue() {\n    if (this.s < 0) {\n        if (this.t == 1) return this.data[0] - this.DV;\n        else if (this.t == 0) return -1;\n    } else if (this.t == 1) return this.data[0];\n    else if (this.t == 0) return 0;\n    // assumes 16 < DB < 32\n    return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];\n}\n//(public) return value as byte\nfunction bnByteValue() {\n    return this.t == 0 ? this.s : this.data[0] << 24 >> 24;\n}\n//(public) return value as short (assumes DB>=16)\nfunction bnShortValue() {\n    return this.t == 0 ? this.s : this.data[0] << 16 >> 16;\n}\n//(protected) return x s.t. r^x < DV\nfunction bnpChunkSize(r) {\n    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n}\n//(public) 0 if this == 0, 1 if this > 0\nfunction bnSigNum() {\n    if (this.s < 0) return -1;\n    else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0) return 0;\n    else return 1;\n}\n//(protected) convert to radix string\nfunction bnpToRadix(b) {\n    if (b == null) b = 10;\n    if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n    var cs = this.chunkSize(b);\n    var a = Math.pow(b, cs);\n    var d = nbv(a), y = nbi(), z = nbi(), r = \"\";\n    this.divRemTo(d, y, z);\n    while(y.signum() > 0){\n        r = (a + z.intValue()).toString(b).substr(1) + r;\n        y.divRemTo(d, y, z);\n    }\n    return z.intValue().toString(b) + r;\n}\n//(protected) convert from radix string\nfunction bnpFromRadix(s, b) {\n    this.fromInt(0);\n    if (b == null) b = 10;\n    var cs = this.chunkSize(b);\n    var d = Math.pow(b, cs), mi = false, j = 0, w = 0;\n    for(var i = 0; i < s.length; ++i){\n        var x = intAt(s, i);\n        if (x < 0) {\n            if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n            continue;\n        }\n        w = b * w + x;\n        if (++j >= cs) {\n            this.dMultiply(d);\n            this.dAddOffset(w, 0);\n            j = 0;\n            w = 0;\n        }\n    }\n    if (j > 0) {\n        this.dMultiply(Math.pow(b, j));\n        this.dAddOffset(w, 0);\n    }\n    if (mi) BigInteger.ZERO.subTo(this, this);\n}\n//(protected) alternate constructor\nfunction bnpFromNumber(a, b, c) {\n    if (\"number\" == typeof b) {\n        // new BigInteger(int,int,RNG)\n        if (a < 2) this.fromInt(1);\n        else {\n            this.fromNumber(a, c);\n            if (!this.testBit(a - 1)) this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n            if (this.isEven()) this.dAddOffset(1, 0); // force odd\n            while(!this.isProbablePrime(b)){\n                this.dAddOffset(2, 0);\n                if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n            }\n        }\n    } else {\n        // new BigInteger(int,RNG)\n        var x = new Array(), t = a & 7;\n        x.length = (a >> 3) + 1;\n        b.nextBytes(x);\n        if (t > 0) x[0] &= (1 << t) - 1;\n        else x[0] = 0;\n        this.fromString(x, 256);\n    }\n}\n//(public) convert to bigendian byte array\nfunction bnToByteArray() {\n    var i = this.t, r = new Array();\n    r[0] = this.s;\n    var p = this.DB - i * this.DB % 8, d, k = 0;\n    if (i-- > 0) {\n        if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p) r[k++] = d | this.s << this.DB - p;\n        while(i >= 0){\n            if (p < 8) {\n                d = (this.data[i] & (1 << p) - 1) << 8 - p;\n                d |= this.data[--i] >> (p += this.DB - 8);\n            } else {\n                d = this.data[i] >> (p -= 8) & 0xff;\n                if (p <= 0) {\n                    p += this.DB;\n                    --i;\n                }\n            }\n            if ((d & 0x80) != 0) d |= -256;\n            if (k == 0 && (this.s & 0x80) != (d & 0x80)) ++k;\n            if (k > 0 || d != this.s) r[k++] = d;\n        }\n    }\n    return r;\n}\nfunction bnEquals(a) {\n    return this.compareTo(a) == 0;\n}\nfunction bnMin(a) {\n    return this.compareTo(a) < 0 ? this : a;\n}\nfunction bnMax(a) {\n    return this.compareTo(a) > 0 ? this : a;\n}\n//(protected) r = this op a (bitwise)\nfunction bnpBitwiseTo(a, op, r) {\n    var i, f, m = Math.min(a.t, this.t);\n    for(i = 0; i < m; ++i)r.data[i] = op(this.data[i], a.data[i]);\n    if (a.t < this.t) {\n        f = a.s & this.DM;\n        for(i = m; i < this.t; ++i)r.data[i] = op(this.data[i], f);\n        r.t = this.t;\n    } else {\n        f = this.s & this.DM;\n        for(i = m; i < a.t; ++i)r.data[i] = op(f, a.data[i]);\n        r.t = a.t;\n    }\n    r.s = op(this.s, a.s);\n    r.clamp();\n}\n//(public) this & a\nfunction op_and(x, y) {\n    return x & y;\n}\nfunction bnAnd(a) {\n    var r = nbi();\n    this.bitwiseTo(a, op_and, r);\n    return r;\n}\n//(public) this | a\nfunction op_or(x, y) {\n    return x | y;\n}\nfunction bnOr(a) {\n    var r = nbi();\n    this.bitwiseTo(a, op_or, r);\n    return r;\n}\n//(public) this ^ a\nfunction op_xor(x, y) {\n    return x ^ y;\n}\nfunction bnXor(a) {\n    var r = nbi();\n    this.bitwiseTo(a, op_xor, r);\n    return r;\n}\n//(public) this & ~a\nfunction op_andnot(x, y) {\n    return x & ~y;\n}\nfunction bnAndNot(a) {\n    var r = nbi();\n    this.bitwiseTo(a, op_andnot, r);\n    return r;\n}\n//(public) ~this\nfunction bnNot() {\n    var r = nbi();\n    for(var i = 0; i < this.t; ++i)r.data[i] = this.DM & ~this.data[i];\n    r.t = this.t;\n    r.s = ~this.s;\n    return r;\n}\n//(public) this << n\nfunction bnShiftLeft(n) {\n    var r = nbi();\n    if (n < 0) this.rShiftTo(-n, r);\n    else this.lShiftTo(n, r);\n    return r;\n}\n//(public) this >> n\nfunction bnShiftRight(n) {\n    var r = nbi();\n    if (n < 0) this.lShiftTo(-n, r);\n    else this.rShiftTo(n, r);\n    return r;\n}\n//return index of lowest 1-bit in x, x < 2^31\nfunction lbit(x) {\n    if (x == 0) return -1;\n    var r = 0;\n    if ((x & 0xffff) == 0) {\n        x >>= 16;\n        r += 16;\n    }\n    if ((x & 0xff) == 0) {\n        x >>= 8;\n        r += 8;\n    }\n    if ((x & 0xf) == 0) {\n        x >>= 4;\n        r += 4;\n    }\n    if ((x & 3) == 0) {\n        x >>= 2;\n        r += 2;\n    }\n    if ((x & 1) == 0) ++r;\n    return r;\n}\n//(public) returns index of lowest 1-bit (or -1 if none)\nfunction bnGetLowestSetBit() {\n    for(var i = 0; i < this.t; ++i)if (this.data[i] != 0) return i * this.DB + lbit(this.data[i]);\n    if (this.s < 0) return this.t * this.DB;\n    return -1;\n}\n//return number of 1 bits in x\nfunction cbit(x) {\n    var r = 0;\n    while(x != 0){\n        x &= x - 1;\n        ++r;\n    }\n    return r;\n}\n//(public) return number of set bits\nfunction bnBitCount() {\n    var r = 0, x = this.s & this.DM;\n    for(var i = 0; i < this.t; ++i)r += cbit(this.data[i] ^ x);\n    return r;\n}\n//(public) true iff nth bit is set\nfunction bnTestBit(n) {\n    var j = Math.floor(n / this.DB);\n    if (j >= this.t) return this.s != 0;\n    return (this.data[j] & 1 << n % this.DB) != 0;\n}\n//(protected) this op (1<<n)\nfunction bnpChangeBit(n, op) {\n    var r = BigInteger.ONE.shiftLeft(n);\n    this.bitwiseTo(r, op, r);\n    return r;\n}\n//(public) this | (1<<n)\nfunction bnSetBit(n) {\n    return this.changeBit(n, op_or);\n}\n//(public) this & ~(1<<n)\nfunction bnClearBit(n) {\n    return this.changeBit(n, op_andnot);\n}\n//(public) this ^ (1<<n)\nfunction bnFlipBit(n) {\n    return this.changeBit(n, op_xor);\n}\n//(protected) r = this + a\nfunction bnpAddTo(a, r) {\n    var i = 0, c = 0, m = Math.min(a.t, this.t);\n    while(i < m){\n        c += this.data[i] + a.data[i];\n        r.data[i++] = c & this.DM;\n        c >>= this.DB;\n    }\n    if (a.t < this.t) {\n        c += a.s;\n        while(i < this.t){\n            c += this.data[i];\n            r.data[i++] = c & this.DM;\n            c >>= this.DB;\n        }\n        c += this.s;\n    } else {\n        c += this.s;\n        while(i < a.t){\n            c += a.data[i];\n            r.data[i++] = c & this.DM;\n            c >>= this.DB;\n        }\n        c += a.s;\n    }\n    r.s = c < 0 ? -1 : 0;\n    if (c > 0) r.data[i++] = c;\n    else if (c < -1) r.data[i++] = this.DV + c;\n    r.t = i;\n    r.clamp();\n}\n//(public) this + a\nfunction bnAdd(a) {\n    var r = nbi();\n    this.addTo(a, r);\n    return r;\n}\n//(public) this - a\nfunction bnSubtract(a) {\n    var r = nbi();\n    this.subTo(a, r);\n    return r;\n}\n//(public) this * a\nfunction bnMultiply(a) {\n    var r = nbi();\n    this.multiplyTo(a, r);\n    return r;\n}\n//(public) this / a\nfunction bnDivide(a) {\n    var r = nbi();\n    this.divRemTo(a, r, null);\n    return r;\n}\n//(public) this % a\nfunction bnRemainder(a) {\n    var r = nbi();\n    this.divRemTo(a, null, r);\n    return r;\n}\n//(public) [this/a,this%a]\nfunction bnDivideAndRemainder(a) {\n    var q = nbi(), r = nbi();\n    this.divRemTo(a, q, r);\n    return new Array(q, r);\n}\n//(protected) this *= n, this >= 0, 1 < n < DV\nfunction bnpDMultiply(n) {\n    this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n    ++this.t;\n    this.clamp();\n}\n//(protected) this += n << w words, this >= 0\nfunction bnpDAddOffset(n, w) {\n    if (n == 0) return;\n    while(this.t <= w)this.data[this.t++] = 0;\n    this.data[w] += n;\n    while(this.data[w] >= this.DV){\n        this.data[w] -= this.DV;\n        if (++w >= this.t) this.data[this.t++] = 0;\n        ++this.data[w];\n    }\n}\n//A \"null\" reducer\nfunction NullExp() {}\nfunction nNop(x) {\n    return x;\n}\nfunction nMulTo(x, y, r) {\n    x.multiplyTo(y, r);\n}\nfunction nSqrTo(x, r) {\n    x.squareTo(r);\n}\nNullExp.prototype.convert = nNop;\nNullExp.prototype.revert = nNop;\nNullExp.prototype.mulTo = nMulTo;\nNullExp.prototype.sqrTo = nSqrTo;\n//(public) this^e\nfunction bnPow(e) {\n    return this.exp(e, new NullExp());\n}\n//(protected) r = lower n words of \"this * a\", a.t <= n\n//\"this\" should be the larger one if appropriate.\nfunction bnpMultiplyLowerTo(a, n, r) {\n    var i = Math.min(this.t + a.t, n);\n    r.s = 0; // assumes a,this >= 0\n    r.t = i;\n    while(i > 0)r.data[--i] = 0;\n    var j;\n    for(j = r.t - this.t; i < j; ++i)r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);\n    for(j = Math.min(a.t, n); i < j; ++i)this.am(0, a.data[i], r, i, 0, n - i);\n    r.clamp();\n}\n//(protected) r = \"this * a\" without lower n words, n > 0\n//\"this\" should be the larger one if appropriate.\nfunction bnpMultiplyUpperTo(a, n, r) {\n    --n;\n    var i = r.t = this.t + a.t - n;\n    r.s = 0; // assumes a,this >= 0\n    while(--i >= 0)r.data[i] = 0;\n    for(i = Math.max(n - this.t, 0); i < a.t; ++i)r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);\n    r.clamp();\n    r.drShiftTo(1, r);\n}\n//Barrett modular reduction\nfunction Barrett(m) {\n    // setup Barrett\n    this.r2 = nbi();\n    this.q3 = nbi();\n    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n    this.mu = this.r2.divide(m);\n    this.m = m;\n}\nfunction barrettConvert(x) {\n    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n    else if (x.compareTo(this.m) < 0) return x;\n    else {\n        var r = nbi();\n        x.copyTo(r);\n        this.reduce(r);\n        return r;\n    }\n}\nfunction barrettRevert(x) {\n    return x;\n}\n//x = x mod m (HAC 14.42)\nfunction barrettReduce(x) {\n    x.drShiftTo(this.m.t - 1, this.r2);\n    if (x.t > this.m.t + 1) {\n        x.t = this.m.t + 1;\n        x.clamp();\n    }\n    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n    while(x.compareTo(this.r2) < 0)x.dAddOffset(1, this.m.t + 1);\n    x.subTo(this.r2, x);\n    while(x.compareTo(this.m) >= 0)x.subTo(this.m, x);\n}\n//r = x^2 mod m; x != r\nfunction barrettSqrTo(x, r) {\n    x.squareTo(r);\n    this.reduce(r);\n}\n//r = x*y mod m; x,y != r\nfunction barrettMulTo(x, y, r) {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n}\nBarrett.prototype.convert = barrettConvert;\nBarrett.prototype.revert = barrettRevert;\nBarrett.prototype.reduce = barrettReduce;\nBarrett.prototype.mulTo = barrettMulTo;\nBarrett.prototype.sqrTo = barrettSqrTo;\n//(public) this^e % m (HAC 14.85)\nfunction bnModPow(e, m) {\n    var i = e.bitLength(), k, r = nbv(1), z;\n    if (i <= 0) return r;\n    else if (i < 18) k = 1;\n    else if (i < 48) k = 3;\n    else if (i < 144) k = 4;\n    else if (i < 768) k = 5;\n    else k = 6;\n    if (i < 8) z = new Classic(m);\n    else if (m.isEven()) z = new Barrett(m);\n    else z = new Montgomery(m);\n    // precomputation\n    var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;\n    g[1] = z.convert(this);\n    if (k > 1) {\n        var g2 = nbi();\n        z.sqrTo(g[1], g2);\n        while(n <= km){\n            g[n] = nbi();\n            z.mulTo(g2, g[n - 2], g[n]);\n            n += 2;\n        }\n    }\n    var j = e.t - 1, w, is1 = true, r2 = nbi(), t;\n    i = nbits(e.data[j]) - 1;\n    while(j >= 0){\n        if (i >= k1) w = e.data[j] >> i - k1 & km;\n        else {\n            w = (e.data[j] & (1 << i + 1) - 1) << k1 - i;\n            if (j > 0) w |= e.data[j - 1] >> this.DB + i - k1;\n        }\n        n = k;\n        while((w & 1) == 0){\n            w >>= 1;\n            --n;\n        }\n        if ((i -= n) < 0) {\n            i += this.DB;\n            --j;\n        }\n        if (is1) {\n            g[w].copyTo(r);\n            is1 = false;\n        } else {\n            while(n > 1){\n                z.sqrTo(r, r2);\n                z.sqrTo(r2, r);\n                n -= 2;\n            }\n            if (n > 0) z.sqrTo(r, r2);\n            else {\n                t = r;\n                r = r2;\n                r2 = t;\n            }\n            z.mulTo(r2, g[w], r);\n        }\n        while(j >= 0 && (e.data[j] & 1 << i) == 0){\n            z.sqrTo(r, r2);\n            t = r;\n            r = r2;\n            r2 = t;\n            if (--i < 0) {\n                i = this.DB - 1;\n                --j;\n            }\n        }\n    }\n    return z.revert(r);\n}\n//(public) gcd(this,a) (HAC 14.54)\nfunction bnGCD(a) {\n    var x = this.s < 0 ? this.negate() : this.clone();\n    var y = a.s < 0 ? a.negate() : a.clone();\n    if (x.compareTo(y) < 0) {\n        var t = x;\n        x = y;\n        y = t;\n    }\n    var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n    if (g < 0) return x;\n    if (i < g) g = i;\n    if (g > 0) {\n        x.rShiftTo(g, x);\n        y.rShiftTo(g, y);\n    }\n    while(x.signum() > 0){\n        if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n        if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n        if (x.compareTo(y) >= 0) {\n            x.subTo(y, x);\n            x.rShiftTo(1, x);\n        } else {\n            y.subTo(x, y);\n            y.rShiftTo(1, y);\n        }\n    }\n    if (g > 0) y.lShiftTo(g, y);\n    return y;\n}\n//(protected) this % n, n < 2^26\nfunction bnpModInt(n) {\n    if (n <= 0) return 0;\n    var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;\n    if (this.t > 0) if (d == 0) r = this.data[0] % n;\n    else for(var i = this.t - 1; i >= 0; --i)r = (d * r + this.data[i]) % n;\n    return r;\n}\n//(public) 1/this % m (HAC 14.61)\nfunction bnModInverse(m) {\n    var ac = m.isEven();\n    if (this.isEven() && ac || m.signum() == 0) return BigInteger.ZERO;\n    var u = m.clone(), v = this.clone();\n    var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n    while(u.signum() != 0){\n        while(u.isEven()){\n            u.rShiftTo(1, u);\n            if (ac) {\n                if (!a.isEven() || !b.isEven()) {\n                    a.addTo(this, a);\n                    b.subTo(m, b);\n                }\n                a.rShiftTo(1, a);\n            } else if (!b.isEven()) b.subTo(m, b);\n            b.rShiftTo(1, b);\n        }\n        while(v.isEven()){\n            v.rShiftTo(1, v);\n            if (ac) {\n                if (!c.isEven() || !d.isEven()) {\n                    c.addTo(this, c);\n                    d.subTo(m, d);\n                }\n                c.rShiftTo(1, c);\n            } else if (!d.isEven()) d.subTo(m, d);\n            d.rShiftTo(1, d);\n        }\n        if (u.compareTo(v) >= 0) {\n            u.subTo(v, u);\n            if (ac) a.subTo(c, a);\n            b.subTo(d, b);\n        } else {\n            v.subTo(u, v);\n            if (ac) c.subTo(a, c);\n            d.subTo(b, d);\n        }\n    }\n    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n    if (d.compareTo(m) >= 0) return d.subtract(m);\n    if (d.signum() < 0) d.addTo(m, d);\n    else return d;\n    if (d.signum() < 0) return d.add(m);\n    else return d;\n}\nvar lowprimes = [\n    2,\n    3,\n    5,\n    7,\n    11,\n    13,\n    17,\n    19,\n    23,\n    29,\n    31,\n    37,\n    41,\n    43,\n    47,\n    53,\n    59,\n    61,\n    67,\n    71,\n    73,\n    79,\n    83,\n    89,\n    97,\n    101,\n    103,\n    107,\n    109,\n    113,\n    127,\n    131,\n    137,\n    139,\n    149,\n    151,\n    157,\n    163,\n    167,\n    173,\n    179,\n    181,\n    191,\n    193,\n    197,\n    199,\n    211,\n    223,\n    227,\n    229,\n    233,\n    239,\n    241,\n    251,\n    257,\n    263,\n    269,\n    271,\n    277,\n    281,\n    283,\n    293,\n    307,\n    311,\n    313,\n    317,\n    331,\n    337,\n    347,\n    349,\n    353,\n    359,\n    367,\n    373,\n    379,\n    383,\n    389,\n    397,\n    401,\n    409,\n    419,\n    421,\n    431,\n    433,\n    439,\n    443,\n    449,\n    457,\n    461,\n    463,\n    467,\n    479,\n    487,\n    491,\n    499,\n    503,\n    509\n];\nvar lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n//(public) test primality with certainty >= 1-.5^t\nfunction bnIsProbablePrime(t) {\n    var i, x = this.abs();\n    if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {\n        for(i = 0; i < lowprimes.length; ++i)if (x.data[0] == lowprimes[i]) return true;\n        return false;\n    }\n    if (x.isEven()) return false;\n    i = 1;\n    while(i < lowprimes.length){\n        var m = lowprimes[i], j = i + 1;\n        while(j < lowprimes.length && m < lplim)m *= lowprimes[j++];\n        m = x.modInt(m);\n        while(i < j)if (m % lowprimes[i++] == 0) return false;\n    }\n    return x.millerRabin(t);\n}\n//(protected) true if probably prime (HAC 4.24, Miller-Rabin)\nfunction bnpMillerRabin(t) {\n    var n1 = this.subtract(BigInteger.ONE);\n    var k = n1.getLowestSetBit();\n    if (k <= 0) return false;\n    var r = n1.shiftRight(k);\n    var prng = bnGetPrng();\n    var a;\n    for(var i = 0; i < t; ++i){\n        // select witness 'a' at random from between 1 and n1\n        do {\n            a = new BigInteger(this.bitLength(), prng);\n        }while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);\n        var y = a.modPow(r, this);\n        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n            var j = 1;\n            while(j++ < k && y.compareTo(n1) != 0){\n                y = y.modPowInt(2, this);\n                if (y.compareTo(BigInteger.ONE) == 0) return false;\n            }\n            if (y.compareTo(n1) != 0) return false;\n        }\n    }\n    return true;\n}\n// get pseudo random number generator\nfunction bnGetPrng() {\n    // create prng with api that matches BigInteger secure random\n    return {\n        // x is an array to fill with bytes\n        nextBytes: function(x) {\n            for(var i = 0; i < x.length; ++i){\n                x[i] = Math.floor(Math.random() * 0x0100);\n            }\n        }\n    };\n}\n//protected\nBigInteger.prototype.chunkSize = bnpChunkSize;\nBigInteger.prototype.toRadix = bnpToRadix;\nBigInteger.prototype.fromRadix = bnpFromRadix;\nBigInteger.prototype.fromNumber = bnpFromNumber;\nBigInteger.prototype.bitwiseTo = bnpBitwiseTo;\nBigInteger.prototype.changeBit = bnpChangeBit;\nBigInteger.prototype.addTo = bnpAddTo;\nBigInteger.prototype.dMultiply = bnpDMultiply;\nBigInteger.prototype.dAddOffset = bnpDAddOffset;\nBigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\nBigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\nBigInteger.prototype.modInt = bnpModInt;\nBigInteger.prototype.millerRabin = bnpMillerRabin;\n//public\nBigInteger.prototype.clone = bnClone;\nBigInteger.prototype.intValue = bnIntValue;\nBigInteger.prototype.byteValue = bnByteValue;\nBigInteger.prototype.shortValue = bnShortValue;\nBigInteger.prototype.signum = bnSigNum;\nBigInteger.prototype.toByteArray = bnToByteArray;\nBigInteger.prototype.equals = bnEquals;\nBigInteger.prototype.min = bnMin;\nBigInteger.prototype.max = bnMax;\nBigInteger.prototype.and = bnAnd;\nBigInteger.prototype.or = bnOr;\nBigInteger.prototype.xor = bnXor;\nBigInteger.prototype.andNot = bnAndNot;\nBigInteger.prototype.not = bnNot;\nBigInteger.prototype.shiftLeft = bnShiftLeft;\nBigInteger.prototype.shiftRight = bnShiftRight;\nBigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\nBigInteger.prototype.bitCount = bnBitCount;\nBigInteger.prototype.testBit = bnTestBit;\nBigInteger.prototype.setBit = bnSetBit;\nBigInteger.prototype.clearBit = bnClearBit;\nBigInteger.prototype.flipBit = bnFlipBit;\nBigInteger.prototype.add = bnAdd;\nBigInteger.prototype.subtract = bnSubtract;\nBigInteger.prototype.multiply = bnMultiply;\nBigInteger.prototype.divide = bnDivide;\nBigInteger.prototype.remainder = bnRemainder;\nBigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\nBigInteger.prototype.modPow = bnModPow;\nBigInteger.prototype.modInverse = bnModInverse;\nBigInteger.prototype.pow = bnPow;\nBigInteger.prototype.gcd = bnGCD;\nBigInteger.prototype.isProbablePrime = bnIsProbablePrime; //BigInteger interfaces not implemented in jsbn:\n //BigInteger(int signum, byte[] magnitude)\n //double doubleValue()\n //float floatValue()\n //int hashCode()\n //long longValue()\n //static BigInteger valueOf(long val)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvanNibi5qcyIsIm1hcHBpbmdzIjoiQUFBQSw2QkFBNkI7QUFDN0IsdUJBQXVCO0FBQ3ZCLDZCQUE2QjtBQUU3QixrRUFBa0U7QUFFbEU7Ozs7O0FBS0EsR0FDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E2QkMsR0FDRDs7Ozs7QUFLQTtBQUNBLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBRXBCQyxPQUFPQyxPQUFPLEdBQUdILE1BQU1JLElBQUksR0FBR0osTUFBTUksSUFBSSxJQUFJLENBQUM7QUFFN0MsaUJBQWlCO0FBQ2pCLElBQUlDO0FBRUosNkJBQTZCO0FBQzdCLElBQUlDLFNBQVM7QUFDYixJQUFJQyxPQUFRLENBQUNELFNBQU8sUUFBTyxLQUFJO0FBRS9CLHVCQUF1QjtBQUN2QixTQUFTRSxXQUFXQyxDQUFDLEVBQUNDLENBQUMsRUFBQ0MsQ0FBQztJQUN2QixJQUFJLENBQUNDLElBQUksR0FBRyxFQUFFO0lBQ2QsSUFBR0gsS0FBSyxNQUNOLElBQUcsWUFBWSxPQUFPQSxHQUFHLElBQUksQ0FBQ0ksVUFBVSxDQUFDSixHQUFFQyxHQUFFQztTQUN4QyxJQUFHRCxLQUFLLFFBQVEsWUFBWSxPQUFPRCxHQUFHLElBQUksQ0FBQ0ssVUFBVSxDQUFDTCxHQUFFO1NBQ3hELElBQUksQ0FBQ0ssVUFBVSxDQUFDTCxHQUFFQztBQUMzQjtBQUNBVixNQUFNSSxJQUFJLENBQUNJLFVBQVUsR0FBR0E7QUFFeEIsK0JBQStCO0FBQy9CLFNBQVNPO0lBQVEsT0FBTyxJQUFJUCxXQUFXO0FBQU87QUFFOUMsb0RBQW9EO0FBQ3BELDJDQUEyQztBQUMzQyw4Q0FBOEM7QUFDOUMsb0VBQW9FO0FBRXBFLDBEQUEwRDtBQUMxRCxzQ0FBc0M7QUFDdEMsb0RBQW9EO0FBQ3BELFNBQVNRLElBQUlDLENBQUMsRUFBQ0MsQ0FBQyxFQUFDQyxDQUFDLEVBQUNDLENBQUMsRUFBQ1QsQ0FBQyxFQUFDVSxD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R2pDO0FBQ2xDN08sV0FBV3lCLFNBQVMsQ0FBQ1EsR0FBRyxHQUFHc0w7QUFDM0J2TixXQUFXeUIsU0FBUyxDQUFDc1AsR0FBRyxHQUFHdEM7QUFDM0J6TyxXQUFXeUIsU0FBUyxDQUFDbUosZUFBZSxHQUFHd0UsbUJBRXZDLGdEQUFnRDtDQUVoRCwwQ0FBMEM7Q0FDMUMsc0JBQXNCO0NBQ3RCLG9CQUFvQjtDQUNwQixnQkFBZ0I7Q0FDaEIsa0JBQWtCO0NBQ2xCLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9qc2JuLmpzPzZkZmMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDA1ICBUb20gV3Vcbi8vIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTZWUgXCJMSUNFTlNFXCIgZm9yIGRldGFpbHMuXG5cbi8vIEJhc2ljIEphdmFTY3JpcHQgQk4gbGlicmFyeSAtIHN1YnNldCB1c2VmdWwgZm9yIFJTQSBlbmNyeXB0aW9uLlxuXG4vKlxuTGljZW5zaW5nIChMSUNFTlNFKVxuLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5UaGlzIHNvZnR3YXJlIGlzIGNvdmVyZWQgdW5kZXIgdGhlIGZvbGxvd2luZyBjb3B5cmlnaHQ6XG4qL1xuLypcbiAqIENvcHlyaWdodCAoYykgMjAwMy0yMDA1ICBUb20gV3VcbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG4gKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbiAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMtSVNcIiBBTkQgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MsIElNUExJRUQgT1IgT1RIRVJXSVNFLCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OLCBBTllcbiAqIFdBUlJBTlRZIE9GIE1FUkNIQU5UQUJJTElUWSBPUiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS5cbiAqXG4gKiBJTiBOTyBFVkVOVCBTSEFMTCBUT00gV1UgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgSU5DSURFTlRBTCxcbiAqIElORElSRUNUIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPRiBBTlkgS0lORCwgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUlxuICogUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBPUiBOT1QgQURWSVNFRCBPRlxuICogVEhFIFBPU1NJQklMSVRZIE9GIERBTUFHRSwgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBBUklTSU5HIE9VVFxuICogT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiAqXG4gKiBJbiBhZGRpdGlvbiwgdGhlIGZvbGxvd2luZyBjb25kaXRpb24gYXBwbGllczpcbiAqXG4gKiBBbGwgcmVkaXN0cmlidXRpb25zIG11c3QgcmV0YWluIGFuIGludGFjdCBjb3B5IG9mIHRoaXMgY29weXJpZ2h0IG5vdGljZVxuICogYW5kIGRpc2NsYWltZXIuXG4gKi9cbi8qXG5BZGRyZXNzIGFsbCBxdWVzdGlvbnMgcmVnYXJkaW5nIHRoaXMgbGljZW5zZSB0bzpcblxuICBUb20gV3VcbiAgdGp3QGNzLlN0YW5mb3JkLkVEVVxuKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5qc2JuID0gZm9yZ2UuanNibiB8fCB7fTtcblxuLy8gQml0cyBwZXIgZGlnaXRcbnZhciBkYml0cztcblxuLy8gSmF2YVNjcmlwdCBlbmdpbmUgYW5hbHlzaXNcbnZhciBjYW5hcnkgPSAweGRlYWRiZWVmY2FmZTtcbnZhciBqX2xtID0gKChjYW5hcnkmMHhmZmZmZmYpPT0weGVmY2FmZSk7XG5cbi8vIChwdWJsaWMpIENvbnN0cnVjdG9yXG5mdW5jdGlvbiBCaWdJbnRlZ2VyKGEsYixjKSB7XG4gIHRoaXMuZGF0YSA9IFtdO1xuICBpZihhICE9IG51bGwpXG4gICAgaWYoXCJudW1iZXJcIiA9PSB0eXBlb2YgYSkgdGhpcy5mcm9tTnVtYmVyKGEsYixjKTtcbiAgICBlbHNlIGlmKGIgPT0gbnVsbCAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBhKSB0aGlzLmZyb21TdHJpbmcoYSwyNTYpO1xuICAgIGVsc2UgdGhpcy5mcm9tU3RyaW5nKGEsYik7XG59XG5mb3JnZS5qc2JuLkJpZ0ludGVnZXIgPSBCaWdJbnRlZ2VyO1xuXG4vLyByZXR1cm4gbmV3LCB1bnNldCBCaWdJbnRlZ2VyXG5mdW5jdGlvbiBuYmkoKSB7IHJldHVybiBuZXcgQmlnSW50ZWdlcihudWxsKTsgfVxuXG4vLyBhbTogQ29tcHV0ZSB3X2ogKz0gKHgqdGhpc19pKSwgcHJvcGFnYXRlIGNhcnJpZXMsXG4vLyBjIGlzIGluaXRpYWwgY2FycnksIHJldHVybnMgZmluYWwgY2FycnkuXG4vLyBjIDwgMypkdmFsdWUsIHggPCAyKmR2YWx1ZSwgdGhpc19pIDwgZHZhbHVlXG4vLyBXZSBuZWVkIHRvIHNlbGVjdCB0aGUgZmFzdGVzdCBvbmUgdGhhdCB3b3JrcyBpbiB0aGlzIGVudmlyb25tZW50LlxuXG4vLyBhbTE6IHVzZSBhIHNpbmdsZSBtdWx0IGFuZCBkaXZpZGUgdG8gZ2V0IHRoZSBoaWdoIGJpdHMsXG4vLyBtYXggZGlnaXQgYml0cyBzaG91bGQgYmUgMjYgYmVjYXVzZVxuLy8gbWF4IGludGVybmFsIHZhbHVlID0gMipkdmFsdWVeMi0yKmR2YWx1ZSAoPCAyXjUzKVxuZnVuY3Rpb24gYW0xKGkseCx3LGosYyxuKSB7XG4gIHdoaWxlKC0tbiA+PSAwKSB7XG4gICAgdmFyIHYgPSB4KnRoaXMuZGF0YVtpKytdK3cuZGF0YVtqXStjO1xuICAgIGMgPSBNYXRoLmZsb29yKHYvMHg0MDAwMDAwKTtcbiAgICB3LmRhdGFbaisrXSA9IHYmMHgzZmZmZmZmO1xuICB9XG4gIHJldHVybiBjO1xufVxuLy8gYW0yIGF2b2lkcyBhIGJpZyBtdWx0LWFuZC1leHRyYWN0IGNvbXBsZXRlbHkuXG4vLyBNYXggZGlnaXQgYml0cyBzaG91bGQgYmUgPD0gMzAgYmVjYXVzZSB3ZSBkbyBiaXR3aXNlIG9wc1xuLy8gb24gdmFsdWVzIHVwIHRvIDIqaGR2YWx1ZV4yLWhkdmFsdWUtMSAoPCAyXjMxKVxuZnVuY3Rpb24gYW0yKGkseCx3LGosYyxuKSB7XG4gIHZhciB4bCA9IHgmMHg3ZmZmLCB4aCA9IHg+PjE1O1xuICB3aGlsZSgtLW4gPj0gMCkge1xuICAgIHZhciBsID0gdGhpcy5kYXRhW2ldJjB4N2ZmZjtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtpKytdPj4xNTtcbiAgICB2YXIgbSA9IHhoKmwraCp4bDtcbiAgICBsID0geGwqbCsoKG0mMHg3ZmZmKTw8MTUpK3cuZGF0YVtqXSsoYyYweDNmZmZmZmZmKTtcbiAgICBjID0gKGw+Pj4zMCkrKG0+Pj4xNSkreGgqaCsoYz4+PjMwKTtcbiAgICB3LmRhdGFbaisrXSA9IGwmMHgzZmZmZmZmZjtcbiAgfVxuICByZXR1cm4gYztcbn1cbi8vIEFsdGVybmF0ZWx5LCBzZXQgbWF4IGRpZ2l0IGJpdHMgdG8gMjggc2luY2Ugc29tZVxuLy8gYnJvd3NlcnMgc2xvdyBkb3duIHdoZW4gZGVhbGluZyB3aXRoIDMyLWJpdCBudW1iZXJzLlxuZnVuY3Rpb24gYW0zKGkseCx3LGosYyxuKSB7XG4gIHZhciB4bCA9IHgmMHgzZmZmLCB4aCA9IHg+PjE0O1xuICB3aGlsZSgtLW4gPj0gMCkge1xuICAgIHZhciBsID0gdGhpcy5kYXRhW2ldJjB4M2ZmZjtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtpKytdPj4xNDtcbiAgICB2YXIgbSA9IHhoKmwraCp4bDtcbiAgICBsID0geGwqbCsoKG0mMHgzZmZmKTw8MTQpK3cuZGF0YVtqXStjO1xuICAgIGMgPSAobD4+MjgpKyhtPj4xNCkreGgqaDtcbiAgICB3LmRhdGFbaisrXSA9IGwmMHhmZmZmZmZmO1xuICB9XG4gIHJldHVybiBjO1xufVxuXG4vLyBub2RlLmpzIChubyBicm93c2VyKVxuaWYodHlwZW9mKG5hdmlnYXRvcikgPT09ICd1bmRlZmluZWQnKVxue1xuICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTM7XG4gICBkYml0cyA9IDI4O1xufSBlbHNlIGlmKGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lID09IFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXCIpKSB7XG4gIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0yO1xuICBkYml0cyA9IDMwO1xufSBlbHNlIGlmKGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lICE9IFwiTmV0c2NhcGVcIikpIHtcbiAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTE7XG4gIGRiaXRzID0gMjY7XG59IGVsc2UgeyAvLyBNb3ppbGxhL05ldHNjYXBlIHNlZW1zIHRvIHByZWZlciBhbTNcbiAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTM7XG4gIGRiaXRzID0gMjg7XG59XG5cbkJpZ0ludGVnZXIucHJvdG90eXBlLkRCID0gZGJpdHM7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5ETSA9ICgoMTw8ZGJpdHMpLTEpO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRFYgPSAoMTw8ZGJpdHMpO1xuXG52YXIgQklfRlAgPSA1MjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLkZWID0gTWF0aC5wb3coMixCSV9GUCk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5GMSA9IEJJX0ZQLWRiaXRzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRjIgPSAyKmRiaXRzLUJJX0ZQO1xuXG4vLyBEaWdpdCBjb252ZXJzaW9uc1xudmFyIEJJX1JNID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcbnZhciBCSV9SQyA9IG5ldyBBcnJheSgpO1xudmFyIHJyLHZ2O1xucnIgPSBcIjBcIi5jaGFyQ29kZUF0KDApO1xuZm9yKHZ2ID0gMDsgdnYgPD0gOTsgKyt2dikgQklfUkNbcnIrK10gPSB2djtcbnJyID0gXCJhXCIuY2hhckNvZGVBdCgwKTtcbmZvcih2diA9IDEwOyB2diA8IDM2OyArK3Z2KSBCSV9SQ1tycisrXSA9IHZ2O1xucnIgPSBcIkFcIi5jaGFyQ29kZUF0KDApO1xuZm9yKHZ2ID0gMTA7IHZ2IDwgMzY7ICsrdnYpIEJJX1JDW3JyKytdID0gdnY7XG5cbmZ1bmN0aW9uIGludDJjaGFyKG4pIHsgcmV0dXJuIEJJX1JNLmNoYXJBdChuKTsgfVxuZnVuY3Rpb24gaW50QXQocyxpKSB7XG4gIHZhciBjID0gQklfUkNbcy5jaGFyQ29kZUF0KGkpXTtcbiAgcmV0dXJuIChjPT1udWxsKT8tMTpjO1xufVxuXG4vLyAocHJvdGVjdGVkKSBjb3B5IHRoaXMgdG8gclxuZnVuY3Rpb24gYm5wQ29weVRvKHIpIHtcbiAgZm9yKHZhciBpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSByLmRhdGFbaV0gPSB0aGlzLmRhdGFbaV07XG4gIHIudCA9IHRoaXMudDtcbiAgci5zID0gdGhpcy5zO1xufVxuXG4vLyAocHJvdGVjdGVkKSBzZXQgZnJvbSBpbnRlZ2VyIHZhbHVlIHgsIC1EViA8PSB4IDwgRFZcbmZ1bmN0aW9uIGJucEZyb21JbnQoeCkge1xuICB0aGlzLnQgPSAxO1xuICB0aGlzLnMgPSAoeDwwKT8tMTowO1xuICBpZih4ID4gMCkgdGhpcy5kYXRhWzBdID0geDtcbiAgZWxzZSBpZih4IDwgLTEpIHRoaXMuZGF0YVswXSA9IHgrdGhpcy5EVjtcbiAgZWxzZSB0aGlzLnQgPSAwO1xufVxuXG4vLyByZXR1cm4gYmlnaW50IGluaXRpYWxpemVkIHRvIHZhbHVlXG5mdW5jdGlvbiBuYnYoaSkgeyB2YXIgciA9IG5iaSgpOyByLmZyb21JbnQoaSk7IHJldHVybiByOyB9XG5cbi8vIChwcm90ZWN0ZWQpIHNldCBmcm9tIHN0cmluZyBhbmQgcmFkaXhcbmZ1bmN0aW9uIGJucEZyb21TdHJpbmcocyxiKSB7XG4gIHZhciBrO1xuICBpZihiID09IDE2KSBrID0gNDtcbiAgZWxzZSBpZihiID09IDgpIGsgPSAzO1xuICBlbHNlIGlmKGIgPT0gMjU2KSBrID0gODsgLy8gYnl0ZSBhcnJheVxuICBlbHNlIGlmKGIgPT0gMikgayA9IDE7XG4gIGVsc2UgaWYoYiA9PSAzMikgayA9IDU7XG4gIGVsc2UgaWYoYiA9PSA0KSBrID0gMjtcbiAgZWxzZSB7IHRoaXMuZnJvbVJhZGl4KHMsYik7IHJldHVybjsgfVxuICB0aGlzLnQgPSAwO1xuICB0aGlzLnMgPSAwO1xuICB2YXIgaSA9IHMubGVuZ3RoLCBtaSA9IGZhbHNlLCBzaCA9IDA7XG4gIHdoaWxlKC0taSA+PSAwKSB7XG4gICAgdmFyIHggPSAoaz09OCk/c1tpXSYweGZmOmludEF0KHMsaSk7XG4gICAgaWYoeCA8IDApIHtcbiAgICAgIGlmKHMuY2hhckF0KGkpID09IFwiLVwiKSBtaSA9IHRydWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbWkgPSBmYWxzZTtcbiAgICBpZihzaCA9PSAwKVxuICAgICAgdGhpcy5kYXRhW3RoaXMudCsrXSA9IHg7XG4gICAgZWxzZSBpZihzaCtrID4gdGhpcy5EQikge1xuICAgICAgdGhpcy5kYXRhW3RoaXMudC0xXSB8PSAoeCYoKDE8PCh0aGlzLkRCLXNoKSktMSkpPDxzaDtcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAoeD4+KHRoaXMuREItc2gpKTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnQtMV0gfD0geDw8c2g7XG4gICAgc2ggKz0gaztcbiAgICBpZihzaCA+PSB0aGlzLkRCKSBzaCAtPSB0aGlzLkRCO1xuICB9XG4gIGlmKGsgPT0gOCAmJiAoc1swXSYweDgwKSAhPSAwKSB7XG4gICAgdGhpcy5zID0gLTE7XG4gICAgaWYoc2ggPiAwKSB0aGlzLmRhdGFbdGhpcy50LTFdIHw9ICgoMTw8KHRoaXMuREItc2gpKS0xKTw8c2g7XG4gIH1cbiAgdGhpcy5jbGFtcCgpO1xuICBpZihtaSkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsdGhpcyk7XG59XG5cbi8vIChwcm90ZWN0ZWQpIGNsYW1wIG9mZiBleGNlc3MgaGlnaCB3b3Jkc1xuZnVuY3Rpb24gYm5wQ2xhbXAoKSB7XG4gIHZhciBjID0gdGhpcy5zJnRoaXMuRE07XG4gIHdoaWxlKHRoaXMudCA+IDAgJiYgdGhpcy5kYXRhW3RoaXMudC0xXSA9PSBjKSAtLXRoaXMudDtcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBpbiBnaXZlbiByYWRpeFxuZnVuY3Rpb24gYm5Ub1N0cmluZyhiKSB7XG4gIGlmKHRoaXMucyA8IDApIHJldHVybiBcIi1cIit0aGlzLm5lZ2F0ZSgpLnRvU3RyaW5nKGIpO1xuICB2YXIgaztcbiAgaWYoYiA9PSAxNikgayA9IDQ7XG4gIGVsc2UgaWYoYiA9PSA4KSBrID0gMztcbiAgZWxzZSBpZihiID09IDIpIGsgPSAxO1xuICBlbHNlIGlmKGIgPT0gMzIpIGsgPSA1O1xuICBlbHNlIGlmKGIgPT0gNCkgayA9IDI7XG4gIGVsc2UgcmV0dXJuIHRoaXMudG9SYWRpeChiKTtcbiAgdmFyIGttID0gKDE8PGspLTEsIGQsIG0gPSBmYWxzZSwgciA9IFwiXCIsIGkgPSB0aGlzLnQ7XG4gIHZhciBwID0gdGhpcy5EQi0oaSp0aGlzLkRCKSVrO1xuICBpZihpLS0gPiAwKSB7XG4gICAgaWYocCA8IHRoaXMuREIgJiYgKGQgPSB0aGlzLmRhdGFbaV0+PnApID4gMCkgeyBtID0gdHJ1ZTsgciA9IGludDJjaGFyKGQpOyB9XG4gICAgd2hpbGUoaSA+PSAwKSB7XG4gICAgICBpZihwIDwgaykge1xuICAgICAgICBkID0gKHRoaXMuZGF0YVtpXSYoKDE8PHApLTEpKTw8KGstcCk7XG4gICAgICAgIGQgfD0gdGhpcy5kYXRhWy0taV0+PihwKz10aGlzLkRCLWspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZCA9ICh0aGlzLmRhdGFbaV0+PihwLT1rKSkma207XG4gICAgICAgIGlmKHAgPD0gMCkgeyBwICs9IHRoaXMuREI7IC0taTsgfVxuICAgICAgfVxuICAgICAgaWYoZCA+IDApIG0gPSB0cnVlO1xuICAgICAgaWYobSkgciArPSBpbnQyY2hhcihkKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG0/cjpcIjBcIjtcbn1cblxuLy8gKHB1YmxpYykgLXRoaXNcbmZ1bmN0aW9uIGJuTmVnYXRlKCkgeyB2YXIgciA9IG5iaSgpOyBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcyxyKTsgcmV0dXJuIHI7IH1cblxuLy8gKHB1YmxpYykgfHRoaXN8XG5mdW5jdGlvbiBibkFicygpIHsgcmV0dXJuICh0aGlzLnM8MCk/dGhpcy5uZWdhdGUoKTp0aGlzOyB9XG5cbi8vIChwdWJsaWMpIHJldHVybiArIGlmIHRoaXMgPiBhLCAtIGlmIHRoaXMgPCBhLCAwIGlmIGVxdWFsXG5mdW5jdGlvbiBibkNvbXBhcmVUbyhhKSB7XG4gIHZhciByID0gdGhpcy5zLWEucztcbiAgaWYociAhPSAwKSByZXR1cm4gcjtcbiAgdmFyIGkgPSB0aGlzLnQ7XG4gIHIgPSBpLWEudDtcbiAgaWYociAhPSAwKSByZXR1cm4gKHRoaXMuczwwKT8tcjpyO1xuICB3aGlsZSgtLWkgPj0gMCkgaWYoKHI9dGhpcy5kYXRhW2ldLWEuZGF0YVtpXSkgIT0gMCkgcmV0dXJuIHI7XG4gIHJldHVybiAwO1xufVxuXG4vLyByZXR1cm5zIGJpdCBsZW5ndGggb2YgdGhlIGludGVnZXIgeFxuZnVuY3Rpb24gbmJpdHMoeCkge1xuICB2YXIgciA9IDEsIHQ7XG4gIGlmKCh0PXg+Pj4xNikgIT0gMCkgeyB4ID0gdDsgciArPSAxNjsgfVxuICBpZigodD14Pj44KSAhPSAwKSB7IHggPSB0OyByICs9IDg7IH1cbiAgaWYoKHQ9eD4+NCkgIT0gMCkgeyB4ID0gdDsgciArPSA0OyB9XG4gIGlmKCh0PXg+PjIpICE9IDApIHsgeCA9IHQ7IHIgKz0gMjsgfVxuICBpZigodD14Pj4xKSAhPSAwKSB7IHggPSB0OyByICs9IDE7IH1cbiAgcmV0dXJuIHI7XG59XG5cbi8vIChwdWJsaWMpIHJldHVybiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gXCJ0aGlzXCJcbmZ1bmN0aW9uIGJuQml0TGVuZ3RoKCkge1xuICBpZih0aGlzLnQgPD0gMCkgcmV0dXJuIDA7XG4gIHJldHVybiB0aGlzLkRCKih0aGlzLnQtMSkrbmJpdHModGhpcy5kYXRhW3RoaXMudC0xXV4odGhpcy5zJnRoaXMuRE0pKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgbipEQlxuZnVuY3Rpb24gYm5wRExTaGlmdFRvKG4scikge1xuICB2YXIgaTtcbiAgZm9yKGkgPSB0aGlzLnQtMTsgaSA+PSAwOyAtLWkpIHIuZGF0YVtpK25dID0gdGhpcy5kYXRhW2ldO1xuICBmb3IoaSA9IG4tMTsgaSA+PSAwOyAtLWkpIHIuZGF0YVtpXSA9IDA7XG4gIHIudCA9IHRoaXMudCtuO1xuICByLnMgPSB0aGlzLnM7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG4qREJcbmZ1bmN0aW9uIGJucERSU2hpZnRUbyhuLHIpIHtcbiAgZm9yKHZhciBpID0gbjsgaSA8IHRoaXMudDsgKytpKSByLmRhdGFbaS1uXSA9IHRoaXMuZGF0YVtpXTtcbiAgci50ID0gTWF0aC5tYXgodGhpcy50LW4sMCk7XG4gIHIucyA9IHRoaXMucztcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgblxuZnVuY3Rpb24gYm5wTFNoaWZ0VG8obixyKSB7XG4gIHZhciBicyA9IG4ldGhpcy5EQjtcbiAgdmFyIGNicyA9IHRoaXMuREItYnM7XG4gIHZhciBibSA9ICgxPDxjYnMpLTE7XG4gIHZhciBkcyA9IE1hdGguZmxvb3Iobi90aGlzLkRCKSwgYyA9ICh0aGlzLnM8PGJzKSZ0aGlzLkRNLCBpO1xuICBmb3IoaSA9IHRoaXMudC0xOyBpID49IDA7IC0taSkge1xuICAgIHIuZGF0YVtpK2RzKzFdID0gKHRoaXMuZGF0YVtpXT4+Y2JzKXxjO1xuICAgIGMgPSAodGhpcy5kYXRhW2ldJmJtKTw8YnM7XG4gIH1cbiAgZm9yKGkgPSBkcy0xOyBpID49IDA7IC0taSkgci5kYXRhW2ldID0gMDtcbiAgci5kYXRhW2RzXSA9IGM7XG4gIHIudCA9IHRoaXMudCtkcysxO1xuICByLnMgPSB0aGlzLnM7XG4gIHIuY2xhbXAoKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPj4gblxuZnVuY3Rpb24gYm5wUlNoaWZ0VG8obixyKSB7XG4gIHIucyA9IHRoaXMucztcbiAgdmFyIGRzID0gTWF0aC5mbG9vcihuL3RoaXMuREIpO1xuICBpZihkcyA+PSB0aGlzLnQpIHsgci50ID0gMDsgcmV0dXJuOyB9XG4gIHZhciBicyA9IG4ldGhpcy5EQjtcbiAgdmFyIGNicyA9IHRoaXMuREItYnM7XG4gIHZhciBibSA9ICgxPDxicyktMTtcbiAgci5kYXRhWzBdID0gdGhpcy5kYXRhW2RzXT4+YnM7XG4gIGZvcih2YXIgaSA9IGRzKzE7IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgIHIuZGF0YVtpLWRzLTFdIHw9ICh0aGlzLmRhdGFbaV0mYm0pPDxjYnM7XG4gICAgci5kYXRhW2ktZHNdID0gdGhpcy5kYXRhW2ldPj5icztcbiAgfVxuICBpZihicyA+IDApIHIuZGF0YVt0aGlzLnQtZHMtMV0gfD0gKHRoaXMucyZibSk8PGNicztcbiAgci50ID0gdGhpcy50LWRzO1xuICByLmNsYW1wKCk7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIC0gYVxuZnVuY3Rpb24gYm5wU3ViVG8oYSxyKSB7XG4gIHZhciBpID0gMCwgYyA9IDAsIG0gPSBNYXRoLm1pbihhLnQsdGhpcy50KTtcbiAgd2hpbGUoaSA8IG0pIHtcbiAgICBjICs9IHRoaXMuZGF0YVtpXS1hLmRhdGFbaV07XG4gICAgci5kYXRhW2krK10gPSBjJnRoaXMuRE07XG4gICAgYyA+Pj0gdGhpcy5EQjtcbiAgfVxuICBpZihhLnQgPCB0aGlzLnQpIHtcbiAgICBjIC09IGEucztcbiAgICB3aGlsZShpIDwgdGhpcy50KSB7XG4gICAgICBjICs9IHRoaXMuZGF0YVtpXTtcbiAgICAgIHIuZGF0YVtpKytdID0gYyZ0aGlzLkRNO1xuICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICB9XG4gICAgYyArPSB0aGlzLnM7XG4gIH0gZWxzZSB7XG4gICAgYyArPSB0aGlzLnM7XG4gICAgd2hpbGUoaSA8IGEudCkge1xuICAgICAgYyAtPSBhLmRhdGFbaV07XG4gICAgICByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgfVxuICAgIGMgLT0gYS5zO1xuICB9XG4gIHIucyA9IChjPDApPy0xOjA7XG4gIGlmKGMgPCAtMSkgci5kYXRhW2krK10gPSB0aGlzLkRWK2M7XG4gIGVsc2UgaWYoYyA+IDApIHIuZGF0YVtpKytdID0gYztcbiAgci50ID0gaTtcbiAgci5jbGFtcCgpO1xufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyAqIGEsIHIgIT0gdGhpcyxhIChIQUMgMTQuMTIpXG4vLyBcInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseVRvKGEscikge1xuICB2YXIgeCA9IHRoaXMuYWJzKCksIHkgPSBhLmFicygpO1xuICB2YXIgaSA9IHgudDtcbiAgci50ID0gaSt5LnQ7XG4gIHdoaWxlKC0taSA+PSAwKSByLmRhdGFbaV0gPSAwO1xuICBmb3IoaSA9IDA7IGkgPCB5LnQ7ICsraSkgci5kYXRhW2kreC50XSA9IHguYW0oMCx5LmRhdGFbaV0scixpLDAseC50KTtcbiAgci5zID0gMDtcbiAgci5jbGFtcCgpO1xuICBpZih0aGlzLnMgIT0gYS5zKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocixyKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXNeMiwgciAhPSB0aGlzIChIQUMgMTQuMTYpXG5mdW5jdGlvbiBibnBTcXVhcmVUbyhyKSB7XG4gIHZhciB4ID0gdGhpcy5hYnMoKTtcbiAgdmFyIGkgPSByLnQgPSAyKngudDtcbiAgd2hpbGUoLS1pID49IDApIHIuZGF0YVtpXSA9IDA7XG4gIGZvcihpID0gMDsgaSA8IHgudC0xOyArK2kpIHtcbiAgICB2YXIgYyA9IHguYW0oaSx4LmRhdGFbaV0sciwyKmksMCwxKTtcbiAgICBpZigoci5kYXRhW2kreC50XSs9eC5hbShpKzEsMip4LmRhdGFbaV0sciwyKmkrMSxjLHgudC1pLTEpKSA+PSB4LkRWKSB7XG4gICAgICByLmRhdGFbaSt4LnRdIC09IHguRFY7XG4gICAgICByLmRhdGFbaSt4LnQrMV0gPSAxO1xuICAgIH1cbiAgfVxuICBpZihyLnQgPiAwKSByLmRhdGFbci50LTFdICs9IHguYW0oaSx4LmRhdGFbaV0sciwyKmksMCwxKTtcbiAgci5zID0gMDtcbiAgci5jbGFtcCgpO1xufVxuXG4vLyAocHJvdGVjdGVkKSBkaXZpZGUgdGhpcyBieSBtLCBxdW90aWVudCBhbmQgcmVtYWluZGVyIHRvIHEsIHIgKEhBQyAxNC4yMClcbi8vIHIgIT0gcSwgdGhpcyAhPSBtLiAgcSBvciByIG1heSBiZSBudWxsLlxuZnVuY3Rpb24gYm5wRGl2UmVtVG8obSxxLHIpIHtcbiAgdmFyIHBtID0gbS5hYnMoKTtcbiAgaWYocG0udCA8PSAwKSByZXR1cm47XG4gIHZhciBwdCA9IHRoaXMuYWJzKCk7XG4gIGlmKHB0LnQgPCBwbS50KSB7XG4gICAgaWYocSAhPSBudWxsKSBxLmZyb21JbnQoMCk7XG4gICAgaWYociAhPSBudWxsKSB0aGlzLmNvcHlUbyhyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYociA9PSBudWxsKSByID0gbmJpKCk7XG4gIHZhciB5ID0gbmJpKCksIHRzID0gdGhpcy5zLCBtcyA9IG0ucztcbiAgdmFyIG5zaCA9IHRoaXMuREItbmJpdHMocG0uZGF0YVtwbS50LTFdKTtcdC8vIG5vcm1hbGl6ZSBtb2R1bHVzXG4gIGlmKG5zaCA+IDApIHsgcG0ubFNoaWZ0VG8obnNoLHkpOyBwdC5sU2hpZnRUbyhuc2gscik7IH0gZWxzZSB7IHBtLmNvcHlUbyh5KTsgcHQuY29weVRvKHIpOyB9XG4gIHZhciB5cyA9IHkudDtcbiAgdmFyIHkwID0geS5kYXRhW3lzLTFdO1xuICBpZih5MCA9PSAwKSByZXR1cm47XG4gIHZhciB5dCA9IHkwKigxPDx0aGlzLkYxKSsoKHlzPjEpP3kuZGF0YVt5cy0yXT4+dGhpcy5GMjowKTtcbiAgdmFyIGQxID0gdGhpcy5GVi95dCwgZDIgPSAoMTw8dGhpcy5GMSkveXQsIGUgPSAxPDx0aGlzLkYyO1xuICB2YXIgaSA9IHIudCwgaiA9IGkteXMsIHQgPSAocT09bnVsbCk/bmJpKCk6cTtcbiAgeS5kbFNoaWZ0VG8oaix0KTtcbiAgaWYoci5jb21wYXJlVG8odCkgPj0gMCkge1xuICAgIHIuZGF0YVtyLnQrK10gPSAxO1xuICAgIHIuc3ViVG8odCxyKTtcbiAgfVxuICBCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oeXMsdCk7XG4gIHQuc3ViVG8oeSx5KTtcdC8vIFwibmVnYXRpdmVcIiB5IHNvIHdlIGNhbiByZXBsYWNlIHN1YiB3aXRoIGFtIGxhdGVyXG4gIHdoaWxlKHkudCA8IHlzKSB5LmRhdGFbeS50KytdID0gMDtcbiAgd2hpbGUoLS1qID49IDApIHtcbiAgICAvLyBFc3RpbWF0ZSBxdW90aWVudCBkaWdpdFxuICAgIHZhciBxZCA9IChyLmRhdGFbLS1pXT09eTApP3RoaXMuRE06TWF0aC5mbG9vcihyLmRhdGFbaV0qZDErKHIuZGF0YVtpLTFdK2UpKmQyKTtcbiAgICBpZigoci5kYXRhW2ldKz15LmFtKDAscWQscixqLDAseXMpKSA8IHFkKSB7XHQvLyBUcnkgaXQgb3V0XG4gICAgICB5LmRsU2hpZnRUbyhqLHQpO1xuICAgICAgci5zdWJUbyh0LHIpO1xuICAgICAgd2hpbGUoci5kYXRhW2ldIDwgLS1xZCkgci5zdWJUbyh0LHIpO1xuICAgIH1cbiAgfVxuICBpZihxICE9IG51bGwpIHtcbiAgICByLmRyU2hpZnRUbyh5cyxxKTtcbiAgICBpZih0cyAhPSBtcykgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHEscSk7XG4gIH1cbiAgci50ID0geXM7XG4gIHIuY2xhbXAoKTtcbiAgaWYobnNoID4gMCkgci5yU2hpZnRUbyhuc2gscik7XHQvLyBEZW5vcm1hbGl6ZSByZW1haW5kZXJcbiAgaWYodHMgPCAwKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocixyKTtcbn1cblxuLy8gKHB1YmxpYykgdGhpcyBtb2QgYVxuZnVuY3Rpb24gYm5Nb2QoYSkge1xuICB2YXIgciA9IG5iaSgpO1xuICB0aGlzLmFicygpLmRpdlJlbVRvKGEsbnVsbCxyKTtcbiAgaWYodGhpcy5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkgYS5zdWJUbyhyLHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gTW9kdWxhciByZWR1Y3Rpb24gdXNpbmcgXCJjbGFzc2ljXCIgYWxnb3JpdGhtXG5mdW5jdGlvbiBDbGFzc2ljKG0pIHsgdGhpcy5tID0gbTsgfVxuZnVuY3Rpb24gY0NvbnZlcnQoeCkge1xuICBpZih4LnMgPCAwIHx8IHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkgcmV0dXJuIHgubW9kKHRoaXMubSk7XG4gIGVsc2UgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBjUmV2ZXJ0KHgpIHsgcmV0dXJuIHg7IH1cbmZ1bmN0aW9uIGNSZWR1Y2UoeCkgeyB4LmRpdlJlbVRvKHRoaXMubSxudWxsLHgpOyB9XG5mdW5jdGlvbiBjTXVsVG8oeCx5LHIpIHsgeC5tdWx0aXBseVRvKHkscik7IHRoaXMucmVkdWNlKHIpOyB9XG5mdW5jdGlvbiBjU3FyVG8oeCxyKSB7IHguc3F1YXJlVG8ocik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbkNsYXNzaWMucHJvdG90eXBlLmNvbnZlcnQgPSBjQ29udmVydDtcbkNsYXNzaWMucHJvdG90eXBlLnJldmVydCA9IGNSZXZlcnQ7XG5DbGFzc2ljLnByb3RvdHlwZS5yZWR1Y2UgPSBjUmVkdWNlO1xuQ2xhc3NpYy5wcm90b3R5cGUubXVsVG8gPSBjTXVsVG87XG5DbGFzc2ljLnByb3RvdHlwZS5zcXJUbyA9IGNTcXJUbztcblxuLy8gKHByb3RlY3RlZCkgcmV0dXJuIFwiLTEvdGhpcyAlIDJeREJcIjsgdXNlZnVsIGZvciBNb250LiByZWR1Y3Rpb25cbi8vIGp1c3RpZmljYXRpb246XG4vLyAgICAgICAgIHh5ID09IDEgKG1vZCBtKVxuLy8gICAgICAgICB4eSA9ICAxK2ttXG4vLyAgIHh5KDIteHkpID0gKDEra20pKDEta20pXG4vLyB4W3koMi14eSldID0gMS1rXjJtXjJcbi8vIHhbeSgyLXh5KV0gPT0gMSAobW9kIG1eMilcbi8vIGlmIHkgaXMgMS94IG1vZCBtLCB0aGVuIHkoMi14eSkgaXMgMS94IG1vZCBtXjJcbi8vIHNob3VsZCByZWR1Y2UgeCBhbmQgeSgyLXh5KSBieSBtXjIgYXQgZWFjaCBzdGVwIHRvIGtlZXAgc2l6ZSBib3VuZGVkLlxuLy8gSlMgbXVsdGlwbHkgXCJvdmVyZmxvd3NcIiBkaWZmZXJlbnRseSBmcm9tIEMvQysrLCBzbyBjYXJlIGlzIG5lZWRlZCBoZXJlLlxuZnVuY3Rpb24gYm5wSW52RGlnaXQoKSB7XG4gIGlmKHRoaXMudCA8IDEpIHJldHVybiAwO1xuICB2YXIgeCA9IHRoaXMuZGF0YVswXTtcbiAgaWYoKHgmMSkgPT0gMCkgcmV0dXJuIDA7XG4gIHZhciB5ID0geCYzO1x0XHQvLyB5ID09IDEveCBtb2QgMl4yXG4gIHkgPSAoeSooMi0oeCYweGYpKnkpKSYweGY7XHQvLyB5ID09IDEveCBtb2QgMl40XG4gIHkgPSAoeSooMi0oeCYweGZmKSp5KSkmMHhmZjtcdC8vIHkgPT0gMS94IG1vZCAyXjhcbiAgeSA9ICh5KigyLSgoKHgmMHhmZmZmKSp5KSYweGZmZmYpKSkmMHhmZmZmO1x0Ly8geSA9PSAxL3ggbW9kIDJeMTZcbiAgLy8gbGFzdCBzdGVwIC0gY2FsY3VsYXRlIGludmVyc2UgbW9kIERWIGRpcmVjdGx5O1xuICAvLyBhc3N1bWVzIDE2IDwgREIgPD0gMzIgYW5kIGFzc3VtZXMgYWJpbGl0eSB0byBoYW5kbGUgNDgtYml0IGludHNcbiAgeSA9ICh5KigyLXgqeSV0aGlzLkRWKSkldGhpcy5EVjtcdFx0Ly8geSA9PSAxL3ggbW9kIDJeZGJpdHNcbiAgLy8gd2UgcmVhbGx5IHdhbnQgdGhlIG5lZ2F0aXZlIGludmVyc2UsIGFuZCAtRFYgPCB5IDwgRFZcbiAgcmV0dXJuICh5PjApP3RoaXMuRFYteToteTtcbn1cblxuLy8gTW9udGdvbWVyeSByZWR1Y3Rpb25cbmZ1bmN0aW9uIE1vbnRnb21lcnkobSkge1xuICB0aGlzLm0gPSBtO1xuICB0aGlzLm1wID0gbS5pbnZEaWdpdCgpO1xuICB0aGlzLm1wbCA9IHRoaXMubXAmMHg3ZmZmO1xuICB0aGlzLm1waCA9IHRoaXMubXA+PjE1O1xuICB0aGlzLnVtID0gKDE8PChtLkRCLTE1KSktMTtcbiAgdGhpcy5tdDIgPSAyKm0udDtcbn1cblxuLy8geFIgbW9kIG1cbmZ1bmN0aW9uIG1vbnRDb252ZXJ0KHgpIHtcbiAgdmFyIHIgPSBuYmkoKTtcbiAgeC5hYnMoKS5kbFNoaWZ0VG8odGhpcy5tLnQscik7XG4gIHIuZGl2UmVtVG8odGhpcy5tLG51bGwscik7XG4gIGlmKHgucyA8IDAgJiYgci5jb21wYXJlVG8oQmlnSW50ZWdlci5aRVJPKSA+IDApIHRoaXMubS5zdWJUbyhyLHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8geC9SIG1vZCBtXG5mdW5jdGlvbiBtb250UmV2ZXJ0KHgpIHtcbiAgdmFyIHIgPSBuYmkoKTtcbiAgeC5jb3B5VG8ocik7XG4gIHRoaXMucmVkdWNlKHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8geCA9IHgvUiBtb2QgbSAoSEFDIDE0LjMyKVxuZnVuY3Rpb24gbW9udFJlZHVjZSh4KSB7XG4gIHdoaWxlKHgudCA8PSB0aGlzLm10MilcdC8vIHBhZCB4IHNvIGFtIGhhcyBlbm91Z2ggcm9vbSBsYXRlclxuICAgIHguZGF0YVt4LnQrK10gPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5tLnQ7ICsraSkge1xuICAgIC8vIGZhc3RlciB3YXkgb2YgY2FsY3VsYXRpbmcgdTAgPSB4LmRhdGFbaV0qbXAgbW9kIERWXG4gICAgdmFyIGogPSB4LmRhdGFbaV0mMHg3ZmZmO1xuICAgIHZhciB1MCA9IChqKnRoaXMubXBsKygoKGoqdGhpcy5tcGgrKHguZGF0YVtpXT4+MTUpKnRoaXMubXBsKSZ0aGlzLnVtKTw8MTUpKSZ4LkRNO1xuICAgIC8vIHVzZSBhbSB0byBjb21iaW5lIHRoZSBtdWx0aXBseS1zaGlmdC1hZGQgaW50byBvbmUgY2FsbFxuICAgIGogPSBpK3RoaXMubS50O1xuICAgIHguZGF0YVtqXSArPSB0aGlzLm0uYW0oMCx1MCx4LGksMCx0aGlzLm0udCk7XG4gICAgLy8gcHJvcGFnYXRlIGNhcnJ5XG4gICAgd2hpbGUoeC5kYXRhW2pdID49IHguRFYpIHsgeC5kYXRhW2pdIC09IHguRFY7IHguZGF0YVsrK2pdKys7IH1cbiAgfVxuICB4LmNsYW1wKCk7XG4gIHguZHJTaGlmdFRvKHRoaXMubS50LHgpO1xuICBpZih4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHguc3ViVG8odGhpcy5tLHgpO1xufVxuXG4vLyByID0gXCJ4XjIvUiBtb2QgbVwiOyB4ICE9IHJcbmZ1bmN0aW9uIG1vbnRTcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuLy8gciA9IFwieHkvUiBtb2QgbVwiOyB4LHkgIT0gclxuZnVuY3Rpb24gbW9udE11bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG5Nb250Z29tZXJ5LnByb3RvdHlwZS5jb252ZXJ0ID0gbW9udENvbnZlcnQ7XG5Nb250Z29tZXJ5LnByb3RvdHlwZS5yZXZlcnQgPSBtb250UmV2ZXJ0O1xuTW9udGdvbWVyeS5wcm90b3R5cGUucmVkdWNlID0gbW9udFJlZHVjZTtcbk1vbnRnb21lcnkucHJvdG90eXBlLm11bFRvID0gbW9udE11bFRvO1xuTW9udGdvbWVyeS5wcm90b3R5cGUuc3FyVG8gPSBtb250U3FyVG87XG5cbi8vIChwcm90ZWN0ZWQpIHRydWUgaWZmIHRoaXMgaXMgZXZlblxuZnVuY3Rpb24gYm5wSXNFdmVuKCkgeyByZXR1cm4gKCh0aGlzLnQ+MCk/KHRoaXMuZGF0YVswXSYxKTp0aGlzLnMpID09IDA7IH1cblxuLy8gKHByb3RlY3RlZCkgdGhpc15lLCBlIDwgMl4zMiwgZG9pbmcgc3FyIGFuZCBtdWwgd2l0aCBcInJcIiAoSEFDIDE0Ljc5KVxuZnVuY3Rpb24gYm5wRXhwKGUseikge1xuICBpZihlID4gMHhmZmZmZmZmZiB8fCBlIDwgMSkgcmV0dXJuIEJpZ0ludGVnZXIuT05FO1xuICB2YXIgciA9IG5iaSgpLCByMiA9IG5iaSgpLCBnID0gei5jb252ZXJ0KHRoaXMpLCBpID0gbmJpdHMoZSktMTtcbiAgZy5jb3B5VG8ocik7XG4gIHdoaWxlKC0taSA+PSAwKSB7XG4gICAgei5zcXJUbyhyLHIyKTtcbiAgICBpZigoZSYoMTw8aSkpID4gMCkgei5tdWxUbyhyMixnLHIpO1xuICAgIGVsc2UgeyB2YXIgdCA9IHI7IHIgPSByMjsgcjIgPSB0OyB9XG4gIH1cbiAgcmV0dXJuIHoucmV2ZXJ0KHIpO1xufVxuXG4vLyAocHVibGljKSB0aGlzXmUgJSBtLCAwIDw9IGUgPCAyXjMyXG5mdW5jdGlvbiBibk1vZFBvd0ludChlLG0pIHtcbiAgdmFyIHo7XG4gIGlmKGUgPCAyNTYgfHwgbS5pc0V2ZW4oKSkgeiA9IG5ldyBDbGFzc2ljKG0pOyBlbHNlIHogPSBuZXcgTW9udGdvbWVyeShtKTtcbiAgcmV0dXJuIHRoaXMuZXhwKGUseik7XG59XG5cbi8vIHByb3RlY3RlZFxuQmlnSW50ZWdlci5wcm90b3R5cGUuY29weVRvID0gYm5wQ29weVRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbUludCA9IGJucEZyb21JbnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tU3RyaW5nID0gYm5wRnJvbVN0cmluZztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNsYW1wID0gYm5wQ2xhbXA7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kbFNoaWZ0VG8gPSBibnBETFNoaWZ0VG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kclNoaWZ0VG8gPSBibnBEUlNoaWZ0VG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5sU2hpZnRUbyA9IGJucExTaGlmdFRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuclNoaWZ0VG8gPSBibnBSU2hpZnRUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLnN1YlRvID0gYm5wU3ViVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVRvID0gYm5wTXVsdGlwbHlUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZVRvID0gYm5wU3F1YXJlVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZSZW1UbyA9IGJucERpdlJlbVRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuaW52RGlnaXQgPSBibnBJbnZEaWdpdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmlzRXZlbiA9IGJucElzRXZlbjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmV4cCA9IGJucEV4cDtcblxuLy8gcHVibGljXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGJuVG9TdHJpbmc7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBibk5lZ2F0ZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFicyA9IGJuQWJzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gYm5Db21wYXJlVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGggPSBibkJpdExlbmd0aDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZCA9IGJuTW9kO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93SW50ID0gYm5Nb2RQb3dJbnQ7XG5cbi8vIFwiY29uc3RhbnRzXCJcbkJpZ0ludGVnZXIuWkVSTyA9IG5idigwKTtcbkJpZ0ludGVnZXIuT05FID0gbmJ2KDEpO1xuXG4vLyBqc2JuMiBsaWJcblxuLy9Db3B5cmlnaHQgKGMpIDIwMDUtMjAwOSAgVG9tIFd1XG4vL0FsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1NlZSBcIkxJQ0VOU0VcIiBmb3IgZGV0YWlscyAoU2VlIGpzYm4uanMgZm9yIExJQ0VOU0UpLlxuXG4vL0V4dGVuZGVkIEphdmFTY3JpcHQgQk4gZnVuY3Rpb25zLCByZXF1aXJlZCBmb3IgUlNBIHByaXZhdGUgb3BzLlxuXG4vL1ZlcnNpb24gMS4xOiBuZXcgQmlnSW50ZWdlcihcIjBcIiwgMTApIHJldHVybnMgXCJwcm9wZXJcIiB6ZXJvXG5cbi8vKHB1YmxpYylcbmZ1bmN0aW9uIGJuQ2xvbmUoKSB7IHZhciByID0gbmJpKCk7IHRoaXMuY29weVRvKHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBpbnRlZ2VyXG5mdW5jdGlvbiBibkludFZhbHVlKCkge1xuaWYodGhpcy5zIDwgMCkge1xuIGlmKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpcy5kYXRhWzBdLXRoaXMuRFY7XG4gZWxzZSBpZih0aGlzLnQgPT0gMCkgcmV0dXJuIC0xO1xufSBlbHNlIGlmKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpcy5kYXRhWzBdO1xuZWxzZSBpZih0aGlzLnQgPT0gMCkgcmV0dXJuIDA7XG4vLyBhc3N1bWVzIDE2IDwgREIgPCAzMlxucmV0dXJuICgodGhpcy5kYXRhWzFdJigoMTw8KDMyLXRoaXMuREIpKS0xKSk8PHRoaXMuREIpfHRoaXMuZGF0YVswXTtcbn1cblxuLy8ocHVibGljKSByZXR1cm4gdmFsdWUgYXMgYnl0ZVxuZnVuY3Rpb24gYm5CeXRlVmFsdWUoKSB7IHJldHVybiAodGhpcy50PT0wKT90aGlzLnM6KHRoaXMuZGF0YVswXTw8MjQpPj4yNDsgfVxuXG4vLyhwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBzaG9ydCAoYXNzdW1lcyBEQj49MTYpXG5mdW5jdGlvbiBiblNob3J0VmFsdWUoKSB7IHJldHVybiAodGhpcy50PT0wKT90aGlzLnM6KHRoaXMuZGF0YVswXTw8MTYpPj4xNjsgfVxuXG4vLyhwcm90ZWN0ZWQpIHJldHVybiB4IHMudC4gcl54IDwgRFZcbmZ1bmN0aW9uIGJucENodW5rU2l6ZShyKSB7IHJldHVybiBNYXRoLmZsb29yKE1hdGguTE4yKnRoaXMuREIvTWF0aC5sb2cocikpOyB9XG5cbi8vKHB1YmxpYykgMCBpZiB0aGlzID09IDAsIDEgaWYgdGhpcyA+IDBcbmZ1bmN0aW9uIGJuU2lnTnVtKCkge1xuaWYodGhpcy5zIDwgMCkgcmV0dXJuIC0xO1xuZWxzZSBpZih0aGlzLnQgPD0gMCB8fCAodGhpcy50ID09IDEgJiYgdGhpcy5kYXRhWzBdIDw9IDApKSByZXR1cm4gMDtcbmVsc2UgcmV0dXJuIDE7XG59XG5cbi8vKHByb3RlY3RlZCkgY29udmVydCB0byByYWRpeCBzdHJpbmdcbmZ1bmN0aW9uIGJucFRvUmFkaXgoYikge1xuaWYoYiA9PSBudWxsKSBiID0gMTA7XG5pZih0aGlzLnNpZ251bSgpID09IDAgfHwgYiA8IDIgfHwgYiA+IDM2KSByZXR1cm4gXCIwXCI7XG52YXIgY3MgPSB0aGlzLmNodW5rU2l6ZShiKTtcbnZhciBhID0gTWF0aC5wb3coYixjcyk7XG52YXIgZCA9IG5idihhKSwgeSA9IG5iaSgpLCB6ID0gbmJpKCksIHIgPSBcIlwiO1xudGhpcy5kaXZSZW1UbyhkLHkseik7XG53aGlsZSh5LnNpZ251bSgpID4gMCkge1xuIHIgPSAoYSt6LmludFZhbHVlKCkpLnRvU3RyaW5nKGIpLnN1YnN0cigxKSArIHI7XG4geS5kaXZSZW1UbyhkLHkseik7XG59XG5yZXR1cm4gei5pbnRWYWx1ZSgpLnRvU3RyaW5nKGIpICsgcjtcbn1cblxuLy8ocHJvdGVjdGVkKSBjb252ZXJ0IGZyb20gcmFkaXggc3RyaW5nXG5mdW5jdGlvbiBibnBGcm9tUmFkaXgocyxiKSB7XG50aGlzLmZyb21JbnQoMCk7XG5pZihiID09IG51bGwpIGIgPSAxMDtcbnZhciBjcyA9IHRoaXMuY2h1bmtTaXplKGIpO1xudmFyIGQgPSBNYXRoLnBvdyhiLGNzKSwgbWkgPSBmYWxzZSwgaiA9IDAsIHcgPSAwO1xuZm9yKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiB2YXIgeCA9IGludEF0KHMsaSk7XG4gaWYoeCA8IDApIHtcbiAgIGlmKHMuY2hhckF0KGkpID09IFwiLVwiICYmIHRoaXMuc2lnbnVtKCkgPT0gMCkgbWkgPSB0cnVlO1xuICAgY29udGludWU7XG4gfVxuIHcgPSBiKncreDtcbiBpZigrK2ogPj0gY3MpIHtcbiAgIHRoaXMuZE11bHRpcGx5KGQpO1xuICAgdGhpcy5kQWRkT2Zmc2V0KHcsMCk7XG4gICBqID0gMDtcbiAgIHcgPSAwO1xuIH1cbn1cbmlmKGogPiAwKSB7XG4gdGhpcy5kTXVsdGlwbHkoTWF0aC5wb3coYixqKSk7XG4gdGhpcy5kQWRkT2Zmc2V0KHcsMCk7XG59XG5pZihtaSkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsdGhpcyk7XG59XG5cbi8vKHByb3RlY3RlZCkgYWx0ZXJuYXRlIGNvbnN0cnVjdG9yXG5mdW5jdGlvbiBibnBGcm9tTnVtYmVyKGEsYixjKSB7XG5pZihcIm51bWJlclwiID09IHR5cGVvZiBiKSB7XG4gLy8gbmV3IEJpZ0ludGVnZXIoaW50LGludCxSTkcpXG4gaWYoYSA8IDIpIHRoaXMuZnJvbUludCgxKTtcbiBlbHNlIHtcbiAgIHRoaXMuZnJvbU51bWJlcihhLGMpO1xuICAgaWYoIXRoaXMudGVzdEJpdChhLTEpKSAgLy8gZm9yY2UgTVNCIHNldFxuICAgICB0aGlzLmJpdHdpc2VUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYS0xKSxvcF9vcix0aGlzKTtcbiAgIGlmKHRoaXMuaXNFdmVuKCkpIHRoaXMuZEFkZE9mZnNldCgxLDApOyAvLyBmb3JjZSBvZGRcbiAgIHdoaWxlKCF0aGlzLmlzUHJvYmFibGVQcmltZShiKSkge1xuICAgICB0aGlzLmRBZGRPZmZzZXQoMiwwKTtcbiAgICAgaWYodGhpcy5iaXRMZW5ndGgoKSA+IGEpIHRoaXMuc3ViVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEtMSksdGhpcyk7XG4gICB9XG4gfVxufSBlbHNlIHtcbiAvLyBuZXcgQmlnSW50ZWdlcihpbnQsUk5HKVxuIHZhciB4ID0gbmV3IEFycmF5KCksIHQgPSBhJjc7XG4geC5sZW5ndGggPSAoYT4+MykrMTtcbiBiLm5leHRCeXRlcyh4KTtcbiBpZih0ID4gMCkgeFswXSAmPSAoKDE8PHQpLTEpOyBlbHNlIHhbMF0gPSAwO1xuIHRoaXMuZnJvbVN0cmluZyh4LDI1Nik7XG59XG59XG5cbi8vKHB1YmxpYykgY29udmVydCB0byBiaWdlbmRpYW4gYnl0ZSBhcnJheVxuZnVuY3Rpb24gYm5Ub0J5dGVBcnJheSgpIHtcbnZhciBpID0gdGhpcy50LCByID0gbmV3IEFycmF5KCk7XG5yWzBdID0gdGhpcy5zO1xudmFyIHAgPSB0aGlzLkRCLShpKnRoaXMuREIpJTgsIGQsIGsgPSAwO1xuaWYoaS0tID4gMCkge1xuIGlmKHAgPCB0aGlzLkRCICYmIChkID0gdGhpcy5kYXRhW2ldPj5wKSAhPSAodGhpcy5zJnRoaXMuRE0pPj5wKVxuICAgcltrKytdID0gZHwodGhpcy5zPDwodGhpcy5EQi1wKSk7XG4gd2hpbGUoaSA+PSAwKSB7XG4gICBpZihwIDwgOCkge1xuICAgICBkID0gKHRoaXMuZGF0YVtpXSYoKDE8PHApLTEpKTw8KDgtcCk7XG4gICAgIGQgfD0gdGhpcy5kYXRhWy0taV0+PihwKz10aGlzLkRCLTgpO1xuICAgfSBlbHNlIHtcbiAgICAgZCA9ICh0aGlzLmRhdGFbaV0+PihwLT04KSkmMHhmZjtcbiAgICAgaWYocCA8PSAwKSB7IHAgKz0gdGhpcy5EQjsgLS1pOyB9XG4gICB9XG4gICBpZigoZCYweDgwKSAhPSAwKSBkIHw9IC0yNTY7XG4gICBpZihrID09IDAgJiYgKHRoaXMucyYweDgwKSAhPSAoZCYweDgwKSkgKytrO1xuICAgaWYoayA+IDAgfHwgZCAhPSB0aGlzLnMpIHJbaysrXSA9IGQ7XG4gfVxufVxucmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJuRXF1YWxzKGEpIHsgcmV0dXJuKHRoaXMuY29tcGFyZVRvKGEpPT0wKTsgfVxuZnVuY3Rpb24gYm5NaW4oYSkgeyByZXR1cm4odGhpcy5jb21wYXJlVG8oYSk8MCk/dGhpczphOyB9XG5mdW5jdGlvbiBibk1heChhKSB7IHJldHVybih0aGlzLmNvbXBhcmVUbyhhKT4wKT90aGlzOmE7IH1cblxuLy8ocHJvdGVjdGVkKSByID0gdGhpcyBvcCBhIChiaXR3aXNlKVxuZnVuY3Rpb24gYm5wQml0d2lzZVRvKGEsb3Ascikge1xudmFyIGksIGYsIG0gPSBNYXRoLm1pbihhLnQsdGhpcy50KTtcbmZvcihpID0gMDsgaSA8IG07ICsraSkgci5kYXRhW2ldID0gb3AodGhpcy5kYXRhW2ldLGEuZGF0YVtpXSk7XG5pZihhLnQgPCB0aGlzLnQpIHtcbiBmID0gYS5zJnRoaXMuRE07XG4gZm9yKGkgPSBtOyBpIDwgdGhpcy50OyArK2kpIHIuZGF0YVtpXSA9IG9wKHRoaXMuZGF0YVtpXSxmKTtcbiByLnQgPSB0aGlzLnQ7XG59IGVsc2Uge1xuIGYgPSB0aGlzLnMmdGhpcy5ETTtcbiBmb3IoaSA9IG07IGkgPCBhLnQ7ICsraSkgci5kYXRhW2ldID0gb3AoZixhLmRhdGFbaV0pO1xuIHIudCA9IGEudDtcbn1cbnIucyA9IG9wKHRoaXMucyxhLnMpO1xuci5jbGFtcCgpO1xufVxuXG4vLyhwdWJsaWMpIHRoaXMgJiBhXG5mdW5jdGlvbiBvcF9hbmQoeCx5KSB7IHJldHVybiB4Jnk7IH1cbmZ1bmN0aW9uIGJuQW5kKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF9hbmQscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyB8IGFcbmZ1bmN0aW9uIG9wX29yKHgseSkgeyByZXR1cm4geHx5OyB9XG5mdW5jdGlvbiBibk9yKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF9vcixyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSB0aGlzIF4gYVxuZnVuY3Rpb24gb3BfeG9yKHgseSkgeyByZXR1cm4geF55OyB9XG5mdW5jdGlvbiBiblhvcihhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuYml0d2lzZVRvKGEsb3BfeG9yLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgJiB+YVxuZnVuY3Rpb24gb3BfYW5kbm90KHgseSkgeyByZXR1cm4geCZ+eTsgfVxuZnVuY3Rpb24gYm5BbmROb3QoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmJpdHdpc2VUbyhhLG9wX2FuZG5vdCxyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSB+dGhpc1xuZnVuY3Rpb24gYm5Ob3QoKSB7XG52YXIgciA9IG5iaSgpO1xuZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSByLmRhdGFbaV0gPSB0aGlzLkRNJn50aGlzLmRhdGFbaV07XG5yLnQgPSB0aGlzLnQ7XG5yLnMgPSB+dGhpcy5zO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdGhpcyA8PCBuXG5mdW5jdGlvbiBiblNoaWZ0TGVmdChuKSB7XG52YXIgciA9IG5iaSgpO1xuaWYobiA8IDApIHRoaXMuclNoaWZ0VG8oLW4scik7IGVsc2UgdGhpcy5sU2hpZnRUbyhuLHIpO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdGhpcyA+PiBuXG5mdW5jdGlvbiBiblNoaWZ0UmlnaHQobikge1xudmFyIHIgPSBuYmkoKTtcbmlmKG4gPCAwKSB0aGlzLmxTaGlmdFRvKC1uLHIpOyBlbHNlIHRoaXMuclNoaWZ0VG8obixyKTtcbnJldHVybiByO1xufVxuXG4vL3JldHVybiBpbmRleCBvZiBsb3dlc3QgMS1iaXQgaW4geCwgeCA8IDJeMzFcbmZ1bmN0aW9uIGxiaXQoeCkge1xuaWYoeCA9PSAwKSByZXR1cm4gLTE7XG52YXIgciA9IDA7XG5pZigoeCYweGZmZmYpID09IDApIHsgeCA+Pj0gMTY7IHIgKz0gMTY7IH1cbmlmKCh4JjB4ZmYpID09IDApIHsgeCA+Pj0gODsgciArPSA4OyB9XG5pZigoeCYweGYpID09IDApIHsgeCA+Pj0gNDsgciArPSA0OyB9XG5pZigoeCYzKSA9PSAwKSB7IHggPj49IDI7IHIgKz0gMjsgfVxuaWYoKHgmMSkgPT0gMCkgKytyO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgcmV0dXJucyBpbmRleCBvZiBsb3dlc3QgMS1iaXQgKG9yIC0xIGlmIG5vbmUpXG5mdW5jdGlvbiBibkdldExvd2VzdFNldEJpdCgpIHtcbmZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSlcbiBpZih0aGlzLmRhdGFbaV0gIT0gMCkgcmV0dXJuIGkqdGhpcy5EQitsYml0KHRoaXMuZGF0YVtpXSk7XG5pZih0aGlzLnMgPCAwKSByZXR1cm4gdGhpcy50KnRoaXMuREI7XG5yZXR1cm4gLTE7XG59XG5cbi8vcmV0dXJuIG51bWJlciBvZiAxIGJpdHMgaW4geFxuZnVuY3Rpb24gY2JpdCh4KSB7XG52YXIgciA9IDA7XG53aGlsZSh4ICE9IDApIHsgeCAmPSB4LTE7ICsrcjsgfVxucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgcmV0dXJuIG51bWJlciBvZiBzZXQgYml0c1xuZnVuY3Rpb24gYm5CaXRDb3VudCgpIHtcbnZhciByID0gMCwgeCA9IHRoaXMucyZ0aGlzLkRNO1xuZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSByICs9IGNiaXQodGhpcy5kYXRhW2ldXngpO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdHJ1ZSBpZmYgbnRoIGJpdCBpcyBzZXRcbmZ1bmN0aW9uIGJuVGVzdEJpdChuKSB7XG52YXIgaiA9IE1hdGguZmxvb3Iobi90aGlzLkRCKTtcbmlmKGogPj0gdGhpcy50KSByZXR1cm4odGhpcy5zIT0wKTtcbnJldHVybigodGhpcy5kYXRhW2pdJigxPDwobiV0aGlzLkRCKSkpIT0wKTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0aGlzIG9wICgxPDxuKVxuZnVuY3Rpb24gYm5wQ2hhbmdlQml0KG4sb3ApIHtcbnZhciByID0gQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KG4pO1xudGhpcy5iaXR3aXNlVG8ocixvcCxyKTtcbnJldHVybiByO1xufVxuXG4vLyhwdWJsaWMpIHRoaXMgfCAoMTw8bilcbmZ1bmN0aW9uIGJuU2V0Qml0KG4pIHsgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3Bfb3IpOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAmIH4oMTw8bilcbmZ1bmN0aW9uIGJuQ2xlYXJCaXQobikgeyByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobixvcF9hbmRub3QpOyB9XG5cbi8vKHB1YmxpYykgdGhpcyBeICgxPDxuKVxuZnVuY3Rpb24gYm5GbGlwQml0KG4pIHsgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3BfeG9yKTsgfVxuXG4vLyhwcm90ZWN0ZWQpIHIgPSB0aGlzICsgYVxuZnVuY3Rpb24gYm5wQWRkVG8oYSxyKSB7XG52YXIgaSA9IDAsIGMgPSAwLCBtID0gTWF0aC5taW4oYS50LHRoaXMudCk7XG53aGlsZShpIDwgbSkge1xuIGMgKz0gdGhpcy5kYXRhW2ldK2EuZGF0YVtpXTtcbiByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiBjID4+PSB0aGlzLkRCO1xufVxuaWYoYS50IDwgdGhpcy50KSB7XG4gYyArPSBhLnM7XG4gd2hpbGUoaSA8IHRoaXMudCkge1xuICAgYyArPSB0aGlzLmRhdGFbaV07XG4gICByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiAgIGMgPj49IHRoaXMuREI7XG4gfVxuIGMgKz0gdGhpcy5zO1xufSBlbHNlIHtcbiBjICs9IHRoaXMucztcbiB3aGlsZShpIDwgYS50KSB7XG4gICBjICs9IGEuZGF0YVtpXTtcbiAgIHIuZGF0YVtpKytdID0gYyZ0aGlzLkRNO1xuICAgYyA+Pj0gdGhpcy5EQjtcbiB9XG4gYyArPSBhLnM7XG59XG5yLnMgPSAoYzwwKT8tMTowO1xuaWYoYyA+IDApIHIuZGF0YVtpKytdID0gYztcbmVsc2UgaWYoYyA8IC0xKSByLmRhdGFbaSsrXSA9IHRoaXMuRFYrYztcbnIudCA9IGk7XG5yLmNsYW1wKCk7XG59XG5cbi8vKHB1YmxpYykgdGhpcyArIGFcbmZ1bmN0aW9uIGJuQWRkKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5hZGRUbyhhLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgLSBhXG5mdW5jdGlvbiBiblN1YnRyYWN0KGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5zdWJUbyhhLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgKiBhXG5mdW5jdGlvbiBibk11bHRpcGx5KGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5tdWx0aXBseVRvKGEscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAvIGFcbmZ1bmN0aW9uIGJuRGl2aWRlKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5kaXZSZW1UbyhhLHIsbnVsbCk7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAlIGFcbmZ1bmN0aW9uIGJuUmVtYWluZGVyKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5kaXZSZW1UbyhhLG51bGwscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgW3RoaXMvYSx0aGlzJWFdXG5mdW5jdGlvbiBibkRpdmlkZUFuZFJlbWFpbmRlcihhKSB7XG52YXIgcSA9IG5iaSgpLCByID0gbmJpKCk7XG50aGlzLmRpdlJlbVRvKGEscSxyKTtcbnJldHVybiBuZXcgQXJyYXkocSxyKTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0aGlzICo9IG4sIHRoaXMgPj0gMCwgMSA8IG4gPCBEVlxuZnVuY3Rpb24gYm5wRE11bHRpcGx5KG4pIHtcbnRoaXMuZGF0YVt0aGlzLnRdID0gdGhpcy5hbSgwLG4tMSx0aGlzLDAsMCx0aGlzLnQpO1xuKyt0aGlzLnQ7XG50aGlzLmNsYW1wKCk7XG59XG5cbi8vKHByb3RlY3RlZCkgdGhpcyArPSBuIDw8IHcgd29yZHMsIHRoaXMgPj0gMFxuZnVuY3Rpb24gYm5wREFkZE9mZnNldChuLHcpIHtcbmlmKG4gPT0gMCkgcmV0dXJuO1xud2hpbGUodGhpcy50IDw9IHcpIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAwO1xudGhpcy5kYXRhW3ddICs9IG47XG53aGlsZSh0aGlzLmRhdGFbd10gPj0gdGhpcy5EVikge1xuIHRoaXMuZGF0YVt3XSAtPSB0aGlzLkRWO1xuIGlmKCsrdyA+PSB0aGlzLnQpIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAwO1xuICsrdGhpcy5kYXRhW3ddO1xufVxufVxuXG4vL0EgXCJudWxsXCIgcmVkdWNlclxuZnVuY3Rpb24gTnVsbEV4cCgpIHt9XG5mdW5jdGlvbiBuTm9wKHgpIHsgcmV0dXJuIHg7IH1cbmZ1bmN0aW9uIG5NdWxUbyh4LHkscikgeyB4Lm11bHRpcGx5VG8oeSxyKTsgfVxuZnVuY3Rpb24gblNxclRvKHgscikgeyB4LnNxdWFyZVRvKHIpOyB9XG5cbk51bGxFeHAucHJvdG90eXBlLmNvbnZlcnQgPSBuTm9wO1xuTnVsbEV4cC5wcm90b3R5cGUucmV2ZXJ0ID0gbk5vcDtcbk51bGxFeHAucHJvdG90eXBlLm11bFRvID0gbk11bFRvO1xuTnVsbEV4cC5wcm90b3R5cGUuc3FyVG8gPSBuU3FyVG87XG5cbi8vKHB1YmxpYykgdGhpc15lXG5mdW5jdGlvbiBiblBvdyhlKSB7IHJldHVybiB0aGlzLmV4cChlLG5ldyBOdWxsRXhwKCkpOyB9XG5cbi8vKHByb3RlY3RlZCkgciA9IGxvd2VyIG4gd29yZHMgb2YgXCJ0aGlzICogYVwiLCBhLnQgPD0gblxuLy9cInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseUxvd2VyVG8oYSxuLHIpIHtcbnZhciBpID0gTWF0aC5taW4odGhpcy50K2EudCxuKTtcbnIucyA9IDA7IC8vIGFzc3VtZXMgYSx0aGlzID49IDBcbnIudCA9IGk7XG53aGlsZShpID4gMCkgci5kYXRhWy0taV0gPSAwO1xudmFyIGo7XG5mb3IoaiA9IHIudC10aGlzLnQ7IGkgPCBqOyArK2kpIHIuZGF0YVtpK3RoaXMudF0gPSB0aGlzLmFtKDAsYS5kYXRhW2ldLHIsaSwwLHRoaXMudCk7XG5mb3IoaiA9IE1hdGgubWluKGEudCxuKTsgaSA8IGo7ICsraSkgdGhpcy5hbSgwLGEuZGF0YVtpXSxyLGksMCxuLWkpO1xuci5jbGFtcCgpO1xufVxuXG4vLyhwcm90ZWN0ZWQpIHIgPSBcInRoaXMgKiBhXCIgd2l0aG91dCBsb3dlciBuIHdvcmRzLCBuID4gMFxuLy9cInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseVVwcGVyVG8oYSxuLHIpIHtcbi0tbjtcbnZhciBpID0gci50ID0gdGhpcy50K2EudC1uO1xuci5zID0gMDsgLy8gYXNzdW1lcyBhLHRoaXMgPj0gMFxud2hpbGUoLS1pID49IDApIHIuZGF0YVtpXSA9IDA7XG5mb3IoaSA9IE1hdGgubWF4KG4tdGhpcy50LDApOyBpIDwgYS50OyArK2kpXG4gci5kYXRhW3RoaXMudCtpLW5dID0gdGhpcy5hbShuLWksYS5kYXRhW2ldLHIsMCwwLHRoaXMudCtpLW4pO1xuci5jbGFtcCgpO1xuci5kclNoaWZ0VG8oMSxyKTtcbn1cblxuLy9CYXJyZXR0IG1vZHVsYXIgcmVkdWN0aW9uXG5mdW5jdGlvbiBCYXJyZXR0KG0pIHtcbi8vIHNldHVwIEJhcnJldHRcbnRoaXMucjIgPSBuYmkoKTtcbnRoaXMucTMgPSBuYmkoKTtcbkJpZ0ludGVnZXIuT05FLmRsU2hpZnRUbygyKm0udCx0aGlzLnIyKTtcbnRoaXMubXUgPSB0aGlzLnIyLmRpdmlkZShtKTtcbnRoaXMubSA9IG07XG59XG5cbmZ1bmN0aW9uIGJhcnJldHRDb252ZXJ0KHgpIHtcbmlmKHgucyA8IDAgfHwgeC50ID4gMip0aGlzLm0udCkgcmV0dXJuIHgubW9kKHRoaXMubSk7XG5lbHNlIGlmKHguY29tcGFyZVRvKHRoaXMubSkgPCAwKSByZXR1cm4geDtcbmVsc2UgeyB2YXIgciA9IG5iaSgpOyB4LmNvcHlUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IHJldHVybiByOyB9XG59XG5cbmZ1bmN0aW9uIGJhcnJldHRSZXZlcnQoeCkgeyByZXR1cm4geDsgfVxuXG4vL3ggPSB4IG1vZCBtIChIQUMgMTQuNDIpXG5mdW5jdGlvbiBiYXJyZXR0UmVkdWNlKHgpIHtcbnguZHJTaGlmdFRvKHRoaXMubS50LTEsdGhpcy5yMik7XG5pZih4LnQgPiB0aGlzLm0udCsxKSB7IHgudCA9IHRoaXMubS50KzE7IHguY2xhbXAoKTsgfVxudGhpcy5tdS5tdWx0aXBseVVwcGVyVG8odGhpcy5yMix0aGlzLm0udCsxLHRoaXMucTMpO1xudGhpcy5tLm11bHRpcGx5TG93ZXJUbyh0aGlzLnEzLHRoaXMubS50KzEsdGhpcy5yMik7XG53aGlsZSh4LmNvbXBhcmVUbyh0aGlzLnIyKSA8IDApIHguZEFkZE9mZnNldCgxLHRoaXMubS50KzEpO1xueC5zdWJUbyh0aGlzLnIyLHgpO1xud2hpbGUoeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSB4LnN1YlRvKHRoaXMubSx4KTtcbn1cblxuLy9yID0geF4yIG1vZCBtOyB4ICE9IHJcbmZ1bmN0aW9uIGJhcnJldHRTcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuLy9yID0geCp5IG1vZCBtOyB4LHkgIT0gclxuZnVuY3Rpb24gYmFycmV0dE11bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG5CYXJyZXR0LnByb3RvdHlwZS5jb252ZXJ0ID0gYmFycmV0dENvbnZlcnQ7XG5CYXJyZXR0LnByb3RvdHlwZS5yZXZlcnQgPSBiYXJyZXR0UmV2ZXJ0O1xuQmFycmV0dC5wcm90b3R5cGUucmVkdWNlID0gYmFycmV0dFJlZHVjZTtcbkJhcnJldHQucHJvdG90eXBlLm11bFRvID0gYmFycmV0dE11bFRvO1xuQmFycmV0dC5wcm90b3R5cGUuc3FyVG8gPSBiYXJyZXR0U3FyVG87XG5cbi8vKHB1YmxpYykgdGhpc15lICUgbSAoSEFDIDE0Ljg1KVxuZnVuY3Rpb24gYm5Nb2RQb3coZSxtKSB7XG52YXIgaSA9IGUuYml0TGVuZ3RoKCksIGssIHIgPSBuYnYoMSksIHo7XG5pZihpIDw9IDApIHJldHVybiByO1xuZWxzZSBpZihpIDwgMTgpIGsgPSAxO1xuZWxzZSBpZihpIDwgNDgpIGsgPSAzO1xuZWxzZSBpZihpIDwgMTQ0KSBrID0gNDtcbmVsc2UgaWYoaSA8IDc2OCkgayA9IDU7XG5lbHNlIGsgPSA2O1xuaWYoaSA8IDgpXG4geiA9IG5ldyBDbGFzc2ljKG0pO1xuZWxzZSBpZihtLmlzRXZlbigpKVxuIHogPSBuZXcgQmFycmV0dChtKTtcbmVsc2VcbiB6ID0gbmV3IE1vbnRnb21lcnkobSk7XG5cbi8vIHByZWNvbXB1dGF0aW9uXG52YXIgZyA9IG5ldyBBcnJheSgpLCBuID0gMywgazEgPSBrLTEsIGttID0gKDE8PGspLTE7XG5nWzFdID0gei5jb252ZXJ0KHRoaXMpO1xuaWYoayA+IDEpIHtcbiB2YXIgZzIgPSBuYmkoKTtcbiB6LnNxclRvKGdbMV0sZzIpO1xuIHdoaWxlKG4gPD0ga20pIHtcbiAgIGdbbl0gPSBuYmkoKTtcbiAgIHoubXVsVG8oZzIsZ1tuLTJdLGdbbl0pO1xuICAgbiArPSAyO1xuIH1cbn1cblxudmFyIGogPSBlLnQtMSwgdywgaXMxID0gdHJ1ZSwgcjIgPSBuYmkoKSwgdDtcbmkgPSBuYml0cyhlLmRhdGFbal0pLTE7XG53aGlsZShqID49IDApIHtcbiBpZihpID49IGsxKSB3ID0gKGUuZGF0YVtqXT4+KGktazEpKSZrbTtcbiBlbHNlIHtcbiAgIHcgPSAoZS5kYXRhW2pdJigoMTw8KGkrMSkpLTEpKTw8KGsxLWkpO1xuICAgaWYoaiA+IDApIHcgfD0gZS5kYXRhW2otMV0+Pih0aGlzLkRCK2ktazEpO1xuIH1cblxuIG4gPSBrO1xuIHdoaWxlKCh3JjEpID09IDApIHsgdyA+Pj0gMTsgLS1uOyB9XG4gaWYoKGkgLT0gbikgPCAwKSB7IGkgKz0gdGhpcy5EQjsgLS1qOyB9XG4gaWYoaXMxKSB7ICAvLyByZXQgPT0gMSwgZG9uJ3QgYm90aGVyIHNxdWFyaW5nIG9yIG11bHRpcGx5aW5nIGl0XG4gICBnW3ddLmNvcHlUbyhyKTtcbiAgIGlzMSA9IGZhbHNlO1xuIH0gZWxzZSB7XG4gICB3aGlsZShuID4gMSkgeyB6LnNxclRvKHIscjIpOyB6LnNxclRvKHIyLHIpOyBuIC09IDI7IH1cbiAgIGlmKG4gPiAwKSB6LnNxclRvKHIscjIpOyBlbHNlIHsgdCA9IHI7IHIgPSByMjsgcjIgPSB0OyB9XG4gICB6Lm11bFRvKHIyLGdbd10scik7XG4gfVxuXG4gd2hpbGUoaiA+PSAwICYmIChlLmRhdGFbal0mKDE8PGkpKSA9PSAwKSB7XG4gICB6LnNxclRvKHIscjIpOyB0ID0gcjsgciA9IHIyOyByMiA9IHQ7XG4gICBpZigtLWkgPCAwKSB7IGkgPSB0aGlzLkRCLTE7IC0tajsgfVxuIH1cbn1cbnJldHVybiB6LnJldmVydChyKTtcbn1cblxuLy8ocHVibGljKSBnY2QodGhpcyxhKSAoSEFDIDE0LjU0KVxuZnVuY3Rpb24gYm5HQ0QoYSkge1xudmFyIHggPSAodGhpcy5zPDApP3RoaXMubmVnYXRlKCk6dGhpcy5jbG9uZSgpO1xudmFyIHkgPSAoYS5zPDApP2EubmVnYXRlKCk6YS5jbG9uZSgpO1xuaWYoeC5jb21wYXJlVG8oeSkgPCAwKSB7IHZhciB0ID0geDsgeCA9IHk7IHkgPSB0OyB9XG52YXIgaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCksIGcgPSB5LmdldExvd2VzdFNldEJpdCgpO1xuaWYoZyA8IDApIHJldHVybiB4O1xuaWYoaSA8IGcpIGcgPSBpO1xuaWYoZyA+IDApIHtcbiB4LnJTaGlmdFRvKGcseCk7XG4geS5yU2hpZnRUbyhnLHkpO1xufVxud2hpbGUoeC5zaWdudW0oKSA+IDApIHtcbiBpZigoaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCkpID4gMCkgeC5yU2hpZnRUbyhpLHgpO1xuIGlmKChpID0geS5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB5LnJTaGlmdFRvKGkseSk7XG4gaWYoeC5jb21wYXJlVG8oeSkgPj0gMCkge1xuICAgeC5zdWJUbyh5LHgpO1xuICAgeC5yU2hpZnRUbygxLHgpO1xuIH0gZWxzZSB7XG4gICB5LnN1YlRvKHgseSk7XG4gICB5LnJTaGlmdFRvKDEseSk7XG4gfVxufVxuaWYoZyA+IDApIHkubFNoaWZ0VG8oZyx5KTtcbnJldHVybiB5O1xufVxuXG4vLyhwcm90ZWN0ZWQpIHRoaXMgJSBuLCBuIDwgMl4yNlxuZnVuY3Rpb24gYm5wTW9kSW50KG4pIHtcbmlmKG4gPD0gMCkgcmV0dXJuIDA7XG52YXIgZCA9IHRoaXMuRFYlbiwgciA9ICh0aGlzLnM8MCk/bi0xOjA7XG5pZih0aGlzLnQgPiAwKVxuIGlmKGQgPT0gMCkgciA9IHRoaXMuZGF0YVswXSVuO1xuIGVsc2UgZm9yKHZhciBpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSByID0gKGQqcit0aGlzLmRhdGFbaV0pJW47XG5yZXR1cm4gcjtcbn1cblxuLy8ocHVibGljKSAxL3RoaXMgJSBtIChIQUMgMTQuNjEpXG5mdW5jdGlvbiBibk1vZEludmVyc2UobSkge1xudmFyIGFjID0gbS5pc0V2ZW4oKTtcbmlmKCh0aGlzLmlzRXZlbigpICYmIGFjKSB8fCBtLnNpZ251bSgpID09IDApIHJldHVybiBCaWdJbnRlZ2VyLlpFUk87XG52YXIgdSA9IG0uY2xvbmUoKSwgdiA9IHRoaXMuY2xvbmUoKTtcbnZhciBhID0gbmJ2KDEpLCBiID0gbmJ2KDApLCBjID0gbmJ2KDApLCBkID0gbmJ2KDEpO1xud2hpbGUodS5zaWdudW0oKSAhPSAwKSB7XG4gd2hpbGUodS5pc0V2ZW4oKSkge1xuICAgdS5yU2hpZnRUbygxLHUpO1xuICAgaWYoYWMpIHtcbiAgICAgaWYoIWEuaXNFdmVuKCkgfHwgIWIuaXNFdmVuKCkpIHsgYS5hZGRUbyh0aGlzLGEpOyBiLnN1YlRvKG0sYik7IH1cbiAgICAgYS5yU2hpZnRUbygxLGEpO1xuICAgfSBlbHNlIGlmKCFiLmlzRXZlbigpKSBiLnN1YlRvKG0sYik7XG4gICBiLnJTaGlmdFRvKDEsYik7XG4gfVxuIHdoaWxlKHYuaXNFdmVuKCkpIHtcbiAgIHYuclNoaWZ0VG8oMSx2KTtcbiAgIGlmKGFjKSB7XG4gICAgIGlmKCFjLmlzRXZlbigpIHx8ICFkLmlzRXZlbigpKSB7IGMuYWRkVG8odGhpcyxjKTsgZC5zdWJUbyhtLGQpOyB9XG4gICAgIGMuclNoaWZ0VG8oMSxjKTtcbiAgIH0gZWxzZSBpZighZC5pc0V2ZW4oKSkgZC5zdWJUbyhtLGQpO1xuICAgZC5yU2hpZnRUbygxLGQpO1xuIH1cbiBpZih1LmNvbXBhcmVUbyh2KSA+PSAwKSB7XG4gICB1LnN1YlRvKHYsdSk7XG4gICBpZihhYykgYS5zdWJUbyhjLGEpO1xuICAgYi5zdWJUbyhkLGIpO1xuIH0gZWxzZSB7XG4gICB2LnN1YlRvKHUsdik7XG4gICBpZihhYykgYy5zdWJUbyhhLGMpO1xuICAgZC5zdWJUbyhiLGQpO1xuIH1cbn1cbmlmKHYuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPSAwKSByZXR1cm4gQmlnSW50ZWdlci5aRVJPO1xuaWYoZC5jb21wYXJlVG8obSkgPj0gMCkgcmV0dXJuIGQuc3VidHJhY3QobSk7XG5pZihkLnNpZ251bSgpIDwgMCkgZC5hZGRUbyhtLGQpOyBlbHNlIHJldHVybiBkO1xuaWYoZC5zaWdudW0oKSA8IDApIHJldHVybiBkLmFkZChtKTsgZWxzZSByZXR1cm4gZDtcbn1cblxudmFyIGxvd3ByaW1lcyA9IFsyLDMsNSw3LDExLDEzLDE3LDE5LDIzLDI5LDMxLDM3LDQxLDQzLDQ3LDUzLDU5LDYxLDY3LDcxLDczLDc5LDgzLDg5LDk3LDEwMSwxMDMsMTA3LDEwOSwxMTMsMTI3LDEzMSwxMzcsMTM5LDE0OSwxNTEsMTU3LDE2MywxNjcsMTczLDE3OSwxODEsMTkxLDE5MywxOTcsMTk5LDIxMSwyMjMsMjI3LDIyOSwyMzMsMjM5LDI0MSwyNTEsMjU3LDI2MywyNjksMjcxLDI3NywyODEsMjgzLDI5MywzMDcsMzExLDMxMywzMTcsMzMxLDMzNywzNDcsMzQ5LDM1MywzNTksMzY3LDM3MywzNzksMzgzLDM4OSwzOTcsNDAxLDQwOSw0MTksNDIxLDQzMSw0MzMsNDM5LDQ0Myw0NDksNDU3LDQ2MSw0NjMsNDY3LDQ3OSw0ODcsNDkxLDQ5OSw1MDMsNTA5XTtcbnZhciBscGxpbSA9ICgxPDwyNikvbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGgtMV07XG5cbi8vKHB1YmxpYykgdGVzdCBwcmltYWxpdHkgd2l0aCBjZXJ0YWludHkgPj0gMS0uNV50XG5mdW5jdGlvbiBibklzUHJvYmFibGVQcmltZSh0KSB7XG52YXIgaSwgeCA9IHRoaXMuYWJzKCk7XG5pZih4LnQgPT0gMSAmJiB4LmRhdGFbMF0gPD0gbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGgtMV0pIHtcbiBmb3IoaSA9IDA7IGkgPCBsb3dwcmltZXMubGVuZ3RoOyArK2kpXG4gICBpZih4LmRhdGFbMF0gPT0gbG93cHJpbWVzW2ldKSByZXR1cm4gdHJ1ZTtcbiByZXR1cm4gZmFsc2U7XG59XG5pZih4LmlzRXZlbigpKSByZXR1cm4gZmFsc2U7XG5pID0gMTtcbndoaWxlKGkgPCBsb3dwcmltZXMubGVuZ3RoKSB7XG4gdmFyIG0gPSBsb3dwcmltZXNbaV0sIGogPSBpKzE7XG4gd2hpbGUoaiA8IGxvd3ByaW1lcy5sZW5ndGggJiYgbSA8IGxwbGltKSBtICo9IGxvd3ByaW1lc1tqKytdO1xuIG0gPSB4Lm1vZEludChtKTtcbiB3aGlsZShpIDwgaikgaWYobSVsb3dwcmltZXNbaSsrXSA9PSAwKSByZXR1cm4gZmFsc2U7XG59XG5yZXR1cm4geC5taWxsZXJSYWJpbih0KTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0cnVlIGlmIHByb2JhYmx5IHByaW1lIChIQUMgNC4yNCwgTWlsbGVyLVJhYmluKVxuZnVuY3Rpb24gYm5wTWlsbGVyUmFiaW4odCkge1xudmFyIG4xID0gdGhpcy5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG52YXIgayA9IG4xLmdldExvd2VzdFNldEJpdCgpO1xuaWYoayA8PSAwKSByZXR1cm4gZmFsc2U7XG52YXIgciA9IG4xLnNoaWZ0UmlnaHQoayk7XG52YXIgcHJuZyA9IGJuR2V0UHJuZygpO1xudmFyIGE7XG5mb3IodmFyIGkgPSAwOyBpIDwgdDsgKytpKSB7XG4gLy8gc2VsZWN0IHdpdG5lc3MgJ2EnIGF0IHJhbmRvbSBmcm9tIGJldHdlZW4gMSBhbmQgbjFcbiBkbyB7XG4gICBhID0gbmV3IEJpZ0ludGVnZXIodGhpcy5iaXRMZW5ndGgoKSwgcHJuZyk7XG4gfVxuIHdoaWxlKGEuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA8PSAwIHx8IGEuY29tcGFyZVRvKG4xKSA+PSAwKTtcbiB2YXIgeSA9IGEubW9kUG93KHIsdGhpcyk7XG4gaWYoeS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9IDAgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgIHZhciBqID0gMTtcbiAgIHdoaWxlKGorKyA8IGsgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgICAgeSA9IHkubW9kUG93SW50KDIsdGhpcyk7XG4gICAgIGlmKHkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICB9XG4gICBpZih5LmNvbXBhcmVUbyhuMSkgIT0gMCkgcmV0dXJuIGZhbHNlO1xuIH1cbn1cbnJldHVybiB0cnVlO1xufVxuXG4vLyBnZXQgcHNldWRvIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG5mdW5jdGlvbiBibkdldFBybmcoKSB7XG4gIC8vIGNyZWF0ZSBwcm5nIHdpdGggYXBpIHRoYXQgbWF0Y2hlcyBCaWdJbnRlZ2VyIHNlY3VyZSByYW5kb21cbiAgcmV0dXJuIHtcbiAgICAvLyB4IGlzIGFuIGFycmF5IHRvIGZpbGwgd2l0aCBieXRlc1xuICAgIG5leHRCeXRlczogZnVuY3Rpb24oeCkge1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgeFtpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MDEwMCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vL3Byb3RlY3RlZFxuQmlnSW50ZWdlci5wcm90b3R5cGUuY2h1bmtTaXplID0gYm5wQ2h1bmtTaXplO1xuQmlnSW50ZWdlci5wcm90b3R5cGUudG9SYWRpeCA9IGJucFRvUmFkaXg7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tUmFkaXggPSBibnBGcm9tUmFkaXg7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tTnVtYmVyID0gYm5wRnJvbU51bWJlcjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmJpdHdpc2VUbyA9IGJucEJpdHdpc2VUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNoYW5nZUJpdCA9IGJucENoYW5nZUJpdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFkZFRvID0gYm5wQWRkVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kTXVsdGlwbHkgPSBibnBETXVsdGlwbHk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kQWRkT2Zmc2V0ID0gYm5wREFkZE9mZnNldDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5TG93ZXJUbyA9IGJucE11bHRpcGx5TG93ZXJUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5VXBwZXJUbyA9IGJucE11bHRpcGx5VXBwZXJUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludCA9IGJucE1vZEludDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1pbGxlclJhYmluID0gYm5wTWlsbGVyUmFiaW47XG5cbi8vcHVibGljXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5jbG9uZSA9IGJuQ2xvbmU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5pbnRWYWx1ZSA9IGJuSW50VmFsdWU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5ieXRlVmFsdWUgPSBibkJ5dGVWYWx1ZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnNob3J0VmFsdWUgPSBiblNob3J0VmFsdWU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zaWdudW0gPSBiblNpZ051bTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnRvQnl0ZUFycmF5ID0gYm5Ub0J5dGVBcnJheTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmVxdWFscyA9IGJuRXF1YWxzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubWluID0gYm5NaW47XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tYXggPSBibk1heDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFuZCA9IGJuQW5kO1xuQmlnSW50ZWdlci5wcm90b3R5cGUub3IgPSBibk9yO1xuQmlnSW50ZWdlci5wcm90b3R5cGUueG9yID0gYm5Yb3I7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmROb3QgPSBibkFuZE5vdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm5vdCA9IGJuTm90O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gYm5TaGlmdExlZnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gYm5TaGlmdFJpZ2h0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZ2V0TG93ZXN0U2V0Qml0ID0gYm5HZXRMb3dlc3RTZXRCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRDb3VudCA9IGJuQml0Q291bnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50ZXN0Qml0ID0gYm5UZXN0Qml0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuc2V0Qml0ID0gYm5TZXRCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5jbGVhckJpdCA9IGJuQ2xlYXJCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mbGlwQml0ID0gYm5GbGlwQml0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkID0gYm5BZGQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGJuU3VidHJhY3Q7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseSA9IGJuTXVsdGlwbHk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGUgPSBibkRpdmlkZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IGJuUmVtYWluZGVyO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlQW5kUmVtYWluZGVyID0gYm5EaXZpZGVBbmRSZW1haW5kZXI7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBibk1vZFBvdztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludmVyc2UgPSBibk1vZEludmVyc2U7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3cgPSBiblBvdztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmdjZCA9IGJuR0NEO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lID0gYm5Jc1Byb2JhYmxlUHJpbWU7XG5cbi8vQmlnSW50ZWdlciBpbnRlcmZhY2VzIG5vdCBpbXBsZW1lbnRlZCBpbiBqc2JuOlxuXG4vL0JpZ0ludGVnZXIoaW50IHNpZ251bSwgYnl0ZVtdIG1hZ25pdHVkZSlcbi8vZG91YmxlIGRvdWJsZVZhbHVlKClcbi8vZmxvYXQgZmxvYXRWYWx1ZSgpXG4vL2ludCBoYXNoQ29kZSgpXG4vL2xvbmcgbG9uZ1ZhbHVlKClcbi8vc3RhdGljIEJpZ0ludGVnZXIgdmFsdWVPZihsb25nIHZhbClcbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwianNibiIsImRiaXRzIiwiY2FuYXJ5Iiwial9sbSIsIkJpZ0ludGVnZXIiLCJhIiwiYiIsImMiLCJkYXRhIiwiZnJvbU51bWJlciIsImZyb21TdHJpbmciLCJuYmkiLCJhbTEiLCJpIiwieCIsInciLCJqIiwibiIsInYiLCJNYXRoIiwiZmxvb3IiLCJhbTIiLCJ4bCIsInhoIiwibCIsImgiLCJtIiwiYW0zIiwibmF2aWdhdG9yIiwicHJvdG90eXBlIiwiYW0iLCJhcHBOYW1lIiwiREIiLCJETSIsIkRWIiwiQklfRlAiLCJGViIsInBvdyIsIkYxIiwiRjIiLCJCSV9STSIsIkJJX1JDIiwiQXJyYXkiLCJyciIsInZ2IiwiY2hhckNvZGVBdCIsImludDJjaGFyIiwiY2hhckF0IiwiaW50QXQiLCJzIiwiYm5wQ29weVRvIiwiciIsInQiLCJibnBGcm9tSW50IiwibmJ2IiwiZnJvbUludCIsImJucEZyb21TdHJpbmciLCJrIiwiZnJvbVJhZGl4IiwibGVuZ3RoIiwibWkiLCJzaCIsImNsYW1wIiwiWkVSTyIsInN1YlRvIiwiYm5wQ2xhbXAiLCJiblRvU3RyaW5nIiwibmVnYXRlIiwidG9TdHJpbmciLCJ0b1JhZGl4Iiwia20iLCJkIiwicCIsImJuTmVnYXRlIiwiYm5BYnMiLCJibkNvbXBhcmVUbyIsIm5iaXRzIiwiYm5CaXRMZW5ndGgiLCJibnBETFNoaWZ0VG8iLCJibnBEUlNoaWZ0VG8iLCJtYXgiLCJibnBMU2hpZnRUbyIsImJzIiwiY2JzIiwiYm0iLCJkcyIsImJucFJTaGlmdFRvIiwiYm5wU3ViVG8iLCJtaW4iLCJibnBNdWx0aXBseVRvIiwiYWJzIiwieSIsImJucFNxdWFyZVRvIiwiYm5wRGl2UmVtVG8iLCJxIiwicG0iLCJwdCIsImNvcHlUbyIsInRzIiwibXMiLCJuc2giLCJsU2hpZnRUbyIsInlzIiwieTAiLCJ5dCIsImQxIiwiZDIiLCJlIiwiZGxTaGlmdFRvIiwiY29tcGFyZVRvIiwiT05FIiwicWQiLCJkclNoaWZ0VG8iLCJyU2hpZnRUbyIsImJuTW9kIiwiZGl2UmVtVG8iLCJDbGFzc2ljIiwiY0NvbnZlcnQiLCJtb2QiLCJjUmV2ZXJ0IiwiY1JlZHVjZSIsImNNdWxUbyIsIm11bHRpcGx5VG8iLCJyZWR1Y2UiLCJjU3FyVG8iLCJzcXVhcmVUbyIsImNvbnZlcnQiLCJyZXZlcnQiLCJtdWxUbyIsInNxclRvIiwiYm5wSW52RGlnaXQiLCJNb250Z29tZXJ5IiwibXAiLCJpbnZEaWdpdCIsIm1wbCIsIm1waCIsInVtIiwibXQyIiwibW9udENvbnZlcnQiLCJtb250UmV2ZXJ0IiwibW9udFJlZHVjZSIsInUwIiwibW9udFNxclRvIiwibW9udE11bFRvIiwiYm5wSXNFdmVuIiwiYm5wRXhwIiwieiIsInIyIiwiZyIsImJuTW9kUG93SW50IiwiaXNFdmVuIiwiZXhwIiwiYml0TGVuZ3RoIiwibW9kUG93SW50IiwiYm5DbG9uZSIsImJuSW50VmFsdWUiLCJibkJ5dGVWYWx1ZSIsImJuU2hvcnRWYWx1ZSIsImJucENodW5rU2l6ZSIsIkxOMiIsImxvZyIsImJuU2lnTnVtIiwiYm5wVG9SYWRpeCIsInNpZ251bSIsImNzIiwiY2h1bmtTaXplIiwiaW50VmFsdWUiLCJzdWJzdHIiLCJibnBGcm9tUmFkaXgiLCJkTXVsdGlwbHkiLCJkQWRkT2Zmc2V0IiwiYm5wRnJvbU51bWJlciIsInRlc3RCaXQiLCJiaXR3aXNlVG8iLCJzaGlmdExlZnQiLCJvcF9vciIsImlzUHJvYmFibGVQcmltZSIsIm5leHRCeXRlcyIsImJuVG9CeXRlQXJyYXkiLCJibkVxdWFscyIsImJuTWluIiwiYm5NYXgiLCJibnBCaXR3aXNlVG8iLCJvcCIsImYiLCJvcF9hbmQiLCJibkFuZCIsImJuT3IiLCJvcF94b3IiLCJiblhvciIsIm9wX2FuZG5vdCIsImJuQW5kTm90IiwiYm5Ob3QiLCJiblNoaWZ0TGVmdCIsImJuU2hpZnRSaWdodCIsImxiaXQiLCJibkdldExvd2VzdFNldEJpdCIsImNiaXQiLCJibkJpdENvdW50IiwiYm5UZXN0Qml0IiwiYm5wQ2hhbmdlQml0IiwiYm5TZXRCaXQiLCJjaGFuZ2VCaXQiLCJibkNsZWFyQml0IiwiYm5GbGlwQml0IiwiYm5wQWRkVG8iLCJibkFkZCIsImFkZFRvIiwiYm5TdWJ0cmFjdCIsImJuTXVsdGlwbHkiLCJibkRpdmlkZSIsImJuUmVtYWluZGVyIiwiYm5EaXZpZGVBbmRSZW1haW5kZXIiLCJibnBETXVsdGlwbHkiLCJibnBEQWRkT2Zmc2V0IiwiTnVsbEV4cCIsIm5Ob3AiLCJuTXVsVG8iLCJuU3FyVG8iLCJiblBvdyIsImJucE11bHRpcGx5TG93ZXJUbyIsImJucE11bHRpcGx5VXBwZXJUbyIsIkJhcnJldHQiLCJxMyIsIm11IiwiZGl2aWRlIiwiYmFycmV0dENvbnZlcnQiLCJiYXJyZXR0UmV2ZXJ0IiwiYmFycmV0dFJlZHVjZSIsIm11bHRpcGx5VXBwZXJUbyIsIm11bHRpcGx5TG93ZXJUbyIsImJhcnJldHRTcXJUbyIsImJhcnJldHRNdWxUbyIsImJuTW9kUG93IiwiazEiLCJnMiIsImlzMSIsImJuR0NEIiwiY2xvbmUiLCJnZXRMb3dlc3RTZXRCaXQiLCJibnBNb2RJbnQiLCJibk1vZEludmVyc2UiLCJhYyIsInUiLCJzdWJ0cmFjdCIsImFkZCIsImxvd3ByaW1lcyIsImxwbGltIiwiYm5Jc1Byb2JhYmxlUHJpbWUiLCJtb2RJbnQiLCJtaWxsZXJSYWJpbiIsImJucE1pbGxlclJhYmluIiwibjEiLCJzaGlmdFJpZ2h0IiwicHJuZyIsImJuR2V0UHJuZyIsIm1vZFBvdyIsInJhbmRvbSIsImJ5dGVWYWx1ZSIsInNob3J0VmFsdWUiLCJ0b0J5dGVBcnJheSIsImVxdWFscyIsImFuZCIsIm9yIiwieG9yIiwiYW5kTm90Iiwibm90IiwiYml0Q291bnQiLCJzZXRCaXQiLCJjbGVhckJpdCIsImZsaXBCaXQiLCJtdWx0aXBseSIsInJlbWFpbmRlciIsImRpdmlkZUFuZFJlbWFpbmRlciIsIm1vZEludmVyc2UiLCJnY2QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/jsbn.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/kem.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/kem.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Javascript implementation of RSA-KEM.\n *\n * @author Lautaro Cozzani Rodriguez\n * @author Dave Longley\n *\n * Copyright (c) 2014 Lautaro Cozzani <lautaro.cozzani@scytl.com>\n * Copyright (c) 2014 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\n__webpack_require__(/*! ./random */ \"(rsc)/./node_modules/node-forge/lib/random.js\");\n__webpack_require__(/*! ./jsbn */ \"(rsc)/./node_modules/node-forge/lib/jsbn.js\");\nmodule.exports = forge.kem = forge.kem || {};\nvar BigInteger = forge.jsbn.BigInteger;\n/**\n * The API for the RSA Key Encapsulation Mechanism (RSA-KEM) from ISO 18033-2.\n */ forge.kem.rsa = {};\n/**\n * Creates an RSA KEM API object for generating a secret asymmetric key.\n *\n * The symmetric key may be generated via a call to 'encrypt', which will\n * produce a ciphertext to be transmitted to the recipient and a key to be\n * kept secret. The ciphertext is a parameter to be passed to 'decrypt' which\n * will produce the same secret key for the recipient to use to decrypt a\n * message that was encrypted with the secret key.\n *\n * @param kdf the KDF API to use (eg: new forge.kem.kdf1()).\n * @param options the options to use.\n *          [prng] a custom crypto-secure pseudo-random number generator to use,\n *            that must define \"getBytesSync\".\n */ forge.kem.rsa.create = function(kdf, options) {\n    options = options || {};\n    var prng = options.prng || forge.random;\n    var kem = {};\n    /**\n   * Generates a secret key and its encapsulation.\n   *\n   * @param publicKey the RSA public key to encrypt with.\n   * @param keyLength the length, in bytes, of the secret key to generate.\n   *\n   * @return an object with:\n   *   encapsulation: the ciphertext for generating the secret key, as a\n   *     binary-encoded string of bytes.\n   *   key: the secret key to use for encrypting a message.\n   */ kem.encrypt = function(publicKey, keyLength) {\n        // generate a random r where 1 < r < n\n        var byteLength = Math.ceil(publicKey.n.bitLength() / 8);\n        var r;\n        do {\n            r = new BigInteger(forge.util.bytesToHex(prng.getBytesSync(byteLength)), 16).mod(publicKey.n);\n        }while (r.compareTo(BigInteger.ONE) <= 0);\n        // prepend r with zeros\n        r = forge.util.hexToBytes(r.toString(16));\n        var zeros = byteLength - r.length;\n        if (zeros > 0) {\n            r = forge.util.fillString(String.fromCharCode(0), zeros) + r;\n        }\n        // encrypt the random\n        var encapsulation = publicKey.encrypt(r, \"NONE\");\n        // generate the secret key\n        var key = kdf.generate(r, keyLength);\n        return {\n            encapsulation: encapsulation,\n            key: key\n        };\n    };\n    /**\n   * Decrypts an encapsulated secret key.\n   *\n   * @param privateKey the RSA private key to decrypt with.\n   * @param encapsulation the ciphertext for generating the secret key, as\n   *          a binary-encoded string of bytes.\n   * @param keyLength the length, in bytes, of the secret key to generate.\n   *\n   * @return the secret key as a binary-encoded string of bytes.\n   */ kem.decrypt = function(privateKey, encapsulation, keyLength) {\n        // decrypt the encapsulation and generate the secret key\n        var r = privateKey.decrypt(encapsulation, \"NONE\");\n        return kdf.generate(r, keyLength);\n    };\n    return kem;\n};\n// TODO: add forge.kem.kdf.create('KDF1', {md: ..., ...}) API?\n/**\n * Creates a key derivation API object that implements KDF1 per ISO 18033-2.\n *\n * @param md the hash API to use.\n * @param [digestLength] an optional digest length that must be positive and\n *          less than or equal to md.digestLength.\n *\n * @return a KDF1 API object.\n */ forge.kem.kdf1 = function(md, digestLength) {\n    _createKDF(this, md, 0, digestLength || md.digestLength);\n};\n/**\n * Creates a key derivation API object that implements KDF2 per ISO 18033-2.\n *\n * @param md the hash API to use.\n * @param [digestLength] an optional digest length that must be positive and\n *          less than or equal to md.digestLength.\n *\n * @return a KDF2 API object.\n */ forge.kem.kdf2 = function(md, digestLength) {\n    _createKDF(this, md, 1, digestLength || md.digestLength);\n};\n/**\n * Creates a KDF1 or KDF2 API object.\n *\n * @param md the hash API to use.\n * @param counterStart the starting index for the counter.\n * @param digestLength the digest length to use.\n *\n * @return the KDF API object.\n */ function _createKDF(kdf, md, counterStart, digestLength) {\n    /**\n   * Generate a key of the specified length.\n   *\n   * @param x the binary-encoded byte string to generate a key from.\n   * @param length the number of bytes to generate (the size of the key).\n   *\n   * @return the key as a binary-encoded string.\n   */ kdf.generate = function(x, length) {\n        var key = new forge.util.ByteBuffer();\n        // run counter from counterStart to ceil(length / Hash.len)\n        var k = Math.ceil(length / digestLength) + counterStart;\n        var c = new forge.util.ByteBuffer();\n        for(var i = counterStart; i < k; ++i){\n            // I2OSP(i, 4): convert counter to an octet string of 4 octets\n            c.putInt32(i);\n            // digest 'x' and the counter and add the result to the key\n            md.start();\n            md.update(x + c.getBytes());\n            var hash = md.digest();\n            key.putBytes(hash.getBytes(digestLength));\n        }\n        // truncate to the correct key length\n        key.truncate(key.length() - length);\n        return key.getBytes();\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIva2VtLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVJDLE9BQU9DLE9BQU8sR0FBR0gsTUFBTUksR0FBRyxHQUFHSixNQUFNSSxHQUFHLElBQUksQ0FBQztBQUUzQyxJQUFJQyxhQUFhTCxNQUFNTSxJQUFJLENBQUNELFVBQVU7QUFFdEM7O0NBRUMsR0FDREwsTUFBTUksR0FBRyxDQUFDRyxHQUFHLEdBQUcsQ0FBQztBQUVqQjs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ0RQLE1BQU1JLEdBQUcsQ0FBQ0csR0FBRyxDQUFDQyxNQUFNLEdBQUcsU0FBU0MsR0FBRyxFQUFFQyxPQUFPO0lBQzFDQSxVQUFVQSxXQUFXLENBQUM7SUFDdEIsSUFBSUMsT0FBT0QsUUFBUUMsSUFBSSxJQUFJWCxNQUFNWSxNQUFNO0lBRXZDLElBQUlSLE1BQU0sQ0FBQztJQUVYOzs7Ozs7Ozs7O0dBVUMsR0FDREEsSUFBSVMsT0FBTyxHQUFHLFNBQVNDLFNBQVMsRUFBRUMsU0FBUztRQUN6QyxzQ0FBc0M7UUFDdEMsSUFBSUMsYUFBYUMsS0FBS0MsSUFBSSxDQUFDSixVQUFVSyxDQUFDLENBQUNDLFNBQVMsS0FBSztRQUNyRCxJQUFJQztRQUNKLEdBQUc7WUFDREEsSUFBSSxJQUFJaEIsV0FDTkwsTUFBTXNCLElBQUksQ0FBQ0MsVUFBVSxDQUFDWixLQUFLYSxZQUFZLENBQUNSLGNBQ3hDLElBQUlTLEdBQUcsQ0FBQ1gsVUFBVUssQ0FBQztRQUN2QixRQUFRRSxFQUFFSyxTQUFTLENBQUNyQixXQUFXc0IsR0FBRyxLQUFLLEdBQUc7UUFFMUMsdUJBQXVCO1FBQ3ZCTixJQUFJckIsTUFBTXNCLElBQUksQ0FBQ00sVUFBVSxDQUFDUCxFQUFFUSxRQUFRLENBQUM7UUFDckMsSUFBSUMsUUFBUWQsYUFBYUssRUFBRVUsTUFBTTtRQUNqQyxJQUFHRCxRQUFRLEdBQUc7WUFDWlQsSUFBSXJCLE1BQU1zQixJQUFJLENBQUNVLFVBQVUsQ0FBQ0MsT0FBT0MsWUFBWSxDQUFDLElBQUlKLFNBQVNUO1FBQzdEO1FBRUEscUJBQXFCO1FBQ3JCLElBQUljLGdCQUFnQnJCLFVBQVVELE9BQU8sQ0FBQ1EsR0FBRztRQUV6QywwQkFBMEI7UUFDMUIsSUFBSWUsTUFBTTNCLElBQUk0QixRQUFRLENBQUNoQixHQUFHTjtRQUUxQixPQUFPO1lBQUNvQixlQUFlQTtZQUFlQyxLQUFLQTtRQUFHO0lBQ2hEO0lBRUE7Ozs7Ozs7OztHQVNDLEdBQ0RoQyxJQUFJa0MsT0FBTyxHQUFHLFNBQVNDLFVBQVUsRUFBRUosYUFBYSxFQUFFcEIsU0FBUztRQUN6RCx3REFBd0Q7UUFDeEQsSUFBSU0sSUFBSWtCLFdBQVdELE9BQU8sQ0FBQ0gsZUFBZTtRQUMxQyxPQUFPMUIsSUFBSTRCLFFBQVEsQ0FBQ2hCLEdBQUdOO0lBQ3pCO0lBRUEsT0FBT1g7QUFDVDtBQUVBLDhEQUE4RDtBQUU5RDs7Ozs7Ozs7Q0FRQyxHQUNESixNQUFNSSxHQUFHLENBQUNvQyxJQUFJLEdBQUcsU0FBU0MsRUFBRSxFQUFFQyxZQUFZO0lBQ3hDQyxXQUFXLElBQUksRUFBRUYsSUFBSSxHQUFHQyxnQkFBZ0JELEdBQUdDLFlBQVk7QUFDekQ7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNEMUMsTUFBTUksR0FBRyxDQUFDd0MsSUFBSSxHQUFHLFNBQVNILEVBQUUsRUFBRUMsWUFBWTtJQUN4Q0MsV0FBVyxJQUFJLEVBQUVGLElBQUksR0FBR0MsZ0JBQWdCRCxHQUFHQyxZQUFZO0FBQ3pEO0FBRUE7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTQyxXQUFXbEMsR0FBRyxFQUFFZ0MsRUFBRSxFQUFFSSxZQUFZLEVBQUVILFlBQVk7SUFDckQ7Ozs7Ozs7R0FPQyxHQUNEakMsSUFBSTRCLFFBQVEsR0FBRyxTQUFTUyxDQUFDLEVBQUVmLE1BQU07UUFDL0IsSUFBSUssTUFBTSxJQUFJcEMsTUFBTXNCLElBQUksQ0FBQ3lCLFVBQVU7UUFFbkMsMkRBQTJEO1FBQzNELElBQUlDLElBQUkvQixLQUFLQyxJQUFJLENBQUNhLFNBQVNXLGdCQUFnQkc7UUFFM0MsSUFBSUksSUFBSSxJQUFJakQsTUFBTXNCLElBQUksQ0FBQ3lCLFVBQVU7UUFDakMsSUFBSSxJQUFJRyxJQUFJTCxjQUFjSyxJQUFJRixHQUFHLEVBQUVFLEVBQUc7WUFDcEMsOERBQThEO1lBQzlERCxFQUFFRSxRQUFRLENBQUNEO1lBRVgsMkRBQTJEO1lBQzNEVCxHQUFHVyxLQUFLO1lBQ1JYLEdBQUdZLE1BQU0sQ0FBQ1AsSUFBSUcsRUFBRUssUUFBUTtZQUN4QixJQUFJQyxPQUFPZCxHQUFHZSxNQUFNO1lBQ3BCcEIsSUFBSXFCLFFBQVEsQ0FBQ0YsS0FBS0QsUUFBUSxDQUFDWjtRQUM3QjtRQUVBLHFDQUFxQztRQUNyQ04sSUFBSXNCLFFBQVEsQ0FBQ3RCLElBQUlMLE1BQU0sS0FBS0E7UUFDNUIsT0FBT0ssSUFBSWtCLFFBQVE7SUFDckI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9rZW0uanM/MGM3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgUlNBLUtFTS5cbiAqXG4gKiBAYXV0aG9yIExhdXRhcm8gQ296emFuaSBSb2RyaWd1ZXpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IExhdXRhcm8gQ296emFuaSA8bGF1dGFyby5jb3p6YW5pQHNjeXRsLmNvbT5cbiAqIENvcHlyaWdodCAoYykgMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcbnJlcXVpcmUoJy4vcmFuZG9tJyk7XG5yZXF1aXJlKCcuL2pzYm4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5rZW0gPSBmb3JnZS5rZW0gfHwge307XG5cbnZhciBCaWdJbnRlZ2VyID0gZm9yZ2UuanNibi5CaWdJbnRlZ2VyO1xuXG4vKipcbiAqIFRoZSBBUEkgZm9yIHRoZSBSU0EgS2V5IEVuY2Fwc3VsYXRpb24gTWVjaGFuaXNtIChSU0EtS0VNKSBmcm9tIElTTyAxODAzMy0yLlxuICovXG5mb3JnZS5rZW0ucnNhID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBSU0EgS0VNIEFQSSBvYmplY3QgZm9yIGdlbmVyYXRpbmcgYSBzZWNyZXQgYXN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIHN5bW1ldHJpYyBrZXkgbWF5IGJlIGdlbmVyYXRlZCB2aWEgYSBjYWxsIHRvICdlbmNyeXB0Jywgd2hpY2ggd2lsbFxuICogcHJvZHVjZSBhIGNpcGhlcnRleHQgdG8gYmUgdHJhbnNtaXR0ZWQgdG8gdGhlIHJlY2lwaWVudCBhbmQgYSBrZXkgdG8gYmVcbiAqIGtlcHQgc2VjcmV0LiBUaGUgY2lwaGVydGV4dCBpcyBhIHBhcmFtZXRlciB0byBiZSBwYXNzZWQgdG8gJ2RlY3J5cHQnIHdoaWNoXG4gKiB3aWxsIHByb2R1Y2UgdGhlIHNhbWUgc2VjcmV0IGtleSBmb3IgdGhlIHJlY2lwaWVudCB0byB1c2UgdG8gZGVjcnlwdCBhXG4gKiBtZXNzYWdlIHRoYXQgd2FzIGVuY3J5cHRlZCB3aXRoIHRoZSBzZWNyZXQga2V5LlxuICpcbiAqIEBwYXJhbSBrZGYgdGhlIEtERiBBUEkgdG8gdXNlIChlZzogbmV3IGZvcmdlLmtlbS5rZGYxKCkpLlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAgW3BybmddIGEgY3VzdG9tIGNyeXB0by1zZWN1cmUgcHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZSxcbiAqICAgICAgICAgICAgdGhhdCBtdXN0IGRlZmluZSBcImdldEJ5dGVzU3luY1wiLlxuICovXG5mb3JnZS5rZW0ucnNhLmNyZWF0ZSA9IGZ1bmN0aW9uKGtkZiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHBybmcgPSBvcHRpb25zLnBybmcgfHwgZm9yZ2UucmFuZG9tO1xuXG4gIHZhciBrZW0gPSB7fTtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgc2VjcmV0IGtleSBhbmQgaXRzIGVuY2Fwc3VsYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBwdWJsaWNLZXkgdGhlIFJTQSBwdWJsaWMga2V5IHRvIGVuY3J5cHQgd2l0aC5cbiAgICogQHBhcmFtIGtleUxlbmd0aCB0aGUgbGVuZ3RoLCBpbiBieXRlcywgb2YgdGhlIHNlY3JldCBrZXkgdG8gZ2VuZXJhdGUuXG4gICAqXG4gICAqIEByZXR1cm4gYW4gb2JqZWN0IHdpdGg6XG4gICAqICAgZW5jYXBzdWxhdGlvbjogdGhlIGNpcGhlcnRleHQgZm9yIGdlbmVyYXRpbmcgdGhlIHNlY3JldCBrZXksIGFzIGFcbiAgICogICAgIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAgICogICBrZXk6IHRoZSBzZWNyZXQga2V5IHRvIHVzZSBmb3IgZW5jcnlwdGluZyBhIG1lc3NhZ2UuXG4gICAqL1xuICBrZW0uZW5jcnlwdCA9IGZ1bmN0aW9uKHB1YmxpY0tleSwga2V5TGVuZ3RoKSB7XG4gICAgLy8gZ2VuZXJhdGUgYSByYW5kb20gciB3aGVyZSAxIDwgciA8IG5cbiAgICB2YXIgYnl0ZUxlbmd0aCA9IE1hdGguY2VpbChwdWJsaWNLZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuICAgIHZhciByO1xuICAgIGRvIHtcbiAgICAgIHIgPSBuZXcgQmlnSW50ZWdlcihcbiAgICAgICAgZm9yZ2UudXRpbC5ieXRlc1RvSGV4KHBybmcuZ2V0Qnl0ZXNTeW5jKGJ5dGVMZW5ndGgpKSxcbiAgICAgICAgMTYpLm1vZChwdWJsaWNLZXkubik7XG4gICAgfSB3aGlsZShyLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPD0gMCk7XG5cbiAgICAvLyBwcmVwZW5kIHIgd2l0aCB6ZXJvc1xuICAgIHIgPSBmb3JnZS51dGlsLmhleFRvQnl0ZXMoci50b1N0cmluZygxNikpO1xuICAgIHZhciB6ZXJvcyA9IGJ5dGVMZW5ndGggLSByLmxlbmd0aDtcbiAgICBpZih6ZXJvcyA+IDApIHtcbiAgICAgIHIgPSBmb3JnZS51dGlsLmZpbGxTdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZSgwKSwgemVyb3MpICsgcjtcbiAgICB9XG5cbiAgICAvLyBlbmNyeXB0IHRoZSByYW5kb21cbiAgICB2YXIgZW5jYXBzdWxhdGlvbiA9IHB1YmxpY0tleS5lbmNyeXB0KHIsICdOT05FJyk7XG5cbiAgICAvLyBnZW5lcmF0ZSB0aGUgc2VjcmV0IGtleVxuICAgIHZhciBrZXkgPSBrZGYuZ2VuZXJhdGUociwga2V5TGVuZ3RoKTtcblxuICAgIHJldHVybiB7ZW5jYXBzdWxhdGlvbjogZW5jYXBzdWxhdGlvbiwga2V5OiBrZXl9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNyeXB0cyBhbiBlbmNhcHN1bGF0ZWQgc2VjcmV0IGtleS5cbiAgICpcbiAgICogQHBhcmFtIHByaXZhdGVLZXkgdGhlIFJTQSBwcml2YXRlIGtleSB0byBkZWNyeXB0IHdpdGguXG4gICAqIEBwYXJhbSBlbmNhcHN1bGF0aW9uIHRoZSBjaXBoZXJ0ZXh0IGZvciBnZW5lcmF0aW5nIHRoZSBzZWNyZXQga2V5LCBhc1xuICAgKiAgICAgICAgICBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAgICogQHBhcmFtIGtleUxlbmd0aCB0aGUgbGVuZ3RoLCBpbiBieXRlcywgb2YgdGhlIHNlY3JldCBrZXkgdG8gZ2VuZXJhdGUuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHNlY3JldCBrZXkgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gICAqL1xuICBrZW0uZGVjcnlwdCA9IGZ1bmN0aW9uKHByaXZhdGVLZXksIGVuY2Fwc3VsYXRpb24sIGtleUxlbmd0aCkge1xuICAgIC8vIGRlY3J5cHQgdGhlIGVuY2Fwc3VsYXRpb24gYW5kIGdlbmVyYXRlIHRoZSBzZWNyZXQga2V5XG4gICAgdmFyIHIgPSBwcml2YXRlS2V5LmRlY3J5cHQoZW5jYXBzdWxhdGlvbiwgJ05PTkUnKTtcbiAgICByZXR1cm4ga2RmLmdlbmVyYXRlKHIsIGtleUxlbmd0aCk7XG4gIH07XG5cbiAgcmV0dXJuIGtlbTtcbn07XG5cbi8vIFRPRE86IGFkZCBmb3JnZS5rZW0ua2RmLmNyZWF0ZSgnS0RGMScsIHttZDogLi4uLCAuLi59KSBBUEk/XG5cbi8qKlxuICogQ3JlYXRlcyBhIGtleSBkZXJpdmF0aW9uIEFQSSBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIEtERjEgcGVyIElTTyAxODAzMy0yLlxuICpcbiAqIEBwYXJhbSBtZCB0aGUgaGFzaCBBUEkgdG8gdXNlLlxuICogQHBhcmFtIFtkaWdlc3RMZW5ndGhdIGFuIG9wdGlvbmFsIGRpZ2VzdCBsZW5ndGggdGhhdCBtdXN0IGJlIHBvc2l0aXZlIGFuZFxuICogICAgICAgICAgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIG1kLmRpZ2VzdExlbmd0aC5cbiAqXG4gKiBAcmV0dXJuIGEgS0RGMSBBUEkgb2JqZWN0LlxuICovXG5mb3JnZS5rZW0ua2RmMSA9IGZ1bmN0aW9uKG1kLCBkaWdlc3RMZW5ndGgpIHtcbiAgX2NyZWF0ZUtERih0aGlzLCBtZCwgMCwgZGlnZXN0TGVuZ3RoIHx8IG1kLmRpZ2VzdExlbmd0aCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBrZXkgZGVyaXZhdGlvbiBBUEkgb2JqZWN0IHRoYXQgaW1wbGVtZW50cyBLREYyIHBlciBJU08gMTgwMzMtMi5cbiAqXG4gKiBAcGFyYW0gbWQgdGhlIGhhc2ggQVBJIHRvIHVzZS5cbiAqIEBwYXJhbSBbZGlnZXN0TGVuZ3RoXSBhbiBvcHRpb25hbCBkaWdlc3QgbGVuZ3RoIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBhbmRcbiAqICAgICAgICAgIGxlc3MgdGhhbiBvciBlcXVhbCB0byBtZC5kaWdlc3RMZW5ndGguXG4gKlxuICogQHJldHVybiBhIEtERjIgQVBJIG9iamVjdC5cbiAqL1xuZm9yZ2Uua2VtLmtkZjIgPSBmdW5jdGlvbihtZCwgZGlnZXN0TGVuZ3RoKSB7XG4gIF9jcmVhdGVLREYodGhpcywgbWQsIDEsIGRpZ2VzdExlbmd0aCB8fCBtZC5kaWdlc3RMZW5ndGgpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgS0RGMSBvciBLREYyIEFQSSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG1kIHRoZSBoYXNoIEFQSSB0byB1c2UuXG4gKiBAcGFyYW0gY291bnRlclN0YXJ0IHRoZSBzdGFydGluZyBpbmRleCBmb3IgdGhlIGNvdW50ZXIuXG4gKiBAcGFyYW0gZGlnZXN0TGVuZ3RoIHRoZSBkaWdlc3QgbGVuZ3RoIHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBLREYgQVBJIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZUtERihrZGYsIG1kLCBjb3VudGVyU3RhcnQsIGRpZ2VzdExlbmd0aCkge1xuICAvKipcbiAgICogR2VuZXJhdGUgYSBrZXkgb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gICAqXG4gICAqIEBwYXJhbSB4IHRoZSBiaW5hcnktZW5jb2RlZCBieXRlIHN0cmluZyB0byBnZW5lcmF0ZSBhIGtleSBmcm9tLlxuICAgKiBAcGFyYW0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGUgKHRoZSBzaXplIG9mIHRoZSBrZXkpLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBrZXkgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcuXG4gICAqL1xuICBrZGYuZ2VuZXJhdGUgPSBmdW5jdGlvbih4LCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuXG4gICAgLy8gcnVuIGNvdW50ZXIgZnJvbSBjb3VudGVyU3RhcnQgdG8gY2VpbChsZW5ndGggLyBIYXNoLmxlbilcbiAgICB2YXIgayA9IE1hdGguY2VpbChsZW5ndGggLyBkaWdlc3RMZW5ndGgpICsgY291bnRlclN0YXJ0O1xuXG4gICAgdmFyIGMgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgZm9yKHZhciBpID0gY291bnRlclN0YXJ0OyBpIDwgazsgKytpKSB7XG4gICAgICAvLyBJMk9TUChpLCA0KTogY29udmVydCBjb3VudGVyIHRvIGFuIG9jdGV0IHN0cmluZyBvZiA0IG9jdGV0c1xuICAgICAgYy5wdXRJbnQzMihpKTtcblxuICAgICAgLy8gZGlnZXN0ICd4JyBhbmQgdGhlIGNvdW50ZXIgYW5kIGFkZCB0aGUgcmVzdWx0IHRvIHRoZSBrZXlcbiAgICAgIG1kLnN0YXJ0KCk7XG4gICAgICBtZC51cGRhdGUoeCArIGMuZ2V0Qnl0ZXMoKSk7XG4gICAgICB2YXIgaGFzaCA9IG1kLmRpZ2VzdCgpO1xuICAgICAga2V5LnB1dEJ5dGVzKGhhc2guZ2V0Qnl0ZXMoZGlnZXN0TGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLy8gdHJ1bmNhdGUgdG8gdGhlIGNvcnJlY3Qga2V5IGxlbmd0aFxuICAgIGtleS50cnVuY2F0ZShrZXkubGVuZ3RoKCkgLSBsZW5ndGgpO1xuICAgIHJldHVybiBrZXkuZ2V0Qnl0ZXMoKTtcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwia2VtIiwiQmlnSW50ZWdlciIsImpzYm4iLCJyc2EiLCJjcmVhdGUiLCJrZGYiLCJvcHRpb25zIiwicHJuZyIsInJhbmRvbSIsImVuY3J5cHQiLCJwdWJsaWNLZXkiLCJrZXlMZW5ndGgiLCJieXRlTGVuZ3RoIiwiTWF0aCIsImNlaWwiLCJuIiwiYml0TGVuZ3RoIiwiciIsInV0aWwiLCJieXRlc1RvSGV4IiwiZ2V0Qnl0ZXNTeW5jIiwibW9kIiwiY29tcGFyZVRvIiwiT05FIiwiaGV4VG9CeXRlcyIsInRvU3RyaW5nIiwiemVyb3MiLCJsZW5ndGgiLCJmaWxsU3RyaW5nIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZW5jYXBzdWxhdGlvbiIsImtleSIsImdlbmVyYXRlIiwiZGVjcnlwdCIsInByaXZhdGVLZXkiLCJrZGYxIiwibWQiLCJkaWdlc3RMZW5ndGgiLCJfY3JlYXRlS0RGIiwia2RmMiIsImNvdW50ZXJTdGFydCIsIngiLCJCeXRlQnVmZmVyIiwiayIsImMiLCJpIiwicHV0SW50MzIiLCJzdGFydCIsInVwZGF0ZSIsImdldEJ5dGVzIiwiaGFzaCIsImRpZ2VzdCIsInB1dEJ5dGVzIiwidHJ1bmNhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/kem.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/log.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/log.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Cross-browser support for logging in a web application.\n *\n * @author David I. Lehn <dlehn@digitalbazaar.com>\n *\n * Copyright (c) 2008-2013 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\n/* LOG API */ module.exports = forge.log = forge.log || {};\n/**\n * Application logging system.\n *\n * Each logger level available as it's own function of the form:\n *   forge.log.level(category, args...)\n * The category is an arbitrary string, and the args are the same as\n * Firebug's console.log API. By default the call will be output as:\n *   'LEVEL [category] <args[0]>, args[1], ...'\n * This enables proper % formatting via the first argument.\n * Each category is enabled by default but can be enabled or disabled with\n * the setCategoryEnabled() function.\n */ // list of known levels\nforge.log.levels = [\n    \"none\",\n    \"error\",\n    \"warning\",\n    \"info\",\n    \"debug\",\n    \"verbose\",\n    \"max\"\n];\n// info on the levels indexed by name:\n//   index: level index\n//   name: uppercased display name\nvar sLevelInfo = {};\n// list of loggers\nvar sLoggers = [];\n/**\n * Standard console logger. If no console support is enabled this will\n * remain null. Check before using.\n */ var sConsoleLogger = null;\n// logger flags\n/**\n * Lock the level at the current value. Used in cases where user config may\n * set the level such that only critical messages are seen but more verbose\n * messages are needed for debugging or other purposes.\n */ forge.log.LEVEL_LOCKED = 1 << 1;\n/**\n * Always call log function. By default, the logging system will check the\n * message level against logger.level before calling the log function. This\n * flag allows the function to do its own check.\n */ forge.log.NO_LEVEL_CHECK = 1 << 2;\n/**\n * Perform message interpolation with the passed arguments. \"%\" style\n * fields in log messages will be replaced by arguments as needed. Some\n * loggers, such as Firebug, may do this automatically. The original log\n * message will be available as 'message' and the interpolated version will\n * be available as 'fullMessage'.\n */ forge.log.INTERPOLATE = 1 << 3;\n// setup each log level\nfor(var i = 0; i < forge.log.levels.length; ++i){\n    var level = forge.log.levels[i];\n    sLevelInfo[level] = {\n        index: i,\n        name: level.toUpperCase()\n    };\n}\n/**\n * Message logger. Will dispatch a message to registered loggers as needed.\n *\n * @param message message object\n */ forge.log.logMessage = function(message) {\n    var messageLevelIndex = sLevelInfo[message.level].index;\n    for(var i = 0; i < sLoggers.length; ++i){\n        var logger = sLoggers[i];\n        if (logger.flags & forge.log.NO_LEVEL_CHECK) {\n            logger.f(message);\n        } else {\n            // get logger level\n            var loggerLevelIndex = sLevelInfo[logger.level].index;\n            // check level\n            if (messageLevelIndex <= loggerLevelIndex) {\n                // message critical enough, call logger\n                logger.f(logger, message);\n            }\n        }\n    }\n};\n/**\n * Sets the 'standard' key on a message object to:\n * \"LEVEL [category] \" + message\n *\n * @param message a message log object\n */ forge.log.prepareStandard = function(message) {\n    if (!(\"standard\" in message)) {\n        message.standard = sLevelInfo[message.level].name + //' ' + +message.timestamp +\n        \" [\" + message.category + \"] \" + message.message;\n    }\n};\n/**\n * Sets the 'full' key on a message object to the original message\n * interpolated via % formatting with the message arguments.\n *\n * @param message a message log object.\n */ forge.log.prepareFull = function(message) {\n    if (!(\"full\" in message)) {\n        // copy args and insert message at the front\n        var args = [\n            message.message\n        ];\n        args = args.concat([] || 0);\n        // format the message\n        message.full = forge.util.format.apply(this, args);\n    }\n};\n/**\n * Applies both preparseStandard() and prepareFull() to a message object and\n * store result in 'standardFull'.\n *\n * @param message a message log object.\n */ forge.log.prepareStandardFull = function(message) {\n    if (!(\"standardFull\" in message)) {\n        // FIXME implement 'standardFull' logging\n        forge.log.prepareStandard(message);\n        message.standardFull = message.standard;\n    }\n};\n// create log level functions\nif (true) {\n    // levels for which we want functions\n    var levels = [\n        \"error\",\n        \"warning\",\n        \"info\",\n        \"debug\",\n        \"verbose\"\n    ];\n    for(var i = 0; i < levels.length; ++i){\n        // wrap in a function to ensure proper level var is passed\n        (function(level) {\n            // create function for this level\n            forge.log[level] = function(category, message /*, args...*/ ) {\n                // convert arguments to real array, remove category and message\n                var args = Array.prototype.slice.call(arguments).slice(2);\n                // create message object\n                // Note: interpolation and standard formatting is done lazily\n                var msg = {\n                    timestamp: new Date(),\n                    level: level,\n                    category: category,\n                    message: message,\n                    \"arguments\": args\n                };\n                // process this message\n                forge.log.logMessage(msg);\n            };\n        })(levels[i]);\n    }\n}\n/**\n * Creates a new logger with specified custom logging function.\n *\n * The logging function has a signature of:\n *   function(logger, message)\n * logger: current logger\n * message: object:\n *   level: level id\n *   category: category\n *   message: string message\n *   arguments: Array of extra arguments\n *   fullMessage: interpolated message and arguments if INTERPOLATE flag set\n *\n * @param logFunction a logging function which takes a log message object\n *          as a parameter.\n *\n * @return a logger object.\n */ forge.log.makeLogger = function(logFunction) {\n    var logger = {\n        flags: 0,\n        f: logFunction\n    };\n    forge.log.setLevel(logger, \"none\");\n    return logger;\n};\n/**\n * Sets the current log level on a logger.\n *\n * @param logger the target logger.\n * @param level the new maximum log level as a string.\n *\n * @return true if set, false if not.\n */ forge.log.setLevel = function(logger, level) {\n    var rval = false;\n    if (logger && !(logger.flags & forge.log.LEVEL_LOCKED)) {\n        for(var i = 0; i < forge.log.levels.length; ++i){\n            var aValidLevel = forge.log.levels[i];\n            if (level == aValidLevel) {\n                // set level\n                logger.level = level;\n                rval = true;\n                break;\n            }\n        }\n    }\n    return rval;\n};\n/**\n * Locks the log level at its current value.\n *\n * @param logger the target logger.\n * @param lock boolean lock value, default to true.\n */ forge.log.lock = function(logger, lock) {\n    if (typeof lock === \"undefined\" || lock) {\n        logger.flags |= forge.log.LEVEL_LOCKED;\n    } else {\n        logger.flags &= ~forge.log.LEVEL_LOCKED;\n    }\n};\n/**\n * Adds a logger.\n *\n * @param logger the logger object.\n */ forge.log.addLogger = function(logger) {\n    sLoggers.push(logger);\n};\n// setup the console logger if possible, else create fake console.log\nif (typeof console !== \"undefined\" && \"log\" in console) {\n    var logger;\n    if (console.error && console.warn && console.info && console.debug) {\n        // looks like Firebug-style logging is available\n        // level handlers map\n        var levelHandlers = {\n            error: console.error,\n            warning: console.warn,\n            info: console.info,\n            debug: console.debug,\n            verbose: console.debug\n        };\n        var f = function(logger, message) {\n            forge.log.prepareStandard(message);\n            var handler = levelHandlers[message.level];\n            // prepend standard message and concat args\n            var args = [\n                message.standard\n            ];\n            args = args.concat(message[\"arguments\"].slice());\n            // apply to low-level console function\n            handler.apply(console, args);\n        };\n        logger = forge.log.makeLogger(f);\n    } else {\n        // only appear to have basic console.log\n        var f = function(logger, message) {\n            forge.log.prepareStandardFull(message);\n            console.log(message.standardFull);\n        };\n        logger = forge.log.makeLogger(f);\n    }\n    forge.log.setLevel(logger, \"debug\");\n    forge.log.addLogger(logger);\n    sConsoleLogger = logger;\n} else {\n    // define fake console.log to avoid potential script errors on\n    // browsers that do not have console logging\n    console = {\n        log: function() {}\n    };\n}\n/*\n * Check for logging control query vars in current URL.\n *\n * console.level=<level-name>\n * Set's the console log level by name.  Useful to override defaults and\n * allow more verbose logging before a user config is loaded.\n *\n * console.lock=<true|false>\n * Lock the console log level at whatever level it is set at.  This is run\n * after console.level is processed.  Useful to force a level of verbosity\n * that could otherwise be limited by a user config.\n */ if (sConsoleLogger !== null && \"undefined\" !== \"undefined\" && 0) { var lock, query; }\n// provide public access to console logger\nforge.log.consoleLogger = sConsoleLogger;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvbG9nLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Q0FNQztBQUNELElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCQSxtQkFBT0EsQ0FBQztBQUVSLFdBQVcsR0FDWEMsT0FBT0MsT0FBTyxHQUFHSCxNQUFNSSxHQUFHLEdBQUdKLE1BQU1JLEdBQUcsSUFBSSxDQUFDO0FBRTNDOzs7Ozs7Ozs7OztDQVdDLEdBQ0QsdUJBQXVCO0FBQ3ZCSixNQUFNSSxHQUFHLENBQUNDLE1BQU0sR0FBRztJQUNqQjtJQUFRO0lBQVM7SUFBVztJQUFRO0lBQVM7SUFBVztDQUFNO0FBQ2hFLHNDQUFzQztBQUN0Qyx1QkFBdUI7QUFDdkIsa0NBQWtDO0FBQ2xDLElBQUlDLGFBQWEsQ0FBQztBQUNsQixrQkFBa0I7QUFDbEIsSUFBSUMsV0FBVyxFQUFFO0FBQ2pCOzs7Q0FHQyxHQUNELElBQUlDLGlCQUFpQjtBQUVyQixlQUFlO0FBQ2Y7Ozs7Q0FJQyxHQUNEUixNQUFNSSxHQUFHLENBQUNLLFlBQVksR0FBSSxLQUFLO0FBQy9COzs7O0NBSUMsR0FDRFQsTUFBTUksR0FBRyxDQUFDTSxjQUFjLEdBQUksS0FBSztBQUNqQzs7Ozs7O0NBTUMsR0FDRFYsTUFBTUksR0FBRyxDQUFDTyxXQUFXLEdBQUksS0FBSztBQUU5Qix1QkFBdUI7QUFDdkIsSUFBSSxJQUFJQyxJQUFJLEdBQUdBLElBQUlaLE1BQU1JLEdBQUcsQ0FBQ0MsTUFBTSxDQUFDUSxNQUFNLEVBQUUsRUFBRUQsRUFBRztJQUMvQyxJQUFJRSxRQUFRZCxNQUFNSSxHQUFHLENBQUNDLE1BQU0sQ0FBQ08sRUFBRTtJQUMvQk4sVUFBVSxDQUFDUSxNQUFNLEdBQUc7UUFDbEJDLE9BQU9IO1FBQ1BJLE1BQU1GLE1BQU1HLFdBQVc7SUFDekI7QUFDRjtBQUVBOzs7O0NBSUMsR0FDRGpCLE1BQU1JLEdBQUcsQ0FBQ2MsVUFBVSxHQUFHLFNBQVNDLE9BQU87SUFDckMs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QjtBQUNGO0FBRUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxJQUFHSSxtQkFBbUIsUUFDcEIsZ0JBQWtCLGVBQWVzRCxDQUFlLEVBQ2hELG9CQWNEO0FBRUQsMENBQTBDO0FBQzFDOUQsTUFBTUksR0FBRyxDQUFDa0UsYUFBYSxHQUFHOUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvbG9nLmpzPzI2NzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDcm9zcy1icm93c2VyIHN1cHBvcnQgZm9yIGxvZ2dpbmcgaW4gYSB3ZWIgYXBwbGljYXRpb24uXG4gKlxuICogQGF1dGhvciBEYXZpZCBJLiBMZWhuIDxkbGVobkBkaWdpdGFsYmF6YWFyLmNvbT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDgtMjAxMyBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxuLyogTE9HIEFQSSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5sb2cgPSBmb3JnZS5sb2cgfHwge307XG5cbi8qKlxuICogQXBwbGljYXRpb24gbG9nZ2luZyBzeXN0ZW0uXG4gKlxuICogRWFjaCBsb2dnZXIgbGV2ZWwgYXZhaWxhYmxlIGFzIGl0J3Mgb3duIGZ1bmN0aW9uIG9mIHRoZSBmb3JtOlxuICogICBmb3JnZS5sb2cubGV2ZWwoY2F0ZWdvcnksIGFyZ3MuLi4pXG4gKiBUaGUgY2F0ZWdvcnkgaXMgYW4gYXJiaXRyYXJ5IHN0cmluZywgYW5kIHRoZSBhcmdzIGFyZSB0aGUgc2FtZSBhc1xuICogRmlyZWJ1ZydzIGNvbnNvbGUubG9nIEFQSS4gQnkgZGVmYXVsdCB0aGUgY2FsbCB3aWxsIGJlIG91dHB1dCBhczpcbiAqICAgJ0xFVkVMIFtjYXRlZ29yeV0gPGFyZ3NbMF0+LCBhcmdzWzFdLCAuLi4nXG4gKiBUaGlzIGVuYWJsZXMgcHJvcGVyICUgZm9ybWF0dGluZyB2aWEgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICogRWFjaCBjYXRlZ29yeSBpcyBlbmFibGVkIGJ5IGRlZmF1bHQgYnV0IGNhbiBiZSBlbmFibGVkIG9yIGRpc2FibGVkIHdpdGhcbiAqIHRoZSBzZXRDYXRlZ29yeUVuYWJsZWQoKSBmdW5jdGlvbi5cbiAqL1xuLy8gbGlzdCBvZiBrbm93biBsZXZlbHNcbmZvcmdlLmxvZy5sZXZlbHMgPSBbXG4gICdub25lJywgJ2Vycm9yJywgJ3dhcm5pbmcnLCAnaW5mbycsICdkZWJ1ZycsICd2ZXJib3NlJywgJ21heCddO1xuLy8gaW5mbyBvbiB0aGUgbGV2ZWxzIGluZGV4ZWQgYnkgbmFtZTpcbi8vICAgaW5kZXg6IGxldmVsIGluZGV4XG4vLyAgIG5hbWU6IHVwcGVyY2FzZWQgZGlzcGxheSBuYW1lXG52YXIgc0xldmVsSW5mbyA9IHt9O1xuLy8gbGlzdCBvZiBsb2dnZXJzXG52YXIgc0xvZ2dlcnMgPSBbXTtcbi8qKlxuICogU3RhbmRhcmQgY29uc29sZSBsb2dnZXIuIElmIG5vIGNvbnNvbGUgc3VwcG9ydCBpcyBlbmFibGVkIHRoaXMgd2lsbFxuICogcmVtYWluIG51bGwuIENoZWNrIGJlZm9yZSB1c2luZy5cbiAqL1xudmFyIHNDb25zb2xlTG9nZ2VyID0gbnVsbDtcblxuLy8gbG9nZ2VyIGZsYWdzXG4vKipcbiAqIExvY2sgdGhlIGxldmVsIGF0IHRoZSBjdXJyZW50IHZhbHVlLiBVc2VkIGluIGNhc2VzIHdoZXJlIHVzZXIgY29uZmlnIG1heVxuICogc2V0IHRoZSBsZXZlbCBzdWNoIHRoYXQgb25seSBjcml0aWNhbCBtZXNzYWdlcyBhcmUgc2VlbiBidXQgbW9yZSB2ZXJib3NlXG4gKiBtZXNzYWdlcyBhcmUgbmVlZGVkIGZvciBkZWJ1Z2dpbmcgb3Igb3RoZXIgcHVycG9zZXMuXG4gKi9cbmZvcmdlLmxvZy5MRVZFTF9MT0NLRUQgPSAoMSA8PCAxKTtcbi8qKlxuICogQWx3YXlzIGNhbGwgbG9nIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgbG9nZ2luZyBzeXN0ZW0gd2lsbCBjaGVjayB0aGVcbiAqIG1lc3NhZ2UgbGV2ZWwgYWdhaW5zdCBsb2dnZXIubGV2ZWwgYmVmb3JlIGNhbGxpbmcgdGhlIGxvZyBmdW5jdGlvbi4gVGhpc1xuICogZmxhZyBhbGxvd3MgdGhlIGZ1bmN0aW9uIHRvIGRvIGl0cyBvd24gY2hlY2suXG4gKi9cbmZvcmdlLmxvZy5OT19MRVZFTF9DSEVDSyA9ICgxIDw8IDIpO1xuLyoqXG4gKiBQZXJmb3JtIG1lc3NhZ2UgaW50ZXJwb2xhdGlvbiB3aXRoIHRoZSBwYXNzZWQgYXJndW1lbnRzLiBcIiVcIiBzdHlsZVxuICogZmllbGRzIGluIGxvZyBtZXNzYWdlcyB3aWxsIGJlIHJlcGxhY2VkIGJ5IGFyZ3VtZW50cyBhcyBuZWVkZWQuIFNvbWVcbiAqIGxvZ2dlcnMsIHN1Y2ggYXMgRmlyZWJ1ZywgbWF5IGRvIHRoaXMgYXV0b21hdGljYWxseS4gVGhlIG9yaWdpbmFsIGxvZ1xuICogbWVzc2FnZSB3aWxsIGJlIGF2YWlsYWJsZSBhcyAnbWVzc2FnZScgYW5kIHRoZSBpbnRlcnBvbGF0ZWQgdmVyc2lvbiB3aWxsXG4gKiBiZSBhdmFpbGFibGUgYXMgJ2Z1bGxNZXNzYWdlJy5cbiAqL1xuZm9yZ2UubG9nLklOVEVSUE9MQVRFID0gKDEgPDwgMyk7XG5cbi8vIHNldHVwIGVhY2ggbG9nIGxldmVsXG5mb3IodmFyIGkgPSAwOyBpIDwgZm9yZ2UubG9nLmxldmVscy5sZW5ndGg7ICsraSkge1xuICB2YXIgbGV2ZWwgPSBmb3JnZS5sb2cubGV2ZWxzW2ldO1xuICBzTGV2ZWxJbmZvW2xldmVsXSA9IHtcbiAgICBpbmRleDogaSxcbiAgICBuYW1lOiBsZXZlbC50b1VwcGVyQ2FzZSgpXG4gIH07XG59XG5cbi8qKlxuICogTWVzc2FnZSBsb2dnZXIuIFdpbGwgZGlzcGF0Y2ggYSBtZXNzYWdlIHRvIHJlZ2lzdGVyZWQgbG9nZ2VycyBhcyBuZWVkZWQuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgbWVzc2FnZSBvYmplY3RcbiAqL1xuZm9yZ2UubG9nLmxvZ01lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIHZhciBtZXNzYWdlTGV2ZWxJbmRleCA9IHNMZXZlbEluZm9bbWVzc2FnZS5sZXZlbF0uaW5kZXg7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzTG9nZ2Vycy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBsb2dnZXIgPSBzTG9nZ2Vyc1tpXTtcbiAgICBpZihsb2dnZXIuZmxhZ3MgJiBmb3JnZS5sb2cuTk9fTEVWRUxfQ0hFQ0spIHtcbiAgICAgIGxvZ2dlci5mKG1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBnZXQgbG9nZ2VyIGxldmVsXG4gICAgICB2YXIgbG9nZ2VyTGV2ZWxJbmRleCA9IHNMZXZlbEluZm9bbG9nZ2VyLmxldmVsXS5pbmRleDtcbiAgICAgIC8vIGNoZWNrIGxldmVsXG4gICAgICBpZihtZXNzYWdlTGV2ZWxJbmRleCA8PSBsb2dnZXJMZXZlbEluZGV4KSB7XG4gICAgICAgIC8vIG1lc3NhZ2UgY3JpdGljYWwgZW5vdWdoLCBjYWxsIGxvZ2dlclxuICAgICAgICBsb2dnZXIuZihsb2dnZXIsIG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTZXRzIHRoZSAnc3RhbmRhcmQnIGtleSBvbiBhIG1lc3NhZ2Ugb2JqZWN0IHRvOlxuICogXCJMRVZFTCBbY2F0ZWdvcnldIFwiICsgbWVzc2FnZVxuICpcbiAqIEBwYXJhbSBtZXNzYWdlIGEgbWVzc2FnZSBsb2cgb2JqZWN0XG4gKi9cbmZvcmdlLmxvZy5wcmVwYXJlU3RhbmRhcmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGlmKCEoJ3N0YW5kYXJkJyBpbiBtZXNzYWdlKSkge1xuICAgIG1lc3NhZ2Uuc3RhbmRhcmQgPVxuICAgICAgc0xldmVsSW5mb1ttZXNzYWdlLmxldmVsXS5uYW1lICtcbiAgICAgIC8vJyAnICsgK21lc3NhZ2UudGltZXN0YW1wICtcbiAgICAgICcgWycgKyBtZXNzYWdlLmNhdGVnb3J5ICsgJ10gJyArXG4gICAgICBtZXNzYWdlLm1lc3NhZ2U7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0cyB0aGUgJ2Z1bGwnIGtleSBvbiBhIG1lc3NhZ2Ugb2JqZWN0IHRvIHRoZSBvcmlnaW5hbCBtZXNzYWdlXG4gKiBpbnRlcnBvbGF0ZWQgdmlhICUgZm9ybWF0dGluZyB3aXRoIHRoZSBtZXNzYWdlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSBhIG1lc3NhZ2UgbG9nIG9iamVjdC5cbiAqL1xuZm9yZ2UubG9nLnByZXBhcmVGdWxsID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICBpZighKCdmdWxsJyBpbiBtZXNzYWdlKSkge1xuICAgIC8vIGNvcHkgYXJncyBhbmQgaW5zZXJ0IG1lc3NhZ2UgYXQgdGhlIGZyb250XG4gICAgdmFyIGFyZ3MgPSBbbWVzc2FnZS5tZXNzYWdlXTtcbiAgICBhcmdzID0gYXJncy5jb25jYXQoW10gfHwgbWVzc2FnZVsnYXJndW1lbnRzJ10pO1xuICAgIC8vIGZvcm1hdCB0aGUgbWVzc2FnZVxuICAgIG1lc3NhZ2UuZnVsbCA9IGZvcmdlLnV0aWwuZm9ybWF0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgYm90aCBwcmVwYXJzZVN0YW5kYXJkKCkgYW5kIHByZXBhcmVGdWxsKCkgdG8gYSBtZXNzYWdlIG9iamVjdCBhbmRcbiAqIHN0b3JlIHJlc3VsdCBpbiAnc3RhbmRhcmRGdWxsJy5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSBhIG1lc3NhZ2UgbG9nIG9iamVjdC5cbiAqL1xuZm9yZ2UubG9nLnByZXBhcmVTdGFuZGFyZEZ1bGwgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGlmKCEoJ3N0YW5kYXJkRnVsbCcgaW4gbWVzc2FnZSkpIHtcbiAgICAvLyBGSVhNRSBpbXBsZW1lbnQgJ3N0YW5kYXJkRnVsbCcgbG9nZ2luZ1xuICAgIGZvcmdlLmxvZy5wcmVwYXJlU3RhbmRhcmQobWVzc2FnZSk7XG4gICAgbWVzc2FnZS5zdGFuZGFyZEZ1bGwgPSBtZXNzYWdlLnN0YW5kYXJkO1xuICB9XG59O1xuXG4vLyBjcmVhdGUgbG9nIGxldmVsIGZ1bmN0aW9uc1xuaWYodHJ1ZSkge1xuICAvLyBsZXZlbHMgZm9yIHdoaWNoIHdlIHdhbnQgZnVuY3Rpb25zXG4gIHZhciBsZXZlbHMgPSBbJ2Vycm9yJywgJ3dhcm5pbmcnLCAnaW5mbycsICdkZWJ1ZycsICd2ZXJib3NlJ107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAvLyB3cmFwIGluIGEgZnVuY3Rpb24gdG8gZW5zdXJlIHByb3BlciBsZXZlbCB2YXIgaXMgcGFzc2VkXG4gICAgKGZ1bmN0aW9uKGxldmVsKSB7XG4gICAgICAvLyBjcmVhdGUgZnVuY3Rpb24gZm9yIHRoaXMgbGV2ZWxcbiAgICAgIGZvcmdlLmxvZ1tsZXZlbF0gPSBmdW5jdGlvbihjYXRlZ29yeSwgbWVzc2FnZS8qLCBhcmdzLi4uKi8pIHtcbiAgICAgICAgLy8gY29udmVydCBhcmd1bWVudHMgdG8gcmVhbCBhcnJheSwgcmVtb3ZlIGNhdGVnb3J5IGFuZCBtZXNzYWdlXG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5zbGljZSgyKTtcbiAgICAgICAgLy8gY3JlYXRlIG1lc3NhZ2Ugb2JqZWN0XG4gICAgICAgIC8vIE5vdGU6IGludGVycG9sYXRpb24gYW5kIHN0YW5kYXJkIGZvcm1hdHRpbmcgaXMgZG9uZSBsYXppbHlcbiAgICAgICAgdmFyIG1zZyA9IHtcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgIGNhdGVnb3J5OiBjYXRlZ29yeSxcbiAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICdhcmd1bWVudHMnOiBhcmdzXG4gICAgICAgICAgLypzdGFuZGFyZCovXG4gICAgICAgICAgLypmdWxsKi9cbiAgICAgICAgICAvKmZ1bGxNZXNzYWdlKi9cbiAgICAgICAgfTtcbiAgICAgICAgLy8gcHJvY2VzcyB0aGlzIG1lc3NhZ2VcbiAgICAgICAgZm9yZ2UubG9nLmxvZ01lc3NhZ2UobXNnKTtcbiAgICAgIH07XG4gICAgfSkobGV2ZWxzW2ldKTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbG9nZ2VyIHdpdGggc3BlY2lmaWVkIGN1c3RvbSBsb2dnaW5nIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSBsb2dnaW5nIGZ1bmN0aW9uIGhhcyBhIHNpZ25hdHVyZSBvZjpcbiAqICAgZnVuY3Rpb24obG9nZ2VyLCBtZXNzYWdlKVxuICogbG9nZ2VyOiBjdXJyZW50IGxvZ2dlclxuICogbWVzc2FnZTogb2JqZWN0OlxuICogICBsZXZlbDogbGV2ZWwgaWRcbiAqICAgY2F0ZWdvcnk6IGNhdGVnb3J5XG4gKiAgIG1lc3NhZ2U6IHN0cmluZyBtZXNzYWdlXG4gKiAgIGFyZ3VtZW50czogQXJyYXkgb2YgZXh0cmEgYXJndW1lbnRzXG4gKiAgIGZ1bGxNZXNzYWdlOiBpbnRlcnBvbGF0ZWQgbWVzc2FnZSBhbmQgYXJndW1lbnRzIGlmIElOVEVSUE9MQVRFIGZsYWcgc2V0XG4gKlxuICogQHBhcmFtIGxvZ0Z1bmN0aW9uIGEgbG9nZ2luZyBmdW5jdGlvbiB3aGljaCB0YWtlcyBhIGxvZyBtZXNzYWdlIG9iamVjdFxuICogICAgICAgICAgYXMgYSBwYXJhbWV0ZXIuXG4gKlxuICogQHJldHVybiBhIGxvZ2dlciBvYmplY3QuXG4gKi9cbmZvcmdlLmxvZy5tYWtlTG9nZ2VyID0gZnVuY3Rpb24obG9nRnVuY3Rpb24pIHtcbiAgdmFyIGxvZ2dlciA9IHtcbiAgICBmbGFnczogMCxcbiAgICBmOiBsb2dGdW5jdGlvblxuICB9O1xuICBmb3JnZS5sb2cuc2V0TGV2ZWwobG9nZ2VyLCAnbm9uZScpO1xuICByZXR1cm4gbG9nZ2VyO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IGxvZyBsZXZlbCBvbiBhIGxvZ2dlci5cbiAqXG4gKiBAcGFyYW0gbG9nZ2VyIHRoZSB0YXJnZXQgbG9nZ2VyLlxuICogQHBhcmFtIGxldmVsIHRoZSBuZXcgbWF4aW11bSBsb2cgbGV2ZWwgYXMgYSBzdHJpbmcuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHNldCwgZmFsc2UgaWYgbm90LlxuICovXG5mb3JnZS5sb2cuc2V0TGV2ZWwgPSBmdW5jdGlvbihsb2dnZXIsIGxldmVsKSB7XG4gIHZhciBydmFsID0gZmFsc2U7XG4gIGlmKGxvZ2dlciAmJiAhKGxvZ2dlci5mbGFncyAmIGZvcmdlLmxvZy5MRVZFTF9MT0NLRUQpKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGZvcmdlLmxvZy5sZXZlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBhVmFsaWRMZXZlbCA9IGZvcmdlLmxvZy5sZXZlbHNbaV07XG4gICAgICBpZihsZXZlbCA9PSBhVmFsaWRMZXZlbCkge1xuICAgICAgICAvLyBzZXQgbGV2ZWxcbiAgICAgICAgbG9nZ2VyLmxldmVsID0gbGV2ZWw7XG4gICAgICAgIHJ2YWwgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogTG9ja3MgdGhlIGxvZyBsZXZlbCBhdCBpdHMgY3VycmVudCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gbG9nZ2VyIHRoZSB0YXJnZXQgbG9nZ2VyLlxuICogQHBhcmFtIGxvY2sgYm9vbGVhbiBsb2NrIHZhbHVlLCBkZWZhdWx0IHRvIHRydWUuXG4gKi9cbmZvcmdlLmxvZy5sb2NrID0gZnVuY3Rpb24obG9nZ2VyLCBsb2NrKSB7XG4gIGlmKHR5cGVvZiBsb2NrID09PSAndW5kZWZpbmVkJyB8fCBsb2NrKSB7XG4gICAgbG9nZ2VyLmZsYWdzIHw9IGZvcmdlLmxvZy5MRVZFTF9MT0NLRUQ7XG4gIH0gZWxzZSB7XG4gICAgbG9nZ2VyLmZsYWdzICY9IH5mb3JnZS5sb2cuTEVWRUxfTE9DS0VEO1xuICB9XG59O1xuXG4vKipcbiAqIEFkZHMgYSBsb2dnZXIuXG4gKlxuICogQHBhcmFtIGxvZ2dlciB0aGUgbG9nZ2VyIG9iamVjdC5cbiAqL1xuZm9yZ2UubG9nLmFkZExvZ2dlciA9IGZ1bmN0aW9uKGxvZ2dlcikge1xuICBzTG9nZ2Vycy5wdXNoKGxvZ2dlcik7XG59O1xuXG4vLyBzZXR1cCB0aGUgY29uc29sZSBsb2dnZXIgaWYgcG9zc2libGUsIGVsc2UgY3JlYXRlIGZha2UgY29uc29sZS5sb2dcbmlmKHR5cGVvZihjb25zb2xlKSAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2xvZycgaW4gY29uc29sZSkge1xuICB2YXIgbG9nZ2VyO1xuICBpZihjb25zb2xlLmVycm9yICYmIGNvbnNvbGUud2FybiAmJiBjb25zb2xlLmluZm8gJiYgY29uc29sZS5kZWJ1Zykge1xuICAgIC8vIGxvb2tzIGxpa2UgRmlyZWJ1Zy1zdHlsZSBsb2dnaW5nIGlzIGF2YWlsYWJsZVxuICAgIC8vIGxldmVsIGhhbmRsZXJzIG1hcFxuICAgIHZhciBsZXZlbEhhbmRsZXJzID0ge1xuICAgICAgZXJyb3I6IGNvbnNvbGUuZXJyb3IsXG4gICAgICB3YXJuaW5nOiBjb25zb2xlLndhcm4sXG4gICAgICBpbmZvOiBjb25zb2xlLmluZm8sXG4gICAgICBkZWJ1ZzogY29uc29sZS5kZWJ1ZyxcbiAgICAgIHZlcmJvc2U6IGNvbnNvbGUuZGVidWdcbiAgICB9O1xuICAgIHZhciBmID0gZnVuY3Rpb24obG9nZ2VyLCBtZXNzYWdlKSB7XG4gICAgICBmb3JnZS5sb2cucHJlcGFyZVN0YW5kYXJkKG1lc3NhZ2UpO1xuICAgICAgdmFyIGhhbmRsZXIgPSBsZXZlbEhhbmRsZXJzW21lc3NhZ2UubGV2ZWxdO1xuICAgICAgLy8gcHJlcGVuZCBzdGFuZGFyZCBtZXNzYWdlIGFuZCBjb25jYXQgYXJnc1xuICAgICAgdmFyIGFyZ3MgPSBbbWVzc2FnZS5zdGFuZGFyZF07XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQobWVzc2FnZVsnYXJndW1lbnRzJ10uc2xpY2UoKSk7XG4gICAgICAvLyBhcHBseSB0byBsb3ctbGV2ZWwgY29uc29sZSBmdW5jdGlvblxuICAgICAgaGFuZGxlci5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICB9O1xuICAgIGxvZ2dlciA9IGZvcmdlLmxvZy5tYWtlTG9nZ2VyKGYpO1xuICB9IGVsc2Uge1xuICAgIC8vIG9ubHkgYXBwZWFyIHRvIGhhdmUgYmFzaWMgY29uc29sZS5sb2dcbiAgICB2YXIgZiA9IGZ1bmN0aW9uKGxvZ2dlciwgbWVzc2FnZSkge1xuICAgICAgZm9yZ2UubG9nLnByZXBhcmVTdGFuZGFyZEZ1bGwobWVzc2FnZSk7XG4gICAgICBjb25zb2xlLmxvZyhtZXNzYWdlLnN0YW5kYXJkRnVsbCk7XG4gICAgfTtcbiAgICBsb2dnZXIgPSBmb3JnZS5sb2cubWFrZUxvZ2dlcihmKTtcbiAgfVxuICBmb3JnZS5sb2cuc2V0TGV2ZWwobG9nZ2VyLCAnZGVidWcnKTtcbiAgZm9yZ2UubG9nLmFkZExvZ2dlcihsb2dnZXIpO1xuICBzQ29uc29sZUxvZ2dlciA9IGxvZ2dlcjtcbn0gZWxzZSB7XG4gIC8vIGRlZmluZSBmYWtlIGNvbnNvbGUubG9nIHRvIGF2b2lkIHBvdGVudGlhbCBzY3JpcHQgZXJyb3JzIG9uXG4gIC8vIGJyb3dzZXJzIHRoYXQgZG8gbm90IGhhdmUgY29uc29sZSBsb2dnaW5nXG4gIGNvbnNvbGUgPSB7XG4gICAgbG9nOiBmdW5jdGlvbigpIHt9XG4gIH07XG59XG5cbi8qXG4gKiBDaGVjayBmb3IgbG9nZ2luZyBjb250cm9sIHF1ZXJ5IHZhcnMgaW4gY3VycmVudCBVUkwuXG4gKlxuICogY29uc29sZS5sZXZlbD08bGV2ZWwtbmFtZT5cbiAqIFNldCdzIHRoZSBjb25zb2xlIGxvZyBsZXZlbCBieSBuYW1lLiAgVXNlZnVsIHRvIG92ZXJyaWRlIGRlZmF1bHRzIGFuZFxuICogYWxsb3cgbW9yZSB2ZXJib3NlIGxvZ2dpbmcgYmVmb3JlIGEgdXNlciBjb25maWcgaXMgbG9hZGVkLlxuICpcbiAqIGNvbnNvbGUubG9jaz08dHJ1ZXxmYWxzZT5cbiAqIExvY2sgdGhlIGNvbnNvbGUgbG9nIGxldmVsIGF0IHdoYXRldmVyIGxldmVsIGl0IGlzIHNldCBhdC4gIFRoaXMgaXMgcnVuXG4gKiBhZnRlciBjb25zb2xlLmxldmVsIGlzIHByb2Nlc3NlZC4gIFVzZWZ1bCB0byBmb3JjZSBhIGxldmVsIG9mIHZlcmJvc2l0eVxuICogdGhhdCBjb3VsZCBvdGhlcndpc2UgYmUgbGltaXRlZCBieSBhIHVzZXIgY29uZmlnLlxuICovXG5pZihzQ29uc29sZUxvZ2dlciAhPT0gbnVsbCAmJlxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYXRpb25cbikge1xuICB2YXIgcXVlcnkgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKS5zZWFyY2hQYXJhbXM7XG4gIGlmKHF1ZXJ5LmhhcygnY29uc29sZS5sZXZlbCcpKSB7XG4gICAgLy8gc2V0IHdpdGggbGFzdCB2YWx1ZVxuICAgIGZvcmdlLmxvZy5zZXRMZXZlbChcbiAgICAgIHNDb25zb2xlTG9nZ2VyLCBxdWVyeS5nZXQoJ2NvbnNvbGUubGV2ZWwnKS5zbGljZSgtMSlbMF0pO1xuICB9XG4gIGlmKHF1ZXJ5LmhhcygnY29uc29sZS5sb2NrJykpIHtcbiAgICAvLyBzZXQgd2l0aCBsYXN0IHZhbHVlXG4gICAgdmFyIGxvY2sgPSBxdWVyeS5nZXQoJ2NvbnNvbGUubG9jaycpLnNsaWNlKC0xKVswXTtcbiAgICBpZihsb2NrID09ICd0cnVlJykge1xuICAgICAgZm9yZ2UubG9nLmxvY2soc0NvbnNvbGVMb2dnZXIpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBwcm92aWRlIHB1YmxpYyBhY2Nlc3MgdG8gY29uc29sZSBsb2dnZXJcbmZvcmdlLmxvZy5jb25zb2xlTG9nZ2VyID0gc0NvbnNvbGVMb2dnZXI7XG4iXSwibmFtZXMiOlsiZm9yZ2UiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsImxvZyIsImxldmVscyIsInNMZXZlbEluZm8iLCJzTG9nZ2VycyIsInNDb25zb2xlTG9nZ2VyIiwiTEVWRUxfTE9DS0VEIiwiTk9fTEVWRUxfQ0hFQ0siLCJJTlRFUlBPTEFURSIsImkiLCJsZW5ndGgiLCJsZXZlbCIsImluZGV4IiwibmFtZSIsInRvVXBwZXJDYXNlIiwibG9nTWVzc2FnZSIsIm1lc3NhZ2UiLCJtZXNzYWdlTGV2ZWxJbmRleCIsImxvZ2dlciIsImZsYWdzIiwiZiIsImxvZ2dlckxldmVsSW5kZXgiLCJwcmVwYXJlU3RhbmRhcmQiLCJzdGFuZGFyZCIsImNhdGVnb3J5IiwicHJlcGFyZUZ1bGwiLCJhcmdzIiwiY29uY2F0IiwiZnVsbCIsInV0aWwiLCJmb3JtYXQiLCJhcHBseSIsInByZXBhcmVTdGFuZGFyZEZ1bGwiLCJzdGFuZGFyZEZ1bGwiLCJBcnJheSIsInByb3RvdHlwZSIsInNsaWNlIiwiY2FsbCIsImFyZ3VtZW50cyIsIm1zZyIsInRpbWVzdGFtcCIsIkRhdGUiLCJtYWtlTG9nZ2VyIiwibG9nRnVuY3Rpb24iLCJzZXRMZXZlbCIsInJ2YWwiLCJhVmFsaWRMZXZlbCIsImxvY2siLCJhZGRMb2dnZXIiLCJwdXNoIiwiY29uc29sZSIsImVycm9yIiwid2FybiIsImluZm8iLCJkZWJ1ZyIsImxldmVsSGFuZGxlcnMiLCJ3YXJuaW5nIiwidmVyYm9zZSIsImhhbmRsZXIiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInF1ZXJ5IiwiVVJMIiwiaHJlZiIsInNlYXJjaFBhcmFtcyIsImhhcyIsImdldCIsImNvbnNvbGVMb2dnZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/log.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/md.all.js":
/*!***********************************************!*\
  !*** ./node_modules/node-forge/lib/md.all.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Node.js module for all known Forge message digests.\n *\n * @author Dave Longley\n *\n * Copyright 2011-2017 Digital Bazaar, Inc.\n */ \nmodule.exports = __webpack_require__(/*! ./md */ \"(rsc)/./node_modules/node-forge/lib/md.js\");\n__webpack_require__(/*! ./md5 */ \"(rsc)/./node_modules/node-forge/lib/md5.js\");\n__webpack_require__(/*! ./sha1 */ \"(rsc)/./node_modules/node-forge/lib/sha1.js\");\n__webpack_require__(/*! ./sha256 */ \"(rsc)/./node_modules/node-forge/lib/sha256.js\");\n__webpack_require__(/*! ./sha512 */ \"(rsc)/./node_modules/node-forge/lib/sha512.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvbWQuYWxsLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Q0FNQztBQUNEQSw2RkFBeUI7QUFFekJFLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL21kLmFsbC5qcz9lOTgxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTm9kZS5qcyBtb2R1bGUgZm9yIGFsbCBrbm93biBGb3JnZSBtZXNzYWdlIGRpZ2VzdHMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tZCcpO1xuXG5yZXF1aXJlKCcuL21kNScpO1xucmVxdWlyZSgnLi9zaGExJyk7XG5yZXF1aXJlKCcuL3NoYTI1NicpO1xucmVxdWlyZSgnLi9zaGE1MTInKTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/md.all.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/md.js":
/*!*******************************************!*\
  !*** ./node_modules/node-forge/lib/md.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Node.js module for Forge message digests.\n *\n * @author Dave Longley\n *\n * Copyright 2011-2017 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\nmodule.exports = forge.md = forge.md || {};\nforge.md.algorithms = forge.md.algorithms || {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvbWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFFcEJDLE9BQU9DLE9BQU8sR0FBR0gsTUFBTUksRUFBRSxHQUFHSixNQUFNSSxFQUFFLElBQUksQ0FBQztBQUN6Q0osTUFBTUksRUFBRSxDQUFDQyxVQUFVLEdBQUdMLE1BQU1JLEVBQUUsQ0FBQ0MsVUFBVSxJQUFJLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvbWQuanM/MjA0OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE5vZGUuanMgbW9kdWxlIGZvciBGb3JnZSBtZXNzYWdlIGRpZ2VzdHMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5tZCA9IGZvcmdlLm1kIHx8IHt9O1xuZm9yZ2UubWQuYWxnb3JpdGhtcyA9IGZvcmdlLm1kLmFsZ29yaXRobXMgfHwge307XG4iXSwibmFtZXMiOlsiZm9yZ2UiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsIm1kIiwiYWxnb3JpdGhtcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/md.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/md5.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/md5.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Message Digest Algorithm 5 with 128-bit digest (MD5) implementation.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./md */ \"(rsc)/./node_modules/node-forge/lib/md.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\nvar md5 = module.exports = forge.md5 = forge.md5 || {};\nforge.md.md5 = forge.md.algorithms.md5 = md5;\n/**\n * Creates an MD5 message digest object.\n *\n * @return a message digest object.\n */ md5.create = function() {\n    // do initialization as necessary\n    if (!_initialized) {\n        _init();\n    }\n    // MD5 state contains four 32-bit integers\n    var _state = null;\n    // input buffer\n    var _input = forge.util.createBuffer();\n    // used for word storage\n    var _w = new Array(16);\n    // message digest object\n    var md = {\n        algorithm: \"md5\",\n        blockLength: 64,\n        digestLength: 16,\n        // 56-bit length of message so far (does not including padding)\n        messageLength: 0,\n        // true message length\n        fullMessageLength: null,\n        // size of message length in bytes\n        messageLengthSize: 8\n    };\n    /**\n   * Starts the digest.\n   *\n   * @return this digest object.\n   */ md.start = function() {\n        // up to 56-bit message length for convenience\n        md.messageLength = 0;\n        // full message length (set md.messageLength64 for backwards-compatibility)\n        md.fullMessageLength = md.messageLength64 = [];\n        var int32s = md.messageLengthSize / 4;\n        for(var i = 0; i < int32s; ++i){\n            md.fullMessageLength.push(0);\n        }\n        _input = forge.util.createBuffer();\n        _state = {\n            h0: 0x67452301,\n            h1: 0xEFCDAB89,\n            h2: 0x98BADCFE,\n            h3: 0x10325476\n        };\n        return md;\n    };\n    // start digest automatically for first time\n    md.start();\n    /**\n   * Updates the digest with the given message input. The given input can\n   * treated as raw input (no encoding will be applied) or an encoding of\n   * 'utf8' maybe given to encode the input using UTF-8.\n   *\n   * @param msg the message input to update with.\n   * @param encoding the encoding to use (default: 'raw', other: 'utf8').\n   *\n   * @return this digest object.\n   */ md.update = function(msg, encoding) {\n        if (encoding === \"utf8\") {\n            msg = forge.util.encodeUtf8(msg);\n        }\n        // update message length\n        var len = msg.length;\n        md.messageLength += len;\n        len = [\n            len / 0x100000000 >>> 0,\n            len >>> 0\n        ];\n        for(var i = md.fullMessageLength.length - 1; i >= 0; --i){\n            md.fullMessageLength[i] += len[1];\n            len[1] = len[0] + (md.fullMessageLength[i] / 0x100000000 >>> 0);\n            md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\n            len[0] = len[1] / 0x100000000 >>> 0;\n        }\n        // add bytes to input buffer\n        _input.putBytes(msg);\n        // process bytes\n        _update(_state, _w, _input);\n        // compact input buffer every 2K or if empty\n        if (_input.read > 2048 || _input.length() === 0) {\n            _input.compact();\n        }\n        return md;\n    };\n    /**\n   * Produces the digest.\n   *\n   * @return a byte buffer containing the digest value.\n   */ md.digest = function() {\n        /* Note: Here we copy the remaining bytes in the input buffer and\n    add the appropriate MD5 padding. Then we do the final update\n    on a copy of the state so that if the user wants to get\n    intermediate digests they can do so. */ /* Determine the number of bytes that must be added to the message\n    to ensure its length is congruent to 448 mod 512. In other words,\n    the data to be digested must be a multiple of 512 bits (or 128 bytes).\n    This data includes the message, some padding, and the length of the\n    message. Since the length of the message will be encoded as 8 bytes (64\n    bits), that means that the last segment of the data must have 56 bytes\n    (448 bits) of message and padding. Therefore, the length of the message\n    plus the padding must be congruent to 448 mod 512 because\n    512 - 128 = 448.\n\n    In order to fill up the message length it must be filled with\n    padding that begins with 1 bit followed by all 0 bits. Padding\n    must *always* be present, so if the message length is already\n    congruent to 448 mod 512, then 512 padding bits must be added. */ var finalBlock = forge.util.createBuffer();\n        finalBlock.putBytes(_input.bytes());\n        // compute remaining size to be digested (include message length size)\n        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;\n        // add padding for overflow blockSize - overflow\n        // _padding starts with 1 byte with first bit is set (byte value 128), then\n        // there may be up to (blockSize - 1) other pad bytes\n        var overflow = remaining & md.blockLength - 1;\n        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\n        // serialize message length in bits in little-endian order; since length\n        // is stored in bytes we multiply by 8 and add carry\n        var bits, carry = 0;\n        for(var i = md.fullMessageLength.length - 1; i >= 0; --i){\n            bits = md.fullMessageLength[i] * 8 + carry;\n            carry = bits / 0x100000000 >>> 0;\n            finalBlock.putInt32Le(bits >>> 0);\n        }\n        var s2 = {\n            h0: _state.h0,\n            h1: _state.h1,\n            h2: _state.h2,\n            h3: _state.h3\n        };\n        _update(s2, _w, finalBlock);\n        var rval = forge.util.createBuffer();\n        rval.putInt32Le(s2.h0);\n        rval.putInt32Le(s2.h1);\n        rval.putInt32Le(s2.h2);\n        rval.putInt32Le(s2.h3);\n        return rval;\n    };\n    return md;\n};\n// padding, constant tables for calculating md5\nvar _padding = null;\nvar _g = null;\nvar _r = null;\nvar _k = null;\nvar _initialized = false;\n/**\n * Initializes the constant tables.\n */ function _init() {\n    // create padding\n    _padding = String.fromCharCode(128);\n    _padding += forge.util.fillString(String.fromCharCode(0x00), 64);\n    // g values\n    _g = [\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n        9,\n        10,\n        11,\n        12,\n        13,\n        14,\n        15,\n        1,\n        6,\n        11,\n        0,\n        5,\n        10,\n        15,\n        4,\n        9,\n        14,\n        3,\n        8,\n        13,\n        2,\n        7,\n        12,\n        5,\n        8,\n        11,\n        14,\n        1,\n        4,\n        7,\n        10,\n        13,\n        0,\n        3,\n        6,\n        9,\n        12,\n        15,\n        2,\n        0,\n        7,\n        14,\n        5,\n        12,\n        3,\n        10,\n        1,\n        8,\n        15,\n        6,\n        13,\n        4,\n        11,\n        2,\n        9\n    ];\n    // rounds table\n    _r = [\n        7,\n        12,\n        17,\n        22,\n        7,\n        12,\n        17,\n        22,\n        7,\n        12,\n        17,\n        22,\n        7,\n        12,\n        17,\n        22,\n        5,\n        9,\n        14,\n        20,\n        5,\n        9,\n        14,\n        20,\n        5,\n        9,\n        14,\n        20,\n        5,\n        9,\n        14,\n        20,\n        4,\n        11,\n        16,\n        23,\n        4,\n        11,\n        16,\n        23,\n        4,\n        11,\n        16,\n        23,\n        4,\n        11,\n        16,\n        23,\n        6,\n        10,\n        15,\n        21,\n        6,\n        10,\n        15,\n        21,\n        6,\n        10,\n        15,\n        21,\n        6,\n        10,\n        15,\n        21\n    ];\n    // get the result of abs(sin(i + 1)) as a 32-bit integer\n    _k = new Array(64);\n    for(var i = 0; i < 64; ++i){\n        _k[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 0x100000000);\n    }\n    // now initialized\n    _initialized = true;\n}\n/**\n * Updates an MD5 state with the given byte buffer.\n *\n * @param s the MD5 state to update.\n * @param w the array to use to store words.\n * @param bytes the byte buffer to update with.\n */ function _update(s, w, bytes) {\n    // consume 512 bit (64 byte) chunks\n    var t, a, b, c, d, f, r, i;\n    var len = bytes.length();\n    while(len >= 64){\n        // initialize hash value for this chunk\n        a = s.h0;\n        b = s.h1;\n        c = s.h2;\n        d = s.h3;\n        // round 1\n        for(i = 0; i < 16; ++i){\n            w[i] = bytes.getInt32Le();\n            f = d ^ b & (c ^ d);\n            t = a + f + _k[i] + w[i];\n            r = _r[i];\n            a = d;\n            d = c;\n            c = b;\n            b += t << r | t >>> 32 - r;\n        }\n        // round 2\n        for(; i < 32; ++i){\n            f = c ^ d & (b ^ c);\n            t = a + f + _k[i] + w[_g[i]];\n            r = _r[i];\n            a = d;\n            d = c;\n            c = b;\n            b += t << r | t >>> 32 - r;\n        }\n        // round 3\n        for(; i < 48; ++i){\n            f = b ^ c ^ d;\n            t = a + f + _k[i] + w[_g[i]];\n            r = _r[i];\n            a = d;\n            d = c;\n            c = b;\n            b += t << r | t >>> 32 - r;\n        }\n        // round 4\n        for(; i < 64; ++i){\n            f = c ^ (b | ~d);\n            t = a + f + _k[i] + w[_g[i]];\n            r = _r[i];\n            a = d;\n            d = c;\n            c = b;\n            b += t << r | t >>> 32 - r;\n        }\n        // update hash state\n        s.h0 = s.h0 + a | 0;\n        s.h1 = s.h1 + b | 0;\n        s.h2 = s.h2 + c | 0;\n        s.h3 = s.h3 + d | 0;\n        len -= 64;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvbWQ1LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Q0FNQztBQUNELElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUVSLElBQUlDLE1BQU1DLE9BQU9DLE9BQU8sR0FBR0osTUFBTUUsR0FBRyxHQUFHRixNQUFNRSxHQUFHLElBQUksQ0FBQztBQUNyREYsTUFBTUssRUFBRSxDQUFDSCxHQUFHLEdBQUdGLE1BQU1LLEVBQUUsQ0FBQ0MsVUFBVSxDQUFDSixHQUFHLEdBQUdBO0FBRXpDOzs7O0NBSUMsR0FDREEsSUFBSUssTUFBTSxHQUFHO0lBQ1gsaUNBQWlDO0lBQ2pDLElBQUcsQ0FBQ0MsY0FBYztRQUNoQkM7SUFDRjtJQUVBLDBDQUEwQztJQUMxQyxJQUFJQyxTQUFTO0lBRWIsZUFBZTtJQUNmLElBQUlDLFNBQVNYLE1BQU1ZLElBQUksQ0FBQ0MsWUFBWTtJQUVwQyx3QkFBd0I7SUFDeEIsSUFBSUMsS0FBSyxJQUFJQyxNQUFNO0lBRW5CLHdCQUF3QjtJQUN4QixJQUFJVixLQUFLO1FBQ1BXLFdBQVc7UUFDWEMsYUFBYTtRQUNiQyxjQUFjO1FBQ2QsK0RBQStEO1FBQy9EQyxlQUFlO1FBQ2Ysc0JBQXNCO1FBQ3RCQyxtQkFBbUI7UUFDbkIsa0NBQWtDO1FBQ2xDQyxtQkFBbUI7SUFDckI7SUFFQTs7OztHQUlDLEdBQ0RoQixHQUFHaUIsS0FBSyxHQUFHO1FBQ1QsOENBQThDO1FBQzlDakIsR0FBR2MsYUFBYSxHQUFHO1FBRW5CLDJFQUEyRTtRQUMzRWQsR0FBR2UsaUJBQWlCLEdBQUdmLEdBQUdrQixlQUFlLEdBQUcsRUFBRTtRQUM5QyxJQUFJQyxTQUFTbkIsR0FBR2dCLGlCQUFpQixHQUFHO1FBQ3BDLElBQUksSUFBSUksSUFBSSxHQUFHQSxJQUFJRCxRQUFRLEVBQUVDLEVBQUc7WUFDOUJwQixHQUFHZSxpQkFBaUIsQ0FBQ00s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LEtBQU1JLElBQU1OLE1BQU8sS0FBS007UUFDL0I7UUFFQSxvQkFBb0I7UUFDcEJSLEVBQUVwQyxFQUFFLEdBQUcsRUFBR0EsRUFBRSxHQUFHdUMsSUFBSztRQUNwQkgsRUFBRW5DLEVBQUUsR0FBRyxFQUFHQSxFQUFFLEdBQUd1QyxJQUFLO1FBQ3BCSixFQUFFbEMsRUFBRSxHQUFHLEVBQUdBLEVBQUUsR0FBR3VDLElBQUs7UUFDcEJMLEVBQUVqQyxFQUFFLEdBQUcsRUFBR0EsRUFBRSxHQUFHdUMsSUFBSztRQUVwQmxDLE9BQU87SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL21kNS5qcz83ZjJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTWVzc2FnZSBEaWdlc3QgQWxnb3JpdGhtIDUgd2l0aCAxMjgtYml0IGRpZ2VzdCAoTUQ1KSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vbWQnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgbWQ1ID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5tZDUgPSBmb3JnZS5tZDUgfHwge307XG5mb3JnZS5tZC5tZDUgPSBmb3JnZS5tZC5hbGdvcml0aG1zLm1kNSA9IG1kNTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIE1ENSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKlxuICogQHJldHVybiBhIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqL1xubWQ1LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBkbyBpbml0aWFsaXphdGlvbiBhcyBuZWNlc3NhcnlcbiAgaWYoIV9pbml0aWFsaXplZCkge1xuICAgIF9pbml0KCk7XG4gIH1cblxuICAvLyBNRDUgc3RhdGUgY29udGFpbnMgZm91ciAzMi1iaXQgaW50ZWdlcnNcbiAgdmFyIF9zdGF0ZSA9IG51bGw7XG5cbiAgLy8gaW5wdXQgYnVmZmVyXG4gIHZhciBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIHVzZWQgZm9yIHdvcmQgc3RvcmFnZVxuICB2YXIgX3cgPSBuZXcgQXJyYXkoMTYpO1xuXG4gIC8vIG1lc3NhZ2UgZGlnZXN0IG9iamVjdFxuICB2YXIgbWQgPSB7XG4gICAgYWxnb3JpdGhtOiAnbWQ1JyxcbiAgICBibG9ja0xlbmd0aDogNjQsXG4gICAgZGlnZXN0TGVuZ3RoOiAxNixcbiAgICAvLyA1Ni1iaXQgbGVuZ3RoIG9mIG1lc3NhZ2Ugc28gZmFyIChkb2VzIG5vdCBpbmNsdWRpbmcgcGFkZGluZylcbiAgICBtZXNzYWdlTGVuZ3RoOiAwLFxuICAgIC8vIHRydWUgbWVzc2FnZSBsZW5ndGhcbiAgICBmdWxsTWVzc2FnZUxlbmd0aDogbnVsbCxcbiAgICAvLyBzaXplIG9mIG1lc3NhZ2UgbGVuZ3RoIGluIGJ5dGVzXG4gICAgbWVzc2FnZUxlbmd0aFNpemU6IDhcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnRzIHRoZSBkaWdlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gdGhpcyBkaWdlc3Qgb2JqZWN0LlxuICAgKi9cbiAgbWQuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB1cCB0byA1Ni1iaXQgbWVzc2FnZSBsZW5ndGggZm9yIGNvbnZlbmllbmNlXG4gICAgbWQubWVzc2FnZUxlbmd0aCA9IDA7XG5cbiAgICAvLyBmdWxsIG1lc3NhZ2UgbGVuZ3RoIChzZXQgbWQubWVzc2FnZUxlbmd0aDY0IGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSlcbiAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aCA9IG1kLm1lc3NhZ2VMZW5ndGg2NCA9IFtdO1xuICAgIHZhciBpbnQzMnMgPSBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSAvIDQ7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGludDMyczsgKytpKSB7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aC5wdXNoKDApO1xuICAgIH1cbiAgICBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIF9zdGF0ZSA9IHtcbiAgICAgIGgwOiAweDY3NDUyMzAxLFxuICAgICAgaDE6IDB4RUZDREFCODksXG4gICAgICBoMjogMHg5OEJBRENGRSxcbiAgICAgIGgzOiAweDEwMzI1NDc2XG4gICAgfTtcbiAgICByZXR1cm4gbWQ7XG4gIH07XG4gIC8vIHN0YXJ0IGRpZ2VzdCBhdXRvbWF0aWNhbGx5IGZvciBmaXJzdCB0aW1lXG4gIG1kLnN0YXJ0KCk7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGRpZ2VzdCB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlIGlucHV0LiBUaGUgZ2l2ZW4gaW5wdXQgY2FuXG4gICAqIHRyZWF0ZWQgYXMgcmF3IGlucHV0IChubyBlbmNvZGluZyB3aWxsIGJlIGFwcGxpZWQpIG9yIGFuIGVuY29kaW5nIG9mXG4gICAqICd1dGY4JyBtYXliZSBnaXZlbiB0byBlbmNvZGUgdGhlIGlucHV0IHVzaW5nIFVURi04LlxuICAgKlxuICAgKiBAcGFyYW0gbXNnIHRoZSBtZXNzYWdlIGlucHV0IHRvIHVwZGF0ZSB3aXRoLlxuICAgKiBAcGFyYW0gZW5jb2RpbmcgdGhlIGVuY29kaW5nIHRvIHVzZSAoZGVmYXVsdDogJ3JhdycsIG90aGVyOiAndXRmOCcpLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoaXMgZGlnZXN0IG9iamVjdC5cbiAgICovXG4gIG1kLnVwZGF0ZSA9IGZ1bmN0aW9uKG1zZywgZW5jb2RpbmcpIHtcbiAgICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICBtc2cgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgobXNnKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgbWVzc2FnZSBsZW5ndGhcbiAgICB2YXIgbGVuID0gbXNnLmxlbmd0aDtcbiAgICBtZC5tZXNzYWdlTGVuZ3RoICs9IGxlbjtcbiAgICBsZW4gPSBbKGxlbiAvIDB4MTAwMDAwMDAwKSA+Pj4gMCwgbGVuID4+PiAwXTtcbiAgICBmb3IodmFyIGkgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gKz0gbGVuWzFdO1xuICAgICAgbGVuWzFdID0gbGVuWzBdICsgKChtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSAvIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldID4+PiAwO1xuICAgICAgbGVuWzBdID0gKGxlblsxXSAvIDB4MTAwMDAwMDAwKSA+Pj4gMDtcbiAgICB9XG5cbiAgICAvLyBhZGQgYnl0ZXMgdG8gaW5wdXQgYnVmZmVyXG4gICAgX2lucHV0LnB1dEJ5dGVzKG1zZyk7XG5cbiAgICAvLyBwcm9jZXNzIGJ5dGVzXG4gICAgX3VwZGF0ZShfc3RhdGUsIF93LCBfaW5wdXQpO1xuXG4gICAgLy8gY29tcGFjdCBpbnB1dCBidWZmZXIgZXZlcnkgMksgb3IgaWYgZW1wdHlcbiAgICBpZihfaW5wdXQucmVhZCA+IDIwNDggfHwgX2lucHV0Lmxlbmd0aCgpID09PSAwKSB7XG4gICAgICBfaW5wdXQuY29tcGFjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtZDtcbiAgfTtcblxuICAvKipcbiAgICogUHJvZHVjZXMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiBhIGJ5dGUgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGRpZ2VzdCB2YWx1ZS5cbiAgICovXG4gIG1kLmRpZ2VzdCA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIE5vdGU6IEhlcmUgd2UgY29weSB0aGUgcmVtYWluaW5nIGJ5dGVzIGluIHRoZSBpbnB1dCBidWZmZXIgYW5kXG4gICAgYWRkIHRoZSBhcHByb3ByaWF0ZSBNRDUgcGFkZGluZy4gVGhlbiB3ZSBkbyB0aGUgZmluYWwgdXBkYXRlXG4gICAgb24gYSBjb3B5IG9mIHRoZSBzdGF0ZSBzbyB0aGF0IGlmIHRoZSB1c2VyIHdhbnRzIHRvIGdldFxuICAgIGludGVybWVkaWF0ZSBkaWdlc3RzIHRoZXkgY2FuIGRvIHNvLiAqL1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBtdXN0IGJlIGFkZGVkIHRvIHRoZSBtZXNzYWdlXG4gICAgdG8gZW5zdXJlIGl0cyBsZW5ndGggaXMgY29uZ3J1ZW50IHRvIDQ0OCBtb2QgNTEyLiBJbiBvdGhlciB3b3JkcyxcbiAgICB0aGUgZGF0YSB0byBiZSBkaWdlc3RlZCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNTEyIGJpdHMgKG9yIDEyOCBieXRlcykuXG4gICAgVGhpcyBkYXRhIGluY2x1ZGVzIHRoZSBtZXNzYWdlLCBzb21lIHBhZGRpbmcsIGFuZCB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgIG1lc3NhZ2UuIFNpbmNlIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2Ugd2lsbCBiZSBlbmNvZGVkIGFzIDggYnl0ZXMgKDY0XG4gICAgYml0cyksIHRoYXQgbWVhbnMgdGhhdCB0aGUgbGFzdCBzZWdtZW50IG9mIHRoZSBkYXRhIG11c3QgaGF2ZSA1NiBieXRlc1xuICAgICg0NDggYml0cykgb2YgbWVzc2FnZSBhbmQgcGFkZGluZy4gVGhlcmVmb3JlLCB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlXG4gICAgcGx1cyB0aGUgcGFkZGluZyBtdXN0IGJlIGNvbmdydWVudCB0byA0NDggbW9kIDUxMiBiZWNhdXNlXG4gICAgNTEyIC0gMTI4ID0gNDQ4LlxuXG4gICAgSW4gb3JkZXIgdG8gZmlsbCB1cCB0aGUgbWVzc2FnZSBsZW5ndGggaXQgbXVzdCBiZSBmaWxsZWQgd2l0aFxuICAgIHBhZGRpbmcgdGhhdCBiZWdpbnMgd2l0aCAxIGJpdCBmb2xsb3dlZCBieSBhbGwgMCBiaXRzLiBQYWRkaW5nXG4gICAgbXVzdCAqYWx3YXlzKiBiZSBwcmVzZW50LCBzbyBpZiB0aGUgbWVzc2FnZSBsZW5ndGggaXMgYWxyZWFkeVxuICAgIGNvbmdydWVudCB0byA0NDggbW9kIDUxMiwgdGhlbiA1MTIgcGFkZGluZyBiaXRzIG11c3QgYmUgYWRkZWQuICovXG5cbiAgICB2YXIgZmluYWxCbG9jayA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgZmluYWxCbG9jay5wdXRCeXRlcyhfaW5wdXQuYnl0ZXMoKSk7XG5cbiAgICAvLyBjb21wdXRlIHJlbWFpbmluZyBzaXplIHRvIGJlIGRpZ2VzdGVkIChpbmNsdWRlIG1lc3NhZ2UgbGVuZ3RoIHNpemUpXG4gICAgdmFyIHJlbWFpbmluZyA9IChcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW21kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDFdICtcbiAgICAgIG1kLm1lc3NhZ2VMZW5ndGhTaXplKTtcblxuICAgIC8vIGFkZCBwYWRkaW5nIGZvciBvdmVyZmxvdyBibG9ja1NpemUgLSBvdmVyZmxvd1xuICAgIC8vIF9wYWRkaW5nIHN0YXJ0cyB3aXRoIDEgYnl0ZSB3aXRoIGZpcnN0IGJpdCBpcyBzZXQgKGJ5dGUgdmFsdWUgMTI4KSwgdGhlblxuICAgIC8vIHRoZXJlIG1heSBiZSB1cCB0byAoYmxvY2tTaXplIC0gMSkgb3RoZXIgcGFkIGJ5dGVzXG4gICAgdmFyIG92ZXJmbG93ID0gcmVtYWluaW5nICYgKG1kLmJsb2NrTGVuZ3RoIC0gMSk7XG4gICAgZmluYWxCbG9jay5wdXRCeXRlcyhfcGFkZGluZy5zdWJzdHIoMCwgbWQuYmxvY2tMZW5ndGggLSBvdmVyZmxvdykpO1xuXG4gICAgLy8gc2VyaWFsaXplIG1lc3NhZ2UgbGVuZ3RoIGluIGJpdHMgaW4gbGl0dGxlLWVuZGlhbiBvcmRlcjsgc2luY2UgbGVuZ3RoXG4gICAgLy8gaXMgc3RvcmVkIGluIGJ5dGVzIHdlIG11bHRpcGx5IGJ5IDggYW5kIGFkZCBjYXJyeVxuICAgIHZhciBiaXRzLCBjYXJyeSA9IDA7XG4gICAgZm9yKHZhciBpID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGJpdHMgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSAqIDggKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gKGJpdHMgLyAweDEwMDAwMDAwMCkgPj4+IDA7XG4gICAgICBmaW5hbEJsb2NrLnB1dEludDMyTGUoYml0cyA+Pj4gMCk7XG4gICAgfVxuXG4gICAgdmFyIHMyID0ge1xuICAgICAgaDA6IF9zdGF0ZS5oMCxcbiAgICAgIGgxOiBfc3RhdGUuaDEsXG4gICAgICBoMjogX3N0YXRlLmgyLFxuICAgICAgaDM6IF9zdGF0ZS5oM1xuICAgIH07XG4gICAgX3VwZGF0ZShzMiwgX3csIGZpbmFsQmxvY2spO1xuICAgIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBydmFsLnB1dEludDMyTGUoczIuaDApO1xuICAgIHJ2YWwucHV0SW50MzJMZShzMi5oMSk7XG4gICAgcnZhbC5wdXRJbnQzMkxlKHMyLmgyKTtcbiAgICBydmFsLnB1dEludDMyTGUoczIuaDMpO1xuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gIHJldHVybiBtZDtcbn07XG5cbi8vIHBhZGRpbmcsIGNvbnN0YW50IHRhYmxlcyBmb3IgY2FsY3VsYXRpbmcgbWQ1XG52YXIgX3BhZGRpbmcgPSBudWxsO1xudmFyIF9nID0gbnVsbDtcbnZhciBfciA9IG51bGw7XG52YXIgX2sgPSBudWxsO1xudmFyIF9pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBjb25zdGFudCB0YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIF9pbml0KCkge1xuICAvLyBjcmVhdGUgcGFkZGluZ1xuICBfcGFkZGluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI4KTtcbiAgX3BhZGRpbmcgKz0gZm9yZ2UudXRpbC5maWxsU3RyaW5nKFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCksIDY0KTtcblxuICAvLyBnIHZhbHVlc1xuICBfZyA9IFtcbiAgICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICAgIDEsIDYsIDExLCAwLCA1LCAxMCwgMTUsIDQsIDksIDE0LCAzLCA4LCAxMywgMiwgNywgMTIsXG4gICAgNSwgOCwgMTEsIDE0LCAxLCA0LCA3LCAxMCwgMTMsIDAsIDMsIDYsIDksIDEyLCAxNSwgMixcbiAgICAwLCA3LCAxNCwgNSwgMTIsIDMsIDEwLCAxLCA4LCAxNSwgNiwgMTMsIDQsIDExLCAyLCA5XTtcblxuICAvLyByb3VuZHMgdGFibGVcbiAgX3IgPSBbXG4gICAgNywgMTIsIDE3LCAyMiwgIDcsIDEyLCAxNywgMjIsICA3LCAxMiwgMTcsIDIyLCAgNywgMTIsIDE3LCAyMixcbiAgICA1LCAgOSwgMTQsIDIwLCAgNSwgIDksIDE0LCAyMCwgIDUsICA5LCAxNCwgMjAsICA1LCAgOSwgMTQsIDIwLFxuICAgIDQsIDExLCAxNiwgMjMsICA0LCAxMSwgMTYsIDIzLCAgNCwgMTEsIDE2LCAyMywgIDQsIDExLCAxNiwgMjMsXG4gICAgNiwgMTAsIDE1LCAyMSwgIDYsIDEwLCAxNSwgMjEsICA2LCAxMCwgMTUsIDIxLCAgNiwgMTAsIDE1LCAyMV07XG5cbiAgLy8gZ2V0IHRoZSByZXN1bHQgb2YgYWJzKHNpbihpICsgMSkpIGFzIGEgMzItYml0IGludGVnZXJcbiAgX2sgPSBuZXcgQXJyYXkoNjQpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgNjQ7ICsraSkge1xuICAgIF9rW2ldID0gTWF0aC5mbG9vcihNYXRoLmFicyhNYXRoLnNpbihpICsgMSkpICogMHgxMDAwMDAwMDApO1xuICB9XG5cbiAgLy8gbm93IGluaXRpYWxpemVkXG4gIF9pbml0aWFsaXplZCA9IHRydWU7XG59XG5cbi8qKlxuICogVXBkYXRlcyBhbiBNRDUgc3RhdGUgd2l0aCB0aGUgZ2l2ZW4gYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIHMgdGhlIE1ENSBzdGF0ZSB0byB1cGRhdGUuXG4gKiBAcGFyYW0gdyB0aGUgYXJyYXkgdG8gdXNlIHRvIHN0b3JlIHdvcmRzLlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byB1cGRhdGUgd2l0aC5cbiAqL1xuZnVuY3Rpb24gX3VwZGF0ZShzLCB3LCBieXRlcykge1xuICAvLyBjb25zdW1lIDUxMiBiaXQgKDY0IGJ5dGUpIGNodW5rc1xuICB2YXIgdCwgYSwgYiwgYywgZCwgZiwgciwgaTtcbiAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aCgpO1xuICB3aGlsZShsZW4gPj0gNjQpIHtcbiAgICAvLyBpbml0aWFsaXplIGhhc2ggdmFsdWUgZm9yIHRoaXMgY2h1bmtcbiAgICBhID0gcy5oMDtcbiAgICBiID0gcy5oMTtcbiAgICBjID0gcy5oMjtcbiAgICBkID0gcy5oMztcblxuICAgIC8vIHJvdW5kIDFcbiAgICBmb3IoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICB3W2ldID0gYnl0ZXMuZ2V0SW50MzJMZSgpO1xuICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgdCA9IChhICsgZiArIF9rW2ldICsgd1tpXSk7XG4gICAgICByID0gX3JbaV07XG4gICAgICBhID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IGI7XG4gICAgICBiICs9ICh0IDw8IHIpIHwgKHQgPj4+ICgzMiAtIHIpKTtcbiAgICB9XG4gICAgLy8gcm91bmQgMlxuICAgIGZvcig7IGkgPCAzMjsgKytpKSB7XG4gICAgICBmID0gYyBeIChkICYgKGIgXiBjKSk7XG4gICAgICB0ID0gKGEgKyBmICsgX2tbaV0gKyB3W19nW2ldXSk7XG4gICAgICByID0gX3JbaV07XG4gICAgICBhID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IGI7XG4gICAgICBiICs9ICh0IDw8IHIpIHwgKHQgPj4+ICgzMiAtIHIpKTtcbiAgICB9XG4gICAgLy8gcm91bmQgM1xuICAgIGZvcig7IGkgPCA0ODsgKytpKSB7XG4gICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgdCA9IChhICsgZiArIF9rW2ldICsgd1tfZ1tpXV0pO1xuICAgICAgciA9IF9yW2ldO1xuICAgICAgYSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBiO1xuICAgICAgYiArPSAodCA8PCByKSB8ICh0ID4+PiAoMzIgLSByKSk7XG4gICAgfVxuICAgIC8vIHJvdW5kIDRcbiAgICBmb3IoOyBpIDwgNjQ7ICsraSkge1xuICAgICAgZiA9IGMgXiAoYiB8IH5kKTtcbiAgICAgIHQgPSAoYSArIGYgKyBfa1tpXSArIHdbX2dbaV1dKTtcbiAgICAgIHIgPSBfcltpXTtcbiAgICAgIGEgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gYjtcbiAgICAgIGIgKz0gKHQgPDwgcikgfCAodCA+Pj4gKDMyIC0gcikpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBoYXNoIHN0YXRlXG4gICAgcy5oMCA9IChzLmgwICsgYSkgfCAwO1xuICAgIHMuaDEgPSAocy5oMSArIGIpIHwgMDtcbiAgICBzLmgyID0gKHMuaDIgKyBjKSB8IDA7XG4gICAgcy5oMyA9IChzLmgzICsgZCkgfCAwO1xuXG4gICAgbGVuIC09IDY0O1xuICB9XG59XG4iXSwibmFtZXMiOlsiZm9yZ2UiLCJyZXF1aXJlIiwibWQ1IiwibW9kdWxlIiwiZXhwb3J0cyIsIm1kIiwiYWxnb3JpdGhtcyIsImNyZWF0ZSIsIl9pbml0aWFsaXplZCIsIl9pbml0IiwiX3N0YXRlIiwiX2lucHV0IiwidXRpbCIsImNyZWF0ZUJ1ZmZlciIsIl93IiwiQXJyYXkiLCJhbGdvcml0aG0iLCJibG9ja0xlbmd0aCIsImRpZ2VzdExlbmd0aCIsIm1lc3NhZ2VMZW5ndGgiLCJmdWxsTWVzc2FnZUxlbmd0aCIsIm1lc3NhZ2VMZW5ndGhTaXplIiwic3RhcnQiLCJtZXNzYWdlTGVuZ3RoNjQiLCJpbnQzMnMiLCJpIiwicHVzaCIsImgwIiwiaDEiLCJoMiIsImgzIiwidXBkYXRlIiwibXNnIiwiZW5jb2RpbmciLCJlbmNvZGVVdGY4IiwibGVuIiwibGVuZ3RoIiwicHV0Qnl0ZXMiLCJfdXBkYXRlIiwicmVhZCIsImNvbXBhY3QiLCJkaWdlc3QiLCJmaW5hbEJsb2NrIiwiYnl0ZXMiLCJyZW1haW5pbmciLCJvdmVyZmxvdyIsIl9wYWRkaW5nIiwic3Vic3RyIiwiYml0cyIsImNhcnJ5IiwicHV0SW50MzJMZSIsInMyIiwicnZhbCIsIl9nIiwiX3IiLCJfayIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImZpbGxTdHJpbmciLCJNYXRoIiwiZmxvb3IiLCJhYnMiLCJzaW4iLCJzIiwidyIsInQiLCJhIiwiYiIsImMiLCJkIiwiZiIsInIiLCJnZXRJbnQzMkxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/md5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/mgf.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/mgf.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Node.js module for Forge mask generation functions.\n *\n * @author Stefan Siegl\n *\n * Copyright 2012 Stefan Siegl <stesie@brokenpipe.de>\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./mgf1 */ \"(rsc)/./node_modules/node-forge/lib/mgf1.js\");\nmodule.exports = forge.mgf = forge.mgf || {};\nforge.mgf.mgf1 = forge.mgf1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvbWdmLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Q0FNQztBQUNELElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCQSxtQkFBT0EsQ0FBQztBQUVSQyxPQUFPQyxPQUFPLEdBQUdILE1BQU1JLEdBQUcsR0FBR0osTUFBTUksR0FBRyxJQUFJLENBQUM7QUFDM0NKLE1BQU1JLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHTCxNQUFNSyxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL21nZi5qcz8zMTZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTm9kZS5qcyBtb2R1bGUgZm9yIEZvcmdlIG1hc2sgZ2VuZXJhdGlvbiBmdW5jdGlvbnMuXG4gKlxuICogQGF1dGhvciBTdGVmYW4gU2llZ2xcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL21nZjEnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5tZ2YgPSBmb3JnZS5tZ2YgfHwge307XG5mb3JnZS5tZ2YubWdmMSA9IGZvcmdlLm1nZjE7XG4iXSwibmFtZXMiOlsiZm9yZ2UiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsIm1nZiIsIm1nZjEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/mgf.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/mgf1.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/mgf1.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Javascript implementation of mask generation function MGF1.\n *\n * @author Stefan Siegl\n * @author Dave Longley\n *\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n * Copyright (c) 2014 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\nforge.mgf = forge.mgf || {};\nvar mgf1 = module.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};\n/**\n * Creates a MGF1 mask generation function object.\n *\n * @param md the message digest API to use (eg: forge.md.sha1.create()).\n *\n * @return a mask generation function object.\n */ mgf1.create = function(md) {\n    var mgf = {\n        /**\n     * Generate mask of specified length.\n     *\n     * @param {String} seed The seed for mask generation.\n     * @param maskLen Number of bytes to generate.\n     * @return {String} The generated mask.\n     */ generate: function(seed, maskLen) {\n            /* 2. Let T be the empty octet string. */ var t = new forge.util.ByteBuffer();\n            /* 3. For counter from 0 to ceil(maskLen / hLen), do the following: */ var len = Math.ceil(maskLen / md.digestLength);\n            for(var i = 0; i < len; i++){\n                /* a. Convert counter to an octet string C of length 4 octets */ var c = new forge.util.ByteBuffer();\n                c.putInt32(i);\n                /* b. Concatenate the hash of the seed mgfSeed and C to the octet\n         * string T: */ md.start();\n                md.update(seed + c.getBytes());\n                t.putBuffer(md.digest());\n            }\n            /* Output the leading maskLen octets of T as the octet string mask. */ t.truncate(t.length() - maskLen);\n            return t.getBytes();\n        }\n    };\n    return mgf;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvbWdmMS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQztBQUNELElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCQSxtQkFBT0EsQ0FBQztBQUVSRCxNQUFNRSxHQUFHLEdBQUdGLE1BQU1FLEdBQUcsSUFBSSxDQUFDO0FBQzFCLElBQUlDLE9BQU9DLE9BQU9DLE9BQU8sR0FBR0wsTUFBTUUsR0FBRyxDQUFDQyxJQUFJLEdBQUdILE1BQU1HLElBQUksR0FBR0gsTUFBTUcsSUFBSSxJQUFJLENBQUM7QUFFekU7Ozs7OztDQU1DLEdBQ0RBLEtBQUtHLE1BQU0sR0FBRyxTQUFTQyxFQUFFO0lBQ3ZCLElBQUlMLE1BQU07UUFDUjs7Ozs7O0tBTUMsR0FDRE0sVUFBVSxTQUFTQyxJQUFJLEVBQUVDLE9BQU87WUFDOUIsdUNBQXVDLEdBQ3ZDLElBQUlDLElBQUksSUFBSVgsTUFBTVksSUFBSSxDQUFDQyxVQUFVO1lBRWpDLG9FQUFvRSxHQUNwRSxJQUFJQyxNQUFNQyxLQUFLQyxJQUFJLENBQUNOLFVBQVVILEdBQUdVLFlBQVk7WUFDN0MsSUFBSSxJQUFJQyxJQUFJLEdBQUdBLElBQUlKLEtBQUtJLElBQUs7Z0JBQzNCLDhEQUE4RCxHQUM5RCxJQUFJQyxJQUFJLElBQUluQixNQUFNWSxJQUFJLENBQUNDLFVBQVU7Z0JBQ2pDTSxFQUFFQyxRQUFRLENBQUNGO2dCQUVYO3FCQUNhLEdBQ2JYLEdBQUdjLEtBQUs7Z0JBQ1JkLEdBQUdlLE1BQU0sQ0FBQ2IsT0FBT1UsRUFBRUksUUFBUTtnQkFDM0JaLEVBQUVhLFNBQVMsQ0FBQ2pCLEdBQUdrQixNQUFNO1lBQ3ZCO1lBRUEsb0VBQW9FLEdBQ3BFZCxFQUFFZSxRQUFRLENBQUNmLEVBQUVnQixNQUFNLEtBQUtqQjtZQUN4QixPQUFPQyxFQUFFWSxRQUFRO1FBQ25CO0lBQ0Y7SUFFQSxPQUFPckI7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9tZ2YxLmpzPzdjM2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIG1hc2sgZ2VuZXJhdGlvbiBmdW5jdGlvbiBNR0YxLlxuICpcbiAqIEBhdXRob3IgU3RlZmFuIFNpZWdsXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICogQ29weXJpZ2h0IChjKSAyMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG5mb3JnZS5tZ2YgPSBmb3JnZS5tZ2YgfHwge307XG52YXIgbWdmMSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UubWdmLm1nZjEgPSBmb3JnZS5tZ2YxID0gZm9yZ2UubWdmMSB8fCB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgTUdGMSBtYXNrIGdlbmVyYXRpb24gZnVuY3Rpb24gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBtZCB0aGUgbWVzc2FnZSBkaWdlc3QgQVBJIHRvIHVzZSAoZWc6IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCkpLlxuICpcbiAqIEByZXR1cm4gYSBtYXNrIGdlbmVyYXRpb24gZnVuY3Rpb24gb2JqZWN0LlxuICovXG5tZ2YxLmNyZWF0ZSA9IGZ1bmN0aW9uKG1kKSB7XG4gIHZhciBtZ2YgPSB7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgbWFzayBvZiBzcGVjaWZpZWQgbGVuZ3RoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNlZWQgVGhlIHNlZWQgZm9yIG1hc2sgZ2VuZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gbWFza0xlbiBOdW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgZ2VuZXJhdGVkIG1hc2suXG4gICAgICovXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHNlZWQsIG1hc2tMZW4pIHtcbiAgICAgIC8qIDIuIExldCBUIGJlIHRoZSBlbXB0eSBvY3RldCBzdHJpbmcuICovXG4gICAgICB2YXIgdCA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcblxuICAgICAgLyogMy4gRm9yIGNvdW50ZXIgZnJvbSAwIHRvIGNlaWwobWFza0xlbiAvIGhMZW4pLCBkbyB0aGUgZm9sbG93aW5nOiAqL1xuICAgICAgdmFyIGxlbiA9IE1hdGguY2VpbChtYXNrTGVuIC8gbWQuZGlnZXN0TGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvKiBhLiBDb252ZXJ0IGNvdW50ZXIgdG8gYW4gb2N0ZXQgc3RyaW5nIEMgb2YgbGVuZ3RoIDQgb2N0ZXRzICovXG4gICAgICAgIHZhciBjID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICAgICAgICBjLnB1dEludDMyKGkpO1xuXG4gICAgICAgIC8qIGIuIENvbmNhdGVuYXRlIHRoZSBoYXNoIG9mIHRoZSBzZWVkIG1nZlNlZWQgYW5kIEMgdG8gdGhlIG9jdGV0XG4gICAgICAgICAqIHN0cmluZyBUOiAqL1xuICAgICAgICBtZC5zdGFydCgpO1xuICAgICAgICBtZC51cGRhdGUoc2VlZCArIGMuZ2V0Qnl0ZXMoKSk7XG4gICAgICAgIHQucHV0QnVmZmVyKG1kLmRpZ2VzdCgpKTtcbiAgICAgIH1cblxuICAgICAgLyogT3V0cHV0IHRoZSBsZWFkaW5nIG1hc2tMZW4gb2N0ZXRzIG9mIFQgYXMgdGhlIG9jdGV0IHN0cmluZyBtYXNrLiAqL1xuICAgICAgdC50cnVuY2F0ZSh0Lmxlbmd0aCgpIC0gbWFza0xlbik7XG4gICAgICByZXR1cm4gdC5nZXRCeXRlcygpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbWdmO1xufTtcbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJtZ2YiLCJtZ2YxIiwibW9kdWxlIiwiZXhwb3J0cyIsImNyZWF0ZSIsIm1kIiwiZ2VuZXJhdGUiLCJzZWVkIiwibWFza0xlbiIsInQiLCJ1dGlsIiwiQnl0ZUJ1ZmZlciIsImxlbiIsIk1hdGgiLCJjZWlsIiwiZGlnZXN0TGVuZ3RoIiwiaSIsImMiLCJwdXRJbnQzMiIsInN0YXJ0IiwidXBkYXRlIiwiZ2V0Qnl0ZXMiLCJwdXRCdWZmZXIiLCJkaWdlc3QiLCJ0cnVuY2F0ZSIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/mgf1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/oids.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/oids.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Object IDs for ASN.1.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\nforge.pki = forge.pki || {};\nvar oids = module.exports = forge.pki.oids = forge.oids = forge.oids || {};\n// set id to name mapping and name to id mapping\nfunction _IN(id, name) {\n    oids[id] = name;\n    oids[name] = id;\n}\n// set id to name mapping only\nfunction _I_(id, name) {\n    oids[id] = name;\n}\n// algorithm OIDs\n_IN(\"1.2.840.113549.1.1.1\", \"rsaEncryption\");\n// Note: md2 & md4 not implemented\n//_IN('1.2.840.113549.1.1.2', 'md2WithRSAEncryption');\n//_IN('1.2.840.113549.1.1.3', 'md4WithRSAEncryption');\n_IN(\"1.2.840.113549.1.1.4\", \"md5WithRSAEncryption\");\n_IN(\"1.2.840.113549.1.1.5\", \"sha1WithRSAEncryption\");\n_IN(\"1.2.840.113549.1.1.7\", \"RSAES-OAEP\");\n_IN(\"1.2.840.113549.1.1.8\", \"mgf1\");\n_IN(\"1.2.840.113549.1.1.9\", \"pSpecified\");\n_IN(\"1.2.840.113549.1.1.10\", \"RSASSA-PSS\");\n_IN(\"1.2.840.113549.1.1.11\", \"sha256WithRSAEncryption\");\n_IN(\"1.2.840.113549.1.1.12\", \"sha384WithRSAEncryption\");\n_IN(\"1.2.840.113549.1.1.13\", \"sha512WithRSAEncryption\");\n// Edwards-curve Digital Signature Algorithm (EdDSA) Ed25519\n_IN(\"1.3.101.112\", \"EdDSA25519\");\n_IN(\"1.2.840.10040.4.3\", \"dsa-with-sha1\");\n_IN(\"1.3.14.3.2.7\", \"desCBC\");\n_IN(\"1.3.14.3.2.26\", \"sha1\");\n// Deprecated equivalent of sha1WithRSAEncryption\n_IN(\"1.3.14.3.2.29\", \"sha1WithRSASignature\");\n_IN(\"2.16.840.1.101.3.4.2.1\", \"sha256\");\n_IN(\"2.16.840.1.101.3.4.2.2\", \"sha384\");\n_IN(\"2.16.840.1.101.3.4.2.3\", \"sha512\");\n_IN(\"2.16.840.1.101.3.4.2.4\", \"sha224\");\n_IN(\"2.16.840.1.101.3.4.2.5\", \"sha512-224\");\n_IN(\"2.16.840.1.101.3.4.2.6\", \"sha512-256\");\n_IN(\"1.2.840.113549.2.2\", \"md2\");\n_IN(\"1.2.840.113549.2.5\", \"md5\");\n// pkcs#7 content types\n_IN(\"1.2.840.113549.1.7.1\", \"data\");\n_IN(\"1.2.840.113549.1.7.2\", \"signedData\");\n_IN(\"1.2.840.113549.1.7.3\", \"envelopedData\");\n_IN(\"1.2.840.113549.1.7.4\", \"signedAndEnvelopedData\");\n_IN(\"1.2.840.113549.1.7.5\", \"digestedData\");\n_IN(\"1.2.840.113549.1.7.6\", \"encryptedData\");\n// pkcs#9 oids\n_IN(\"1.2.840.113549.1.9.1\", \"emailAddress\");\n_IN(\"1.2.840.113549.1.9.2\", \"unstructuredName\");\n_IN(\"1.2.840.113549.1.9.3\", \"contentType\");\n_IN(\"1.2.840.113549.1.9.4\", \"messageDigest\");\n_IN(\"1.2.840.113549.1.9.5\", \"signingTime\");\n_IN(\"1.2.840.113549.1.9.6\", \"counterSignature\");\n_IN(\"1.2.840.113549.1.9.7\", \"challengePassword\");\n_IN(\"1.2.840.113549.1.9.8\", \"unstructuredAddress\");\n_IN(\"1.2.840.113549.1.9.14\", \"extensionRequest\");\n_IN(\"1.2.840.113549.1.9.20\", \"friendlyName\");\n_IN(\"1.2.840.113549.1.9.21\", \"localKeyId\");\n_IN(\"1.2.840.113549.1.9.22.1\", \"x509Certificate\");\n// pkcs#12 safe bags\n_IN(\"1.2.840.113549.1.12.10.1.1\", \"keyBag\");\n_IN(\"1.2.840.113549.1.12.10.1.2\", \"pkcs8ShroudedKeyBag\");\n_IN(\"1.2.840.113549.1.12.10.1.3\", \"certBag\");\n_IN(\"1.2.840.113549.1.12.10.1.4\", \"crlBag\");\n_IN(\"1.2.840.113549.1.12.10.1.5\", \"secretBag\");\n_IN(\"1.2.840.113549.1.12.10.1.6\", \"safeContentsBag\");\n// password-based-encryption for pkcs#12\n_IN(\"1.2.840.113549.1.5.13\", \"pkcs5PBES2\");\n_IN(\"1.2.840.113549.1.5.12\", \"pkcs5PBKDF2\");\n_IN(\"1.2.840.113549.1.12.1.1\", \"pbeWithSHAAnd128BitRC4\");\n_IN(\"1.2.840.113549.1.12.1.2\", \"pbeWithSHAAnd40BitRC4\");\n_IN(\"1.2.840.113549.1.12.1.3\", \"pbeWithSHAAnd3-KeyTripleDES-CBC\");\n_IN(\"1.2.840.113549.1.12.1.4\", \"pbeWithSHAAnd2-KeyTripleDES-CBC\");\n_IN(\"1.2.840.113549.1.12.1.5\", \"pbeWithSHAAnd128BitRC2-CBC\");\n_IN(\"1.2.840.113549.1.12.1.6\", \"pbewithSHAAnd40BitRC2-CBC\");\n// hmac OIDs\n_IN(\"1.2.840.113549.2.7\", \"hmacWithSHA1\");\n_IN(\"1.2.840.113549.2.8\", \"hmacWithSHA224\");\n_IN(\"1.2.840.113549.2.9\", \"hmacWithSHA256\");\n_IN(\"1.2.840.113549.2.10\", \"hmacWithSHA384\");\n_IN(\"1.2.840.113549.2.11\", \"hmacWithSHA512\");\n// symmetric key algorithm oids\n_IN(\"1.2.840.113549.3.7\", \"des-EDE3-CBC\");\n_IN(\"2.16.840.1.101.3.4.1.2\", \"aes128-CBC\");\n_IN(\"2.16.840.1.101.3.4.1.22\", \"aes192-CBC\");\n_IN(\"2.16.840.1.101.3.4.1.42\", \"aes256-CBC\");\n// certificate issuer/subject OIDs\n_IN(\"2.5.4.3\", \"commonName\");\n_IN(\"2.5.4.4\", \"surname\");\n_IN(\"2.5.4.5\", \"serialNumber\");\n_IN(\"2.5.4.6\", \"countryName\");\n_IN(\"2.5.4.7\", \"localityName\");\n_IN(\"2.5.4.8\", \"stateOrProvinceName\");\n_IN(\"2.5.4.9\", \"streetAddress\");\n_IN(\"2.5.4.10\", \"organizationName\");\n_IN(\"2.5.4.11\", \"organizationalUnitName\");\n_IN(\"2.5.4.12\", \"title\");\n_IN(\"2.5.4.13\", \"description\");\n_IN(\"2.5.4.15\", \"businessCategory\");\n_IN(\"2.5.4.17\", \"postalCode\");\n_IN(\"2.5.4.42\", \"givenName\");\n_IN(\"1.3.6.1.4.1.311.60.2.1.2\", \"jurisdictionOfIncorporationStateOrProvinceName\");\n_IN(\"1.3.6.1.4.1.311.60.2.1.3\", \"jurisdictionOfIncorporationCountryName\");\n// X.509 extension OIDs\n_IN(\"2.16.840.1.113730.1.1\", \"nsCertType\");\n_IN(\"2.16.840.1.113730.1.13\", \"nsComment\"); // deprecated in theory; still widely used\n_I_(\"2.5.29.1\", \"authorityKeyIdentifier\"); // deprecated, use .35\n_I_(\"2.5.29.2\", \"keyAttributes\"); // obsolete use .37 or .15\n_I_(\"2.5.29.3\", \"certificatePolicies\"); // deprecated, use .32\n_I_(\"2.5.29.4\", \"keyUsageRestriction\"); // obsolete use .37 or .15\n_I_(\"2.5.29.5\", \"policyMapping\"); // deprecated use .33\n_I_(\"2.5.29.6\", \"subtreesConstraint\"); // obsolete use .30\n_I_(\"2.5.29.7\", \"subjectAltName\"); // deprecated use .17\n_I_(\"2.5.29.8\", \"issuerAltName\"); // deprecated use .18\n_I_(\"2.5.29.9\", \"subjectDirectoryAttributes\");\n_I_(\"2.5.29.10\", \"basicConstraints\"); // deprecated use .19\n_I_(\"2.5.29.11\", \"nameConstraints\"); // deprecated use .30\n_I_(\"2.5.29.12\", \"policyConstraints\"); // deprecated use .36\n_I_(\"2.5.29.13\", \"basicConstraints\"); // deprecated use .19\n_IN(\"2.5.29.14\", \"subjectKeyIdentifier\");\n_IN(\"2.5.29.15\", \"keyUsage\");\n_I_(\"2.5.29.16\", \"privateKeyUsagePeriod\");\n_IN(\"2.5.29.17\", \"subjectAltName\");\n_IN(\"2.5.29.18\", \"issuerAltName\");\n_IN(\"2.5.29.19\", \"basicConstraints\");\n_I_(\"2.5.29.20\", \"cRLNumber\");\n_I_(\"2.5.29.21\", \"cRLReason\");\n_I_(\"2.5.29.22\", \"expirationDate\");\n_I_(\"2.5.29.23\", \"instructionCode\");\n_I_(\"2.5.29.24\", \"invalidityDate\");\n_I_(\"2.5.29.25\", \"cRLDistributionPoints\"); // deprecated use .31\n_I_(\"2.5.29.26\", \"issuingDistributionPoint\"); // deprecated use .28\n_I_(\"2.5.29.27\", \"deltaCRLIndicator\");\n_I_(\"2.5.29.28\", \"issuingDistributionPoint\");\n_I_(\"2.5.29.29\", \"certificateIssuer\");\n_I_(\"2.5.29.30\", \"nameConstraints\");\n_IN(\"2.5.29.31\", \"cRLDistributionPoints\");\n_IN(\"2.5.29.32\", \"certificatePolicies\");\n_I_(\"2.5.29.33\", \"policyMappings\");\n_I_(\"2.5.29.34\", \"policyConstraints\"); // deprecated use .36\n_IN(\"2.5.29.35\", \"authorityKeyIdentifier\");\n_I_(\"2.5.29.36\", \"policyConstraints\");\n_IN(\"2.5.29.37\", \"extKeyUsage\");\n_I_(\"2.5.29.46\", \"freshestCRL\");\n_I_(\"2.5.29.54\", \"inhibitAnyPolicy\");\n// extKeyUsage purposes\n_IN(\"1.3.6.1.4.1.11129.2.4.2\", \"timestampList\");\n_IN(\"1.3.6.1.5.5.7.1.1\", \"authorityInfoAccess\");\n_IN(\"1.3.6.1.5.5.7.3.1\", \"serverAuth\");\n_IN(\"1.3.6.1.5.5.7.3.2\", \"clientAuth\");\n_IN(\"1.3.6.1.5.5.7.3.3\", \"codeSigning\");\n_IN(\"1.3.6.1.5.5.7.3.4\", \"emailProtection\");\n_IN(\"1.3.6.1.5.5.7.3.8\", \"timeStamping\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvb2lkcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0NBTUM7QUFDRCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUVwQkQsTUFBTUUsR0FBRyxHQUFHRixNQUFNRSxHQUFHLElBQUksQ0FBQztBQUMxQixJQUFJQyxPQUFPQyxPQUFPQyxPQUFPLEdBQUdMLE1BQU1FLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHSCxNQUFNRyxJQUFJLEdBQUdILE1BQU1HLElBQUksSUFBSSxDQUFDO0FBRXpFLGdEQUFnRDtBQUNoRCxTQUFTRyxJQUFJQyxFQUFFLEVBQUVDLElBQUk7SUFDbkJMLElBQUksQ0FBQ0ksR0FBRyxHQUFHQztJQUNYTCxJQUFJLENBQUNLLEtBQUssR0FBR0Q7QUFDZjtBQUNBLDhCQUE4QjtBQUM5QixTQUFTRSxJQUFJRixFQUFFLEVBQUVDLElBQUk7SUFDbkJMLElBQUksQ0FBQ0ksR0FBRyxHQUFHQztBQUNiO0FBRUEsaUJBQWlCO0FBQ2pCRixJQUFJLHdCQUF3QjtBQUM1QixrQ0FBa0M7QUFDbEMsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0REEsSUFBSSx3QkFBd0I7QUFDNUJBLElBQUksd0JBQXdCO0FBQzVCQSxJQUFJLHdCQUF3QjtBQUM1QkEsSUFBSSx3QkFBd0I7QUFDNUJBLElBQUksd0JBQXdCO0FBQzVCQSxJQUFJLHlCQUF5QjtBQUM3QkEsSUFBSSx5QkFBeUI7QUFDN0JBLElBQUkseUJBQXlCO0FBQzdCQSxJQUFJLHlCQUF5QjtBQUM3Qiw0REFBNEQ7QUFDNURBLElBQUksZUFBZTtBQUVuQkEsSUFBSSxxQkFBcUI7QUFFekJBLElBQUksZ0JBQWdCO0FBRXBCQSxJQUFJLGlCQUFpQjtBQUNyQixpREFBaUQ7QUFDakRBLElBQUksaUJBQWlCO0FBQ3JCQSxJQUFJLDBCQUEwQjtBQUM5QkEsSUFBSSwwQkFBMEI7QUFDOUJBLElBQUksMEJBQTBCO0FBQzlCQSxJQUFJLDBCQUEwQjtBQUM5QkEs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SSxhQUFhO0FBQ2pCQSxJQUFJLGFBQWE7QUFDakJBLElBQUksYUFBYTtBQUNqQkEsSUFBSSxhQUFhLDBCQUEwQixxQkFBcUI7QUFDaEVBLElBQUksYUFBYSw2QkFBNkIscUJBQXFCO0FBQ25FQSxJQUFJLGFBQWE7QUFDakJBLElBQUksYUFBYTtBQUNqQkEsSUFBSSxhQUFhO0FBQ2pCQSxJQUFJLGFBQWE7QUFDakJILElBQUksYUFBYTtBQUNqQkEsSUFBSSxhQUFhO0FBQ2pCRyxJQUFJLGFBQWE7QUFDakJBLElBQUksYUFBYSxzQkFBc0IscUJBQXFCO0FBQzVESCxJQUFJLGFBQWE7QUFDakJHLElBQUksYUFBYTtBQUNqQkgsSUFBSSxhQUFhO0FBQ2pCRyxJQUFJLGFBQWE7QUFDakJBLElBQUksYUFBYTtBQUVqQix1QkFBdUI7QUFDdkJILElBQUksMkJBQTJCO0FBQy9CQSxJQUFJLHFCQUFxQjtBQUN6QkEsSUFBSSxxQkFBcUI7QUFDekJBLElBQUkscUJBQXFCO0FBQ3pCQSxJQUFJLHFCQUFxQjtBQUN6QkEsSUFBSSxxQkFBcUI7QUFDekJBLElBQUkscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL29pZHMuanM/NmEyYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE9iamVjdCBJRHMgZm9yIEFTTi4xLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTMgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xuXG5mb3JnZS5wa2kgPSBmb3JnZS5wa2kgfHwge307XG52YXIgb2lkcyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtpLm9pZHMgPSBmb3JnZS5vaWRzID0gZm9yZ2Uub2lkcyB8fCB7fTtcblxuLy8gc2V0IGlkIHRvIG5hbWUgbWFwcGluZyBhbmQgbmFtZSB0byBpZCBtYXBwaW5nXG5mdW5jdGlvbiBfSU4oaWQsIG5hbWUpIHtcbiAgb2lkc1tpZF0gPSBuYW1lO1xuICBvaWRzW25hbWVdID0gaWQ7XG59XG4vLyBzZXQgaWQgdG8gbmFtZSBtYXBwaW5nIG9ubHlcbmZ1bmN0aW9uIF9JXyhpZCwgbmFtZSkge1xuICBvaWRzW2lkXSA9IG5hbWU7XG59XG5cbi8vIGFsZ29yaXRobSBPSURzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4xJywgJ3JzYUVuY3J5cHRpb24nKTtcbi8vIE5vdGU6IG1kMiAmIG1kNCBub3QgaW1wbGVtZW50ZWRcbi8vX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMicsICdtZDJXaXRoUlNBRW5jcnlwdGlvbicpO1xuLy9fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4zJywgJ21kNFdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS40JywgJ21kNVdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS41JywgJ3NoYTFXaXRoUlNBRW5jcnlwdGlvbicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuNycsICdSU0FFUy1PQUVQJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS44JywgJ21nZjEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjknLCAncFNwZWNpZmllZCcpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMTAnLCAnUlNBU1NBLVBTUycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMTEnLCAnc2hhMjU2V2l0aFJTQUVuY3J5cHRpb24nKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjEyJywgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4xMycsICdzaGE1MTJXaXRoUlNBRW5jcnlwdGlvbicpO1xuLy8gRWR3YXJkcy1jdXJ2ZSBEaWdpdGFsIFNpZ25hdHVyZSBBbGdvcml0aG0gKEVkRFNBKSBFZDI1NTE5XG5fSU4oJzEuMy4xMDEuMTEyJywgJ0VkRFNBMjU1MTknKTtcblxuX0lOKCcxLjIuODQwLjEwMDQwLjQuMycsICdkc2Etd2l0aC1zaGExJyk7XG5cbl9JTignMS4zLjE0LjMuMi43JywgJ2Rlc0NCQycpO1xuXG5fSU4oJzEuMy4xNC4zLjIuMjYnLCAnc2hhMScpO1xuLy8gRGVwcmVjYXRlZCBlcXVpdmFsZW50IG9mIHNoYTFXaXRoUlNBRW5jcnlwdGlvblxuX0lOKCcxLjMuMTQuMy4yLjI5JywgJ3NoYTFXaXRoUlNBU2lnbmF0dXJlJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjEnLCAnc2hhMjU2Jyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjInLCAnc2hhMzg0Jyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjMnLCAnc2hhNTEyJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjQnLCAnc2hhMjI0Jyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjUnLCAnc2hhNTEyLTIyNCcpO1xuX0lOKCcyLjE2Ljg0MC4xLjEwMS4zLjQuMi42JywgJ3NoYTUxMi0yNTYnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMi4yJywgJ21kMicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4yLjUnLCAnbWQ1Jyk7XG5cbi8vIHBrY3MjNyBjb250ZW50IHR5cGVzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuNy4xJywgJ2RhdGEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjInLCAnc2lnbmVkRGF0YScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjcuMycsICdlbnZlbG9wZWREYXRhJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuNy40JywgJ3NpZ25lZEFuZEVudmVsb3BlZERhdGEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjUnLCAnZGlnZXN0ZWREYXRhJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuNy42JywgJ2VuY3J5cHRlZERhdGEnKTtcblxuLy8gcGtjcyM5IG9pZHNcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjEnLCAnZW1haWxBZGRyZXNzJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS4yJywgJ3Vuc3RydWN0dXJlZE5hbWUnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjMnLCAnY29udGVudFR5cGUnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjQnLCAnbWVzc2FnZURpZ2VzdCcpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuNScsICdzaWduaW5nVGltZScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuNicsICdjb3VudGVyU2lnbmF0dXJlJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS43JywgJ2NoYWxsZW5nZVBhc3N3b3JkJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS44JywgJ3Vuc3RydWN0dXJlZEFkZHJlc3MnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjE0JywgJ2V4dGVuc2lvblJlcXVlc3QnKTtcblxuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMjAnLCAnZnJpZW5kbHlOYW1lJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS4yMScsICdsb2NhbEtleUlkJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS4yMi4xJywgJ3g1MDlDZXJ0aWZpY2F0ZScpO1xuXG4vLyBwa2NzIzEyIHNhZmUgYmFnc1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuMScsICdrZXlCYWcnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xMC4xLjInLCAncGtjczhTaHJvdWRlZEtleUJhZycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuMycsICdjZXJ0QmFnJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS40JywgJ2NybEJhZycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuNScsICdzZWNyZXRCYWcnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xMC4xLjYnLCAnc2FmZUNvbnRlbnRzQmFnJyk7XG5cbi8vIHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gZm9yIHBrY3MjMTJcbl9JTignMS4yLjg0MC4xMTM1NDkuMS41LjEzJywgJ3BrY3M1UEJFUzInKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS41LjEyJywgJ3BrY3M1UEJLREYyJyk7XG5cbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjEnLCAncGJlV2l0aFNIQUFuZDEyOEJpdFJDNCcpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEuMicsICdwYmVXaXRoU0hBQW5kNDBCaXRSQzQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjMnLCAncGJlV2l0aFNIQUFuZDMtS2V5VHJpcGxlREVTLUNCQycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEuNCcsICdwYmVXaXRoU0hBQW5kMi1LZXlUcmlwbGVERVMtQ0JDJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMS41JywgJ3BiZVdpdGhTSEFBbmQxMjhCaXRSQzItQ0JDJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMS42JywgJ3BiZXdpdGhTSEFBbmQ0MEJpdFJDMi1DQkMnKTtcblxuLy8gaG1hYyBPSURzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjIuNycsICdobWFjV2l0aFNIQTEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMi44JywgJ2htYWNXaXRoU0hBMjI0Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjIuOScsICdobWFjV2l0aFNIQTI1NicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4yLjEwJywgJ2htYWNXaXRoU0hBMzg0Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjIuMTEnLCAnaG1hY1dpdGhTSEE1MTInKTtcblxuLy8gc3ltbWV0cmljIGtleSBhbGdvcml0aG0gb2lkc1xuX0lOKCcxLjIuODQwLjExMzU0OS4zLjcnLCAnZGVzLUVERTMtQ0JDJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4xLjInLCAnYWVzMTI4LUNCQycpO1xuX0lOKCcyLjE2Ljg0MC4xLjEwMS4zLjQuMS4yMicsICdhZXMxOTItQ0JDJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4xLjQyJywgJ2FlczI1Ni1DQkMnKTtcblxuLy8gY2VydGlmaWNhdGUgaXNzdWVyL3N1YmplY3QgT0lEc1xuX0lOKCcyLjUuNC4zJywgJ2NvbW1vbk5hbWUnKTtcbl9JTignMi41LjQuNCcsICdzdXJuYW1lJyk7XG5fSU4oJzIuNS40LjUnLCAnc2VyaWFsTnVtYmVyJyk7XG5fSU4oJzIuNS40LjYnLCAnY291bnRyeU5hbWUnKTtcbl9JTignMi41LjQuNycsICdsb2NhbGl0eU5hbWUnKTtcbl9JTignMi41LjQuOCcsICdzdGF0ZU9yUHJvdmluY2VOYW1lJyk7XG5fSU4oJzIuNS40LjknLCAnc3RyZWV0QWRkcmVzcycpO1xuX0lOKCcyLjUuNC4xMCcsICdvcmdhbml6YXRpb25OYW1lJyk7XG5fSU4oJzIuNS40LjExJywgJ29yZ2FuaXphdGlvbmFsVW5pdE5hbWUnKTtcbl9JTignMi41LjQuMTInLCAndGl0bGUnKTtcbl9JTignMi41LjQuMTMnLCAnZGVzY3JpcHRpb24nKTtcbl9JTignMi41LjQuMTUnLCAnYnVzaW5lc3NDYXRlZ29yeScpO1xuX0lOKCcyLjUuNC4xNycsICdwb3N0YWxDb2RlJyk7XG5fSU4oJzIuNS40LjQyJywgJ2dpdmVuTmFtZScpO1xuX0lOKCcxLjMuNi4xLjQuMS4zMTEuNjAuMi4xLjInLCAnanVyaXNkaWN0aW9uT2ZJbmNvcnBvcmF0aW9uU3RhdGVPclByb3ZpbmNlTmFtZScpO1xuX0lOKCcxLjMuNi4xLjQuMS4zMTEuNjAuMi4xLjMnLCAnanVyaXNkaWN0aW9uT2ZJbmNvcnBvcmF0aW9uQ291bnRyeU5hbWUnKTtcblxuLy8gWC41MDkgZXh0ZW5zaW9uIE9JRHNcbl9JTignMi4xNi44NDAuMS4xMTM3MzAuMS4xJywgJ25zQ2VydFR5cGUnKTtcbl9JTignMi4xNi44NDAuMS4xMTM3MzAuMS4xMycsICduc0NvbW1lbnQnKTsgLy8gZGVwcmVjYXRlZCBpbiB0aGVvcnk7IHN0aWxsIHdpZGVseSB1c2VkXG5fSV8oJzIuNS4yOS4xJywgJ2F1dGhvcml0eUtleUlkZW50aWZpZXInKTsgLy8gZGVwcmVjYXRlZCwgdXNlIC4zNVxuX0lfKCcyLjUuMjkuMicsICdrZXlBdHRyaWJ1dGVzJyk7IC8vIG9ic29sZXRlIHVzZSAuMzcgb3IgLjE1XG5fSV8oJzIuNS4yOS4zJywgJ2NlcnRpZmljYXRlUG9saWNpZXMnKTsgLy8gZGVwcmVjYXRlZCwgdXNlIC4zMlxuX0lfKCcyLjUuMjkuNCcsICdrZXlVc2FnZVJlc3RyaWN0aW9uJyk7IC8vIG9ic29sZXRlIHVzZSAuMzcgb3IgLjE1XG5fSV8oJzIuNS4yOS41JywgJ3BvbGljeU1hcHBpbmcnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjMzXG5fSV8oJzIuNS4yOS42JywgJ3N1YnRyZWVzQ29uc3RyYWludCcpOyAvLyBvYnNvbGV0ZSB1c2UgLjMwXG5fSV8oJzIuNS4yOS43JywgJ3N1YmplY3RBbHROYW1lJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4xN1xuX0lfKCcyLjUuMjkuOCcsICdpc3N1ZXJBbHROYW1lJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4xOFxuX0lfKCcyLjUuMjkuOScsICdzdWJqZWN0RGlyZWN0b3J5QXR0cmlidXRlcycpO1xuX0lfKCcyLjUuMjkuMTAnLCAnYmFzaWNDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMTlcbl9JXygnMi41LjI5LjExJywgJ25hbWVDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMzBcbl9JXygnMi41LjI5LjEyJywgJ3BvbGljeUNvbnN0cmFpbnRzJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4zNlxuX0lfKCcyLjUuMjkuMTMnLCAnYmFzaWNDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMTlcbl9JTignMi41LjI5LjE0JywgJ3N1YmplY3RLZXlJZGVudGlmaWVyJyk7XG5fSU4oJzIuNS4yOS4xNScsICdrZXlVc2FnZScpO1xuX0lfKCcyLjUuMjkuMTYnLCAncHJpdmF0ZUtleVVzYWdlUGVyaW9kJyk7XG5fSU4oJzIuNS4yOS4xNycsICdzdWJqZWN0QWx0TmFtZScpO1xuX0lOKCcyLjUuMjkuMTgnLCAnaXNzdWVyQWx0TmFtZScpO1xuX0lOKCcyLjUuMjkuMTknLCAnYmFzaWNDb25zdHJhaW50cycpO1xuX0lfKCcyLjUuMjkuMjAnLCAnY1JMTnVtYmVyJyk7XG5fSV8oJzIuNS4yOS4yMScsICdjUkxSZWFzb24nKTtcbl9JXygnMi41LjI5LjIyJywgJ2V4cGlyYXRpb25EYXRlJyk7XG5fSV8oJzIuNS4yOS4yMycsICdpbnN0cnVjdGlvbkNvZGUnKTtcbl9JXygnMi41LjI5LjI0JywgJ2ludmFsaWRpdHlEYXRlJyk7XG5fSV8oJzIuNS4yOS4yNScsICdjUkxEaXN0cmlidXRpb25Qb2ludHMnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjMxXG5fSV8oJzIuNS4yOS4yNicsICdpc3N1aW5nRGlzdHJpYnV0aW9uUG9pbnQnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjI4XG5fSV8oJzIuNS4yOS4yNycsICdkZWx0YUNSTEluZGljYXRvcicpO1xuX0lfKCcyLjUuMjkuMjgnLCAnaXNzdWluZ0Rpc3RyaWJ1dGlvblBvaW50Jyk7XG5fSV8oJzIuNS4yOS4yOScsICdjZXJ0aWZpY2F0ZUlzc3VlcicpO1xuX0lfKCcyLjUuMjkuMzAnLCAnbmFtZUNvbnN0cmFpbnRzJyk7XG5fSU4oJzIuNS4yOS4zMScsICdjUkxEaXN0cmlidXRpb25Qb2ludHMnKTtcbl9JTignMi41LjI5LjMyJywgJ2NlcnRpZmljYXRlUG9saWNpZXMnKTtcbl9JXygnMi41LjI5LjMzJywgJ3BvbGljeU1hcHBpbmdzJyk7XG5fSV8oJzIuNS4yOS4zNCcsICdwb2xpY3lDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMzZcbl9JTignMi41LjI5LjM1JywgJ2F1dGhvcml0eUtleUlkZW50aWZpZXInKTtcbl9JXygnMi41LjI5LjM2JywgJ3BvbGljeUNvbnN0cmFpbnRzJyk7XG5fSU4oJzIuNS4yOS4zNycsICdleHRLZXlVc2FnZScpO1xuX0lfKCcyLjUuMjkuNDYnLCAnZnJlc2hlc3RDUkwnKTtcbl9JXygnMi41LjI5LjU0JywgJ2luaGliaXRBbnlQb2xpY3knKTtcblxuLy8gZXh0S2V5VXNhZ2UgcHVycG9zZXNcbl9JTignMS4zLjYuMS40LjEuMTExMjkuMi40LjInLCAndGltZXN0YW1wTGlzdCcpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjEuMScsICdhdXRob3JpdHlJbmZvQWNjZXNzJyk7XG5fSU4oJzEuMy42LjEuNS41LjcuMy4xJywgJ3NlcnZlckF1dGgnKTtcbl9JTignMS4zLjYuMS41LjUuNy4zLjInLCAnY2xpZW50QXV0aCcpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjMuMycsICdjb2RlU2lnbmluZycpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjMuNCcsICdlbWFpbFByb3RlY3Rpb24nKTtcbl9JTignMS4zLjYuMS41LjUuNy4zLjgnLCAndGltZVN0YW1waW5nJyk7XG4iXSwibmFtZXMiOlsiZm9yZ2UiLCJyZXF1aXJlIiwicGtpIiwib2lkcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJfSU4iLCJpZCIsIm5hbWUiLCJfSV8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/oids.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/pbe.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/pbe.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Password-based encryption functions.\n *\n * @author Dave Longley\n * @author Stefan Siegl <stesie@brokenpipe.de>\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n *\n * An EncryptedPrivateKeyInfo:\n *\n * EncryptedPrivateKeyInfo ::= SEQUENCE {\n *   encryptionAlgorithm  EncryptionAlgorithmIdentifier,\n *   encryptedData        EncryptedData }\n *\n * EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier\n *\n * EncryptedData ::= OCTET STRING\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./aes */ \"(rsc)/./node_modules/node-forge/lib/aes.js\");\n__webpack_require__(/*! ./asn1 */ \"(rsc)/./node_modules/node-forge/lib/asn1.js\");\n__webpack_require__(/*! ./des */ \"(rsc)/./node_modules/node-forge/lib/des.js\");\n__webpack_require__(/*! ./md */ \"(rsc)/./node_modules/node-forge/lib/md.js\");\n__webpack_require__(/*! ./oids */ \"(rsc)/./node_modules/node-forge/lib/oids.js\");\n__webpack_require__(/*! ./pbkdf2 */ \"(rsc)/./node_modules/node-forge/lib/pbkdf2.js\");\n__webpack_require__(/*! ./pem */ \"(rsc)/./node_modules/node-forge/lib/pem.js\");\n__webpack_require__(/*! ./random */ \"(rsc)/./node_modules/node-forge/lib/random.js\");\n__webpack_require__(/*! ./rc2 */ \"(rsc)/./node_modules/node-forge/lib/rc2.js\");\n__webpack_require__(/*! ./rsa */ \"(rsc)/./node_modules/node-forge/lib/rsa.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\nif (typeof BigInteger === \"undefined\") {\n    var BigInteger = forge.jsbn.BigInteger;\n}\n// shortcut for asn.1 API\nvar asn1 = forge.asn1;\n/* Password-based encryption implementation. */ var pki = forge.pki = forge.pki || {};\nmodule.exports = pki.pbe = forge.pbe = forge.pbe || {};\nvar oids = pki.oids;\n// validator for an EncryptedPrivateKeyInfo structure\n// Note: Currently only works w/algorithm params\nvar encryptedPrivateKeyValidator = {\n    name: \"EncryptedPrivateKeyInfo\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"EncryptedPrivateKeyInfo.encryptionAlgorithm\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    name: \"AlgorithmIdentifier.algorithm\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OID,\n                    constructed: false,\n                    capture: \"encryptionOid\"\n                },\n                {\n                    name: \"AlgorithmIdentifier.parameters\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.SEQUENCE,\n                    constructed: true,\n                    captureAsn1: \"encryptionParams\"\n                }\n            ]\n        },\n        {\n            // encryptedData\n            name: \"EncryptedPrivateKeyInfo.encryptedData\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OCTETSTRING,\n            constructed: false,\n            capture: \"encryptedData\"\n        }\n    ]\n};\n// validator for a PBES2Algorithms structure\n// Note: Currently only works w/PBKDF2 + AES encryption schemes\nvar PBES2AlgorithmsValidator = {\n    name: \"PBES2Algorithms\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"PBES2Algorithms.keyDerivationFunc\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    name: \"PBES2Algorithms.keyDerivationFunc.oid\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OID,\n                    constructed: false,\n                    capture: \"kdfOid\"\n                },\n                {\n                    name: \"PBES2Algorithms.params\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.SEQUENCE,\n                    constructed: true,\n                    value: [\n                        {\n                            name: \"PBES2Algorithms.params.salt\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.OCTETSTRING,\n                            constructed: false,\n                            capture: \"kdfSalt\"\n                        },\n                        {\n                            name: \"PBES2Algorithms.params.iterationCount\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.INTEGER,\n                            constructed: false,\n                            capture: \"kdfIterationCount\"\n                        },\n                        {\n                            name: \"PBES2Algorithms.params.keyLength\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.INTEGER,\n                            constructed: false,\n                            optional: true,\n                            capture: \"keyLength\"\n                        },\n                        {\n                            // prf\n                            name: \"PBES2Algorithms.params.prf\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.SEQUENCE,\n                            constructed: true,\n                            optional: true,\n                            value: [\n                                {\n                                    name: \"PBES2Algorithms.params.prf.algorithm\",\n                                    tagClass: asn1.Class.UNIVERSAL,\n                                    type: asn1.Type.OID,\n                                    constructed: false,\n                                    capture: \"prfOid\"\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ]\n        },\n        {\n            name: \"PBES2Algorithms.encryptionScheme\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    name: \"PBES2Algorithms.encryptionScheme.oid\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OID,\n                    constructed: false,\n                    capture: \"encOid\"\n                },\n                {\n                    name: \"PBES2Algorithms.encryptionScheme.iv\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OCTETSTRING,\n                    constructed: false,\n                    capture: \"encIv\"\n                }\n            ]\n        }\n    ]\n};\nvar pkcs12PbeParamsValidator = {\n    name: \"pkcs-12PbeParams\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"pkcs-12PbeParams.salt\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OCTETSTRING,\n            constructed: false,\n            capture: \"salt\"\n        },\n        {\n            name: \"pkcs-12PbeParams.iterations\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"iterations\"\n        }\n    ]\n};\n/**\n * Encrypts a ASN.1 PrivateKeyInfo object, producing an EncryptedPrivateKeyInfo.\n *\n * PBES2Algorithms ALGORITHM-IDENTIFIER ::=\n *   { {PBES2-params IDENTIFIED BY id-PBES2}, ...}\n *\n * id-PBES2 OBJECT IDENTIFIER ::= {pkcs-5 13}\n *\n * PBES2-params ::= SEQUENCE {\n *   keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},\n *   encryptionScheme AlgorithmIdentifier {{PBES2-Encs}}\n * }\n *\n * PBES2-KDFs ALGORITHM-IDENTIFIER ::=\n *   { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }\n *\n * PBES2-Encs ALGORITHM-IDENTIFIER ::= { ... }\n *\n * PBKDF2-params ::= SEQUENCE {\n *   salt CHOICE {\n *     specified OCTET STRING,\n *     otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}\n *   },\n *   iterationCount INTEGER (1..MAX),\n *   keyLength INTEGER (1..MAX) OPTIONAL,\n *   prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1\n * }\n *\n * @param obj the ASN.1 PrivateKeyInfo object.\n * @param password the password to encrypt with.\n * @param options:\n *          algorithm the encryption algorithm to use\n *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.\n *          count the iteration count to use.\n *          saltSize the salt size to use.\n *          prfAlgorithm the PRF message digest algorithm to use\n *            ('sha1', 'sha224', 'sha256', 'sha384', 'sha512')\n *\n * @return the ASN.1 EncryptedPrivateKeyInfo.\n */ pki.encryptPrivateKeyInfo = function(obj, password, options) {\n    // set default options\n    options = options || {};\n    options.saltSize = options.saltSize || 8;\n    options.count = options.count || 2048;\n    options.algorithm = options.algorithm || \"aes128\";\n    options.prfAlgorithm = options.prfAlgorithm || \"sha1\";\n    // generate PBE params\n    var salt = forge.random.getBytesSync(options.saltSize);\n    var count = options.count;\n    var countBytes = asn1.integerToDer(count);\n    var dkLen;\n    var encryptionAlgorithm;\n    var encryptedData;\n    if (options.algorithm.indexOf(\"aes\") === 0 || options.algorithm === \"des\") {\n        // do PBES2\n        var ivLen, encOid, cipherFn;\n        switch(options.algorithm){\n            case \"aes128\":\n                dkLen = 16;\n                ivLen = 16;\n                encOid = oids[\"aes128-CBC\"];\n                cipherFn = forge.aes.createEncryptionCipher;\n                break;\n            case \"aes192\":\n                dkLen = 24;\n                ivLen = 16;\n                encOid = oids[\"aes192-CBC\"];\n                cipherFn = forge.aes.createEncryptionCipher;\n                break;\n            case \"aes256\":\n                dkLen = 32;\n                ivLen = 16;\n                encOid = oids[\"aes256-CBC\"];\n                cipherFn = forge.aes.createEncryptionCipher;\n                break;\n            case \"des\":\n                dkLen = 8;\n                ivLen = 8;\n                encOid = oids[\"desCBC\"];\n                cipherFn = forge.des.createEncryptionCipher;\n                break;\n            default:\n                var error = new Error(\"Cannot encrypt private key. Unknown encryption algorithm.\");\n                error.algorithm = options.algorithm;\n                throw error;\n        }\n        // get PRF message digest\n        var prfAlgorithm = \"hmacWith\" + options.prfAlgorithm.toUpperCase();\n        var md = prfAlgorithmToMessageDigest(prfAlgorithm);\n        // encrypt private key using pbe SHA-1 and AES/DES\n        var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);\n        var iv = forge.random.getBytesSync(ivLen);\n        var cipher = cipherFn(dk);\n        cipher.start(iv);\n        cipher.update(asn1.toDer(obj));\n        cipher.finish();\n        encryptedData = cipher.output.getBytes();\n        // get PBKDF2-params\n        var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);\n        encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids[\"pkcs5PBES2\"]).getBytes()),\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                // keyDerivationFunc\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids[\"pkcs5PBKDF2\"]).getBytes()),\n                    // PBKDF2-params\n                    params\n                ]),\n                // encryptionScheme\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(encOid).getBytes()),\n                    // iv\n                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)\n                ])\n            ])\n        ]);\n    } else if (options.algorithm === \"3des\") {\n        // Do PKCS12 PBE\n        dkLen = 24;\n        var saltBytes = new forge.util.ByteBuffer(salt);\n        var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);\n        var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);\n        var cipher = forge.des.createEncryptionCipher(dk);\n        cipher.start(iv);\n        cipher.update(asn1.toDer(obj));\n        cipher.finish();\n        encryptedData = cipher.output.getBytes();\n        encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids[\"pbeWithSHAAnd3-KeyTripleDES-CBC\"]).getBytes()),\n            // pkcs-12PbeParams\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                // salt\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),\n                // iteration count\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())\n            ])\n        ]);\n    } else {\n        var error = new Error(\"Cannot encrypt private key. Unknown encryption algorithm.\");\n        error.algorithm = options.algorithm;\n        throw error;\n    }\n    // EncryptedPrivateKeyInfo\n    var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // encryptionAlgorithm\n        encryptionAlgorithm,\n        // encryptedData\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, encryptedData)\n    ]);\n    return rval;\n};\n/**\n * Decrypts a ASN.1 PrivateKeyInfo object.\n *\n * @param obj the ASN.1 EncryptedPrivateKeyInfo object.\n * @param password the password to decrypt with.\n *\n * @return the ASN.1 PrivateKeyInfo on success, null on failure.\n */ pki.decryptPrivateKeyInfo = function(obj, password) {\n    var rval = null;\n    // get PBE params\n    var capture = {};\n    var errors = [];\n    if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {\n        var error = new Error(\"Cannot read encrypted private key. \" + \"ASN.1 object is not a supported EncryptedPrivateKeyInfo.\");\n        error.errors = errors;\n        throw error;\n    }\n    // get cipher\n    var oid = asn1.derToOid(capture.encryptionOid);\n    var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);\n    // get encrypted data\n    var encrypted = forge.util.createBuffer(capture.encryptedData);\n    cipher.update(encrypted);\n    if (cipher.finish()) {\n        rval = asn1.fromDer(cipher.output);\n    }\n    return rval;\n};\n/**\n * Converts a EncryptedPrivateKeyInfo to PEM format.\n *\n * @param epki the EncryptedPrivateKeyInfo.\n * @param maxline the maximum characters per line, defaults to 64.\n *\n * @return the PEM-formatted encrypted private key.\n */ pki.encryptedPrivateKeyToPem = function(epki, maxline) {\n    // convert to DER, then PEM-encode\n    var msg = {\n        type: \"ENCRYPTED PRIVATE KEY\",\n        body: asn1.toDer(epki).getBytes()\n    };\n    return forge.pem.encode(msg, {\n        maxline: maxline\n    });\n};\n/**\n * Converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format. Decryption\n * is not performed.\n *\n * @param pem the EncryptedPrivateKeyInfo in PEM-format.\n *\n * @return the ASN.1 EncryptedPrivateKeyInfo.\n */ pki.encryptedPrivateKeyFromPem = function(pem) {\n    var msg = forge.pem.decode(pem)[0];\n    if (msg.type !== \"ENCRYPTED PRIVATE KEY\") {\n        var error = new Error(\"Could not convert encrypted private key from PEM; \" + 'PEM header type is \"ENCRYPTED PRIVATE KEY\".');\n        error.headerType = msg.type;\n        throw error;\n    }\n    if (msg.procType && msg.procType.type === \"ENCRYPTED\") {\n        throw new Error(\"Could not convert encrypted private key from PEM; \" + \"PEM is encrypted.\");\n    }\n    // convert DER to ASN.1 object\n    return asn1.fromDer(msg.body);\n};\n/**\n * Encrypts an RSA private key. By default, the key will be wrapped in\n * a PrivateKeyInfo and encrypted to produce a PKCS#8 EncryptedPrivateKeyInfo.\n * This is the standard, preferred way to encrypt a private key.\n *\n * To produce a non-standard PEM-encrypted private key that uses encapsulated\n * headers to indicate the encryption algorithm (old-style non-PKCS#8 OpenSSL\n * private key encryption), set the 'legacy' option to true. Note: Using this\n * option will cause the iteration count to be forced to 1.\n *\n * Note: The 'des' algorithm is supported, but it is not considered to be\n * secure because it only uses a single 56-bit key. If possible, it is highly\n * recommended that a different algorithm be used.\n *\n * @param rsaKey the RSA key to encrypt.\n * @param password the password to use.\n * @param options:\n *          algorithm: the encryption algorithm to use\n *            ('aes128', 'aes192', 'aes256', '3des', 'des').\n *          count: the iteration count to use.\n *          saltSize: the salt size to use.\n *          legacy: output an old non-PKCS#8 PEM-encrypted+encapsulated\n *            headers (DEK-Info) private key.\n *\n * @return the PEM-encoded ASN.1 EncryptedPrivateKeyInfo.\n */ pki.encryptRsaPrivateKey = function(rsaKey, password, options) {\n    // standard PKCS#8\n    options = options || {};\n    if (!options.legacy) {\n        // encrypt PrivateKeyInfo\n        var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));\n        rval = pki.encryptPrivateKeyInfo(rval, password, options);\n        return pki.encryptedPrivateKeyToPem(rval);\n    }\n    // legacy non-PKCS#8\n    var algorithm;\n    var iv;\n    var dkLen;\n    var cipherFn;\n    switch(options.algorithm){\n        case \"aes128\":\n            algorithm = \"AES-128-CBC\";\n            dkLen = 16;\n            iv = forge.random.getBytesSync(16);\n            cipherFn = forge.aes.createEncryptionCipher;\n            break;\n        case \"aes192\":\n            algorithm = \"AES-192-CBC\";\n            dkLen = 24;\n            iv = forge.random.getBytesSync(16);\n            cipherFn = forge.aes.createEncryptionCipher;\n            break;\n        case \"aes256\":\n            algorithm = \"AES-256-CBC\";\n            dkLen = 32;\n            iv = forge.random.getBytesSync(16);\n            cipherFn = forge.aes.createEncryptionCipher;\n            break;\n        case \"3des\":\n            algorithm = \"DES-EDE3-CBC\";\n            dkLen = 24;\n            iv = forge.random.getBytesSync(8);\n            cipherFn = forge.des.createEncryptionCipher;\n            break;\n        case \"des\":\n            algorithm = \"DES-CBC\";\n            dkLen = 8;\n            iv = forge.random.getBytesSync(8);\n            cipherFn = forge.des.createEncryptionCipher;\n            break;\n        default:\n            var error = new Error(\"Could not encrypt RSA private key; unsupported \" + 'encryption algorithm \"' + options.algorithm + '\".');\n            error.algorithm = options.algorithm;\n            throw error;\n    }\n    // encrypt private key using OpenSSL legacy key derivation\n    var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);\n    var cipher = cipherFn(dk);\n    cipher.start(iv);\n    cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));\n    cipher.finish();\n    var msg = {\n        type: \"RSA PRIVATE KEY\",\n        procType: {\n            version: \"4\",\n            type: \"ENCRYPTED\"\n        },\n        dekInfo: {\n            algorithm: algorithm,\n            parameters: forge.util.bytesToHex(iv).toUpperCase()\n        },\n        body: cipher.output.getBytes()\n    };\n    return forge.pem.encode(msg);\n};\n/**\n * Decrypts an RSA private key.\n *\n * @param pem the PEM-formatted EncryptedPrivateKeyInfo to decrypt.\n * @param password the password to use.\n *\n * @return the RSA key on success, null on failure.\n */ pki.decryptRsaPrivateKey = function(pem, password) {\n    var rval = null;\n    var msg = forge.pem.decode(pem)[0];\n    if (msg.type !== \"ENCRYPTED PRIVATE KEY\" && msg.type !== \"PRIVATE KEY\" && msg.type !== \"RSA PRIVATE KEY\") {\n        var error = new Error(\"Could not convert private key from PEM; PEM header type \" + 'is not \"ENCRYPTED PRIVATE KEY\", \"PRIVATE KEY\", or \"RSA PRIVATE KEY\".');\n        error.headerType = error;\n        throw error;\n    }\n    if (msg.procType && msg.procType.type === \"ENCRYPTED\") {\n        var dkLen;\n        var cipherFn;\n        switch(msg.dekInfo.algorithm){\n            case \"DES-CBC\":\n                dkLen = 8;\n                cipherFn = forge.des.createDecryptionCipher;\n                break;\n            case \"DES-EDE3-CBC\":\n                dkLen = 24;\n                cipherFn = forge.des.createDecryptionCipher;\n                break;\n            case \"AES-128-CBC\":\n                dkLen = 16;\n                cipherFn = forge.aes.createDecryptionCipher;\n                break;\n            case \"AES-192-CBC\":\n                dkLen = 24;\n                cipherFn = forge.aes.createDecryptionCipher;\n                break;\n            case \"AES-256-CBC\":\n                dkLen = 32;\n                cipherFn = forge.aes.createDecryptionCipher;\n                break;\n            case \"RC2-40-CBC\":\n                dkLen = 5;\n                cipherFn = function(key) {\n                    return forge.rc2.createDecryptionCipher(key, 40);\n                };\n                break;\n            case \"RC2-64-CBC\":\n                dkLen = 8;\n                cipherFn = function(key) {\n                    return forge.rc2.createDecryptionCipher(key, 64);\n                };\n                break;\n            case \"RC2-128-CBC\":\n                dkLen = 16;\n                cipherFn = function(key) {\n                    return forge.rc2.createDecryptionCipher(key, 128);\n                };\n                break;\n            default:\n                var error = new Error(\"Could not decrypt private key; unsupported \" + 'encryption algorithm \"' + msg.dekInfo.algorithm + '\".');\n                error.algorithm = msg.dekInfo.algorithm;\n                throw error;\n        }\n        // use OpenSSL legacy key derivation\n        var iv = forge.util.hexToBytes(msg.dekInfo.parameters);\n        var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);\n        var cipher = cipherFn(dk);\n        cipher.start(iv);\n        cipher.update(forge.util.createBuffer(msg.body));\n        if (cipher.finish()) {\n            rval = cipher.output.getBytes();\n        } else {\n            return rval;\n        }\n    } else {\n        rval = msg.body;\n    }\n    if (msg.type === \"ENCRYPTED PRIVATE KEY\") {\n        rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);\n    } else {\n        // decryption already performed above\n        rval = asn1.fromDer(rval);\n    }\n    if (rval !== null) {\n        rval = pki.privateKeyFromAsn1(rval);\n    }\n    return rval;\n};\n/**\n * Derives a PKCS#12 key.\n *\n * @param password the password to derive the key material from, null or\n *          undefined for none.\n * @param salt the salt, as a ByteBuffer, to use.\n * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).\n * @param iter the iteration count.\n * @param n the number of bytes to derive from the password.\n * @param md the message digest to use, defaults to SHA-1.\n *\n * @return a ByteBuffer with the bytes derived from the password.\n */ pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {\n    var j, l;\n    if (typeof md === \"undefined\" || md === null) {\n        if (!(\"sha1\" in forge.md)) {\n            throw new Error('\"sha1\" hash algorithm unavailable.');\n        }\n        md = forge.md.sha1.create();\n    }\n    var u = md.digestLength;\n    var v = md.blockLength;\n    var result = new forge.util.ByteBuffer();\n    /* Convert password to Unicode byte buffer + trailing 0-byte. */ var passBuf = new forge.util.ByteBuffer();\n    if (password !== null && password !== undefined) {\n        for(l = 0; l < password.length; l++){\n            passBuf.putInt16(password.charCodeAt(l));\n        }\n        passBuf.putInt16(0);\n    }\n    /* Length of salt and password in BYTES. */ var p = passBuf.length();\n    var s = salt.length();\n    /* 1. Construct a string, D (the \"diversifier\"), by concatenating\n        v copies of ID. */ var D = new forge.util.ByteBuffer();\n    D.fillWithByte(id, v);\n    /* 2. Concatenate copies of the salt together to create a string S of length\n        v * ceil(s / v) bytes (the final copy of the salt may be trunacted\n        to create S).\n        Note that if the salt is the empty string, then so is S. */ var Slen = v * Math.ceil(s / v);\n    var S = new forge.util.ByteBuffer();\n    for(l = 0; l < Slen; l++){\n        S.putByte(salt.at(l % s));\n    }\n    /* 3. Concatenate copies of the password together to create a string P of\n        length v * ceil(p / v) bytes (the final copy of the password may be\n        truncated to create P).\n        Note that if the password is the empty string, then so is P. */ var Plen = v * Math.ceil(p / v);\n    var P = new forge.util.ByteBuffer();\n    for(l = 0; l < Plen; l++){\n        P.putByte(passBuf.at(l % p));\n    }\n    /* 4. Set I=S||P to be the concatenation of S and P. */ var I = S;\n    I.putBuffer(P);\n    /* 5. Set c=ceil(n / u). */ var c = Math.ceil(n / u);\n    /* 6. For i=1, 2, ..., c, do the following: */ for(var i = 1; i <= c; i++){\n        /* a) Set Ai=H^r(D||I). (l.e. the rth hash of D||I, H(H(H(...H(D||I)))) */ var buf = new forge.util.ByteBuffer();\n        buf.putBytes(D.bytes());\n        buf.putBytes(I.bytes());\n        for(var round = 0; round < iter; round++){\n            md.start();\n            md.update(buf.getBytes());\n            buf = md.digest();\n        }\n        /* b) Concatenate copies of Ai to create a string B of length v bytes (the\n          final copy of Ai may be truncated to create B). */ var B = new forge.util.ByteBuffer();\n        for(l = 0; l < v; l++){\n            B.putByte(buf.at(l % u));\n        }\n        /* c) Treating I as a concatenation I0, I1, ..., Ik-1 of v-byte blocks,\n          where k=ceil(s / v) + ceil(p / v), modify I by setting\n          Ij=(Ij+B+1) mod 2v for each j.  */ var k = Math.ceil(s / v) + Math.ceil(p / v);\n        var Inew = new forge.util.ByteBuffer();\n        for(j = 0; j < k; j++){\n            var chunk = new forge.util.ByteBuffer(I.getBytes(v));\n            var x = 0x1ff;\n            for(l = B.length() - 1; l >= 0; l--){\n                x = x >> 8;\n                x += B.at(l) + chunk.at(l);\n                chunk.setAt(l, x & 0xff);\n            }\n            Inew.putBuffer(chunk);\n        }\n        I = Inew;\n        /* Add Ai to A. */ result.putBuffer(buf);\n    }\n    result.truncate(result.length() - n);\n    return result;\n};\n/**\n * Get new Forge cipher object instance.\n *\n * @param oid the OID (in string notation).\n * @param params the ASN.1 params object.\n * @param password the password to decrypt with.\n *\n * @return new cipher object instance.\n */ pki.pbe.getCipher = function(oid, params, password) {\n    switch(oid){\n        case pki.oids[\"pkcs5PBES2\"]:\n            return pki.pbe.getCipherForPBES2(oid, params, password);\n        case pki.oids[\"pbeWithSHAAnd3-KeyTripleDES-CBC\"]:\n        case pki.oids[\"pbewithSHAAnd40BitRC2-CBC\"]:\n            return pki.pbe.getCipherForPKCS12PBE(oid, params, password);\n        default:\n            var error = new Error(\"Cannot read encrypted PBE data block. Unsupported OID.\");\n            error.oid = oid;\n            error.supportedOids = [\n                \"pkcs5PBES2\",\n                \"pbeWithSHAAnd3-KeyTripleDES-CBC\",\n                \"pbewithSHAAnd40BitRC2-CBC\"\n            ];\n            throw error;\n    }\n};\n/**\n * Get new Forge cipher object instance according to PBES2 params block.\n *\n * The returned cipher instance is already started using the IV\n * from PBES2 parameter block.\n *\n * @param oid the PKCS#5 PBKDF2 OID (in string notation).\n * @param params the ASN.1 PBES2-params object.\n * @param password the password to decrypt with.\n *\n * @return new cipher object instance.\n */ pki.pbe.getCipherForPBES2 = function(oid, params, password) {\n    // get PBE params\n    var capture = {};\n    var errors = [];\n    if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {\n        var error = new Error(\"Cannot read password-based-encryption algorithm \" + \"parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.\");\n        error.errors = errors;\n        throw error;\n    }\n    // check oids\n    oid = asn1.derToOid(capture.kdfOid);\n    if (oid !== pki.oids[\"pkcs5PBKDF2\"]) {\n        var error = new Error(\"Cannot read encrypted private key. \" + \"Unsupported key derivation function OID.\");\n        error.oid = oid;\n        error.supportedOids = [\n            \"pkcs5PBKDF2\"\n        ];\n        throw error;\n    }\n    oid = asn1.derToOid(capture.encOid);\n    if (oid !== pki.oids[\"aes128-CBC\"] && oid !== pki.oids[\"aes192-CBC\"] && oid !== pki.oids[\"aes256-CBC\"] && oid !== pki.oids[\"des-EDE3-CBC\"] && oid !== pki.oids[\"desCBC\"]) {\n        var error = new Error(\"Cannot read encrypted private key. \" + \"Unsupported encryption scheme OID.\");\n        error.oid = oid;\n        error.supportedOids = [\n            \"aes128-CBC\",\n            \"aes192-CBC\",\n            \"aes256-CBC\",\n            \"des-EDE3-CBC\",\n            \"desCBC\"\n        ];\n        throw error;\n    }\n    // set PBE params\n    var salt = capture.kdfSalt;\n    var count = forge.util.createBuffer(capture.kdfIterationCount);\n    count = count.getInt(count.length() << 3);\n    var dkLen;\n    var cipherFn;\n    switch(pki.oids[oid]){\n        case \"aes128-CBC\":\n            dkLen = 16;\n            cipherFn = forge.aes.createDecryptionCipher;\n            break;\n        case \"aes192-CBC\":\n            dkLen = 24;\n            cipherFn = forge.aes.createDecryptionCipher;\n            break;\n        case \"aes256-CBC\":\n            dkLen = 32;\n            cipherFn = forge.aes.createDecryptionCipher;\n            break;\n        case \"des-EDE3-CBC\":\n            dkLen = 24;\n            cipherFn = forge.des.createDecryptionCipher;\n            break;\n        case \"desCBC\":\n            dkLen = 8;\n            cipherFn = forge.des.createDecryptionCipher;\n            break;\n    }\n    // get PRF message digest\n    var md = prfOidToMessageDigest(capture.prfOid);\n    // decrypt private key using pbe with chosen PRF and AES/DES\n    var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);\n    var iv = capture.encIv;\n    var cipher = cipherFn(dk);\n    cipher.start(iv);\n    return cipher;\n};\n/**\n * Get new Forge cipher object instance for PKCS#12 PBE.\n *\n * The returned cipher instance is already started using the key & IV\n * derived from the provided password and PKCS#12 PBE salt.\n *\n * @param oid The PKCS#12 PBE OID (in string notation).\n * @param params The ASN.1 PKCS#12 PBE-params object.\n * @param password The password to decrypt with.\n *\n * @return the new cipher object instance.\n */ pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {\n    // get PBE params\n    var capture = {};\n    var errors = [];\n    if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {\n        var error = new Error(\"Cannot read password-based-encryption algorithm \" + \"parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.\");\n        error.errors = errors;\n        throw error;\n    }\n    var salt = forge.util.createBuffer(capture.salt);\n    var count = forge.util.createBuffer(capture.iterations);\n    count = count.getInt(count.length() << 3);\n    var dkLen, dIvLen, cipherFn;\n    switch(oid){\n        case pki.oids[\"pbeWithSHAAnd3-KeyTripleDES-CBC\"]:\n            dkLen = 24;\n            dIvLen = 8;\n            cipherFn = forge.des.startDecrypting;\n            break;\n        case pki.oids[\"pbewithSHAAnd40BitRC2-CBC\"]:\n            dkLen = 5;\n            dIvLen = 8;\n            cipherFn = function(key, iv) {\n                var cipher = forge.rc2.createDecryptionCipher(key, 40);\n                cipher.start(iv, null);\n                return cipher;\n            };\n            break;\n        default:\n            var error = new Error(\"Cannot read PKCS #12 PBE data block. Unsupported OID.\");\n            error.oid = oid;\n            throw error;\n    }\n    // get PRF message digest\n    var md = prfOidToMessageDigest(capture.prfOid);\n    var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);\n    md.start();\n    var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);\n    return cipherFn(key, iv);\n};\n/**\n * OpenSSL's legacy key derivation function.\n *\n * See: http://www.openssl.org/docs/crypto/EVP_BytesToKey.html\n *\n * @param password the password to derive the key from.\n * @param salt the salt to use, null for none.\n * @param dkLen the number of bytes needed for the derived key.\n * @param [options] the options to use:\n *          [md] an optional message digest object to use.\n */ pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {\n    if (typeof md === \"undefined\" || md === null) {\n        if (!(\"md5\" in forge.md)) {\n            throw new Error('\"md5\" hash algorithm unavailable.');\n        }\n        md = forge.md.md5.create();\n    }\n    if (salt === null) {\n        salt = \"\";\n    }\n    var digests = [\n        hash(md, password + salt)\n    ];\n    for(var length = 16, i = 1; length < dkLen; ++i, length += 16){\n        digests.push(hash(md, digests[i - 1] + password + salt));\n    }\n    return digests.join(\"\").substr(0, dkLen);\n};\nfunction hash(md, bytes) {\n    return md.start().update(bytes).digest().getBytes();\n}\nfunction prfOidToMessageDigest(prfOid) {\n    // get PRF algorithm, default to SHA-1\n    var prfAlgorithm;\n    if (!prfOid) {\n        prfAlgorithm = \"hmacWithSHA1\";\n    } else {\n        prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];\n        if (!prfAlgorithm) {\n            var error = new Error(\"Unsupported PRF OID.\");\n            error.oid = prfOid;\n            error.supported = [\n                \"hmacWithSHA1\",\n                \"hmacWithSHA224\",\n                \"hmacWithSHA256\",\n                \"hmacWithSHA384\",\n                \"hmacWithSHA512\"\n            ];\n            throw error;\n        }\n    }\n    return prfAlgorithmToMessageDigest(prfAlgorithm);\n}\nfunction prfAlgorithmToMessageDigest(prfAlgorithm) {\n    var factory = forge.md;\n    switch(prfAlgorithm){\n        case \"hmacWithSHA224\":\n            factory = forge.md.sha512;\n        case \"hmacWithSHA1\":\n        case \"hmacWithSHA256\":\n        case \"hmacWithSHA384\":\n        case \"hmacWithSHA512\":\n            prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();\n            break;\n        default:\n            var error = new Error(\"Unsupported PRF algorithm.\");\n            error.algorithm = prfAlgorithm;\n            error.supported = [\n                \"hmacWithSHA1\",\n                \"hmacWithSHA224\",\n                \"hmacWithSHA256\",\n                \"hmacWithSHA384\",\n                \"hmacWithSHA512\"\n            ];\n            throw error;\n    }\n    if (!factory || !(prfAlgorithm in factory)) {\n        throw new Error(\"Unknown hash algorithm: \" + prfAlgorithm);\n    }\n    return factory[prfAlgorithm].create();\n}\nfunction createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {\n    var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // salt\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),\n        // iteration count\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())\n    ]);\n    // when PRF algorithm is not SHA-1 default, add key length and PRF algorithm\n    if (prfAlgorithm !== \"hmacWithSHA1\") {\n        params.value.push(// key length\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(dkLen.toString(16))), // AlgorithmIdentifier\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // algorithm\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()),\n            // parameters (null)\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n        ]));\n    }\n    return params;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGJlLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkM7QUFDRCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixJQUFHLE9BQU9DLGVBQWUsYUFBYTtJQUNwQyxJQUFJQSxhQUFhRixNQUFNRyxJQUFJLENBQUNELFVBQVU7QUFDeEM7QUFFQSx5QkFBeUI7QUFDekIsSUFBSUUsT0FBT0osTUFBTUksSUFBSTtBQUVyQiw2Q0FBNkMsR0FDN0MsSUFBSUMsTUFBTUwsTUFBTUssR0FBRyxHQUFHTCxNQUFNSyxHQUFHLElBQUksQ0FBQztBQUNwQ0MsT0FBT0MsT0FBTyxHQUFHRixJQUFJRyxHQUFHLEdBQUdSLE1BQU1RLEdBQUcsR0FBR1IsTUFBTVEsR0FBRyxJQUFJLENBQUM7QUFDckQsSUFBSUMsT0FBT0osSUFBSUksSUFBSTtBQUVuQixxREFBcUQ7QUFDckQsZ0RBQWdEO0FBQ2hELElBQUlDLCtCQUErQjtJQUNqQ0MsTUFBTTtJQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7SUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0MsUUFBUTtJQUN4QkMsYUFBYTtJQUNiQyxPQUFPO1FBQUM7WUFDTlIsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0MsUUFBUTtZQUN4QkMsYUFBYTtZQUNiQyxPQUFPO2dCQUFDO29CQUNOUixNQUFNO29C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U0FBUyxFQUFFVixLQUFLWSxJQUFJLENBQUNzSyxJQUFJLEVBQUUsT0FBTztTQUMxRDtJQUNMO0lBQ0EsT0FBT25IO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGJlLmpzPzY0N2IiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQYXNzd29yZC1iYXNlZCBlbmNyeXB0aW9uIGZ1bmN0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICogQGF1dGhvciBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBBbiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbzpcbiAqXG4gKiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBlbmNyeXB0aW9uQWxnb3JpdGhtICBFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkRGF0YSAgICAgICAgRW5jcnlwdGVkRGF0YSB9XG4gKlxuICogRW5jcnlwdGlvbkFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAqXG4gKiBFbmNyeXB0ZWREYXRhIDo6PSBPQ1RFVCBTVFJJTkdcbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9hZXMnKTtcbnJlcXVpcmUoJy4vYXNuMScpO1xucmVxdWlyZSgnLi9kZXMnKTtcbnJlcXVpcmUoJy4vbWQnKTtcbnJlcXVpcmUoJy4vb2lkcycpO1xucmVxdWlyZSgnLi9wYmtkZjInKTtcbnJlcXVpcmUoJy4vcGVtJyk7XG5yZXF1aXJlKCcuL3JhbmRvbScpO1xucmVxdWlyZSgnLi9yYzInKTtcbnJlcXVpcmUoJy4vcnNhJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxuaWYodHlwZW9mIEJpZ0ludGVnZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gIHZhciBCaWdJbnRlZ2VyID0gZm9yZ2UuanNibi5CaWdJbnRlZ2VyO1xufVxuXG4vLyBzaG9ydGN1dCBmb3IgYXNuLjEgQVBJXG52YXIgYXNuMSA9IGZvcmdlLmFzbjE7XG5cbi8qIFBhc3N3b3JkLWJhc2VkIGVuY3J5cHRpb24gaW1wbGVtZW50YXRpb24uICovXG52YXIgcGtpID0gZm9yZ2UucGtpID0gZm9yZ2UucGtpIHx8IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBwa2kucGJlID0gZm9yZ2UucGJlID0gZm9yZ2UucGJlIHx8IHt9O1xudmFyIG9pZHMgPSBwa2kub2lkcztcblxuLy8gdmFsaWRhdG9yIGZvciBhbiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyBzdHJ1Y3R1cmVcbi8vIE5vdGU6IEN1cnJlbnRseSBvbmx5IHdvcmtzIHcvYWxnb3JpdGhtIHBhcmFtc1xudmFyIGVuY3J5cHRlZFByaXZhdGVLZXlWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0VuY3J5cHRlZFByaXZhdGVLZXlJbmZvLmVuY3J5cHRpb25BbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNyeXB0aW9uT2lkJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdBbGdvcml0aG1JZGVudGlmaWVyLnBhcmFtZXRlcnMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ2VuY3J5cHRpb25QYXJhbXMnXG4gICAgfV1cbiAgfSwge1xuICAgIC8vIGVuY3J5cHRlZERhdGFcbiAgICBuYW1lOiAnRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uZW5jcnlwdGVkRGF0YScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2VuY3J5cHRlZERhdGEnXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGEgUEJFUzJBbGdvcml0aG1zIHN0cnVjdHVyZVxuLy8gTm90ZTogQ3VycmVudGx5IG9ubHkgd29ya3Mgdy9QQktERjIgKyBBRVMgZW5jcnlwdGlvbiBzY2hlbWVzXG52YXIgUEJFUzJBbGdvcml0aG1zVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLmtleURlcml2YXRpb25GdW5jJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5rZXlEZXJpdmF0aW9uRnVuYy5vaWQnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdrZGZPaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5wYXJhbXMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5wYXJhbXMuc2FsdCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6ICdrZGZTYWx0J1xuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5pdGVyYXRpb25Db3VudCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ2tkZkl0ZXJhdGlvbkNvdW50J1xuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5rZXlMZW5ndGgnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlOiAna2V5TGVuZ3RoJ1xuICAgICAgfSwge1xuICAgICAgICAvLyBwcmZcbiAgICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5wYXJhbXMucHJmJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFt7XG4gICAgICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5wYXJhbXMucHJmLmFsZ29yaXRobScsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6ICdwcmZPaWQnXG4gICAgICAgIH1dXG4gICAgICB9XVxuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLmVuY3J5cHRpb25TY2hlbWUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLmVuY3J5cHRpb25TY2hlbWUub2lkJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnZW5jT2lkJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMuZW5jcnlwdGlvblNjaGVtZS5pdicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnZW5jSXYnXG4gICAgfV1cbiAgfV1cbn07XG5cbnZhciBwa2NzMTJQYmVQYXJhbXNWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdwa2NzLTEyUGJlUGFyYW1zJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAncGtjcy0xMlBiZVBhcmFtcy5zYWx0JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnc2FsdCdcbiAgfSwge1xuICAgIG5hbWU6ICdwa2NzLTEyUGJlUGFyYW1zLml0ZXJhdGlvbnMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2l0ZXJhdGlvbnMnXG4gIH1dXG59O1xuXG4vKipcbiAqIEVuY3J5cHRzIGEgQVNOLjEgUHJpdmF0ZUtleUluZm8gb2JqZWN0LCBwcm9kdWNpbmcgYW4gRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uXG4gKlxuICogUEJFUzJBbGdvcml0aG1zIEFMR09SSVRITS1JREVOVElGSUVSIDo6PVxuICogICB7IHtQQkVTMi1wYXJhbXMgSURFTlRJRklFRCBCWSBpZC1QQkVTMn0sIC4uLn1cbiAqXG4gKiBpZC1QQkVTMiBPQkpFQ1QgSURFTlRJRklFUiA6Oj0ge3BrY3MtNSAxM31cbiAqXG4gKiBQQkVTMi1wYXJhbXMgOjo9IFNFUVVFTkNFIHtcbiAqICAga2V5RGVyaXZhdGlvbkZ1bmMgQWxnb3JpdGhtSWRlbnRpZmllciB7e1BCRVMyLUtERnN9fSxcbiAqICAgZW5jcnlwdGlvblNjaGVtZSBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJFUzItRW5jc319XG4gKiB9XG4gKlxuICogUEJFUzItS0RGcyBBTEdPUklUSE0tSURFTlRJRklFUiA6Oj1cbiAqICAgeyB7UEJLREYyLXBhcmFtcyBJREVOVElGSUVEIEJZIGlkLVBCS0RGMn0sIC4uLiB9XG4gKlxuICogUEJFUzItRW5jcyBBTEdPUklUSE0tSURFTlRJRklFUiA6Oj0geyAuLi4gfVxuICpcbiAqIFBCS0RGMi1wYXJhbXMgOjo9IFNFUVVFTkNFIHtcbiAqICAgc2FsdCBDSE9JQ0Uge1xuICogICAgIHNwZWNpZmllZCBPQ1RFVCBTVFJJTkcsXG4gKiAgICAgb3RoZXJTb3VyY2UgQWxnb3JpdGhtSWRlbnRpZmllciB7e1BCS0RGMi1TYWx0U291cmNlc319XG4gKiAgIH0sXG4gKiAgIGl0ZXJhdGlvbkNvdW50IElOVEVHRVIgKDEuLk1BWCksXG4gKiAgIGtleUxlbmd0aCBJTlRFR0VSICgxLi5NQVgpIE9QVElPTkFMLFxuICogICBwcmYgQWxnb3JpdGhtSWRlbnRpZmllciB7e1BCS0RGMi1QUkZzfX0gREVGQVVMVCBhbGdpZC1obWFjV2l0aFNIQTFcbiAqIH1cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBBU04uMSBQcml2YXRlS2V5SW5mbyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGVuY3J5cHQgd2l0aC5cbiAqIEBwYXJhbSBvcHRpb25zOlxuICogICAgICAgICAgYWxnb3JpdGhtIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSB0byB1c2VcbiAqICAgICAgICAgICAgKCdhZXMxMjgnLCAnYWVzMTkyJywgJ2FlczI1NicsICczZGVzJyksIGRlZmF1bHRzIHRvICdhZXMxMjgnLlxuICogICAgICAgICAgY291bnQgdGhlIGl0ZXJhdGlvbiBjb3VudCB0byB1c2UuXG4gKiAgICAgICAgICBzYWx0U2l6ZSB0aGUgc2FsdCBzaXplIHRvIHVzZS5cbiAqICAgICAgICAgIHByZkFsZ29yaXRobSB0aGUgUFJGIG1lc3NhZ2UgZGlnZXN0IGFsZ29yaXRobSB0byB1c2VcbiAqICAgICAgICAgICAgKCdzaGExJywgJ3NoYTIyNCcsICdzaGEyNTYnLCAnc2hhMzg0JywgJ3NoYTUxMicpXG4gKlxuICogQHJldHVybiB0aGUgQVNOLjEgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uXG4gKi9cbnBraS5lbmNyeXB0UHJpdmF0ZUtleUluZm8gPSBmdW5jdGlvbihvYmosIHBhc3N3b3JkLCBvcHRpb25zKSB7XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuc2FsdFNpemUgPSBvcHRpb25zLnNhbHRTaXplIHx8IDg7XG4gIG9wdGlvbnMuY291bnQgPSBvcHRpb25zLmNvdW50IHx8IDIwNDg7XG4gIG9wdGlvbnMuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgJ2FlczEyOCc7XG4gIG9wdGlvbnMucHJmQWxnb3JpdGhtID0gb3B0aW9ucy5wcmZBbGdvcml0aG0gfHwgJ3NoYTEnO1xuXG4gIC8vIGdlbmVyYXRlIFBCRSBwYXJhbXNcbiAgdmFyIHNhbHQgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKG9wdGlvbnMuc2FsdFNpemUpO1xuICB2YXIgY291bnQgPSBvcHRpb25zLmNvdW50O1xuICB2YXIgY291bnRCeXRlcyA9IGFzbjEuaW50ZWdlclRvRGVyKGNvdW50KTtcbiAgdmFyIGRrTGVuO1xuICB2YXIgZW5jcnlwdGlvbkFsZ29yaXRobTtcbiAgdmFyIGVuY3J5cHRlZERhdGE7XG4gIGlmKG9wdGlvbnMuYWxnb3JpdGhtLmluZGV4T2YoJ2FlcycpID09PSAwIHx8IG9wdGlvbnMuYWxnb3JpdGhtID09PSAnZGVzJykge1xuICAgIC8vIGRvIFBCRVMyXG4gICAgdmFyIGl2TGVuLCBlbmNPaWQsIGNpcGhlckZuO1xuICAgIHN3aXRjaChvcHRpb25zLmFsZ29yaXRobSkge1xuICAgIGNhc2UgJ2FlczEyOCc6XG4gICAgICBka0xlbiA9IDE2O1xuICAgICAgaXZMZW4gPSAxNjtcbiAgICAgIGVuY09pZCA9IG9pZHNbJ2FlczEyOC1DQkMnXTtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhZXMxOTInOlxuICAgICAgZGtMZW4gPSAyNDtcbiAgICAgIGl2TGVuID0gMTY7XG4gICAgICBlbmNPaWQgPSBvaWRzWydhZXMxOTItQ0JDJ107XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYWVzMjU2JzpcbiAgICAgIGRrTGVuID0gMzI7XG4gICAgICBpdkxlbiA9IDE2O1xuICAgICAgZW5jT2lkID0gb2lkc1snYWVzMjU2LUNCQyddO1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Rlcyc6XG4gICAgICBka0xlbiA9IDg7XG4gICAgICBpdkxlbiA9IDg7XG4gICAgICBlbmNPaWQgPSBvaWRzWydkZXNDQkMnXTtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgZW5jcnlwdCBwcml2YXRlIGtleS4gVW5rbm93biBlbmNyeXB0aW9uIGFsZ29yaXRobS4nKTtcbiAgICAgIGVycm9yLmFsZ29yaXRobSA9IG9wdGlvbnMuYWxnb3JpdGhtO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gZ2V0IFBSRiBtZXNzYWdlIGRpZ2VzdFxuICAgIHZhciBwcmZBbGdvcml0aG0gPSAnaG1hY1dpdGgnICsgb3B0aW9ucy5wcmZBbGdvcml0aG0udG9VcHBlckNhc2UoKTtcbiAgICB2YXIgbWQgPSBwcmZBbGdvcml0aG1Ub01lc3NhZ2VEaWdlc3QocHJmQWxnb3JpdGhtKTtcblxuICAgIC8vIGVuY3J5cHQgcHJpdmF0ZSBrZXkgdXNpbmcgcGJlIFNIQS0xIGFuZCBBRVMvREVTXG4gICAgdmFyIGRrID0gZm9yZ2UucGtjczUucGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBjb3VudCwgZGtMZW4sIG1kKTtcbiAgICB2YXIgaXYgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKGl2TGVuKTtcbiAgICB2YXIgY2lwaGVyID0gY2lwaGVyRm4oZGspO1xuICAgIGNpcGhlci5zdGFydChpdik7XG4gICAgY2lwaGVyLnVwZGF0ZShhc24xLnRvRGVyKG9iaikpO1xuICAgIGNpcGhlci5maW5pc2goKTtcbiAgICBlbmNyeXB0ZWREYXRhID0gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xuXG4gICAgLy8gZ2V0IFBCS0RGMi1wYXJhbXNcbiAgICB2YXIgcGFyYW1zID0gY3JlYXRlUGJrZGYyUGFyYW1zKHNhbHQsIGNvdW50Qnl0ZXMsIGRrTGVuLCBwcmZBbGdvcml0aG0pO1xuXG4gICAgZW5jcnlwdGlvbkFsZ29yaXRobSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKG9pZHNbJ3BrY3M1UEJFUzInXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIGtleURlcml2YXRpb25GdW5jXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgICBhc24xLm9pZFRvRGVyKG9pZHNbJ3BrY3M1UEJLREYyJ10pLmdldEJ5dGVzKCkpLFxuICAgICAgICAgIC8vIFBCS0RGMi1wYXJhbXNcbiAgICAgICAgICBwYXJhbXNcbiAgICAgICAgXSksXG4gICAgICAgIC8vIGVuY3J5cHRpb25TY2hlbWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIoZW5jT2lkKS5nZXRCeXRlcygpKSxcbiAgICAgICAgICAvLyBpdlxuICAgICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIGl2KVxuICAgICAgICBdKVxuICAgICAgXSlcbiAgICBdKTtcbiAgfSBlbHNlIGlmKG9wdGlvbnMuYWxnb3JpdGhtID09PSAnM2RlcycpIHtcbiAgICAvLyBEbyBQS0NTMTIgUEJFXG4gICAgZGtMZW4gPSAyNDtcblxuICAgIHZhciBzYWx0Qnl0ZXMgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKHNhbHQpO1xuICAgIHZhciBkayA9IHBraS5wYmUuZ2VuZXJhdGVQa2NzMTJLZXkocGFzc3dvcmQsIHNhbHRCeXRlcywgMSwgY291bnQsIGRrTGVuKTtcbiAgICB2YXIgaXYgPSBwa2kucGJlLmdlbmVyYXRlUGtjczEyS2V5KHBhc3N3b3JkLCBzYWx0Qnl0ZXMsIDIsIGNvdW50LCBka0xlbik7XG4gICAgdmFyIGNpcGhlciA9IGZvcmdlLmRlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyKGRrKTtcbiAgICBjaXBoZXIuc3RhcnQoaXYpO1xuICAgIGNpcGhlci51cGRhdGUoYXNuMS50b0RlcihvYmopKTtcbiAgICBjaXBoZXIuZmluaXNoKCk7XG4gICAgZW5jcnlwdGVkRGF0YSA9IGNpcGhlci5vdXRwdXQuZ2V0Qnl0ZXMoKTtcblxuICAgIGVuY3J5cHRpb25BbGdvcml0aG0gPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgYXNuMS5vaWRUb0RlcihvaWRzWydwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJ10pLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gcGtjcy0xMlBiZVBhcmFtc1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBzYWx0XG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsIGZhbHNlLCBzYWx0KSxcbiAgICAgICAgLy8gaXRlcmF0aW9uIGNvdW50XG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICAgICAgY291bnRCeXRlcy5nZXRCeXRlcygpKVxuICAgICAgXSlcbiAgICBdKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmNyeXB0IHByaXZhdGUga2V5LiBVbmtub3duIGVuY3J5cHRpb24gYWxnb3JpdGhtLicpO1xuICAgIGVycm9yLmFsZ29yaXRobSA9IG9wdGlvbnMuYWxnb3JpdGhtO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gRW5jcnlwdGVkUHJpdmF0ZUtleUluZm9cbiAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gZW5jcnlwdGlvbkFsZ29yaXRobVxuICAgIGVuY3J5cHRpb25BbGdvcml0aG0sXG4gICAgLy8gZW5jcnlwdGVkRGF0YVxuICAgIGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIGVuY3J5cHRlZERhdGEpXG4gIF0pO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogRGVjcnlwdHMgYSBBU04uMSBQcml2YXRlS2V5SW5mbyBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgQVNOLjEgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8gb2JqZWN0LlxuICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCB0byBkZWNyeXB0IHdpdGguXG4gKlxuICogQHJldHVybiB0aGUgQVNOLjEgUHJpdmF0ZUtleUluZm8gb24gc3VjY2VzcywgbnVsbCBvbiBmYWlsdXJlLlxuICovXG5wa2kuZGVjcnlwdFByaXZhdGVLZXlJbmZvID0gZnVuY3Rpb24ob2JqLCBwYXNzd29yZCkge1xuICB2YXIgcnZhbCA9IG51bGw7XG5cbiAgLy8gZ2V0IFBCRSBwYXJhbXNcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIGVuY3J5cHRlZFByaXZhdGVLZXlWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIGVuY3J5cHRlZCBwcml2YXRlIGtleS4gJyArXG4gICAgICAnQVNOLjEgb2JqZWN0IGlzIG5vdCBhIHN1cHBvcnRlZCBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby4nKTtcbiAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBnZXQgY2lwaGVyXG4gIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuZW5jcnlwdGlvbk9pZCk7XG4gIHZhciBjaXBoZXIgPSBwa2kucGJlLmdldENpcGhlcihvaWQsIGNhcHR1cmUuZW5jcnlwdGlvblBhcmFtcywgcGFzc3dvcmQpO1xuXG4gIC8vIGdldCBlbmNyeXB0ZWQgZGF0YVxuICB2YXIgZW5jcnlwdGVkID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5lbmNyeXB0ZWREYXRhKTtcblxuICBjaXBoZXIudXBkYXRlKGVuY3J5cHRlZCk7XG4gIGlmKGNpcGhlci5maW5pc2goKSkge1xuICAgIHJ2YWwgPSBhc24xLmZyb21EZXIoY2lwaGVyLm91dHB1dCk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyB0byBQRU0gZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBlcGtpIHRoZSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIGNoYXJhY3RlcnMgcGVyIGxpbmUsIGRlZmF1bHRzIHRvIDY0LlxuICpcbiAqIEByZXR1cm4gdGhlIFBFTS1mb3JtYXR0ZWQgZW5jcnlwdGVkIHByaXZhdGUga2V5LlxuICovXG5wa2kuZW5jcnlwdGVkUHJpdmF0ZUtleVRvUGVtID0gZnVuY3Rpb24oZXBraSwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ0VOQ1JZUFRFRCBQUklWQVRFIEtFWScsXG4gICAgYm9keTogYXNuMS50b0RlcihlcGtpKS5nZXRCeXRlcygpXG4gIH07XG4gIHJldHVybiBmb3JnZS5wZW0uZW5jb2RlKG1zZywge21heGxpbmU6IG1heGxpbmV9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQRU0tZW5jb2RlZCBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyB0byBBU04uMSBmb3JtYXQuIERlY3J5cHRpb25cbiAqIGlzIG5vdCBwZXJmb3JtZWQuXG4gKlxuICogQHBhcmFtIHBlbSB0aGUgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8gaW4gUEVNLWZvcm1hdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqL1xucGtpLmVuY3J5cHRlZFByaXZhdGVLZXlGcm9tUGVtID0gZnVuY3Rpb24ocGVtKSB7XG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdFTkNSWVBURUQgUFJJVkFURSBLRVknKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkgZnJvbSBQRU07ICcgK1xuICAgICAgJ1BFTSBoZWFkZXIgdHlwZSBpcyBcIkVOQ1JZUFRFRCBQUklWQVRFIEtFWVwiLicpO1xuICAgIGVycm9yLmhlYWRlclR5cGUgPSBtc2cudHlwZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkgZnJvbSBQRU07ICcgK1xuICAgICAgJ1BFTSBpcyBlbmNyeXB0ZWQuJyk7XG4gIH1cblxuICAvLyBjb252ZXJ0IERFUiB0byBBU04uMSBvYmplY3RcbiAgcmV0dXJuIGFzbjEuZnJvbURlcihtc2cuYm9keSk7XG59O1xuXG4vKipcbiAqIEVuY3J5cHRzIGFuIFJTQSBwcml2YXRlIGtleS4gQnkgZGVmYXVsdCwgdGhlIGtleSB3aWxsIGJlIHdyYXBwZWQgaW5cbiAqIGEgUHJpdmF0ZUtleUluZm8gYW5kIGVuY3J5cHRlZCB0byBwcm9kdWNlIGEgUEtDUyM4IEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLlxuICogVGhpcyBpcyB0aGUgc3RhbmRhcmQsIHByZWZlcnJlZCB3YXkgdG8gZW5jcnlwdCBhIHByaXZhdGUga2V5LlxuICpcbiAqIFRvIHByb2R1Y2UgYSBub24tc3RhbmRhcmQgUEVNLWVuY3J5cHRlZCBwcml2YXRlIGtleSB0aGF0IHVzZXMgZW5jYXBzdWxhdGVkXG4gKiBoZWFkZXJzIHRvIGluZGljYXRlIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSAob2xkLXN0eWxlIG5vbi1QS0NTIzggT3BlblNTTFxuICogcHJpdmF0ZSBrZXkgZW5jcnlwdGlvbiksIHNldCB0aGUgJ2xlZ2FjeScgb3B0aW9uIHRvIHRydWUuIE5vdGU6IFVzaW5nIHRoaXNcbiAqIG9wdGlvbiB3aWxsIGNhdXNlIHRoZSBpdGVyYXRpb24gY291bnQgdG8gYmUgZm9yY2VkIHRvIDEuXG4gKlxuICogTm90ZTogVGhlICdkZXMnIGFsZ29yaXRobSBpcyBzdXBwb3J0ZWQsIGJ1dCBpdCBpcyBub3QgY29uc2lkZXJlZCB0byBiZVxuICogc2VjdXJlIGJlY2F1c2UgaXQgb25seSB1c2VzIGEgc2luZ2xlIDU2LWJpdCBrZXkuIElmIHBvc3NpYmxlLCBpdCBpcyBoaWdobHlcbiAqIHJlY29tbWVuZGVkIHRoYXQgYSBkaWZmZXJlbnQgYWxnb3JpdGhtIGJlIHVzZWQuXG4gKlxuICogQHBhcmFtIHJzYUtleSB0aGUgUlNBIGtleSB0byBlbmNyeXB0LlxuICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCB0byB1c2UuXG4gKiBAcGFyYW0gb3B0aW9uczpcbiAqICAgICAgICAgIGFsZ29yaXRobTogdGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtIHRvIHVzZVxuICogICAgICAgICAgICAoJ2FlczEyOCcsICdhZXMxOTInLCAnYWVzMjU2JywgJzNkZXMnLCAnZGVzJykuXG4gKiAgICAgICAgICBjb3VudDogdGhlIGl0ZXJhdGlvbiBjb3VudCB0byB1c2UuXG4gKiAgICAgICAgICBzYWx0U2l6ZTogdGhlIHNhbHQgc2l6ZSB0byB1c2UuXG4gKiAgICAgICAgICBsZWdhY3k6IG91dHB1dCBhbiBvbGQgbm9uLVBLQ1MjOCBQRU0tZW5jcnlwdGVkK2VuY2Fwc3VsYXRlZFxuICogICAgICAgICAgICBoZWFkZXJzIChERUstSW5mbykgcHJpdmF0ZSBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWVuY29kZWQgQVNOLjEgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uXG4gKi9cbnBraS5lbmNyeXB0UnNhUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKHJzYUtleSwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgLy8gc3RhbmRhcmQgUEtDUyM4XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZighb3B0aW9ucy5sZWdhY3kpIHtcbiAgICAvLyBlbmNyeXB0IFByaXZhdGVLZXlJbmZvXG4gICAgdmFyIHJ2YWwgPSBwa2kud3JhcFJzYVByaXZhdGVLZXkocGtpLnByaXZhdGVLZXlUb0FzbjEocnNhS2V5KSk7XG4gICAgcnZhbCA9IHBraS5lbmNyeXB0UHJpdmF0ZUtleUluZm8ocnZhbCwgcGFzc3dvcmQsIG9wdGlvbnMpO1xuICAgIHJldHVybiBwa2kuZW5jcnlwdGVkUHJpdmF0ZUtleVRvUGVtKHJ2YWwpO1xuICB9XG5cbiAgLy8gbGVnYWN5IG5vbi1QS0NTIzhcbiAgdmFyIGFsZ29yaXRobTtcbiAgdmFyIGl2O1xuICB2YXIgZGtMZW47XG4gIHZhciBjaXBoZXJGbjtcbiAgc3dpdGNoKG9wdGlvbnMuYWxnb3JpdGhtKSB7XG4gIGNhc2UgJ2FlczEyOCc6XG4gICAgYWxnb3JpdGhtID0gJ0FFUy0xMjgtQ0JDJztcbiAgICBka0xlbiA9IDE2O1xuICAgIGl2ID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzU3luYygxNik7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnYWVzMTkyJzpcbiAgICBhbGdvcml0aG0gPSAnQUVTLTE5Mi1DQkMnO1xuICAgIGRrTGVuID0gMjQ7XG4gICAgaXYgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKDE2KTtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBjYXNlICdhZXMyNTYnOlxuICAgIGFsZ29yaXRobSA9ICdBRVMtMjU2LUNCQyc7XG4gICAgZGtMZW4gPSAzMjtcbiAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoMTYpO1xuICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJzNkZXMnOlxuICAgIGFsZ29yaXRobSA9ICdERVMtRURFMy1DQkMnO1xuICAgIGRrTGVuID0gMjQ7XG4gICAgaXYgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKDgpO1xuICAgIGNpcGhlckZuID0gZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2Rlcyc6XG4gICAgYWxnb3JpdGhtID0gJ0RFUy1DQkMnO1xuICAgIGRrTGVuID0gODtcbiAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoOCk7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBlbmNyeXB0IFJTQSBwcml2YXRlIGtleTsgdW5zdXBwb3J0ZWQgJyArXG4gICAgICAnZW5jcnlwdGlvbiBhbGdvcml0aG0gXCInICsgb3B0aW9ucy5hbGdvcml0aG0gKyAnXCIuJyk7XG4gICAgZXJyb3IuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG07XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBlbmNyeXB0IHByaXZhdGUga2V5IHVzaW5nIE9wZW5TU0wgbGVnYWN5IGtleSBkZXJpdmF0aW9uXG4gIHZhciBkayA9IGZvcmdlLnBiZS5vcGVuc3NsRGVyaXZlQnl0ZXMocGFzc3dvcmQsIGl2LnN1YnN0cigwLCA4KSwgZGtMZW4pO1xuICB2YXIgY2lwaGVyID0gY2lwaGVyRm4oZGspO1xuICBjaXBoZXIuc3RhcnQoaXYpO1xuICBjaXBoZXIudXBkYXRlKGFzbjEudG9EZXIocGtpLnByaXZhdGVLZXlUb0FzbjEocnNhS2V5KSkpO1xuICBjaXBoZXIuZmluaXNoKCk7XG5cbiAgdmFyIG1zZyA9IHtcbiAgICB0eXBlOiAnUlNBIFBSSVZBVEUgS0VZJyxcbiAgICBwcm9jVHlwZToge1xuICAgICAgdmVyc2lvbjogJzQnLFxuICAgICAgdHlwZTogJ0VOQ1JZUFRFRCdcbiAgICB9LFxuICAgIGRla0luZm86IHtcbiAgICAgIGFsZ29yaXRobTogYWxnb3JpdGhtLFxuICAgICAgcGFyYW1ldGVyczogZm9yZ2UudXRpbC5ieXRlc1RvSGV4KGl2KS50b1VwcGVyQ2FzZSgpXG4gICAgfSxcbiAgICBib2R5OiBjaXBoZXIub3V0cHV0LmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnKTtcbn07XG5cbi8qKlxuICogRGVjcnlwdHMgYW4gUlNBIHByaXZhdGUga2V5LlxuICpcbiAqIEBwYXJhbSBwZW0gdGhlIFBFTS1mb3JtYXR0ZWQgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8gdG8gZGVjcnlwdC5cbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIFJTQSBrZXkgb24gc3VjY2VzcywgbnVsbCBvbiBmYWlsdXJlLlxuICovXG5wa2kuZGVjcnlwdFJzYVByaXZhdGVLZXkgPSBmdW5jdGlvbihwZW0sIHBhc3N3b3JkKSB7XG4gIHZhciBydmFsID0gbnVsbDtcblxuICB2YXIgbXNnID0gZm9yZ2UucGVtLmRlY29kZShwZW0pWzBdO1xuXG4gIGlmKG1zZy50eXBlICE9PSAnRU5DUllQVEVEIFBSSVZBVEUgS0VZJyAmJlxuICAgIG1zZy50eXBlICE9PSAnUFJJVkFURSBLRVknICYmXG4gICAgbXNnLnR5cGUgIT09ICdSU0EgUFJJVkFURSBLRVknKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBwcml2YXRlIGtleSBmcm9tIFBFTTsgUEVNIGhlYWRlciB0eXBlICcgK1xuICAgICAgJ2lzIG5vdCBcIkVOQ1JZUFRFRCBQUklWQVRFIEtFWVwiLCBcIlBSSVZBVEUgS0VZXCIsIG9yIFwiUlNBIFBSSVZBVEUgS0VZXCIuJyk7XG4gICAgZXJyb3IuaGVhZGVyVHlwZSA9IGVycm9yO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHZhciBka0xlbjtcbiAgICB2YXIgY2lwaGVyRm47XG4gICAgc3dpdGNoKG1zZy5kZWtJbmZvLmFsZ29yaXRobSkge1xuICAgIGNhc2UgJ0RFUy1DQkMnOlxuICAgICAgZGtMZW4gPSA4O1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0RFUy1FREUzLUNCQyc6XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0FFUy0xMjgtQ0JDJzpcbiAgICAgIGRrTGVuID0gMTY7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnQUVTLTE5Mi1DQkMnOlxuICAgICAgZGtMZW4gPSAyNDtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdBRVMtMjU2LUNCQyc6XG4gICAgICBka0xlbiA9IDMyO1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1JDMi00MC1DQkMnOlxuICAgICAgZGtMZW4gPSA1O1xuICAgICAgY2lwaGVyRm4gPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyKGtleSwgNDApO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1JDMi02NC1DQkMnOlxuICAgICAgZGtMZW4gPSA4O1xuICAgICAgY2lwaGVyRm4gPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyKGtleSwgNjQpO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1JDMi0xMjgtQ0JDJzpcbiAgICAgIGRrTGVuID0gMTY7XG4gICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCAxMjgpO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZWNyeXB0IHByaXZhdGUga2V5OyB1bnN1cHBvcnRlZCAnICtcbiAgICAgICAgJ2VuY3J5cHRpb24gYWxnb3JpdGhtIFwiJyArIG1zZy5kZWtJbmZvLmFsZ29yaXRobSArICdcIi4nKTtcbiAgICAgIGVycm9yLmFsZ29yaXRobSA9IG1zZy5kZWtJbmZvLmFsZ29yaXRobTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8vIHVzZSBPcGVuU1NMIGxlZ2FjeSBrZXkgZGVyaXZhdGlvblxuICAgIHZhciBpdiA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhtc2cuZGVrSW5mby5wYXJhbWV0ZXJzKTtcbiAgICB2YXIgZGsgPSBmb3JnZS5wYmUub3BlbnNzbERlcml2ZUJ5dGVzKHBhc3N3b3JkLCBpdi5zdWJzdHIoMCwgOCksIGRrTGVuKTtcbiAgICB2YXIgY2lwaGVyID0gY2lwaGVyRm4oZGspO1xuICAgIGNpcGhlci5zdGFydChpdik7XG4gICAgY2lwaGVyLnVwZGF0ZShmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihtc2cuYm9keSkpO1xuICAgIGlmKGNpcGhlci5maW5pc2goKSkge1xuICAgICAgcnZhbCA9IGNpcGhlci5vdXRwdXQuZ2V0Qnl0ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJ2YWwgPSBtc2cuYm9keTtcbiAgfVxuXG4gIGlmKG1zZy50eXBlID09PSAnRU5DUllQVEVEIFBSSVZBVEUgS0VZJykge1xuICAgIHJ2YWwgPSBwa2kuZGVjcnlwdFByaXZhdGVLZXlJbmZvKGFzbjEuZnJvbURlcihydmFsKSwgcGFzc3dvcmQpO1xuICB9IGVsc2Uge1xuICAgIC8vIGRlY3J5cHRpb24gYWxyZWFkeSBwZXJmb3JtZWQgYWJvdmVcbiAgICBydmFsID0gYXNuMS5mcm9tRGVyKHJ2YWwpO1xuICB9XG5cbiAgaWYocnZhbCAhPT0gbnVsbCkge1xuICAgIHJ2YWwgPSBwa2kucHJpdmF0ZUtleUZyb21Bc24xKHJ2YWwpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIERlcml2ZXMgYSBQS0NTIzEyIGtleS5cbiAqXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlcml2ZSB0aGUga2V5IG1hdGVyaWFsIGZyb20sIG51bGwgb3JcbiAqICAgICAgICAgIHVuZGVmaW5lZCBmb3Igbm9uZS5cbiAqIEBwYXJhbSBzYWx0IHRoZSBzYWx0LCBhcyBhIEJ5dGVCdWZmZXIsIHRvIHVzZS5cbiAqIEBwYXJhbSBpZCB0aGUgUEtDUyMxMiBJRCBieXRlICgxID0ga2V5IG1hdGVyaWFsLCAyID0gSVYsIDMgPSBNQUMpLlxuICogQHBhcmFtIGl0ZXIgdGhlIGl0ZXJhdGlvbiBjb3VudC5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZGVyaXZlIGZyb20gdGhlIHBhc3N3b3JkLlxuICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCB0byB1c2UsIGRlZmF1bHRzIHRvIFNIQS0xLlxuICpcbiAqIEByZXR1cm4gYSBCeXRlQnVmZmVyIHdpdGggdGhlIGJ5dGVzIGRlcml2ZWQgZnJvbSB0aGUgcGFzc3dvcmQuXG4gKi9cbnBraS5wYmUuZ2VuZXJhdGVQa2NzMTJLZXkgPSBmdW5jdGlvbihwYXNzd29yZCwgc2FsdCwgaWQsIGl0ZXIsIG4sIG1kKSB7XG4gIHZhciBqLCBsO1xuXG4gIGlmKHR5cGVvZiBtZCA9PT0gJ3VuZGVmaW5lZCcgfHwgbWQgPT09IG51bGwpIHtcbiAgICBpZighKCdzaGExJyBpbiBmb3JnZS5tZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJzaGExXCIgaGFzaCBhbGdvcml0aG0gdW5hdmFpbGFibGUuJyk7XG4gICAgfVxuICAgIG1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgfVxuXG4gIHZhciB1ID0gbWQuZGlnZXN0TGVuZ3RoO1xuICB2YXIgdiA9IG1kLmJsb2NrTGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuXG4gIC8qIENvbnZlcnQgcGFzc3dvcmQgdG8gVW5pY29kZSBieXRlIGJ1ZmZlciArIHRyYWlsaW5nIDAtYnl0ZS4gKi9cbiAgdmFyIHBhc3NCdWYgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gIGlmKHBhc3N3b3JkICE9PSBudWxsICYmIHBhc3N3b3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IobCA9IDA7IGwgPCBwYXNzd29yZC5sZW5ndGg7IGwrKykge1xuICAgICAgcGFzc0J1Zi5wdXRJbnQxNihwYXNzd29yZC5jaGFyQ29kZUF0KGwpKTtcbiAgICB9XG4gICAgcGFzc0J1Zi5wdXRJbnQxNigwKTtcbiAgfVxuXG4gIC8qIExlbmd0aCBvZiBzYWx0IGFuZCBwYXNzd29yZCBpbiBCWVRFUy4gKi9cbiAgdmFyIHAgPSBwYXNzQnVmLmxlbmd0aCgpO1xuICB2YXIgcyA9IHNhbHQubGVuZ3RoKCk7XG5cbiAgLyogMS4gQ29uc3RydWN0IGEgc3RyaW5nLCBEICh0aGUgXCJkaXZlcnNpZmllclwiKSwgYnkgY29uY2F0ZW5hdGluZ1xuICAgICAgICB2IGNvcGllcyBvZiBJRC4gKi9cbiAgdmFyIEQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gIEQuZmlsbFdpdGhCeXRlKGlkLCB2KTtcblxuICAvKiAyLiBDb25jYXRlbmF0ZSBjb3BpZXMgb2YgdGhlIHNhbHQgdG9nZXRoZXIgdG8gY3JlYXRlIGEgc3RyaW5nIFMgb2YgbGVuZ3RoXG4gICAgICAgIHYgKiBjZWlsKHMgLyB2KSBieXRlcyAodGhlIGZpbmFsIGNvcHkgb2YgdGhlIHNhbHQgbWF5IGJlIHRydW5hY3RlZFxuICAgICAgICB0byBjcmVhdGUgUykuXG4gICAgICAgIE5vdGUgdGhhdCBpZiB0aGUgc2FsdCBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIHNvIGlzIFMuICovXG4gIHZhciBTbGVuID0gdiAqIE1hdGguY2VpbChzIC8gdik7XG4gIHZhciBTID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICBmb3IobCA9IDA7IGwgPCBTbGVuOyBsKyspIHtcbiAgICBTLnB1dEJ5dGUoc2FsdC5hdChsICUgcykpO1xuICB9XG5cbiAgLyogMy4gQ29uY2F0ZW5hdGUgY29waWVzIG9mIHRoZSBwYXNzd29yZCB0b2dldGhlciB0byBjcmVhdGUgYSBzdHJpbmcgUCBvZlxuICAgICAgICBsZW5ndGggdiAqIGNlaWwocCAvIHYpIGJ5dGVzICh0aGUgZmluYWwgY29weSBvZiB0aGUgcGFzc3dvcmQgbWF5IGJlXG4gICAgICAgIHRydW5jYXRlZCB0byBjcmVhdGUgUCkuXG4gICAgICAgIE5vdGUgdGhhdCBpZiB0aGUgcGFzc3dvcmQgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzbyBpcyBQLiAqL1xuICB2YXIgUGxlbiA9IHYgKiBNYXRoLmNlaWwocCAvIHYpO1xuICB2YXIgUCA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgZm9yKGwgPSAwOyBsIDwgUGxlbjsgbCsrKSB7XG4gICAgUC5wdXRCeXRlKHBhc3NCdWYuYXQobCAlIHApKTtcbiAgfVxuXG4gIC8qIDQuIFNldCBJPVN8fFAgdG8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgUyBhbmQgUC4gKi9cbiAgdmFyIEkgPSBTO1xuICBJLnB1dEJ1ZmZlcihQKTtcblxuICAvKiA1LiBTZXQgYz1jZWlsKG4gLyB1KS4gKi9cbiAgdmFyIGMgPSBNYXRoLmNlaWwobiAvIHUpO1xuXG4gIC8qIDYuIEZvciBpPTEsIDIsIC4uLiwgYywgZG8gdGhlIGZvbGxvd2luZzogKi9cbiAgZm9yKHZhciBpID0gMTsgaSA8PSBjOyBpKyspIHtcbiAgICAvKiBhKSBTZXQgQWk9SF5yKER8fEkpLiAobC5lLiB0aGUgcnRoIGhhc2ggb2YgRHx8SSwgSChIKEgoLi4uSChEfHxJKSkpKSAqL1xuICAgIHZhciBidWYgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgYnVmLnB1dEJ5dGVzKEQuYnl0ZXMoKSk7XG4gICAgYnVmLnB1dEJ5dGVzKEkuYnl0ZXMoKSk7XG4gICAgZm9yKHZhciByb3VuZCA9IDA7IHJvdW5kIDwgaXRlcjsgcm91bmQrKykge1xuICAgICAgbWQuc3RhcnQoKTtcbiAgICAgIG1kLnVwZGF0ZShidWYuZ2V0Qnl0ZXMoKSk7XG4gICAgICBidWYgPSBtZC5kaWdlc3QoKTtcbiAgICB9XG5cbiAgICAvKiBiKSBDb25jYXRlbmF0ZSBjb3BpZXMgb2YgQWkgdG8gY3JlYXRlIGEgc3RyaW5nIEIgb2YgbGVuZ3RoIHYgYnl0ZXMgKHRoZVxuICAgICAgICAgIGZpbmFsIGNvcHkgb2YgQWkgbWF5IGJlIHRydW5jYXRlZCB0byBjcmVhdGUgQikuICovXG4gICAgdmFyIEIgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgZm9yKGwgPSAwOyBsIDwgdjsgbCsrKSB7XG4gICAgICBCLnB1dEJ5dGUoYnVmLmF0KGwgJSB1KSk7XG4gICAgfVxuXG4gICAgLyogYykgVHJlYXRpbmcgSSBhcyBhIGNvbmNhdGVuYXRpb24gSTAsIEkxLCAuLi4sIElrLTEgb2Ygdi1ieXRlIGJsb2NrcyxcbiAgICAgICAgICB3aGVyZSBrPWNlaWwocyAvIHYpICsgY2VpbChwIC8gdiksIG1vZGlmeSBJIGJ5IHNldHRpbmdcbiAgICAgICAgICBJaj0oSWorQisxKSBtb2QgMnYgZm9yIGVhY2ggai4gICovXG4gICAgdmFyIGsgPSBNYXRoLmNlaWwocyAvIHYpICsgTWF0aC5jZWlsKHAgLyB2KTtcbiAgICB2YXIgSW5ldyA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICBmb3IoaiA9IDA7IGogPCBrOyBqKyspIHtcbiAgICAgIHZhciBjaHVuayA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoSS5nZXRCeXRlcyh2KSk7XG4gICAgICB2YXIgeCA9IDB4MWZmO1xuICAgICAgZm9yKGwgPSBCLmxlbmd0aCgpIC0gMTsgbCA+PSAwOyBsLS0pIHtcbiAgICAgICAgeCA9IHggPj4gODtcbiAgICAgICAgeCArPSBCLmF0KGwpICsgY2h1bmsuYXQobCk7XG4gICAgICAgIGNodW5rLnNldEF0KGwsIHggJiAweGZmKTtcbiAgICAgIH1cbiAgICAgIEluZXcucHV0QnVmZmVyKGNodW5rKTtcbiAgICB9XG4gICAgSSA9IEluZXc7XG5cbiAgICAvKiBBZGQgQWkgdG8gQS4gKi9cbiAgICByZXN1bHQucHV0QnVmZmVyKGJ1Zik7XG4gIH1cblxuICByZXN1bHQudHJ1bmNhdGUocmVzdWx0Lmxlbmd0aCgpIC0gbik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEdldCBuZXcgRm9yZ2UgY2lwaGVyIG9iamVjdCBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gb2lkIHRoZSBPSUQgKGluIHN0cmluZyBub3RhdGlvbikuXG4gKiBAcGFyYW0gcGFyYW1zIHRoZSBBU04uMSBwYXJhbXMgb2JqZWN0LlxuICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCB0byBkZWNyeXB0IHdpdGguXG4gKlxuICogQHJldHVybiBuZXcgY2lwaGVyIG9iamVjdCBpbnN0YW5jZS5cbiAqL1xucGtpLnBiZS5nZXRDaXBoZXIgPSBmdW5jdGlvbihvaWQsIHBhcmFtcywgcGFzc3dvcmQpIHtcbiAgc3dpdGNoKG9pZCkge1xuICBjYXNlIHBraS5vaWRzWydwa2NzNVBCRVMyJ106XG4gICAgcmV0dXJuIHBraS5wYmUuZ2V0Q2lwaGVyRm9yUEJFUzIob2lkLCBwYXJhbXMsIHBhc3N3b3JkKTtcblxuICBjYXNlIHBraS5vaWRzWydwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJ106XG4gIGNhc2UgcGtpLm9pZHNbJ3BiZXdpdGhTSEFBbmQ0MEJpdFJDMi1DQkMnXTpcbiAgICByZXR1cm4gcGtpLnBiZS5nZXRDaXBoZXJGb3JQS0NTMTJQQkUob2lkLCBwYXJhbXMsIHBhc3N3b3JkKTtcblxuICBkZWZhdWx0OlxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgZW5jcnlwdGVkIFBCRSBkYXRhIGJsb2NrLiBVbnN1cHBvcnRlZCBPSUQuJyk7XG4gICAgZXJyb3Iub2lkID0gb2lkO1xuICAgIGVycm9yLnN1cHBvcnRlZE9pZHMgPSBbXG4gICAgICAncGtjczVQQkVTMicsXG4gICAgICAncGJlV2l0aFNIQUFuZDMtS2V5VHJpcGxlREVTLUNCQycsXG4gICAgICAncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQydcbiAgICBdO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBuZXcgRm9yZ2UgY2lwaGVyIG9iamVjdCBpbnN0YW5jZSBhY2NvcmRpbmcgdG8gUEJFUzIgcGFyYW1zIGJsb2NrLlxuICpcbiAqIFRoZSByZXR1cm5lZCBjaXBoZXIgaW5zdGFuY2UgaXMgYWxyZWFkeSBzdGFydGVkIHVzaW5nIHRoZSBJVlxuICogZnJvbSBQQkVTMiBwYXJhbWV0ZXIgYmxvY2suXG4gKlxuICogQHBhcmFtIG9pZCB0aGUgUEtDUyM1IFBCS0RGMiBPSUQgKGluIHN0cmluZyBub3RhdGlvbikuXG4gKiBAcGFyYW0gcGFyYW1zIHRoZSBBU04uMSBQQkVTMi1wYXJhbXMgb2JqZWN0LlxuICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCB0byBkZWNyeXB0IHdpdGguXG4gKlxuICogQHJldHVybiBuZXcgY2lwaGVyIG9iamVjdCBpbnN0YW5jZS5cbiAqL1xucGtpLnBiZS5nZXRDaXBoZXJGb3JQQkVTMiA9IGZ1bmN0aW9uKG9pZCwgcGFyYW1zLCBwYXNzd29yZCkge1xuICAvLyBnZXQgUEJFIHBhcmFtc1xuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKHBhcmFtcywgUEJFUzJBbGdvcml0aG1zVmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwYXNzd29yZC1iYXNlZC1lbmNyeXB0aW9uIGFsZ29yaXRobSAnICtcbiAgICAgICdwYXJhbWV0ZXJzLiBBU04uMSBvYmplY3QgaXMgbm90IGEgc3VwcG9ydGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGNoZWNrIG9pZHNcbiAgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmtkZk9pZCk7XG4gIGlmKG9pZCAhPT0gcGtpLm9pZHNbJ3BrY3M1UEJLREYyJ10pIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIGVuY3J5cHRlZCBwcml2YXRlIGtleS4gJyArXG4gICAgICAnVW5zdXBwb3J0ZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gT0lELicpO1xuICAgIGVycm9yLm9pZCA9IG9pZDtcbiAgICBlcnJvci5zdXBwb3J0ZWRPaWRzID0gWydwa2NzNVBCS0RGMiddO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5lbmNPaWQpO1xuICBpZihvaWQgIT09IHBraS5vaWRzWydhZXMxMjgtQ0JDJ10gJiZcbiAgICBvaWQgIT09IHBraS5vaWRzWydhZXMxOTItQ0JDJ10gJiZcbiAgICBvaWQgIT09IHBraS5vaWRzWydhZXMyNTYtQ0JDJ10gJiZcbiAgICBvaWQgIT09IHBraS5vaWRzWydkZXMtRURFMy1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2Rlc0NCQyddKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkuICcgK1xuICAgICAgJ1Vuc3VwcG9ydGVkIGVuY3J5cHRpb24gc2NoZW1lIE9JRC4nKTtcbiAgICBlcnJvci5vaWQgPSBvaWQ7XG4gICAgZXJyb3Iuc3VwcG9ydGVkT2lkcyA9IFtcbiAgICAgICdhZXMxMjgtQ0JDJywgJ2FlczE5Mi1DQkMnLCAnYWVzMjU2LUNCQycsICdkZXMtRURFMy1DQkMnLCAnZGVzQ0JDJ107XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBzZXQgUEJFIHBhcmFtc1xuICB2YXIgc2FsdCA9IGNhcHR1cmUua2RmU2FsdDtcbiAgdmFyIGNvdW50ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5rZGZJdGVyYXRpb25Db3VudCk7XG4gIGNvdW50ID0gY291bnQuZ2V0SW50KGNvdW50Lmxlbmd0aCgpIDw8IDMpO1xuICB2YXIgZGtMZW47XG4gIHZhciBjaXBoZXJGbjtcbiAgc3dpdGNoKHBraS5vaWRzW29pZF0pIHtcbiAgY2FzZSAnYWVzMTI4LUNCQyc6XG4gICAgZGtMZW4gPSAxNjtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBjYXNlICdhZXMxOTItQ0JDJzpcbiAgICBka0xlbiA9IDI0O1xuICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2FlczI1Ni1DQkMnOlxuICAgIGRrTGVuID0gMzI7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnZGVzLUVERTMtQ0JDJzpcbiAgICBka0xlbiA9IDI0O1xuICAgIGNpcGhlckZuID0gZm9yZ2UuZGVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2Rlc0NCQyc6XG4gICAgZGtMZW4gPSA4O1xuICAgIGNpcGhlckZuID0gZm9yZ2UuZGVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBnZXQgUFJGIG1lc3NhZ2UgZGlnZXN0XG4gIHZhciBtZCA9IHByZk9pZFRvTWVzc2FnZURpZ2VzdChjYXB0dXJlLnByZk9pZCk7XG5cbiAgLy8gZGVjcnlwdCBwcml2YXRlIGtleSB1c2luZyBwYmUgd2l0aCBjaG9zZW4gUFJGIGFuZCBBRVMvREVTXG4gIHZhciBkayA9IGZvcmdlLnBrY3M1LnBia2RmMihwYXNzd29yZCwgc2FsdCwgY291bnQsIGRrTGVuLCBtZCk7XG4gIHZhciBpdiA9IGNhcHR1cmUuZW5jSXY7XG4gIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gIGNpcGhlci5zdGFydChpdik7XG5cbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogR2V0IG5ldyBGb3JnZSBjaXBoZXIgb2JqZWN0IGluc3RhbmNlIGZvciBQS0NTIzEyIFBCRS5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgY2lwaGVyIGluc3RhbmNlIGlzIGFscmVhZHkgc3RhcnRlZCB1c2luZyB0aGUga2V5ICYgSVZcbiAqIGRlcml2ZWQgZnJvbSB0aGUgcHJvdmlkZWQgcGFzc3dvcmQgYW5kIFBLQ1MjMTIgUEJFIHNhbHQuXG4gKlxuICogQHBhcmFtIG9pZCBUaGUgUEtDUyMxMiBQQkUgT0lEIChpbiBzdHJpbmcgbm90YXRpb24pLlxuICogQHBhcmFtIHBhcmFtcyBUaGUgQVNOLjEgUEtDUyMxMiBQQkUtcGFyYW1zIG9iamVjdC5cbiAqIEBwYXJhbSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgdG8gZGVjcnlwdCB3aXRoLlxuICpcbiAqIEByZXR1cm4gdGhlIG5ldyBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICovXG5wa2kucGJlLmdldENpcGhlckZvclBLQ1MxMlBCRSA9IGZ1bmN0aW9uKG9pZCwgcGFyYW1zLCBwYXNzd29yZCkge1xuICAvLyBnZXQgUEJFIHBhcmFtc1xuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKHBhcmFtcywgcGtjczEyUGJlUGFyYW1zVmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwYXNzd29yZC1iYXNlZC1lbmNyeXB0aW9uIGFsZ29yaXRobSAnICtcbiAgICAgICdwYXJhbWV0ZXJzLiBBU04uMSBvYmplY3QgaXMgbm90IGEgc3VwcG9ydGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBzYWx0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5zYWx0KTtcbiAgdmFyIGNvdW50ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5pdGVyYXRpb25zKTtcbiAgY291bnQgPSBjb3VudC5nZXRJbnQoY291bnQubGVuZ3RoKCkgPDwgMyk7XG5cbiAgdmFyIGRrTGVuLCBkSXZMZW4sIGNpcGhlckZuO1xuICBzd2l0Y2gob2lkKSB7XG4gICAgY2FzZSBwa2kub2lkc1sncGJlV2l0aFNIQUFuZDMtS2V5VHJpcGxlREVTLUNCQyddOlxuICAgICAgZGtMZW4gPSAyNDtcbiAgICAgIGRJdkxlbiA9IDg7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5zdGFydERlY3J5cHRpbmc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGtpLm9pZHNbJ3BiZXdpdGhTSEFBbmQ0MEJpdFJDMi1DQkMnXTpcbiAgICAgIGRrTGVuID0gNTtcbiAgICAgIGRJdkxlbiA9IDg7XG4gICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleSwgaXYpIHtcbiAgICAgICAgdmFyIGNpcGhlciA9IGZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyKGtleSwgNDApO1xuICAgICAgICBjaXBoZXIuc3RhcnQoaXYsIG51bGwpO1xuICAgICAgICByZXR1cm4gY2lwaGVyO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgUEtDUyAjMTIgUEJFIGRhdGEgYmxvY2suIFVuc3VwcG9ydGVkIE9JRC4nKTtcbiAgICAgIGVycm9yLm9pZCA9IG9pZDtcbiAgICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gZ2V0IFBSRiBtZXNzYWdlIGRpZ2VzdFxuICB2YXIgbWQgPSBwcmZPaWRUb01lc3NhZ2VEaWdlc3QoY2FwdHVyZS5wcmZPaWQpO1xuICB2YXIga2V5ID0gcGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleShwYXNzd29yZCwgc2FsdCwgMSwgY291bnQsIGRrTGVuLCBtZCk7XG4gIG1kLnN0YXJ0KCk7XG4gIHZhciBpdiA9IHBraS5wYmUuZ2VuZXJhdGVQa2NzMTJLZXkocGFzc3dvcmQsIHNhbHQsIDIsIGNvdW50LCBkSXZMZW4sIG1kKTtcblxuICByZXR1cm4gY2lwaGVyRm4oa2V5LCBpdik7XG59O1xuXG4vKipcbiAqIE9wZW5TU0wncyBsZWdhY3kga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG4gKlxuICogU2VlOiBodHRwOi8vd3d3Lm9wZW5zc2wub3JnL2RvY3MvY3J5cHRvL0VWUF9CeXRlc1RvS2V5Lmh0bWxcbiAqXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlcml2ZSB0aGUga2V5IGZyb20uXG4gKiBAcGFyYW0gc2FsdCB0aGUgc2FsdCB0byB1c2UsIG51bGwgZm9yIG5vbmUuXG4gKiBAcGFyYW0gZGtMZW4gdGhlIG51bWJlciBvZiBieXRlcyBuZWVkZWQgZm9yIHRoZSBkZXJpdmVkIGtleS5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW21kXSBhbiBvcHRpb25hbCBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlLlxuICovXG5wa2kucGJlLm9wZW5zc2xEZXJpdmVCeXRlcyA9IGZ1bmN0aW9uKHBhc3N3b3JkLCBzYWx0LCBka0xlbiwgbWQpIHtcbiAgaWYodHlwZW9mIG1kID09PSAndW5kZWZpbmVkJyB8fCBtZCA9PT0gbnVsbCkge1xuICAgIGlmKCEoJ21kNScgaW4gZm9yZ2UubWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWQ1XCIgaGFzaCBhbGdvcml0aG0gdW5hdmFpbGFibGUuJyk7XG4gICAgfVxuICAgIG1kID0gZm9yZ2UubWQubWQ1LmNyZWF0ZSgpO1xuICB9XG4gIGlmKHNhbHQgPT09IG51bGwpIHtcbiAgICBzYWx0ID0gJyc7XG4gIH1cbiAgdmFyIGRpZ2VzdHMgPSBbaGFzaChtZCwgcGFzc3dvcmQgKyBzYWx0KV07XG4gIGZvcih2YXIgbGVuZ3RoID0gMTYsIGkgPSAxOyBsZW5ndGggPCBka0xlbjsgKytpLCBsZW5ndGggKz0gMTYpIHtcbiAgICBkaWdlc3RzLnB1c2goaGFzaChtZCwgZGlnZXN0c1tpIC0gMV0gKyBwYXNzd29yZCArIHNhbHQpKTtcbiAgfVxuICByZXR1cm4gZGlnZXN0cy5qb2luKCcnKS5zdWJzdHIoMCwgZGtMZW4pO1xufTtcblxuZnVuY3Rpb24gaGFzaChtZCwgYnl0ZXMpIHtcbiAgcmV0dXJuIG1kLnN0YXJ0KCkudXBkYXRlKGJ5dGVzKS5kaWdlc3QoKS5nZXRCeXRlcygpO1xufVxuXG5mdW5jdGlvbiBwcmZPaWRUb01lc3NhZ2VEaWdlc3QocHJmT2lkKSB7XG4gIC8vIGdldCBQUkYgYWxnb3JpdGhtLCBkZWZhdWx0IHRvIFNIQS0xXG4gIHZhciBwcmZBbGdvcml0aG07XG4gIGlmKCFwcmZPaWQpIHtcbiAgICBwcmZBbGdvcml0aG0gPSAnaG1hY1dpdGhTSEExJztcbiAgfSBlbHNlIHtcbiAgICBwcmZBbGdvcml0aG0gPSBwa2kub2lkc1thc24xLmRlclRvT2lkKHByZk9pZCldO1xuICAgIGlmKCFwcmZBbGdvcml0aG0pIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUFJGIE9JRC4nKTtcbiAgICAgIGVycm9yLm9pZCA9IHByZk9pZDtcbiAgICAgIGVycm9yLnN1cHBvcnRlZCA9IFtcbiAgICAgICAgJ2htYWNXaXRoU0hBMScsICdobWFjV2l0aFNIQTIyNCcsICdobWFjV2l0aFNIQTI1NicsICdobWFjV2l0aFNIQTM4NCcsXG4gICAgICAgICdobWFjV2l0aFNIQTUxMiddO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcmZBbGdvcml0aG1Ub01lc3NhZ2VEaWdlc3QocHJmQWxnb3JpdGhtKTtcbn1cblxuZnVuY3Rpb24gcHJmQWxnb3JpdGhtVG9NZXNzYWdlRGlnZXN0KHByZkFsZ29yaXRobSkge1xuICB2YXIgZmFjdG9yeSA9IGZvcmdlLm1kO1xuICBzd2l0Y2gocHJmQWxnb3JpdGhtKSB7XG4gIGNhc2UgJ2htYWNXaXRoU0hBMjI0JzpcbiAgICBmYWN0b3J5ID0gZm9yZ2UubWQuc2hhNTEyO1xuICBjYXNlICdobWFjV2l0aFNIQTEnOlxuICBjYXNlICdobWFjV2l0aFNIQTI1Nic6XG4gIGNhc2UgJ2htYWNXaXRoU0hBMzg0JzpcbiAgY2FzZSAnaG1hY1dpdGhTSEE1MTInOlxuICAgIHByZkFsZ29yaXRobSA9IHByZkFsZ29yaXRobS5zdWJzdHIoOCkudG9Mb3dlckNhc2UoKTtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFBSRiBhbGdvcml0aG0uJyk7XG4gICAgZXJyb3IuYWxnb3JpdGhtID0gcHJmQWxnb3JpdGhtO1xuICAgIGVycm9yLnN1cHBvcnRlZCA9IFtcbiAgICAgICdobWFjV2l0aFNIQTEnLCAnaG1hY1dpdGhTSEEyMjQnLCAnaG1hY1dpdGhTSEEyNTYnLCAnaG1hY1dpdGhTSEEzODQnLFxuICAgICAgJ2htYWNXaXRoU0hBNTEyJ107XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYoIWZhY3RvcnkgfHwgIShwcmZBbGdvcml0aG0gaW4gZmFjdG9yeSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaGFzaCBhbGdvcml0aG06ICcgKyBwcmZBbGdvcml0aG0pO1xuICB9XG4gIHJldHVybiBmYWN0b3J5W3ByZkFsZ29yaXRobV0uY3JlYXRlKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBia2RmMlBhcmFtcyhzYWx0LCBjb3VudEJ5dGVzLCBka0xlbiwgcHJmQWxnb3JpdGhtKSB7XG4gIHZhciBwYXJhbXMgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gc2FsdFxuICAgIGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHNhbHQpLFxuICAgIC8vIGl0ZXJhdGlvbiBjb3VudFxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBjb3VudEJ5dGVzLmdldEJ5dGVzKCkpXG4gIF0pO1xuICAvLyB3aGVuIFBSRiBhbGdvcml0aG0gaXMgbm90IFNIQS0xIGRlZmF1bHQsIGFkZCBrZXkgbGVuZ3RoIGFuZCBQUkYgYWxnb3JpdGhtXG4gIGlmKHByZkFsZ29yaXRobSAhPT0gJ2htYWNXaXRoU0hBMScpIHtcbiAgICBwYXJhbXMudmFsdWUucHVzaChcbiAgICAgIC8vIGtleSBsZW5ndGhcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICAgIGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhka0xlbi50b1N0cmluZygxNikpKSxcbiAgICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXJcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzW3ByZkFsZ29yaXRobV0pLmdldEJ5dGVzKCkpLFxuICAgICAgICAvLyBwYXJhbWV0ZXJzIChudWxsKVxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICAgIF0pKTtcbiAgfVxuICByZXR1cm4gcGFyYW1zO1xufVxuIl0sIm5hbWVzIjpbImZvcmdlIiwicmVxdWlyZSIsIkJpZ0ludGVnZXIiLCJqc2JuIiwiYXNuMSIsInBraSIsIm1vZHVsZSIsImV4cG9ydHMiLCJwYmUiLCJvaWRzIiwiZW5jcnlwdGVkUHJpdmF0ZUtleVZhbGlkYXRvciIsIm5hbWUiLCJ0YWdDbGFzcyIsIkNsYXNzIiwiVU5JVkVSU0FMIiwidHlwZSIsIlR5cGUiLCJTRVFVRU5DRSIsImNvbnN0cnVjdGVkIiwidmFsdWUiLCJPSUQiLCJjYXB0dXJlIiwiY2FwdHVyZUFzbjEiLCJPQ1RFVFNUUklORyIsIlBCRVMyQWxnb3JpdGhtc1ZhbGlkYXRvciIsIklOVEVHRVIiLCJvcHRpb25hbCIsInBrY3MxMlBiZVBhcmFtc1ZhbGlkYXRvciIsImVuY3J5cHRQcml2YXRlS2V5SW5mbyIsIm9iaiIsInBhc3N3b3JkIiwib3B0aW9ucyIsInNhbHRTaXplIiwiY291bnQiLCJhbGdvcml0aG0iLCJwcmZBbGdvcml0aG0iLCJzYWx0IiwicmFuZG9tIiwiZ2V0Qnl0ZXNTeW5jIiwiY291bnRCeXRlcyIsImludGVnZXJUb0RlciIsImRrTGVuIiwiZW5jcnlwdGlvbkFsZ29yaXRobSIsImVuY3J5cHRlZERhdGEiLCJpbmRleE9mIiwiaXZMZW4iLCJlbmNPaWQiLCJjaXBoZXJGbiIsImFlcyIsImNyZWF0ZUVuY3J5cHRpb25DaXBoZXIiLCJkZXMiLCJlcnJvciIsIkVycm9yIiwidG9VcHBlckNhc2UiLCJtZCIsInByZkFsZ29yaXRobVRvTWVzc2FnZURpZ2VzdCIsImRrIiwicGtjczUiLCJwYmtkZjIiLCJpdiIsImNpcGhlciIsInN0YXJ0IiwidXBkYXRlIiwidG9EZXIiLCJmaW5pc2giLCJvdXRwdXQiLCJnZXRCeXRlcyIsInBhcmFtcyIsImNyZWF0ZVBia2RmMlBhcmFtcyIsImNyZWF0ZSIsIm9pZFRvRGVyIiwic2FsdEJ5dGVzIiwidXRpbCIsIkJ5dGVCdWZmZXIiLCJnZW5lcmF0ZVBrY3MxMktleSIsInJ2YWwiLCJkZWNyeXB0UHJpdmF0ZUtleUluZm8iLCJlcnJvcnMiLCJ2YWxpZGF0ZSIsIm9pZCIsImRlclRvT2lkIiwiZW5jcnlwdGlvbk9pZCIsImdldENpcGhlciIsImVuY3J5cHRpb25QYXJhbXMiLCJlbmNyeXB0ZWQiLCJjcmVhdGVCdWZmZXIiLCJmcm9tRGVyIiwiZW5jcnlwdGVkUHJpdmF0ZUtleVRvUGVtIiwiZXBraSIsIm1heGxpbmUiLCJtc2ciLCJib2R5IiwicGVtIiwiZW5jb2RlIiwiZW5jcnlwdGVkUHJpdmF0ZUtleUZyb21QZW0iLCJkZWNvZGUiLCJoZWFkZXJUeXBlIiwicHJvY1R5cGUiLCJlbmNyeXB0UnNhUHJpdmF0ZUtleSIsInJzYUtleSIsImxlZ2FjeSIsIndyYXBSc2FQcml2YXRlS2V5IiwicHJpdmF0ZUtleVRvQXNuMSIsIm9wZW5zc2xEZXJpdmVCeXRlcyIsInN1YnN0ciIsInZlcnNpb24iLCJkZWtJbmZvIiwicGFyYW1ldGVycyIsImJ5dGVzVG9IZXgiLCJkZWNyeXB0UnNhUHJpdmF0ZUtleSIsImNyZWF0ZURlY3J5cHRpb25DaXBoZXIiLCJrZXkiLCJyYzIiLCJoZXhUb0J5dGVzIiwicHJpdmF0ZUtleUZyb21Bc24xIiwiaWQiLCJpdGVyIiwibiIsImoiLCJsIiwic2hhMSIsInUiLCJkaWdlc3RMZW5ndGgiLCJ2IiwiYmxvY2tMZW5ndGgiLCJyZXN1bHQiLCJwYXNzQnVmIiwidW5kZWZpbmVkIiwibGVuZ3RoIiwicHV0SW50MTYiLCJjaGFyQ29kZUF0IiwicCIsInMiLCJEIiwiZmlsbFdpdGhCeXRlIiwiU2xlbiIsIk1hdGgiLCJjZWlsIiwiUyIsInB1dEJ5dGUiLCJhdCIsIlBsZW4iLCJQIiwiSSIsInB1dEJ1ZmZlciIsImMiLCJpIiwiYnVmIiwicHV0Qnl0ZXMiLCJieXRlcyIsInJvdW5kIiwiZGlnZXN0IiwiQiIsImsiLCJJbmV3IiwiY2h1bmsiLCJ4Iiwic2V0QXQiLCJ0cnVuY2F0ZSIsImdldENpcGhlckZvclBCRVMyIiwiZ2V0Q2lwaGVyRm9yUEtDUzEyUEJFIiwic3VwcG9ydGVkT2lkcyIsImtkZk9pZCIsImtkZlNhbHQiLCJrZGZJdGVyYXRpb25Db3VudCIsImdldEludCIsInByZk9pZFRvTWVzc2FnZURpZ2VzdCIsInByZk9pZCIsImVuY0l2IiwiaXRlcmF0aW9ucyIsImRJdkxlbiIsInN0YXJ0RGVjcnlwdGluZyIsIm1kNSIsImRpZ2VzdHMiLCJoYXNoIiwicHVzaCIsImpvaW4iLCJzdXBwb3J0ZWQiLCJmYWN0b3J5Iiwic2hhNTEyIiwidG9Mb3dlckNhc2UiLCJ0b1N0cmluZyIsIk5VTEwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/pbe.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/pbkdf2.js":
/*!***********************************************!*\
  !*** ./node_modules/node-forge/lib/pbkdf2.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Password-Based Key-Derivation Function #2 implementation.\n *\n * See RFC 2898 for details.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./hmac */ \"(rsc)/./node_modules/node-forge/lib/hmac.js\");\n__webpack_require__(/*! ./md */ \"(rsc)/./node_modules/node-forge/lib/md.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\nvar pkcs5 = forge.pkcs5 = forge.pkcs5 || {};\nvar crypto;\nif (forge.util.isNodejs && !forge.options.usePureJavaScript) {\n    crypto = __webpack_require__(/*! crypto */ \"crypto\");\n}\n/**\n * Derives a key from a password.\n *\n * @param p the password as a binary-encoded string of bytes.\n * @param s the salt as a binary-encoded string of bytes.\n * @param c the iteration count, a positive integer.\n * @param dkLen the intended length, in bytes, of the derived key,\n *          (max: 2^32 - 1) * hash length of the PRF.\n * @param [md] the message digest (or algorithm identifier as a string) to use\n *          in the PRF, defaults to SHA-1.\n * @param [callback(err, key)] presence triggers asynchronous version, called\n *          once the operation completes.\n *\n * @return the derived key, as a binary-encoded string of bytes, for the\n *           synchronous version (if no callback is specified).\n */ module.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md, callback) {\n    if (typeof md === \"function\") {\n        callback = md;\n        md = null;\n    }\n    // use native implementation if possible and not disabled, note that\n    // some node versions only support SHA-1, others allow digest to be changed\n    if (forge.util.isNodejs && !forge.options.usePureJavaScript && crypto.pbkdf2 && (md === null || typeof md !== \"object\") && (crypto.pbkdf2Sync.length > 4 || !md || md === \"sha1\")) {\n        if (typeof md !== \"string\") {\n            // default prf to SHA-1\n            md = \"sha1\";\n        }\n        p = Buffer.from(p, \"binary\");\n        s = Buffer.from(s, \"binary\");\n        if (!callback) {\n            if (crypto.pbkdf2Sync.length === 4) {\n                return crypto.pbkdf2Sync(p, s, c, dkLen).toString(\"binary\");\n            }\n            return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString(\"binary\");\n        }\n        if (crypto.pbkdf2Sync.length === 4) {\n            return crypto.pbkdf2(p, s, c, dkLen, function(err, key) {\n                if (err) {\n                    return callback(err);\n                }\n                callback(null, key.toString(\"binary\"));\n            });\n        }\n        return crypto.pbkdf2(p, s, c, dkLen, md, function(err, key) {\n            if (err) {\n                return callback(err);\n            }\n            callback(null, key.toString(\"binary\"));\n        });\n    }\n    if (typeof md === \"undefined\" || md === null) {\n        // default prf to SHA-1\n        md = \"sha1\";\n    }\n    if (typeof md === \"string\") {\n        if (!(md in forge.md.algorithms)) {\n            throw new Error(\"Unknown hash algorithm: \" + md);\n        }\n        md = forge.md[md].create();\n    }\n    var hLen = md.digestLength;\n    /* 1. If dkLen > (2^32 - 1) * hLen, output \"derived key too long\" and\n    stop. */ if (dkLen > 0xFFFFFFFF * hLen) {\n        var err = new Error(\"Derived key is too long.\");\n        if (callback) {\n            return callback(err);\n        }\n        throw err;\n    }\n    /* 2. Let len be the number of hLen-octet blocks in the derived key,\n    rounding up, and let r be the number of octets in the last\n    block:\n\n    len = CEIL(dkLen / hLen),\n    r = dkLen - (len - 1) * hLen. */ var len = Math.ceil(dkLen / hLen);\n    var r = dkLen - (len - 1) * hLen;\n    /* 3. For each block of the derived key apply the function F defined\n    below to the password P, the salt S, the iteration count c, and\n    the block index to compute the block:\n\n    T_1 = F(P, S, c, 1),\n    T_2 = F(P, S, c, 2),\n    ...\n    T_len = F(P, S, c, len),\n\n    where the function F is defined as the exclusive-or sum of the\n    first c iterates of the underlying pseudorandom function PRF\n    applied to the password P and the concatenation of the salt S\n    and the block index i:\n\n    F(P, S, c, i) = u_1 XOR u_2 XOR ... XOR u_c\n\n    where\n\n    u_1 = PRF(P, S || INT(i)),\n    u_2 = PRF(P, u_1),\n    ...\n    u_c = PRF(P, u_{c-1}).\n\n    Here, INT(i) is a four-octet encoding of the integer i, most\n    significant octet first. */ var prf = forge.hmac.create();\n    prf.start(md, p);\n    var dk = \"\";\n    var xor, u_c, u_c1;\n    // sync version\n    if (!callback) {\n        for(var i = 1; i <= len; ++i){\n            // PRF(P, S || INT(i)) (first iteration)\n            prf.start(null, null);\n            prf.update(s);\n            prf.update(forge.util.int32ToBytes(i));\n            xor = u_c1 = prf.digest().getBytes();\n            // PRF(P, u_{c-1}) (other iterations)\n            for(var j = 2; j <= c; ++j){\n                prf.start(null, null);\n                prf.update(u_c1);\n                u_c = prf.digest().getBytes();\n                // F(p, s, c, i)\n                xor = forge.util.xorBytes(xor, u_c, hLen);\n                u_c1 = u_c;\n            }\n            /* 4. Concatenate the blocks and extract the first dkLen octets to\n        produce a derived key DK:\n\n        DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */ dk += i < len ? xor : xor.substr(0, r);\n        }\n        /* 5. Output the derived key DK. */ return dk;\n    }\n    // async version\n    var i = 1, j;\n    function outer() {\n        if (i > len) {\n            // done\n            return callback(null, dk);\n        }\n        // PRF(P, S || INT(i)) (first iteration)\n        prf.start(null, null);\n        prf.update(s);\n        prf.update(forge.util.int32ToBytes(i));\n        xor = u_c1 = prf.digest().getBytes();\n        // PRF(P, u_{c-1}) (other iterations)\n        j = 2;\n        inner();\n    }\n    function inner() {\n        if (j <= c) {\n            prf.start(null, null);\n            prf.update(u_c1);\n            u_c = prf.digest().getBytes();\n            // F(p, s, c, i)\n            xor = forge.util.xorBytes(xor, u_c, hLen);\n            u_c1 = u_c;\n            ++j;\n            return forge.util.setImmediate(inner);\n        }\n        /* 4. Concatenate the blocks and extract the first dkLen octets to\n      produce a derived key DK:\n\n      DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */ dk += i < len ? xor : xor.substr(0, r);\n        ++i;\n        outer();\n    }\n    outer();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGJrZGYyLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVIsSUFBSUMsUUFBUUYsTUFBTUUsS0FBSyxHQUFHRixNQUFNRSxLQUFLLElBQUksQ0FBQztBQUUxQyxJQUFJQztBQUNKLElBQUdILE1BQU1JLElBQUksQ0FBQ0MsUUFBUSxJQUFJLENBQUNMLE1BQU1NLE9BQU8sQ0FBQ0MsaUJBQWlCLEVBQUU7SUFDMURKLFNBQVNGLG1CQUFPQSxDQUFDO0FBQ25CO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RPLE9BQU9DLE9BQU8sR0FBR1QsTUFBTVUsTUFBTSxHQUFHUixNQUFNUSxNQUFNLEdBQUcsU0FDN0NDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEtBQUssRUFBRUMsRUFBRSxFQUFFQyxRQUFRO0lBQzVCLElBQUcsT0FBT0QsT0FBTyxZQUFZO1FBQzNCQyxXQUFXRDtRQUNYQSxLQUFLO0lBQ1A7SUFFQSxvRUFBb0U7SUFDcEUsMkVBQTJFO0lBQzNFLElBQUdmLE1BQU1JLElBQUksQ0FBQ0MsUUFBUSxJQUFJLENBQUNMLE1BQU1NLE9BQU8sQ0FBQ0MsaUJBQWlCLElBQ3hESixPQUFPTyxNQUFNLElBQUtLLENBQUFBLE9BQU8sUUFBUSxPQUFPQSxPQUFPLFFBQU8sS0FDckRaLENBQUFBLE9BQU9jLFVBQVUsQ0FBQ0MsTUFBTSxHQUFHLEtBQU0sQ0FBQ0gsTUFBTUEsT0FBTyxNQUFNLEdBQUk7UUFDMUQsSUFBRyxPQUFPQSxPQUFPLFVBQVU7WUFDekIsdUJBQXVCO1lBQ3ZCQSxLQUFLO1FBQ1A7UUFDQUosSUFBSVEsT0FBT0MsSUFBSSxDQUFDVCxHQUFHO1FBQ25CQyxJQUFJTyxPQUFPQyxJQUFJLENBQUNSLEdB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O0lBQ1Q7SUFFQSxnQkFBZ0I7SUFDaEIsSUFBSUksSUFBSSxHQUFHSztJQUNYLFNBQVNHO1FBQ1AsSUFBR1IsSUFBSVgsS0FBSztZQUNWLE9BQU87WUFDUCxPQUFPYixTQUFTLE1BQU1vQjtRQUN4QjtRQUVBLHdDQUF3QztRQUN4Q0gsSUFBSUUsS0FBSyxDQUFDLE1BQU07UUFDaEJGLElBQUlRLE1BQU0sQ0FBQzdCO1FBQ1hxQixJQUFJUSxNQUFNLENBQUN6QyxNQUFNSSxJQUFJLENBQUNzQyxZQUFZLENBQUNGO1FBQ25DSCxNQUFNRSxPQUFPTixJQUFJVSxNQUFNLEdBQUdDLFFBQVE7UUFFbEMscUNBQXFDO1FBQ3JDQyxJQUFJO1FBQ0pJO0lBQ0Y7SUFFQSxTQUFTQTtRQUNQLElBQUdKLEtBQUtoQyxHQUFHO1lBQ1RvQixJQUFJRSxLQUFLLENBQUMsTUFBTTtZQUNoQkYsSUFBSVEsTUFBTSxDQUFDRjtZQUNYRCxNQUFNTCxJQUFJVSxNQUFNLEdBQUdDLFFBQVE7WUFDM0IsZ0JBQWdCO1lBQ2hCUCxNQUFNckMsTUFBTUksSUFBSSxDQUFDMEMsUUFBUSxDQUFDVCxLQUFLQyxLQUFLWDtZQUNwQ1ksT0FBT0Q7WUFDUCxFQUFFTztZQUNGLE9BQU83QyxNQUFNSSxJQUFJLENBQUM4QyxZQUFZLENBQUNEO1FBQ2pDO1FBRUE7OztnREFHNEMsR0FDNUNiLE1BQU0sSUFBS1AsTUFBT1EsTUFBTUEsSUFBSVUsTUFBTSxDQUFDLEdBQUdmO1FBRXRDLEVBQUVRO1FBQ0ZRO0lBQ0Y7SUFFQUE7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9wYmtkZjIuanM/ZDllMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBhc3N3b3JkLUJhc2VkIEtleS1EZXJpdmF0aW9uIEZ1bmN0aW9uICMyIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFNlZSBSRkMgMjg5OCBmb3IgZGV0YWlscy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vaG1hYycpO1xucmVxdWlyZSgnLi9tZCcpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBwa2NzNSA9IGZvcmdlLnBrY3M1ID0gZm9yZ2UucGtjczUgfHwge307XG5cbnZhciBjcnlwdG87XG5pZihmb3JnZS51dGlsLmlzTm9kZWpzICYmICFmb3JnZS5vcHRpb25zLnVzZVB1cmVKYXZhU2NyaXB0KSB7XG4gIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xufVxuXG4vKipcbiAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuICpcbiAqIEBwYXJhbSBwIHRoZSBwYXNzd29yZCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqIEBwYXJhbSBzIHRoZSBzYWx0IGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICogQHBhcmFtIGMgdGhlIGl0ZXJhdGlvbiBjb3VudCwgYSBwb3NpdGl2ZSBpbnRlZ2VyLlxuICogQHBhcmFtIGRrTGVuIHRoZSBpbnRlbmRlZCBsZW5ndGgsIGluIGJ5dGVzLCBvZiB0aGUgZGVyaXZlZCBrZXksXG4gKiAgICAgICAgICAobWF4OiAyXjMyIC0gMSkgKiBoYXNoIGxlbmd0aCBvZiB0aGUgUFJGLlxuICogQHBhcmFtIFttZF0gdGhlIG1lc3NhZ2UgZGlnZXN0IChvciBhbGdvcml0aG0gaWRlbnRpZmllciBhcyBhIHN0cmluZykgdG8gdXNlXG4gKiAgICAgICAgICBpbiB0aGUgUFJGLCBkZWZhdWx0cyB0byBTSEEtMS5cbiAqIEBwYXJhbSBbY2FsbGJhY2soZXJyLCBrZXkpXSBwcmVzZW5jZSB0cmlnZ2VycyBhc3luY2hyb25vdXMgdmVyc2lvbiwgY2FsbGVkXG4gKiAgICAgICAgICBvbmNlIHRoZSBvcGVyYXRpb24gY29tcGxldGVzLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlcml2ZWQga2V5LCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcywgZm9yIHRoZVxuICogICAgICAgICAgIHN5bmNocm9ub3VzIHZlcnNpb24gKGlmIG5vIGNhbGxiYWNrIGlzIHNwZWNpZmllZCkuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGJrZGYyID0gcGtjczUucGJrZGYyID0gZnVuY3Rpb24oXG4gIHAsIHMsIGMsIGRrTGVuLCBtZCwgY2FsbGJhY2spIHtcbiAgaWYodHlwZW9mIG1kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBtZDtcbiAgICBtZCA9IG51bGw7XG4gIH1cblxuICAvLyB1c2UgbmF0aXZlIGltcGxlbWVudGF0aW9uIGlmIHBvc3NpYmxlIGFuZCBub3QgZGlzYWJsZWQsIG5vdGUgdGhhdFxuICAvLyBzb21lIG5vZGUgdmVyc2lvbnMgb25seSBzdXBwb3J0IFNIQS0xLCBvdGhlcnMgYWxsb3cgZGlnZXN0IHRvIGJlIGNoYW5nZWRcbiAgaWYoZm9yZ2UudXRpbC5pc05vZGVqcyAmJiAhZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCAmJlxuICAgIGNyeXB0by5wYmtkZjIgJiYgKG1kID09PSBudWxsIHx8IHR5cGVvZiBtZCAhPT0gJ29iamVjdCcpICYmXG4gICAgKGNyeXB0by5wYmtkZjJTeW5jLmxlbmd0aCA+IDQgfHwgKCFtZCB8fCBtZCA9PT0gJ3NoYTEnKSkpIHtcbiAgICBpZih0eXBlb2YgbWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBkZWZhdWx0IHByZiB0byBTSEEtMVxuICAgICAgbWQgPSAnc2hhMSc7XG4gICAgfVxuICAgIHAgPSBCdWZmZXIuZnJvbShwLCAnYmluYXJ5Jyk7XG4gICAgcyA9IEJ1ZmZlci5mcm9tKHMsICdiaW5hcnknKTtcbiAgICBpZighY2FsbGJhY2spIHtcbiAgICAgIGlmKGNyeXB0by5wYmtkZjJTeW5jLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICByZXR1cm4gY3J5cHRvLnBia2RmMlN5bmMocCwgcywgYywgZGtMZW4pLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcnlwdG8ucGJrZGYyU3luYyhwLCBzLCBjLCBka0xlbiwgbWQpLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICB9XG4gICAgaWYoY3J5cHRvLnBia2RmMlN5bmMubGVuZ3RoID09PSA0KSB7XG4gICAgICByZXR1cm4gY3J5cHRvLnBia2RmMihwLCBzLCBjLCBka0xlbiwgZnVuY3Rpb24oZXJyLCBrZXkpIHtcbiAgICAgICAgaWYoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobnVsbCwga2V5LnRvU3RyaW5nKCdiaW5hcnknKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyeXB0by5wYmtkZjIocCwgcywgYywgZGtMZW4sIG1kLCBmdW5jdGlvbihlcnIsIGtleSkge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwga2V5LnRvU3RyaW5nKCdiaW5hcnknKSk7XG4gICAgfSk7XG4gIH1cblxuICBpZih0eXBlb2YgbWQgPT09ICd1bmRlZmluZWQnIHx8IG1kID09PSBudWxsKSB7XG4gICAgLy8gZGVmYXVsdCBwcmYgdG8gU0hBLTFcbiAgICBtZCA9ICdzaGExJztcbiAgfVxuICBpZih0eXBlb2YgbWQgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYoIShtZCBpbiBmb3JnZS5tZC5hbGdvcml0aG1zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGhhc2ggYWxnb3JpdGhtOiAnICsgbWQpO1xuICAgIH1cbiAgICBtZCA9IGZvcmdlLm1kW21kXS5jcmVhdGUoKTtcbiAgfVxuXG4gIHZhciBoTGVuID0gbWQuZGlnZXN0TGVuZ3RoO1xuXG4gIC8qIDEuIElmIGRrTGVuID4gKDJeMzIgLSAxKSAqIGhMZW4sIG91dHB1dCBcImRlcml2ZWQga2V5IHRvbyBsb25nXCIgYW5kXG4gICAgc3RvcC4gKi9cbiAgaWYoZGtMZW4gPiAoMHhGRkZGRkZGRiAqIGhMZW4pKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignRGVyaXZlZCBrZXkgaXMgdG9vIGxvbmcuJyk7XG4gICAgaWYoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH1cblxuICAvKiAyLiBMZXQgbGVuIGJlIHRoZSBudW1iZXIgb2YgaExlbi1vY3RldCBibG9ja3MgaW4gdGhlIGRlcml2ZWQga2V5LFxuICAgIHJvdW5kaW5nIHVwLCBhbmQgbGV0IHIgYmUgdGhlIG51bWJlciBvZiBvY3RldHMgaW4gdGhlIGxhc3RcbiAgICBibG9jazpcblxuICAgIGxlbiA9IENFSUwoZGtMZW4gLyBoTGVuKSxcbiAgICByID0gZGtMZW4gLSAobGVuIC0gMSkgKiBoTGVuLiAqL1xuICB2YXIgbGVuID0gTWF0aC5jZWlsKGRrTGVuIC8gaExlbik7XG4gIHZhciByID0gZGtMZW4gLSAobGVuIC0gMSkgKiBoTGVuO1xuXG4gIC8qIDMuIEZvciBlYWNoIGJsb2NrIG9mIHRoZSBkZXJpdmVkIGtleSBhcHBseSB0aGUgZnVuY3Rpb24gRiBkZWZpbmVkXG4gICAgYmVsb3cgdG8gdGhlIHBhc3N3b3JkIFAsIHRoZSBzYWx0IFMsIHRoZSBpdGVyYXRpb24gY291bnQgYywgYW5kXG4gICAgdGhlIGJsb2NrIGluZGV4IHRvIGNvbXB1dGUgdGhlIGJsb2NrOlxuXG4gICAgVF8xID0gRihQLCBTLCBjLCAxKSxcbiAgICBUXzIgPSBGKFAsIFMsIGMsIDIpLFxuICAgIC4uLlxuICAgIFRfbGVuID0gRihQLCBTLCBjLCBsZW4pLFxuXG4gICAgd2hlcmUgdGhlIGZ1bmN0aW9uIEYgaXMgZGVmaW5lZCBhcyB0aGUgZXhjbHVzaXZlLW9yIHN1bSBvZiB0aGVcbiAgICBmaXJzdCBjIGl0ZXJhdGVzIG9mIHRoZSB1bmRlcmx5aW5nIHBzZXVkb3JhbmRvbSBmdW5jdGlvbiBQUkZcbiAgICBhcHBsaWVkIHRvIHRoZSBwYXNzd29yZCBQIGFuZCB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgc2FsdCBTXG4gICAgYW5kIHRoZSBibG9jayBpbmRleCBpOlxuXG4gICAgRihQLCBTLCBjLCBpKSA9IHVfMSBYT1IgdV8yIFhPUiAuLi4gWE9SIHVfY1xuXG4gICAgd2hlcmVcblxuICAgIHVfMSA9IFBSRihQLCBTIHx8IElOVChpKSksXG4gICAgdV8yID0gUFJGKFAsIHVfMSksXG4gICAgLi4uXG4gICAgdV9jID0gUFJGKFAsIHVfe2MtMX0pLlxuXG4gICAgSGVyZSwgSU5UKGkpIGlzIGEgZm91ci1vY3RldCBlbmNvZGluZyBvZiB0aGUgaW50ZWdlciBpLCBtb3N0XG4gICAgc2lnbmlmaWNhbnQgb2N0ZXQgZmlyc3QuICovXG4gIHZhciBwcmYgPSBmb3JnZS5obWFjLmNyZWF0ZSgpO1xuICBwcmYuc3RhcnQobWQsIHApO1xuICB2YXIgZGsgPSAnJztcbiAgdmFyIHhvciwgdV9jLCB1X2MxO1xuXG4gIC8vIHN5bmMgdmVyc2lvblxuICBpZighY2FsbGJhY2spIHtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDw9IGxlbjsgKytpKSB7XG4gICAgICAvLyBQUkYoUCwgUyB8fCBJTlQoaSkpIChmaXJzdCBpdGVyYXRpb24pXG4gICAgICBwcmYuc3RhcnQobnVsbCwgbnVsbCk7XG4gICAgICBwcmYudXBkYXRlKHMpO1xuICAgICAgcHJmLnVwZGF0ZShmb3JnZS51dGlsLmludDMyVG9CeXRlcyhpKSk7XG4gICAgICB4b3IgPSB1X2MxID0gcHJmLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAgIC8vIFBSRihQLCB1X3tjLTF9KSAob3RoZXIgaXRlcmF0aW9ucylcbiAgICAgIGZvcih2YXIgaiA9IDI7IGogPD0gYzsgKytqKSB7XG4gICAgICAgIHByZi5zdGFydChudWxsLCBudWxsKTtcbiAgICAgICAgcHJmLnVwZGF0ZSh1X2MxKTtcbiAgICAgICAgdV9jID0gcHJmLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG4gICAgICAgIC8vIEYocCwgcywgYywgaSlcbiAgICAgICAgeG9yID0gZm9yZ2UudXRpbC54b3JCeXRlcyh4b3IsIHVfYywgaExlbik7XG4gICAgICAgIHVfYzEgPSB1X2M7XG4gICAgICB9XG5cbiAgICAgIC8qIDQuIENvbmNhdGVuYXRlIHRoZSBibG9ja3MgYW5kIGV4dHJhY3QgdGhlIGZpcnN0IGRrTGVuIG9jdGV0cyB0b1xuICAgICAgICBwcm9kdWNlIGEgZGVyaXZlZCBrZXkgREs6XG5cbiAgICAgICAgREsgPSBUXzEgfHwgVF8yIHx8ICAuLi4gIHx8IFRfbGVuPDAuLnItMT4gKi9cbiAgICAgIGRrICs9IChpIDwgbGVuKSA/IHhvciA6IHhvci5zdWJzdHIoMCwgcik7XG4gICAgfVxuICAgIC8qIDUuIE91dHB1dCB0aGUgZGVyaXZlZCBrZXkgREsuICovXG4gICAgcmV0dXJuIGRrO1xuICB9XG5cbiAgLy8gYXN5bmMgdmVyc2lvblxuICB2YXIgaSA9IDEsIGo7XG4gIGZ1bmN0aW9uIG91dGVyKCkge1xuICAgIGlmKGkgPiBsZW4pIHtcbiAgICAgIC8vIGRvbmVcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBkayk7XG4gICAgfVxuXG4gICAgLy8gUFJGKFAsIFMgfHwgSU5UKGkpKSAoZmlyc3QgaXRlcmF0aW9uKVxuICAgIHByZi5zdGFydChudWxsLCBudWxsKTtcbiAgICBwcmYudXBkYXRlKHMpO1xuICAgIHByZi51cGRhdGUoZm9yZ2UudXRpbC5pbnQzMlRvQnl0ZXMoaSkpO1xuICAgIHhvciA9IHVfYzEgPSBwcmYuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcblxuICAgIC8vIFBSRihQLCB1X3tjLTF9KSAob3RoZXIgaXRlcmF0aW9ucylcbiAgICBqID0gMjtcbiAgICBpbm5lcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5uZXIoKSB7XG4gICAgaWYoaiA8PSBjKSB7XG4gICAgICBwcmYuc3RhcnQobnVsbCwgbnVsbCk7XG4gICAgICBwcmYudXBkYXRlKHVfYzEpO1xuICAgICAgdV9jID0gcHJmLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG4gICAgICAvLyBGKHAsIHMsIGMsIGkpXG4gICAgICB4b3IgPSBmb3JnZS51dGlsLnhvckJ5dGVzKHhvciwgdV9jLCBoTGVuKTtcbiAgICAgIHVfYzEgPSB1X2M7XG4gICAgICArK2o7XG4gICAgICByZXR1cm4gZm9yZ2UudXRpbC5zZXRJbW1lZGlhdGUoaW5uZXIpO1xuICAgIH1cblxuICAgIC8qIDQuIENvbmNhdGVuYXRlIHRoZSBibG9ja3MgYW5kIGV4dHJhY3QgdGhlIGZpcnN0IGRrTGVuIG9jdGV0cyB0b1xuICAgICAgcHJvZHVjZSBhIGRlcml2ZWQga2V5IERLOlxuXG4gICAgICBESyA9IFRfMSB8fCBUXzIgfHwgIC4uLiAgfHwgVF9sZW48MC4uci0xPiAqL1xuICAgIGRrICs9IChpIDwgbGVuKSA/IHhvciA6IHhvci5zdWJzdHIoMCwgcik7XG5cbiAgICArK2k7XG4gICAgb3V0ZXIoKTtcbiAgfVxuXG4gIG91dGVyKCk7XG59O1xuIl0sIm5hbWVzIjpbImZvcmdlIiwicmVxdWlyZSIsInBrY3M1IiwiY3J5cHRvIiwidXRpbCIsImlzTm9kZWpzIiwib3B0aW9ucyIsInVzZVB1cmVKYXZhU2NyaXB0IiwibW9kdWxlIiwiZXhwb3J0cyIsInBia2RmMiIsInAiLCJzIiwiYyIsImRrTGVuIiwibWQiLCJjYWxsYmFjayIsInBia2RmMlN5bmMiLCJsZW5ndGgiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJlcnIiLCJrZXkiLCJhbGdvcml0aG1zIiwiRXJyb3IiLCJjcmVhdGUiLCJoTGVuIiwiZGlnZXN0TGVuZ3RoIiwibGVuIiwiTWF0aCIsImNlaWwiLCJyIiwicHJmIiwiaG1hYyIsInN0YXJ0IiwiZGsiLCJ4b3IiLCJ1X2MiLCJ1X2MxIiwiaSIsInVwZGF0ZSIsImludDMyVG9CeXRlcyIsImRpZ2VzdCIsImdldEJ5dGVzIiwiaiIsInhvckJ5dGVzIiwic3Vic3RyIiwib3V0ZXIiLCJpbm5lciIsInNldEltbWVkaWF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/pbkdf2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/pem.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/pem.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Javascript implementation of basic PEM (Privacy Enhanced Mail) algorithms.\n *\n * See: RFC 1421.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2013-2014 Digital Bazaar, Inc.\n *\n * A Forge PEM object has the following fields:\n *\n * type: identifies the type of message (eg: \"RSA PRIVATE KEY\").\n *\n * procType: identifies the type of processing performed on the message,\n *   it has two subfields: version and type, eg: 4,ENCRYPTED.\n *\n * contentDomain: identifies the type of content in the message, typically\n *   only uses the value: \"RFC822\".\n *\n * dekInfo: identifies the message encryption algorithm and mode and includes\n *   any parameters for the algorithm, it has two subfields: algorithm and\n *   parameters, eg: DES-CBC,F8143EDE5960C597.\n *\n * headers: contains all other PEM encapsulated headers -- where order is\n *   significant (for pairing data like recipient ID + key info).\n *\n * body: the binary-encoded body.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\n// shortcut for pem API\nvar pem = module.exports = forge.pem = forge.pem || {};\n/**\n * Encodes (serializes) the given PEM object.\n *\n * @param msg the PEM message object to encode.\n * @param options the options to use:\n *          maxline the maximum characters per line for the body, (default: 64).\n *\n * @return the PEM-formatted string.\n */ pem.encode = function(msg, options) {\n    options = options || {};\n    var rval = \"-----BEGIN \" + msg.type + \"-----\\r\\n\";\n    // encode special headers\n    var header;\n    if (msg.procType) {\n        header = {\n            name: \"Proc-Type\",\n            values: [\n                String(msg.procType.version),\n                msg.procType.type\n            ]\n        };\n        rval += foldHeader(header);\n    }\n    if (msg.contentDomain) {\n        header = {\n            name: \"Content-Domain\",\n            values: [\n                msg.contentDomain\n            ]\n        };\n        rval += foldHeader(header);\n    }\n    if (msg.dekInfo) {\n        header = {\n            name: \"DEK-Info\",\n            values: [\n                msg.dekInfo.algorithm\n            ]\n        };\n        if (msg.dekInfo.parameters) {\n            header.values.push(msg.dekInfo.parameters);\n        }\n        rval += foldHeader(header);\n    }\n    if (msg.headers) {\n        // encode all other headers\n        for(var i = 0; i < msg.headers.length; ++i){\n            rval += foldHeader(msg.headers[i]);\n        }\n    }\n    // terminate header\n    if (msg.procType) {\n        rval += \"\\r\\n\";\n    }\n    // add body\n    rval += forge.util.encode64(msg.body, options.maxline || 64) + \"\\r\\n\";\n    rval += \"-----END \" + msg.type + \"-----\\r\\n\";\n    return rval;\n};\n/**\n * Decodes (deserializes) all PEM messages found in the given string.\n *\n * @param str the PEM-formatted string to decode.\n *\n * @return the PEM message objects in an array.\n */ pem.decode = function(str) {\n    var rval = [];\n    // split string into PEM messages (be lenient w/EOF on BEGIN line)\n    var rMessage = /\\s*-----BEGIN ([A-Z0-9- ]+)-----\\r?\\n?([\\x21-\\x7e\\s]+?(?:\\r?\\n\\r?\\n))?([:A-Za-z0-9+\\/=\\s]+?)-----END \\1-----/g;\n    var rHeader = /([\\x21-\\x7e]+):\\s*([\\x21-\\x7e\\s^:]+)/;\n    var rCRLF = /\\r?\\n/;\n    var match;\n    while(true){\n        match = rMessage.exec(str);\n        if (!match) {\n            break;\n        }\n        // accept \"NEW CERTIFICATE REQUEST\" as \"CERTIFICATE REQUEST\"\n        // https://datatracker.ietf.org/doc/html/rfc7468#section-7\n        var type = match[1];\n        if (type === \"NEW CERTIFICATE REQUEST\") {\n            type = \"CERTIFICATE REQUEST\";\n        }\n        var msg = {\n            type: type,\n            procType: null,\n            contentDomain: null,\n            dekInfo: null,\n            headers: [],\n            body: forge.util.decode64(match[3])\n        };\n        rval.push(msg);\n        // no headers\n        if (!match[2]) {\n            continue;\n        }\n        // parse headers\n        var lines = match[2].split(rCRLF);\n        var li = 0;\n        while(match && li < lines.length){\n            // get line, trim any rhs whitespace\n            var line = lines[li].replace(/\\s+$/, \"\");\n            // RFC2822 unfold any following folded lines\n            for(var nl = li + 1; nl < lines.length; ++nl){\n                var next = lines[nl];\n                if (!/\\s/.test(next[0])) {\n                    break;\n                }\n                line += next;\n                li = nl;\n            }\n            // parse header\n            match = line.match(rHeader);\n            if (match) {\n                var header = {\n                    name: match[1],\n                    values: []\n                };\n                var values = match[2].split(\",\");\n                for(var vi = 0; vi < values.length; ++vi){\n                    header.values.push(ltrim(values[vi]));\n                }\n                // Proc-Type must be the first header\n                if (!msg.procType) {\n                    if (header.name !== \"Proc-Type\") {\n                        throw new Error(\"Invalid PEM formatted message. The first \" + 'encapsulated header must be \"Proc-Type\".');\n                    } else if (header.values.length !== 2) {\n                        throw new Error('Invalid PEM formatted message. The \"Proc-Type\" ' + \"header must have two subfields.\");\n                    }\n                    msg.procType = {\n                        version: values[0],\n                        type: values[1]\n                    };\n                } else if (!msg.contentDomain && header.name === \"Content-Domain\") {\n                    // special-case Content-Domain\n                    msg.contentDomain = values[0] || \"\";\n                } else if (!msg.dekInfo && header.name === \"DEK-Info\") {\n                    // special-case DEK-Info\n                    if (header.values.length === 0) {\n                        throw new Error('Invalid PEM formatted message. The \"DEK-Info\" ' + \"header must have at least one subfield.\");\n                    }\n                    msg.dekInfo = {\n                        algorithm: values[0],\n                        parameters: values[1] || null\n                    };\n                } else {\n                    msg.headers.push(header);\n                }\n            }\n            ++li;\n        }\n        if (msg.procType === \"ENCRYPTED\" && !msg.dekInfo) {\n            throw new Error('Invalid PEM formatted message. The \"DEK-Info\" ' + 'header must be present if \"Proc-Type\" is \"ENCRYPTED\".');\n        }\n    }\n    if (rval.length === 0) {\n        throw new Error(\"Invalid PEM formatted message.\");\n    }\n    return rval;\n};\nfunction foldHeader(header) {\n    var rval = header.name + \": \";\n    // ensure values with CRLF are folded\n    var values = [];\n    var insertSpace = function(match, $1) {\n        return \" \" + $1;\n    };\n    for(var i = 0; i < header.values.length; ++i){\n        values.push(header.values[i].replace(/^(\\S+\\r\\n)/, insertSpace));\n    }\n    rval += values.join(\",\") + \"\\r\\n\";\n    // do folding\n    var length = 0;\n    var candidate = -1;\n    for(var i = 0; i < rval.length; ++i, ++length){\n        if (length > 65 && candidate !== -1) {\n            var insert = rval[candidate];\n            if (insert === \",\") {\n                ++candidate;\n                rval = rval.substr(0, candidate) + \"\\r\\n \" + rval.substr(candidate);\n            } else {\n                rval = rval.substr(0, candidate) + \"\\r\\n\" + insert + rval.substr(candidate + 1);\n            }\n            length = i - candidate - 1;\n            candidate = -1;\n            ++i;\n        } else if (rval[i] === \" \" || rval[i] === \"\t\" || rval[i] === \",\") {\n            candidate = i;\n        }\n    }\n    return rval;\n}\nfunction ltrim(str) {\n    return str.replace(/^\\s+/, \"\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGVtLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EyQkM7QUFDRCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQkEsbUJBQU9BLENBQUM7QUFFUix1QkFBdUI7QUFDdkIsSUFBSUMsTUFBTUMsT0FBT0MsT0FBTyxHQUFHSixNQUFNRSxHQUFHLEdBQUdGLE1BQU1FLEdBQUcsSUFBSSxDQUFDO0FBRXJEOzs7Ozs7OztDQVFDLEdBQ0RBLElBQUlHLE1BQU0sR0FBRyxTQUFTQyxHQUFHLEVBQUVDLE9BQU87SUFDaENBLFVBQVVBLFdBQVcsQ0FBQztJQUN0QixJQUFJQyxPQUFPLGdCQUFnQkYsSUFBSUcsSUFBSSxHQUFHO0lBRXRDLHlCQUF5QjtJQUN6QixJQUFJQztJQUNKLElBQUdKLElBQUlLLFFBQVEsRUFBRTtRQUNmRCxTQUFTO1lBQ1BFLE1BQU07WUFDTkMsUUFBUTtnQkFBQ0MsT0FBT1IsSUFBSUssUUFBUSxDQUFDSSxPQUFPO2dCQUFHVCxJQUFJSyxRQUFRLENBQUNGLElBQUk7YUFBQztRQUMzRDtRQUNBRCxRQUFRUSxXQUFXTjtJQUNyQjtJQUNBLElBQUdKLElBQUlXLGFBQWEsRUFBRTtRQUNwQlAsU0FBUztZQUFDRSxNQUFNO1lBQWtCQyxRQUFRO2dCQUFDUCxJQUFJVyxhQUFhO2FBQUM7UUFBQTtRQUM3RFQsUUFBUVEsV0FBV047SUFDckI7SUFDQSxJQUFHSixJQUFJWSxPQUFPLEVBQUU7UUFDZFIsU0FBUztZQUFDRSxNQUFNO1lBQVlDLFFBQVE7Z0JBQUNQLElBQUlZLE9BQU8sQ0FBQ0MsU0FBUzthQUFDO1FBQUE7UUFDM0QsSUFBR2IsSUFBSVksT0FBTyxDQUFDRSxVQUFVLEVBQUU7WUFDekJWLE9BQU9HLE1BQU0sQ0FBQ1EsSUFBSSxDQUFDZixJQUFJWSxPQUFPLENBQUNFLFVBQVU7UUFDM0M7UUFDQVosUUFBUVEsV0FBV047SUFDckI7SUFFQSxJQUFHSixJQUFJZ0IsT0FBTyxFQUFFO1FBQ2QsMkJBQTJCO1FBQzNCLElBQUksSUFBSUMsSUFBSSxHQUFHQSxJQUFJakIsSUFBSWdCLE9BQU8sQ0FBQ0UsTUFBTSxFQUFFLEVBQUVELEVBQUc7WUFDMUNmLFFBQVFRLFdBQVdWLElBQUlnQixPQUFPLENBQUNDLEVBQUU7UUFDbkM7SUFDRjtJQUVBLG1CQUFtQjtJQUNuQixJQUFHakIsSUFBSUssUUFBUSxFQUFFO1FBQ2ZILFFBQVE7SUFDVjtJQUVBLFdBQVc7SUFDWEEsUUFBUVIsTUFBTXlCLElBQUksQ0FBQ0MsUUFBUSxDQUFDcEIsSUFBSXFCLElBQUksRUFBRXBCLFFBQVFxQixPQUFPLElBQUksTUFBTTtJQUUvRHBCLFFBQVEsY0FBY0YsSUFBSUcsSUFBSSxHQUFHO0lBQ2pDLE9BQU9EO0FBQ1Q7QUFFQTs7Ozs7O0NBTUMsR0FDRE4sSUFBSTJCLE1BQU0sR0FBRyxTQUFTQyxHQUFHO0lBQ3ZCLElBQUl0QixPQUFPLEVBQUU7SUFFYixrRUFBa0U7SUFDbEUsSUFBSXVCLFdBQVc7SUFDZixJQUFJQyxVQUFVO0lBQ2QsSUFBSUMsUUFBUTtJQUNaLElBQUlDO0lBQ0osTUFBTSxLQUFNO1FBQ1ZBLFFBQVFILFNBQVNJLElBQUksQ0FBQ0w7UUFDdEIsSUFBRyxDQUFDSSxPQUFPO1lBQ1Q7UUFDRjtRQUVBLDREQUE0RDtRQUM1RCwwREFBMEQ7UUFDMUQsSUFBSXpCLE9BQU95QixLQUFLLENBQUMsRUFBRTtRQUNuQixJQUFHekIsU0FBUywyQkFBMkI7WUFDckNBLE9BQU87UUFDVDtRQUVBLElBQUlILE1BQU07WUFDUkcsTUFBTUE7WUFDTkUsVUFBVTtZQUNWTSxlQUFlO1lBQ2ZDLFNBQVM7WUFDVEksU0FBUyxFQUFFO1lBQ1hLLE1BQU0zQixNQUFNeUIsSUFBSSxDQUFDVyxRQUFRLENBQUNGLEtBQUssQ0FBQyxFQUFFO1FBQ3BDO1FBQ0ExQixLQUFLYSxJQUFJLENBQUNmO1FBRVYsYUFBYTtRQUNiLElBQUcsQ0FBQzRCLEtBQUssQ0FBQyxFQUFFLEVBQUU7WUFDWjtRQUNGO1FBRUEsZ0JBQWdCO1FBQ2hCLElBQUlHLFFBQVFILEtBQUssQ0FBQyxFQUFFLENBQUNJLEtBQUssQ0FBQ0w7UUFDM0IsSUFBSU0sS0FBSztRQUNULE1BQU1MLFNBQVNLLEtBQUtGLE1BQU1iLE1BQU0sQ0FBRTtZQUNoQyxvQ0FBb0M7WUFDcEMsSUFBSWdCLE9BQU9ILEtBQUssQ0FBQ0UsR0FBRyxDQUFDRSxPQUFPLENBQUMsUUFBUTtZQUVyQyw0Q0FBNEM7WUFDNUMsSUFBSSxJQUFJQyxLQUFLSCxLQUFLLEdBQUdHLEtBQUtMLE1BQU1iLE1BQU0sRUFBRSxFQUFFa0IsR0FBSTtnQkFDNUMsSUFBSUMsT0FBT04sS0FBSyxDQUFDSyxHQUFHO2dCQUNwQixJQUFHLENBQUMsS0FBS0UsSUFBSSxDQUFDRCxJQUFJLENBQUMsRUFBRSxHQUFHO29CQUN0QjtnQkFDRjtnQkFDQUgsUUFBUUc7Z0JBQ1JKLEtBQUtHO1lBQ1A7WUFFQSxlQUFlO1lBQ2ZSLFFBQVFNLEtBQUtOLEtBQUssQ0FBQ0Y7WUFDbkIsSUFBR0UsT0FBTztnQkFDUixJQUFJeEIsU0FBUztvQkFBQ0UsTUFBTXNCLEtBQUssQ0FBQyxFQUFFO29CQUFFckIsUUFBUSxFQUFFO2dCQUFBO2dCQUN4QyxJQUFJQSxTQUFTcUIsS0FBSyxDQUFDLEVBQUUsQ0FBQ0ksS0FBSyxDQUFDO2dCQUM1QixJQUFJLElBQUlPLEtBQUssR0FBR0EsS0FBS2hDLE9BQU9XLE1BQU0sRUFBRSxFQUFFcUIsR0FBSTtvQkFDeENuQyxPQUFPRyxNQUFNLENBQUNRLElBQUksQ0FBQ3lCLE1BQU1qQyxNQUFNLENBQUNnQyxHQUFHO2dCQUNyQztnQkFFQSxxQ0FBcUM7Z0JBQ3JDLElBQUcsQ0FBQ3ZDLElBQUlLLFFBQVEsRUFBRTtvQkFDaEIsSUFBR0QsT0FBT0UsSUFBSSxLQUFLLGFBQWE7d0JBQzlCLE1BQU0sSUFBSW1DLE1BQU0sOENBQ2Q7b0JBQ0osT0FBTyxJQUFHckMsT0FBT0csTUFBTSxDQUFDVyxNQUFNLEtBQUssR0FBRzt3QkFDcEMsTUFBTSxJQUFJdUIsTUFBTSxvREFDZDtvQkFDSjtvQkFDQXpDLElBQUlLLFFBQVEsR0FBRzt3QkFBQ0ksU0FBU0YsTUFBTSxDQUFDLEVBQUU7d0JBQUVKLE1BQU1JLE1BQU0sQ0FBQyxFQUFFO29CQUFBO2dCQUNyRCxPQUFPLElBQUcsQ0FBQ1AsSUFBSVcsYUFBYSxJQUFJUCxPQUFPRSxJQUFJLEtBQUssa0JBQWtCO29CQUNoRSw4QkFBOEI7b0JBQzlCTixJQUFJVyxhQUFhLEdBQUdKLE1BQU0sQ0FBQyxFQUFFLElBQUk7Z0JBQ25DLE9BQU8sSUFBRyxDQUFDUCxJQUFJWSxPQUFPLElBQUlSLE9BQU9FLElBQUksS0FBSyxZQUFZO29CQUNwRCx3QkFBd0I7b0JBQ3hCLElBQUdGLE9BQU9HLE1BQU0sQ0FBQ1csTUFBTSxLQUFLLEdBQUc7d0JBQzdCLE1BQU0sSUFBSXVCLE1BQU0sbURBQ2Q7b0JBQ0o7b0JBQ0F6QyxJQUFJWSxPQUFPLEdBQUc7d0JBQUNDLFdBQVdOLE1BQU0sQ0FBQyxFQUFFO3dCQUFFTyxZQUFZUCxNQUFNLENBQUMsRUFBRSxJQUFJO29CQUFJO2dCQUNwRSxPQUFPO29CQUNMUCxJQUFJZ0IsT0FBTyxDQUFDRCxJQUFJLENBQUNYO2dCQUNuQjtZQUNGO1lBRUEsRUFBRTZCO1FBQ0o7UUFFQSxJQUFHakMsSUFBSUssUUFBUSxLQUFLLGVBQWUsQ0FBQ0wsSUFBSVksT0FBTyxFQUFFO1lBQy9DLE1BQU0sSUFBSTZCLE1BQU0sbURBQ2Q7UUFDSjtJQUNGO0lBRUEsSUFBR3ZDLEtBQUtnQixNQUFNLEtBQUssR0FBRztRQUNwQixNQUFNLElBQUl1QixNQUFNO0lBQ2xCO0lBRUEsT0FBT3ZDO0FBQ1Q7QUFFQSxTQUFTUSxXQUFXTixNQUFNO0lBQ3hCLElBQUlGLE9BQU9FLE9BQU9FLElBQUksR0FBRztJQUV6QixxQ0FBcUM7SUFDckMsSUFBSUMsU0FBUyxFQUFFO0lBQ2YsSUFBSW1DLGNBQWMsU0FBU2QsS0FBSyxFQUFFZSxFQUFFO1FBQ2xDLE9BQU8sTUFBTUE7SUFDZjtJQUNBLElBQUksSUFBSTFCLElBQUksR0FBR0EsSUFBSWIsT0FBT0csTUFBTSxDQUFDVyxNQUFNLEVBQUUsRUFBRUQsRUFBRztRQUM1Q1YsT0FBT1EsSUFBSSxDQUFDWCxPQUFPRyxNQUFNLENBQUNVLEVBQUUsQ0FBQ2tCLE9BQU8sQ0FBQyxjQUFjTztJQUNyRDtJQUNBeEMsUUFBUUssT0FBT3FDLElBQUksQ0FBQyxPQUFPO0lBRTNCLGFBQWE7SUFDYixJQUFJMUIsU0FBUztJQUNiLElBQUkyQixZQUFZLENBQUM7SUFDakIsSUFBSSxJQUFJNUIsSUFBSSxHQUFHQSxJQUFJZixLQUFLZ0IsTUFBTSxFQUFFLEVBQUVELEdBQUcsRUFBRUMsT0FBUTtRQUM3QyxJQUFHQSxTQUFTLE1BQU0yQixjQUFjLENBQUMsR0FBRztZQUNsQyxJQUFJQyxTQUFTNUMsSUFBSSxDQUFDMkMsVUFBVTtZQUM1QixJQUFHQyxXQUFXLEtBQUs7Z0JBQ2pCLEVBQUVEO2dCQUNGM0MsT0FBT0EsS0FBSzZDLE1BQU0sQ0FBQyxHQUFHRixhQUFhLFVBQVUzQyxLQUFLNkMsTUFBTSxDQUFDRjtZQUMzRCxPQUFPO2dCQUNMM0MsT0FBT0EsS0FBSzZDLE1BQU0sQ0FBQyxHQUFHRixhQUNwQixTQUFTQyxTQUFTNUMsS0FBSzZDLE1BQU0sQ0FBQ0YsWUFBWTtZQUM5QztZQUNBM0IsU0FBVUQsSUFBSTRCLFlBQVk7WUFDMUJBLFlBQVksQ0FBQztZQUNiLEVBQUU1QjtRQUNKLE9BQU8sSUFBR2YsSUFBSSxDQUFDZSxFQUFFLEtBQUssT0FBT2YsSUFBSSxDQUFDZSxFQUFFLEtBQUssT0FBUWYsSUFBSSxDQUFDZSxFQUFFLEtBQUssS0FBSztZQUNoRTRCLFlBQVk1QjtRQUNkO0lBQ0Y7SUFFQSxPQUFPZjtBQUNUO0FBRUEsU0FBU3NDLE1BQU1oQixHQUFHO0lBQ2hCLE9BQU9BLElBQUlXLE9BQU8sQ0FBQyxRQUFRO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3BlbS5qcz9hMWI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBiYXNpYyBQRU0gKFByaXZhY3kgRW5oYW5jZWQgTWFpbCkgYWxnb3JpdGhtcy5cbiAqXG4gKiBTZWU6IFJGQyAxNDIxLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqXG4gKiBBIEZvcmdlIFBFTSBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICpcbiAqIHR5cGU6IGlkZW50aWZpZXMgdGhlIHR5cGUgb2YgbWVzc2FnZSAoZWc6IFwiUlNBIFBSSVZBVEUgS0VZXCIpLlxuICpcbiAqIHByb2NUeXBlOiBpZGVudGlmaWVzIHRoZSB0eXBlIG9mIHByb2Nlc3NpbmcgcGVyZm9ybWVkIG9uIHRoZSBtZXNzYWdlLFxuICogICBpdCBoYXMgdHdvIHN1YmZpZWxkczogdmVyc2lvbiBhbmQgdHlwZSwgZWc6IDQsRU5DUllQVEVELlxuICpcbiAqIGNvbnRlbnREb21haW46IGlkZW50aWZpZXMgdGhlIHR5cGUgb2YgY29udGVudCBpbiB0aGUgbWVzc2FnZSwgdHlwaWNhbGx5XG4gKiAgIG9ubHkgdXNlcyB0aGUgdmFsdWU6IFwiUkZDODIyXCIuXG4gKlxuICogZGVrSW5mbzogaWRlbnRpZmllcyB0aGUgbWVzc2FnZSBlbmNyeXB0aW9uIGFsZ29yaXRobSBhbmQgbW9kZSBhbmQgaW5jbHVkZXNcbiAqICAgYW55IHBhcmFtZXRlcnMgZm9yIHRoZSBhbGdvcml0aG0sIGl0IGhhcyB0d28gc3ViZmllbGRzOiBhbGdvcml0aG0gYW5kXG4gKiAgIHBhcmFtZXRlcnMsIGVnOiBERVMtQ0JDLEY4MTQzRURFNTk2MEM1OTcuXG4gKlxuICogaGVhZGVyczogY29udGFpbnMgYWxsIG90aGVyIFBFTSBlbmNhcHN1bGF0ZWQgaGVhZGVycyAtLSB3aGVyZSBvcmRlciBpc1xuICogICBzaWduaWZpY2FudCAoZm9yIHBhaXJpbmcgZGF0YSBsaWtlIHJlY2lwaWVudCBJRCArIGtleSBpbmZvKS5cbiAqXG4gKiBib2R5OiB0aGUgYmluYXJ5LWVuY29kZWQgYm9keS5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIHNob3J0Y3V0IGZvciBwZW0gQVBJXG52YXIgcGVtID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wZW0gPSBmb3JnZS5wZW0gfHwge307XG5cbi8qKlxuICogRW5jb2RlcyAoc2VyaWFsaXplcykgdGhlIGdpdmVuIFBFTSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG1zZyB0aGUgUEVNIG1lc3NhZ2Ugb2JqZWN0IHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSBmb3IgdGhlIGJvZHksIChkZWZhdWx0OiA2NCkuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBzdHJpbmcuXG4gKi9cbnBlbS5lbmNvZGUgPSBmdW5jdGlvbihtc2csIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBydmFsID0gJy0tLS0tQkVHSU4gJyArIG1zZy50eXBlICsgJy0tLS0tXFxyXFxuJztcblxuICAvLyBlbmNvZGUgc3BlY2lhbCBoZWFkZXJzXG4gIHZhciBoZWFkZXI7XG4gIGlmKG1zZy5wcm9jVHlwZSkge1xuICAgIGhlYWRlciA9IHtcbiAgICAgIG5hbWU6ICdQcm9jLVR5cGUnLFxuICAgICAgdmFsdWVzOiBbU3RyaW5nKG1zZy5wcm9jVHlwZS52ZXJzaW9uKSwgbXNnLnByb2NUeXBlLnR5cGVdXG4gICAgfTtcbiAgICBydmFsICs9IGZvbGRIZWFkZXIoaGVhZGVyKTtcbiAgfVxuICBpZihtc2cuY29udGVudERvbWFpbikge1xuICAgIGhlYWRlciA9IHtuYW1lOiAnQ29udGVudC1Eb21haW4nLCB2YWx1ZXM6IFttc2cuY29udGVudERvbWFpbl19O1xuICAgIHJ2YWwgKz0gZm9sZEhlYWRlcihoZWFkZXIpO1xuICB9XG4gIGlmKG1zZy5kZWtJbmZvKSB7XG4gICAgaGVhZGVyID0ge25hbWU6ICdERUstSW5mbycsIHZhbHVlczogW21zZy5kZWtJbmZvLmFsZ29yaXRobV19O1xuICAgIGlmKG1zZy5kZWtJbmZvLnBhcmFtZXRlcnMpIHtcbiAgICAgIGhlYWRlci52YWx1ZXMucHVzaChtc2cuZGVrSW5mby5wYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgcnZhbCArPSBmb2xkSGVhZGVyKGhlYWRlcik7XG4gIH1cblxuICBpZihtc2cuaGVhZGVycykge1xuICAgIC8vIGVuY29kZSBhbGwgb3RoZXIgaGVhZGVyc1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtc2cuaGVhZGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgcnZhbCArPSBmb2xkSGVhZGVyKG1zZy5oZWFkZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyB0ZXJtaW5hdGUgaGVhZGVyXG4gIGlmKG1zZy5wcm9jVHlwZSkge1xuICAgIHJ2YWwgKz0gJ1xcclxcbic7XG4gIH1cblxuICAvLyBhZGQgYm9keVxuICBydmFsICs9IGZvcmdlLnV0aWwuZW5jb2RlNjQobXNnLmJvZHksIG9wdGlvbnMubWF4bGluZSB8fCA2NCkgKyAnXFxyXFxuJztcblxuICBydmFsICs9ICctLS0tLUVORCAnICsgbXNnLnR5cGUgKyAnLS0tLS1cXHJcXG4nO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyAoZGVzZXJpYWxpemVzKSBhbGwgUEVNIG1lc3NhZ2VzIGZvdW5kIGluIHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgUEVNLWZvcm1hdHRlZCBzdHJpbmcgdG8gZGVjb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIFBFTSBtZXNzYWdlIG9iamVjdHMgaW4gYW4gYXJyYXkuXG4gKi9cbnBlbS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIHJ2YWwgPSBbXTtcblxuICAvLyBzcGxpdCBzdHJpbmcgaW50byBQRU0gbWVzc2FnZXMgKGJlIGxlbmllbnQgdy9FT0Ygb24gQkVHSU4gbGluZSlcbiAgdmFyIHJNZXNzYWdlID0gL1xccyotLS0tLUJFR0lOIChbQS1aMC05LSBdKyktLS0tLVxccj9cXG4/KFtcXHgyMS1cXHg3ZVxcc10rPyg/Olxccj9cXG5cXHI/XFxuKSk/KFs6QS1aYS16MC05K1xcLz1cXHNdKz8pLS0tLS1FTkQgXFwxLS0tLS0vZztcbiAgdmFyIHJIZWFkZXIgPSAvKFtcXHgyMS1cXHg3ZV0rKTpcXHMqKFtcXHgyMS1cXHg3ZVxcc146XSspLztcbiAgdmFyIHJDUkxGID0gL1xccj9cXG4vO1xuICB2YXIgbWF0Y2g7XG4gIHdoaWxlKHRydWUpIHtcbiAgICBtYXRjaCA9IHJNZXNzYWdlLmV4ZWMoc3RyKTtcbiAgICBpZighbWF0Y2gpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGFjY2VwdCBcIk5FVyBDRVJUSUZJQ0FURSBSRVFVRVNUXCIgYXMgXCJDRVJUSUZJQ0FURSBSRVFVRVNUXCJcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzc0Njgjc2VjdGlvbi03XG4gICAgdmFyIHR5cGUgPSBtYXRjaFsxXTtcbiAgICBpZih0eXBlID09PSAnTkVXIENFUlRJRklDQVRFIFJFUVVFU1QnKSB7XG4gICAgICB0eXBlID0gJ0NFUlRJRklDQVRFIFJFUVVFU1QnO1xuICAgIH1cblxuICAgIHZhciBtc2cgPSB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgcHJvY1R5cGU6IG51bGwsXG4gICAgICBjb250ZW50RG9tYWluOiBudWxsLFxuICAgICAgZGVrSW5mbzogbnVsbCxcbiAgICAgIGhlYWRlcnM6IFtdLFxuICAgICAgYm9keTogZm9yZ2UudXRpbC5kZWNvZGU2NChtYXRjaFszXSlcbiAgICB9O1xuICAgIHJ2YWwucHVzaChtc2cpO1xuXG4gICAgLy8gbm8gaGVhZGVyc1xuICAgIGlmKCFtYXRjaFsyXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gcGFyc2UgaGVhZGVyc1xuICAgIHZhciBsaW5lcyA9IG1hdGNoWzJdLnNwbGl0KHJDUkxGKTtcbiAgICB2YXIgbGkgPSAwO1xuICAgIHdoaWxlKG1hdGNoICYmIGxpIDwgbGluZXMubGVuZ3RoKSB7XG4gICAgICAvLyBnZXQgbGluZSwgdHJpbSBhbnkgcmhzIHdoaXRlc3BhY2VcbiAgICAgIHZhciBsaW5lID0gbGluZXNbbGldLnJlcGxhY2UoL1xccyskLywgJycpO1xuXG4gICAgICAvLyBSRkMyODIyIHVuZm9sZCBhbnkgZm9sbG93aW5nIGZvbGRlZCBsaW5lc1xuICAgICAgZm9yKHZhciBubCA9IGxpICsgMTsgbmwgPCBsaW5lcy5sZW5ndGg7ICsrbmwpIHtcbiAgICAgICAgdmFyIG5leHQgPSBsaW5lc1tubF07XG4gICAgICAgIGlmKCEvXFxzLy50ZXN0KG5leHRbMF0pKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGluZSArPSBuZXh0O1xuICAgICAgICBsaSA9IG5sO1xuICAgICAgfVxuXG4gICAgICAvLyBwYXJzZSBoZWFkZXJcbiAgICAgIG1hdGNoID0gbGluZS5tYXRjaChySGVhZGVyKTtcbiAgICAgIGlmKG1hdGNoKSB7XG4gICAgICAgIHZhciBoZWFkZXIgPSB7bmFtZTogbWF0Y2hbMV0sIHZhbHVlczogW119O1xuICAgICAgICB2YXIgdmFsdWVzID0gbWF0Y2hbMl0uc3BsaXQoJywnKTtcbiAgICAgICAgZm9yKHZhciB2aSA9IDA7IHZpIDwgdmFsdWVzLmxlbmd0aDsgKyt2aSkge1xuICAgICAgICAgIGhlYWRlci52YWx1ZXMucHVzaChsdHJpbSh2YWx1ZXNbdmldKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcm9jLVR5cGUgbXVzdCBiZSB0aGUgZmlyc3QgaGVhZGVyXG4gICAgICAgIGlmKCFtc2cucHJvY1R5cGUpIHtcbiAgICAgICAgICBpZihoZWFkZXIubmFtZSAhPT0gJ1Byb2MtVHlwZScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQRU0gZm9ybWF0dGVkIG1lc3NhZ2UuIFRoZSBmaXJzdCAnICtcbiAgICAgICAgICAgICAgJ2VuY2Fwc3VsYXRlZCBoZWFkZXIgbXVzdCBiZSBcIlByb2MtVHlwZVwiLicpO1xuICAgICAgICAgIH0gZWxzZSBpZihoZWFkZXIudmFsdWVzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBFTSBmb3JtYXR0ZWQgbWVzc2FnZS4gVGhlIFwiUHJvYy1UeXBlXCIgJyArXG4gICAgICAgICAgICAgICdoZWFkZXIgbXVzdCBoYXZlIHR3byBzdWJmaWVsZHMuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1zZy5wcm9jVHlwZSA9IHt2ZXJzaW9uOiB2YWx1ZXNbMF0sIHR5cGU6IHZhbHVlc1sxXX07XG4gICAgICAgIH0gZWxzZSBpZighbXNnLmNvbnRlbnREb21haW4gJiYgaGVhZGVyLm5hbWUgPT09ICdDb250ZW50LURvbWFpbicpIHtcbiAgICAgICAgICAvLyBzcGVjaWFsLWNhc2UgQ29udGVudC1Eb21haW5cbiAgICAgICAgICBtc2cuY29udGVudERvbWFpbiA9IHZhbHVlc1swXSB8fCAnJztcbiAgICAgICAgfSBlbHNlIGlmKCFtc2cuZGVrSW5mbyAmJiBoZWFkZXIubmFtZSA9PT0gJ0RFSy1JbmZvJykge1xuICAgICAgICAgIC8vIHNwZWNpYWwtY2FzZSBERUstSW5mb1xuICAgICAgICAgIGlmKGhlYWRlci52YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUEVNIGZvcm1hdHRlZCBtZXNzYWdlLiBUaGUgXCJERUstSW5mb1wiICcgK1xuICAgICAgICAgICAgICAnaGVhZGVyIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgc3ViZmllbGQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1zZy5kZWtJbmZvID0ge2FsZ29yaXRobTogdmFsdWVzWzBdLCBwYXJhbWV0ZXJzOiB2YWx1ZXNbMV0gfHwgbnVsbH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXNnLmhlYWRlcnMucHVzaChoZWFkZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgICsrbGk7XG4gICAgfVxuXG4gICAgaWYobXNnLnByb2NUeXBlID09PSAnRU5DUllQVEVEJyAmJiAhbXNnLmRla0luZm8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQRU0gZm9ybWF0dGVkIG1lc3NhZ2UuIFRoZSBcIkRFSy1JbmZvXCIgJyArXG4gICAgICAgICdoZWFkZXIgbXVzdCBiZSBwcmVzZW50IGlmIFwiUHJvYy1UeXBlXCIgaXMgXCJFTkNSWVBURURcIi4nKTtcbiAgICB9XG4gIH1cblxuICBpZihydmFsLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQRU0gZm9ybWF0dGVkIG1lc3NhZ2UuJyk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbmZ1bmN0aW9uIGZvbGRIZWFkZXIoaGVhZGVyKSB7XG4gIHZhciBydmFsID0gaGVhZGVyLm5hbWUgKyAnOiAnO1xuXG4gIC8vIGVuc3VyZSB2YWx1ZXMgd2l0aCBDUkxGIGFyZSBmb2xkZWRcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICB2YXIgaW5zZXJ0U3BhY2UgPSBmdW5jdGlvbihtYXRjaCwgJDEpIHtcbiAgICByZXR1cm4gJyAnICsgJDE7XG4gIH07XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBoZWFkZXIudmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFsdWVzLnB1c2goaGVhZGVyLnZhbHVlc1tpXS5yZXBsYWNlKC9eKFxcUytcXHJcXG4pLywgaW5zZXJ0U3BhY2UpKTtcbiAgfVxuICBydmFsICs9IHZhbHVlcy5qb2luKCcsJykgKyAnXFxyXFxuJztcblxuICAvLyBkbyBmb2xkaW5nXG4gIHZhciBsZW5ndGggPSAwO1xuICB2YXIgY2FuZGlkYXRlID0gLTE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBydmFsLmxlbmd0aDsgKytpLCArK2xlbmd0aCkge1xuICAgIGlmKGxlbmd0aCA+IDY1ICYmIGNhbmRpZGF0ZSAhPT0gLTEpIHtcbiAgICAgIHZhciBpbnNlcnQgPSBydmFsW2NhbmRpZGF0ZV07XG4gICAgICBpZihpbnNlcnQgPT09ICcsJykge1xuICAgICAgICArK2NhbmRpZGF0ZTtcbiAgICAgICAgcnZhbCA9IHJ2YWwuc3Vic3RyKDAsIGNhbmRpZGF0ZSkgKyAnXFxyXFxuICcgKyBydmFsLnN1YnN0cihjYW5kaWRhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnZhbCA9IHJ2YWwuc3Vic3RyKDAsIGNhbmRpZGF0ZSkgK1xuICAgICAgICAgICdcXHJcXG4nICsgaW5zZXJ0ICsgcnZhbC5zdWJzdHIoY2FuZGlkYXRlICsgMSk7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSAoaSAtIGNhbmRpZGF0ZSAtIDEpO1xuICAgICAgY2FuZGlkYXRlID0gLTE7XG4gICAgICArK2k7XG4gICAgfSBlbHNlIGlmKHJ2YWxbaV0gPT09ICcgJyB8fCBydmFsW2ldID09PSAnXFx0JyB8fCBydmFsW2ldID09PSAnLCcpIHtcbiAgICAgIGNhbmRpZGF0ZSA9IGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbmZ1bmN0aW9uIGx0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrLywgJycpO1xufVxuIl0sIm5hbWVzIjpbImZvcmdlIiwicmVxdWlyZSIsInBlbSIsIm1vZHVsZSIsImV4cG9ydHMiLCJlbmNvZGUiLCJtc2ciLCJvcHRpb25zIiwicnZhbCIsInR5cGUiLCJoZWFkZXIiLCJwcm9jVHlwZSIsIm5hbWUiLCJ2YWx1ZXMiLCJTdHJpbmciLCJ2ZXJzaW9uIiwiZm9sZEhlYWRlciIsImNvbnRlbnREb21haW4iLCJkZWtJbmZvIiwiYWxnb3JpdGhtIiwicGFyYW1ldGVycyIsInB1c2giLCJoZWFkZXJzIiwiaSIsImxlbmd0aCIsInV0aWwiLCJlbmNvZGU2NCIsImJvZHkiLCJtYXhsaW5lIiwiZGVjb2RlIiwic3RyIiwick1lc3NhZ2UiLCJySGVhZGVyIiwickNSTEYiLCJtYXRjaCIsImV4ZWMiLCJkZWNvZGU2NCIsImxpbmVzIiwic3BsaXQiLCJsaSIsImxpbmUiLCJyZXBsYWNlIiwibmwiLCJuZXh0IiwidGVzdCIsInZpIiwibHRyaW0iLCJFcnJvciIsImluc2VydFNwYWNlIiwiJDEiLCJqb2luIiwiY2FuZGlkYXRlIiwiaW5zZXJ0Iiwic3Vic3RyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/pem.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/pkcs1.js":
/*!**********************************************!*\
  !*** ./node_modules/node-forge/lib/pkcs1.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Partial implementation of PKCS#1 v2.2: RSA-OEAP\n *\n * Modified but based on the following MIT and BSD licensed code:\n *\n * https://github.com/kjur/jsjws/blob/master/rsa.js:\n *\n * The 'jsjws'(JSON Web Signature JavaScript Library) License\n *\n * Copyright (c) 2012 Kenji Urushima\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * http://webrsa.cvs.sourceforge.net/viewvc/webrsa/Client/RSAES-OAEP.js?content-type=text%2Fplain:\n *\n * RSAES-OAEP.js\n * $Id: RSAES-OAEP.js,v 1.1.1.1 2003/03/19 15:37:20 ellispritchard Exp $\n * JavaScript Implementation of PKCS #1 v2.1 RSA CRYPTOGRAPHY STANDARD (RSA Laboratories, June 14, 2002)\n * Copyright (C) Ellis Pritchard, Guardian Unlimited 2003.\n * Contact: ellis@nukinetics.com\n * Distributed under the BSD License.\n *\n * Official documentation: http://www.rsa.com/rsalabs/node.asp?id=2125\n *\n * @author Evan Jones (http://evanjones.ca/)\n * @author Dave Longley\n *\n * Copyright (c) 2013-2014 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\n__webpack_require__(/*! ./random */ \"(rsc)/./node_modules/node-forge/lib/random.js\");\n__webpack_require__(/*! ./sha1 */ \"(rsc)/./node_modules/node-forge/lib/sha1.js\");\n// shortcut for PKCS#1 API\nvar pkcs1 = module.exports = forge.pkcs1 = forge.pkcs1 || {};\n/**\n * Encode the given RSAES-OAEP message (M) using key, with optional label (L)\n * and seed.\n *\n * This method does not perform RSA encryption, it only encodes the message\n * using RSAES-OAEP.\n *\n * @param key the RSA key to use.\n * @param message the message to encode.\n * @param options the options to use:\n *          label an optional label to use.\n *          seed the seed to use.\n *          md the message digest object to use, undefined for SHA-1.\n *          mgf1 optional mgf1 parameters:\n *            md the message digest object to use for MGF1.\n *\n * @return the encoded message bytes.\n */ pkcs1.encode_rsa_oaep = function(key, message, options) {\n    // parse arguments\n    var label;\n    var seed;\n    var md;\n    var mgf1Md;\n    // legacy args (label, seed, md)\n    if (typeof options === \"string\") {\n        label = options;\n        seed = arguments[3] || undefined;\n        md = arguments[4] || undefined;\n    } else if (options) {\n        label = options.label || undefined;\n        seed = options.seed || undefined;\n        md = options.md || undefined;\n        if (options.mgf1 && options.mgf1.md) {\n            mgf1Md = options.mgf1.md;\n        }\n    }\n    // default OAEP to SHA-1 message digest\n    if (!md) {\n        md = forge.md.sha1.create();\n    } else {\n        md.start();\n    }\n    // default MGF-1 to same as OAEP\n    if (!mgf1Md) {\n        mgf1Md = md;\n    }\n    // compute length in bytes and check output\n    var keyLength = Math.ceil(key.n.bitLength() / 8);\n    var maxLength = keyLength - 2 * md.digestLength - 2;\n    if (message.length > maxLength) {\n        var error = new Error(\"RSAES-OAEP input message length is too long.\");\n        error.length = message.length;\n        error.maxLength = maxLength;\n        throw error;\n    }\n    if (!label) {\n        label = \"\";\n    }\n    md.update(label, \"raw\");\n    var lHash = md.digest();\n    var PS = \"\";\n    var PS_length = maxLength - message.length;\n    for(var i = 0; i < PS_length; i++){\n        PS += \"\\x00\";\n    }\n    var DB = lHash.getBytes() + PS + \"\\x01\" + message;\n    if (!seed) {\n        seed = forge.random.getBytes(md.digestLength);\n    } else if (seed.length !== md.digestLength) {\n        var error = new Error(\"Invalid RSAES-OAEP seed. The seed length must \" + \"match the digest length.\");\n        error.seedLength = seed.length;\n        error.digestLength = md.digestLength;\n        throw error;\n    }\n    var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);\n    var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);\n    var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);\n    var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);\n    // return encoded message\n    return \"\\x00\" + maskedSeed + maskedDB;\n};\n/**\n * Decode the given RSAES-OAEP encoded message (EM) using key, with optional\n * label (L).\n *\n * This method does not perform RSA decryption, it only decodes the message\n * using RSAES-OAEP.\n *\n * @param key the RSA key to use.\n * @param em the encoded message to decode.\n * @param options the options to use:\n *          label an optional label to use.\n *          md the message digest object to use for OAEP, undefined for SHA-1.\n *          mgf1 optional mgf1 parameters:\n *            md the message digest object to use for MGF1.\n *\n * @return the decoded message bytes.\n */ pkcs1.decode_rsa_oaep = function(key, em, options) {\n    // parse args\n    var label;\n    var md;\n    var mgf1Md;\n    // legacy args\n    if (typeof options === \"string\") {\n        label = options;\n        md = arguments[3] || undefined;\n    } else if (options) {\n        label = options.label || undefined;\n        md = options.md || undefined;\n        if (options.mgf1 && options.mgf1.md) {\n            mgf1Md = options.mgf1.md;\n        }\n    }\n    // compute length in bytes\n    var keyLength = Math.ceil(key.n.bitLength() / 8);\n    if (em.length !== keyLength) {\n        var error = new Error(\"RSAES-OAEP encoded message length is invalid.\");\n        error.length = em.length;\n        error.expectedLength = keyLength;\n        throw error;\n    }\n    // default OAEP to SHA-1 message digest\n    if (md === undefined) {\n        md = forge.md.sha1.create();\n    } else {\n        md.start();\n    }\n    // default MGF-1 to same as OAEP\n    if (!mgf1Md) {\n        mgf1Md = md;\n    }\n    if (keyLength < 2 * md.digestLength + 2) {\n        throw new Error(\"RSAES-OAEP key is too short for the hash function.\");\n    }\n    if (!label) {\n        label = \"\";\n    }\n    md.update(label, \"raw\");\n    var lHash = md.digest().getBytes();\n    // split the message into its parts\n    var y = em.charAt(0);\n    var maskedSeed = em.substring(1, md.digestLength + 1);\n    var maskedDB = em.substring(1 + md.digestLength);\n    var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);\n    var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);\n    var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);\n    var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);\n    var lHashPrime = db.substring(0, md.digestLength);\n    // constant time check that all values match what is expected\n    var error = y !== \"\\x00\";\n    // constant time check lHash vs lHashPrime\n    for(var i = 0; i < md.digestLength; ++i){\n        error |= lHash.charAt(i) !== lHashPrime.charAt(i);\n    }\n    // \"constant time\" find the 0x1 byte separating the padding (zeros) from the\n    // message\n    // TODO: It must be possible to do this in a better/smarter way?\n    var in_ps = 1;\n    var index = md.digestLength;\n    for(var j = md.digestLength; j < db.length; j++){\n        var code = db.charCodeAt(j);\n        var is_0 = code & 0x1 ^ 0x1;\n        // non-zero if not 0 or 1 in the ps section\n        var error_mask = in_ps ? 0xfffe : 0x0000;\n        error |= code & error_mask;\n        // latch in_ps to zero after we find 0x1\n        in_ps = in_ps & is_0;\n        index += in_ps;\n    }\n    if (error || db.charCodeAt(index) !== 0x1) {\n        throw new Error(\"Invalid RSAES-OAEP padding.\");\n    }\n    return db.substring(index + 1);\n};\nfunction rsa_mgf1(seed, maskLength, hash) {\n    // default to SHA-1 message digest\n    if (!hash) {\n        hash = forge.md.sha1.create();\n    }\n    var t = \"\";\n    var count = Math.ceil(maskLength / hash.digestLength);\n    for(var i = 0; i < count; ++i){\n        var c = String.fromCharCode(i >> 24 & 0xFF, i >> 16 & 0xFF, i >> 8 & 0xFF, i & 0xFF);\n        hash.start();\n        hash.update(seed + c);\n        t += hash.digest().getBytes();\n    }\n    return t.substring(0, maskLength);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGtjczEuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNENDO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVIsMEJBQTBCO0FBQzFCLElBQUlDLFFBQVFDLE9BQU9DLE9BQU8sR0FBR0osTUFBTUUsS0FBSyxHQUFHRixNQUFNRSxLQUFLLElBQUksQ0FBQztBQUUzRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDREEsTUFBTUcsZUFBZSxHQUFHLFNBQVNDLEdBQUcsRUFBRUMsT0FBTyxFQUFFQyxPQUFPO0lBQ3BELGtCQUFrQjtJQUNsQixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUNKLGdDQUFnQztJQUNoQyxJQUFHLE9BQU9KLFlBQVksVUFBVTtRQUM5QkMsUUFBUUQ7UUFDUkUsT0FBT0csU0FBUyxDQUFDLEVBQUUsSUFBSUM7UUFDdkJILEtBQUtFLFNBQVMsQ0FBQyxFQUFFLElBQUlDO0lBQ3ZCLE9BQU8sSUFBR04sU0FBUztRQUNqQkMsUUFBUUQsUUFBUUMsS0FBSyxJQUFJSztRQUN6QkosT0FBT0YsUUFBUUUsSUFBSSxJQUFJSTtRQUN2QkgsS0FBS0gsUUFBUUcsRUFBRSxJQUFJRztRQUNuQixJQUFHTixRQUFRTyxJQUFJLElBQUlQLFFBQVFPLElBQUksQ0FBQ0osRUFBRSxFQUFFO1lBQ2xDQyxTQUFTSixRQUFRTyxJQUFJLENBQUNKLEVBQUU7UUFDMUI7SUFDRjtJQUVBLHVDQUF1QztJQUN2QyxJQUFHLENBQUNBLElBQUk7UUFDTkEsS0FBS1gsTUFBTVcsRUFBRSxDQUFDSyxJQUFJLENBQUNDLE1BQU07SUFDM0IsT0FBTztRQUNMTixHQUFHTyxLQUFLO0lBQ1Y7SUFFQSxnQ0FBZ0M7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MkIsRUFBRVosU0FBUyxDQUFDLEdBQUdVO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3BrY3MxLmpzPzk1NjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQYXJ0aWFsIGltcGxlbWVudGF0aW9uIG9mIFBLQ1MjMSB2Mi4yOiBSU0EtT0VBUFxuICpcbiAqIE1vZGlmaWVkIGJ1dCBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIE1JVCBhbmQgQlNEIGxpY2Vuc2VkIGNvZGU6XG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2tqdXIvanNqd3MvYmxvYi9tYXN0ZXIvcnNhLmpzOlxuICpcbiAqIFRoZSAnanNqd3MnKEpTT04gV2ViIFNpZ25hdHVyZSBKYXZhU2NyaXB0IExpYnJhcnkpIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgS2VuamkgVXJ1c2hpbWFcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICpcbiAqIGh0dHA6Ly93ZWJyc2EuY3ZzLnNvdXJjZWZvcmdlLm5ldC92aWV3dmMvd2VicnNhL0NsaWVudC9SU0FFUy1PQUVQLmpzP2NvbnRlbnQtdHlwZT10ZXh0JTJGcGxhaW46XG4gKlxuICogUlNBRVMtT0FFUC5qc1xuICogJElkOiBSU0FFUy1PQUVQLmpzLHYgMS4xLjEuMSAyMDAzLzAzLzE5IDE1OjM3OjIwIGVsbGlzcHJpdGNoYXJkIEV4cCAkXG4gKiBKYXZhU2NyaXB0IEltcGxlbWVudGF0aW9uIG9mIFBLQ1MgIzEgdjIuMSBSU0EgQ1JZUFRPR1JBUEhZIFNUQU5EQVJEIChSU0EgTGFib3JhdG9yaWVzLCBKdW5lIDE0LCAyMDAyKVxuICogQ29weXJpZ2h0IChDKSBFbGxpcyBQcml0Y2hhcmQsIEd1YXJkaWFuIFVubGltaXRlZCAyMDAzLlxuICogQ29udGFjdDogZWxsaXNAbnVraW5ldGljcy5jb21cbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbiAqXG4gKiBPZmZpY2lhbCBkb2N1bWVudGF0aW9uOiBodHRwOi8vd3d3LnJzYS5jb20vcnNhbGFicy9ub2RlLmFzcD9pZD0yMTI1XG4gKlxuICogQGF1dGhvciBFdmFuIEpvbmVzIChodHRwOi8vZXZhbmpvbmVzLmNhLylcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5yZXF1aXJlKCcuL3JhbmRvbScpO1xucmVxdWlyZSgnLi9zaGExJyk7XG5cbi8vIHNob3J0Y3V0IGZvciBQS0NTIzEgQVBJXG52YXIgcGtjczEgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnBrY3MxID0gZm9yZ2UucGtjczEgfHwge307XG5cbi8qKlxuICogRW5jb2RlIHRoZSBnaXZlbiBSU0FFUy1PQUVQIG1lc3NhZ2UgKE0pIHVzaW5nIGtleSwgd2l0aCBvcHRpb25hbCBsYWJlbCAoTClcbiAqIGFuZCBzZWVkLlxuICpcbiAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHBlcmZvcm0gUlNBIGVuY3J5cHRpb24sIGl0IG9ubHkgZW5jb2RlcyB0aGUgbWVzc2FnZVxuICogdXNpbmcgUlNBRVMtT0FFUC5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIGxhYmVsIGFuIG9wdGlvbmFsIGxhYmVsIHRvIHVzZS5cbiAqICAgICAgICAgIHNlZWQgdGhlIHNlZWQgdG8gdXNlLlxuICogICAgICAgICAgbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UsIHVuZGVmaW5lZCBmb3IgU0hBLTEuXG4gKiAgICAgICAgICBtZ2YxIG9wdGlvbmFsIG1nZjEgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UgZm9yIE1HRjEuXG4gKlxuICogQHJldHVybiB0aGUgZW5jb2RlZCBtZXNzYWdlIGJ5dGVzLlxuICovXG5wa2NzMS5lbmNvZGVfcnNhX29hZXAgPSBmdW5jdGlvbihrZXksIG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgLy8gcGFyc2UgYXJndW1lbnRzXG4gIHZhciBsYWJlbDtcbiAgdmFyIHNlZWQ7XG4gIHZhciBtZDtcbiAgdmFyIG1nZjFNZDtcbiAgLy8gbGVnYWN5IGFyZ3MgKGxhYmVsLCBzZWVkLCBtZClcbiAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgbGFiZWwgPSBvcHRpb25zO1xuICAgIHNlZWQgPSBhcmd1bWVudHNbM10gfHwgdW5kZWZpbmVkO1xuICAgIG1kID0gYXJndW1lbnRzWzRdIHx8IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmKG9wdGlvbnMpIHtcbiAgICBsYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgdW5kZWZpbmVkO1xuICAgIHNlZWQgPSBvcHRpb25zLnNlZWQgfHwgdW5kZWZpbmVkO1xuICAgIG1kID0gb3B0aW9ucy5tZCB8fCB1bmRlZmluZWQ7XG4gICAgaWYob3B0aW9ucy5tZ2YxICYmIG9wdGlvbnMubWdmMS5tZCkge1xuICAgICAgbWdmMU1kID0gb3B0aW9ucy5tZ2YxLm1kO1xuICAgIH1cbiAgfVxuXG4gIC8vIGRlZmF1bHQgT0FFUCB0byBTSEEtMSBtZXNzYWdlIGRpZ2VzdFxuICBpZighbWQpIHtcbiAgICBtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIH0gZWxzZSB7XG4gICAgbWQuc3RhcnQoKTtcbiAgfVxuXG4gIC8vIGRlZmF1bHQgTUdGLTEgdG8gc2FtZSBhcyBPQUVQXG4gIGlmKCFtZ2YxTWQpIHtcbiAgICBtZ2YxTWQgPSBtZDtcbiAgfVxuXG4gIC8vIGNvbXB1dGUgbGVuZ3RoIGluIGJ5dGVzIGFuZCBjaGVjayBvdXRwdXRcbiAgdmFyIGtleUxlbmd0aCA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuICB2YXIgbWF4TGVuZ3RoID0ga2V5TGVuZ3RoIC0gMiAqIG1kLmRpZ2VzdExlbmd0aCAtIDI7XG4gIGlmKG1lc3NhZ2UubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdSU0FFUy1PQUVQIGlucHV0IG1lc3NhZ2UgbGVuZ3RoIGlzIHRvbyBsb25nLicpO1xuICAgIGVycm9yLmxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoO1xuICAgIGVycm9yLm1heExlbmd0aCA9IG1heExlbmd0aDtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGlmKCFsYWJlbCkge1xuICAgIGxhYmVsID0gJyc7XG4gIH1cbiAgbWQudXBkYXRlKGxhYmVsLCAncmF3Jyk7XG4gIHZhciBsSGFzaCA9IG1kLmRpZ2VzdCgpO1xuXG4gIHZhciBQUyA9ICcnO1xuICB2YXIgUFNfbGVuZ3RoID0gbWF4TGVuZ3RoIC0gbWVzc2FnZS5sZW5ndGg7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBQU19sZW5ndGg7IGkrKykge1xuICAgIFBTICs9ICdcXHgwMCc7XG4gIH1cblxuICB2YXIgREIgPSBsSGFzaC5nZXRCeXRlcygpICsgUFMgKyAnXFx4MDEnICsgbWVzc2FnZTtcblxuICBpZighc2VlZCkge1xuICAgIHNlZWQgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMobWQuZGlnZXN0TGVuZ3RoKTtcbiAgfSBlbHNlIGlmKHNlZWQubGVuZ3RoICE9PSBtZC5kaWdlc3RMZW5ndGgpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0ludmFsaWQgUlNBRVMtT0FFUCBzZWVkLiBUaGUgc2VlZCBsZW5ndGggbXVzdCAnICtcbiAgICAgICdtYXRjaCB0aGUgZGlnZXN0IGxlbmd0aC4nKTtcbiAgICBlcnJvci5zZWVkTGVuZ3RoID0gc2VlZC5sZW5ndGg7XG4gICAgZXJyb3IuZGlnZXN0TGVuZ3RoID0gbWQuZGlnZXN0TGVuZ3RoO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIGRiTWFzayA9IHJzYV9tZ2YxKHNlZWQsIGtleUxlbmd0aCAtIG1kLmRpZ2VzdExlbmd0aCAtIDEsIG1nZjFNZCk7XG4gIHZhciBtYXNrZWREQiA9IGZvcmdlLnV0aWwueG9yQnl0ZXMoREIsIGRiTWFzaywgREIubGVuZ3RoKTtcblxuICB2YXIgc2VlZE1hc2sgPSByc2FfbWdmMShtYXNrZWREQiwgbWQuZGlnZXN0TGVuZ3RoLCBtZ2YxTWQpO1xuICB2YXIgbWFza2VkU2VlZCA9IGZvcmdlLnV0aWwueG9yQnl0ZXMoc2VlZCwgc2VlZE1hc2ssIHNlZWQubGVuZ3RoKTtcblxuICAvLyByZXR1cm4gZW5jb2RlZCBtZXNzYWdlXG4gIHJldHVybiAnXFx4MDAnICsgbWFza2VkU2VlZCArIG1hc2tlZERCO1xufTtcblxuLyoqXG4gKiBEZWNvZGUgdGhlIGdpdmVuIFJTQUVTLU9BRVAgZW5jb2RlZCBtZXNzYWdlIChFTSkgdXNpbmcga2V5LCB3aXRoIG9wdGlvbmFsXG4gKiBsYWJlbCAoTCkuXG4gKlxuICogVGhpcyBtZXRob2QgZG9lcyBub3QgcGVyZm9ybSBSU0EgZGVjcnlwdGlvbiwgaXQgb25seSBkZWNvZGVzIHRoZSBtZXNzYWdlXG4gKiB1c2luZyBSU0FFUy1PQUVQLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIFJTQSBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGVtIHRoZSBlbmNvZGVkIG1lc3NhZ2UgdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgbGFiZWwgYW4gb3B0aW9uYWwgbGFiZWwgdG8gdXNlLlxuICogICAgICAgICAgbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UgZm9yIE9BRVAsIHVuZGVmaW5lZCBmb3IgU0hBLTEuXG4gKiAgICAgICAgICBtZ2YxIG9wdGlvbmFsIG1nZjEgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UgZm9yIE1HRjEuXG4gKlxuICogQHJldHVybiB0aGUgZGVjb2RlZCBtZXNzYWdlIGJ5dGVzLlxuICovXG5wa2NzMS5kZWNvZGVfcnNhX29hZXAgPSBmdW5jdGlvbihrZXksIGVtLCBvcHRpb25zKSB7XG4gIC8vIHBhcnNlIGFyZ3NcbiAgdmFyIGxhYmVsO1xuICB2YXIgbWQ7XG4gIHZhciBtZ2YxTWQ7XG4gIC8vIGxlZ2FjeSBhcmdzXG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIGxhYmVsID0gb3B0aW9ucztcbiAgICBtZCA9IGFyZ3VtZW50c1szXSB8fCB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZihvcHRpb25zKSB7XG4gICAgbGFiZWwgPSBvcHRpb25zLmxhYmVsIHx8IHVuZGVmaW5lZDtcbiAgICBtZCA9IG9wdGlvbnMubWQgfHwgdW5kZWZpbmVkO1xuICAgIGlmKG9wdGlvbnMubWdmMSAmJiBvcHRpb25zLm1nZjEubWQpIHtcbiAgICAgIG1nZjFNZCA9IG9wdGlvbnMubWdmMS5tZDtcbiAgICB9XG4gIH1cblxuICAvLyBjb21wdXRlIGxlbmd0aCBpbiBieXRlc1xuICB2YXIga2V5TGVuZ3RoID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG5cbiAgaWYoZW0ubGVuZ3RoICE9PSBrZXlMZW5ndGgpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1JTQUVTLU9BRVAgZW5jb2RlZCBtZXNzYWdlIGxlbmd0aCBpcyBpbnZhbGlkLicpO1xuICAgIGVycm9yLmxlbmd0aCA9IGVtLmxlbmd0aDtcbiAgICBlcnJvci5leHBlY3RlZExlbmd0aCA9IGtleUxlbmd0aDtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGRlZmF1bHQgT0FFUCB0byBTSEEtMSBtZXNzYWdlIGRpZ2VzdFxuICBpZihtZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICB9IGVsc2Uge1xuICAgIG1kLnN0YXJ0KCk7XG4gIH1cblxuICAvLyBkZWZhdWx0IE1HRi0xIHRvIHNhbWUgYXMgT0FFUFxuICBpZighbWdmMU1kKSB7XG4gICAgbWdmMU1kID0gbWQ7XG4gIH1cblxuICBpZihrZXlMZW5ndGggPCAyICogbWQuZGlnZXN0TGVuZ3RoICsgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignUlNBRVMtT0FFUCBrZXkgaXMgdG9vIHNob3J0IGZvciB0aGUgaGFzaCBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIGlmKCFsYWJlbCkge1xuICAgIGxhYmVsID0gJyc7XG4gIH1cbiAgbWQudXBkYXRlKGxhYmVsLCAncmF3Jyk7XG4gIHZhciBsSGFzaCA9IG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgLy8gc3BsaXQgdGhlIG1lc3NhZ2UgaW50byBpdHMgcGFydHNcbiAgdmFyIHkgPSBlbS5jaGFyQXQoMCk7XG4gIHZhciBtYXNrZWRTZWVkID0gZW0uc3Vic3RyaW5nKDEsIG1kLmRpZ2VzdExlbmd0aCArIDEpO1xuICB2YXIgbWFza2VkREIgPSBlbS5zdWJzdHJpbmcoMSArIG1kLmRpZ2VzdExlbmd0aCk7XG5cbiAgdmFyIHNlZWRNYXNrID0gcnNhX21nZjEobWFza2VkREIsIG1kLmRpZ2VzdExlbmd0aCwgbWdmMU1kKTtcbiAgdmFyIHNlZWQgPSBmb3JnZS51dGlsLnhvckJ5dGVzKG1hc2tlZFNlZWQsIHNlZWRNYXNrLCBtYXNrZWRTZWVkLmxlbmd0aCk7XG5cbiAgdmFyIGRiTWFzayA9IHJzYV9tZ2YxKHNlZWQsIGtleUxlbmd0aCAtIG1kLmRpZ2VzdExlbmd0aCAtIDEsIG1nZjFNZCk7XG4gIHZhciBkYiA9IGZvcmdlLnV0aWwueG9yQnl0ZXMobWFza2VkREIsIGRiTWFzaywgbWFza2VkREIubGVuZ3RoKTtcblxuICB2YXIgbEhhc2hQcmltZSA9IGRiLnN1YnN0cmluZygwLCBtZC5kaWdlc3RMZW5ndGgpO1xuXG4gIC8vIGNvbnN0YW50IHRpbWUgY2hlY2sgdGhhdCBhbGwgdmFsdWVzIG1hdGNoIHdoYXQgaXMgZXhwZWN0ZWRcbiAgdmFyIGVycm9yID0gKHkgIT09ICdcXHgwMCcpO1xuXG4gIC8vIGNvbnN0YW50IHRpbWUgY2hlY2sgbEhhc2ggdnMgbEhhc2hQcmltZVxuICBmb3IodmFyIGkgPSAwOyBpIDwgbWQuZGlnZXN0TGVuZ3RoOyArK2kpIHtcbiAgICBlcnJvciB8PSAobEhhc2guY2hhckF0KGkpICE9PSBsSGFzaFByaW1lLmNoYXJBdChpKSk7XG4gIH1cblxuICAvLyBcImNvbnN0YW50IHRpbWVcIiBmaW5kIHRoZSAweDEgYnl0ZSBzZXBhcmF0aW5nIHRoZSBwYWRkaW5nICh6ZXJvcykgZnJvbSB0aGVcbiAgLy8gbWVzc2FnZVxuICAvLyBUT0RPOiBJdCBtdXN0IGJlIHBvc3NpYmxlIHRvIGRvIHRoaXMgaW4gYSBiZXR0ZXIvc21hcnRlciB3YXk/XG4gIHZhciBpbl9wcyA9IDE7XG4gIHZhciBpbmRleCA9IG1kLmRpZ2VzdExlbmd0aDtcbiAgZm9yKHZhciBqID0gbWQuZGlnZXN0TGVuZ3RoOyBqIDwgZGIubGVuZ3RoOyBqKyspIHtcbiAgICB2YXIgY29kZSA9IGRiLmNoYXJDb2RlQXQoaik7XG5cbiAgICB2YXIgaXNfMCA9IChjb2RlICYgMHgxKSBeIDB4MTtcblxuICAgIC8vIG5vbi16ZXJvIGlmIG5vdCAwIG9yIDEgaW4gdGhlIHBzIHNlY3Rpb25cbiAgICB2YXIgZXJyb3JfbWFzayA9IGluX3BzID8gMHhmZmZlIDogMHgwMDAwO1xuICAgIGVycm9yIHw9IChjb2RlICYgZXJyb3JfbWFzayk7XG5cbiAgICAvLyBsYXRjaCBpbl9wcyB0byB6ZXJvIGFmdGVyIHdlIGZpbmQgMHgxXG4gICAgaW5fcHMgPSBpbl9wcyAmIGlzXzA7XG4gICAgaW5kZXggKz0gaW5fcHM7XG4gIH1cblxuICBpZihlcnJvciB8fCBkYi5jaGFyQ29kZUF0KGluZGV4KSAhPT0gMHgxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFJTQUVTLU9BRVAgcGFkZGluZy4nKTtcbiAgfVxuXG4gIHJldHVybiBkYi5zdWJzdHJpbmcoaW5kZXggKyAxKTtcbn07XG5cbmZ1bmN0aW9uIHJzYV9tZ2YxKHNlZWQsIG1hc2tMZW5ndGgsIGhhc2gpIHtcbiAgLy8gZGVmYXVsdCB0byBTSEEtMSBtZXNzYWdlIGRpZ2VzdFxuICBpZighaGFzaCkge1xuICAgIGhhc2ggPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICB9XG4gIHZhciB0ID0gJyc7XG4gIHZhciBjb3VudCA9IE1hdGguY2VpbChtYXNrTGVuZ3RoIC8gaGFzaC5kaWdlc3RMZW5ndGgpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgIHZhciBjID0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgIChpID4+IDI0KSAmIDB4RkYsIChpID4+IDE2KSAmIDB4RkYsIChpID4+IDgpICYgMHhGRiwgaSAmIDB4RkYpO1xuICAgIGhhc2guc3RhcnQoKTtcbiAgICBoYXNoLnVwZGF0ZShzZWVkICsgYyk7XG4gICAgdCArPSBoYXNoLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG4gIH1cbiAgcmV0dXJuIHQuc3Vic3RyaW5nKDAsIG1hc2tMZW5ndGgpO1xufVxuIl0sIm5hbWVzIjpbImZvcmdlIiwicmVxdWlyZSIsInBrY3MxIiwibW9kdWxlIiwiZXhwb3J0cyIsImVuY29kZV9yc2Ffb2FlcCIsImtleSIsIm1lc3NhZ2UiLCJvcHRpb25zIiwibGFiZWwiLCJzZWVkIiwibWQiLCJtZ2YxTWQiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJtZ2YxIiwic2hhMSIsImNyZWF0ZSIsInN0YXJ0Iiwia2V5TGVuZ3RoIiwiTWF0aCIsImNlaWwiLCJuIiwiYml0TGVuZ3RoIiwibWF4TGVuZ3RoIiwiZGlnZXN0TGVuZ3RoIiwibGVuZ3RoIiwiZXJyb3IiLCJFcnJvciIsInVwZGF0ZSIsImxIYXNoIiwiZGlnZXN0IiwiUFMiLCJQU19sZW5ndGgiLCJpIiwiREIiLCJnZXRCeXRlcyIsInJhbmRvbSIsInNlZWRMZW5ndGgiLCJkYk1hc2siLCJyc2FfbWdmMSIsIm1hc2tlZERCIiwidXRpbCIsInhvckJ5dGVzIiwic2VlZE1hc2siLCJtYXNrZWRTZWVkIiwiZGVjb2RlX3JzYV9vYWVwIiwiZW0iLCJleHBlY3RlZExlbmd0aCIsInkiLCJjaGFyQXQiLCJzdWJzdHJpbmciLCJkYiIsImxIYXNoUHJpbWUiLCJpbl9wcyIsImluZGV4IiwiaiIsImNvZGUiLCJjaGFyQ29kZUF0IiwiaXNfMCIsImVycm9yX21hc2siLCJtYXNrTGVuZ3RoIiwiaGFzaCIsInQiLCJjb3VudCIsImMiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/pkcs1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/pkcs12.js":
/*!***********************************************!*\
  !*** ./node_modules/node-forge/lib/pkcs12.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Javascript implementation of PKCS#12.\n *\n * @author Dave Longley\n * @author Stefan Siegl <stesie@brokenpipe.de>\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n *\n * The ASN.1 representation of PKCS#12 is as follows\n * (see ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12-tc1.pdf for details)\n *\n * PFX ::= SEQUENCE {\n *   version  INTEGER {v3(3)}(v3,...),\n *   authSafe ContentInfo,\n *   macData  MacData OPTIONAL\n * }\n *\n * MacData ::= SEQUENCE {\n *   mac DigestInfo,\n *   macSalt OCTET STRING,\n *   iterations INTEGER DEFAULT 1\n * }\n * Note: The iterations default is for historical reasons and its use is\n * deprecated. A higher value, like 1024, is recommended.\n *\n * DigestInfo is defined in PKCS#7 as follows:\n *\n * DigestInfo ::= SEQUENCE {\n *   digestAlgorithm DigestAlgorithmIdentifier,\n *   digest Digest\n * }\n *\n * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\n *\n * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\n * for the algorithm, if any. In the case of SHA1 there is none.\n *\n * AlgorithmIdentifer ::= SEQUENCE {\n *    algorithm OBJECT IDENTIFIER,\n *    parameters ANY DEFINED BY algorithm OPTIONAL\n * }\n *\n * Digest ::= OCTET STRING\n *\n *\n * ContentInfo ::= SEQUENCE {\n *   contentType ContentType,\n *   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL\n * }\n *\n * ContentType ::= OBJECT IDENTIFIER\n *\n * AuthenticatedSafe ::= SEQUENCE OF ContentInfo\n * -- Data if unencrypted\n * -- EncryptedData if password-encrypted\n * -- EnvelopedData if public key-encrypted\n *\n *\n * SafeContents ::= SEQUENCE OF SafeBag\n *\n * SafeBag ::= SEQUENCE {\n *   bagId     BAG-TYPE.&id ({PKCS12BagSet})\n *   bagValue  [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),\n *   bagAttributes SET OF PKCS12Attribute OPTIONAL\n * }\n *\n * PKCS12Attribute ::= SEQUENCE {\n *   attrId ATTRIBUTE.&id ({PKCS12AttrSet}),\n *   attrValues SET OF ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})\n * } -- This type is compatible with the X.500 type 'Attribute'\n *\n * PKCS12AttrSet ATTRIBUTE ::= {\n *   friendlyName | -- from PKCS #9\n *   localKeyId, -- from PKCS #9\n *   ... -- Other attributes are allowed\n * }\n *\n * CertBag ::= SEQUENCE {\n *   certId    BAG-TYPE.&id   ({CertTypes}),\n *   certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})\n * }\n *\n * x509Certificate BAG-TYPE ::= {OCTET STRING IDENTIFIED BY {certTypes 1}}\n *   -- DER-encoded X.509 certificate stored in OCTET STRING\n *\n * sdsiCertificate BAG-TYPE ::= {IA5String IDENTIFIED BY {certTypes 2}}\n * -- Base64-encoded SDSI certificate stored in IA5String\n *\n * CertTypes BAG-TYPE ::= {\n *   x509Certificate |\n *   sdsiCertificate,\n *   ... -- For future extensions\n * }\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./asn1 */ \"(rsc)/./node_modules/node-forge/lib/asn1.js\");\n__webpack_require__(/*! ./hmac */ \"(rsc)/./node_modules/node-forge/lib/hmac.js\");\n__webpack_require__(/*! ./oids */ \"(rsc)/./node_modules/node-forge/lib/oids.js\");\n__webpack_require__(/*! ./pkcs7asn1 */ \"(rsc)/./node_modules/node-forge/lib/pkcs7asn1.js\");\n__webpack_require__(/*! ./pbe */ \"(rsc)/./node_modules/node-forge/lib/pbe.js\");\n__webpack_require__(/*! ./random */ \"(rsc)/./node_modules/node-forge/lib/random.js\");\n__webpack_require__(/*! ./rsa */ \"(rsc)/./node_modules/node-forge/lib/rsa.js\");\n__webpack_require__(/*! ./sha1 */ \"(rsc)/./node_modules/node-forge/lib/sha1.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\n__webpack_require__(/*! ./x509 */ \"(rsc)/./node_modules/node-forge/lib/x509.js\");\n// shortcut for asn.1 & PKI API\nvar asn1 = forge.asn1;\nvar pki = forge.pki;\n// shortcut for PKCS#12 API\nvar p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {};\nvar contentInfoValidator = {\n    name: \"ContentInfo\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"ContentInfo.contentType\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OID,\n            constructed: false,\n            capture: \"contentType\"\n        },\n        {\n            name: \"ContentInfo.content\",\n            tagClass: asn1.Class.CONTEXT_SPECIFIC,\n            constructed: true,\n            captureAsn1: \"content\"\n        }\n    ]\n};\nvar pfxValidator = {\n    name: \"PFX\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"PFX.version\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"version\"\n        },\n        contentInfoValidator,\n        {\n            name: \"PFX.macData\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            optional: true,\n            captureAsn1: \"mac\",\n            value: [\n                {\n                    name: \"PFX.macData.mac\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.SEQUENCE,\n                    constructed: true,\n                    value: [\n                        {\n                            name: \"PFX.macData.mac.digestAlgorithm\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.SEQUENCE,\n                            constructed: true,\n                            value: [\n                                {\n                                    name: \"PFX.macData.mac.digestAlgorithm.algorithm\",\n                                    tagClass: asn1.Class.UNIVERSAL,\n                                    type: asn1.Type.OID,\n                                    constructed: false,\n                                    capture: \"macAlgorithm\"\n                                },\n                                {\n                                    name: \"PFX.macData.mac.digestAlgorithm.parameters\",\n                                    tagClass: asn1.Class.UNIVERSAL,\n                                    captureAsn1: \"macAlgorithmParameters\"\n                                }\n                            ]\n                        },\n                        {\n                            name: \"PFX.macData.mac.digest\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.OCTETSTRING,\n                            constructed: false,\n                            capture: \"macDigest\"\n                        }\n                    ]\n                },\n                {\n                    name: \"PFX.macData.macSalt\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OCTETSTRING,\n                    constructed: false,\n                    capture: \"macSalt\"\n                },\n                {\n                    name: \"PFX.macData.iterations\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.INTEGER,\n                    constructed: false,\n                    optional: true,\n                    capture: \"macIterations\"\n                }\n            ]\n        }\n    ]\n};\nvar safeBagValidator = {\n    name: \"SafeBag\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"SafeBag.bagId\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OID,\n            constructed: false,\n            capture: \"bagId\"\n        },\n        {\n            name: \"SafeBag.bagValue\",\n            tagClass: asn1.Class.CONTEXT_SPECIFIC,\n            constructed: true,\n            captureAsn1: \"bagValue\"\n        },\n        {\n            name: \"SafeBag.bagAttributes\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SET,\n            constructed: true,\n            optional: true,\n            capture: \"bagAttributes\"\n        }\n    ]\n};\nvar attributeValidator = {\n    name: \"Attribute\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"Attribute.attrId\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OID,\n            constructed: false,\n            capture: \"oid\"\n        },\n        {\n            name: \"Attribute.attrValues\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SET,\n            constructed: true,\n            capture: \"values\"\n        }\n    ]\n};\nvar certBagValidator = {\n    name: \"CertBag\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"CertBag.certId\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OID,\n            constructed: false,\n            capture: \"certId\"\n        },\n        {\n            name: \"CertBag.certValue\",\n            tagClass: asn1.Class.CONTEXT_SPECIFIC,\n            constructed: true,\n            /* So far we only support X.509 certificates (which are wrapped in\n       an OCTET STRING, hence hard code that here). */ value: [\n                {\n                    name: \"CertBag.certValue[0]\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Class.OCTETSTRING,\n                    constructed: false,\n                    capture: \"cert\"\n                }\n            ]\n        }\n    ]\n};\n/**\n * Search SafeContents structure for bags with matching attributes.\n *\n * The search can optionally be narrowed by a certain bag type.\n *\n * @param safeContents the SafeContents structure to search in.\n * @param attrName the name of the attribute to compare against.\n * @param attrValue the attribute value to search for.\n * @param [bagType] bag type to narrow search by.\n *\n * @return an array of matching bags.\n */ function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {\n    var result = [];\n    for(var i = 0; i < safeContents.length; i++){\n        for(var j = 0; j < safeContents[i].safeBags.length; j++){\n            var bag = safeContents[i].safeBags[j];\n            if (bagType !== undefined && bag.type !== bagType) {\n                continue;\n            }\n            // only filter by bag type, no attribute specified\n            if (attrName === null) {\n                result.push(bag);\n                continue;\n            }\n            if (bag.attributes[attrName] !== undefined && bag.attributes[attrName].indexOf(attrValue) >= 0) {\n                result.push(bag);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Converts a PKCS#12 PFX in ASN.1 notation into a PFX object.\n *\n * @param obj The PKCS#12 PFX in ASN.1 notation.\n * @param strict true to use strict DER decoding, false not to (default: true).\n * @param {String} password Password to decrypt with (optional).\n *\n * @return PKCS#12 PFX object.\n */ p12.pkcs12FromAsn1 = function(obj, strict, password) {\n    // handle args\n    if (typeof strict === \"string\") {\n        password = strict;\n        strict = true;\n    } else if (strict === undefined) {\n        strict = true;\n    }\n    // validate PFX and capture data\n    var capture = {};\n    var errors = [];\n    if (!asn1.validate(obj, pfxValidator, capture, errors)) {\n        var error = new Error(\"Cannot read PKCS#12 PFX. \" + \"ASN.1 object is not an PKCS#12 PFX.\");\n        error.errors = error;\n        throw error;\n    }\n    var pfx = {\n        version: capture.version.charCodeAt(0),\n        safeContents: [],\n        /**\n     * Gets bags with matching attributes.\n     *\n     * @param filter the attributes to filter by:\n     *          [localKeyId] the localKeyId to search for.\n     *          [localKeyIdHex] the localKeyId in hex to search for.\n     *          [friendlyName] the friendly name to search for.\n     *          [bagType] bag type to narrow each attribute search by.\n     *\n     * @return a map of attribute type to an array of matching bags or, if no\n     *           attribute was given but a bag type, the map key will be the\n     *           bag type.\n     */ getBags: function(filter) {\n            var rval = {};\n            var localKeyId;\n            if (\"localKeyId\" in filter) {\n                localKeyId = filter.localKeyId;\n            } else if (\"localKeyIdHex\" in filter) {\n                localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);\n            }\n            // filter on bagType only\n            if (localKeyId === undefined && !(\"friendlyName\" in filter) && \"bagType\" in filter) {\n                rval[filter.bagType] = _getBagsByAttribute(pfx.safeContents, null, null, filter.bagType);\n            }\n            if (localKeyId !== undefined) {\n                rval.localKeyId = _getBagsByAttribute(pfx.safeContents, \"localKeyId\", localKeyId, filter.bagType);\n            }\n            if (\"friendlyName\" in filter) {\n                rval.friendlyName = _getBagsByAttribute(pfx.safeContents, \"friendlyName\", filter.friendlyName, filter.bagType);\n            }\n            return rval;\n        },\n        /**\n     * DEPRECATED: use getBags() instead.\n     *\n     * Get bags with matching friendlyName attribute.\n     *\n     * @param friendlyName the friendly name to search for.\n     * @param [bagType] bag type to narrow search by.\n     *\n     * @return an array of bags with matching friendlyName attribute.\n     */ getBagsByFriendlyName: function(friendlyName, bagType) {\n            return _getBagsByAttribute(pfx.safeContents, \"friendlyName\", friendlyName, bagType);\n        },\n        /**\n     * DEPRECATED: use getBags() instead.\n     *\n     * Get bags with matching localKeyId attribute.\n     *\n     * @param localKeyId the localKeyId to search for.\n     * @param [bagType] bag type to narrow search by.\n     *\n     * @return an array of bags with matching localKeyId attribute.\n     */ getBagsByLocalKeyId: function(localKeyId, bagType) {\n            return _getBagsByAttribute(pfx.safeContents, \"localKeyId\", localKeyId, bagType);\n        }\n    };\n    if (capture.version.charCodeAt(0) !== 3) {\n        var error = new Error(\"PKCS#12 PFX of version other than 3 not supported.\");\n        error.version = capture.version.charCodeAt(0);\n        throw error;\n    }\n    if (asn1.derToOid(capture.contentType) !== pki.oids.data) {\n        var error = new Error(\"Only PKCS#12 PFX in password integrity mode supported.\");\n        error.oid = asn1.derToOid(capture.contentType);\n        throw error;\n    }\n    var data = capture.content.value[0];\n    if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {\n        throw new Error(\"PKCS#12 authSafe content data is not an OCTET STRING.\");\n    }\n    data = _decodePkcs7Data(data);\n    // check for MAC\n    if (capture.mac) {\n        var md = null;\n        var macKeyBytes = 0;\n        var macAlgorithm = asn1.derToOid(capture.macAlgorithm);\n        switch(macAlgorithm){\n            case pki.oids.sha1:\n                md = forge.md.sha1.create();\n                macKeyBytes = 20;\n                break;\n            case pki.oids.sha256:\n                md = forge.md.sha256.create();\n                macKeyBytes = 32;\n                break;\n            case pki.oids.sha384:\n                md = forge.md.sha384.create();\n                macKeyBytes = 48;\n                break;\n            case pki.oids.sha512:\n                md = forge.md.sha512.create();\n                macKeyBytes = 64;\n                break;\n            case pki.oids.md5:\n                md = forge.md.md5.create();\n                macKeyBytes = 16;\n                break;\n        }\n        if (md === null) {\n            throw new Error(\"PKCS#12 uses unsupported MAC algorithm: \" + macAlgorithm);\n        }\n        // verify MAC (iterations default to 1)\n        var macSalt = new forge.util.ByteBuffer(capture.macSalt);\n        var macIterations = \"macIterations\" in capture ? parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1;\n        var macKey = p12.generateKey(password, macSalt, 3, macIterations, macKeyBytes, md);\n        var mac = forge.hmac.create();\n        mac.start(md, macKey);\n        mac.update(data.value);\n        var macValue = mac.getMac();\n        if (macValue.getBytes() !== capture.macDigest) {\n            throw new Error(\"PKCS#12 MAC could not be verified. Invalid password?\");\n        }\n    }\n    _decodeAuthenticatedSafe(pfx, data.value, strict, password);\n    return pfx;\n};\n/**\n * Decodes PKCS#7 Data. PKCS#7 (RFC 2315) defines \"Data\" as an OCTET STRING,\n * but it is sometimes an OCTET STRING that is composed/constructed of chunks,\n * each its own OCTET STRING. This is BER-encoding vs. DER-encoding. This\n * function transforms this corner-case into the usual simple,\n * non-composed/constructed OCTET STRING.\n *\n * This function may be moved to ASN.1 at some point to better deal with\n * more BER-encoding issues, should they arise.\n *\n * @param data the ASN.1 Data object to transform.\n */ function _decodePkcs7Data(data) {\n    // handle special case of \"chunked\" data content: an octet string composed\n    // of other octet strings\n    if (data.composed || data.constructed) {\n        var value = forge.util.createBuffer();\n        for(var i = 0; i < data.value.length; ++i){\n            value.putBytes(data.value[i].value);\n        }\n        data.composed = data.constructed = false;\n        data.value = value.getBytes();\n    }\n    return data;\n}\n/**\n * Decode PKCS#12 AuthenticatedSafe (BER encoded) into PFX object.\n *\n * The AuthenticatedSafe is a BER-encoded SEQUENCE OF ContentInfo.\n *\n * @param pfx The PKCS#12 PFX object to fill.\n * @param {String} authSafe BER-encoded AuthenticatedSafe.\n * @param strict true to use strict DER decoding, false not to.\n * @param {String} password Password to decrypt with (optional).\n */ function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {\n    authSafe = asn1.fromDer(authSafe, strict); /* actually it's BER encoded */ \n    if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) {\n        throw new Error(\"PKCS#12 AuthenticatedSafe expected to be a \" + \"SEQUENCE OF ContentInfo\");\n    }\n    for(var i = 0; i < authSafe.value.length; i++){\n        var contentInfo = authSafe.value[i];\n        // validate contentInfo and capture data\n        var capture = {};\n        var errors = [];\n        if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {\n            var error = new Error(\"Cannot read ContentInfo.\");\n            error.errors = errors;\n            throw error;\n        }\n        var obj = {\n            encrypted: false\n        };\n        var safeContents = null;\n        var data = capture.content.value[0];\n        switch(asn1.derToOid(capture.contentType)){\n            case pki.oids.data:\n                if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {\n                    throw new Error(\"PKCS#12 SafeContents Data is not an OCTET STRING.\");\n                }\n                safeContents = _decodePkcs7Data(data).value;\n                break;\n            case pki.oids.encryptedData:\n                safeContents = _decryptSafeContents(data, password);\n                obj.encrypted = true;\n                break;\n            default:\n                var error = new Error(\"Unsupported PKCS#12 contentType.\");\n                error.contentType = asn1.derToOid(capture.contentType);\n                throw error;\n        }\n        obj.safeBags = _decodeSafeContents(safeContents, strict, password);\n        pfx.safeContents.push(obj);\n    }\n}\n/**\n * Decrypt PKCS#7 EncryptedData structure.\n *\n * @param data ASN.1 encoded EncryptedContentInfo object.\n * @param password The user-provided password.\n *\n * @return The decrypted SafeContents (ASN.1 object).\n */ function _decryptSafeContents(data, password) {\n    var capture = {};\n    var errors = [];\n    if (!asn1.validate(data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {\n        var error = new Error(\"Cannot read EncryptedContentInfo.\");\n        error.errors = errors;\n        throw error;\n    }\n    var oid = asn1.derToOid(capture.contentType);\n    if (oid !== pki.oids.data) {\n        var error = new Error(\"PKCS#12 EncryptedContentInfo ContentType is not Data.\");\n        error.oid = oid;\n        throw error;\n    }\n    // get cipher\n    oid = asn1.derToOid(capture.encAlgorithm);\n    var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);\n    // get encrypted data\n    var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);\n    var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);\n    cipher.update(encrypted);\n    if (!cipher.finish()) {\n        throw new Error(\"Failed to decrypt PKCS#12 SafeContents.\");\n    }\n    return cipher.output.getBytes();\n}\n/**\n * Decode PKCS#12 SafeContents (BER-encoded) into array of Bag objects.\n *\n * The safeContents is a BER-encoded SEQUENCE OF SafeBag.\n *\n * @param {String} safeContents BER-encoded safeContents.\n * @param strict true to use strict DER decoding, false not to.\n * @param {String} password Password to decrypt with (optional).\n *\n * @return {Array} Array of Bag objects.\n */ function _decodeSafeContents(safeContents, strict, password) {\n    // if strict and no safe contents, return empty safes\n    if (!strict && safeContents.length === 0) {\n        return [];\n    }\n    // actually it's BER-encoded\n    safeContents = asn1.fromDer(safeContents, strict);\n    if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) {\n        throw new Error(\"PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.\");\n    }\n    var res = [];\n    for(var i = 0; i < safeContents.value.length; i++){\n        var safeBag = safeContents.value[i];\n        // validate SafeBag and capture data\n        var capture = {};\n        var errors = [];\n        if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {\n            var error = new Error(\"Cannot read SafeBag.\");\n            error.errors = errors;\n            throw error;\n        }\n        /* Create bag object and push to result array. */ var bag = {\n            type: asn1.derToOid(capture.bagId),\n            attributes: _decodeBagAttributes(capture.bagAttributes)\n        };\n        res.push(bag);\n        var validator, decoder;\n        var bagAsn1 = capture.bagValue.value[0];\n        switch(bag.type){\n            case pki.oids.pkcs8ShroudedKeyBag:\n                /* bagAsn1 has a EncryptedPrivateKeyInfo, which we need to decrypt.\n           Afterwards we can handle it like a keyBag,\n           which is a PrivateKeyInfo. */ bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);\n                if (bagAsn1 === null) {\n                    throw new Error(\"Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?\");\n                }\n            /* fall through */ case pki.oids.keyBag:\n                /* A PKCS#12 keyBag is a simple PrivateKeyInfo as understood by our\n           PKI module, hence we don't have to do validation/capturing here,\n           just pass what we already got. */ try {\n                    bag.key = pki.privateKeyFromAsn1(bagAsn1);\n                } catch (e) {\n                    // ignore unknown key type, pass asn1 value\n                    bag.key = null;\n                    bag.asn1 = bagAsn1;\n                }\n                continue; /* Nothing more to do. */ \n            case pki.oids.certBag:\n                /* A PKCS#12 certBag can wrap both X.509 and sdsi certificates.\n           Therefore put the SafeBag content through another validator to\n           capture the fields.  Afterwards check & store the results. */ validator = certBagValidator;\n                decoder = function() {\n                    if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {\n                        var error = new Error(\"Unsupported certificate type, only X.509 supported.\");\n                        error.oid = asn1.derToOid(capture.certId);\n                        throw error;\n                    }\n                    // true=produce cert hash\n                    var certAsn1 = asn1.fromDer(capture.cert, strict);\n                    try {\n                        bag.cert = pki.certificateFromAsn1(certAsn1, true);\n                    } catch (e) {\n                        // ignore unknown cert type, pass asn1 value\n                        bag.cert = null;\n                        bag.asn1 = certAsn1;\n                    }\n                };\n                break;\n            default:\n                var error = new Error(\"Unsupported PKCS#12 SafeBag type.\");\n                error.oid = bag.type;\n                throw error;\n        }\n        /* Validate SafeBag value (i.e. CertBag, etc.) and capture data if needed. */ if (validator !== undefined && !asn1.validate(bagAsn1, validator, capture, errors)) {\n            var error = new Error(\"Cannot read PKCS#12 \" + validator.name);\n            error.errors = errors;\n            throw error;\n        }\n        /* Call decoder function from above to store the results. */ decoder();\n    }\n    return res;\n}\n/**\n * Decode PKCS#12 SET OF PKCS12Attribute into JavaScript object.\n *\n * @param attributes SET OF PKCS12Attribute (ASN.1 object).\n *\n * @return the decoded attributes.\n */ function _decodeBagAttributes(attributes) {\n    var decodedAttrs = {};\n    if (attributes !== undefined) {\n        for(var i = 0; i < attributes.length; ++i){\n            var capture = {};\n            var errors = [];\n            if (!asn1.validate(attributes[i], attributeValidator, capture, errors)) {\n                var error = new Error(\"Cannot read PKCS#12 BagAttribute.\");\n                error.errors = errors;\n                throw error;\n            }\n            var oid = asn1.derToOid(capture.oid);\n            if (pki.oids[oid] === undefined) {\n                continue;\n            }\n            decodedAttrs[pki.oids[oid]] = [];\n            for(var j = 0; j < capture.values.length; ++j){\n                decodedAttrs[pki.oids[oid]].push(capture.values[j].value);\n            }\n        }\n    }\n    return decodedAttrs;\n}\n/**\n * Wraps a private key and certificate in a PKCS#12 PFX wrapper. If a\n * password is provided then the private key will be encrypted.\n *\n * An entire certificate chain may also be included. To do this, pass\n * an array for the \"cert\" parameter where the first certificate is\n * the one that is paired with the private key and each subsequent one\n * verifies the previous one. The certificates may be in PEM format or\n * have been already parsed by Forge.\n *\n * @todo implement password-based-encryption for the whole package\n *\n * @param key the private key.\n * @param cert the certificate (may be an array of certificates in order\n *          to specify a certificate chain).\n * @param password the password to use, null for none.\n * @param options:\n *          algorithm the encryption algorithm to use\n *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.\n *          count the iteration count to use.\n *          saltSize the salt size to use.\n *          useMac true to include a MAC, false not to, defaults to true.\n *          localKeyId the local key ID to use, in hex.\n *          friendlyName the friendly name to use.\n *          generateLocalKeyId true to generate a random local key ID,\n *            false not to, defaults to true.\n *\n * @return the PKCS#12 PFX ASN.1 object.\n */ p12.toPkcs12Asn1 = function(key, cert, password, options) {\n    // set default options\n    options = options || {};\n    options.saltSize = options.saltSize || 8;\n    options.count = options.count || 2048;\n    options.algorithm = options.algorithm || options.encAlgorithm || \"aes128\";\n    if (!(\"useMac\" in options)) {\n        options.useMac = true;\n    }\n    if (!(\"localKeyId\" in options)) {\n        options.localKeyId = null;\n    }\n    if (!(\"generateLocalKeyId\" in options)) {\n        options.generateLocalKeyId = true;\n    }\n    var localKeyId = options.localKeyId;\n    var bagAttrs;\n    if (localKeyId !== null) {\n        localKeyId = forge.util.hexToBytes(localKeyId);\n    } else if (options.generateLocalKeyId) {\n        // use SHA-1 of paired cert, if available\n        if (cert) {\n            var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;\n            if (typeof pairedCert === \"string\") {\n                pairedCert = pki.certificateFromPem(pairedCert);\n            }\n            var sha1 = forge.md.sha1.create();\n            sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());\n            localKeyId = sha1.digest().getBytes();\n        } else {\n            // FIXME: consider using SHA-1 of public key (which can be generated\n            // from private key components), see: cert.generateSubjectKeyIdentifier\n            // generate random bytes\n            localKeyId = forge.random.getBytes(20);\n        }\n    }\n    var attrs = [];\n    if (localKeyId !== null) {\n        attrs.push(// localKeyID\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // attrId\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.localKeyId).getBytes()),\n            // attrValues\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, localKeyId)\n            ])\n        ]));\n    }\n    if (\"friendlyName\" in options) {\n        attrs.push(// friendlyName\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // attrId\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.friendlyName).getBytes()),\n            // attrValues\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false, options.friendlyName)\n            ])\n        ]));\n    }\n    if (attrs.length > 0) {\n        bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);\n    }\n    // collect contents for AuthenticatedSafe\n    var contents = [];\n    // create safe bag(s) for certificate chain\n    var chain = [];\n    if (cert !== null) {\n        if (forge.util.isArray(cert)) {\n            chain = cert;\n        } else {\n            chain = [\n                cert\n            ];\n        }\n    }\n    var certSafeBags = [];\n    for(var i = 0; i < chain.length; ++i){\n        // convert cert from PEM as necessary\n        cert = chain[i];\n        if (typeof cert === \"string\") {\n            cert = pki.certificateFromPem(cert);\n        }\n        // SafeBag\n        var certBagAttrs = i === 0 ? bagAttrs : undefined;\n        var certAsn1 = pki.certificateToAsn1(cert);\n        var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // bagId\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.certBag).getBytes()),\n            // bagValue\n            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n                // CertBag\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                    // certId\n                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.x509Certificate).getBytes()),\n                    // certValue (x509Certificate)\n                    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n                        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certAsn1).getBytes())\n                    ])\n                ])\n            ]),\n            // bagAttributes (OPTIONAL)\n            certBagAttrs\n        ]);\n        certSafeBags.push(certSafeBag);\n    }\n    if (certSafeBags.length > 0) {\n        // SafeContents\n        var certSafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags);\n        // ContentInfo\n        var certCI = // PKCS#7 ContentInfo\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // contentType\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, // OID for the content type is 'data'\n            asn1.oidToDer(pki.oids.data).getBytes()),\n            // content\n            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certSafeContents).getBytes())\n            ])\n        ]);\n        contents.push(certCI);\n    }\n    // create safe contents for private key\n    var keyBag = null;\n    if (key !== null) {\n        // SafeBag\n        var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));\n        if (password === null) {\n            // no encryption\n            keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                // bagId\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.keyBag).getBytes()),\n                // bagValue\n                asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n                    // PrivateKeyInfo\n                    pkAsn1\n                ]),\n                // bagAttributes (OPTIONAL)\n                bagAttrs\n            ]);\n        } else {\n            // encrypted PrivateKeyInfo\n            keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                // bagId\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()),\n                // bagValue\n                asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n                    // EncryptedPrivateKeyInfo\n                    pki.encryptPrivateKeyInfo(pkAsn1, password, options)\n                ]),\n                // bagAttributes (OPTIONAL)\n                bagAttrs\n            ]);\n        }\n        // SafeContents\n        var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            keyBag\n        ]);\n        // ContentInfo\n        var keyCI = // PKCS#7 ContentInfo\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // contentType\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, // OID for the content type is 'data'\n            asn1.oidToDer(pki.oids.data).getBytes()),\n            // content\n            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(keySafeContents).getBytes())\n            ])\n        ]);\n        contents.push(keyCI);\n    }\n    // create AuthenticatedSafe by stringing together the contents\n    var safe = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents);\n    var macData;\n    if (options.useMac) {\n        // MacData\n        var sha1 = forge.md.sha1.create();\n        var macSalt = new forge.util.ByteBuffer(forge.random.getBytes(options.saltSize));\n        var count = options.count;\n        // 160-bit key\n        var key = p12.generateKey(password, macSalt, 3, count, 20);\n        var mac = forge.hmac.create();\n        mac.start(sha1, key);\n        mac.update(asn1.toDer(safe).getBytes());\n        var macValue = mac.getMac();\n        macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // mac DigestInfo\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                // digestAlgorithm\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                    // algorithm = SHA-1\n                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.sha1).getBytes()),\n                    // parameters = Null\n                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n                ]),\n                // digest\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macValue.getBytes())\n            ]),\n            // macSalt OCTET STRING\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()),\n            // iterations INTEGER (XXX: Only support count < 65536)\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(count).getBytes())\n        ]);\n    }\n    // PFX\n    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // version (3)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(3).getBytes()),\n        // PKCS#7 ContentInfo\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // contentType\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, // OID for the content type is 'data'\n            asn1.oidToDer(pki.oids.data).getBytes()),\n            // content\n            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(safe).getBytes())\n            ])\n        ]),\n        macData\n    ]);\n};\n/**\n * Derives a PKCS#12 key.\n *\n * @param password the password to derive the key material from, null or\n *          undefined for none.\n * @param salt the salt, as a ByteBuffer, to use.\n * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).\n * @param iter the iteration count.\n * @param n the number of bytes to derive from the password.\n * @param md the message digest to use, defaults to SHA-1.\n *\n * @return a ByteBuffer with the bytes derived from the password.\n */ p12.generateKey = forge.pbe.generatePkcs12Key;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGtjczEyLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBOEZDO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVIsK0JBQStCO0FBQy9CLElBQUlDLE9BQU9GLE1BQU1FLElBQUk7QUFDckIsSUFBSUMsTUFBTUgsTUFBTUcsR0FBRztBQUVuQiwyQkFBMkI7QUFDM0IsSUFBSUMsTUFBTUMsT0FBT0MsT0FBTyxHQUFHTixNQUFNTyxNQUFNLEdBQUdQLE1BQU1PLE1BQU0sSUFBSSxDQUFDO0FBRTNELElBQUlDLHVCQUF1QjtJQUN6QkMsTUFBTTtJQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7SUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0MsUUFBUTtJQUN4QkMsYUFBYTtJQUNiQyxPQUFPO1FBQUM7WUFDTlIsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0ksR0FBRztZQUNuQkYsYUFBYTtZQUNiRyxTQUFTO1FBQ1g7UUFBRztZQUNEVixNQUFNO1lBQ05DLFVBQVVSLEtBQUtTLEtBQUssQ0FBQ1MsZ0JBQWdCO1lBQ3JDSixhQUFhO1lBQ2JLLGFBQWE7UUFDZjtLQUFFO0FBQ0o7QUFFQSxJQUFJQyxlQUFlO0lBQ2pCYixN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QUNDLFNBQVMsRUFBRVYsS0FBS1ksSUFBSSxDQUFDQyxRQUFRLEVBQUUsTUFBTTtRQUNqRSxjQUFjO1FBQ2RiLEtBQUs0RSxNQUFNLENBQUM1RSxLQUFLUyxLQUFLLENBQUNDLFNBQVMsRUFBRVYsS0FBS1ksSUFBSSxDQUFDUyxPQUFPLEVBQUUsT0FDbkRyQixLQUFLNkssWUFBWSxDQUFDLEdBQUdoRixRQUFRO1FBQy9CLHFCQUFxQjtRQUNyQjdGLEtBQUs0RSxNQUFNLENBQUM1RSxLQUFLUyxLQUFLLENBQUNDLFNBQVMsRUFBRVYsS0FBS1ksSUFBSSxDQUFDQyxRQUFRLEVBQUUsTUFBTTtZQUMxRCxjQUFjO1lBQ2RiLEtBQUs0RSxNQUFNLENBQUM1RSxLQUFLUyxLQUFLLENBQUNDLFNBQVMsRUFBRVYsS0FBS1ksSUFBSSxDQUFDSSxHQUFHLEVBQUUsT0FDL0MscUNBQXFDO1lBQ3JDaEIsS0FBSzJKLFFBQVEsQ0FBQzFKLElBQUlpRSxJQUFJLENBQUNDLElBQUksRUFBRTBCLFFBQVE7WUFDdkMsVUFBVTtZQUNWN0YsS0FBSzRFLE1BQU0sQ0FBQzVFLEtBQUtTLEtBQUssQ0FBQ1MsZ0JBQWdCLEVBQUUsR0FBRyxNQUFNO2dCQUNoRGxCLEtBQUs0RSxNQUFNLENBQ1Q1RSxLQUFLUyxLQUFLLENBQUNDLFNBQVMsRUFBRVYsS0FBS1ksSUFBSSxDQUFDVyxXQUFXLEVBQUUsT0FDN0N2QixLQUFLc0osS0FBSyxDQUFDb0IsTUFBTTdFLFFBQVE7YUFDNUI7U0FDRjtRQUNEOEU7S0FDRDtBQUNIO0FBRUE7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0R6SyxJQUFJcUYsV0FBVyxHQUFHekYsTUFBTWdILEdBQUcsQ0FBQ2dFLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9wa2NzMTIuanM/NmNiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgUEtDUyMxMi5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICogQGF1dGhvciBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBUaGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgUEtDUyMxMiBpcyBhcyBmb2xsb3dzXG4gKiAoc2VlIGZ0cDovL2Z0cC5yc2FzZWN1cml0eS5jb20vcHViL3BrY3MvcGtjcy0xMi9wa2NzLTEyLXRjMS5wZGYgZm9yIGRldGFpbHMpXG4gKlxuICogUEZYIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gIElOVEVHRVIge3YzKDMpfSh2MywuLi4pLFxuICogICBhdXRoU2FmZSBDb250ZW50SW5mbyxcbiAqICAgbWFjRGF0YSAgTWFjRGF0YSBPUFRJT05BTFxuICogfVxuICpcbiAqIE1hY0RhdGEgOjo9IFNFUVVFTkNFIHtcbiAqICAgbWFjIERpZ2VzdEluZm8sXG4gKiAgIG1hY1NhbHQgT0NURVQgU1RSSU5HLFxuICogICBpdGVyYXRpb25zIElOVEVHRVIgREVGQVVMVCAxXG4gKiB9XG4gKiBOb3RlOiBUaGUgaXRlcmF0aW9ucyBkZWZhdWx0IGlzIGZvciBoaXN0b3JpY2FsIHJlYXNvbnMgYW5kIGl0cyB1c2UgaXNcbiAqIGRlcHJlY2F0ZWQuIEEgaGlnaGVyIHZhbHVlLCBsaWtlIDEwMjQsIGlzIHJlY29tbWVuZGVkLlxuICpcbiAqIERpZ2VzdEluZm8gaXMgZGVmaW5lZCBpbiBQS0NTIzcgYXMgZm9sbG93czpcbiAqXG4gKiBEaWdlc3RJbmZvIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGRpZ2VzdEFsZ29yaXRobSBEaWdlc3RBbGdvcml0aG1JZGVudGlmaWVyLFxuICogICBkaWdlc3QgRGlnZXN0XG4gKiB9XG4gKlxuICogRGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllciA6Oj0gQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIFRoZSBBbGdvcml0aG1JZGVudGlmaWVyIGNvbnRhaW5zIGFuIE9iamVjdCBJZGVudGlmaWVyIChPSUQpIGFuZCBwYXJhbWV0ZXJzXG4gKiBmb3IgdGhlIGFsZ29yaXRobSwgaWYgYW55LiBJbiB0aGUgY2FzZSBvZiBTSEExIHRoZXJlIGlzIG5vbmUuXG4gKlxuICogQWxnb3JpdGhtSWRlbnRpZmVyIDo6PSBTRVFVRU5DRSB7XG4gKiAgICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgICBwYXJhbWV0ZXJzIEFOWSBERUZJTkVEIEJZIGFsZ29yaXRobSBPUFRJT05BTFxuICogfVxuICpcbiAqIERpZ2VzdCA6Oj0gT0NURVQgU1RSSU5HXG4gKlxuICpcbiAqIENvbnRlbnRJbmZvIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGNvbnRlbnRUeXBlIENvbnRlbnRUeXBlLFxuICogICBjb250ZW50ICAgICBbMF0gRVhQTElDSVQgQU5ZIERFRklORUQgQlkgY29udGVudFR5cGUgT1BUSU9OQUxcbiAqIH1cbiAqXG4gKiBDb250ZW50VHlwZSA6Oj0gT0JKRUNUIElERU5USUZJRVJcbiAqXG4gKiBBdXRoZW50aWNhdGVkU2FmZSA6Oj0gU0VRVUVOQ0UgT0YgQ29udGVudEluZm9cbiAqIC0tIERhdGEgaWYgdW5lbmNyeXB0ZWRcbiAqIC0tIEVuY3J5cHRlZERhdGEgaWYgcGFzc3dvcmQtZW5jcnlwdGVkXG4gKiAtLSBFbnZlbG9wZWREYXRhIGlmIHB1YmxpYyBrZXktZW5jcnlwdGVkXG4gKlxuICpcbiAqIFNhZmVDb250ZW50cyA6Oj0gU0VRVUVOQ0UgT0YgU2FmZUJhZ1xuICpcbiAqIFNhZmVCYWcgOjo9IFNFUVVFTkNFIHtcbiAqICAgYmFnSWQgICAgIEJBRy1UWVBFLiZpZCAoe1BLQ1MxMkJhZ1NldH0pXG4gKiAgIGJhZ1ZhbHVlICBbMF0gRVhQTElDSVQgQkFHLVRZUEUuJlR5cGUoe1BLQ1MxMkJhZ1NldH17QGJhZ0lkfSksXG4gKiAgIGJhZ0F0dHJpYnV0ZXMgU0VUIE9GIFBLQ1MxMkF0dHJpYnV0ZSBPUFRJT05BTFxuICogfVxuICpcbiAqIFBLQ1MxMkF0dHJpYnV0ZSA6Oj0gU0VRVUVOQ0Uge1xuICogICBhdHRySWQgQVRUUklCVVRFLiZpZCAoe1BLQ1MxMkF0dHJTZXR9KSxcbiAqICAgYXR0clZhbHVlcyBTRVQgT0YgQVRUUklCVVRFLiZUeXBlICh7UEtDUzEyQXR0clNldH17QGF0dHJJZH0pXG4gKiB9IC0tIFRoaXMgdHlwZSBpcyBjb21wYXRpYmxlIHdpdGggdGhlIFguNTAwIHR5cGUgJ0F0dHJpYnV0ZSdcbiAqXG4gKiBQS0NTMTJBdHRyU2V0IEFUVFJJQlVURSA6Oj0ge1xuICogICBmcmllbmRseU5hbWUgfCAtLSBmcm9tIFBLQ1MgIzlcbiAqICAgbG9jYWxLZXlJZCwgLS0gZnJvbSBQS0NTICM5XG4gKiAgIC4uLiAtLSBPdGhlciBhdHRyaWJ1dGVzIGFyZSBhbGxvd2VkXG4gKiB9XG4gKlxuICogQ2VydEJhZyA6Oj0gU0VRVUVOQ0Uge1xuICogICBjZXJ0SWQgICAgQkFHLVRZUEUuJmlkICAgKHtDZXJ0VHlwZXN9KSxcbiAqICAgY2VydFZhbHVlIFswXSBFWFBMSUNJVCBCQUctVFlQRS4mVHlwZSAoe0NlcnRUeXBlc317QGNlcnRJZH0pXG4gKiB9XG4gKlxuICogeDUwOUNlcnRpZmljYXRlIEJBRy1UWVBFIDo6PSB7T0NURVQgU1RSSU5HIElERU5USUZJRUQgQlkge2NlcnRUeXBlcyAxfX1cbiAqICAgLS0gREVSLWVuY29kZWQgWC41MDkgY2VydGlmaWNhdGUgc3RvcmVkIGluIE9DVEVUIFNUUklOR1xuICpcbiAqIHNkc2lDZXJ0aWZpY2F0ZSBCQUctVFlQRSA6Oj0ge0lBNVN0cmluZyBJREVOVElGSUVEIEJZIHtjZXJ0VHlwZXMgMn19XG4gKiAtLSBCYXNlNjQtZW5jb2RlZCBTRFNJIGNlcnRpZmljYXRlIHN0b3JlZCBpbiBJQTVTdHJpbmdcbiAqXG4gKiBDZXJ0VHlwZXMgQkFHLVRZUEUgOjo9IHtcbiAqICAgeDUwOUNlcnRpZmljYXRlIHxcbiAqICAgc2RzaUNlcnRpZmljYXRlLFxuICogICAuLi4gLS0gRm9yIGZ1dHVyZSBleHRlbnNpb25zXG4gKiB9XG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vYXNuMScpO1xucmVxdWlyZSgnLi9obWFjJyk7XG5yZXF1aXJlKCcuL29pZHMnKTtcbnJlcXVpcmUoJy4vcGtjczdhc24xJyk7XG5yZXF1aXJlKCcuL3BiZScpO1xucmVxdWlyZSgnLi9yYW5kb20nKTtcbnJlcXVpcmUoJy4vcnNhJyk7XG5yZXF1aXJlKCcuL3NoYTEnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xucmVxdWlyZSgnLi94NTA5Jyk7XG5cbi8vIHNob3J0Y3V0IGZvciBhc24uMSAmIFBLSSBBUElcbnZhciBhc24xID0gZm9yZ2UuYXNuMTtcbnZhciBwa2kgPSBmb3JnZS5wa2k7XG5cbi8vIHNob3J0Y3V0IGZvciBQS0NTIzEyIEFQSVxudmFyIHAxMiA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtjczEyID0gZm9yZ2UucGtjczEyIHx8IHt9O1xuXG52YXIgY29udGVudEluZm9WYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdDb250ZW50SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLCAgLy8gYSBDb250ZW50SW5mb1xuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0NvbnRlbnRJbmZvLmNvbnRlbnRUeXBlJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2NvbnRlbnRUeXBlJ1xuICB9LCB7XG4gICAgbmFtZTogJ0NvbnRlbnRJbmZvLmNvbnRlbnQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICdjb250ZW50J1xuICB9XVxufTtcblxudmFyIHBmeFZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ1BGWCcsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ1BGWC52ZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICd2ZXJzaW9uJ1xuICB9LFxuICBjb250ZW50SW5mb1ZhbGlkYXRvciwge1xuICAgIG5hbWU6ICdQRlgubWFjRGF0YScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ21hYycsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnUEZYLm1hY0RhdGEubWFjJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSwgIC8vIERpZ2VzdEluZm9cbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5tYWMuZGlnZXN0QWxnb3JpdGhtJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsICAvLyBEaWdlc3RBbGdvcml0aG1JZGVudGlmaWVyXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICBuYW1lOiAnUEZYLm1hY0RhdGEubWFjLmRpZ2VzdEFsZ29yaXRobS5hbGdvcml0aG0nLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBjYXB0dXJlOiAnbWFjQWxnb3JpdGhtJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogJ1BGWC5tYWNEYXRhLm1hYy5kaWdlc3RBbGdvcml0aG0ucGFyYW1ldGVycycsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIGNhcHR1cmVBc24xOiAnbWFjQWxnb3JpdGhtUGFyYW1ldGVycydcbiAgICAgICAgfV1cbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ1BGWC5tYWNEYXRhLm1hYy5kaWdlc3QnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiAnbWFjRGlnZXN0J1xuICAgICAgfV1cbiAgICB9LCB7XG4gICAgICBuYW1lOiAnUEZYLm1hY0RhdGEubWFjU2FsdCcsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnbWFjU2FsdCdcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnUEZYLm1hY0RhdGEuaXRlcmF0aW9ucycsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgY2FwdHVyZTogJ21hY0l0ZXJhdGlvbnMnXG4gICAgfV1cbiAgfV1cbn07XG5cbnZhciBzYWZlQmFnVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnU2FmZUJhZycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ1NhZmVCYWcuYmFnSWQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnYmFnSWQnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2FmZUJhZy5iYWdWYWx1ZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ2JhZ1ZhbHVlJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NhZmVCYWcuYmFnQXR0cmlidXRlcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgY2FwdHVyZTogJ2JhZ0F0dHJpYnV0ZXMnXG4gIH1dXG59O1xuXG52YXIgYXR0cmlidXRlVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnQXR0cmlidXRlJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnQXR0cmlidXRlLmF0dHJJZCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdvaWQnXG4gIH0sIHtcbiAgICBuYW1lOiAnQXR0cmlidXRlLmF0dHJWYWx1ZXMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VULFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIGNhcHR1cmU6ICd2YWx1ZXMnXG4gIH1dXG59O1xuXG52YXIgY2VydEJhZ1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0NlcnRCYWcnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdDZXJ0QmFnLmNlcnRJZCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdjZXJ0SWQnXG4gIH0sIHtcbiAgICBuYW1lOiAnQ2VydEJhZy5jZXJ0VmFsdWUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgLyogU28gZmFyIHdlIG9ubHkgc3VwcG9ydCBYLjUwOSBjZXJ0aWZpY2F0ZXMgKHdoaWNoIGFyZSB3cmFwcGVkIGluXG4gICAgICAgYW4gT0NURVQgU1RSSU5HLCBoZW5jZSBoYXJkIGNvZGUgdGhhdCBoZXJlKS4gKi9cbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdDZXJ0QmFnLmNlcnRWYWx1ZVswXScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLkNsYXNzLk9DVEVUU1RSSU5HLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2NlcnQnXG4gICAgfV1cbiAgfV1cbn07XG5cbi8qKlxuICogU2VhcmNoIFNhZmVDb250ZW50cyBzdHJ1Y3R1cmUgZm9yIGJhZ3Mgd2l0aCBtYXRjaGluZyBhdHRyaWJ1dGVzLlxuICpcbiAqIFRoZSBzZWFyY2ggY2FuIG9wdGlvbmFsbHkgYmUgbmFycm93ZWQgYnkgYSBjZXJ0YWluIGJhZyB0eXBlLlxuICpcbiAqIEBwYXJhbSBzYWZlQ29udGVudHMgdGhlIFNhZmVDb250ZW50cyBzdHJ1Y3R1cmUgdG8gc2VhcmNoIGluLlxuICogQHBhcmFtIGF0dHJOYW1lIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICogQHBhcmFtIGF0dHJWYWx1ZSB0aGUgYXR0cmlidXRlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0gW2JhZ1R5cGVdIGJhZyB0eXBlIHRvIG5hcnJvdyBzZWFyY2ggYnkuXG4gKlxuICogQHJldHVybiBhbiBhcnJheSBvZiBtYXRjaGluZyBiYWdzLlxuICovXG5mdW5jdGlvbiBfZ2V0QmFnc0J5QXR0cmlidXRlKHNhZmVDb250ZW50cywgYXR0ck5hbWUsIGF0dHJWYWx1ZSwgYmFnVHlwZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgZm9yKHZhciBpID0gMDsgaSA8IHNhZmVDb250ZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGZvcih2YXIgaiA9IDA7IGogPCBzYWZlQ29udGVudHNbaV0uc2FmZUJhZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBiYWcgPSBzYWZlQ29udGVudHNbaV0uc2FmZUJhZ3Nbal07XG4gICAgICBpZihiYWdUeXBlICE9PSB1bmRlZmluZWQgJiYgYmFnLnR5cGUgIT09IGJhZ1R5cGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBvbmx5IGZpbHRlciBieSBiYWcgdHlwZSwgbm8gYXR0cmlidXRlIHNwZWNpZmllZFxuICAgICAgaWYoYXR0ck5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYmFnKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZihiYWcuYXR0cmlidXRlc1thdHRyTmFtZV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBiYWcuYXR0cmlidXRlc1thdHRyTmFtZV0uaW5kZXhPZihhdHRyVmFsdWUpID49IDApIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYmFnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgUEtDUyMxMiBQRlggaW4gQVNOLjEgbm90YXRpb24gaW50byBhIFBGWCBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iaiBUaGUgUEtDUyMxMiBQRlggaW4gQVNOLjEgbm90YXRpb24uXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gdXNlIHN0cmljdCBERVIgZGVjb2RpbmcsIGZhbHNlIG5vdCB0byAoZGVmYXVsdDogdHJ1ZSkuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFzc3dvcmQgUGFzc3dvcmQgdG8gZGVjcnlwdCB3aXRoIChvcHRpb25hbCkuXG4gKlxuICogQHJldHVybiBQS0NTIzEyIFBGWCBvYmplY3QuXG4gKi9cbnAxMi5wa2NzMTJGcm9tQXNuMSA9IGZ1bmN0aW9uKG9iaiwgc3RyaWN0LCBwYXNzd29yZCkge1xuICAvLyBoYW5kbGUgYXJnc1xuICBpZih0eXBlb2Ygc3RyaWN0ID09PSAnc3RyaW5nJykge1xuICAgIHBhc3N3b3JkID0gc3RyaWN0O1xuICAgIHN0cmljdCA9IHRydWU7XG4gIH0gZWxzZSBpZihzdHJpY3QgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0cmljdCA9IHRydWU7XG4gIH1cblxuICAvLyB2YWxpZGF0ZSBQRlggYW5kIGNhcHR1cmUgZGF0YVxuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKG9iaiwgcGZ4VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTIzEyIFBGWC4gJyArXG4gICAgICAnQVNOLjEgb2JqZWN0IGlzIG5vdCBhbiBQS0NTIzEyIFBGWC4nKTtcbiAgICBlcnJvci5lcnJvcnMgPSBlcnJvcjtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBwZnggPSB7XG4gICAgdmVyc2lvbjogY2FwdHVyZS52ZXJzaW9uLmNoYXJDb2RlQXQoMCksXG4gICAgc2FmZUNvbnRlbnRzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgYmFncyB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsdGVyIHRoZSBhdHRyaWJ1dGVzIHRvIGZpbHRlciBieTpcbiAgICAgKiAgICAgICAgICBbbG9jYWxLZXlJZF0gdGhlIGxvY2FsS2V5SWQgdG8gc2VhcmNoIGZvci5cbiAgICAgKiAgICAgICAgICBbbG9jYWxLZXlJZEhleF0gdGhlIGxvY2FsS2V5SWQgaW4gaGV4IHRvIHNlYXJjaCBmb3IuXG4gICAgICogICAgICAgICAgW2ZyaWVuZGx5TmFtZV0gdGhlIGZyaWVuZGx5IG5hbWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiAgICAgICAgICBbYmFnVHlwZV0gYmFnIHR5cGUgdG8gbmFycm93IGVhY2ggYXR0cmlidXRlIHNlYXJjaCBieS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBtYXAgb2YgYXR0cmlidXRlIHR5cGUgdG8gYW4gYXJyYXkgb2YgbWF0Y2hpbmcgYmFncyBvciwgaWYgbm9cbiAgICAgKiAgICAgICAgICAgYXR0cmlidXRlIHdhcyBnaXZlbiBidXQgYSBiYWcgdHlwZSwgdGhlIG1hcCBrZXkgd2lsbCBiZSB0aGVcbiAgICAgKiAgICAgICAgICAgYmFnIHR5cGUuXG4gICAgICovXG4gICAgZ2V0QmFnczogZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICB2YXIgcnZhbCA9IHt9O1xuXG4gICAgICB2YXIgbG9jYWxLZXlJZDtcbiAgICAgIGlmKCdsb2NhbEtleUlkJyBpbiBmaWx0ZXIpIHtcbiAgICAgICAgbG9jYWxLZXlJZCA9IGZpbHRlci5sb2NhbEtleUlkO1xuICAgICAgfSBlbHNlIGlmKCdsb2NhbEtleUlkSGV4JyBpbiBmaWx0ZXIpIHtcbiAgICAgICAgbG9jYWxLZXlJZCA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhmaWx0ZXIubG9jYWxLZXlJZEhleCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGZpbHRlciBvbiBiYWdUeXBlIG9ubHlcbiAgICAgIGlmKGxvY2FsS2V5SWQgPT09IHVuZGVmaW5lZCAmJiAhKCdmcmllbmRseU5hbWUnIGluIGZpbHRlcikgJiZcbiAgICAgICAgJ2JhZ1R5cGUnIGluIGZpbHRlcikge1xuICAgICAgICBydmFsW2ZpbHRlci5iYWdUeXBlXSA9IF9nZXRCYWdzQnlBdHRyaWJ1dGUoXG4gICAgICAgICAgcGZ4LnNhZmVDb250ZW50cywgbnVsbCwgbnVsbCwgZmlsdGVyLmJhZ1R5cGUpO1xuICAgICAgfVxuXG4gICAgICBpZihsb2NhbEtleUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcnZhbC5sb2NhbEtleUlkID0gX2dldEJhZ3NCeUF0dHJpYnV0ZShcbiAgICAgICAgICBwZnguc2FmZUNvbnRlbnRzLCAnbG9jYWxLZXlJZCcsXG4gICAgICAgICAgbG9jYWxLZXlJZCwgZmlsdGVyLmJhZ1R5cGUpO1xuICAgICAgfVxuICAgICAgaWYoJ2ZyaWVuZGx5TmFtZScgaW4gZmlsdGVyKSB7XG4gICAgICAgIHJ2YWwuZnJpZW5kbHlOYW1lID0gX2dldEJhZ3NCeUF0dHJpYnV0ZShcbiAgICAgICAgICBwZnguc2FmZUNvbnRlbnRzLCAnZnJpZW5kbHlOYW1lJyxcbiAgICAgICAgICBmaWx0ZXIuZnJpZW5kbHlOYW1lLCBmaWx0ZXIuYmFnVHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBERVBSRUNBVEVEOiB1c2UgZ2V0QmFncygpIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBHZXQgYmFncyB3aXRoIG1hdGNoaW5nIGZyaWVuZGx5TmFtZSBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJpZW5kbHlOYW1lIHRoZSBmcmllbmRseSBuYW1lIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIFtiYWdUeXBlXSBiYWcgdHlwZSB0byBuYXJyb3cgc2VhcmNoIGJ5LlxuICAgICAqXG4gICAgICogQHJldHVybiBhbiBhcnJheSBvZiBiYWdzIHdpdGggbWF0Y2hpbmcgZnJpZW5kbHlOYW1lIGF0dHJpYnV0ZS5cbiAgICAgKi9cbiAgICBnZXRCYWdzQnlGcmllbmRseU5hbWU6IGZ1bmN0aW9uKGZyaWVuZGx5TmFtZSwgYmFnVHlwZSkge1xuICAgICAgcmV0dXJuIF9nZXRCYWdzQnlBdHRyaWJ1dGUoXG4gICAgICAgIHBmeC5zYWZlQ29udGVudHMsICdmcmllbmRseU5hbWUnLCBmcmllbmRseU5hbWUsIGJhZ1R5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBERVBSRUNBVEVEOiB1c2UgZ2V0QmFncygpIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBHZXQgYmFncyB3aXRoIG1hdGNoaW5nIGxvY2FsS2V5SWQgYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxvY2FsS2V5SWQgdGhlIGxvY2FsS2V5SWQgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0gW2JhZ1R5cGVdIGJhZyB0eXBlIHRvIG5hcnJvdyBzZWFyY2ggYnkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGJhZ3Mgd2l0aCBtYXRjaGluZyBsb2NhbEtleUlkIGF0dHJpYnV0ZS5cbiAgICAgKi9cbiAgICBnZXRCYWdzQnlMb2NhbEtleUlkOiBmdW5jdGlvbihsb2NhbEtleUlkLCBiYWdUeXBlKSB7XG4gICAgICByZXR1cm4gX2dldEJhZ3NCeUF0dHJpYnV0ZShcbiAgICAgICAgcGZ4LnNhZmVDb250ZW50cywgJ2xvY2FsS2V5SWQnLCBsb2NhbEtleUlkLCBiYWdUeXBlKTtcbiAgICB9XG4gIH07XG5cbiAgaWYoY2FwdHVyZS52ZXJzaW9uLmNoYXJDb2RlQXQoMCkgIT09IDMpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1BLQ1MjMTIgUEZYIG9mIHZlcnNpb24gb3RoZXIgdGhhbiAzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgZXJyb3IudmVyc2lvbiA9IGNhcHR1cmUudmVyc2lvbi5jaGFyQ29kZUF0KDApO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgaWYoYXNuMS5kZXJUb09pZChjYXB0dXJlLmNvbnRlbnRUeXBlKSAhPT0gcGtpLm9pZHMuZGF0YSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignT25seSBQS0NTIzEyIFBGWCBpbiBwYXNzd29yZCBpbnRlZ3JpdHkgbW9kZSBzdXBwb3J0ZWQuJyk7XG4gICAgZXJyb3Iub2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmNvbnRlbnRUeXBlKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBkYXRhID0gY2FwdHVyZS5jb250ZW50LnZhbHVlWzBdO1xuICBpZihkYXRhLnRhZ0NsYXNzICE9PSBhc24xLkNsYXNzLlVOSVZFUlNBTCB8fFxuICAgICBkYXRhLnR5cGUgIT09IGFzbjEuVHlwZS5PQ1RFVFNUUklORykge1xuICAgIHRocm93IG5ldyBFcnJvcignUEtDUyMxMiBhdXRoU2FmZSBjb250ZW50IGRhdGEgaXMgbm90IGFuIE9DVEVUIFNUUklORy4nKTtcbiAgfVxuICBkYXRhID0gX2RlY29kZVBrY3M3RGF0YShkYXRhKTtcblxuICAvLyBjaGVjayBmb3IgTUFDXG4gIGlmKGNhcHR1cmUubWFjKSB7XG4gICAgdmFyIG1kID0gbnVsbDtcbiAgICB2YXIgbWFjS2V5Qnl0ZXMgPSAwO1xuICAgIHZhciBtYWNBbGdvcml0aG0gPSBhc24xLmRlclRvT2lkKGNhcHR1cmUubWFjQWxnb3JpdGhtKTtcbiAgICBzd2l0Y2gobWFjQWxnb3JpdGhtKSB7XG4gICAgY2FzZSBwa2kub2lkcy5zaGExOlxuICAgICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgbWFjS2V5Qnl0ZXMgPSAyMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgcGtpLm9pZHMuc2hhMjU2OlxuICAgICAgbWQgPSBmb3JnZS5tZC5zaGEyNTYuY3JlYXRlKCk7XG4gICAgICBtYWNLZXlCeXRlcyA9IDMyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBwa2kub2lkcy5zaGEzODQ6XG4gICAgICBtZCA9IGZvcmdlLm1kLnNoYTM4NC5jcmVhdGUoKTtcbiAgICAgIG1hY0tleUJ5dGVzID0gNDg7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHBraS5vaWRzLnNoYTUxMjpcbiAgICAgIG1kID0gZm9yZ2UubWQuc2hhNTEyLmNyZWF0ZSgpO1xuICAgICAgbWFjS2V5Qnl0ZXMgPSA2NDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgcGtpLm9pZHMubWQ1OlxuICAgICAgbWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gICAgICBtYWNLZXlCeXRlcyA9IDE2O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmKG1kID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BLQ1MjMTIgdXNlcyB1bnN1cHBvcnRlZCBNQUMgYWxnb3JpdGhtOiAnICsgbWFjQWxnb3JpdGhtKTtcbiAgICB9XG5cbiAgICAvLyB2ZXJpZnkgTUFDIChpdGVyYXRpb25zIGRlZmF1bHQgdG8gMSlcbiAgICB2YXIgbWFjU2FsdCA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoY2FwdHVyZS5tYWNTYWx0KTtcbiAgICB2YXIgbWFjSXRlcmF0aW9ucyA9ICgoJ21hY0l0ZXJhdGlvbnMnIGluIGNhcHR1cmUpID9cbiAgICAgIHBhcnNlSW50KGZvcmdlLnV0aWwuYnl0ZXNUb0hleChjYXB0dXJlLm1hY0l0ZXJhdGlvbnMpLCAxNikgOiAxKTtcbiAgICB2YXIgbWFjS2V5ID0gcDEyLmdlbmVyYXRlS2V5KFxuICAgICAgcGFzc3dvcmQsIG1hY1NhbHQsIDMsIG1hY0l0ZXJhdGlvbnMsIG1hY0tleUJ5dGVzLCBtZCk7XG4gICAgdmFyIG1hYyA9IGZvcmdlLmhtYWMuY3JlYXRlKCk7XG4gICAgbWFjLnN0YXJ0KG1kLCBtYWNLZXkpO1xuICAgIG1hYy51cGRhdGUoZGF0YS52YWx1ZSk7XG4gICAgdmFyIG1hY1ZhbHVlID0gbWFjLmdldE1hYygpO1xuICAgIGlmKG1hY1ZhbHVlLmdldEJ5dGVzKCkgIT09IGNhcHR1cmUubWFjRGlnZXN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BLQ1MjMTIgTUFDIGNvdWxkIG5vdCBiZSB2ZXJpZmllZC4gSW52YWxpZCBwYXNzd29yZD8nKTtcbiAgICB9XG4gIH1cblxuICBfZGVjb2RlQXV0aGVudGljYXRlZFNhZmUocGZ4LCBkYXRhLnZhbHVlLCBzdHJpY3QsIHBhc3N3b3JkKTtcbiAgcmV0dXJuIHBmeDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBQS0NTIzcgRGF0YS4gUEtDUyM3IChSRkMgMjMxNSkgZGVmaW5lcyBcIkRhdGFcIiBhcyBhbiBPQ1RFVCBTVFJJTkcsXG4gKiBidXQgaXQgaXMgc29tZXRpbWVzIGFuIE9DVEVUIFNUUklORyB0aGF0IGlzIGNvbXBvc2VkL2NvbnN0cnVjdGVkIG9mIGNodW5rcyxcbiAqIGVhY2ggaXRzIG93biBPQ1RFVCBTVFJJTkcuIFRoaXMgaXMgQkVSLWVuY29kaW5nIHZzLiBERVItZW5jb2RpbmcuIFRoaXNcbiAqIGZ1bmN0aW9uIHRyYW5zZm9ybXMgdGhpcyBjb3JuZXItY2FzZSBpbnRvIHRoZSB1c3VhbCBzaW1wbGUsXG4gKiBub24tY29tcG9zZWQvY29uc3RydWN0ZWQgT0NURVQgU1RSSU5HLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbWF5IGJlIG1vdmVkIHRvIEFTTi4xIGF0IHNvbWUgcG9pbnQgdG8gYmV0dGVyIGRlYWwgd2l0aFxuICogbW9yZSBCRVItZW5jb2RpbmcgaXNzdWVzLCBzaG91bGQgdGhleSBhcmlzZS5cbiAqXG4gKiBAcGFyYW0gZGF0YSB0aGUgQVNOLjEgRGF0YSBvYmplY3QgdG8gdHJhbnNmb3JtLlxuICovXG5mdW5jdGlvbiBfZGVjb2RlUGtjczdEYXRhKGRhdGEpIHtcbiAgLy8gaGFuZGxlIHNwZWNpYWwgY2FzZSBvZiBcImNodW5rZWRcIiBkYXRhIGNvbnRlbnQ6IGFuIG9jdGV0IHN0cmluZyBjb21wb3NlZFxuICAvLyBvZiBvdGhlciBvY3RldCBzdHJpbmdzXG4gIGlmKGRhdGEuY29tcG9zZWQgfHwgZGF0YS5jb25zdHJ1Y3RlZCkge1xuICAgIHZhciB2YWx1ZSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGRhdGEudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhbHVlLnB1dEJ5dGVzKGRhdGEudmFsdWVbaV0udmFsdWUpO1xuICAgIH1cbiAgICBkYXRhLmNvbXBvc2VkID0gZGF0YS5jb25zdHJ1Y3RlZCA9IGZhbHNlO1xuICAgIGRhdGEudmFsdWUgPSB2YWx1ZS5nZXRCeXRlcygpO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIERlY29kZSBQS0NTIzEyIEF1dGhlbnRpY2F0ZWRTYWZlIChCRVIgZW5jb2RlZCkgaW50byBQRlggb2JqZWN0LlxuICpcbiAqIFRoZSBBdXRoZW50aWNhdGVkU2FmZSBpcyBhIEJFUi1lbmNvZGVkIFNFUVVFTkNFIE9GIENvbnRlbnRJbmZvLlxuICpcbiAqIEBwYXJhbSBwZnggVGhlIFBLQ1MjMTIgUEZYIG9iamVjdCB0byBmaWxsLlxuICogQHBhcmFtIHtTdHJpbmd9IGF1dGhTYWZlIEJFUi1lbmNvZGVkIEF1dGhlbnRpY2F0ZWRTYWZlLlxuICogQHBhcmFtIHN0cmljdCB0cnVlIHRvIHVzZSBzdHJpY3QgREVSIGRlY29kaW5nLCBmYWxzZSBub3QgdG8uXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFzc3dvcmQgUGFzc3dvcmQgdG8gZGVjcnlwdCB3aXRoIChvcHRpb25hbCkuXG4gKi9cbmZ1bmN0aW9uIF9kZWNvZGVBdXRoZW50aWNhdGVkU2FmZShwZngsIGF1dGhTYWZlLCBzdHJpY3QsIHBhc3N3b3JkKSB7XG4gIGF1dGhTYWZlID0gYXNuMS5mcm9tRGVyKGF1dGhTYWZlLCBzdHJpY3QpOyAgLyogYWN0dWFsbHkgaXQncyBCRVIgZW5jb2RlZCAqL1xuXG4gIGlmKGF1dGhTYWZlLnRhZ0NsYXNzICE9PSBhc24xLkNsYXNzLlVOSVZFUlNBTCB8fFxuICAgICBhdXRoU2FmZS50eXBlICE9PSBhc24xLlR5cGUuU0VRVUVOQ0UgfHxcbiAgICAgYXV0aFNhZmUuY29uc3RydWN0ZWQgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BLQ1MjMTIgQXV0aGVudGljYXRlZFNhZmUgZXhwZWN0ZWQgdG8gYmUgYSAnICtcbiAgICAgICdTRVFVRU5DRSBPRiBDb250ZW50SW5mbycpO1xuICB9XG5cbiAgZm9yKHZhciBpID0gMDsgaSA8IGF1dGhTYWZlLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbnRlbnRJbmZvID0gYXV0aFNhZmUudmFsdWVbaV07XG5cbiAgICAvLyB2YWxpZGF0ZSBjb250ZW50SW5mbyBhbmQgY2FwdHVyZSBkYXRhXG4gICAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgaWYoIWFzbjEudmFsaWRhdGUoY29udGVudEluZm8sIGNvbnRlbnRJbmZvVmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIENvbnRlbnRJbmZvLicpO1xuICAgICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGVuY3J5cHRlZDogZmFsc2VcbiAgICB9O1xuICAgIHZhciBzYWZlQ29udGVudHMgPSBudWxsO1xuICAgIHZhciBkYXRhID0gY2FwdHVyZS5jb250ZW50LnZhbHVlWzBdO1xuICAgIHN3aXRjaChhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpKSB7XG4gICAgY2FzZSBwa2kub2lkcy5kYXRhOlxuICAgICAgaWYoZGF0YS50YWdDbGFzcyAhPT0gYXNuMS5DbGFzcy5VTklWRVJTQUwgfHxcbiAgICAgICAgIGRhdGEudHlwZSAhPT0gYXNuMS5UeXBlLk9DVEVUU1RSSU5HKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUEtDUyMxMiBTYWZlQ29udGVudHMgRGF0YSBpcyBub3QgYW4gT0NURVQgU1RSSU5HLicpO1xuICAgICAgfVxuICAgICAgc2FmZUNvbnRlbnRzID0gX2RlY29kZVBrY3M3RGF0YShkYXRhKS52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgcGtpLm9pZHMuZW5jcnlwdGVkRGF0YTpcbiAgICAgIHNhZmVDb250ZW50cyA9IF9kZWNyeXB0U2FmZUNvbnRlbnRzKGRhdGEsIHBhc3N3b3JkKTtcbiAgICAgIG9iai5lbmNyeXB0ZWQgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUEtDUyMxMiBjb250ZW50VHlwZS4nKTtcbiAgICAgIGVycm9yLmNvbnRlbnRUeXBlID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmNvbnRlbnRUeXBlKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIG9iai5zYWZlQmFncyA9IF9kZWNvZGVTYWZlQ29udGVudHMoc2FmZUNvbnRlbnRzLCBzdHJpY3QsIHBhc3N3b3JkKTtcbiAgICBwZnguc2FmZUNvbnRlbnRzLnB1c2gob2JqKTtcbiAgfVxufVxuXG4vKipcbiAqIERlY3J5cHQgUEtDUyM3IEVuY3J5cHRlZERhdGEgc3RydWN0dXJlLlxuICpcbiAqIEBwYXJhbSBkYXRhIEFTTi4xIGVuY29kZWQgRW5jcnlwdGVkQ29udGVudEluZm8gb2JqZWN0LlxuICogQHBhcmFtIHBhc3N3b3JkIFRoZSB1c2VyLXByb3ZpZGVkIHBhc3N3b3JkLlxuICpcbiAqIEByZXR1cm4gVGhlIGRlY3J5cHRlZCBTYWZlQ29udGVudHMgKEFTTi4xIG9iamVjdCkuXG4gKi9cbmZ1bmN0aW9uIF9kZWNyeXB0U2FmZUNvbnRlbnRzKGRhdGEsIHBhc3N3b3JkKSB7XG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUoXG4gICAgZGF0YSwgZm9yZ2UucGtjczcuYXNuMS5lbmNyeXB0ZWREYXRhVmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBFbmNyeXB0ZWRDb250ZW50SW5mby4nKTtcbiAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICB2YXIgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmNvbnRlbnRUeXBlKTtcbiAgaWYob2lkICE9PSBwa2kub2lkcy5kYXRhKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgJ1BLQ1MjMTIgRW5jcnlwdGVkQ29udGVudEluZm8gQ29udGVudFR5cGUgaXMgbm90IERhdGEuJyk7XG4gICAgZXJyb3Iub2lkID0gb2lkO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gZ2V0IGNpcGhlclxuICBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuZW5jQWxnb3JpdGhtKTtcbiAgdmFyIGNpcGhlciA9IHBraS5wYmUuZ2V0Q2lwaGVyKG9pZCwgY2FwdHVyZS5lbmNQYXJhbWV0ZXIsIHBhc3N3b3JkKTtcblxuICAvLyBnZXQgZW5jcnlwdGVkIGRhdGFcbiAgdmFyIGVuY3J5cHRlZENvbnRlbnRBc24xID0gX2RlY29kZVBrY3M3RGF0YShjYXB0dXJlLmVuY3J5cHRlZENvbnRlbnRBc24xKTtcbiAgdmFyIGVuY3J5cHRlZCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGVuY3J5cHRlZENvbnRlbnRBc24xLnZhbHVlKTtcblxuICBjaXBoZXIudXBkYXRlKGVuY3J5cHRlZCk7XG4gIGlmKCFjaXBoZXIuZmluaXNoKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWNyeXB0IFBLQ1MjMTIgU2FmZUNvbnRlbnRzLicpO1xuICB9XG5cbiAgcmV0dXJuIGNpcGhlci5vdXRwdXQuZ2V0Qnl0ZXMoKTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgUEtDUyMxMiBTYWZlQ29udGVudHMgKEJFUi1lbmNvZGVkKSBpbnRvIGFycmF5IG9mIEJhZyBvYmplY3RzLlxuICpcbiAqIFRoZSBzYWZlQ29udGVudHMgaXMgYSBCRVItZW5jb2RlZCBTRVFVRU5DRSBPRiBTYWZlQmFnLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzYWZlQ29udGVudHMgQkVSLWVuY29kZWQgc2FmZUNvbnRlbnRzLlxuICogQHBhcmFtIHN0cmljdCB0cnVlIHRvIHVzZSBzdHJpY3QgREVSIGRlY29kaW5nLCBmYWxzZSBub3QgdG8uXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFzc3dvcmQgUGFzc3dvcmQgdG8gZGVjcnlwdCB3aXRoIChvcHRpb25hbCkuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIEJhZyBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBfZGVjb2RlU2FmZUNvbnRlbnRzKHNhZmVDb250ZW50cywgc3RyaWN0LCBwYXNzd29yZCkge1xuICAvLyBpZiBzdHJpY3QgYW5kIG5vIHNhZmUgY29udGVudHMsIHJldHVybiBlbXB0eSBzYWZlc1xuICBpZighc3RyaWN0ICYmIHNhZmVDb250ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvLyBhY3R1YWxseSBpdCdzIEJFUi1lbmNvZGVkXG4gIHNhZmVDb250ZW50cyA9IGFzbjEuZnJvbURlcihzYWZlQ29udGVudHMsIHN0cmljdCk7XG5cbiAgaWYoc2FmZUNvbnRlbnRzLnRhZ0NsYXNzICE9PSBhc24xLkNsYXNzLlVOSVZFUlNBTCB8fFxuICAgIHNhZmVDb250ZW50cy50eXBlICE9PSBhc24xLlR5cGUuU0VRVUVOQ0UgfHxcbiAgICBzYWZlQ29udGVudHMuY29uc3RydWN0ZWQgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnUEtDUyMxMiBTYWZlQ29udGVudHMgZXhwZWN0ZWQgdG8gYmUgYSBTRVFVRU5DRSBPRiBTYWZlQmFnLicpO1xuICB9XG5cbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2FmZUNvbnRlbnRzLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNhZmVCYWcgPSBzYWZlQ29udGVudHMudmFsdWVbaV07XG5cbiAgICAvLyB2YWxpZGF0ZSBTYWZlQmFnIGFuZCBjYXB0dXJlIGRhdGFcbiAgICB2YXIgY2FwdHVyZSA9IHt9O1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBpZighYXNuMS52YWxpZGF0ZShzYWZlQmFnLCBzYWZlQmFnVmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIFNhZmVCYWcuJyk7XG4gICAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvKiBDcmVhdGUgYmFnIG9iamVjdCBhbmQgcHVzaCB0byByZXN1bHQgYXJyYXkuICovXG4gICAgdmFyIGJhZyA9IHtcbiAgICAgIHR5cGU6IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5iYWdJZCksXG4gICAgICBhdHRyaWJ1dGVzOiBfZGVjb2RlQmFnQXR0cmlidXRlcyhjYXB0dXJlLmJhZ0F0dHJpYnV0ZXMpXG4gICAgfTtcbiAgICByZXMucHVzaChiYWcpO1xuXG4gICAgdmFyIHZhbGlkYXRvciwgZGVjb2RlcjtcbiAgICB2YXIgYmFnQXNuMSA9IGNhcHR1cmUuYmFnVmFsdWUudmFsdWVbMF07XG4gICAgc3dpdGNoKGJhZy50eXBlKSB7XG4gICAgICBjYXNlIHBraS5vaWRzLnBrY3M4U2hyb3VkZWRLZXlCYWc6XG4gICAgICAgIC8qIGJhZ0FzbjEgaGFzIGEgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8sIHdoaWNoIHdlIG5lZWQgdG8gZGVjcnlwdC5cbiAgICAgICAgICAgQWZ0ZXJ3YXJkcyB3ZSBjYW4gaGFuZGxlIGl0IGxpa2UgYSBrZXlCYWcsXG4gICAgICAgICAgIHdoaWNoIGlzIGEgUHJpdmF0ZUtleUluZm8uICovXG4gICAgICAgIGJhZ0FzbjEgPSBwa2kuZGVjcnlwdFByaXZhdGVLZXlJbmZvKGJhZ0FzbjEsIHBhc3N3b3JkKTtcbiAgICAgICAgaWYoYmFnQXNuMSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdVbmFibGUgdG8gZGVjcnlwdCBQS0NTIzggU2hyb3VkZWRLZXlCYWcsIHdyb25nIHBhc3N3b3JkPycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogZmFsbCB0aHJvdWdoICovXG4gICAgICBjYXNlIHBraS5vaWRzLmtleUJhZzpcbiAgICAgICAgLyogQSBQS0NTIzEyIGtleUJhZyBpcyBhIHNpbXBsZSBQcml2YXRlS2V5SW5mbyBhcyB1bmRlcnN0b29kIGJ5IG91clxuICAgICAgICAgICBQS0kgbW9kdWxlLCBoZW5jZSB3ZSBkb24ndCBoYXZlIHRvIGRvIHZhbGlkYXRpb24vY2FwdHVyaW5nIGhlcmUsXG4gICAgICAgICAgIGp1c3QgcGFzcyB3aGF0IHdlIGFscmVhZHkgZ290LiAqL1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGJhZy5rZXkgPSBwa2kucHJpdmF0ZUtleUZyb21Bc24xKGJhZ0FzbjEpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAvLyBpZ25vcmUgdW5rbm93biBrZXkgdHlwZSwgcGFzcyBhc24xIHZhbHVlXG4gICAgICAgICAgYmFnLmtleSA9IG51bGw7XG4gICAgICAgICAgYmFnLmFzbjEgPSBiYWdBc24xO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlOyAgLyogTm90aGluZyBtb3JlIHRvIGRvLiAqL1xuXG4gICAgICBjYXNlIHBraS5vaWRzLmNlcnRCYWc6XG4gICAgICAgIC8qIEEgUEtDUyMxMiBjZXJ0QmFnIGNhbiB3cmFwIGJvdGggWC41MDkgYW5kIHNkc2kgY2VydGlmaWNhdGVzLlxuICAgICAgICAgICBUaGVyZWZvcmUgcHV0IHRoZSBTYWZlQmFnIGNvbnRlbnQgdGhyb3VnaCBhbm90aGVyIHZhbGlkYXRvciB0b1xuICAgICAgICAgICBjYXB0dXJlIHRoZSBmaWVsZHMuICBBZnRlcndhcmRzIGNoZWNrICYgc3RvcmUgdGhlIHJlc3VsdHMuICovXG4gICAgICAgIHZhbGlkYXRvciA9IGNlcnRCYWdWYWxpZGF0b3I7XG4gICAgICAgIGRlY29kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZihhc24xLmRlclRvT2lkKGNhcHR1cmUuY2VydElkKSAhPT0gcGtpLm9pZHMueDUwOUNlcnRpZmljYXRlKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdVbnN1cHBvcnRlZCBjZXJ0aWZpY2F0ZSB0eXBlLCBvbmx5IFguNTA5IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgICAgIGVycm9yLm9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jZXJ0SWQpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdHJ1ZT1wcm9kdWNlIGNlcnQgaGFzaFxuICAgICAgICAgIHZhciBjZXJ0QXNuMSA9IGFzbjEuZnJvbURlcihjYXB0dXJlLmNlcnQsIHN0cmljdCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJhZy5jZXJ0ID0gcGtpLmNlcnRpZmljYXRlRnJvbUFzbjEoY2VydEFzbjEsIHRydWUpO1xuICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgLy8gaWdub3JlIHVua25vd24gY2VydCB0eXBlLCBwYXNzIGFzbjEgdmFsdWVcbiAgICAgICAgICAgIGJhZy5jZXJ0ID0gbnVsbDtcbiAgICAgICAgICAgIGJhZy5hc24xID0gY2VydEFzbjE7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBQS0NTIzEyIFNhZmVCYWcgdHlwZS4nKTtcbiAgICAgICAgZXJyb3Iub2lkID0gYmFnLnR5cGU7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8qIFZhbGlkYXRlIFNhZmVCYWcgdmFsdWUgKGkuZS4gQ2VydEJhZywgZXRjLikgYW5kIGNhcHR1cmUgZGF0YSBpZiBuZWVkZWQuICovXG4gICAgaWYodmFsaWRhdG9yICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAhYXNuMS52YWxpZGF0ZShiYWdBc24xLCB2YWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgUEtDUyMxMiAnICsgdmFsaWRhdG9yLm5hbWUpO1xuICAgICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLyogQ2FsbCBkZWNvZGVyIGZ1bmN0aW9uIGZyb20gYWJvdmUgdG8gc3RvcmUgdGhlIHJlc3VsdHMuICovXG4gICAgZGVjb2RlcigpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBEZWNvZGUgUEtDUyMxMiBTRVQgT0YgUEtDUzEyQXR0cmlidXRlIGludG8gSmF2YVNjcmlwdCBvYmplY3QuXG4gKlxuICogQHBhcmFtIGF0dHJpYnV0ZXMgU0VUIE9GIFBLQ1MxMkF0dHJpYnV0ZSAoQVNOLjEgb2JqZWN0KS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkZWNvZGVkIGF0dHJpYnV0ZXMuXG4gKi9cbmZ1bmN0aW9uIF9kZWNvZGVCYWdBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgdmFyIGRlY29kZWRBdHRycyA9IHt9O1xuXG4gIGlmKGF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgY2FwdHVyZSA9IHt9O1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgaWYoIWFzbjEudmFsaWRhdGUoYXR0cmlidXRlc1tpXSwgYXR0cmlidXRlVmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgUEtDUyMxMiBCYWdBdHRyaWJ1dGUuJyk7XG4gICAgICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUub2lkKTtcbiAgICAgIGlmKHBraS5vaWRzW29pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB1bnN1cHBvcnRlZCBhdHRyaWJ1dGUgdHlwZSwgaWdub3JlLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZGVjb2RlZEF0dHJzW3BraS5vaWRzW29pZF1dID0gW107XG4gICAgICBmb3IodmFyIGogPSAwOyBqIDwgY2FwdHVyZS52YWx1ZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgZGVjb2RlZEF0dHJzW3BraS5vaWRzW29pZF1dLnB1c2goY2FwdHVyZS52YWx1ZXNbal0udmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZWNvZGVkQXR0cnM7XG59XG5cbi8qKlxuICogV3JhcHMgYSBwcml2YXRlIGtleSBhbmQgY2VydGlmaWNhdGUgaW4gYSBQS0NTIzEyIFBGWCB3cmFwcGVyLiBJZiBhXG4gKiBwYXNzd29yZCBpcyBwcm92aWRlZCB0aGVuIHRoZSBwcml2YXRlIGtleSB3aWxsIGJlIGVuY3J5cHRlZC5cbiAqXG4gKiBBbiBlbnRpcmUgY2VydGlmaWNhdGUgY2hhaW4gbWF5IGFsc28gYmUgaW5jbHVkZWQuIFRvIGRvIHRoaXMsIHBhc3NcbiAqIGFuIGFycmF5IGZvciB0aGUgXCJjZXJ0XCIgcGFyYW1ldGVyIHdoZXJlIHRoZSBmaXJzdCBjZXJ0aWZpY2F0ZSBpc1xuICogdGhlIG9uZSB0aGF0IGlzIHBhaXJlZCB3aXRoIHRoZSBwcml2YXRlIGtleSBhbmQgZWFjaCBzdWJzZXF1ZW50IG9uZVxuICogdmVyaWZpZXMgdGhlIHByZXZpb3VzIG9uZS4gVGhlIGNlcnRpZmljYXRlcyBtYXkgYmUgaW4gUEVNIGZvcm1hdCBvclxuICogaGF2ZSBiZWVuIGFscmVhZHkgcGFyc2VkIGJ5IEZvcmdlLlxuICpcbiAqIEB0b2RvIGltcGxlbWVudCBwYXNzd29yZC1iYXNlZC1lbmNyeXB0aW9uIGZvciB0aGUgd2hvbGUgcGFja2FnZVxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHByaXZhdGUga2V5LlxuICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIChtYXkgYmUgYW4gYXJyYXkgb2YgY2VydGlmaWNhdGVzIGluIG9yZGVyXG4gKiAgICAgICAgICB0byBzcGVjaWZ5IGEgY2VydGlmaWNhdGUgY2hhaW4pLlxuICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCB0byB1c2UsIG51bGwgZm9yIG5vbmUuXG4gKiBAcGFyYW0gb3B0aW9uczpcbiAqICAgICAgICAgIGFsZ29yaXRobSB0aGUgZW5jcnlwdGlvbiBhbGdvcml0aG0gdG8gdXNlXG4gKiAgICAgICAgICAgICgnYWVzMTI4JywgJ2FlczE5MicsICdhZXMyNTYnLCAnM2RlcycpLCBkZWZhdWx0cyB0byAnYWVzMTI4Jy5cbiAqICAgICAgICAgIGNvdW50IHRoZSBpdGVyYXRpb24gY291bnQgdG8gdXNlLlxuICogICAgICAgICAgc2FsdFNpemUgdGhlIHNhbHQgc2l6ZSB0byB1c2UuXG4gKiAgICAgICAgICB1c2VNYWMgdHJ1ZSB0byBpbmNsdWRlIGEgTUFDLCBmYWxzZSBub3QgdG8sIGRlZmF1bHRzIHRvIHRydWUuXG4gKiAgICAgICAgICBsb2NhbEtleUlkIHRoZSBsb2NhbCBrZXkgSUQgdG8gdXNlLCBpbiBoZXguXG4gKiAgICAgICAgICBmcmllbmRseU5hbWUgdGhlIGZyaWVuZGx5IG5hbWUgdG8gdXNlLlxuICogICAgICAgICAgZ2VuZXJhdGVMb2NhbEtleUlkIHRydWUgdG8gZ2VuZXJhdGUgYSByYW5kb20gbG9jYWwga2V5IElELFxuICogICAgICAgICAgICBmYWxzZSBub3QgdG8sIGRlZmF1bHRzIHRvIHRydWUuXG4gKlxuICogQHJldHVybiB0aGUgUEtDUyMxMiBQRlggQVNOLjEgb2JqZWN0LlxuICovXG5wMTIudG9Qa2NzMTJBc24xID0gZnVuY3Rpb24oa2V5LCBjZXJ0LCBwYXNzd29yZCwgb3B0aW9ucykge1xuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnNhbHRTaXplID0gb3B0aW9ucy5zYWx0U2l6ZSB8fCA4O1xuICBvcHRpb25zLmNvdW50ID0gb3B0aW9ucy5jb3VudCB8fCAyMDQ4O1xuICBvcHRpb25zLmFsZ29yaXRobSA9IG9wdGlvbnMuYWxnb3JpdGhtIHx8IG9wdGlvbnMuZW5jQWxnb3JpdGhtIHx8ICdhZXMxMjgnO1xuICBpZighKCd1c2VNYWMnIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy51c2VNYWMgPSB0cnVlO1xuICB9XG4gIGlmKCEoJ2xvY2FsS2V5SWQnIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5sb2NhbEtleUlkID0gbnVsbDtcbiAgfVxuICBpZighKCdnZW5lcmF0ZUxvY2FsS2V5SWQnIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5nZW5lcmF0ZUxvY2FsS2V5SWQgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGxvY2FsS2V5SWQgPSBvcHRpb25zLmxvY2FsS2V5SWQ7XG4gIHZhciBiYWdBdHRycztcbiAgaWYobG9jYWxLZXlJZCAhPT0gbnVsbCkge1xuICAgIGxvY2FsS2V5SWQgPSBmb3JnZS51dGlsLmhleFRvQnl0ZXMobG9jYWxLZXlJZCk7XG4gIH0gZWxzZSBpZihvcHRpb25zLmdlbmVyYXRlTG9jYWxLZXlJZCkge1xuICAgIC8vIHVzZSBTSEEtMSBvZiBwYWlyZWQgY2VydCwgaWYgYXZhaWxhYmxlXG4gICAgaWYoY2VydCkge1xuICAgICAgdmFyIHBhaXJlZENlcnQgPSBmb3JnZS51dGlsLmlzQXJyYXkoY2VydCkgPyBjZXJ0WzBdIDogY2VydDtcbiAgICAgIGlmKHR5cGVvZiBwYWlyZWRDZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYWlyZWRDZXJ0ID0gcGtpLmNlcnRpZmljYXRlRnJvbVBlbShwYWlyZWRDZXJ0KTtcbiAgICAgIH1cbiAgICAgIHZhciBzaGExID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICAgIHNoYTEudXBkYXRlKGFzbjEudG9EZXIocGtpLmNlcnRpZmljYXRlVG9Bc24xKHBhaXJlZENlcnQpKS5nZXRCeXRlcygpKTtcbiAgICAgIGxvY2FsS2V5SWQgPSBzaGExLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZJWE1FOiBjb25zaWRlciB1c2luZyBTSEEtMSBvZiBwdWJsaWMga2V5ICh3aGljaCBjYW4gYmUgZ2VuZXJhdGVkXG4gICAgICAvLyBmcm9tIHByaXZhdGUga2V5IGNvbXBvbmVudHMpLCBzZWU6IGNlcnQuZ2VuZXJhdGVTdWJqZWN0S2V5SWRlbnRpZmllclxuICAgICAgLy8gZ2VuZXJhdGUgcmFuZG9tIGJ5dGVzXG4gICAgICBsb2NhbEtleUlkID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzKDIwKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYXR0cnMgPSBbXTtcbiAgaWYobG9jYWxLZXlJZCAhPT0gbnVsbCkge1xuICAgIGF0dHJzLnB1c2goXG4gICAgICAvLyBsb2NhbEtleUlEXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIGF0dHJJZFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5sb2NhbEtleUlkKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gYXR0clZhbHVlc1xuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFVCwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsIGZhbHNlLFxuICAgICAgICAgICAgbG9jYWxLZXlJZClcbiAgICAgICAgXSlcbiAgICAgIF0pKTtcbiAgfVxuICBpZignZnJpZW5kbHlOYW1lJyBpbiBvcHRpb25zKSB7XG4gICAgYXR0cnMucHVzaChcbiAgICAgIC8vIGZyaWVuZGx5TmFtZVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBhdHRySWRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMuZnJpZW5kbHlOYW1lKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gYXR0clZhbHVlc1xuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFVCwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQk1QU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAgIG9wdGlvbnMuZnJpZW5kbHlOYW1lKVxuICAgICAgICBdKVxuICAgICAgXSkpO1xuICB9XG5cbiAgaWYoYXR0cnMubGVuZ3RoID4gMCkge1xuICAgIGJhZ0F0dHJzID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVQsIHRydWUsIGF0dHJzKTtcbiAgfVxuXG4gIC8vIGNvbGxlY3QgY29udGVudHMgZm9yIEF1dGhlbnRpY2F0ZWRTYWZlXG4gIHZhciBjb250ZW50cyA9IFtdO1xuXG4gIC8vIGNyZWF0ZSBzYWZlIGJhZyhzKSBmb3IgY2VydGlmaWNhdGUgY2hhaW5cbiAgdmFyIGNoYWluID0gW107XG4gIGlmKGNlcnQgIT09IG51bGwpIHtcbiAgICBpZihmb3JnZS51dGlsLmlzQXJyYXkoY2VydCkpIHtcbiAgICAgIGNoYWluID0gY2VydDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhaW4gPSBbY2VydF07XG4gICAgfVxuICB9XG5cbiAgdmFyIGNlcnRTYWZlQmFncyA9IFtdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgY2hhaW4ubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBjb252ZXJ0IGNlcnQgZnJvbSBQRU0gYXMgbmVjZXNzYXJ5XG4gICAgY2VydCA9IGNoYWluW2ldO1xuICAgIGlmKHR5cGVvZiBjZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgY2VydCA9IHBraS5jZXJ0aWZpY2F0ZUZyb21QZW0oY2VydCk7XG4gICAgfVxuXG4gICAgLy8gU2FmZUJhZ1xuICAgIHZhciBjZXJ0QmFnQXR0cnMgPSAoaSA9PT0gMCkgPyBiYWdBdHRycyA6IHVuZGVmaW5lZDtcbiAgICB2YXIgY2VydEFzbjEgPSBwa2kuY2VydGlmaWNhdGVUb0FzbjEoY2VydCk7XG4gICAgdmFyIGNlcnRTYWZlQmFnID1cbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8gYmFnSWRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMuY2VydEJhZykuZ2V0Qnl0ZXMoKSksXG4gICAgICAgIC8vIGJhZ1ZhbHVlXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW1xuICAgICAgICAgIC8vIENlcnRCYWdcbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICAvLyBjZXJ0SWRcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy54NTA5Q2VydGlmaWNhdGUpLmdldEJ5dGVzKCkpLFxuICAgICAgICAgICAgLy8gY2VydFZhbHVlICh4NTA5Q2VydGlmaWNhdGUpXG4gICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtcbiAgICAgICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsXG4gICAgICAgICAgICAgICAgYXNuMS50b0RlcihjZXJ0QXNuMSkuZ2V0Qnl0ZXMoKSlcbiAgICAgICAgICAgIF0pXSldKSxcbiAgICAgICAgLy8gYmFnQXR0cmlidXRlcyAoT1BUSU9OQUwpXG4gICAgICAgIGNlcnRCYWdBdHRyc1xuICAgICAgXSk7XG4gICAgY2VydFNhZmVCYWdzLnB1c2goY2VydFNhZmVCYWcpO1xuICB9XG5cbiAgaWYoY2VydFNhZmVCYWdzLmxlbmd0aCA+IDApIHtcbiAgICAvLyBTYWZlQ29udGVudHNcbiAgICB2YXIgY2VydFNhZmVDb250ZW50cyA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgY2VydFNhZmVCYWdzKTtcblxuICAgIC8vIENvbnRlbnRJbmZvXG4gICAgdmFyIGNlcnRDSSA9XG4gICAgICAvLyBQS0NTIzcgQ29udGVudEluZm9cbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8gY29udGVudFR5cGVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgIC8vIE9JRCBmb3IgdGhlIGNvbnRlbnQgdHlwZSBpcyAnZGF0YSdcbiAgICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzLmRhdGEpLmdldEJ5dGVzKCkpLFxuICAgICAgICAvLyBjb250ZW50XG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsXG4gICAgICAgICAgICBhc24xLnRvRGVyKGNlcnRTYWZlQ29udGVudHMpLmdldEJ5dGVzKCkpXG4gICAgICAgIF0pXG4gICAgICBdKTtcbiAgICBjb250ZW50cy5wdXNoKGNlcnRDSSk7XG4gIH1cblxuICAvLyBjcmVhdGUgc2FmZSBjb250ZW50cyBmb3IgcHJpdmF0ZSBrZXlcbiAgdmFyIGtleUJhZyA9IG51bGw7XG4gIGlmKGtleSAhPT0gbnVsbCkge1xuICAgIC8vIFNhZmVCYWdcbiAgICB2YXIgcGtBc24xID0gcGtpLndyYXBSc2FQcml2YXRlS2V5KHBraS5wcml2YXRlS2V5VG9Bc24xKGtleSkpO1xuICAgIGlmKHBhc3N3b3JkID09PSBudWxsKSB7XG4gICAgICAvLyBubyBlbmNyeXB0aW9uXG4gICAgICBrZXlCYWcgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIGJhZ0lkXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzLmtleUJhZykuZ2V0Qnl0ZXMoKSksXG4gICAgICAgIC8vIGJhZ1ZhbHVlXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW1xuICAgICAgICAgIC8vIFByaXZhdGVLZXlJbmZvXG4gICAgICAgICAgcGtBc24xXG4gICAgICAgIF0pLFxuICAgICAgICAvLyBiYWdBdHRyaWJ1dGVzIChPUFRJT05BTClcbiAgICAgICAgYmFnQXR0cnNcbiAgICAgIF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbmNyeXB0ZWQgUHJpdmF0ZUtleUluZm9cbiAgICAgIGtleUJhZyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8gYmFnSWRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMucGtjczhTaHJvdWRlZEtleUJhZykuZ2V0Qnl0ZXMoKSksXG4gICAgICAgIC8vIGJhZ1ZhbHVlXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW1xuICAgICAgICAgIC8vIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvXG4gICAgICAgICAgcGtpLmVuY3J5cHRQcml2YXRlS2V5SW5mbyhwa0FzbjEsIHBhc3N3b3JkLCBvcHRpb25zKVxuICAgICAgICBdKSxcbiAgICAgICAgLy8gYmFnQXR0cmlidXRlcyAoT1BUSU9OQUwpXG4gICAgICAgIGJhZ0F0dHJzXG4gICAgICBdKTtcbiAgICB9XG5cbiAgICAvLyBTYWZlQ29udGVudHNcbiAgICB2YXIga2V5U2FmZUNvbnRlbnRzID1cbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtrZXlCYWddKTtcblxuICAgIC8vIENvbnRlbnRJbmZvXG4gICAgdmFyIGtleUNJID1cbiAgICAgIC8vIFBLQ1MjNyBDb250ZW50SW5mb1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBjb250ZW50VHlwZVxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgLy8gT0lEIGZvciB0aGUgY29udGVudCB0eXBlIGlzICdkYXRhJ1xuICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMuZGF0YSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEudG9EZXIoa2V5U2FmZUNvbnRlbnRzKS5nZXRCeXRlcygpKVxuICAgICAgICBdKVxuICAgICAgXSk7XG4gICAgY29udGVudHMucHVzaChrZXlDSSk7XG4gIH1cblxuICAvLyBjcmVhdGUgQXV0aGVudGljYXRlZFNhZmUgYnkgc3RyaW5naW5nIHRvZ2V0aGVyIHRoZSBjb250ZW50c1xuICB2YXIgc2FmZSA9IGFzbjEuY3JlYXRlKFxuICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIGNvbnRlbnRzKTtcblxuICB2YXIgbWFjRGF0YTtcbiAgaWYob3B0aW9ucy51c2VNYWMpIHtcbiAgICAvLyBNYWNEYXRhXG4gICAgdmFyIHNoYTEgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgIHZhciBtYWNTYWx0ID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcihcbiAgICAgIGZvcmdlLnJhbmRvbS5nZXRCeXRlcyhvcHRpb25zLnNhbHRTaXplKSk7XG4gICAgdmFyIGNvdW50ID0gb3B0aW9ucy5jb3VudDtcbiAgICAvLyAxNjAtYml0IGtleVxuICAgIHZhciBrZXkgPSBwMTIuZ2VuZXJhdGVLZXkocGFzc3dvcmQsIG1hY1NhbHQsIDMsIGNvdW50LCAyMCk7XG4gICAgdmFyIG1hYyA9IGZvcmdlLmhtYWMuY3JlYXRlKCk7XG4gICAgbWFjLnN0YXJ0KHNoYTEsIGtleSk7XG4gICAgbWFjLnVwZGF0ZShhc24xLnRvRGVyKHNhZmUpLmdldEJ5dGVzKCkpO1xuICAgIHZhciBtYWNWYWx1ZSA9IG1hYy5nZXRNYWMoKTtcbiAgICBtYWNEYXRhID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gbWFjIERpZ2VzdEluZm9cbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8gZGlnZXN0QWxnb3JpdGhtXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAvLyBhbGdvcml0aG0gPSBTSEEtMVxuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMuc2hhMSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgLy8gcGFyYW1ldGVycyA9IE51bGxcbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICAgICAgXSksXG4gICAgICAgIC8vIGRpZ2VzdFxuICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICAgIGZhbHNlLCBtYWNWYWx1ZS5nZXRCeXRlcygpKVxuICAgICAgXSksXG4gICAgICAvLyBtYWNTYWx0IE9DVEVUIFNUUklOR1xuICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsIGZhbHNlLCBtYWNTYWx0LmdldEJ5dGVzKCkpLFxuICAgICAgLy8gaXRlcmF0aW9ucyBJTlRFR0VSIChYWFg6IE9ubHkgc3VwcG9ydCBjb3VudCA8IDY1NTM2KVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoY291bnQpLmdldEJ5dGVzKClcbiAgICAgIClcbiAgICBdKTtcbiAgfVxuXG4gIC8vIFBGWFxuICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgIC8vIHZlcnNpb24gKDMpXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGFzbjEuaW50ZWdlclRvRGVyKDMpLmdldEJ5dGVzKCkpLFxuICAgIC8vIFBLQ1MjNyBDb250ZW50SW5mb1xuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIC8vIGNvbnRlbnRUeXBlXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIC8vIE9JRCBmb3IgdGhlIGNvbnRlbnQgdHlwZSBpcyAnZGF0YSdcbiAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5kYXRhKS5nZXRCeXRlcygpKSxcbiAgICAgIC8vIGNvbnRlbnRcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW1xuICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICBhc24xLnRvRGVyKHNhZmUpLmdldEJ5dGVzKCkpXG4gICAgICBdKVxuICAgIF0pLFxuICAgIG1hY0RhdGFcbiAgXSk7XG59O1xuXG4vKipcbiAqIERlcml2ZXMgYSBQS0NTIzEyIGtleS5cbiAqXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlcml2ZSB0aGUga2V5IG1hdGVyaWFsIGZyb20sIG51bGwgb3JcbiAqICAgICAgICAgIHVuZGVmaW5lZCBmb3Igbm9uZS5cbiAqIEBwYXJhbSBzYWx0IHRoZSBzYWx0LCBhcyBhIEJ5dGVCdWZmZXIsIHRvIHVzZS5cbiAqIEBwYXJhbSBpZCB0aGUgUEtDUyMxMiBJRCBieXRlICgxID0ga2V5IG1hdGVyaWFsLCAyID0gSVYsIDMgPSBNQUMpLlxuICogQHBhcmFtIGl0ZXIgdGhlIGl0ZXJhdGlvbiBjb3VudC5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZGVyaXZlIGZyb20gdGhlIHBhc3N3b3JkLlxuICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCB0byB1c2UsIGRlZmF1bHRzIHRvIFNIQS0xLlxuICpcbiAqIEByZXR1cm4gYSBCeXRlQnVmZmVyIHdpdGggdGhlIGJ5dGVzIGRlcml2ZWQgZnJvbSB0aGUgcGFzc3dvcmQuXG4gKi9cbnAxMi5nZW5lcmF0ZUtleSA9IGZvcmdlLnBiZS5nZW5lcmF0ZVBrY3MxMktleTtcbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJhc24xIiwicGtpIiwicDEyIiwibW9kdWxlIiwiZXhwb3J0cyIsInBrY3MxMiIsImNvbnRlbnRJbmZvVmFsaWRhdG9yIiwibmFtZSIsInRhZ0NsYXNzIiwiQ2xhc3MiLCJVTklWRVJTQUwiLCJ0eXBlIiwiVHlwZSIsIlNFUVVFTkNFIiwiY29uc3RydWN0ZWQiLCJ2YWx1ZSIsIk9JRCIsImNhcHR1cmUiLCJDT05URVhUX1NQRUNJRklDIiwiY2FwdHVyZUFzbjEiLCJwZnhWYWxpZGF0b3IiLCJJTlRFR0VSIiwib3B0aW9uYWwiLCJPQ1RFVFNUUklORyIsInNhZmVCYWdWYWxpZGF0b3IiLCJTRVQiLCJhdHRyaWJ1dGVWYWxpZGF0b3IiLCJjZXJ0QmFnVmFsaWRhdG9yIiwiX2dldEJhZ3NCeUF0dHJpYnV0ZSIsInNhZmVDb250ZW50cyIsImF0dHJOYW1lIiwiYXR0clZhbHVlIiwiYmFnVHlwZSIsInJlc3VsdCIsImkiLCJsZW5ndGgiLCJqIiwic2FmZUJhZ3MiLCJiYWciLCJ1bmRlZmluZWQiLCJwdXNoIiwiYXR0cmlidXRlcyIsImluZGV4T2YiLCJwa2NzMTJGcm9tQXNuMSIsIm9iaiIsInN0cmljdCIsInBhc3N3b3JkIiwiZXJyb3JzIiwidmFsaWRhdGUiLCJlcnJvciIsIkVycm9yIiwicGZ4IiwidmVyc2lvbiIsImNoYXJDb2RlQXQiLCJnZXRCYWdzIiwiZmlsdGVyIiwicnZhbCIsImxvY2FsS2V5SWQiLCJ1dGlsIiwiaGV4VG9CeXRlcyIsImxvY2FsS2V5SWRIZXgiLCJmcmllbmRseU5hbWUiLCJnZXRCYWdzQnlGcmllbmRseU5hbWUiLCJnZXRCYWdzQnlMb2NhbEtleUlkIiwiZGVyVG9PaWQiLCJjb250ZW50VHlwZSIsIm9pZHMiLCJkYXRhIiwib2lkIiwiY29udGVudCIsIl9kZWNvZGVQa2NzN0RhdGEiLCJtYWMiLCJtZCIsIm1hY0tleUJ5dGVzIiwibWFjQWxnb3JpdGhtIiwic2hhMSIsImNyZWF0ZSIsInNoYTI1NiIsInNoYTM4NCIsInNoYTUxMiIsIm1kNSIsIm1hY1NhbHQiLCJCeXRlQnVmZmVyIiwibWFjSXRlcmF0aW9ucyIsInBhcnNlSW50IiwiYnl0ZXNUb0hleCIsIm1hY0tleSIsImdlbmVyYXRlS2V5IiwiaG1hYyIsInN0YXJ0IiwidXBkYXRlIiwibWFjVmFsdWUiLCJnZXRNYWMiLCJnZXRCeXRlcyIsIm1hY0RpZ2VzdCIsIl9kZWNvZGVBdXRoZW50aWNhdGVkU2FmZSIsImNvbXBvc2VkIiwiY3JlYXRlQnVmZmVyIiwicHV0Qnl0ZXMiLCJhdXRoU2FmZSIsImZyb21EZXIiLCJjb250ZW50SW5mbyIsImVuY3J5cHRlZCIsImVuY3J5cHRlZERhdGEiLCJfZGVjcnlwdFNhZmVDb250ZW50cyIsIl9kZWNvZGVTYWZlQ29udGVudHMiLCJwa2NzNyIsImVuY3J5cHRlZERhdGFWYWxpZGF0b3IiLCJlbmNBbGdvcml0aG0iLCJjaXBoZXIiLCJwYmUiLCJnZXRDaXBoZXIiLCJlbmNQYXJhbWV0ZXIiLCJlbmNyeXB0ZWRDb250ZW50QXNuMSIsImZpbmlzaCIsIm91dHB1dCIsInJlcyIsInNhZmVCYWciLCJiYWdJZCIsIl9kZWNvZGVCYWdBdHRyaWJ1dGVzIiwiYmFnQXR0cmlidXRlcyIsInZhbGlkYXRvciIsImRlY29kZXIiLCJiYWdBc24xIiwiYmFnVmFsdWUiLCJwa2NzOFNocm91ZGVkS2V5QmFnIiwiZGVjcnlwdFByaXZhdGVLZXlJbmZvIiwia2V5QmFnIiwia2V5IiwicHJpdmF0ZUtleUZyb21Bc24xIiwiZSIsImNlcnRCYWciLCJjZXJ0SWQiLCJ4NTA5Q2VydGlmaWNhdGUiLCJjZXJ0QXNuMSIsImNlcnQiLCJjZXJ0aWZpY2F0ZUZyb21Bc24xIiwiZGVjb2RlZEF0dHJzIiwidmFsdWVzIiwidG9Qa2NzMTJBc24xIiwib3B0aW9ucyIsInNhbHRTaXplIiwiY291bnQiLCJhbGdvcml0aG0iLCJ1c2VNYWMiLCJnZW5lcmF0ZUxvY2FsS2V5SWQiLCJiYWdBdHRycyIsInBhaXJlZENlcnQiLCJpc0FycmF5IiwiY2VydGlmaWNhdGVGcm9tUGVtIiwidG9EZXIiLCJjZXJ0aWZpY2F0ZVRvQXNuMSIsImRpZ2VzdCIsInJhbmRvbSIsImF0dHJzIiwib2lkVG9EZXIiLCJCTVBTVFJJTkciLCJjb250ZW50cyIsImNoYWluIiwiY2VydFNhZmVCYWdzIiwiY2VydEJhZ0F0dHJzIiwiY2VydFNhZmVCYWciLCJjZXJ0U2FmZUNvbnRlbnRzIiwiY2VydENJIiwicGtBc24xIiwid3JhcFJzYVByaXZhdGVLZXkiLCJwcml2YXRlS2V5VG9Bc24xIiwiZW5jcnlwdFByaXZhdGVLZXlJbmZvIiwia2V5U2FmZUNvbnRlbnRzIiwia2V5Q0kiLCJzYWZlIiwibWFjRGF0YSIsIk5VTEwiLCJpbnRlZ2VyVG9EZXIiLCJnZW5lcmF0ZVBrY3MxMktleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/pkcs12.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/pkcs7.js":
/*!**********************************************!*\
  !*** ./node_modules/node-forge/lib/pkcs7.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Javascript implementation of PKCS#7 v1.5.\n *\n * @author Stefan Siegl\n * @author Dave Longley\n *\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n * Copyright (c) 2012-2015 Digital Bazaar, Inc.\n *\n * Currently this implementation only supports ContentType of EnvelopedData,\n * EncryptedData, or SignedData at the root level. The top level elements may\n * contain only a ContentInfo of ContentType Data, i.e. plain data. Further\n * nesting is not (yet) supported.\n *\n * The Forge validators for PKCS #7's ASN.1 structures are available from\n * a separate file pkcs7asn1.js, since those are referenced from other\n * PKCS standards like PKCS #12.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./aes */ \"(rsc)/./node_modules/node-forge/lib/aes.js\");\n__webpack_require__(/*! ./asn1 */ \"(rsc)/./node_modules/node-forge/lib/asn1.js\");\n__webpack_require__(/*! ./des */ \"(rsc)/./node_modules/node-forge/lib/des.js\");\n__webpack_require__(/*! ./oids */ \"(rsc)/./node_modules/node-forge/lib/oids.js\");\n__webpack_require__(/*! ./pem */ \"(rsc)/./node_modules/node-forge/lib/pem.js\");\n__webpack_require__(/*! ./pkcs7asn1 */ \"(rsc)/./node_modules/node-forge/lib/pkcs7asn1.js\");\n__webpack_require__(/*! ./random */ \"(rsc)/./node_modules/node-forge/lib/random.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\n__webpack_require__(/*! ./x509 */ \"(rsc)/./node_modules/node-forge/lib/x509.js\");\n// shortcut for ASN.1 API\nvar asn1 = forge.asn1;\n// shortcut for PKCS#7 API\nvar p7 = module.exports = forge.pkcs7 = forge.pkcs7 || {};\n/**\n * Converts a PKCS#7 message from PEM format.\n *\n * @param pem the PEM-formatted PKCS#7 message.\n *\n * @return the PKCS#7 message.\n */ p7.messageFromPem = function(pem) {\n    var msg = forge.pem.decode(pem)[0];\n    if (msg.type !== \"PKCS7\") {\n        var error = new Error(\"Could not convert PKCS#7 message from PEM; PEM \" + 'header type is not \"PKCS#7\".');\n        error.headerType = msg.type;\n        throw error;\n    }\n    if (msg.procType && msg.procType.type === \"ENCRYPTED\") {\n        throw new Error(\"Could not convert PKCS#7 message from PEM; PEM is encrypted.\");\n    }\n    // convert DER to ASN.1 object\n    var obj = asn1.fromDer(msg.body);\n    return p7.messageFromAsn1(obj);\n};\n/**\n * Converts a PKCS#7 message to PEM format.\n *\n * @param msg The PKCS#7 message object\n * @param maxline The maximum characters per line, defaults to 64.\n *\n * @return The PEM-formatted PKCS#7 message.\n */ p7.messageToPem = function(msg, maxline) {\n    // convert to ASN.1, then DER, then PEM-encode\n    var pemObj = {\n        type: \"PKCS7\",\n        body: asn1.toDer(msg.toAsn1()).getBytes()\n    };\n    return forge.pem.encode(pemObj, {\n        maxline: maxline\n    });\n};\n/**\n * Converts a PKCS#7 message from an ASN.1 object.\n *\n * @param obj the ASN.1 representation of a ContentInfo.\n *\n * @return the PKCS#7 message.\n */ p7.messageFromAsn1 = function(obj) {\n    // validate root level ContentInfo and capture data\n    var capture = {};\n    var errors = [];\n    if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {\n        var error = new Error(\"Cannot read PKCS#7 message. \" + \"ASN.1 object is not an PKCS#7 ContentInfo.\");\n        error.errors = errors;\n        throw error;\n    }\n    var contentType = asn1.derToOid(capture.contentType);\n    var msg;\n    switch(contentType){\n        case forge.pki.oids.envelopedData:\n            msg = p7.createEnvelopedData();\n            break;\n        case forge.pki.oids.encryptedData:\n            msg = p7.createEncryptedData();\n            break;\n        case forge.pki.oids.signedData:\n            msg = p7.createSignedData();\n            break;\n        default:\n            throw new Error(\"Cannot read PKCS#7 message. ContentType with OID \" + contentType + \" is not (yet) supported.\");\n    }\n    msg.fromAsn1(capture.content.value[0]);\n    return msg;\n};\np7.createSignedData = function() {\n    var msg = null;\n    msg = {\n        type: forge.pki.oids.signedData,\n        version: 1,\n        certificates: [],\n        crls: [],\n        // TODO: add json-formatted signer stuff here?\n        signers: [],\n        // populated during sign()\n        digestAlgorithmIdentifiers: [],\n        contentInfo: null,\n        signerInfos: [],\n        fromAsn1: function(obj) {\n            // validate SignedData content block and capture data.\n            _fromAsn1(msg, obj, p7.asn1.signedDataValidator);\n            msg.certificates = [];\n            msg.crls = [];\n            msg.digestAlgorithmIdentifiers = [];\n            msg.contentInfo = null;\n            msg.signerInfos = [];\n            if (msg.rawCapture.certificates) {\n                var certs = msg.rawCapture.certificates.value;\n                for(var i = 0; i < certs.length; ++i){\n                    msg.certificates.push(forge.pki.certificateFromAsn1(certs[i]));\n                }\n            }\n        // TODO: parse crls\n        },\n        toAsn1: function() {\n            // degenerate case with no content\n            if (!msg.contentInfo) {\n                msg.sign();\n            }\n            var certs = [];\n            for(var i = 0; i < msg.certificates.length; ++i){\n                certs.push(forge.pki.certificateToAsn1(msg.certificates[i]));\n            }\n            var crls = [];\n            // TODO: implement CRLs\n            // [0] SignedData\n            var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                    // Version\n                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()),\n                    // DigestAlgorithmIdentifiers\n                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.digestAlgorithmIdentifiers),\n                    // ContentInfo\n                    msg.contentInfo\n                ])\n            ]);\n            if (certs.length > 0) {\n                // [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL\n                signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs));\n            }\n            if (crls.length > 0) {\n                // [1] IMPLICIT CertificateRevocationLists OPTIONAL\n                signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls));\n            }\n            // SignerInfos\n            signedData.value[0].value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.signerInfos));\n            // ContentInfo\n            return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                // ContentType\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()),\n                // [0] SignedData\n                signedData\n            ]);\n        },\n        /**\n     * Add (another) entity to list of signers.\n     *\n     * Note: If authenticatedAttributes are provided, then, per RFC 2315,\n     * they must include at least two attributes: content type and\n     * message digest. The message digest attribute value will be\n     * auto-calculated during signing and will be ignored if provided.\n     *\n     * Here's an example of providing these two attributes:\n     *\n     * forge.pkcs7.createSignedData();\n     * p7.addSigner({\n     *   issuer: cert.issuer.attributes,\n     *   serialNumber: cert.serialNumber,\n     *   key: privateKey,\n     *   digestAlgorithm: forge.pki.oids.sha1,\n     *   authenticatedAttributes: [{\n     *     type: forge.pki.oids.contentType,\n     *     value: forge.pki.oids.data\n     *   }, {\n     *     type: forge.pki.oids.messageDigest\n     *   }]\n     * });\n     *\n     * TODO: Support [subjectKeyIdentifier] as signer's ID.\n     *\n     * @param signer the signer information:\n     *          key the signer's private key.\n     *          [certificate] a certificate containing the public key\n     *            associated with the signer's private key; use this option as\n     *            an alternative to specifying signer.issuer and\n     *            signer.serialNumber.\n     *          [issuer] the issuer attributes (eg: cert.issuer.attributes).\n     *          [serialNumber] the signer's certificate's serial number in\n     *           hexadecimal (eg: cert.serialNumber).\n     *          [digestAlgorithm] the message digest OID, as a string, to use\n     *            (eg: forge.pki.oids.sha1).\n     *          [authenticatedAttributes] an optional array of attributes\n     *            to also sign along with the content.\n     */ addSigner: function(signer) {\n            var issuer = signer.issuer;\n            var serialNumber = signer.serialNumber;\n            if (signer.certificate) {\n                var cert = signer.certificate;\n                if (typeof cert === \"string\") {\n                    cert = forge.pki.certificateFromPem(cert);\n                }\n                issuer = cert.issuer.attributes;\n                serialNumber = cert.serialNumber;\n            }\n            var key = signer.key;\n            if (!key) {\n                throw new Error(\"Could not add PKCS#7 signer; no private key specified.\");\n            }\n            if (typeof key === \"string\") {\n                key = forge.pki.privateKeyFromPem(key);\n            }\n            // ensure OID known for digest algorithm\n            var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;\n            switch(digestAlgorithm){\n                case forge.pki.oids.sha1:\n                case forge.pki.oids.sha256:\n                case forge.pki.oids.sha384:\n                case forge.pki.oids.sha512:\n                case forge.pki.oids.md5:\n                    break;\n                default:\n                    throw new Error(\"Could not add PKCS#7 signer; unknown message digest algorithm: \" + digestAlgorithm);\n            }\n            // if authenticatedAttributes is present, then the attributes\n            // must contain at least PKCS #9 content-type and message-digest\n            var authenticatedAttributes = signer.authenticatedAttributes || [];\n            if (authenticatedAttributes.length > 0) {\n                var contentType = false;\n                var messageDigest = false;\n                for(var i = 0; i < authenticatedAttributes.length; ++i){\n                    var attr = authenticatedAttributes[i];\n                    if (!contentType && attr.type === forge.pki.oids.contentType) {\n                        contentType = true;\n                        if (messageDigest) {\n                            break;\n                        }\n                        continue;\n                    }\n                    if (!messageDigest && attr.type === forge.pki.oids.messageDigest) {\n                        messageDigest = true;\n                        if (contentType) {\n                            break;\n                        }\n                        continue;\n                    }\n                }\n                if (!contentType || !messageDigest) {\n                    throw new Error(\"Invalid signer.authenticatedAttributes. If \" + \"signer.authenticatedAttributes is specified, then it must \" + \"contain at least two attributes, PKCS #9 content-type and \" + \"PKCS #9 message-digest.\");\n                }\n            }\n            msg.signers.push({\n                key: key,\n                version: 1,\n                issuer: issuer,\n                serialNumber: serialNumber,\n                digestAlgorithm: digestAlgorithm,\n                signatureAlgorithm: forge.pki.oids.rsaEncryption,\n                signature: null,\n                authenticatedAttributes: authenticatedAttributes,\n                unauthenticatedAttributes: []\n            });\n        },\n        /**\n     * Signs the content.\n     * @param options Options to apply when signing:\n     *    [detached] boolean. If signing should be done in detached mode. Defaults to false.\n     */ sign: function(options) {\n            options = options || {};\n            // auto-generate content info\n            if (typeof msg.content !== \"object\" || msg.contentInfo === null) {\n                // use Data ContentInfo\n                msg.contentInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                    // ContentType\n                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes())\n                ]);\n                // add actual content, if present\n                if (\"content\" in msg) {\n                    var content;\n                    if (msg.content instanceof forge.util.ByteBuffer) {\n                        content = msg.content.bytes();\n                    } else if (typeof msg.content === \"string\") {\n                        content = forge.util.encodeUtf8(msg.content);\n                    }\n                    if (options.detached) {\n                        msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);\n                    } else {\n                        msg.contentInfo.value.push(// [0] EXPLICIT content\n                        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n                            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content)\n                        ]));\n                    }\n                }\n            }\n            // no signers, return early (degenerate case for certificate container)\n            if (msg.signers.length === 0) {\n                return;\n            }\n            // generate digest algorithm identifiers\n            var mds = addDigestAlgorithmIds();\n            // generate signerInfos\n            addSignerInfos(mds);\n        },\n        verify: function() {\n            throw new Error(\"PKCS#7 signature verification not yet implemented.\");\n        },\n        /**\n     * Add a certificate.\n     *\n     * @param cert the certificate to add.\n     */ addCertificate: function(cert) {\n            // convert from PEM\n            if (typeof cert === \"string\") {\n                cert = forge.pki.certificateFromPem(cert);\n            }\n            msg.certificates.push(cert);\n        },\n        /**\n     * Add a certificate revokation list.\n     *\n     * @param crl the certificate revokation list to add.\n     */ addCertificateRevokationList: function(crl) {\n            throw new Error(\"PKCS#7 CRL support not yet implemented.\");\n        }\n    };\n    return msg;\n    function addDigestAlgorithmIds() {\n        var mds = {};\n        for(var i = 0; i < msg.signers.length; ++i){\n            var signer = msg.signers[i];\n            var oid = signer.digestAlgorithm;\n            if (!(oid in mds)) {\n                // content digest\n                mds[oid] = forge.md[forge.pki.oids[oid]].create();\n            }\n            if (signer.authenticatedAttributes.length === 0) {\n                // no custom attributes to digest; use content message digest\n                signer.md = mds[oid];\n            } else {\n                // custom attributes to be digested; use own message digest\n                // TODO: optimize to just copy message digest state if that\n                // feature is ever supported with message digests\n                signer.md = forge.md[forge.pki.oids[oid]].create();\n            }\n        }\n        // add unique digest algorithm identifiers\n        msg.digestAlgorithmIdentifiers = [];\n        for(var oid in mds){\n            msg.digestAlgorithmIdentifiers.push(// AlgorithmIdentifier\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                // algorithm\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oid).getBytes()),\n                // parameters (null)\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n            ]));\n        }\n        return mds;\n    }\n    function addSignerInfos(mds) {\n        var content;\n        if (msg.detachedContent) {\n            // Signature has been made in detached mode.\n            content = msg.detachedContent;\n        } else {\n            // Note: ContentInfo is a SEQUENCE with 2 values, second value is\n            // the content field and is optional for a ContentInfo but required here\n            // since signers are present\n            // get ContentInfo content\n            content = msg.contentInfo.value[1];\n            // skip [0] EXPLICIT content wrapper\n            content = content.value[0];\n        }\n        if (!content) {\n            throw new Error(\"Could not sign PKCS#7 message; there is no content to sign.\");\n        }\n        // get ContentInfo content type\n        var contentType = asn1.derToOid(msg.contentInfo.value[0].value);\n        // serialize content\n        var bytes = asn1.toDer(content);\n        // skip identifier and length per RFC 2315 9.3\n        // skip identifier (1 byte)\n        bytes.getByte();\n        // read and discard length bytes\n        asn1.getBerValueLength(bytes);\n        bytes = bytes.getBytes();\n        // digest content DER value bytes\n        for(var oid in mds){\n            mds[oid].start().update(bytes);\n        }\n        // sign content\n        var signingTime = new Date();\n        for(var i = 0; i < msg.signers.length; ++i){\n            var signer = msg.signers[i];\n            if (signer.authenticatedAttributes.length === 0) {\n                // if ContentInfo content type is not \"Data\", then\n                // authenticatedAttributes must be present per RFC 2315\n                if (contentType !== forge.pki.oids.data) {\n                    throw new Error(\"Invalid signer; authenticatedAttributes must be present \" + \"when the ContentInfo content type is not PKCS#7 Data.\");\n                }\n            } else {\n                // process authenticated attributes\n                // [0] IMPLICIT\n                signer.authenticatedAttributesAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);\n                // per RFC 2315, attributes are to be digested using a SET container\n                // not the above [0] IMPLICIT container\n                var attrsAsn1 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, []);\n                for(var ai = 0; ai < signer.authenticatedAttributes.length; ++ai){\n                    var attr = signer.authenticatedAttributes[ai];\n                    if (attr.type === forge.pki.oids.messageDigest) {\n                        // use content message digest as value\n                        attr.value = mds[signer.digestAlgorithm].digest();\n                    } else if (attr.type === forge.pki.oids.signingTime) {\n                        // auto-populate signing time if not already set\n                        if (!attr.value) {\n                            attr.value = signingTime;\n                        }\n                    }\n                    // convert to ASN.1 and push onto Attributes SET (for signing) and\n                    // onto authenticatedAttributesAsn1 to complete SignedData ASN.1\n                    // TODO: optimize away duplication\n                    attrsAsn1.value.push(_attributeToAsn1(attr));\n                    signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));\n                }\n                // DER-serialize and digest SET OF attributes only\n                bytes = asn1.toDer(attrsAsn1).getBytes();\n                signer.md.start().update(bytes);\n            }\n            // sign digest\n            signer.signature = signer.key.sign(signer.md, \"RSASSA-PKCS1-V1_5\");\n        }\n        // add signer info\n        msg.signerInfos = _signersToAsn1(msg.signers);\n    }\n};\n/**\n * Creates an empty PKCS#7 message of type EncryptedData.\n *\n * @return the message.\n */ p7.createEncryptedData = function() {\n    var msg = null;\n    msg = {\n        type: forge.pki.oids.encryptedData,\n        version: 0,\n        encryptedContent: {\n            algorithm: forge.pki.oids[\"aes256-CBC\"]\n        },\n        /**\n     * Reads an EncryptedData content block (in ASN.1 format)\n     *\n     * @param obj The ASN.1 representation of the EncryptedData content block\n     */ fromAsn1: function(obj) {\n            // Validate EncryptedData content block and capture data.\n            _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);\n        },\n        /**\n     * Decrypt encrypted content\n     *\n     * @param key The (symmetric) key as a byte buffer\n     */ decrypt: function(key) {\n            if (key !== undefined) {\n                msg.encryptedContent.key = key;\n            }\n            _decryptContent(msg);\n        }\n    };\n    return msg;\n};\n/**\n * Creates an empty PKCS#7 message of type EnvelopedData.\n *\n * @return the message.\n */ p7.createEnvelopedData = function() {\n    var msg = null;\n    msg = {\n        type: forge.pki.oids.envelopedData,\n        version: 0,\n        recipients: [],\n        encryptedContent: {\n            algorithm: forge.pki.oids[\"aes256-CBC\"]\n        },\n        /**\n     * Reads an EnvelopedData content block (in ASN.1 format)\n     *\n     * @param obj the ASN.1 representation of the EnvelopedData content block.\n     */ fromAsn1: function(obj) {\n            // validate EnvelopedData content block and capture data\n            var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);\n            msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);\n        },\n        toAsn1: function() {\n            // ContentInfo\n            return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                // ContentType\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()),\n                // [0] EnvelopedData\n                asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                        // Version\n                        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()),\n                        // RecipientInfos\n                        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, _recipientsToAsn1(msg.recipients)),\n                        // EncryptedContentInfo\n                        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, _encryptedContentToAsn1(msg.encryptedContent))\n                    ])\n                ])\n            ]);\n        },\n        /**\n     * Find recipient by X.509 certificate's issuer.\n     *\n     * @param cert the certificate with the issuer to look for.\n     *\n     * @return the recipient object.\n     */ findRecipient: function(cert) {\n            var sAttr = cert.issuer.attributes;\n            for(var i = 0; i < msg.recipients.length; ++i){\n                var r = msg.recipients[i];\n                var rAttr = r.issuer;\n                if (r.serialNumber !== cert.serialNumber) {\n                    continue;\n                }\n                if (rAttr.length !== sAttr.length) {\n                    continue;\n                }\n                var match = true;\n                for(var j = 0; j < sAttr.length; ++j){\n                    if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {\n                        match = false;\n                        break;\n                    }\n                }\n                if (match) {\n                    return r;\n                }\n            }\n            return null;\n        },\n        /**\n     * Decrypt enveloped content\n     *\n     * @param recipient The recipient object related to the private key\n     * @param privKey The (RSA) private key object\n     */ decrypt: function(recipient, privKey) {\n            if (msg.encryptedContent.key === undefined && recipient !== undefined && privKey !== undefined) {\n                switch(recipient.encryptedContent.algorithm){\n                    case forge.pki.oids.rsaEncryption:\n                    case forge.pki.oids.desCBC:\n                        var key = privKey.decrypt(recipient.encryptedContent.content);\n                        msg.encryptedContent.key = forge.util.createBuffer(key);\n                        break;\n                    default:\n                        throw new Error(\"Unsupported asymmetric cipher, \" + \"OID \" + recipient.encryptedContent.algorithm);\n                }\n            }\n            _decryptContent(msg);\n        },\n        /**\n     * Add (another) entity to list of recipients.\n     *\n     * @param cert The certificate of the entity to add.\n     */ addRecipient: function(cert) {\n            msg.recipients.push({\n                version: 0,\n                issuer: cert.issuer.attributes,\n                serialNumber: cert.serialNumber,\n                encryptedContent: {\n                    // We simply assume rsaEncryption here, since forge.pki only\n                    // supports RSA so far.  If the PKI module supports other\n                    // ciphers one day, we need to modify this one as well.\n                    algorithm: forge.pki.oids.rsaEncryption,\n                    key: cert.publicKey\n                }\n            });\n        },\n        /**\n     * Encrypt enveloped content.\n     *\n     * This function supports two optional arguments, cipher and key, which\n     * can be used to influence symmetric encryption.  Unless cipher is\n     * provided, the cipher specified in encryptedContent.algorithm is used\n     * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key\n     * is (re-)used.  If that one's not set, a random key will be generated\n     * automatically.\n     *\n     * @param [key] The key to be used for symmetric encryption.\n     * @param [cipher] The OID of the symmetric cipher to use.\n     */ encrypt: function(key, cipher) {\n            // Part 1: Symmetric encryption\n            if (msg.encryptedContent.content === undefined) {\n                cipher = cipher || msg.encryptedContent.algorithm;\n                key = key || msg.encryptedContent.key;\n                var keyLen, ivLen, ciphFn;\n                switch(cipher){\n                    case forge.pki.oids[\"aes128-CBC\"]:\n                        keyLen = 16;\n                        ivLen = 16;\n                        ciphFn = forge.aes.createEncryptionCipher;\n                        break;\n                    case forge.pki.oids[\"aes192-CBC\"]:\n                        keyLen = 24;\n                        ivLen = 16;\n                        ciphFn = forge.aes.createEncryptionCipher;\n                        break;\n                    case forge.pki.oids[\"aes256-CBC\"]:\n                        keyLen = 32;\n                        ivLen = 16;\n                        ciphFn = forge.aes.createEncryptionCipher;\n                        break;\n                    case forge.pki.oids[\"des-EDE3-CBC\"]:\n                        keyLen = 24;\n                        ivLen = 8;\n                        ciphFn = forge.des.createEncryptionCipher;\n                        break;\n                    default:\n                        throw new Error(\"Unsupported symmetric cipher, OID \" + cipher);\n                }\n                if (key === undefined) {\n                    key = forge.util.createBuffer(forge.random.getBytes(keyLen));\n                } else if (key.length() != keyLen) {\n                    throw new Error(\"Symmetric key has wrong length; \" + \"got \" + key.length() + \" bytes, expected \" + keyLen + \".\");\n                }\n                // Keep a copy of the key & IV in the object, so the caller can\n                // use it for whatever reason.\n                msg.encryptedContent.algorithm = cipher;\n                msg.encryptedContent.key = key;\n                msg.encryptedContent.parameter = forge.util.createBuffer(forge.random.getBytes(ivLen));\n                var ciph = ciphFn(key);\n                ciph.start(msg.encryptedContent.parameter.copy());\n                ciph.update(msg.content);\n                // The finish function does PKCS#7 padding by default, therefore\n                // no action required by us.\n                if (!ciph.finish()) {\n                    throw new Error(\"Symmetric encryption failed.\");\n                }\n                msg.encryptedContent.content = ciph.output;\n            }\n            // Part 2: asymmetric encryption for each recipient\n            for(var i = 0; i < msg.recipients.length; ++i){\n                var recipient = msg.recipients[i];\n                // Nothing to do, encryption already done.\n                if (recipient.encryptedContent.content !== undefined) {\n                    continue;\n                }\n                switch(recipient.encryptedContent.algorithm){\n                    case forge.pki.oids.rsaEncryption:\n                        recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(msg.encryptedContent.key.data);\n                        break;\n                    default:\n                        throw new Error(\"Unsupported asymmetric cipher, OID \" + recipient.encryptedContent.algorithm);\n                }\n            }\n        }\n    };\n    return msg;\n};\n/**\n * Converts a single recipient from an ASN.1 object.\n *\n * @param obj the ASN.1 RecipientInfo.\n *\n * @return the recipient object.\n */ function _recipientFromAsn1(obj) {\n    // validate EnvelopedData content block and capture data\n    var capture = {};\n    var errors = [];\n    if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {\n        var error = new Error(\"Cannot read PKCS#7 RecipientInfo. \" + \"ASN.1 object is not an PKCS#7 RecipientInfo.\");\n        error.errors = errors;\n        throw error;\n    }\n    return {\n        version: capture.version.charCodeAt(0),\n        issuer: forge.pki.RDNAttributesAsArray(capture.issuer),\n        serialNumber: forge.util.createBuffer(capture.serial).toHex(),\n        encryptedContent: {\n            algorithm: asn1.derToOid(capture.encAlgorithm),\n            parameter: capture.encParameter ? capture.encParameter.value : undefined,\n            content: capture.encKey\n        }\n    };\n}\n/**\n * Converts a single recipient object to an ASN.1 object.\n *\n * @param obj the recipient object.\n *\n * @return the ASN.1 RecipientInfo.\n */ function _recipientToAsn1(obj) {\n    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // Version\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()),\n        // IssuerAndSerialNumber\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // Name\n            forge.pki.distinguishedNameToAsn1({\n                attributes: obj.issuer\n            }),\n            // Serial\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))\n        ]),\n        // KeyEncryptionAlgorithmIdentifier\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // Algorithm\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()),\n            // Parameter, force NULL, only RSA supported for now.\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n        ]),\n        // EncryptedKey\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.encryptedContent.content)\n    ]);\n}\n/**\n * Map a set of RecipientInfo ASN.1 objects to recipient objects.\n *\n * @param infos an array of ASN.1 representations RecipientInfo (i.e. SET OF).\n *\n * @return an array of recipient objects.\n */ function _recipientsFromAsn1(infos) {\n    var ret = [];\n    for(var i = 0; i < infos.length; ++i){\n        ret.push(_recipientFromAsn1(infos[i]));\n    }\n    return ret;\n}\n/**\n * Map an array of recipient objects to ASN.1 RecipientInfo objects.\n *\n * @param recipients an array of recipientInfo objects.\n *\n * @return an array of ASN.1 RecipientInfos.\n */ function _recipientsToAsn1(recipients) {\n    var ret = [];\n    for(var i = 0; i < recipients.length; ++i){\n        ret.push(_recipientToAsn1(recipients[i]));\n    }\n    return ret;\n}\n/**\n * Converts a single signer from an ASN.1 object.\n *\n * @param obj the ASN.1 representation of a SignerInfo.\n *\n * @return the signer object.\n */ function _signerFromAsn1(obj) {\n    // validate EnvelopedData content block and capture data\n    var capture = {};\n    var errors = [];\n    if (!asn1.validate(obj, p7.asn1.signerInfoValidator, capture, errors)) {\n        var error = new Error(\"Cannot read PKCS#7 SignerInfo. \" + \"ASN.1 object is not an PKCS#7 SignerInfo.\");\n        error.errors = errors;\n        throw error;\n    }\n    var rval = {\n        version: capture.version.charCodeAt(0),\n        issuer: forge.pki.RDNAttributesAsArray(capture.issuer),\n        serialNumber: forge.util.createBuffer(capture.serial).toHex(),\n        digestAlgorithm: asn1.derToOid(capture.digestAlgorithm),\n        signatureAlgorithm: asn1.derToOid(capture.signatureAlgorithm),\n        signature: capture.signature,\n        authenticatedAttributes: [],\n        unauthenticatedAttributes: []\n    };\n    // TODO: convert attributes\n    var authenticatedAttributes = capture.authenticatedAttributes || [];\n    var unauthenticatedAttributes = capture.unauthenticatedAttributes || [];\n    return rval;\n}\n/**\n * Converts a single signerInfo object to an ASN.1 object.\n *\n * @param obj the signerInfo object.\n *\n * @return the ASN.1 representation of a SignerInfo.\n */ function _signerToAsn1(obj) {\n    // SignerInfo\n    var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // version\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()),\n        // issuerAndSerialNumber\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // name\n            forge.pki.distinguishedNameToAsn1({\n                attributes: obj.issuer\n            }),\n            // serial\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))\n        ]),\n        // digestAlgorithm\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // algorithm\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.digestAlgorithm).getBytes()),\n            // parameters (null)\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n        ])\n    ]);\n    // authenticatedAttributes (OPTIONAL)\n    if (obj.authenticatedAttributesAsn1) {\n        // add ASN.1 previously generated during signing\n        rval.value.push(obj.authenticatedAttributesAsn1);\n    }\n    // digestEncryptionAlgorithm\n    rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // algorithm\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.signatureAlgorithm).getBytes()),\n        // parameters (null)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n    ]));\n    // encryptedDigest\n    rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.signature));\n    // unauthenticatedAttributes (OPTIONAL)\n    if (obj.unauthenticatedAttributes.length > 0) {\n        // [1] IMPLICIT\n        var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);\n        for(var i = 0; i < obj.unauthenticatedAttributes.length; ++i){\n            var attr = obj.unauthenticatedAttributes[i];\n            attrsAsn1.values.push(_attributeToAsn1(attr));\n        }\n        rval.value.push(attrsAsn1);\n    }\n    return rval;\n}\n/**\n * Map a set of SignerInfo ASN.1 objects to an array of signer objects.\n *\n * @param signerInfoAsn1s an array of ASN.1 SignerInfos (i.e. SET OF).\n *\n * @return an array of signers objects.\n */ function _signersFromAsn1(signerInfoAsn1s) {\n    var ret = [];\n    for(var i = 0; i < signerInfoAsn1s.length; ++i){\n        ret.push(_signerFromAsn1(signerInfoAsn1s[i]));\n    }\n    return ret;\n}\n/**\n * Map an array of signer objects to ASN.1 objects.\n *\n * @param signers an array of signer objects.\n *\n * @return an array of ASN.1 SignerInfos.\n */ function _signersToAsn1(signers) {\n    var ret = [];\n    for(var i = 0; i < signers.length; ++i){\n        ret.push(_signerToAsn1(signers[i]));\n    }\n    return ret;\n}\n/**\n * Convert an attribute object to an ASN.1 Attribute.\n *\n * @param attr the attribute object.\n *\n * @return the ASN.1 Attribute.\n */ function _attributeToAsn1(attr) {\n    var value;\n    // TODO: generalize to support more attributes\n    if (attr.type === forge.pki.oids.contentType) {\n        value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.value).getBytes());\n    } else if (attr.type === forge.pki.oids.messageDigest) {\n        value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, attr.value.bytes());\n    } else if (attr.type === forge.pki.oids.signingTime) {\n        /* Note per RFC 2985: Dates between 1 January 1950 and 31 December 2049\n      (inclusive) MUST be encoded as UTCTime. Any dates with year values\n      before 1950 or after 2049 MUST be encoded as GeneralizedTime. [Further,]\n      UTCTime values MUST be expressed in Greenwich Mean Time (Zulu) and MUST\n      include seconds (i.e., times are YYMMDDHHMMSSZ), even where the\n      number of seconds is zero.  Midnight (GMT) must be represented as\n      \"YYMMDD000000Z\". */ // TODO: make these module-level constants\n        var jan_1_1950 = new Date(\"1950-01-01T00:00:00Z\");\n        var jan_1_2050 = new Date(\"2050-01-01T00:00:00Z\");\n        var date = attr.value;\n        if (typeof date === \"string\") {\n            // try to parse date\n            var timestamp = Date.parse(date);\n            if (!isNaN(timestamp)) {\n                date = new Date(timestamp);\n            } else if (date.length === 13) {\n                // YYMMDDHHMMSSZ (13 chars for UTCTime)\n                date = asn1.utcTimeToDate(date);\n            } else {\n                // assume generalized time\n                date = asn1.generalizedTimeToDate(date);\n            }\n        }\n        if (date >= jan_1_1950 && date < jan_1_2050) {\n            value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));\n        } else {\n            value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));\n        }\n    }\n    // TODO: expose as common API call\n    // create a RelativeDistinguishedName set\n    // each value in the set is an AttributeTypeAndValue first\n    // containing the type (an OID) and second the value\n    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // AttributeType\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\n            // AttributeValue\n            value\n        ])\n    ]);\n}\n/**\n * Map messages encrypted content to ASN.1 objects.\n *\n * @param ec The encryptedContent object of the message.\n *\n * @return ASN.1 representation of the encryptedContent object (SEQUENCE).\n */ function _encryptedContentToAsn1(ec) {\n    return [\n        // ContentType, always Data for the moment\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes()),\n        // ContentEncryptionAlgorithmIdentifier\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // Algorithm\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ec.algorithm).getBytes()),\n            // Parameters (IV)\n            !ec.parameter ? undefined : asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.parameter.getBytes())\n        ]),\n        // [0] EncryptedContent\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.content.getBytes())\n        ])\n    ];\n}\n/**\n * Reads the \"common part\" of an PKCS#7 content block (in ASN.1 format)\n *\n * This function reads the \"common part\" of the PKCS#7 content blocks\n * EncryptedData and EnvelopedData, i.e. version number and symmetrically\n * encrypted content block.\n *\n * The result of the ASN.1 validate and capture process is returned\n * to allow the caller to extract further data, e.g. the list of recipients\n * in case of a EnvelopedData object.\n *\n * @param msg the PKCS#7 object to read the data to.\n * @param obj the ASN.1 representation of the content block.\n * @param validator the ASN.1 structure validator object to use.\n *\n * @return the value map captured by validator object.\n */ function _fromAsn1(msg, obj, validator) {\n    var capture = {};\n    var errors = [];\n    if (!asn1.validate(obj, validator, capture, errors)) {\n        var error = new Error(\"Cannot read PKCS#7 message. \" + \"ASN.1 object is not a supported PKCS#7 message.\");\n        error.errors = error;\n        throw error;\n    }\n    // Check contentType, so far we only support (raw) Data.\n    var contentType = asn1.derToOid(capture.contentType);\n    if (contentType !== forge.pki.oids.data) {\n        throw new Error(\"Unsupported PKCS#7 message. \" + \"Only wrapped ContentType Data supported.\");\n    }\n    if (capture.encryptedContent) {\n        var content = \"\";\n        if (forge.util.isArray(capture.encryptedContent)) {\n            for(var i = 0; i < capture.encryptedContent.length; ++i){\n                if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {\n                    throw new Error(\"Malformed PKCS#7 message, expecting encrypted \" + \"content constructed of only OCTET STRING objects.\");\n                }\n                content += capture.encryptedContent[i].value;\n            }\n        } else {\n            content = capture.encryptedContent;\n        }\n        msg.encryptedContent = {\n            algorithm: asn1.derToOid(capture.encAlgorithm),\n            parameter: forge.util.createBuffer(capture.encParameter.value),\n            content: forge.util.createBuffer(content)\n        };\n    }\n    if (capture.content) {\n        var content = \"\";\n        if (forge.util.isArray(capture.content)) {\n            for(var i = 0; i < capture.content.length; ++i){\n                if (capture.content[i].type !== asn1.Type.OCTETSTRING) {\n                    throw new Error(\"Malformed PKCS#7 message, expecting \" + \"content constructed of only OCTET STRING objects.\");\n                }\n                content += capture.content[i].value;\n            }\n        } else {\n            content = capture.content;\n        }\n        msg.content = forge.util.createBuffer(content);\n    }\n    msg.version = capture.version.charCodeAt(0);\n    msg.rawCapture = capture;\n    return capture;\n}\n/**\n * Decrypt the symmetrically encrypted content block of the PKCS#7 message.\n *\n * Decryption is skipped in case the PKCS#7 message object already has a\n * (decrypted) content attribute.  The algorithm, key and cipher parameters\n * (probably the iv) are taken from the encryptedContent attribute of the\n * message object.\n *\n * @param The PKCS#7 message object.\n */ function _decryptContent(msg) {\n    if (msg.encryptedContent.key === undefined) {\n        throw new Error(\"Symmetric key not available.\");\n    }\n    if (msg.content === undefined) {\n        var ciph;\n        switch(msg.encryptedContent.algorithm){\n            case forge.pki.oids[\"aes128-CBC\"]:\n            case forge.pki.oids[\"aes192-CBC\"]:\n            case forge.pki.oids[\"aes256-CBC\"]:\n                ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);\n                break;\n            case forge.pki.oids[\"desCBC\"]:\n            case forge.pki.oids[\"des-EDE3-CBC\"]:\n                ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);\n                break;\n            default:\n                throw new Error(\"Unsupported symmetric cipher, OID \" + msg.encryptedContent.algorithm);\n        }\n        ciph.start(msg.encryptedContent.parameter);\n        ciph.update(msg.encryptedContent.content);\n        if (!ciph.finish()) {\n            throw new Error(\"Symmetric decryption failed.\");\n        }\n        msg.content = ciph.output;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGtjczcuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVIseUJBQXlCO0FBQ3pCLElBQUlDLE9BQU9GLE1BQU1FLElBQUk7QUFFckIsMEJBQTBCO0FBQzFCLElBQUlDLEtBQUtDLE9BQU9DLE9BQU8sR0FBR0wsTUFBTU0sS0FBSyxHQUFHTixNQUFNTSxLQUFLLElBQUksQ0FBQztBQUV4RDs7Ozs7O0NBTUMsR0FDREgsR0FBR0ksY0FBYyxHQUFHLFNBQVNDLEdBQUc7SUFDOUIsSUFBSUMsTUFBTVQsTUFBTVEsR0FBRyxDQUFDRSxNQUFNLENBQUNGLElBQUksQ0FBQyxFQUFFO0lBRWxDLElBQUdDLElBQUlFLElBQUksS0FBSyxTQUFTO1FBQ3ZCLElBQUlDLFFBQVEsSUFBSUMsTUFBTSxvREFDcEI7UUFDRkQsTUFBTUUsVUFBVSxHQUFHTCxJQUFJRSxJQUFJO1FBQzNCLE1BQU1DO0lBQ1I7SUFDQSxJQUFHSCxJQUFJTSxRQUFRLElBQUlOLElBQUlNLFFBQVEsQ0FBQ0osSUFBSSxLQUFLLGFBQWE7UUFDcEQsTUFBTSxJQUFJRSxNQUFNO0lBQ2xCO0lBRUEsOEJBQThCO0lBQzlCLElBQUlHLE1BQU1kLEtBQUtlLE9BQU8sQ0FBQ1IsSUFBSVMsSUFBSTtJQUUvQixPQUFPZixHQUFHZ0IsZUFBZSxDQUFDSDtBQUM1QjtBQUVBOzs7Ozs7O0NBT0MsR0FDRGIsR0FBR2lCLFlBQVksR0FBRyxTQUFTWCxHQUFHLEVBQUVZLE9BQU87SUFD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cy9ub2RlLWZvcmdlL2xpYi9wa2NzNy5qcz82MzVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBQS0NTIzcgdjEuNS5cbiAqXG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKlxuICogQ3VycmVudGx5IHRoaXMgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBDb250ZW50VHlwZSBvZiBFbnZlbG9wZWREYXRhLFxuICogRW5jcnlwdGVkRGF0YSwgb3IgU2lnbmVkRGF0YSBhdCB0aGUgcm9vdCBsZXZlbC4gVGhlIHRvcCBsZXZlbCBlbGVtZW50cyBtYXlcbiAqIGNvbnRhaW4gb25seSBhIENvbnRlbnRJbmZvIG9mIENvbnRlbnRUeXBlIERhdGEsIGkuZS4gcGxhaW4gZGF0YS4gRnVydGhlclxuICogbmVzdGluZyBpcyBub3QgKHlldCkgc3VwcG9ydGVkLlxuICpcbiAqIFRoZSBGb3JnZSB2YWxpZGF0b3JzIGZvciBQS0NTICM3J3MgQVNOLjEgc3RydWN0dXJlcyBhcmUgYXZhaWxhYmxlIGZyb21cbiAqIGEgc2VwYXJhdGUgZmlsZSBwa2NzN2FzbjEuanMsIHNpbmNlIHRob3NlIGFyZSByZWZlcmVuY2VkIGZyb20gb3RoZXJcbiAqIFBLQ1Mgc3RhbmRhcmRzIGxpa2UgUEtDUyAjMTIuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vYWVzJyk7XG5yZXF1aXJlKCcuL2FzbjEnKTtcbnJlcXVpcmUoJy4vZGVzJyk7XG5yZXF1aXJlKCcuL29pZHMnKTtcbnJlcXVpcmUoJy4vcGVtJyk7XG5yZXF1aXJlKCcuL3BrY3M3YXNuMScpO1xucmVxdWlyZSgnLi9yYW5kb20nKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xucmVxdWlyZSgnLi94NTA5Jyk7XG5cbi8vIHNob3J0Y3V0IGZvciBBU04uMSBBUElcbnZhciBhc24xID0gZm9yZ2UuYXNuMTtcblxuLy8gc2hvcnRjdXQgZm9yIFBLQ1MjNyBBUElcbnZhciBwNyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtjczcgPSBmb3JnZS5wa2NzNyB8fCB7fTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFBLQ1MjNyBtZXNzYWdlIGZyb20gUEVNIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gcGVtIHRoZSBQRU0tZm9ybWF0dGVkIFBLQ1MjNyBtZXNzYWdlLlxuICpcbiAqIEByZXR1cm4gdGhlIFBLQ1MjNyBtZXNzYWdlLlxuICovXG5wNy5tZXNzYWdlRnJvbVBlbSA9IGZ1bmN0aW9uKHBlbSkge1xuICB2YXIgbXNnID0gZm9yZ2UucGVtLmRlY29kZShwZW0pWzBdO1xuXG4gIGlmKG1zZy50eXBlICE9PSAnUEtDUzcnKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBQS0NTIzcgbWVzc2FnZSBmcm9tIFBFTTsgUEVNICcgK1xuICAgICAgJ2hlYWRlciB0eXBlIGlzIG5vdCBcIlBLQ1MjN1wiLicpO1xuICAgIGVycm9yLmhlYWRlclR5cGUgPSBtc2cudHlwZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBQS0NTIzcgbWVzc2FnZSBmcm9tIFBFTTsgUEVNIGlzIGVuY3J5cHRlZC4nKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgREVSIHRvIEFTTi4xIG9iamVjdFxuICB2YXIgb2JqID0gYXNuMS5mcm9tRGVyKG1zZy5ib2R5KTtcblxuICByZXR1cm4gcDcubWVzc2FnZUZyb21Bc24xKG9iaik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUEtDUyM3IG1lc3NhZ2UgdG8gUEVNIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gbXNnIFRoZSBQS0NTIzcgbWVzc2FnZSBvYmplY3RcbiAqIEBwYXJhbSBtYXhsaW5lIFRoZSBtYXhpbXVtIGNoYXJhY3RlcnMgcGVyIGxpbmUsIGRlZmF1bHRzIHRvIDY0LlxuICpcbiAqIEByZXR1cm4gVGhlIFBFTS1mb3JtYXR0ZWQgUEtDUyM3IG1lc3NhZ2UuXG4gKi9cbnA3Lm1lc3NhZ2VUb1BlbSA9IGZ1bmN0aW9uKG1zZywgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIEFTTi4xLCB0aGVuIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBwZW1PYmogPSB7XG4gICAgdHlwZTogJ1BLQ1M3JyxcbiAgICBib2R5OiBhc24xLnRvRGVyKG1zZy50b0FzbjEoKSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShwZW1PYmosIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUEtDUyM3IG1lc3NhZ2UgZnJvbSBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgYSBDb250ZW50SW5mby5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQS0NTIzcgbWVzc2FnZS5cbiAqL1xucDcubWVzc2FnZUZyb21Bc24xID0gZnVuY3Rpb24ob2JqKSB7XG4gIC8vIHZhbGlkYXRlIHJvb3QgbGV2ZWwgQ29udGVudEluZm8gYW5kIGNhcHR1cmUgZGF0YVxuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKG9iaiwgcDcuYXNuMS5jb250ZW50SW5mb1ZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgUEtDUyM3IG1lc3NhZ2UuICcgK1xuICAgICAgJ0FTTi4xIG9iamVjdCBpcyBub3QgYW4gUEtDUyM3IENvbnRlbnRJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBjb250ZW50VHlwZSA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jb250ZW50VHlwZSk7XG4gIHZhciBtc2c7XG5cbiAgc3dpdGNoKGNvbnRlbnRUeXBlKSB7XG4gICAgY2FzZSBmb3JnZS5wa2kub2lkcy5lbnZlbG9wZWREYXRhOlxuICAgICAgbXNnID0gcDcuY3JlYXRlRW52ZWxvcGVkRGF0YSgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGZvcmdlLnBraS5vaWRzLmVuY3J5cHRlZERhdGE6XG4gICAgICBtc2cgPSBwNy5jcmVhdGVFbmNyeXB0ZWREYXRhKCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgZm9yZ2UucGtpLm9pZHMuc2lnbmVkRGF0YTpcbiAgICAgIG1zZyA9IHA3LmNyZWF0ZVNpZ25lZERhdGEoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgUEtDUyM3IG1lc3NhZ2UuIENvbnRlbnRUeXBlIHdpdGggT0lEICcgK1xuICAgICAgICBjb250ZW50VHlwZSArICcgaXMgbm90ICh5ZXQpIHN1cHBvcnRlZC4nKTtcbiAgfVxuXG4gIG1zZy5mcm9tQXNuMShjYXB0dXJlLmNvbnRlbnQudmFsdWVbMF0pO1xuICByZXR1cm4gbXNnO1xufTtcblxucDcuY3JlYXRlU2lnbmVkRGF0YSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbXNnID0gbnVsbDtcbiAgbXNnID0ge1xuICAgIHR5cGU6IGZvcmdlLnBraS5vaWRzLnNpZ25lZERhdGEsXG4gICAgdmVyc2lvbjogMSxcbiAgICBjZXJ0aWZpY2F0ZXM6IFtdLFxuICAgIGNybHM6IFtdLFxuICAgIC8vIFRPRE86IGFkZCBqc29uLWZvcm1hdHRlZCBzaWduZXIgc3R1ZmYgaGVyZT9cbiAgICBzaWduZXJzOiBbXSxcbiAgICAvLyBwb3B1bGF0ZWQgZHVyaW5nIHNpZ24oKVxuICAgIGRpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXJzOiBbXSxcbiAgICBjb250ZW50SW5mbzogbnVsbCxcbiAgICBzaWduZXJJbmZvczogW10sXG5cbiAgICBmcm9tQXNuMTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAvLyB2YWxpZGF0ZSBTaWduZWREYXRhIGNvbnRlbnQgYmxvY2sgYW5kIGNhcHR1cmUgZGF0YS5cbiAgICAgIF9mcm9tQXNuMShtc2csIG9iaiwgcDcuYXNuMS5zaWduZWREYXRhVmFsaWRhdG9yKTtcbiAgICAgIG1zZy5jZXJ0aWZpY2F0ZXMgPSBbXTtcbiAgICAgIG1zZy5jcmxzID0gW107XG4gICAgICBtc2cuZGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcnMgPSBbXTtcbiAgICAgIG1zZy5jb250ZW50SW5mbyA9IG51bGw7XG4gICAgICBtc2cuc2lnbmVySW5mb3MgPSBbXTtcblxuICAgICAgaWYobXNnLnJhd0NhcHR1cmUuY2VydGlmaWNhdGVzKSB7XG4gICAgICAgIHZhciBjZXJ0cyA9IG1zZy5yYXdDYXB0dXJlLmNlcnRpZmljYXRlcy52YWx1ZTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNlcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgbXNnLmNlcnRpZmljYXRlcy5wdXNoKGZvcmdlLnBraS5jZXJ0aWZpY2F0ZUZyb21Bc24xKGNlcnRzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogcGFyc2UgY3Jsc1xuICAgIH0sXG5cbiAgICB0b0FzbjE6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gZGVnZW5lcmF0ZSBjYXNlIHdpdGggbm8gY29udGVudFxuICAgICAgaWYoIW1zZy5jb250ZW50SW5mbykge1xuICAgICAgICBtc2cuc2lnbigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2VydHMgPSBbXTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtc2cuY2VydGlmaWNhdGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNlcnRzLnB1c2goZm9yZ2UucGtpLmNlcnRpZmljYXRlVG9Bc24xKG1zZy5jZXJ0aWZpY2F0ZXNbaV0pKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNybHMgPSBbXTtcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCBDUkxzXG5cbiAgICAgIC8vIFswXSBTaWduZWREYXRhXG4gICAgICB2YXIgc2lnbmVkRGF0YSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW1xuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgLy8gVmVyc2lvblxuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICAgICAgICBhc24xLmludGVnZXJUb0Rlcihtc2cudmVyc2lvbikuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgLy8gRGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcnNcbiAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLFxuICAgICAgICAgICAgbXNnLmRpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXJzKSxcbiAgICAgICAgICAvLyBDb250ZW50SW5mb1xuICAgICAgICAgIG1zZy5jb250ZW50SW5mb1xuICAgICAgICBdKVxuICAgICAgXSk7XG4gICAgICBpZihjZXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIFswXSBJTVBMSUNJVCBFeHRlbmRlZENlcnRpZmljYXRlc0FuZENlcnRpZmljYXRlcyBPUFRJT05BTFxuICAgICAgICBzaWduZWREYXRhLnZhbHVlWzBdLnZhbHVlLnB1c2goXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBjZXJ0cykpO1xuICAgICAgfVxuICAgICAgaWYoY3Jscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIFsxXSBJTVBMSUNJVCBDZXJ0aWZpY2F0ZVJldm9jYXRpb25MaXN0cyBPUFRJT05BTFxuICAgICAgICBzaWduZWREYXRhLnZhbHVlWzBdLnZhbHVlLnB1c2goXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAxLCB0cnVlLCBjcmxzKSk7XG4gICAgICB9XG4gICAgICAvLyBTaWduZXJJbmZvc1xuICAgICAgc2lnbmVkRGF0YS52YWx1ZVswXS52YWx1ZS5wdXNoKFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFVCwgdHJ1ZSxcbiAgICAgICAgICBtc2cuc2lnbmVySW5mb3MpKTtcblxuICAgICAgLy8gQ29udGVudEluZm9cbiAgICAgIHJldHVybiBhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIC8vIENvbnRlbnRUeXBlXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5vaWRUb0Rlcihtc2cudHlwZSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgLy8gWzBdIFNpZ25lZERhdGFcbiAgICAgICAgICBzaWduZWREYXRhXG4gICAgICAgIF0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgKGFub3RoZXIpIGVudGl0eSB0byBsaXN0IG9mIHNpZ25lcnMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJZiBhdXRoZW50aWNhdGVkQXR0cmlidXRlcyBhcmUgcHJvdmlkZWQsIHRoZW4sIHBlciBSRkMgMjMxNSxcbiAgICAgKiB0aGV5IG11c3QgaW5jbHVkZSBhdCBsZWFzdCB0d28gYXR0cmlidXRlczogY29udGVudCB0eXBlIGFuZFxuICAgICAqIG1lc3NhZ2UgZGlnZXN0LiBUaGUgbWVzc2FnZSBkaWdlc3QgYXR0cmlidXRlIHZhbHVlIHdpbGwgYmVcbiAgICAgKiBhdXRvLWNhbGN1bGF0ZWQgZHVyaW5nIHNpZ25pbmcgYW5kIHdpbGwgYmUgaWdub3JlZCBpZiBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEhlcmUncyBhbiBleGFtcGxlIG9mIHByb3ZpZGluZyB0aGVzZSB0d28gYXR0cmlidXRlczpcbiAgICAgKlxuICAgICAqIGZvcmdlLnBrY3M3LmNyZWF0ZVNpZ25lZERhdGEoKTtcbiAgICAgKiBwNy5hZGRTaWduZXIoe1xuICAgICAqICAgaXNzdWVyOiBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzLFxuICAgICAqICAgc2VyaWFsTnVtYmVyOiBjZXJ0LnNlcmlhbE51bWJlcixcbiAgICAgKiAgIGtleTogcHJpdmF0ZUtleSxcbiAgICAgKiAgIGRpZ2VzdEFsZ29yaXRobTogZm9yZ2UucGtpLm9pZHMuc2hhMSxcbiAgICAgKiAgIGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzOiBbe1xuICAgICAqICAgICB0eXBlOiBmb3JnZS5wa2kub2lkcy5jb250ZW50VHlwZSxcbiAgICAgKiAgICAgdmFsdWU6IGZvcmdlLnBraS5vaWRzLmRhdGFcbiAgICAgKiAgIH0sIHtcbiAgICAgKiAgICAgdHlwZTogZm9yZ2UucGtpLm9pZHMubWVzc2FnZURpZ2VzdFxuICAgICAqICAgfV1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIFRPRE86IFN1cHBvcnQgW3N1YmplY3RLZXlJZGVudGlmaWVyXSBhcyBzaWduZXIncyBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaWduZXIgdGhlIHNpZ25lciBpbmZvcm1hdGlvbjpcbiAgICAgKiAgICAgICAgICBrZXkgdGhlIHNpZ25lcidzIHByaXZhdGUga2V5LlxuICAgICAqICAgICAgICAgIFtjZXJ0aWZpY2F0ZV0gYSBjZXJ0aWZpY2F0ZSBjb250YWluaW5nIHRoZSBwdWJsaWMga2V5XG4gICAgICogICAgICAgICAgICBhc3NvY2lhdGVkIHdpdGggdGhlIHNpZ25lcidzIHByaXZhdGUga2V5OyB1c2UgdGhpcyBvcHRpb24gYXNcbiAgICAgKiAgICAgICAgICAgIGFuIGFsdGVybmF0aXZlIHRvIHNwZWNpZnlpbmcgc2lnbmVyLmlzc3VlciBhbmRcbiAgICAgKiAgICAgICAgICAgIHNpZ25lci5zZXJpYWxOdW1iZXIuXG4gICAgICogICAgICAgICAgW2lzc3Vlcl0gdGhlIGlzc3VlciBhdHRyaWJ1dGVzIChlZzogY2VydC5pc3N1ZXIuYXR0cmlidXRlcykuXG4gICAgICogICAgICAgICAgW3NlcmlhbE51bWJlcl0gdGhlIHNpZ25lcidzIGNlcnRpZmljYXRlJ3Mgc2VyaWFsIG51bWJlciBpblxuICAgICAqICAgICAgICAgICBoZXhhZGVjaW1hbCAoZWc6IGNlcnQuc2VyaWFsTnVtYmVyKS5cbiAgICAgKiAgICAgICAgICBbZGlnZXN0QWxnb3JpdGhtXSB0aGUgbWVzc2FnZSBkaWdlc3QgT0lELCBhcyBhIHN0cmluZywgdG8gdXNlXG4gICAgICogICAgICAgICAgICAoZWc6IGZvcmdlLnBraS5vaWRzLnNoYTEpLlxuICAgICAqICAgICAgICAgIFthdXRoZW50aWNhdGVkQXR0cmlidXRlc10gYW4gb3B0aW9uYWwgYXJyYXkgb2YgYXR0cmlidXRlc1xuICAgICAqICAgICAgICAgICAgdG8gYWxzbyBzaWduIGFsb25nIHdpdGggdGhlIGNvbnRlbnQuXG4gICAgICovXG4gICAgYWRkU2lnbmVyOiBmdW5jdGlvbihzaWduZXIpIHtcbiAgICAgIHZhciBpc3N1ZXIgPSBzaWduZXIuaXNzdWVyO1xuICAgICAgdmFyIHNlcmlhbE51bWJlciA9IHNpZ25lci5zZXJpYWxOdW1iZXI7XG4gICAgICBpZihzaWduZXIuY2VydGlmaWNhdGUpIHtcbiAgICAgICAgdmFyIGNlcnQgPSBzaWduZXIuY2VydGlmaWNhdGU7XG4gICAgICAgIGlmKHR5cGVvZiBjZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNlcnQgPSBmb3JnZS5wa2kuY2VydGlmaWNhdGVGcm9tUGVtKGNlcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlzc3VlciA9IGNlcnQuaXNzdWVyLmF0dHJpYnV0ZXM7XG4gICAgICAgIHNlcmlhbE51bWJlciA9IGNlcnQuc2VyaWFsTnVtYmVyO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHNpZ25lci5rZXk7XG4gICAgICBpZigha2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQ291bGQgbm90IGFkZCBQS0NTIzcgc2lnbmVyOyBubyBwcml2YXRlIGtleSBzcGVjaWZpZWQuJyk7XG4gICAgICB9XG4gICAgICBpZih0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBrZXkgPSBmb3JnZS5wa2kucHJpdmF0ZUtleUZyb21QZW0oa2V5KTtcbiAgICAgIH1cblxuICAgICAgLy8gZW5zdXJlIE9JRCBrbm93biBmb3IgZGlnZXN0IGFsZ29yaXRobVxuICAgICAgdmFyIGRpZ2VzdEFsZ29yaXRobSA9IHNpZ25lci5kaWdlc3RBbGdvcml0aG0gfHwgZm9yZ2UucGtpLm9pZHMuc2hhMTtcbiAgICAgIHN3aXRjaChkaWdlc3RBbGdvcml0aG0pIHtcbiAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHMuc2hhMTpcbiAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHMuc2hhMjU2OlxuICAgICAgY2FzZSBmb3JnZS5wa2kub2lkcy5zaGEzODQ6XG4gICAgICBjYXNlIGZvcmdlLnBraS5vaWRzLnNoYTUxMjpcbiAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHMubWQ1OlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQ291bGQgbm90IGFkZCBQS0NTIzcgc2lnbmVyOyB1bmtub3duIG1lc3NhZ2UgZGlnZXN0IGFsZ29yaXRobTogJyArXG4gICAgICAgICAgZGlnZXN0QWxnb3JpdGhtKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMgaXMgcHJlc2VudCwgdGhlbiB0aGUgYXR0cmlidXRlc1xuICAgICAgLy8gbXVzdCBjb250YWluIGF0IGxlYXN0IFBLQ1MgIzkgY29udGVudC10eXBlIGFuZCBtZXNzYWdlLWRpZ2VzdFxuICAgICAgdmFyIGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzID0gc2lnbmVyLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzIHx8IFtdO1xuICAgICAgaWYoYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgY29udGVudFR5cGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIG1lc3NhZ2VEaWdlc3QgPSBmYWxzZTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGF0dHIgPSBhdXRoZW50aWNhdGVkQXR0cmlidXRlc1tpXTtcbiAgICAgICAgICBpZighY29udGVudFR5cGUgJiYgYXR0ci50eXBlID09PSBmb3JnZS5wa2kub2lkcy5jb250ZW50VHlwZSkge1xuICAgICAgICAgICAgY29udGVudFR5cGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYobWVzc2FnZURpZ2VzdCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZighbWVzc2FnZURpZ2VzdCAmJiBhdHRyLnR5cGUgPT09IGZvcmdlLnBraS5vaWRzLm1lc3NhZ2VEaWdlc3QpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VEaWdlc3QgPSB0cnVlO1xuICAgICAgICAgICAgaWYoY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZighY29udGVudFR5cGUgfHwgIW1lc3NhZ2VEaWdlc3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmVyLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzLiBJZiAnICtcbiAgICAgICAgICAgICdzaWduZXIuYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMgaXMgc3BlY2lmaWVkLCB0aGVuIGl0IG11c3QgJyArXG4gICAgICAgICAgICAnY29udGFpbiBhdCBsZWFzdCB0d28gYXR0cmlidXRlcywgUEtDUyAjOSBjb250ZW50LXR5cGUgYW5kICcgK1xuICAgICAgICAgICAgJ1BLQ1MgIzkgbWVzc2FnZS1kaWdlc3QuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbXNnLnNpZ25lcnMucHVzaCh7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICBpc3N1ZXI6IGlzc3VlcixcbiAgICAgICAgc2VyaWFsTnVtYmVyOiBzZXJpYWxOdW1iZXIsXG4gICAgICAgIGRpZ2VzdEFsZ29yaXRobTogZGlnZXN0QWxnb3JpdGhtLFxuICAgICAgICBzaWduYXR1cmVBbGdvcml0aG06IGZvcmdlLnBraS5vaWRzLnJzYUVuY3J5cHRpb24sXG4gICAgICAgIHNpZ25hdHVyZTogbnVsbCxcbiAgICAgICAgYXV0aGVudGljYXRlZEF0dHJpYnV0ZXM6IGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzLFxuICAgICAgICB1bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzOiBbXVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNpZ25zIHRoZSBjb250ZW50LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gYXBwbHkgd2hlbiBzaWduaW5nOlxuICAgICAqICAgIFtkZXRhY2hlZF0gYm9vbGVhbi4gSWYgc2lnbmluZyBzaG91bGQgYmUgZG9uZSBpbiBkZXRhY2hlZCBtb2RlLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKi9cbiAgICBzaWduOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIC8vIGF1dG8tZ2VuZXJhdGUgY29udGVudCBpbmZvXG4gICAgICBpZih0eXBlb2YgbXNnLmNvbnRlbnQgIT09ICdvYmplY3QnIHx8IG1zZy5jb250ZW50SW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAvLyB1c2UgRGF0YSBDb250ZW50SW5mb1xuICAgICAgICBtc2cuY29udGVudEluZm8gPSBhc24xLmNyZWF0ZShcbiAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICAvLyBDb250ZW50VHlwZVxuICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKGZvcmdlLnBraS5vaWRzLmRhdGEpLmdldEJ5dGVzKCkpXG4gICAgICAgICAgXSk7XG5cbiAgICAgICAgLy8gYWRkIGFjdHVhbCBjb250ZW50LCBpZiBwcmVzZW50XG4gICAgICAgIGlmKCdjb250ZW50JyBpbiBtc2cpIHtcbiAgICAgICAgICB2YXIgY29udGVudDtcbiAgICAgICAgICBpZihtc2cuY29udGVudCBpbnN0YW5jZW9mIGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcikge1xuICAgICAgICAgICAgY29udGVudCA9IG1zZy5jb250ZW50LmJ5dGVzKCk7XG4gICAgICAgICAgfSBlbHNlIGlmKHR5cGVvZiBtc2cuY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgobXNnLmNvbnRlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLmRldGFjaGVkKSB7XG4gICAgICAgICAgICBtc2cuZGV0YWNoZWRDb250ZW50ID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIGNvbnRlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtc2cuY29udGVudEluZm8udmFsdWUucHVzaChcbiAgICAgICAgICAgICAgLy8gWzBdIEVYUExJQ0lUIGNvbnRlbnRcbiAgICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsXG4gICAgICAgICAgICAgICAgICBjb250ZW50KVxuICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5vIHNpZ25lcnMsIHJldHVybiBlYXJseSAoZGVnZW5lcmF0ZSBjYXNlIGZvciBjZXJ0aWZpY2F0ZSBjb250YWluZXIpXG4gICAgICBpZihtc2cuc2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBnZW5lcmF0ZSBkaWdlc3QgYWxnb3JpdGhtIGlkZW50aWZpZXJzXG4gICAgICB2YXIgbWRzID0gYWRkRGlnZXN0QWxnb3JpdGhtSWRzKCk7XG5cbiAgICAgIC8vIGdlbmVyYXRlIHNpZ25lckluZm9zXG4gICAgICBhZGRTaWduZXJJbmZvcyhtZHMpO1xuICAgIH0sXG5cbiAgICB2ZXJpZnk6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQS0NTIzcgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBub3QgeWV0IGltcGxlbWVudGVkLicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjZXJ0aWZpY2F0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZSB0byBhZGQuXG4gICAgICovXG4gICAgYWRkQ2VydGlmaWNhdGU6IGZ1bmN0aW9uKGNlcnQpIHtcbiAgICAgIC8vIGNvbnZlcnQgZnJvbSBQRU1cbiAgICAgIGlmKHR5cGVvZiBjZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBjZXJ0ID0gZm9yZ2UucGtpLmNlcnRpZmljYXRlRnJvbVBlbShjZXJ0KTtcbiAgICAgIH1cbiAgICAgIG1zZy5jZXJ0aWZpY2F0ZXMucHVzaChjZXJ0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgY2VydGlmaWNhdGUgcmV2b2thdGlvbiBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNybCB0aGUgY2VydGlmaWNhdGUgcmV2b2thdGlvbiBsaXN0IHRvIGFkZC5cbiAgICAgKi9cbiAgICBhZGRDZXJ0aWZpY2F0ZVJldm9rYXRpb25MaXN0OiBmdW5jdGlvbihjcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUEtDUyM3IENSTCBzdXBwb3J0IG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbXNnO1xuXG4gIGZ1bmN0aW9uIGFkZERpZ2VzdEFsZ29yaXRobUlkcygpIHtcbiAgICB2YXIgbWRzID0ge307XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbXNnLnNpZ25lcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzaWduZXIgPSBtc2cuc2lnbmVyc1tpXTtcbiAgICAgIHZhciBvaWQgPSBzaWduZXIuZGlnZXN0QWxnb3JpdGhtO1xuICAgICAgaWYoIShvaWQgaW4gbWRzKSkge1xuICAgICAgICAvLyBjb250ZW50IGRpZ2VzdFxuICAgICAgICBtZHNbb2lkXSA9IGZvcmdlLm1kW2ZvcmdlLnBraS5vaWRzW29pZF1dLmNyZWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYoc2lnbmVyLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBubyBjdXN0b20gYXR0cmlidXRlcyB0byBkaWdlc3Q7IHVzZSBjb250ZW50IG1lc3NhZ2UgZGlnZXN0XG4gICAgICAgIHNpZ25lci5tZCA9IG1kc1tvaWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3VzdG9tIGF0dHJpYnV0ZXMgdG8gYmUgZGlnZXN0ZWQ7IHVzZSBvd24gbWVzc2FnZSBkaWdlc3RcbiAgICAgICAgLy8gVE9ETzogb3B0aW1pemUgdG8ganVzdCBjb3B5IG1lc3NhZ2UgZGlnZXN0IHN0YXRlIGlmIHRoYXRcbiAgICAgICAgLy8gZmVhdHVyZSBpcyBldmVyIHN1cHBvcnRlZCB3aXRoIG1lc3NhZ2UgZGlnZXN0c1xuICAgICAgICBzaWduZXIubWQgPSBmb3JnZS5tZFtmb3JnZS5wa2kub2lkc1tvaWRdXS5jcmVhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgdW5pcXVlIGRpZ2VzdCBhbGdvcml0aG0gaWRlbnRpZmllcnNcbiAgICBtc2cuZGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcnMgPSBbXTtcbiAgICBmb3IodmFyIG9pZCBpbiBtZHMpIHtcbiAgICAgIG1zZy5kaWdlc3RBbGdvcml0aG1JZGVudGlmaWVycy5wdXNoKFxuICAgICAgICAvLyBBbGdvcml0aG1JZGVudGlmaWVyXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAvLyBhbGdvcml0aG1cbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgICBhc24xLm9pZFRvRGVyKG9pZCkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgLy8gcGFyYW1ldGVycyAobnVsbClcbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICAgICAgXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBtZHM7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRTaWduZXJJbmZvcyhtZHMpIHtcbiAgICB2YXIgY29udGVudDtcblxuICAgIGlmIChtc2cuZGV0YWNoZWRDb250ZW50KSB7XG4gICAgICAvLyBTaWduYXR1cmUgaGFzIGJlZW4gbWFkZSBpbiBkZXRhY2hlZCBtb2RlLlxuICAgICAgY29udGVudCA9IG1zZy5kZXRhY2hlZENvbnRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vdGU6IENvbnRlbnRJbmZvIGlzIGEgU0VRVUVOQ0Ugd2l0aCAyIHZhbHVlcywgc2Vjb25kIHZhbHVlIGlzXG4gICAgICAvLyB0aGUgY29udGVudCBmaWVsZCBhbmQgaXMgb3B0aW9uYWwgZm9yIGEgQ29udGVudEluZm8gYnV0IHJlcXVpcmVkIGhlcmVcbiAgICAgIC8vIHNpbmNlIHNpZ25lcnMgYXJlIHByZXNlbnRcbiAgICAgIC8vIGdldCBDb250ZW50SW5mbyBjb250ZW50XG4gICAgICBjb250ZW50ID0gbXNnLmNvbnRlbnRJbmZvLnZhbHVlWzFdO1xuICAgICAgLy8gc2tpcCBbMF0gRVhQTElDSVQgY29udGVudCB3cmFwcGVyXG4gICAgICBjb250ZW50ID0gY29udGVudC52YWx1ZVswXTtcbiAgICB9XG5cbiAgICBpZighY29udGVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ291bGQgbm90IHNpZ24gUEtDUyM3IG1lc3NhZ2U7IHRoZXJlIGlzIG5vIGNvbnRlbnQgdG8gc2lnbi4nKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgQ29udGVudEluZm8gY29udGVudCB0eXBlXG4gICAgdmFyIGNvbnRlbnRUeXBlID0gYXNuMS5kZXJUb09pZChtc2cuY29udGVudEluZm8udmFsdWVbMF0udmFsdWUpO1xuXG4gICAgLy8gc2VyaWFsaXplIGNvbnRlbnRcbiAgICB2YXIgYnl0ZXMgPSBhc24xLnRvRGVyKGNvbnRlbnQpO1xuXG4gICAgLy8gc2tpcCBpZGVudGlmaWVyIGFuZCBsZW5ndGggcGVyIFJGQyAyMzE1IDkuM1xuICAgIC8vIHNraXAgaWRlbnRpZmllciAoMSBieXRlKVxuICAgIGJ5dGVzLmdldEJ5dGUoKTtcbiAgICAvLyByZWFkIGFuZCBkaXNjYXJkIGxlbmd0aCBieXRlc1xuICAgIGFzbjEuZ2V0QmVyVmFsdWVMZW5ndGgoYnl0ZXMpO1xuICAgIGJ5dGVzID0gYnl0ZXMuZ2V0Qnl0ZXMoKTtcblxuICAgIC8vIGRpZ2VzdCBjb250ZW50IERFUiB2YWx1ZSBieXRlc1xuICAgIGZvcih2YXIgb2lkIGluIG1kcykge1xuICAgICAgbWRzW29pZF0uc3RhcnQoKS51cGRhdGUoYnl0ZXMpO1xuICAgIH1cblxuICAgIC8vIHNpZ24gY29udGVudFxuICAgIHZhciBzaWduaW5nVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1zZy5zaWduZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc2lnbmVyID0gbXNnLnNpZ25lcnNbaV07XG5cbiAgICAgIGlmKHNpZ25lci5hdXRoZW50aWNhdGVkQXR0cmlidXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gaWYgQ29udGVudEluZm8gY29udGVudCB0eXBlIGlzIG5vdCBcIkRhdGFcIiwgdGhlblxuICAgICAgICAvLyBhdXRoZW50aWNhdGVkQXR0cmlidXRlcyBtdXN0IGJlIHByZXNlbnQgcGVyIFJGQyAyMzE1XG4gICAgICAgIGlmKGNvbnRlbnRUeXBlICE9PSBmb3JnZS5wa2kub2lkcy5kYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgc2lnbmVyOyBhdXRoZW50aWNhdGVkQXR0cmlidXRlcyBtdXN0IGJlIHByZXNlbnQgJyArXG4gICAgICAgICAgICAnd2hlbiB0aGUgQ29udGVudEluZm8gY29udGVudCB0eXBlIGlzIG5vdCBQS0NTIzcgRGF0YS4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcHJvY2VzcyBhdXRoZW50aWNhdGVkIGF0dHJpYnV0ZXNcbiAgICAgICAgLy8gWzBdIElNUExJQ0lUXG4gICAgICAgIHNpZ25lci5hdXRoZW50aWNhdGVkQXR0cmlidXRlc0FzbjEgPSBhc24xLmNyZWF0ZShcbiAgICAgICAgICBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtdKTtcblxuICAgICAgICAvLyBwZXIgUkZDIDIzMTUsIGF0dHJpYnV0ZXMgYXJlIHRvIGJlIGRpZ2VzdGVkIHVzaW5nIGEgU0VUIGNvbnRhaW5lclxuICAgICAgICAvLyBub3QgdGhlIGFib3ZlIFswXSBJTVBMSUNJVCBjb250YWluZXJcbiAgICAgICAgdmFyIGF0dHJzQXNuMSA9IGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXSk7XG5cbiAgICAgICAgZm9yKHZhciBhaSA9IDA7IGFpIDwgc2lnbmVyLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzLmxlbmd0aDsgKythaSkge1xuICAgICAgICAgIHZhciBhdHRyID0gc2lnbmVyLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzW2FpXTtcbiAgICAgICAgICBpZihhdHRyLnR5cGUgPT09IGZvcmdlLnBraS5vaWRzLm1lc3NhZ2VEaWdlc3QpIHtcbiAgICAgICAgICAgIC8vIHVzZSBjb250ZW50IG1lc3NhZ2UgZGlnZXN0IGFzIHZhbHVlXG4gICAgICAgICAgICBhdHRyLnZhbHVlID0gbWRzW3NpZ25lci5kaWdlc3RBbGdvcml0aG1dLmRpZ2VzdCgpO1xuICAgICAgICAgIH0gZWxzZSBpZihhdHRyLnR5cGUgPT09IGZvcmdlLnBraS5vaWRzLnNpZ25pbmdUaW1lKSB7XG4gICAgICAgICAgICAvLyBhdXRvLXBvcHVsYXRlIHNpZ25pbmcgdGltZSBpZiBub3QgYWxyZWFkeSBzZXRcbiAgICAgICAgICAgIGlmKCFhdHRyLnZhbHVlKSB7XG4gICAgICAgICAgICAgIGF0dHIudmFsdWUgPSBzaWduaW5nVGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBjb252ZXJ0IHRvIEFTTi4xIGFuZCBwdXNoIG9udG8gQXR0cmlidXRlcyBTRVQgKGZvciBzaWduaW5nKSBhbmRcbiAgICAgICAgICAvLyBvbnRvIGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzQXNuMSB0byBjb21wbGV0ZSBTaWduZWREYXRhIEFTTi4xXG4gICAgICAgICAgLy8gVE9ETzogb3B0aW1pemUgYXdheSBkdXBsaWNhdGlvblxuICAgICAgICAgIGF0dHJzQXNuMS52YWx1ZS5wdXNoKF9hdHRyaWJ1dGVUb0FzbjEoYXR0cikpO1xuICAgICAgICAgIHNpZ25lci5hdXRoZW50aWNhdGVkQXR0cmlidXRlc0FzbjEudmFsdWUucHVzaChfYXR0cmlidXRlVG9Bc24xKGF0dHIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERFUi1zZXJpYWxpemUgYW5kIGRpZ2VzdCBTRVQgT0YgYXR0cmlidXRlcyBvbmx5XG4gICAgICAgIGJ5dGVzID0gYXNuMS50b0RlcihhdHRyc0FzbjEpLmdldEJ5dGVzKCk7XG4gICAgICAgIHNpZ25lci5tZC5zdGFydCgpLnVwZGF0ZShieXRlcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNpZ24gZGlnZXN0XG4gICAgICBzaWduZXIuc2lnbmF0dXJlID0gc2lnbmVyLmtleS5zaWduKHNpZ25lci5tZCwgJ1JTQVNTQS1QS0NTMS1WMV81Jyk7XG4gICAgfVxuXG4gICAgLy8gYWRkIHNpZ25lciBpbmZvXG4gICAgbXNnLnNpZ25lckluZm9zID0gX3NpZ25lcnNUb0FzbjEobXNnLnNpZ25lcnMpO1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW1wdHkgUEtDUyM3IG1lc3NhZ2Ugb2YgdHlwZSBFbmNyeXB0ZWREYXRhLlxuICpcbiAqIEByZXR1cm4gdGhlIG1lc3NhZ2UuXG4gKi9cbnA3LmNyZWF0ZUVuY3J5cHRlZERhdGEgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG1zZyA9IG51bGw7XG4gIG1zZyA9IHtcbiAgICB0eXBlOiBmb3JnZS5wa2kub2lkcy5lbmNyeXB0ZWREYXRhLFxuICAgIHZlcnNpb246IDAsXG4gICAgZW5jcnlwdGVkQ29udGVudDoge1xuICAgICAgYWxnb3JpdGhtOiBmb3JnZS5wa2kub2lkc1snYWVzMjU2LUNCQyddXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIEVuY3J5cHRlZERhdGEgY29udGVudCBibG9jayAoaW4gQVNOLjEgZm9ybWF0KVxuICAgICAqXG4gICAgICogQHBhcmFtIG9iaiBUaGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgdGhlIEVuY3J5cHRlZERhdGEgY29udGVudCBibG9ja1xuICAgICAqL1xuICAgIGZyb21Bc24xOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIC8vIFZhbGlkYXRlIEVuY3J5cHRlZERhdGEgY29udGVudCBibG9jayBhbmQgY2FwdHVyZSBkYXRhLlxuICAgICAgX2Zyb21Bc24xKG1zZywgb2JqLCBwNy5hc24xLmVuY3J5cHRlZERhdGFWYWxpZGF0b3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNyeXB0IGVuY3J5cHRlZCBjb250ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSAoc3ltbWV0cmljKSBrZXkgYXMgYSBieXRlIGJ1ZmZlclxuICAgICAqL1xuICAgIGRlY3J5cHQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbXNnLmVuY3J5cHRlZENvbnRlbnQua2V5ID0ga2V5O1xuICAgICAgfVxuICAgICAgX2RlY3J5cHRDb250ZW50KG1zZyk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbXNnO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVtcHR5IFBLQ1MjNyBtZXNzYWdlIG9mIHR5cGUgRW52ZWxvcGVkRGF0YS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBtZXNzYWdlLlxuICovXG5wNy5jcmVhdGVFbnZlbG9wZWREYXRhID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtc2cgPSBudWxsO1xuICBtc2cgPSB7XG4gICAgdHlwZTogZm9yZ2UucGtpLm9pZHMuZW52ZWxvcGVkRGF0YSxcbiAgICB2ZXJzaW9uOiAwLFxuICAgIHJlY2lwaWVudHM6IFtdLFxuICAgIGVuY3J5cHRlZENvbnRlbnQ6IHtcbiAgICAgIGFsZ29yaXRobTogZm9yZ2UucGtpLm9pZHNbJ2FlczI1Ni1DQkMnXVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBFbnZlbG9wZWREYXRhIGNvbnRlbnQgYmxvY2sgKGluIEFTTi4xIGZvcm1hdClcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvYmogdGhlIEFTTi4xIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBFbnZlbG9wZWREYXRhIGNvbnRlbnQgYmxvY2suXG4gICAgICovXG4gICAgZnJvbUFzbjE6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgLy8gdmFsaWRhdGUgRW52ZWxvcGVkRGF0YSBjb250ZW50IGJsb2NrIGFuZCBjYXB0dXJlIGRhdGFcbiAgICAgIHZhciBjYXB0dXJlID0gX2Zyb21Bc24xKG1zZywgb2JqLCBwNy5hc24xLmVudmVsb3BlZERhdGFWYWxpZGF0b3IpO1xuICAgICAgbXNnLnJlY2lwaWVudHMgPSBfcmVjaXBpZW50c0Zyb21Bc24xKGNhcHR1cmUucmVjaXBpZW50SW5mb3MudmFsdWUpO1xuICAgIH0sXG5cbiAgICB0b0FzbjE6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQ29udGVudEluZm9cbiAgICAgIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIENvbnRlbnRUeXBlXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICBhc24xLm9pZFRvRGVyKG1zZy50eXBlKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gWzBdIEVudmVsb3BlZERhdGFcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgICAgLy8gVmVyc2lvblxuICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIobXNnLnZlcnNpb24pLmdldEJ5dGVzKCkpLFxuICAgICAgICAgICAgLy8gUmVjaXBpZW50SW5mb3NcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLFxuICAgICAgICAgICAgICBfcmVjaXBpZW50c1RvQXNuMShtc2cucmVjaXBpZW50cykpLFxuICAgICAgICAgICAgLy8gRW5jcnlwdGVkQ29udGVudEluZm9cbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsXG4gICAgICAgICAgICAgIF9lbmNyeXB0ZWRDb250ZW50VG9Bc24xKG1zZy5lbmNyeXB0ZWRDb250ZW50KSlcbiAgICAgICAgICBdKVxuICAgICAgICBdKVxuICAgICAgXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgcmVjaXBpZW50IGJ5IFguNTA5IGNlcnRpZmljYXRlJ3MgaXNzdWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIHdpdGggdGhlIGlzc3VlciB0byBsb29rIGZvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhlIHJlY2lwaWVudCBvYmplY3QuXG4gICAgICovXG4gICAgZmluZFJlY2lwaWVudDogZnVuY3Rpb24oY2VydCkge1xuICAgICAgdmFyIHNBdHRyID0gY2VydC5pc3N1ZXIuYXR0cmlidXRlcztcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1zZy5yZWNpcGllbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciByID0gbXNnLnJlY2lwaWVudHNbaV07XG4gICAgICAgIHZhciByQXR0ciA9IHIuaXNzdWVyO1xuXG4gICAgICAgIGlmKHIuc2VyaWFsTnVtYmVyICE9PSBjZXJ0LnNlcmlhbE51bWJlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYockF0dHIubGVuZ3RoICE9PSBzQXR0ci5sZW5ndGgpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXRjaCA9IHRydWU7XG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBzQXR0ci5sZW5ndGg7ICsraikge1xuICAgICAgICAgIGlmKHJBdHRyW2pdLnR5cGUgIT09IHNBdHRyW2pdLnR5cGUgfHxcbiAgICAgICAgICAgIHJBdHRyW2pdLnZhbHVlICE9PSBzQXR0cltqXS52YWx1ZSkge1xuICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY3J5cHQgZW52ZWxvcGVkIGNvbnRlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWNpcGllbnQgVGhlIHJlY2lwaWVudCBvYmplY3QgcmVsYXRlZCB0byB0aGUgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gcHJpdktleSBUaGUgKFJTQSkgcHJpdmF0ZSBrZXkgb2JqZWN0XG4gICAgICovXG4gICAgZGVjcnlwdDogZnVuY3Rpb24ocmVjaXBpZW50LCBwcml2S2V5KSB7XG4gICAgICBpZihtc2cuZW5jcnlwdGVkQ29udGVudC5rZXkgPT09IHVuZGVmaW5lZCAmJiByZWNpcGllbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBwcml2S2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3dpdGNoKHJlY2lwaWVudC5lbmNyeXB0ZWRDb250ZW50LmFsZ29yaXRobSkge1xuICAgICAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHMucnNhRW5jcnlwdGlvbjpcbiAgICAgICAgICBjYXNlIGZvcmdlLnBraS5vaWRzLmRlc0NCQzpcbiAgICAgICAgICAgIHZhciBrZXkgPSBwcml2S2V5LmRlY3J5cHQocmVjaXBpZW50LmVuY3J5cHRlZENvbnRlbnQuY29udGVudCk7XG4gICAgICAgICAgICBtc2cuZW5jcnlwdGVkQ29udGVudC5rZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBhc3ltbWV0cmljIGNpcGhlciwgJyArXG4gICAgICAgICAgICAgICdPSUQgJyArIHJlY2lwaWVudC5lbmNyeXB0ZWRDb250ZW50LmFsZ29yaXRobSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2RlY3J5cHRDb250ZW50KG1zZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCAoYW5vdGhlcikgZW50aXR5IHRvIGxpc3Qgb2YgcmVjaXBpZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjZXJ0IFRoZSBjZXJ0aWZpY2F0ZSBvZiB0aGUgZW50aXR5IHRvIGFkZC5cbiAgICAgKi9cbiAgICBhZGRSZWNpcGllbnQ6IGZ1bmN0aW9uKGNlcnQpIHtcbiAgICAgIG1zZy5yZWNpcGllbnRzLnB1c2goe1xuICAgICAgICB2ZXJzaW9uOiAwLFxuICAgICAgICBpc3N1ZXI6IGNlcnQuaXNzdWVyLmF0dHJpYnV0ZXMsXG4gICAgICAgIHNlcmlhbE51bWJlcjogY2VydC5zZXJpYWxOdW1iZXIsXG4gICAgICAgIGVuY3J5cHRlZENvbnRlbnQ6IHtcbiAgICAgICAgICAvLyBXZSBzaW1wbHkgYXNzdW1lIHJzYUVuY3J5cHRpb24gaGVyZSwgc2luY2UgZm9yZ2UucGtpIG9ubHlcbiAgICAgICAgICAvLyBzdXBwb3J0cyBSU0Egc28gZmFyLiAgSWYgdGhlIFBLSSBtb2R1bGUgc3VwcG9ydHMgb3RoZXJcbiAgICAgICAgICAvLyBjaXBoZXJzIG9uZSBkYXksIHdlIG5lZWQgdG8gbW9kaWZ5IHRoaXMgb25lIGFzIHdlbGwuXG4gICAgICAgICAgYWxnb3JpdGhtOiBmb3JnZS5wa2kub2lkcy5yc2FFbmNyeXB0aW9uLFxuICAgICAgICAgIGtleTogY2VydC5wdWJsaWNLZXlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuY3J5cHQgZW52ZWxvcGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHN1cHBvcnRzIHR3byBvcHRpb25hbCBhcmd1bWVudHMsIGNpcGhlciBhbmQga2V5LCB3aGljaFxuICAgICAqIGNhbiBiZSB1c2VkIHRvIGluZmx1ZW5jZSBzeW1tZXRyaWMgZW5jcnlwdGlvbi4gIFVubGVzcyBjaXBoZXIgaXNcbiAgICAgKiBwcm92aWRlZCwgdGhlIGNpcGhlciBzcGVjaWZpZWQgaW4gZW5jcnlwdGVkQ29udGVudC5hbGdvcml0aG0gaXMgdXNlZFxuICAgICAqIChkZWZhdWx0cyB0byBBRVMtMjU2LUNCQykuICBJZiBubyBrZXkgaXMgcHJvdmlkZWQsIGVuY3J5cHRlZENvbnRlbnQua2V5XG4gICAgICogaXMgKHJlLSl1c2VkLiAgSWYgdGhhdCBvbmUncyBub3Qgc2V0LCBhIHJhbmRvbSBrZXkgd2lsbCBiZSBnZW5lcmF0ZWRcbiAgICAgKiBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIFtrZXldIFRoZSBrZXkgdG8gYmUgdXNlZCBmb3Igc3ltbWV0cmljIGVuY3J5cHRpb24uXG4gICAgICogQHBhcmFtIFtjaXBoZXJdIFRoZSBPSUQgb2YgdGhlIHN5bW1ldHJpYyBjaXBoZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIGVuY3J5cHQ6IGZ1bmN0aW9uKGtleSwgY2lwaGVyKSB7XG4gICAgICAvLyBQYXJ0IDE6IFN5bW1ldHJpYyBlbmNyeXB0aW9uXG4gICAgICBpZihtc2cuZW5jcnlwdGVkQ29udGVudC5jb250ZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2lwaGVyID0gY2lwaGVyIHx8IG1zZy5lbmNyeXB0ZWRDb250ZW50LmFsZ29yaXRobTtcbiAgICAgICAga2V5ID0ga2V5IHx8IG1zZy5lbmNyeXB0ZWRDb250ZW50LmtleTtcblxuICAgICAgICB2YXIga2V5TGVuLCBpdkxlbiwgY2lwaEZuO1xuICAgICAgICBzd2l0Y2goY2lwaGVyKSB7XG4gICAgICAgICAgY2FzZSBmb3JnZS5wa2kub2lkc1snYWVzMTI4LUNCQyddOlxuICAgICAgICAgICAga2V5TGVuID0gMTY7XG4gICAgICAgICAgICBpdkxlbiA9IDE2O1xuICAgICAgICAgICAgY2lwaEZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHNbJ2FlczE5Mi1DQkMnXTpcbiAgICAgICAgICAgIGtleUxlbiA9IDI0O1xuICAgICAgICAgICAgaXZMZW4gPSAxNjtcbiAgICAgICAgICAgIGNpcGhGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIGZvcmdlLnBraS5vaWRzWydhZXMyNTYtQ0JDJ106XG4gICAgICAgICAgICBrZXlMZW4gPSAzMjtcbiAgICAgICAgICAgIGl2TGVuID0gMTY7XG4gICAgICAgICAgICBjaXBoRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBmb3JnZS5wa2kub2lkc1snZGVzLUVERTMtQ0JDJ106XG4gICAgICAgICAgICBrZXlMZW4gPSAyNDtcbiAgICAgICAgICAgIGl2TGVuID0gODtcbiAgICAgICAgICAgIGNpcGhGbiA9IGZvcmdlLmRlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzeW1tZXRyaWMgY2lwaGVyLCBPSUQgJyArIGNpcGhlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZihrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGZvcmdlLnJhbmRvbS5nZXRCeXRlcyhrZXlMZW4pKTtcbiAgICAgICAgfSBlbHNlIGlmKGtleS5sZW5ndGgoKSAhPSBrZXlMZW4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N5bW1ldHJpYyBrZXkgaGFzIHdyb25nIGxlbmd0aDsgJyArXG4gICAgICAgICAgICAnZ290ICcgKyBrZXkubGVuZ3RoKCkgKyAnIGJ5dGVzLCBleHBlY3RlZCAnICsga2V5TGVuICsgJy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEtlZXAgYSBjb3B5IG9mIHRoZSBrZXkgJiBJViBpbiB0aGUgb2JqZWN0LCBzbyB0aGUgY2FsbGVyIGNhblxuICAgICAgICAvLyB1c2UgaXQgZm9yIHdoYXRldmVyIHJlYXNvbi5cbiAgICAgICAgbXNnLmVuY3J5cHRlZENvbnRlbnQuYWxnb3JpdGhtID0gY2lwaGVyO1xuICAgICAgICBtc2cuZW5jcnlwdGVkQ29udGVudC5rZXkgPSBrZXk7XG4gICAgICAgIG1zZy5lbmNyeXB0ZWRDb250ZW50LnBhcmFtZXRlciA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKFxuICAgICAgICAgIGZvcmdlLnJhbmRvbS5nZXRCeXRlcyhpdkxlbikpO1xuXG4gICAgICAgIHZhciBjaXBoID0gY2lwaEZuKGtleSk7XG4gICAgICAgIGNpcGguc3RhcnQobXNnLmVuY3J5cHRlZENvbnRlbnQucGFyYW1ldGVyLmNvcHkoKSk7XG4gICAgICAgIGNpcGgudXBkYXRlKG1zZy5jb250ZW50KTtcblxuICAgICAgICAvLyBUaGUgZmluaXNoIGZ1bmN0aW9uIGRvZXMgUEtDUyM3IHBhZGRpbmcgYnkgZGVmYXVsdCwgdGhlcmVmb3JlXG4gICAgICAgIC8vIG5vIGFjdGlvbiByZXF1aXJlZCBieSB1cy5cbiAgICAgICAgaWYoIWNpcGguZmluaXNoKCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N5bW1ldHJpYyBlbmNyeXB0aW9uIGZhaWxlZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1zZy5lbmNyeXB0ZWRDb250ZW50LmNvbnRlbnQgPSBjaXBoLm91dHB1dDtcbiAgICAgIH1cblxuICAgICAgLy8gUGFydCAyOiBhc3ltbWV0cmljIGVuY3J5cHRpb24gZm9yIGVhY2ggcmVjaXBpZW50XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbXNnLnJlY2lwaWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlY2lwaWVudCA9IG1zZy5yZWNpcGllbnRzW2ldO1xuXG4gICAgICAgIC8vIE5vdGhpbmcgdG8gZG8sIGVuY3J5cHRpb24gYWxyZWFkeSBkb25lLlxuICAgICAgICBpZihyZWNpcGllbnQuZW5jcnlwdGVkQ29udGVudC5jb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaChyZWNpcGllbnQuZW5jcnlwdGVkQ29udGVudC5hbGdvcml0aG0pIHtcbiAgICAgICAgICBjYXNlIGZvcmdlLnBraS5vaWRzLnJzYUVuY3J5cHRpb246XG4gICAgICAgICAgICByZWNpcGllbnQuZW5jcnlwdGVkQ29udGVudC5jb250ZW50ID1cbiAgICAgICAgICAgICAgcmVjaXBpZW50LmVuY3J5cHRlZENvbnRlbnQua2V5LmVuY3J5cHQoXG4gICAgICAgICAgICAgICAgbXNnLmVuY3J5cHRlZENvbnRlbnQua2V5LmRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBhc3ltbWV0cmljIGNpcGhlciwgT0lEICcgK1xuICAgICAgICAgICAgICByZWNpcGllbnQuZW5jcnlwdGVkQ29udGVudC5hbGdvcml0aG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gbXNnO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNpbmdsZSByZWNpcGllbnQgZnJvbSBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgQVNOLjEgUmVjaXBpZW50SW5mby5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZWNpcGllbnQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBfcmVjaXBpZW50RnJvbUFzbjEob2JqKSB7XG4gIC8vIHZhbGlkYXRlIEVudmVsb3BlZERhdGEgY29udGVudCBibG9jayBhbmQgY2FwdHVyZSBkYXRhXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCBwNy5hc24xLnJlY2lwaWVudEluZm9WYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIFBLQ1MjNyBSZWNpcGllbnRJbmZvLiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgaXMgbm90IGFuIFBLQ1MjNyBSZWNpcGllbnRJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmVyc2lvbjogY2FwdHVyZS52ZXJzaW9uLmNoYXJDb2RlQXQoMCksXG4gICAgaXNzdWVyOiBmb3JnZS5wa2kuUkROQXR0cmlidXRlc0FzQXJyYXkoY2FwdHVyZS5pc3N1ZXIpLFxuICAgIHNlcmlhbE51bWJlcjogZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5zZXJpYWwpLnRvSGV4KCksXG4gICAgZW5jcnlwdGVkQ29udGVudDoge1xuICAgICAgYWxnb3JpdGhtOiBhc24xLmRlclRvT2lkKGNhcHR1cmUuZW5jQWxnb3JpdGhtKSxcbiAgICAgIHBhcmFtZXRlcjogY2FwdHVyZS5lbmNQYXJhbWV0ZXIgPyBjYXB0dXJlLmVuY1BhcmFtZXRlci52YWx1ZSA6IHVuZGVmaW5lZCxcbiAgICAgIGNvbnRlbnQ6IGNhcHR1cmUuZW5jS2V5XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc2luZ2xlIHJlY2lwaWVudCBvYmplY3QgdG8gYW4gQVNOLjEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIHJlY2lwaWVudCBvYmplY3QuXG4gKlxuICogQHJldHVybiB0aGUgQVNOLjEgUmVjaXBpZW50SW5mby5cbiAqL1xuZnVuY3Rpb24gX3JlY2lwaWVudFRvQXNuMShvYmopIHtcbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBWZXJzaW9uXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGFzbjEuaW50ZWdlclRvRGVyKG9iai52ZXJzaW9uKS5nZXRCeXRlcygpKSxcbiAgICAvLyBJc3N1ZXJBbmRTZXJpYWxOdW1iZXJcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAvLyBOYW1lXG4gICAgICBmb3JnZS5wa2kuZGlzdGluZ3Vpc2hlZE5hbWVUb0FzbjEoe2F0dHJpYnV0ZXM6IG9iai5pc3N1ZXJ9KSxcbiAgICAgIC8vIFNlcmlhbFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgZm9yZ2UudXRpbC5oZXhUb0J5dGVzKG9iai5zZXJpYWxOdW1iZXIpKVxuICAgIF0pLFxuICAgIC8vIEtleUVuY3J5cHRpb25BbGdvcml0aG1JZGVudGlmaWVyXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gQWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIob2JqLmVuY3J5cHRlZENvbnRlbnQuYWxnb3JpdGhtKS5nZXRCeXRlcygpKSxcbiAgICAgIC8vIFBhcmFtZXRlciwgZm9yY2UgTlVMTCwgb25seSBSU0Egc3VwcG9ydGVkIGZvciBub3cuXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICBdKSxcbiAgICAvLyBFbmNyeXB0ZWRLZXlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSxcbiAgICAgIG9iai5lbmNyeXB0ZWRDb250ZW50LmNvbnRlbnQpXG4gIF0pO1xufVxuXG4vKipcbiAqIE1hcCBhIHNldCBvZiBSZWNpcGllbnRJbmZvIEFTTi4xIG9iamVjdHMgdG8gcmVjaXBpZW50IG9iamVjdHMuXG4gKlxuICogQHBhcmFtIGluZm9zIGFuIGFycmF5IG9mIEFTTi4xIHJlcHJlc2VudGF0aW9ucyBSZWNpcGllbnRJbmZvIChpLmUuIFNFVCBPRikuXG4gKlxuICogQHJldHVybiBhbiBhcnJheSBvZiByZWNpcGllbnQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gX3JlY2lwaWVudHNGcm9tQXNuMShpbmZvcykge1xuICB2YXIgcmV0ID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbmZvcy5sZW5ndGg7ICsraSkge1xuICAgIHJldC5wdXNoKF9yZWNpcGllbnRGcm9tQXNuMShpbmZvc1tpXSkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogTWFwIGFuIGFycmF5IG9mIHJlY2lwaWVudCBvYmplY3RzIHRvIEFTTi4xIFJlY2lwaWVudEluZm8gb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gcmVjaXBpZW50cyBhbiBhcnJheSBvZiByZWNpcGllbnRJbmZvIG9iamVjdHMuXG4gKlxuICogQHJldHVybiBhbiBhcnJheSBvZiBBU04uMSBSZWNpcGllbnRJbmZvcy5cbiAqL1xuZnVuY3Rpb24gX3JlY2lwaWVudHNUb0FzbjEocmVjaXBpZW50cykge1xuICB2YXIgcmV0ID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCByZWNpcGllbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgcmV0LnB1c2goX3JlY2lwaWVudFRvQXNuMShyZWNpcGllbnRzW2ldKSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNpbmdsZSBzaWduZXIgZnJvbSBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgYSBTaWduZXJJbmZvLlxuICpcbiAqIEByZXR1cm4gdGhlIHNpZ25lciBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIF9zaWduZXJGcm9tQXNuMShvYmopIHtcbiAgLy8gdmFsaWRhdGUgRW52ZWxvcGVkRGF0YSBjb250ZW50IGJsb2NrIGFuZCBjYXB0dXJlIGRhdGFcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIHA3LmFzbjEuc2lnbmVySW5mb1ZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgUEtDUyM3IFNpZ25lckluZm8uICcgK1xuICAgICAgJ0FTTi4xIG9iamVjdCBpcyBub3QgYW4gUEtDUyM3IFNpZ25lckluZm8uJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIHJ2YWwgPSB7XG4gICAgdmVyc2lvbjogY2FwdHVyZS52ZXJzaW9uLmNoYXJDb2RlQXQoMCksXG4gICAgaXNzdWVyOiBmb3JnZS5wa2kuUkROQXR0cmlidXRlc0FzQXJyYXkoY2FwdHVyZS5pc3N1ZXIpLFxuICAgIHNlcmlhbE51bWJlcjogZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5zZXJpYWwpLnRvSGV4KCksXG4gICAgZGlnZXN0QWxnb3JpdGhtOiBhc24xLmRlclRvT2lkKGNhcHR1cmUuZGlnZXN0QWxnb3JpdGhtKSxcbiAgICBzaWduYXR1cmVBbGdvcml0aG06IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5zaWduYXR1cmVBbGdvcml0aG0pLFxuICAgIHNpZ25hdHVyZTogY2FwdHVyZS5zaWduYXR1cmUsXG4gICAgYXV0aGVudGljYXRlZEF0dHJpYnV0ZXM6IFtdLFxuICAgIHVuYXV0aGVudGljYXRlZEF0dHJpYnV0ZXM6IFtdXG4gIH07XG5cbiAgLy8gVE9ETzogY29udmVydCBhdHRyaWJ1dGVzXG4gIHZhciBhdXRoZW50aWNhdGVkQXR0cmlidXRlcyA9IGNhcHR1cmUuYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMgfHwgW107XG4gIHZhciB1bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzID0gY2FwdHVyZS51bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzIHx8IFtdO1xuXG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc2luZ2xlIHNpZ25lckluZm8gb2JqZWN0IHRvIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBzaWduZXJJbmZvIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSByZXByZXNlbnRhdGlvbiBvZiBhIFNpZ25lckluZm8uXG4gKi9cbmZ1bmN0aW9uIF9zaWduZXJUb0FzbjEob2JqKSB7XG4gIC8vIFNpZ25lckluZm9cbiAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gdmVyc2lvblxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBhc24xLmludGVnZXJUb0RlcihvYmoudmVyc2lvbikuZ2V0Qnl0ZXMoKSksXG4gICAgLy8gaXNzdWVyQW5kU2VyaWFsTnVtYmVyXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gbmFtZVxuICAgICAgZm9yZ2UucGtpLmRpc3Rpbmd1aXNoZWROYW1lVG9Bc24xKHthdHRyaWJ1dGVzOiBvYmouaXNzdWVyfSksXG4gICAgICAvLyBzZXJpYWxcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICAgIGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhvYmouc2VyaWFsTnVtYmVyKSlcbiAgICBdKSxcbiAgICAvLyBkaWdlc3RBbGdvcml0aG1cbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAvLyBhbGdvcml0aG1cbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgYXNuMS5vaWRUb0RlcihvYmouZGlnZXN0QWxnb3JpdGhtKS5nZXRCeXRlcygpKSxcbiAgICAgIC8vIHBhcmFtZXRlcnMgKG51bGwpXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICBdKVxuICBdKTtcblxuICAvLyBhdXRoZW50aWNhdGVkQXR0cmlidXRlcyAoT1BUSU9OQUwpXG4gIGlmKG9iai5hdXRoZW50aWNhdGVkQXR0cmlidXRlc0FzbjEpIHtcbiAgICAvLyBhZGQgQVNOLjEgcHJldmlvdXNseSBnZW5lcmF0ZWQgZHVyaW5nIHNpZ25pbmdcbiAgICBydmFsLnZhbHVlLnB1c2gob2JqLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzQXNuMSk7XG4gIH1cblxuICAvLyBkaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtXG4gIHJ2YWwudmFsdWUucHVzaChhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gYWxnb3JpdGhtXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgYXNuMS5vaWRUb0RlcihvYmouc2lnbmF0dXJlQWxnb3JpdGhtKS5nZXRCeXRlcygpKSxcbiAgICAvLyBwYXJhbWV0ZXJzIChudWxsKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICBdKSk7XG5cbiAgLy8gZW5jcnlwdGVkRGlnZXN0XG4gIHJ2YWwudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgb2JqLnNpZ25hdHVyZSkpO1xuXG4gIC8vIHVuYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMgKE9QVElPTkFMKVxuICBpZihvYmoudW5hdXRoZW50aWNhdGVkQXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgLy8gWzFdIElNUExJQ0lUXG4gICAgdmFyIGF0dHJzQXNuMSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMSwgdHJ1ZSwgW10pO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmoudW5hdXRoZW50aWNhdGVkQXR0cmlidXRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGF0dHIgPSBvYmoudW5hdXRoZW50aWNhdGVkQXR0cmlidXRlc1tpXTtcbiAgICAgIGF0dHJzQXNuMS52YWx1ZXMucHVzaChfYXR0cmlidXRlVG9Bc24xKGF0dHIpKTtcbiAgICB9XG4gICAgcnZhbC52YWx1ZS5wdXNoKGF0dHJzQXNuMSk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn1cblxuLyoqXG4gKiBNYXAgYSBzZXQgb2YgU2lnbmVySW5mbyBBU04uMSBvYmplY3RzIHRvIGFuIGFycmF5IG9mIHNpZ25lciBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSBzaWduZXJJbmZvQXNuMXMgYW4gYXJyYXkgb2YgQVNOLjEgU2lnbmVySW5mb3MgKGkuZS4gU0VUIE9GKS5cbiAqXG4gKiBAcmV0dXJuIGFuIGFycmF5IG9mIHNpZ25lcnMgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gX3NpZ25lcnNGcm9tQXNuMShzaWduZXJJbmZvQXNuMXMpIHtcbiAgdmFyIHJldCA9IFtdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2lnbmVySW5mb0FzbjFzLmxlbmd0aDsgKytpKSB7XG4gICAgcmV0LnB1c2goX3NpZ25lckZyb21Bc24xKHNpZ25lckluZm9Bc24xc1tpXSkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogTWFwIGFuIGFycmF5IG9mIHNpZ25lciBvYmplY3RzIHRvIEFTTi4xIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHNpZ25lcnMgYW4gYXJyYXkgb2Ygc2lnbmVyIG9iamVjdHMuXG4gKlxuICogQHJldHVybiBhbiBhcnJheSBvZiBBU04uMSBTaWduZXJJbmZvcy5cbiAqL1xuZnVuY3Rpb24gX3NpZ25lcnNUb0FzbjEoc2lnbmVycykge1xuICB2YXIgcmV0ID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzaWduZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgcmV0LnB1c2goX3NpZ25lclRvQXNuMShzaWduZXJzW2ldKSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIGF0dHJpYnV0ZSBvYmplY3QgdG8gYW4gQVNOLjEgQXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSBhdHRyIHRoZSBhdHRyaWJ1dGUgb2JqZWN0LlxuICpcbiAqIEByZXR1cm4gdGhlIEFTTi4xIEF0dHJpYnV0ZS5cbiAqL1xuZnVuY3Rpb24gX2F0dHJpYnV0ZVRvQXNuMShhdHRyKSB7XG4gIHZhciB2YWx1ZTtcblxuICAvLyBUT0RPOiBnZW5lcmFsaXplIHRvIHN1cHBvcnQgbW9yZSBhdHRyaWJ1dGVzXG4gIGlmKGF0dHIudHlwZSA9PT0gZm9yZ2UucGtpLm9pZHMuY29udGVudFR5cGUpIHtcbiAgICB2YWx1ZSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgIGFzbjEub2lkVG9EZXIoYXR0ci52YWx1ZSkuZ2V0Qnl0ZXMoKSk7XG4gIH0gZWxzZSBpZihhdHRyLnR5cGUgPT09IGZvcmdlLnBraS5vaWRzLm1lc3NhZ2VEaWdlc3QpIHtcbiAgICB2YWx1ZSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsIGZhbHNlLFxuICAgICAgYXR0ci52YWx1ZS5ieXRlcygpKTtcbiAgfSBlbHNlIGlmKGF0dHIudHlwZSA9PT0gZm9yZ2UucGtpLm9pZHMuc2lnbmluZ1RpbWUpIHtcbiAgICAvKiBOb3RlIHBlciBSRkMgMjk4NTogRGF0ZXMgYmV0d2VlbiAxIEphbnVhcnkgMTk1MCBhbmQgMzEgRGVjZW1iZXIgMjA0OVxuICAgICAgKGluY2x1c2l2ZSkgTVVTVCBiZSBlbmNvZGVkIGFzIFVUQ1RpbWUuIEFueSBkYXRlcyB3aXRoIHllYXIgdmFsdWVzXG4gICAgICBiZWZvcmUgMTk1MCBvciBhZnRlciAyMDQ5IE1VU1QgYmUgZW5jb2RlZCBhcyBHZW5lcmFsaXplZFRpbWUuIFtGdXJ0aGVyLF1cbiAgICAgIFVUQ1RpbWUgdmFsdWVzIE1VU1QgYmUgZXhwcmVzc2VkIGluIEdyZWVud2ljaCBNZWFuIFRpbWUgKFp1bHUpIGFuZCBNVVNUXG4gICAgICBpbmNsdWRlIHNlY29uZHMgKGkuZS4sIHRpbWVzIGFyZSBZWU1NRERISE1NU1NaKSwgZXZlbiB3aGVyZSB0aGVcbiAgICAgIG51bWJlciBvZiBzZWNvbmRzIGlzIHplcm8uICBNaWRuaWdodCAoR01UKSBtdXN0IGJlIHJlcHJlc2VudGVkIGFzXG4gICAgICBcIllZTU1ERDAwMDAwMFpcIi4gKi9cbiAgICAvLyBUT0RPOiBtYWtlIHRoZXNlIG1vZHVsZS1sZXZlbCBjb25zdGFudHNcbiAgICB2YXIgamFuXzFfMTk1MCA9IG5ldyBEYXRlKCcxOTUwLTAxLTAxVDAwOjAwOjAwWicpO1xuICAgIHZhciBqYW5fMV8yMDUwID0gbmV3IERhdGUoJzIwNTAtMDEtMDFUMDA6MDA6MDBaJyk7XG4gICAgdmFyIGRhdGUgPSBhdHRyLnZhbHVlO1xuICAgIGlmKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gdHJ5IHRvIHBhcnNlIGRhdGVcbiAgICAgIHZhciB0aW1lc3RhbXAgPSBEYXRlLnBhcnNlKGRhdGUpO1xuICAgICAgaWYoIWlzTmFOKHRpbWVzdGFtcCkpIHtcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHRpbWVzdGFtcCk7XG4gICAgICB9IGVsc2UgaWYoZGF0ZS5sZW5ndGggPT09IDEzKSB7XG4gICAgICAgIC8vIFlZTU1EREhITU1TU1ogKDEzIGNoYXJzIGZvciBVVENUaW1lKVxuICAgICAgICBkYXRlID0gYXNuMS51dGNUaW1lVG9EYXRlKGRhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYXNzdW1lIGdlbmVyYWxpemVkIHRpbWVcbiAgICAgICAgZGF0ZSA9IGFzbjEuZ2VuZXJhbGl6ZWRUaW1lVG9EYXRlKGRhdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGRhdGUgPj0gamFuXzFfMTk1MCAmJiBkYXRlIDwgamFuXzFfMjA1MCkge1xuICAgICAgdmFsdWUgPSBhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5VVENUSU1FLCBmYWxzZSxcbiAgICAgICAgYXNuMS5kYXRlVG9VdGNUaW1lKGRhdGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5HRU5FUkFMSVpFRFRJTUUsIGZhbHNlLFxuICAgICAgICBhc24xLmRhdGVUb0dlbmVyYWxpemVkVGltZShkYXRlKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogZXhwb3NlIGFzIGNvbW1vbiBBUEkgY2FsbFxuICAvLyBjcmVhdGUgYSBSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lIHNldFxuICAvLyBlYWNoIHZhbHVlIGluIHRoZSBzZXQgaXMgYW4gQXR0cmlidXRlVHlwZUFuZFZhbHVlIGZpcnN0XG4gIC8vIGNvbnRhaW5pbmcgdGhlIHR5cGUgKGFuIE9JRCkgYW5kIHNlY29uZCB0aGUgdmFsdWVcbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBBdHRyaWJ1dGVUeXBlXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgYXNuMS5vaWRUb0RlcihhdHRyLnR5cGUpLmdldEJ5dGVzKCkpLFxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICAvLyBBdHRyaWJ1dGVWYWx1ZVxuICAgICAgdmFsdWVcbiAgICBdKVxuICBdKTtcbn1cblxuLyoqXG4gKiBNYXAgbWVzc2FnZXMgZW5jcnlwdGVkIGNvbnRlbnQgdG8gQVNOLjEgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gZWMgVGhlIGVuY3J5cHRlZENvbnRlbnQgb2JqZWN0IG9mIHRoZSBtZXNzYWdlLlxuICpcbiAqIEByZXR1cm4gQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVuY3J5cHRlZENvbnRlbnQgb2JqZWN0IChTRVFVRU5DRSkuXG4gKi9cbmZ1bmN0aW9uIF9lbmNyeXB0ZWRDb250ZW50VG9Bc24xKGVjKSB7XG4gIHJldHVybiBbXG4gICAgLy8gQ29udGVudFR5cGUsIGFsd2F5cyBEYXRhIGZvciB0aGUgbW9tZW50XG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgYXNuMS5vaWRUb0Rlcihmb3JnZS5wa2kub2lkcy5kYXRhKS5nZXRCeXRlcygpKSxcbiAgICAvLyBDb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobUlkZW50aWZpZXJcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAvLyBBbGdvcml0aG1cbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgYXNuMS5vaWRUb0RlcihlYy5hbGdvcml0aG0pLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gUGFyYW1ldGVycyAoSVYpXG4gICAgICAhZWMucGFyYW1ldGVyID9cbiAgICAgICAgdW5kZWZpbmVkIDpcbiAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsXG4gICAgICAgICAgZWMucGFyYW1ldGVyLmdldEJ5dGVzKCkpXG4gICAgXSksXG4gICAgLy8gWzBdIEVuY3J5cHRlZENvbnRlbnRcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsIGZhbHNlLFxuICAgICAgICBlYy5jb250ZW50LmdldEJ5dGVzKCkpXG4gICAgXSlcbiAgXTtcbn1cblxuLyoqXG4gKiBSZWFkcyB0aGUgXCJjb21tb24gcGFydFwiIG9mIGFuIFBLQ1MjNyBjb250ZW50IGJsb2NrIChpbiBBU04uMSBmb3JtYXQpXG4gKlxuICogVGhpcyBmdW5jdGlvbiByZWFkcyB0aGUgXCJjb21tb24gcGFydFwiIG9mIHRoZSBQS0NTIzcgY29udGVudCBibG9ja3NcbiAqIEVuY3J5cHRlZERhdGEgYW5kIEVudmVsb3BlZERhdGEsIGkuZS4gdmVyc2lvbiBudW1iZXIgYW5kIHN5bW1ldHJpY2FsbHlcbiAqIGVuY3J5cHRlZCBjb250ZW50IGJsb2NrLlxuICpcbiAqIFRoZSByZXN1bHQgb2YgdGhlIEFTTi4xIHZhbGlkYXRlIGFuZCBjYXB0dXJlIHByb2Nlc3MgaXMgcmV0dXJuZWRcbiAqIHRvIGFsbG93IHRoZSBjYWxsZXIgdG8gZXh0cmFjdCBmdXJ0aGVyIGRhdGEsIGUuZy4gdGhlIGxpc3Qgb2YgcmVjaXBpZW50c1xuICogaW4gY2FzZSBvZiBhIEVudmVsb3BlZERhdGEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBtc2cgdGhlIFBLQ1MjNyBvYmplY3QgdG8gcmVhZCB0aGUgZGF0YSB0by5cbiAqIEBwYXJhbSBvYmogdGhlIEFTTi4xIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb250ZW50IGJsb2NrLlxuICogQHBhcmFtIHZhbGlkYXRvciB0aGUgQVNOLjEgc3RydWN0dXJlIHZhbGlkYXRvciBvYmplY3QgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIHZhbHVlIG1hcCBjYXB0dXJlZCBieSB2YWxpZGF0b3Igb2JqZWN0LlxuICovXG5mdW5jdGlvbiBfZnJvbUFzbjEobXNnLCBvYmosIHZhbGlkYXRvcikge1xuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKG9iaiwgdmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTIzcgbWVzc2FnZS4gJyArXG4gICAgICAnQVNOLjEgb2JqZWN0IGlzIG5vdCBhIHN1cHBvcnRlZCBQS0NTIzcgbWVzc2FnZS4nKTtcbiAgICBlcnJvci5lcnJvcnMgPSBlcnJvcjtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIENoZWNrIGNvbnRlbnRUeXBlLCBzbyBmYXIgd2Ugb25seSBzdXBwb3J0IChyYXcpIERhdGEuXG4gIHZhciBjb250ZW50VHlwZSA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jb250ZW50VHlwZSk7XG4gIGlmKGNvbnRlbnRUeXBlICE9PSBmb3JnZS5wa2kub2lkcy5kYXRhKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBQS0NTIzcgbWVzc2FnZS4gJyArXG4gICAgICAnT25seSB3cmFwcGVkIENvbnRlbnRUeXBlIERhdGEgc3VwcG9ydGVkLicpO1xuICB9XG5cbiAgaWYoY2FwdHVyZS5lbmNyeXB0ZWRDb250ZW50KSB7XG4gICAgdmFyIGNvbnRlbnQgPSAnJztcbiAgICBpZihmb3JnZS51dGlsLmlzQXJyYXkoY2FwdHVyZS5lbmNyeXB0ZWRDb250ZW50KSkge1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNhcHR1cmUuZW5jcnlwdGVkQ29udGVudC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZihjYXB0dXJlLmVuY3J5cHRlZENvbnRlbnRbaV0udHlwZSAhPT0gYXNuMS5UeXBlLk9DVEVUU1RSSU5HKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgUEtDUyM3IG1lc3NhZ2UsIGV4cGVjdGluZyBlbmNyeXB0ZWQgJyArXG4gICAgICAgICAgICAnY29udGVudCBjb25zdHJ1Y3RlZCBvZiBvbmx5IE9DVEVUIFNUUklORyBvYmplY3RzLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnQgKz0gY2FwdHVyZS5lbmNyeXB0ZWRDb250ZW50W2ldLnZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50ID0gY2FwdHVyZS5lbmNyeXB0ZWRDb250ZW50O1xuICAgIH1cbiAgICBtc2cuZW5jcnlwdGVkQ29udGVudCA9IHtcbiAgICAgIGFsZ29yaXRobTogYXNuMS5kZXJUb09pZChjYXB0dXJlLmVuY0FsZ29yaXRobSksXG4gICAgICBwYXJhbWV0ZXI6IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUuZW5jUGFyYW1ldGVyLnZhbHVlKSxcbiAgICAgIGNvbnRlbnQ6IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNvbnRlbnQpXG4gICAgfTtcbiAgfVxuXG4gIGlmKGNhcHR1cmUuY29udGVudCkge1xuICAgIHZhciBjb250ZW50ID0gJyc7XG4gICAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KGNhcHR1cmUuY29udGVudCkpIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjYXB0dXJlLmNvbnRlbnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYoY2FwdHVyZS5jb250ZW50W2ldLnR5cGUgIT09IGFzbjEuVHlwZS5PQ1RFVFNUUklORykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFBLQ1MjNyBtZXNzYWdlLCBleHBlY3RpbmcgJyArXG4gICAgICAgICAgICAnY29udGVudCBjb25zdHJ1Y3RlZCBvZiBvbmx5IE9DVEVUIFNUUklORyBvYmplY3RzLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnQgKz0gY2FwdHVyZS5jb250ZW50W2ldLnZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50ID0gY2FwdHVyZS5jb250ZW50O1xuICAgIH1cbiAgICBtc2cuY29udGVudCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNvbnRlbnQpO1xuICB9XG5cbiAgbXNnLnZlcnNpb24gPSBjYXB0dXJlLnZlcnNpb24uY2hhckNvZGVBdCgwKTtcbiAgbXNnLnJhd0NhcHR1cmUgPSBjYXB0dXJlO1xuXG4gIHJldHVybiBjYXB0dXJlO1xufVxuXG4vKipcbiAqIERlY3J5cHQgdGhlIHN5bW1ldHJpY2FsbHkgZW5jcnlwdGVkIGNvbnRlbnQgYmxvY2sgb2YgdGhlIFBLQ1MjNyBtZXNzYWdlLlxuICpcbiAqIERlY3J5cHRpb24gaXMgc2tpcHBlZCBpbiBjYXNlIHRoZSBQS0NTIzcgbWVzc2FnZSBvYmplY3QgYWxyZWFkeSBoYXMgYVxuICogKGRlY3J5cHRlZCkgY29udGVudCBhdHRyaWJ1dGUuICBUaGUgYWxnb3JpdGhtLCBrZXkgYW5kIGNpcGhlciBwYXJhbWV0ZXJzXG4gKiAocHJvYmFibHkgdGhlIGl2KSBhcmUgdGFrZW4gZnJvbSB0aGUgZW5jcnlwdGVkQ29udGVudCBhdHRyaWJ1dGUgb2YgdGhlXG4gKiBtZXNzYWdlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gVGhlIFBLQ1MjNyBtZXNzYWdlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gX2RlY3J5cHRDb250ZW50KG1zZykge1xuICBpZihtc2cuZW5jcnlwdGVkQ29udGVudC5rZXkgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3ltbWV0cmljIGtleSBub3QgYXZhaWxhYmxlLicpO1xuICB9XG5cbiAgaWYobXNnLmNvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBjaXBoO1xuXG4gICAgc3dpdGNoKG1zZy5lbmNyeXB0ZWRDb250ZW50LmFsZ29yaXRobSkge1xuICAgICAgY2FzZSBmb3JnZS5wa2kub2lkc1snYWVzMTI4LUNCQyddOlxuICAgICAgY2FzZSBmb3JnZS5wa2kub2lkc1snYWVzMTkyLUNCQyddOlxuICAgICAgY2FzZSBmb3JnZS5wa2kub2lkc1snYWVzMjU2LUNCQyddOlxuICAgICAgICBjaXBoID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIobXNnLmVuY3J5cHRlZENvbnRlbnQua2V5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHNbJ2Rlc0NCQyddOlxuICAgICAgY2FzZSBmb3JnZS5wa2kub2lkc1snZGVzLUVERTMtQ0JDJ106XG4gICAgICAgIGNpcGggPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcihtc2cuZW5jcnlwdGVkQ29udGVudC5rZXkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzeW1tZXRyaWMgY2lwaGVyLCBPSUQgJyArXG4gICAgICAgICAgbXNnLmVuY3J5cHRlZENvbnRlbnQuYWxnb3JpdGhtKTtcbiAgICB9XG4gICAgY2lwaC5zdGFydChtc2cuZW5jcnlwdGVkQ29udGVudC5wYXJhbWV0ZXIpO1xuICAgIGNpcGgudXBkYXRlKG1zZy5lbmNyeXB0ZWRDb250ZW50LmNvbnRlbnQpO1xuXG4gICAgaWYoIWNpcGguZmluaXNoKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3ltbWV0cmljIGRlY3J5cHRpb24gZmFpbGVkLicpO1xuICAgIH1cblxuICAgIG1zZy5jb250ZW50ID0gY2lwaC5vdXRwdXQ7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJhc24xIiwicDciLCJtb2R1bGUiLCJleHBvcnRzIiwicGtjczciLCJtZXNzYWdlRnJvbVBlbSIsInBlbSIsIm1zZyIsImRlY29kZSIsInR5cGUiLCJlcnJvciIsIkVycm9yIiwiaGVhZGVyVHlwZSIsInByb2NUeXBlIiwib2JqIiwiZnJvbURlciIsImJvZHkiLCJtZXNzYWdlRnJvbUFzbjEiLCJtZXNzYWdlVG9QZW0iLCJtYXhsaW5lIiwicGVtT2JqIiwidG9EZXIiLCJ0b0FzbjEiLCJnZXRCeXRlcyIsImVuY29kZSIsImNhcHR1cmUiLCJlcnJvcnMiLCJ2YWxpZGF0ZSIsImNvbnRlbnRJbmZvVmFsaWRhdG9yIiwiY29udGVudFR5cGUiLCJkZXJUb09pZCIsInBraSIsIm9pZHMiLCJlbnZlbG9wZWREYXRhIiwiY3JlYXRlRW52ZWxvcGVkRGF0YSIsImVuY3J5cHRlZERhdGEiLCJjcmVhdGVFbmNyeXB0ZWREYXRhIiwic2lnbmVkRGF0YSIsImNyZWF0ZVNpZ25lZERhdGEiLCJmcm9tQXNuMSIsImNvbnRlbnQiLCJ2YWx1ZSIsInZlcnNpb24iLCJjZXJ0aWZpY2F0ZXMiLCJjcmxzIiwic2lnbmVycyIsImRpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXJzIiwiY29udGVudEluZm8iLCJzaWduZXJJbmZvcyIsIl9mcm9tQXNuMSIsInNpZ25lZERhdGFWYWxpZGF0b3IiLCJyYXdDYXB0dXJlIiwiY2VydHMiLCJpIiwibGVuZ3RoIiwicHVzaCIsImNlcnRpZmljYXRlRnJvbUFzbjEiLCJzaWduIiwiY2VydGlmaWNhdGVUb0FzbjEiLCJjcmVhdGUiLCJDbGFzcyIsIkNPTlRFWFRfU1BFQ0lGSUMiLCJVTklWRVJTQUwiLCJUeXBlIiwiU0VRVUVOQ0UiLCJJTlRFR0VSIiwiaW50ZWdlclRvRGVyIiwiU0VUIiwiT0lEIiwib2lkVG9EZXIiLCJhZGRTaWduZXIiLCJzaWduZXIiLCJpc3N1ZXIiLCJzZXJpYWxOdW1iZXIiLCJjZXJ0aWZpY2F0ZSIsImNlcnQiLCJjZXJ0aWZpY2F0ZUZyb21QZW0iLCJhdHRyaWJ1dGVzIiwia2V5IiwicHJpdmF0ZUtleUZyb21QZW0iLCJkaWdlc3RBbGdvcml0aG0iLCJzaGExIiwic2hhMjU2Iiwic2hhMzg0Iiwic2hhNTEyIiwibWQ1IiwiYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMiLCJtZXNzYWdlRGlnZXN0IiwiYXR0ciIsInNpZ25hdHVyZUFsZ29yaXRobSIsInJzYUVuY3J5cHRpb24iLCJzaWduYXR1cmUiLCJ1bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzIiwib3B0aW9ucyIsImRhdGEiLCJ1dGlsIiwiQnl0ZUJ1ZmZlciIsImJ5dGVzIiwiZW5jb2RlVXRmOCIsImRldGFjaGVkIiwiZGV0YWNoZWRDb250ZW50IiwiT0NURVRTVFJJTkciLCJtZHMiLCJhZGREaWdlc3RBbGdvcml0aG1JZHMiLCJhZGRTaWduZXJJbmZvcyIsInZlcmlmeSIsImFkZENlcnRpZmljYXRlIiwiYWRkQ2VydGlmaWNhdGVSZXZva2F0aW9uTGlzdCIsImNybCIsIm9pZCIsIm1kIiwiTlVMTCIsImdldEJ5dGUiLCJnZXRCZXJWYWx1ZUxlbmd0aCIsInN0YXJ0IiwidXBkYXRlIiwic2lnbmluZ1RpbWUiLCJEYXRlIiwiYXV0aGVudGljYXRlZEF0dHJpYnV0ZXNBc24xIiwiYXR0cnNBc24xIiwiYWkiLCJkaWdlc3QiLCJfYXR0cmlidXRlVG9Bc24xIiwiX3NpZ25lcnNUb0FzbjEiLCJlbmNyeXB0ZWRDb250ZW50IiwiYWxnb3JpdGhtIiwiZW5jcnlwdGVkRGF0YVZhbGlkYXRvciIsImRlY3J5cHQiLCJ1bmRlZmluZWQiLCJfZGVjcnlwdENvbnRlbnQiLCJyZWNpcGllbnRzIiwiZW52ZWxvcGVkRGF0YVZhbGlkYXRvciIsIl9yZWNpcGllbnRzRnJvbUFzbjEiLCJyZWNpcGllbnRJbmZvcyIsIl9yZWNpcGllbnRzVG9Bc24xIiwiX2VuY3J5cHRlZENvbnRlbnRUb0FzbjEiLCJmaW5kUmVjaXBpZW50Iiwic0F0dHIiLCJyIiwickF0dHIiLCJtYXRjaCIsImoiLCJyZWNpcGllbnQiLCJwcml2S2V5IiwiZGVzQ0JDIiwiY3JlYXRlQnVmZmVyIiwiYWRkUmVjaXBpZW50IiwicHVibGljS2V5IiwiZW5jcnlwdCIsImNpcGhlciIsImtleUxlbiIsIml2TGVuIiwiY2lwaEZuIiwiYWVzIiwiY3JlYXRlRW5jcnlwdGlvbkNpcGhlciIsImRlcyIsInJhbmRvbSIsInBhcmFtZXRlciIsImNpcGgiLCJjb3B5IiwiZmluaXNoIiwib3V0cHV0IiwiX3JlY2lwaWVudEZyb21Bc24xIiwicmVjaXBpZW50SW5mb1ZhbGlkYXRvciIsImNoYXJDb2RlQXQiLCJSRE5BdHRyaWJ1dGVzQXNBcnJheSIsInNlcmlhbCIsInRvSGV4IiwiZW5jQWxnb3JpdGhtIiwiZW5jUGFyYW1ldGVyIiwiZW5jS2V5IiwiX3JlY2lwaWVudFRvQXNuMSIsImRpc3Rpbmd1aXNoZWROYW1lVG9Bc24xIiwiaGV4VG9CeXRlcyIsImluZm9zIiwicmV0IiwiX3NpZ25lckZyb21Bc24xIiwic2lnbmVySW5mb1ZhbGlkYXRvciIsInJ2YWwiLCJfc2lnbmVyVG9Bc24xIiwidmFsdWVzIiwiX3NpZ25lcnNGcm9tQXNuMSIsInNpZ25lckluZm9Bc24xcyIsImphbl8xXzE5NTAiLCJqYW5fMV8yMDUwIiwiZGF0ZSIsInRpbWVzdGFtcCIsInBhcnNlIiwiaXNOYU4iLCJ1dGNUaW1lVG9EYXRlIiwiZ2VuZXJhbGl6ZWRUaW1lVG9EYXRlIiwiVVRDVElNRSIsImRhdGVUb1V0Y1RpbWUiLCJHRU5FUkFMSVpFRFRJTUUiLCJkYXRlVG9HZW5lcmFsaXplZFRpbWUiLCJlYyIsInZhbGlkYXRvciIsImlzQXJyYXkiLCJjcmVhdGVEZWNyeXB0aW9uQ2lwaGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/pkcs7.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/pkcs7asn1.js":
/*!**************************************************!*\
  !*** ./node_modules/node-forge/lib/pkcs7asn1.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Javascript implementation of ASN.1 validators for PKCS#7 v1.5.\n *\n * @author Dave Longley\n * @author Stefan Siegl\n *\n * Copyright (c) 2012-2015 Digital Bazaar, Inc.\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n *\n * The ASN.1 representation of PKCS#7 is as follows\n * (see RFC #2315 for details, http://www.ietf.org/rfc/rfc2315.txt):\n *\n * A PKCS#7 message consists of a ContentInfo on root level, which may\n * contain any number of further ContentInfo nested into it.\n *\n * ContentInfo ::= SEQUENCE {\n *   contentType                ContentType,\n *   content               [0]  EXPLICIT ANY DEFINED BY contentType OPTIONAL\n * }\n *\n * ContentType ::= OBJECT IDENTIFIER\n *\n * EnvelopedData ::= SEQUENCE {\n *   version                    Version,\n *   recipientInfos             RecipientInfos,\n *   encryptedContentInfo       EncryptedContentInfo\n * }\n *\n * EncryptedData ::= SEQUENCE {\n *   version                    Version,\n *   encryptedContentInfo       EncryptedContentInfo\n * }\n *\n * id-signedData OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n *   us(840) rsadsi(113549) pkcs(1) pkcs7(7) 2 }\n *\n * SignedData ::= SEQUENCE {\n *   version           INTEGER,\n *   digestAlgorithms  DigestAlgorithmIdentifiers,\n *   contentInfo       ContentInfo,\n *   certificates      [0] IMPLICIT Certificates OPTIONAL,\n *   crls              [1] IMPLICIT CertificateRevocationLists OPTIONAL,\n *   signerInfos       SignerInfos\n * }\n *\n * SignerInfos ::= SET OF SignerInfo\n *\n * SignerInfo ::= SEQUENCE {\n *   version                    Version,\n *   issuerAndSerialNumber      IssuerAndSerialNumber,\n *   digestAlgorithm            DigestAlgorithmIdentifier,\n *   authenticatedAttributes    [0] IMPLICIT Attributes OPTIONAL,\n *   digestEncryptionAlgorithm  DigestEncryptionAlgorithmIdentifier,\n *   encryptedDigest            EncryptedDigest,\n *   unauthenticatedAttributes  [1] IMPLICIT Attributes OPTIONAL\n * }\n *\n * EncryptedDigest ::= OCTET STRING\n *\n * Attributes ::= SET OF Attribute\n *\n * Attribute ::= SEQUENCE {\n *   attrType    OBJECT IDENTIFIER,\n *   attrValues  SET OF AttributeValue\n * }\n *\n * AttributeValue ::= ANY\n *\n * Version ::= INTEGER\n *\n * RecipientInfos ::= SET OF RecipientInfo\n *\n * EncryptedContentInfo ::= SEQUENCE {\n *   contentType                 ContentType,\n *   contentEncryptionAlgorithm  ContentEncryptionAlgorithmIdentifier,\n *   encryptedContent       [0]  IMPLICIT EncryptedContent OPTIONAL\n * }\n *\n * ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier\n *\n * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\n * for the algorithm, if any. In the case of AES and DES3, there is only one,\n * the IV.\n *\n * AlgorithmIdentifer ::= SEQUENCE {\n *    algorithm OBJECT IDENTIFIER,\n *    parameters ANY DEFINED BY algorithm OPTIONAL\n * }\n *\n * EncryptedContent ::= OCTET STRING\n *\n * RecipientInfo ::= SEQUENCE {\n *   version                     Version,\n *   issuerAndSerialNumber       IssuerAndSerialNumber,\n *   keyEncryptionAlgorithm      KeyEncryptionAlgorithmIdentifier,\n *   encryptedKey                EncryptedKey\n * }\n *\n * IssuerAndSerialNumber ::= SEQUENCE {\n *   issuer                      Name,\n *   serialNumber                CertificateSerialNumber\n * }\n *\n * CertificateSerialNumber ::= INTEGER\n *\n * KeyEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier\n *\n * EncryptedKey ::= OCTET STRING\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./asn1 */ \"(rsc)/./node_modules/node-forge/lib/asn1.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\n// shortcut for ASN.1 API\nvar asn1 = forge.asn1;\n// shortcut for PKCS#7 API\nvar p7v = module.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};\nforge.pkcs7 = forge.pkcs7 || {};\nforge.pkcs7.asn1 = p7v;\nvar contentInfoValidator = {\n    name: \"ContentInfo\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"ContentInfo.ContentType\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OID,\n            constructed: false,\n            capture: \"contentType\"\n        },\n        {\n            name: \"ContentInfo.content\",\n            tagClass: asn1.Class.CONTEXT_SPECIFIC,\n            type: 0,\n            constructed: true,\n            optional: true,\n            captureAsn1: \"content\"\n        }\n    ]\n};\np7v.contentInfoValidator = contentInfoValidator;\nvar encryptedContentInfoValidator = {\n    name: \"EncryptedContentInfo\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"EncryptedContentInfo.contentType\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OID,\n            constructed: false,\n            capture: \"contentType\"\n        },\n        {\n            name: \"EncryptedContentInfo.contentEncryptionAlgorithm\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    name: \"EncryptedContentInfo.contentEncryptionAlgorithm.algorithm\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OID,\n                    constructed: false,\n                    capture: \"encAlgorithm\"\n                },\n                {\n                    name: \"EncryptedContentInfo.contentEncryptionAlgorithm.parameter\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    captureAsn1: \"encParameter\"\n                }\n            ]\n        },\n        {\n            name: \"EncryptedContentInfo.encryptedContent\",\n            tagClass: asn1.Class.CONTEXT_SPECIFIC,\n            type: 0,\n            /* The PKCS#7 structure output by OpenSSL somewhat differs from what\n     * other implementations do generate.\n     *\n     * OpenSSL generates a structure like this:\n     * SEQUENCE {\n     *    ...\n     *    [0]\n     *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38\n     *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45\n     *       ...\n     * }\n     *\n     * Whereas other implementations (and this PKCS#7 module) generate:\n     * SEQUENCE {\n     *    ...\n     *    [0] {\n     *       OCTET STRING\n     *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38\n     *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45\n     *          ...\n     *    }\n     * }\n     *\n     * In order to support both, we just capture the context specific\n     * field here.  The OCTET STRING bit is removed below.\n     */ capture: \"encryptedContent\",\n            captureAsn1: \"encryptedContentAsn1\"\n        }\n    ]\n};\np7v.envelopedDataValidator = {\n    name: \"EnvelopedData\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"EnvelopedData.Version\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"version\"\n        },\n        {\n            name: \"EnvelopedData.RecipientInfos\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SET,\n            constructed: true,\n            captureAsn1: \"recipientInfos\"\n        }\n    ].concat(encryptedContentInfoValidator)\n};\np7v.encryptedDataValidator = {\n    name: \"EncryptedData\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"EncryptedData.Version\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"version\"\n        }\n    ].concat(encryptedContentInfoValidator)\n};\nvar signerValidator = {\n    name: \"SignerInfo\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"SignerInfo.version\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false\n        },\n        {\n            name: \"SignerInfo.issuerAndSerialNumber\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    name: \"SignerInfo.issuerAndSerialNumber.issuer\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.SEQUENCE,\n                    constructed: true,\n                    captureAsn1: \"issuer\"\n                },\n                {\n                    name: \"SignerInfo.issuerAndSerialNumber.serialNumber\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.INTEGER,\n                    constructed: false,\n                    capture: \"serial\"\n                }\n            ]\n        },\n        {\n            name: \"SignerInfo.digestAlgorithm\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    name: \"SignerInfo.digestAlgorithm.algorithm\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OID,\n                    constructed: false,\n                    capture: \"digestAlgorithm\"\n                },\n                {\n                    name: \"SignerInfo.digestAlgorithm.parameter\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    constructed: false,\n                    captureAsn1: \"digestParameter\",\n                    optional: true\n                }\n            ]\n        },\n        {\n            name: \"SignerInfo.authenticatedAttributes\",\n            tagClass: asn1.Class.CONTEXT_SPECIFIC,\n            type: 0,\n            constructed: true,\n            optional: true,\n            capture: \"authenticatedAttributes\"\n        },\n        {\n            name: \"SignerInfo.digestEncryptionAlgorithm\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            capture: \"signatureAlgorithm\"\n        },\n        {\n            name: \"SignerInfo.encryptedDigest\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OCTETSTRING,\n            constructed: false,\n            capture: \"signature\"\n        },\n        {\n            name: \"SignerInfo.unauthenticatedAttributes\",\n            tagClass: asn1.Class.CONTEXT_SPECIFIC,\n            type: 1,\n            constructed: true,\n            optional: true,\n            capture: \"unauthenticatedAttributes\"\n        }\n    ]\n};\np7v.signedDataValidator = {\n    name: \"SignedData\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"SignedData.Version\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"version\"\n        },\n        {\n            name: \"SignedData.DigestAlgorithms\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SET,\n            constructed: true,\n            captureAsn1: \"digestAlgorithms\"\n        },\n        contentInfoValidator,\n        {\n            name: \"SignedData.Certificates\",\n            tagClass: asn1.Class.CONTEXT_SPECIFIC,\n            type: 0,\n            optional: true,\n            captureAsn1: \"certificates\"\n        },\n        {\n            name: \"SignedData.CertificateRevocationLists\",\n            tagClass: asn1.Class.CONTEXT_SPECIFIC,\n            type: 1,\n            optional: true,\n            captureAsn1: \"crls\"\n        },\n        {\n            name: \"SignedData.SignerInfos\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SET,\n            capture: \"signerInfos\",\n            optional: true,\n            value: [\n                signerValidator\n            ]\n        }\n    ]\n};\np7v.recipientInfoValidator = {\n    name: \"RecipientInfo\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"RecipientInfo.version\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"version\"\n        },\n        {\n            name: \"RecipientInfo.issuerAndSerial\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    name: \"RecipientInfo.issuerAndSerial.issuer\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.SEQUENCE,\n                    constructed: true,\n                    captureAsn1: \"issuer\"\n                },\n                {\n                    name: \"RecipientInfo.issuerAndSerial.serialNumber\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.INTEGER,\n                    constructed: false,\n                    capture: \"serial\"\n                }\n            ]\n        },\n        {\n            name: \"RecipientInfo.keyEncryptionAlgorithm\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    name: \"RecipientInfo.keyEncryptionAlgorithm.algorithm\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OID,\n                    constructed: false,\n                    capture: \"encAlgorithm\"\n                },\n                {\n                    name: \"RecipientInfo.keyEncryptionAlgorithm.parameter\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    constructed: false,\n                    captureAsn1: \"encParameter\",\n                    optional: true\n                }\n            ]\n        },\n        {\n            name: \"RecipientInfo.encryptedKey\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OCTETSTRING,\n            constructed: false,\n            capture: \"encKey\"\n        }\n    ]\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGtjczdhc24xLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0R0M7QUFDRCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUix5QkFBeUI7QUFDekIsSUFBSUMsT0FBT0YsTUFBTUUsSUFBSTtBQUVyQiwwQkFBMEI7QUFDMUIsSUFBSUMsTUFBTUMsT0FBT0MsT0FBTyxHQUFHTCxNQUFNTSxTQUFTLEdBQUdOLE1BQU1NLFNBQVMsSUFBSSxDQUFDO0FBQ2pFTixNQUFNTyxLQUFLLEdBQUdQLE1BQU1PLEtBQUssSUFBSSxDQUFDO0FBQzlCUCxNQUFNTyxLQUFLLENBQUNMLElBQUksR0FBR0M7QUFFbkIsSUFBSUssdUJBQXVCO0lBQ3pCQyxNQUFNO0lBQ05DLFVBQVVSLEtBQUtTLEtBQUssQ0FBQ0MsU0FBUztJQUM5QkMsTUFBTVgsS0FBS1ksSUFBSSxDQUFDQyxRQUFRO0lBQ3hCQyxhQUFhO0lBQ2JDLE9BQU87UUFBQztZQUNOUixNQUFNO1lBQ05DLFVBQVVSLEtBQUtTLEtBQUssQ0FBQ0MsU0FBUztZQUM5QkMsTUFBTVgsS0FBS1ksSUFBSSxDQUFDSSxHQUFHO1lBQ25CRixhQUFhO1lBQ2JHLFNBQVM7UUFDWDtRQUFHO1lBQ0RWLE1BQU07WUFDTkMsVUFBVVIsS0FBS1MsS0FBSyxDQUFDUyxnQkFBZ0I7WUFDckNQLE1BQU07WUFDTkcsYUFBYTtZQUNiSyxVQUFVO1lBQ1ZDLGFBQWE7UUFDZjtLQUFFO0FBQ0o7QUFDQW5CLElBQUlLLG9CQUFvQixHQUFHQTtBQUUzQixJQUFJZSxnQ0FBZ0M7SUFDbENkLE1BQU07SUFDTkMsVUFBVVIsS0FBS1MsS0FB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LFVBQVVSLEtBQUtTLEtBQUssQ0FBQ0MsU0FBUztZQUM5QkMsTUFBTVgsS0FBS1ksSUFBSSxDQUFDQyxRQUFRO1lBQ3hCQyxhQUFhO1lBQ2JDLE9BQU87Z0JBQUM7b0JBQ05SLE1BQU07b0JBQ05DLFVBQVVSLEtBQUtTLEtBQUssQ0FBQ0MsU0FBUztvQkFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0MsUUFBUTtvQkFDeEJDLGFBQWE7b0JBQ2JNLGFBQWE7Z0JBQ2Y7Z0JBQUc7b0JBQ0RiLE1BQU07b0JBQ05DLFVBQVVSLEtBQUtTLEtBQUssQ0FBQ0MsU0FBUztvQkFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ1csT0FBTztvQkFDdkJULGFBQWE7b0JBQ2JHLFNBQVM7Z0JBQ1g7YUFBRTtRQUNKO1FBQUc7WUFDRFYsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0MsUUFBUTtZQUN4QkMsYUFBYTtZQUNiQyxPQUFPO2dCQUFDO29CQUNOUixNQUFNO29CQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7b0JBQzlCQyxNQUFNWCxLQUFLWSxJQUFJLENBQUNJLEdBQUc7b0JBQ25CRixhQUFhO29CQUNiRyxTQUFTO2dCQUNYO2dCQUFHO29CQUNEVixNQUFNO29CQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7b0JBQzlCSSxhQUFhO29CQUNiTSxhQUFhO29CQUNiRCxVQUFVO2dCQUNaO2FBQUU7UUFDSjtRQUFHO1lBQ0RaLE1BQU07WUFDTkMsVUFBVVIsS0FBS1MsS0FBSyxDQUFDQyxTQUFTO1lBQzlCQyxNQUFNWCxLQUFLWSxJQUFJLENBQUNnQixXQUFXO1lBQzNCZCxhQUFhO1lBQ2JHLFNBQVM7UUFDWDtLQUFFO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGtjczdhc24xLmpzPzY5OTciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIEFTTi4xIHZhbGlkYXRvcnMgZm9yIFBLQ1MjNyB2MS41LlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBUaGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgUEtDUyM3IGlzIGFzIGZvbGxvd3NcbiAqIChzZWUgUkZDICMyMzE1IGZvciBkZXRhaWxzLCBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMzE1LnR4dCk6XG4gKlxuICogQSBQS0NTIzcgbWVzc2FnZSBjb25zaXN0cyBvZiBhIENvbnRlbnRJbmZvIG9uIHJvb3QgbGV2ZWwsIHdoaWNoIG1heVxuICogY29udGFpbiBhbnkgbnVtYmVyIG9mIGZ1cnRoZXIgQ29udGVudEluZm8gbmVzdGVkIGludG8gaXQuXG4gKlxuICogQ29udGVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgY29udGVudFR5cGUgICAgICAgICAgICAgICAgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnQgICAgICAgICAgICAgICBbMF0gIEVYUExJQ0lUIEFOWSBERUZJTkVEIEJZIGNvbnRlbnRUeXBlIE9QVElPTkFMXG4gKiB9XG4gKlxuICogQ29udGVudFR5cGUgOjo9IE9CSkVDVCBJREVOVElGSUVSXG4gKlxuICogRW52ZWxvcGVkRGF0YSA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgICBWZXJzaW9uLFxuICogICByZWNpcGllbnRJbmZvcyAgICAgICAgICAgICBSZWNpcGllbnRJbmZvcyxcbiAqICAgZW5jcnlwdGVkQ29udGVudEluZm8gICAgICAgRW5jcnlwdGVkQ29udGVudEluZm9cbiAqIH1cbiAqXG4gKiBFbmNyeXB0ZWREYXRhIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIGVuY3J5cHRlZENvbnRlbnRJbmZvICAgICAgIEVuY3J5cHRlZENvbnRlbnRJbmZvXG4gKiB9XG4gKlxuICogaWQtc2lnbmVkRGF0YSBPQkpFQ1QgSURFTlRJRklFUiA6Oj0geyBpc28oMSkgbWVtYmVyLWJvZHkoMilcbiAqICAgdXMoODQwKSByc2Fkc2koMTEzNTQ5KSBwa2NzKDEpIHBrY3M3KDcpIDIgfVxuICpcbiAqIFNpZ25lZERhdGEgOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgICAgSU5URUdFUixcbiAqICAgZGlnZXN0QWxnb3JpdGhtcyAgRGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcnMsXG4gKiAgIGNvbnRlbnRJbmZvICAgICAgIENvbnRlbnRJbmZvLFxuICogICBjZXJ0aWZpY2F0ZXMgICAgICBbMF0gSU1QTElDSVQgQ2VydGlmaWNhdGVzIE9QVElPTkFMLFxuICogICBjcmxzICAgICAgICAgICAgICBbMV0gSU1QTElDSVQgQ2VydGlmaWNhdGVSZXZvY2F0aW9uTGlzdHMgT1BUSU9OQUwsXG4gKiAgIHNpZ25lckluZm9zICAgICAgIFNpZ25lckluZm9zXG4gKiB9XG4gKlxuICogU2lnbmVySW5mb3MgOjo9IFNFVCBPRiBTaWduZXJJbmZvXG4gKlxuICogU2lnbmVySW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgICBWZXJzaW9uLFxuICogICBpc3N1ZXJBbmRTZXJpYWxOdW1iZXIgICAgICBJc3N1ZXJBbmRTZXJpYWxOdW1iZXIsXG4gKiAgIGRpZ2VzdEFsZ29yaXRobSAgICAgICAgICAgIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzICAgIFswXSBJTVBMSUNJVCBBdHRyaWJ1dGVzIE9QVElPTkFMLFxuICogICBkaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtICBEaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkRGlnZXN0ICAgICAgICAgICAgRW5jcnlwdGVkRGlnZXN0LFxuICogICB1bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzICBbMV0gSU1QTElDSVQgQXR0cmlidXRlcyBPUFRJT05BTFxuICogfVxuICpcbiAqIEVuY3J5cHRlZERpZ2VzdCA6Oj0gT0NURVQgU1RSSU5HXG4gKlxuICogQXR0cmlidXRlcyA6Oj0gU0VUIE9GIEF0dHJpYnV0ZVxuICpcbiAqIEF0dHJpYnV0ZSA6Oj0gU0VRVUVOQ0Uge1xuICogICBhdHRyVHlwZSAgICBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgYXR0clZhbHVlcyAgU0VUIE9GIEF0dHJpYnV0ZVZhbHVlXG4gKiB9XG4gKlxuICogQXR0cmlidXRlVmFsdWUgOjo9IEFOWVxuICpcbiAqIFZlcnNpb24gOjo9IElOVEVHRVJcbiAqXG4gKiBSZWNpcGllbnRJbmZvcyA6Oj0gU0VUIE9GIFJlY2lwaWVudEluZm9cbiAqXG4gKiBFbmNyeXB0ZWRDb250ZW50SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBjb250ZW50VHlwZSAgICAgICAgICAgICAgICAgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnRFbmNyeXB0aW9uQWxnb3JpdGhtICBDb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGVuY3J5cHRlZENvbnRlbnQgICAgICAgWzBdICBJTVBMSUNJVCBFbmNyeXB0ZWRDb250ZW50IE9QVElPTkFMXG4gKiB9XG4gKlxuICogQ29udGVudEVuY3J5cHRpb25BbGdvcml0aG1JZGVudGlmaWVyIDo6PSBBbGdvcml0aG1JZGVudGlmaWVyXG4gKlxuICogVGhlIEFsZ29yaXRobUlkZW50aWZpZXIgY29udGFpbnMgYW4gT2JqZWN0IElkZW50aWZpZXIgKE9JRCkgYW5kIHBhcmFtZXRlcnNcbiAqIGZvciB0aGUgYWxnb3JpdGhtLCBpZiBhbnkuIEluIHRoZSBjYXNlIG9mIEFFUyBhbmQgREVTMywgdGhlcmUgaXMgb25seSBvbmUsXG4gKiB0aGUgSVYuXG4gKlxuICogQWxnb3JpdGhtSWRlbnRpZmVyIDo6PSBTRVFVRU5DRSB7XG4gKiAgICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgICBwYXJhbWV0ZXJzIEFOWSBERUZJTkVEIEJZIGFsZ29yaXRobSBPUFRJT05BTFxuICogfVxuICpcbiAqIEVuY3J5cHRlZENvbnRlbnQgOjo9IE9DVEVUIFNUUklOR1xuICpcbiAqIFJlY2lwaWVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIGlzc3VlckFuZFNlcmlhbE51bWJlciAgICAgICBJc3N1ZXJBbmRTZXJpYWxOdW1iZXIsXG4gKiAgIGtleUVuY3J5cHRpb25BbGdvcml0aG0gICAgICBLZXlFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkS2V5ICAgICAgICAgICAgICAgIEVuY3J5cHRlZEtleVxuICogfVxuICpcbiAqIElzc3VlckFuZFNlcmlhbE51bWJlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBpc3N1ZXIgICAgICAgICAgICAgICAgICAgICAgTmFtZSxcbiAqICAgc2VyaWFsTnVtYmVyICAgICAgICAgICAgICAgIENlcnRpZmljYXRlU2VyaWFsTnVtYmVyXG4gKiB9XG4gKlxuICogQ2VydGlmaWNhdGVTZXJpYWxOdW1iZXIgOjo9IElOVEVHRVJcbiAqXG4gKiBLZXlFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllciA6Oj0gQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIEVuY3J5cHRlZEtleSA6Oj0gT0NURVQgU1RSSU5HXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vYXNuMScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIHNob3J0Y3V0IGZvciBBU04uMSBBUElcbnZhciBhc24xID0gZm9yZ2UuYXNuMTtcblxuLy8gc2hvcnRjdXQgZm9yIFBLQ1MjNyBBUElcbnZhciBwN3YgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnBrY3M3YXNuMSA9IGZvcmdlLnBrY3M3YXNuMSB8fCB7fTtcbmZvcmdlLnBrY3M3ID0gZm9yZ2UucGtjczcgfHwge307XG5mb3JnZS5wa2NzNy5hc24xID0gcDd2O1xuXG52YXIgY29udGVudEluZm9WYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdDb250ZW50SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0NvbnRlbnRJbmZvLkNvbnRlbnRUeXBlJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2NvbnRlbnRUeXBlJ1xuICB9LCB7XG4gICAgbmFtZTogJ0NvbnRlbnRJbmZvLmNvbnRlbnQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ2NvbnRlbnQnXG4gIH1dXG59O1xucDd2LmNvbnRlbnRJbmZvVmFsaWRhdG9yID0gY29udGVudEluZm9WYWxpZGF0b3I7XG5cbnZhciBlbmNyeXB0ZWRDb250ZW50SW5mb1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0VuY3J5cHRlZENvbnRlbnRJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnRW5jcnlwdGVkQ29udGVudEluZm8uY29udGVudFR5cGUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnY29udGVudFR5cGUnXG4gIH0sIHtcbiAgICBuYW1lOiAnRW5jcnlwdGVkQ29udGVudEluZm8uY29udGVudEVuY3J5cHRpb25BbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnRW5jcnlwdGVkQ29udGVudEluZm8uY29udGVudEVuY3J5cHRpb25BbGdvcml0aG0uYWxnb3JpdGhtJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnZW5jQWxnb3JpdGhtJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdFbmNyeXB0ZWRDb250ZW50SW5mby5jb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobS5wYXJhbWV0ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgY2FwdHVyZUFzbjE6ICdlbmNQYXJhbWV0ZXInXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdFbmNyeXB0ZWRDb250ZW50SW5mby5lbmNyeXB0ZWRDb250ZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDAsXG4gICAgLyogVGhlIFBLQ1MjNyBzdHJ1Y3R1cmUgb3V0cHV0IGJ5IE9wZW5TU0wgc29tZXdoYXQgZGlmZmVycyBmcm9tIHdoYXRcbiAgICAgKiBvdGhlciBpbXBsZW1lbnRhdGlvbnMgZG8gZ2VuZXJhdGUuXG4gICAgICpcbiAgICAgKiBPcGVuU1NMIGdlbmVyYXRlcyBhIHN0cnVjdHVyZSBsaWtlIHRoaXM6XG4gICAgICogU0VRVUVOQ0Uge1xuICAgICAqICAgIC4uLlxuICAgICAqICAgIFswXVxuICAgICAqICAgICAgIDI2IERBIDY3IEQyIDE3IDlDIDQ1IDNDIEIxIDJBIEE4IDU5IDJGIDI5IDMzIDM4XG4gICAgICogICAgICAgQzMgQzMgREYgODYgNzEgNzQgN0EgMTkgOUYgNDAgRDAgMjkgQkUgODUgOTAgNDVcbiAgICAgKiAgICAgICAuLi5cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBXaGVyZWFzIG90aGVyIGltcGxlbWVudGF0aW9ucyAoYW5kIHRoaXMgUEtDUyM3IG1vZHVsZSkgZ2VuZXJhdGU6XG4gICAgICogU0VRVUVOQ0Uge1xuICAgICAqICAgIC4uLlxuICAgICAqICAgIFswXSB7XG4gICAgICogICAgICAgT0NURVQgU1RSSU5HXG4gICAgICogICAgICAgICAgMjYgREEgNjcgRDIgMTcgOUMgNDUgM0MgQjEgMkEgQTggNTkgMkYgMjkgMzMgMzhcbiAgICAgKiAgICAgICAgICBDMyBDMyBERiA4NiA3MSA3NCA3QSAxOSA5RiA0MCBEMCAyOSBCRSA4NSA5MCA0NVxuICAgICAqICAgICAgICAgIC4uLlxuICAgICAqICAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBJbiBvcmRlciB0byBzdXBwb3J0IGJvdGgsIHdlIGp1c3QgY2FwdHVyZSB0aGUgY29udGV4dCBzcGVjaWZpY1xuICAgICAqIGZpZWxkIGhlcmUuICBUaGUgT0NURVQgU1RSSU5HIGJpdCBpcyByZW1vdmVkIGJlbG93LlxuICAgICAqL1xuICAgIGNhcHR1cmU6ICdlbmNyeXB0ZWRDb250ZW50JyxcbiAgICBjYXB0dXJlQXNuMTogJ2VuY3J5cHRlZENvbnRlbnRBc24xJ1xuICB9XVxufTtcblxucDd2LmVudmVsb3BlZERhdGFWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdFbnZlbG9wZWREYXRhJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnRW52ZWxvcGVkRGF0YS5WZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICd2ZXJzaW9uJ1xuICB9LCB7XG4gICAgbmFtZTogJ0VudmVsb3BlZERhdGEuUmVjaXBpZW50SW5mb3MnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VULFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAncmVjaXBpZW50SW5mb3MnXG4gIH1dLmNvbmNhdChlbmNyeXB0ZWRDb250ZW50SW5mb1ZhbGlkYXRvcilcbn07XG5cbnA3di5lbmNyeXB0ZWREYXRhVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnRW5jcnlwdGVkRGF0YScsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0VuY3J5cHRlZERhdGEuVmVyc2lvbicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAndmVyc2lvbidcbiAgfV0uY29uY2F0KGVuY3J5cHRlZENvbnRlbnRJbmZvVmFsaWRhdG9yKVxufTtcblxudmFyIHNpZ25lclZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ1NpZ25lckluZm8nLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdTaWduZXJJbmZvLnZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2VcbiAgfSwge1xuICAgIG5hbWU6ICdTaWduZXJJbmZvLmlzc3VlckFuZFNlcmlhbE51bWJlcicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdTaWduZXJJbmZvLmlzc3VlckFuZFNlcmlhbE51bWJlci5pc3N1ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ2lzc3VlcidcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnU2lnbmVySW5mby5pc3N1ZXJBbmRTZXJpYWxOdW1iZXIuc2VyaWFsTnVtYmVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3NlcmlhbCdcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8uZGlnZXN0QWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ1NpZ25lckluZm8uZGlnZXN0QWxnb3JpdGhtLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2RpZ2VzdEFsZ29yaXRobSdcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnU2lnbmVySW5mby5kaWdlc3RBbGdvcml0aG0ucGFyYW1ldGVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnZGlnZXN0UGFyYW1ldGVyJyxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdTaWduZXJJbmZvLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDAsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgY2FwdHVyZTogJ2F1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8uZGlnZXN0RW5jcnlwdGlvbkFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBjYXB0dXJlOiAnc2lnbmF0dXJlQWxnb3JpdGhtJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8uZW5jcnlwdGVkRGlnZXN0JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnc2lnbmF0dXJlJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8udW5hdXRoZW50aWNhdGVkQXR0cmlidXRlcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAxLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmU6ICd1bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzJ1xuICB9XVxufTtcblxucDd2LnNpZ25lZERhdGFWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdTaWduZWREYXRhJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnU2lnbmVkRGF0YS5WZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICd2ZXJzaW9uJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lZERhdGEuRGlnZXN0QWxnb3JpdGhtcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICdkaWdlc3RBbGdvcml0aG1zJ1xuICB9LFxuICBjb250ZW50SW5mb1ZhbGlkYXRvcixcbiAge1xuICAgIG5hbWU6ICdTaWduZWREYXRhLkNlcnRpZmljYXRlcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAwLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnY2VydGlmaWNhdGVzJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lZERhdGEuQ2VydGlmaWNhdGVSZXZvY2F0aW9uTGlzdHMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ2NybHMnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVkRGF0YS5TaWduZXJJbmZvcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgY2FwdHVyZTogJ3NpZ25lckluZm9zJyxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICB2YWx1ZTogW3NpZ25lclZhbGlkYXRvcl1cbiAgfV1cbn07XG5cbnA3di5yZWNpcGllbnRJbmZvVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnUmVjaXBpZW50SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ1JlY2lwaWVudEluZm8udmVyc2lvbicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAndmVyc2lvbidcbiAgfSwge1xuICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmlzc3VlckFuZFNlcmlhbCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmlzc3VlckFuZFNlcmlhbC5pc3N1ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ2lzc3VlcidcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnUmVjaXBpZW50SW5mby5pc3N1ZXJBbmRTZXJpYWwuc2VyaWFsTnVtYmVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3NlcmlhbCdcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ1JlY2lwaWVudEluZm8ua2V5RW5jcnlwdGlvbkFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmtleUVuY3J5cHRpb25BbGdvcml0aG0uYWxnb3JpdGhtJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnZW5jQWxnb3JpdGhtJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmtleUVuY3J5cHRpb25BbGdvcml0aG0ucGFyYW1ldGVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnZW5jUGFyYW1ldGVyJyxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmVuY3J5cHRlZEtleScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2VuY0tleSdcbiAgfV1cbn07XG4iXSwibmFtZXMiOlsiZm9yZ2UiLCJyZXF1aXJlIiwiYXNuMSIsInA3diIsIm1vZHVsZSIsImV4cG9ydHMiLCJwa2NzN2FzbjEiLCJwa2NzNyIsImNvbnRlbnRJbmZvVmFsaWRhdG9yIiwibmFtZSIsInRhZ0NsYXNzIiwiQ2xhc3MiLCJVTklWRVJTQUwiLCJ0eXBlIiwiVHlwZSIsIlNFUVVFTkNFIiwiY29uc3RydWN0ZWQiLCJ2YWx1ZSIsIk9JRCIsImNhcHR1cmUiLCJDT05URVhUX1NQRUNJRklDIiwib3B0aW9uYWwiLCJjYXB0dXJlQXNuMSIsImVuY3J5cHRlZENvbnRlbnRJbmZvVmFsaWRhdG9yIiwiZW52ZWxvcGVkRGF0YVZhbGlkYXRvciIsIklOVEVHRVIiLCJTRVQiLCJjb25jYXQiLCJlbmNyeXB0ZWREYXRhVmFsaWRhdG9yIiwic2lnbmVyVmFsaWRhdG9yIiwiT0NURVRTVFJJTkciLCJzaWduZWREYXRhVmFsaWRhdG9yIiwicmVjaXBpZW50SW5mb1ZhbGlkYXRvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/pkcs7asn1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/pki.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/pki.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Javascript implementation of a basic Public Key Infrastructure, including\n * support for RSA public and private keys.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./asn1 */ \"(rsc)/./node_modules/node-forge/lib/asn1.js\");\n__webpack_require__(/*! ./oids */ \"(rsc)/./node_modules/node-forge/lib/oids.js\");\n__webpack_require__(/*! ./pbe */ \"(rsc)/./node_modules/node-forge/lib/pbe.js\");\n__webpack_require__(/*! ./pem */ \"(rsc)/./node_modules/node-forge/lib/pem.js\");\n__webpack_require__(/*! ./pbkdf2 */ \"(rsc)/./node_modules/node-forge/lib/pbkdf2.js\");\n__webpack_require__(/*! ./pkcs12 */ \"(rsc)/./node_modules/node-forge/lib/pkcs12.js\");\n__webpack_require__(/*! ./pss */ \"(rsc)/./node_modules/node-forge/lib/pss.js\");\n__webpack_require__(/*! ./rsa */ \"(rsc)/./node_modules/node-forge/lib/rsa.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\n__webpack_require__(/*! ./x509 */ \"(rsc)/./node_modules/node-forge/lib/x509.js\");\n// shortcut for asn.1 API\nvar asn1 = forge.asn1;\n/* Public Key Infrastructure (PKI) implementation. */ var pki = module.exports = forge.pki = forge.pki || {};\n/**\n * NOTE: THIS METHOD IS DEPRECATED. Use pem.decode() instead.\n *\n * Converts PEM-formatted data to DER.\n *\n * @param pem the PEM-formatted data.\n *\n * @return the DER-formatted data.\n */ pki.pemToDer = function(pem) {\n    var msg = forge.pem.decode(pem)[0];\n    if (msg.procType && msg.procType.type === \"ENCRYPTED\") {\n        throw new Error(\"Could not convert PEM to DER; PEM is encrypted.\");\n    }\n    return forge.util.createBuffer(msg.body);\n};\n/**\n * Converts an RSA private key from PEM format.\n *\n * @param pem the PEM-formatted private key.\n *\n * @return the private key.\n */ pki.privateKeyFromPem = function(pem) {\n    var msg = forge.pem.decode(pem)[0];\n    if (msg.type !== \"PRIVATE KEY\" && msg.type !== \"RSA PRIVATE KEY\") {\n        var error = new Error(\"Could not convert private key from PEM; PEM \" + 'header type is not \"PRIVATE KEY\" or \"RSA PRIVATE KEY\".');\n        error.headerType = msg.type;\n        throw error;\n    }\n    if (msg.procType && msg.procType.type === \"ENCRYPTED\") {\n        throw new Error(\"Could not convert private key from PEM; PEM is encrypted.\");\n    }\n    // convert DER to ASN.1 object\n    var obj = asn1.fromDer(msg.body);\n    return pki.privateKeyFromAsn1(obj);\n};\n/**\n * Converts an RSA private key to PEM format.\n *\n * @param key the private key.\n * @param maxline the maximum characters per line, defaults to 64.\n *\n * @return the PEM-formatted private key.\n */ pki.privateKeyToPem = function(key, maxline) {\n    // convert to ASN.1, then DER, then PEM-encode\n    var msg = {\n        type: \"RSA PRIVATE KEY\",\n        body: asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()\n    };\n    return forge.pem.encode(msg, {\n        maxline: maxline\n    });\n};\n/**\n * Converts a PrivateKeyInfo to PEM format.\n *\n * @param pki the PrivateKeyInfo.\n * @param maxline the maximum characters per line, defaults to 64.\n *\n * @return the PEM-formatted private key.\n */ pki.privateKeyInfoToPem = function(pki, maxline) {\n    // convert to DER, then PEM-encode\n    var msg = {\n        type: \"PRIVATE KEY\",\n        body: asn1.toDer(pki).getBytes()\n    };\n    return forge.pem.encode(msg, {\n        maxline: maxline\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGtpLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0NBT0M7QUFDRCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUix5QkFBeUI7QUFDekIsSUFBSUMsT0FBT0YsTUFBTUUsSUFBSTtBQUVyQixtREFBbUQsR0FDbkQsSUFBSUMsTUFBTUMsT0FBT0MsT0FBTyxHQUFHTCxNQUFNRyxHQUFHLEdBQUdILE1BQU1HLEdBQUcsSUFBSSxDQUFDO0FBRXJEOzs7Ozs7OztDQVFDLEdBQ0RBLElBQUlHLFFBQVEsR0FBRyxTQUFTQyxHQUFHO0lBQ3pCLElBQUlDLE1BQU1SLE1BQU1PLEdBQUcsQ0FBQ0UsTUFBTSxDQUFDRixJQUFJLENBQUMsRUFBRTtJQUNsQyxJQUFHQyxJQUFJRSxRQUFRLElBQUlGLElBQUlFLFFBQVEsQ0FBQ0MsSUFBSSxLQUFLLGFBQWE7UUFDcEQsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBQ0EsT0FBT1osTUFBTWEsSUFBSSxDQUFDQyxZQUFZLENBQUNOLElBQUlPLElBQUk7QUFDekM7QUFFQTs7Ozs7O0NBTUMsR0FDRFosSUFBSWEsaUJBQWlCLEdBQUcsU0FBU1QsR0FBRztJQUNsQyxJQUFJQyxNQUFNUixNQUFNTyxHQUFHLENBQUNFLE1BQU0sQ0FBQ0YsSUFBSSxDQUFDLEVBQUU7SUFFbEMsSUFBR0MsSUFBSUcsSUFBSSxLQUFLLGlCQUFpQkgsSUFBSUcsSUFBSSxLQUFLLG1CQUFtQjtRQUMvRCxJQUFJTSxRQUFRLElBQUlMLE1BQU0saURBQ3BCO1FBQ0ZLLE1BQU1DLFVBQVUsR0FBR1YsSUFBSUcsSUFBSTtRQUMzQixNQUFNTTtJQUNSO0lBQ0EsSUFBR1QsSUFBSUUsUUFBUSxJQUFJRixJQUFJRSxRQUFRLENBQUNDLElBQUksS0FBSyxhQUFhO1FBQ3BELE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJQUVBLDhCQUE4QjtJQUM5QixJQUFJTyxNQUFNakIsS0FBS2tCLE9BQU8sQ0FBQ1osSUFBSU8sSUFBSTtJQUUvQixPQUFPWixJQUFJa0Isa0JBQWtCLENBQUNGO0FBQ2hDO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNEaEIsSUFBSW1CLGVBQWUsR0FBRyxTQUFTQyxHQUFHLEVBQUVDLE9BQU87SUFDekMsOENBQThDO0lBQzlDLElBQUloQixNQUFNO1FBQ1JHLE1BQU07UUFDTkksTUFBTWIsS0FBS3VCLEtBQUssQ0FBQ3RCLElBQUl1QixnQkFBZ0IsQ0FBQ0gsTUFBTUksUUFBUTtJQUN0RDtJQUNBLE9BQU8zQixNQUFNTyxHQUFHLENBQUNxQixNQUFNLENBQUNwQixLQUFLO1FBQUNnQixTQUFTQTtJQUFPO0FBQ2hEO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNEckIsSUFBSTBCLG1CQUFtQixHQUFHLFNBQVMxQixHQUFHLEVBQUVxQixPQUFPO0lBQzdDLGtDQUFrQztJQUNsQyxJQUFJaEIsTUFBTTtRQUNSRyxNQUFNO1FBQ05JLE1BQU1iLEtBQUt1QixLQUFLLENBQUN0QixLQUFLd0IsUUFBUTtJQUNoQztJQUNBLE9BQU8zQixNQUFNTyxHQUFHLENBQUNxQixNQUFNLENBQUNwQixLQUFLO1FBQUNnQixTQUFTQTtJQUFPO0FBQ2hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3BraS5qcz85MzMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBhIGJhc2ljIFB1YmxpYyBLZXkgSW5mcmFzdHJ1Y3R1cmUsIGluY2x1ZGluZ1xuICogc3VwcG9ydCBmb3IgUlNBIHB1YmxpYyBhbmQgcHJpdmF0ZSBrZXlzLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTMgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9hc24xJyk7XG5yZXF1aXJlKCcuL29pZHMnKTtcbnJlcXVpcmUoJy4vcGJlJyk7XG5yZXF1aXJlKCcuL3BlbScpO1xucmVxdWlyZSgnLi9wYmtkZjInKTtcbnJlcXVpcmUoJy4vcGtjczEyJyk7XG5yZXF1aXJlKCcuL3BzcycpO1xucmVxdWlyZSgnLi9yc2EnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xucmVxdWlyZSgnLi94NTA5Jyk7XG5cbi8vIHNob3J0Y3V0IGZvciBhc24uMSBBUElcbnZhciBhc24xID0gZm9yZ2UuYXNuMTtcblxuLyogUHVibGljIEtleSBJbmZyYXN0cnVjdHVyZSAoUEtJKSBpbXBsZW1lbnRhdGlvbi4gKi9cbnZhciBwa2kgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnBraSA9IGZvcmdlLnBraSB8fCB7fTtcblxuLyoqXG4gKiBOT1RFOiBUSElTIE1FVEhPRCBJUyBERVBSRUNBVEVELiBVc2UgcGVtLmRlY29kZSgpIGluc3RlYWQuXG4gKlxuICogQ29udmVydHMgUEVNLWZvcm1hdHRlZCBkYXRhIHRvIERFUi5cbiAqXG4gKiBAcGFyYW0gcGVtIHRoZSBQRU0tZm9ybWF0dGVkIGRhdGEuXG4gKlxuICogQHJldHVybiB0aGUgREVSLWZvcm1hdHRlZCBkYXRhLlxuICovXG5wa2kucGVtVG9EZXIgPSBmdW5jdGlvbihwZW0pIHtcbiAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUocGVtKVswXTtcbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgUEVNIHRvIERFUjsgUEVNIGlzIGVuY3J5cHRlZC4nKTtcbiAgfVxuICByZXR1cm4gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIobXNnLmJvZHkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBSU0EgcHJpdmF0ZSBrZXkgZnJvbSBQRU0gZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBwZW0gdGhlIFBFTS1mb3JtYXR0ZWQgcHJpdmF0ZSBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgcHJpdmF0ZSBrZXkuXG4gKi9cbnBraS5wcml2YXRlS2V5RnJvbVBlbSA9IGZ1bmN0aW9uKHBlbSkge1xuICB2YXIgbXNnID0gZm9yZ2UucGVtLmRlY29kZShwZW0pWzBdO1xuXG4gIGlmKG1zZy50eXBlICE9PSAnUFJJVkFURSBLRVknICYmIG1zZy50eXBlICE9PSAnUlNBIFBSSVZBVEUgS0VZJykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgcHJpdmF0ZSBrZXkgZnJvbSBQRU07IFBFTSAnICtcbiAgICAgICdoZWFkZXIgdHlwZSBpcyBub3QgXCJQUklWQVRFIEtFWVwiIG9yIFwiUlNBIFBSSVZBVEUgS0VZXCIuJyk7XG4gICAgZXJyb3IuaGVhZGVyVHlwZSA9IG1zZy50eXBlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIGlmKG1zZy5wcm9jVHlwZSAmJiBtc2cucHJvY1R5cGUudHlwZSA9PT0gJ0VOQ1JZUFRFRCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IHByaXZhdGUga2V5IGZyb20gUEVNOyBQRU0gaXMgZW5jcnlwdGVkLicpO1xuICB9XG5cbiAgLy8gY29udmVydCBERVIgdG8gQVNOLjEgb2JqZWN0XG4gIHZhciBvYmogPSBhc24xLmZyb21EZXIobXNnLmJvZHkpO1xuXG4gIHJldHVybiBwa2kucHJpdmF0ZUtleUZyb21Bc24xKG9iaik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJTQSBwcml2YXRlIGtleSB0byBQRU0gZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHByaXZhdGUga2V5LlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSwgZGVmYXVsdHMgdG8gNjQuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBwcml2YXRlIGtleS5cbiAqL1xucGtpLnByaXZhdGVLZXlUb1BlbSA9IGZ1bmN0aW9uKGtleSwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIEFTTi4xLCB0aGVuIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ1JTQSBQUklWQVRFIEtFWScsXG4gICAgYm9keTogYXNuMS50b0Rlcihwa2kucHJpdmF0ZUtleVRvQXNuMShrZXkpKS5nZXRCeXRlcygpXG4gIH07XG4gIHJldHVybiBmb3JnZS5wZW0uZW5jb2RlKG1zZywge21heGxpbmU6IG1heGxpbmV9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQcml2YXRlS2V5SW5mbyB0byBQRU0gZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBwa2kgdGhlIFByaXZhdGVLZXlJbmZvLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSwgZGVmYXVsdHMgdG8gNjQuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBwcml2YXRlIGtleS5cbiAqL1xucGtpLnByaXZhdGVLZXlJbmZvVG9QZW0gPSBmdW5jdGlvbihwa2ksIG1heGxpbmUpIHtcbiAgLy8gY29udmVydCB0byBERVIsIHRoZW4gUEVNLWVuY29kZVxuICB2YXIgbXNnID0ge1xuICAgIHR5cGU6ICdQUklWQVRFIEtFWScsXG4gICAgYm9keTogYXNuMS50b0Rlcihwa2kpLmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnLCB7bWF4bGluZTogbWF4bGluZX0pO1xufTtcbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJhc24xIiwicGtpIiwibW9kdWxlIiwiZXhwb3J0cyIsInBlbVRvRGVyIiwicGVtIiwibXNnIiwiZGVjb2RlIiwicHJvY1R5cGUiLCJ0eXBlIiwiRXJyb3IiLCJ1dGlsIiwiY3JlYXRlQnVmZmVyIiwiYm9keSIsInByaXZhdGVLZXlGcm9tUGVtIiwiZXJyb3IiLCJoZWFkZXJUeXBlIiwib2JqIiwiZnJvbURlciIsInByaXZhdGVLZXlGcm9tQXNuMSIsInByaXZhdGVLZXlUb1BlbSIsImtleSIsIm1heGxpbmUiLCJ0b0RlciIsInByaXZhdGVLZXlUb0FzbjEiLCJnZXRCeXRlcyIsImVuY29kZSIsInByaXZhdGVLZXlJbmZvVG9QZW0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/pki.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/prime.js":
/*!**********************************************!*\
  !*** ./node_modules/node-forge/lib/prime.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Prime number generation API.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2014 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\n__webpack_require__(/*! ./jsbn */ \"(rsc)/./node_modules/node-forge/lib/jsbn.js\");\n__webpack_require__(/*! ./random */ \"(rsc)/./node_modules/node-forge/lib/random.js\");\n(function() {\n    // forge.prime already defined\n    if (forge.prime) {\n        module.exports = forge.prime;\n        return;\n    }\n    /* PRIME API */ var prime = module.exports = forge.prime = forge.prime || {};\n    var BigInteger = forge.jsbn.BigInteger;\n    // primes are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29\n    var GCD_30_DELTA = [\n        6,\n        4,\n        2,\n        4,\n        2,\n        4,\n        6,\n        2\n    ];\n    var THIRTY = new BigInteger(null);\n    THIRTY.fromInt(30);\n    var op_or = function(x, y) {\n        return x | y;\n    };\n    /**\n * Generates a random probable prime with the given number of bits.\n *\n * Alternative algorithms can be specified by name as a string or as an\n * object with custom options like so:\n *\n * {\n *   name: 'PRIMEINC',\n *   options: {\n *     maxBlockTime: <the maximum amount of time to block the main\n *       thread before allowing I/O other JS to run>,\n *     millerRabinTests: <the number of miller-rabin tests to run>,\n *     workerScript: <the worker script URL>,\n *     workers: <the number of web workers (if supported) to use,\n *       -1 to use estimated cores minus one>.\n *     workLoad: the size of the work load, ie: number of possible prime\n *       numbers for each web worker to check per work assignment,\n *       (default: 100).\n *   }\n * }\n *\n * @param bits the number of bits for the prime number.\n * @param options the options to use.\n *          [algorithm] the algorithm to use (default: 'PRIMEINC').\n *          [prng] a custom crypto-secure pseudo-random number generator to use,\n *            that must define \"getBytesSync\".\n *\n * @return callback(err, num) called once the operation completes.\n */ prime.generateProbablePrime = function(bits, options, callback) {\n        if (typeof options === \"function\") {\n            callback = options;\n            options = {};\n        }\n        options = options || {};\n        // default to PRIMEINC algorithm\n        var algorithm = options.algorithm || \"PRIMEINC\";\n        if (typeof algorithm === \"string\") {\n            algorithm = {\n                name: algorithm\n            };\n        }\n        algorithm.options = algorithm.options || {};\n        // create prng with api that matches BigInteger secure random\n        var prng = options.prng || forge.random;\n        var rng = {\n            // x is an array to fill with bytes\n            nextBytes: function(x) {\n                var b = prng.getBytesSync(x.length);\n                for(var i = 0; i < x.length; ++i){\n                    x[i] = b.charCodeAt(i);\n                }\n            }\n        };\n        if (algorithm.name === \"PRIMEINC\") {\n            return primeincFindPrime(bits, rng, algorithm.options, callback);\n        }\n        throw new Error(\"Invalid prime generation algorithm: \" + algorithm.name);\n    };\n    function primeincFindPrime(bits, rng, options, callback) {\n        if (\"workers\" in options) {\n            return primeincFindPrimeWithWorkers(bits, rng, options, callback);\n        }\n        return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);\n    }\n    function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {\n        // initialize random number\n        var num = generateRandom(bits, rng);\n        /* Note: All primes are of the form 30k+i for i < 30 and gcd(30, i)=1. The\n  number we are given is always aligned at 30k + 1. Each time the number is\n  determined not to be prime we add to get to the next 'i', eg: if the number\n  was at 30k + 1 we add 6. */ var deltaIdx = 0;\n        // get required number of MR tests\n        var mrTests = getMillerRabinTests(num.bitLength());\n        if (\"millerRabinTests\" in options) {\n            mrTests = options.millerRabinTests;\n        }\n        // find prime nearest to 'num' for maxBlockTime ms\n        // 10 ms gives 5ms of leeway for other calculations before dropping\n        // below 60fps (1000/60 == 16.67), but in reality, the number will\n        // likely be higher due to an 'atomic' big int modPow\n        var maxBlockTime = 10;\n        if (\"maxBlockTime\" in options) {\n            maxBlockTime = options.maxBlockTime;\n        }\n        _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);\n    }\n    function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {\n        var start = +new Date();\n        do {\n            // overflow, regenerate random number\n            if (num.bitLength() > bits) {\n                num = generateRandom(bits, rng);\n            }\n            // do primality test\n            if (num.isProbablePrime(mrTests)) {\n                return callback(null, num);\n            }\n            // get next potential prime\n            num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);\n        }while (maxBlockTime < 0 || +new Date() - start < maxBlockTime);\n        // keep trying later\n        forge.util.setImmediate(function() {\n            _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);\n        });\n    }\n    // NOTE: This algorithm is indeterminate in nature because workers\n    // run in parallel looking at different segments of numbers. Even if this\n    // algorithm is run twice with the same input from a predictable RNG, it\n    // may produce different outputs.\n    function primeincFindPrimeWithWorkers(bits, rng, options, callback) {\n        // web workers unavailable\n        if (typeof Worker === \"undefined\") {\n            return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);\n        }\n        // initialize random number\n        var num = generateRandom(bits, rng);\n        // use web workers to generate keys\n        var numWorkers = options.workers;\n        var workLoad = options.workLoad || 100;\n        var range = workLoad * 30 / 8;\n        var workerScript = options.workerScript || \"forge/prime.worker.js\";\n        if (numWorkers === -1) {\n            return forge.util.estimateCores(function(err, cores) {\n                if (err) {\n                    // default to 2\n                    cores = 2;\n                }\n                numWorkers = cores - 1;\n                generate();\n            });\n        }\n        generate();\n        function generate() {\n            // require at least 1 worker\n            numWorkers = Math.max(1, numWorkers);\n            // TODO: consider optimizing by starting workers outside getPrime() ...\n            // note that in order to clean up they will have to be made internally\n            // asynchronous which may actually be slower\n            // start workers immediately\n            var workers = [];\n            for(var i = 0; i < numWorkers; ++i){\n                // FIXME: fix path or use blob URLs\n                workers[i] = new Worker(workerScript);\n            }\n            var running = numWorkers;\n            // listen for requests from workers and assign ranges to find prime\n            for(var i = 0; i < numWorkers; ++i){\n                workers[i].addEventListener(\"message\", workerMessage);\n            }\n            /* Note: The distribution of random numbers is unknown. Therefore, each\n    web worker is continuously allocated a range of numbers to check for a\n    random number until one is found.\n\n    Every 30 numbers will be checked just 8 times, because prime numbers\n    have the form:\n\n    30k+i, for i < 30 and gcd(30, i)=1 (there are 8 values of i for this)\n\n    Therefore, if we want a web worker to run N checks before asking for\n    a new range of numbers, each range must contain N*30/8 numbers.\n\n    For 100 checks (workLoad), this is a range of 375. */ var found = false;\n            function workerMessage(e) {\n                // ignore message, prime already found\n                if (found) {\n                    return;\n                }\n                --running;\n                var data = e.data;\n                if (data.found) {\n                    // terminate all workers\n                    for(var i = 0; i < workers.length; ++i){\n                        workers[i].terminate();\n                    }\n                    found = true;\n                    return callback(null, new BigInteger(data.prime, 16));\n                }\n                // overflow, regenerate random number\n                if (num.bitLength() > bits) {\n                    num = generateRandom(bits, rng);\n                }\n                // assign new range to check\n                var hex = num.toString(16);\n                // start prime search\n                e.target.postMessage({\n                    hex: hex,\n                    workLoad: workLoad\n                });\n                num.dAddOffset(range, 0);\n            }\n        }\n    }\n    /**\n * Generates a random number using the given number of bits and RNG.\n *\n * @param bits the number of bits for the number.\n * @param rng the random number generator to use.\n *\n * @return the random number.\n */ function generateRandom(bits, rng) {\n        var num = new BigInteger(bits, rng);\n        // force MSB set\n        var bits1 = bits - 1;\n        if (!num.testBit(bits1)) {\n            num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);\n        }\n        // align number on 30k+1 boundary\n        num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);\n        return num;\n    }\n    /**\n * Returns the required number of Miller-Rabin tests to generate a\n * prime with an error probability of (1/2)^80.\n *\n * See Handbook of Applied Cryptography Chapter 4, Table 4.4.\n *\n * @param bits the bit size.\n *\n * @return the required number of iterations.\n */ function getMillerRabinTests(bits) {\n        if (bits <= 100) return 27;\n        if (bits <= 150) return 18;\n        if (bits <= 200) return 15;\n        if (bits <= 250) return 12;\n        if (bits <= 300) return 9;\n        if (bits <= 350) return 8;\n        if (bits <= 400) return 7;\n        if (bits <= 500) return 6;\n        if (bits <= 600) return 5;\n        if (bits <= 800) return 4;\n        if (bits <= 1250) return 3;\n        return 2;\n    }\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcHJpbWUuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVA7SUFFRCw4QkFBOEI7SUFDOUIsSUFBR0QsTUFBTUUsS0FBSyxFQUFFO1FBQ2RDLE9BQU9DLE9BQU8sR0FBR0osTUFBTUUsS0FBSztRQUM1QjtJQUNGO0lBRUEsYUFBYSxHQUNiLElBQUlBLFFBQVFDLE9BQU9DLE9BQU8sR0FBR0osTUFBTUUsS0FBSyxHQUFHRixNQUFNRSxLQUFLLElBQUksQ0FBQztJQUUzRCxJQUFJRyxhQUFhTCxNQUFNTSxJQUFJLENBQUNELFVBQVU7SUFFdEMsd0RBQXdEO0lBQ3hELElBQUlFLGVBQWU7UUFBQztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO0tBQUU7SUFDM0MsSUFBSUMsU0FBUyxJQUFJSCxXQUFXO0lBQzVCRyxPQUFPQyxPQUFPLENBQUM7SUFDZixJQUFJQyxRQUFRLFNBQVNDLENBQUMsRUFBRUMsQ0FBQztRQUFHLE9BQU9ELElBQUVDO0lBQUU7SUFFdkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0QkMsR0FDRFYsTUFBTVcscUJBQXFCLEdBQUcsU0FBU0MsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLFFBQVE7UUFDNUQsSUFBRyxPQUFPRCxZQUFZLFlBQVk7WUFDaENDLFdBQVdEO1lBQ1hBLFVBQVUsQ0FBQztRQUNiO1FBQ0FBLFVBQVVBLFdBQVcsQ0FBQztRQUV0QixnQ0FBZ0M7UUFDaEMsSUFBSUUsWUFBWUYsUUFBUUUsU0FBUyxJQUFJO1FBQ3JDLElBQUcsT0FBT0EsY0FBYyxVQUFVO1lBQ2hDQSxZQUFZO2dCQUFDQyxNQUFNRDtZQUFTO1FBQzlCO1FBQ0FBLFVBQVVGLE9BQU8sR0FBR0UsVUFBVUYsT0FBTyxJQUFJLENBQUM7UUFFMUMsNkRBQTZEO1FBQzdELElBQUlJLE9BQU9KLFFBQVFJLElBQUksSUFBSW5CLE1BQU1vQixNQUFNO1FBQ3ZDLElBQUlDLE1BQU07WUFDUixtQ0FBbUM7WUFDbkNDLFdBQVcsU0FBU1gsQ0FBQztnQkFDbkIsSUFBSVksSUFBSUosS0FBS0ssWUFBWSxDQUFDYixFQUFFYyxNQUFNO2dCQUNsQyxJQUFJLElBQUlDLElBQUksR0FBR0EsSUFBSWYsRUFBRWMsTUFBTSxFQUFFLEVBQUVDLEVBQUc7b0JBQ2hDZixDQUFDLENBQUNlLEVBQUUsR0FBR0gsRUFBRUksVUFBVSxDQUFDRDtnQkFDdEI7WUFDRjtRQUNGO1FBRUEsSUFBR1QsVUFBVUMsSUFBSSxLQUFLLFlBQVk7WUFDaEMsT0FBT1Usa0JBQWtCZCxNQUFNTyxLQUFLSixVQUFVRixPQUFPLEVBQUVDO1FBQ3pEO1FBRUEsTUFBTSxJQUFJYSxNQUFNLHlDQUF5Q1osVUFBVUMsSUFBSTtJQUN6RTtJQUVBLFNBQVNVLGtCQUFrQmQsSUFBSSxFQUFFTyxHQUFHLEVBQUVOLE9BQU8sRUFBRUMsUUFBUTtRQUNyRCxJQUFHLGFBQWFELFNBQVM7WUFDdkIsT0FBT2UsNkJBQTZCaEIsTUFBTU8sS0FBS04sU0FBU0M7UUFDMUQ7UUFDQSxPQUFPZSxnQ0FBZ0NqQixNQUFNTyxLQUFLTixTQUFTQztJQUM3RDtJQUVBLFNBQVNlLGdDQUFnQ2pCLElBQUksRUFBRU8sR0FBRyxFQUFFTixPQUFPLEVBQUVDLFFBQVE7UUFDbkUsMkJBQTJCO1FBQzNCLElBQUlnQixNQUFNQyxlQUFlbkIsTUFBTU87UUFFL0I7OzsyQkFHeUIsR0FDekIsSUFBSWEsV0FBVztRQUVmLGtDQUFrQztRQUNsQyxJQUFJQyxVQUFVQyxvQkFBb0JKLElBQUlLLFNBQVM7UUFDL0MsSUFBRyxzQkFBc0J0QixTQUFTO1lBQ2hDb0IsVUFBVXBCLFFBQVF1QixnQkFBZ0I7UUFDcEM7UUFFQSxrREFBa0Q7UUFDbEQsbUVBQW1FO1FBQ25FLGtFQUFrRTtRQUNsRSxxREFBcUQ7UUFDckQsSUFBSUMsZUFBZTtRQUNuQixJQUFHLGtCQUFrQnhCLFNBQVM7WUFDNUJ3QixlQUFleEIsUUFBUXdCLFlBQVk7UUFDckM7UUFFQUMsVUFBVVIsS0FBS2xCLE1BQU1PLEtBQUthLFVBQVVDLFNBQVNJLGNBQWN2QjtJQUM3RDtJQUVBLFNBQVN3QixVQUFVUixHQUFHLEVBQUVsQixJQUFJLEVBQUVPLEdBQUcsRUFBRWEsUUFBUSxFQUFFQyxPQUFPLEVBQUVJLFlBQVksRUFBRXZCLFFBQVE7UUFDMUUsSUFBSXlCLFFBQVEsQ0FBQyxJQUFJQztRQUNqQixHQUFHO1lBQ0QscUNBQXFDO1lBQ3JDLElBQUdWLElBQUlLLFNBQVMsS0FBS3ZCLE1BQU07Z0JBQ3pCa0IsTUFBTUMsZUFBZW5CLE1BQU1PO1lBQzdCO1lBQ0Esb0JBQW9CO1lBQ3BCLElBQUdXLElBQUlXLGVBQWUsQ0FBQ1IsVUFBVTtnQkFDL0IsT0FBT25CLFNBQVMsTUFBTWdCO1lBQ3hCO1lBQ0EsMkJBQTJCO1lBQzNCQSxJQUFJWSxVQUFVLENBQUNyQyxZQUFZLENBQUMyQixhQUFhLEVBQUUsRUFBRTtRQUMvQyxRQUFRSyxlQUFlLEtBQU0sQ0FBQyxJQUFJRyxTQUFTRCxRQUFRRixjQUFlO1FBRWxFLG9CQUFvQjtRQUNwQnZDLE1BQU02QyxJQUFJLENBQUNDLFlBQVksQ0FBQztZQUN0Qk4sVUFBVVIsS0FBS2xCLE1BQU1PLEtBQUthLFVBQVVDLFNBQVNJLGNBQWN2QjtRQUM3RDtJQUNGO0lBRUEsa0VBQWtFO0lBQ2xFLHlFQUF5RTtJQUN6RSx3RUFBd0U7SUFDeEUsaUNBQWlDO0lBQ2pDLFNBQVNjLDZCQUE2QmhCLElBQUksRUFBRU8sR0FBRyxFQUFFTixPQUFPLEVBQUVDLFFBQVE7UUFDaEUsMEJBQTBCO1FBQzFCLElBQUcsT0FBTytCLFdBQVcsYUFBYTtZQUNoQyxPQUFPaEIsZ0NBQWdDakIsTUFBTU8sS0FBS04sU0FBU0M7UUFDN0Q7UUFFQSwyQkFBMkI7UUFDM0IsSUFBSWdCLE1BQU1DLGVBQWVuQixNQUFNTztRQUUvQixtQ0FBbUM7UUFDbkMsSUFBSTJCLGFBQWFqQyxRQUFRa0MsT0FBTztRQUNoQyxJQUFJQyxXQUFXbkMsUUFBUW1DLFFBQVEsSUFBSTtRQUNuQyxJQUFJQyxRQUFRRCxXQUFXLEtBQUs7UUFDNUIsSUFBSUUsZUFBZXJDLFFBQVFxQyxZQUFZLElBQUk7UUFDM0MsSUFBR0osZUFBZSxDQUFDLEdBQUc7WUFDcEIsT0FBT2hELE1BQU02QyxJQUFJLENBQUNRLGFBQWEsQ0FBQyxTQUFTQyxHQUFHLEVBQUVDLEtBQUs7Z0JBQ2pELElBQUdELEtBQUs7b0JBQ04sZUFBZTtvQkFDZkMsUUFBUTtnQkFDVjtnQkFDQVAsYUFBYU8sUUFBUTtnQkFDckJDO1lBQ0Y7UUFDRjtRQUNBQTtRQUVBLFNBQVNBO1lBQ1AsNEJBQTRCO1lBQzVCUixhQUFhUyxLQUFLQyxHQUFHLENBQUMsR0FBR1Y7WUFFekIsdUVBQXVFO1lBQ3ZFLHNFQUFzRTtZQUN0RSw0Q0FBNEM7WUFFNUMsNEJBQTRCO1lBQzVCLElBQUlDLFVBQVUsRUFBRTtZQUNoQixJQUFJLElBQUl2QixJQUFJLEdBQUdBLElBQUlzQixZQUFZLEVBQUV0QixFQUFHO2dCQUNsQyxtQ0FBbUM7Z0JBQ25DdUIsT0FBTyxDQUFDdkIsRUFBRSxHQUFHLElBQUlxQixPQUFPSztZQUMxQjtZQUNBLElBQUlPLFVBQVVYO1lBRWQsbUVBQW1FO1lBQ25FLElBQUksSUFBSXRCLElBQUksR0FBR0EsSUFBSXNCLFlBQVksRUFBRXRCLEVBQUc7Z0JBQ2xDdUIsT0FBTyxDQUFDdkIsRUFBRSxDQUFDa0MsZ0JBQWdCLENBQUMsV0FBV0M7WUFDekM7WUFFQTs7Ozs7Ozs7Ozs7O3VEQVltRCxHQUVuRCxJQUFJQyxRQUFRO1lBQ1osU0FBU0QsY0FBY0UsQ0FBQztnQkFDdEIsc0NBQXNDO2dCQUN0QyxJQUFHRCxPQUFPO29CQUNSO2dCQUNGO2dCQUVBLEVBQUVIO2dCQUNGLElBQUlLLE9BQU9ELEVBQUVDLElBQUk7Z0JBQ2pCLElBQUdBLEtBQUtGLEtBQUssRUFBRTtvQkFDYix3QkFBd0I7b0JBQ3hCLElBQUksSUFBSXBDLElBQUksR0FBR0EsSUFBSXVCLFFBQVF4QixNQUFNLEVBQUUsRUFBRUMsRUFBRzt3QkFDdEN1QixPQUFPLENBQUN2QixFQUFFLENBQUN1QyxTQUFTO29CQUN0QjtvQkFDQUgsUUFBUTtvQkFDUixPQUFPOUMsU0FBUyxNQUFNLElBQUlYLFdBQVcyRCxLQUFLOUQsS0FBSyxFQUFFO2dCQUNuRDtnQkFFQSxxQ0FBcUM7Z0JBQ3JDLElBQUc4QixJQUFJSyxTQUFTLEtBQUt2QixNQUFNO29CQUN6QmtCLE1BQU1DLGVBQWVuQixNQUFNTztnQkFDN0I7Z0JBRUEsNEJBQTRCO2dCQUM1QixJQUFJNkMsTUFBTWxDLElBQUltQyxRQUFRLENBQUM7Z0JBRXZCLHFCQUFxQjtnQkFDckJKLEVBQUVLLE1BQU0sQ0FBQ0MsV0FBVyxDQUFDO29CQUNuQkgsS0FBS0E7b0JBQ0xoQixVQUFVQTtnQkFDWjtnQkFFQWxCLElBQUlZLFVBQVUsQ0FBQ08sT0FBTztZQUN4QjtRQUNGO0lBQ0Y7SUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU2xCLGVBQWVuQixJQUFJLEVBQUVPLEdBQUc7UUFDL0IsSUFBSVcsTUFBTSxJQUFJM0IsV0FBV1MsTUFBTU87UUFDL0IsZ0JBQWdCO1FBQ2hCLElBQUlpRCxRQUFReEQsT0FBTztRQUNuQixJQUFHLENBQUNrQixJQUFJdUMsT0FBTyxDQUFDRCxRQUFRO1lBQ3RCdEMsSUFBSXdDLFNBQVMsQ0FBQ25FLFdBQVdvRSxHQUFHLENBQUNDLFNBQVMsQ0FBQ0osUUFBUTVELE9BQU9zQjtRQUN4RDtRQUNBLGlDQUFpQztRQUNqQ0EsSUFBSVksVUFBVSxDQUFDLEtBQUtaLElBQUkyQyxHQUFHLENBQUNuRSxRQUFRb0UsU0FBUyxJQUFJO1FBQ2pELE9BQU81QztJQUNUO0lBRUE7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU0ksb0JBQW9CdEIsSUFBSTtRQUMvQixJQUFHQSxRQUFRLEtBQUssT0FBTztRQUN2QixJQUFHQSxRQUFRLEtBQUssT0FBTztRQUN2QixJQUFHQSxRQUFRLEtBQUssT0FBTztRQUN2QixJQUFHQSxRQUFRLEtBQUssT0FBTztRQUN2QixJQUFHQSxRQUFRLEtBQUssT0FBTztRQUN2QixJQUFHQSxRQUFRLEtBQUssT0FBTztRQUN2QixJQUFHQSxRQUFRLEtBQUssT0FBTztRQUN2QixJQUFHQSxRQUFRLEtBQUssT0FBTztRQUN2QixJQUFHQSxRQUFRLEtBQUssT0FBTztRQUN2QixJQUFHQSxRQUFRLEtBQUssT0FBTztRQUN2QixJQUFHQSxRQUFRLE1BQU0sT0FBTztRQUN4QixPQUFPO0lBQ1Q7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9wcmltZS5qcz9jMTcyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUHJpbWUgbnVtYmVyIGdlbmVyYXRpb24gQVBJLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xucmVxdWlyZSgnLi9qc2JuJyk7XG5yZXF1aXJlKCcuL3JhbmRvbScpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbi8vIGZvcmdlLnByaW1lIGFscmVhZHkgZGVmaW5lZFxuaWYoZm9yZ2UucHJpbWUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wcmltZTtcbiAgcmV0dXJuO1xufVxuXG4vKiBQUklNRSBBUEkgKi9cbnZhciBwcmltZSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucHJpbWUgPSBmb3JnZS5wcmltZSB8fCB7fTtcblxudmFyIEJpZ0ludGVnZXIgPSBmb3JnZS5qc2JuLkJpZ0ludGVnZXI7XG5cbi8vIHByaW1lcyBhcmUgMzBrK2kgZm9yIGkgPSAxLCA3LCAxMSwgMTMsIDE3LCAxOSwgMjMsIDI5XG52YXIgR0NEXzMwX0RFTFRBID0gWzYsIDQsIDIsIDQsIDIsIDQsIDYsIDJdO1xudmFyIFRISVJUWSA9IG5ldyBCaWdJbnRlZ2VyKG51bGwpO1xuVEhJUlRZLmZyb21JbnQoMzApO1xudmFyIG9wX29yID0gZnVuY3Rpb24oeCwgeSkge3JldHVybiB4fHk7fTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gcHJvYmFibGUgcHJpbWUgd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKlxuICogQWx0ZXJuYXRpdmUgYWxnb3JpdGhtcyBjYW4gYmUgc3BlY2lmaWVkIGJ5IG5hbWUgYXMgYSBzdHJpbmcgb3IgYXMgYW5cbiAqIG9iamVjdCB3aXRoIGN1c3RvbSBvcHRpb25zIGxpa2Ugc286XG4gKlxuICoge1xuICogICBuYW1lOiAnUFJJTUVJTkMnLFxuICogICBvcHRpb25zOiB7XG4gKiAgICAgbWF4QmxvY2tUaW1lOiA8dGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gYmxvY2sgdGhlIG1haW5cbiAqICAgICAgIHRocmVhZCBiZWZvcmUgYWxsb3dpbmcgSS9PIG90aGVyIEpTIHRvIHJ1bj4sXG4gKiAgICAgbWlsbGVyUmFiaW5UZXN0czogPHRoZSBudW1iZXIgb2YgbWlsbGVyLXJhYmluIHRlc3RzIHRvIHJ1bj4sXG4gKiAgICAgd29ya2VyU2NyaXB0OiA8dGhlIHdvcmtlciBzY3JpcHQgVVJMPixcbiAqICAgICB3b3JrZXJzOiA8dGhlIG51bWJlciBvZiB3ZWIgd29ya2VycyAoaWYgc3VwcG9ydGVkKSB0byB1c2UsXG4gKiAgICAgICAtMSB0byB1c2UgZXN0aW1hdGVkIGNvcmVzIG1pbnVzIG9uZT4uXG4gKiAgICAgd29ya0xvYWQ6IHRoZSBzaXplIG9mIHRoZSB3b3JrIGxvYWQsIGllOiBudW1iZXIgb2YgcG9zc2libGUgcHJpbWVcbiAqICAgICAgIG51bWJlcnMgZm9yIGVhY2ggd2ViIHdvcmtlciB0byBjaGVjayBwZXIgd29yayBhc3NpZ25tZW50LFxuICogICAgICAgKGRlZmF1bHQ6IDEwMCkuXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBAcGFyYW0gYml0cyB0aGUgbnVtYmVyIG9mIGJpdHMgZm9yIHRoZSBwcmltZSBudW1iZXIuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2UuXG4gKiAgICAgICAgICBbYWxnb3JpdGhtXSB0aGUgYWxnb3JpdGhtIHRvIHVzZSAoZGVmYXVsdDogJ1BSSU1FSU5DJykuXG4gKiAgICAgICAgICBbcHJuZ10gYSBjdXN0b20gY3J5cHRvLXNlY3VyZSBwc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgdG8gdXNlLFxuICogICAgICAgICAgICB0aGF0IG11c3QgZGVmaW5lIFwiZ2V0Qnl0ZXNTeW5jXCIuXG4gKlxuICogQHJldHVybiBjYWxsYmFjayhlcnIsIG51bSkgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKi9cbnByaW1lLmdlbmVyYXRlUHJvYmFibGVQcmltZSA9IGZ1bmN0aW9uKGJpdHMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBkZWZhdWx0IHRvIFBSSU1FSU5DIGFsZ29yaXRobVxuICB2YXIgYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgJ1BSSU1FSU5DJztcbiAgaWYodHlwZW9mIGFsZ29yaXRobSA9PT0gJ3N0cmluZycpIHtcbiAgICBhbGdvcml0aG0gPSB7bmFtZTogYWxnb3JpdGhtfTtcbiAgfVxuICBhbGdvcml0aG0ub3B0aW9ucyA9IGFsZ29yaXRobS5vcHRpb25zIHx8IHt9O1xuXG4gIC8vIGNyZWF0ZSBwcm5nIHdpdGggYXBpIHRoYXQgbWF0Y2hlcyBCaWdJbnRlZ2VyIHNlY3VyZSByYW5kb21cbiAgdmFyIHBybmcgPSBvcHRpb25zLnBybmcgfHwgZm9yZ2UucmFuZG9tO1xuICB2YXIgcm5nID0ge1xuICAgIC8vIHggaXMgYW4gYXJyYXkgdG8gZmlsbCB3aXRoIGJ5dGVzXG4gICAgbmV4dEJ5dGVzOiBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgYiA9IHBybmcuZ2V0Qnl0ZXNTeW5jKHgubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHhbaV0gPSBiLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGlmKGFsZ29yaXRobS5uYW1lID09PSAnUFJJTUVJTkMnKSB7XG4gICAgcmV0dXJuIHByaW1laW5jRmluZFByaW1lKGJpdHMsIHJuZywgYWxnb3JpdGhtLm9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmltZSBnZW5lcmF0aW9uIGFsZ29yaXRobTogJyArIGFsZ29yaXRobS5uYW1lKTtcbn07XG5cbmZ1bmN0aW9uIHByaW1laW5jRmluZFByaW1lKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYoJ3dvcmtlcnMnIGluIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHJpbWVpbmNGaW5kUHJpbWVXaXRoV29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuICByZXR1cm4gcHJpbWVpbmNGaW5kUHJpbWVXaXRob3V0V29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gcHJpbWVpbmNGaW5kUHJpbWVXaXRob3V0V29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIC8vIGluaXRpYWxpemUgcmFuZG9tIG51bWJlclxuICB2YXIgbnVtID0gZ2VuZXJhdGVSYW5kb20oYml0cywgcm5nKTtcblxuICAvKiBOb3RlOiBBbGwgcHJpbWVzIGFyZSBvZiB0aGUgZm9ybSAzMGsraSBmb3IgaSA8IDMwIGFuZCBnY2QoMzAsIGkpPTEuIFRoZVxuICBudW1iZXIgd2UgYXJlIGdpdmVuIGlzIGFsd2F5cyBhbGlnbmVkIGF0IDMwayArIDEuIEVhY2ggdGltZSB0aGUgbnVtYmVyIGlzXG4gIGRldGVybWluZWQgbm90IHRvIGJlIHByaW1lIHdlIGFkZCB0byBnZXQgdG8gdGhlIG5leHQgJ2knLCBlZzogaWYgdGhlIG51bWJlclxuICB3YXMgYXQgMzBrICsgMSB3ZSBhZGQgNi4gKi9cbiAgdmFyIGRlbHRhSWR4ID0gMDtcblxuICAvLyBnZXQgcmVxdWlyZWQgbnVtYmVyIG9mIE1SIHRlc3RzXG4gIHZhciBtclRlc3RzID0gZ2V0TWlsbGVyUmFiaW5UZXN0cyhudW0uYml0TGVuZ3RoKCkpO1xuICBpZignbWlsbGVyUmFiaW5UZXN0cycgaW4gb3B0aW9ucykge1xuICAgIG1yVGVzdHMgPSBvcHRpb25zLm1pbGxlclJhYmluVGVzdHM7XG4gIH1cblxuICAvLyBmaW5kIHByaW1lIG5lYXJlc3QgdG8gJ251bScgZm9yIG1heEJsb2NrVGltZSBtc1xuICAvLyAxMCBtcyBnaXZlcyA1bXMgb2YgbGVld2F5IGZvciBvdGhlciBjYWxjdWxhdGlvbnMgYmVmb3JlIGRyb3BwaW5nXG4gIC8vIGJlbG93IDYwZnBzICgxMDAwLzYwID09IDE2LjY3KSwgYnV0IGluIHJlYWxpdHksIHRoZSBudW1iZXIgd2lsbFxuICAvLyBsaWtlbHkgYmUgaGlnaGVyIGR1ZSB0byBhbiAnYXRvbWljJyBiaWcgaW50IG1vZFBvd1xuICB2YXIgbWF4QmxvY2tUaW1lID0gMTA7XG4gIGlmKCdtYXhCbG9ja1RpbWUnIGluIG9wdGlvbnMpIHtcbiAgICBtYXhCbG9ja1RpbWUgPSBvcHRpb25zLm1heEJsb2NrVGltZTtcbiAgfVxuXG4gIF9wcmltZWluYyhudW0sIGJpdHMsIHJuZywgZGVsdGFJZHgsIG1yVGVzdHMsIG1heEJsb2NrVGltZSwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBfcHJpbWVpbmMobnVtLCBiaXRzLCBybmcsIGRlbHRhSWR4LCBtclRlc3RzLCBtYXhCbG9ja1RpbWUsIGNhbGxiYWNrKSB7XG4gIHZhciBzdGFydCA9ICtuZXcgRGF0ZSgpO1xuICBkbyB7XG4gICAgLy8gb3ZlcmZsb3csIHJlZ2VuZXJhdGUgcmFuZG9tIG51bWJlclxuICAgIGlmKG51bS5iaXRMZW5ndGgoKSA+IGJpdHMpIHtcbiAgICAgIG51bSA9IGdlbmVyYXRlUmFuZG9tKGJpdHMsIHJuZyk7XG4gICAgfVxuICAgIC8vIGRvIHByaW1hbGl0eSB0ZXN0XG4gICAgaWYobnVtLmlzUHJvYmFibGVQcmltZShtclRlc3RzKSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bSk7XG4gICAgfVxuICAgIC8vIGdldCBuZXh0IHBvdGVudGlhbCBwcmltZVxuICAgIG51bS5kQWRkT2Zmc2V0KEdDRF8zMF9ERUxUQVtkZWx0YUlkeCsrICUgOF0sIDApO1xuICB9IHdoaWxlKG1heEJsb2NrVGltZSA8IDAgfHwgKCtuZXcgRGF0ZSgpIC0gc3RhcnQgPCBtYXhCbG9ja1RpbWUpKTtcblxuICAvLyBrZWVwIHRyeWluZyBsYXRlclxuICBmb3JnZS51dGlsLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICBfcHJpbWVpbmMobnVtLCBiaXRzLCBybmcsIGRlbHRhSWR4LCBtclRlc3RzLCBtYXhCbG9ja1RpbWUsIGNhbGxiYWNrKTtcbiAgfSk7XG59XG5cbi8vIE5PVEU6IFRoaXMgYWxnb3JpdGhtIGlzIGluZGV0ZXJtaW5hdGUgaW4gbmF0dXJlIGJlY2F1c2Ugd29ya2Vyc1xuLy8gcnVuIGluIHBhcmFsbGVsIGxvb2tpbmcgYXQgZGlmZmVyZW50IHNlZ21lbnRzIG9mIG51bWJlcnMuIEV2ZW4gaWYgdGhpc1xuLy8gYWxnb3JpdGhtIGlzIHJ1biB0d2ljZSB3aXRoIHRoZSBzYW1lIGlucHV0IGZyb20gYSBwcmVkaWN0YWJsZSBSTkcsIGl0XG4vLyBtYXkgcHJvZHVjZSBkaWZmZXJlbnQgb3V0cHV0cy5cbmZ1bmN0aW9uIHByaW1laW5jRmluZFByaW1lV2l0aFdvcmtlcnMoYml0cywgcm5nLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAvLyB3ZWIgd29ya2VycyB1bmF2YWlsYWJsZVxuICBpZih0eXBlb2YgV29ya2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBwcmltZWluY0ZpbmRQcmltZVdpdGhvdXRXb3JrZXJzKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSByYW5kb20gbnVtYmVyXG4gIHZhciBudW0gPSBnZW5lcmF0ZVJhbmRvbShiaXRzLCBybmcpO1xuXG4gIC8vIHVzZSB3ZWIgd29ya2VycyB0byBnZW5lcmF0ZSBrZXlzXG4gIHZhciBudW1Xb3JrZXJzID0gb3B0aW9ucy53b3JrZXJzO1xuICB2YXIgd29ya0xvYWQgPSBvcHRpb25zLndvcmtMb2FkIHx8IDEwMDtcbiAgdmFyIHJhbmdlID0gd29ya0xvYWQgKiAzMCAvIDg7XG4gIHZhciB3b3JrZXJTY3JpcHQgPSBvcHRpb25zLndvcmtlclNjcmlwdCB8fCAnZm9yZ2UvcHJpbWUud29ya2VyLmpzJztcbiAgaWYobnVtV29ya2VycyA9PT0gLTEpIHtcbiAgICByZXR1cm4gZm9yZ2UudXRpbC5lc3RpbWF0ZUNvcmVzKGZ1bmN0aW9uKGVyciwgY29yZXMpIHtcbiAgICAgIGlmKGVycikge1xuICAgICAgICAvLyBkZWZhdWx0IHRvIDJcbiAgICAgICAgY29yZXMgPSAyO1xuICAgICAgfVxuICAgICAgbnVtV29ya2VycyA9IGNvcmVzIC0gMTtcbiAgICAgIGdlbmVyYXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2VuZXJhdGUoKTtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAvLyByZXF1aXJlIGF0IGxlYXN0IDEgd29ya2VyXG4gICAgbnVtV29ya2VycyA9IE1hdGgubWF4KDEsIG51bVdvcmtlcnMpO1xuXG4gICAgLy8gVE9ETzogY29uc2lkZXIgb3B0aW1pemluZyBieSBzdGFydGluZyB3b3JrZXJzIG91dHNpZGUgZ2V0UHJpbWUoKSAuLi5cbiAgICAvLyBub3RlIHRoYXQgaW4gb3JkZXIgdG8gY2xlYW4gdXAgdGhleSB3aWxsIGhhdmUgdG8gYmUgbWFkZSBpbnRlcm5hbGx5XG4gICAgLy8gYXN5bmNocm9ub3VzIHdoaWNoIG1heSBhY3R1YWxseSBiZSBzbG93ZXJcblxuICAgIC8vIHN0YXJ0IHdvcmtlcnMgaW1tZWRpYXRlbHlcbiAgICB2YXIgd29ya2VycyA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyArK2kpIHtcbiAgICAgIC8vIEZJWE1FOiBmaXggcGF0aCBvciB1c2UgYmxvYiBVUkxzXG4gICAgICB3b3JrZXJzW2ldID0gbmV3IFdvcmtlcih3b3JrZXJTY3JpcHQpO1xuICAgIH1cbiAgICB2YXIgcnVubmluZyA9IG51bVdvcmtlcnM7XG5cbiAgICAvLyBsaXN0ZW4gZm9yIHJlcXVlc3RzIGZyb20gd29ya2VycyBhbmQgYXNzaWduIHJhbmdlcyB0byBmaW5kIHByaW1lXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgd29ya2Vyc1tpXS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgd29ya2VyTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyogTm90ZTogVGhlIGRpc3RyaWJ1dGlvbiBvZiByYW5kb20gbnVtYmVycyBpcyB1bmtub3duLiBUaGVyZWZvcmUsIGVhY2hcbiAgICB3ZWIgd29ya2VyIGlzIGNvbnRpbnVvdXNseSBhbGxvY2F0ZWQgYSByYW5nZSBvZiBudW1iZXJzIHRvIGNoZWNrIGZvciBhXG4gICAgcmFuZG9tIG51bWJlciB1bnRpbCBvbmUgaXMgZm91bmQuXG5cbiAgICBFdmVyeSAzMCBudW1iZXJzIHdpbGwgYmUgY2hlY2tlZCBqdXN0IDggdGltZXMsIGJlY2F1c2UgcHJpbWUgbnVtYmVyc1xuICAgIGhhdmUgdGhlIGZvcm06XG5cbiAgICAzMGsraSwgZm9yIGkgPCAzMCBhbmQgZ2NkKDMwLCBpKT0xICh0aGVyZSBhcmUgOCB2YWx1ZXMgb2YgaSBmb3IgdGhpcylcblxuICAgIFRoZXJlZm9yZSwgaWYgd2Ugd2FudCBhIHdlYiB3b3JrZXIgdG8gcnVuIE4gY2hlY2tzIGJlZm9yZSBhc2tpbmcgZm9yXG4gICAgYSBuZXcgcmFuZ2Ugb2YgbnVtYmVycywgZWFjaCByYW5nZSBtdXN0IGNvbnRhaW4gTiozMC84IG51bWJlcnMuXG5cbiAgICBGb3IgMTAwIGNoZWNrcyAod29ya0xvYWQpLCB0aGlzIGlzIGEgcmFuZ2Ugb2YgMzc1LiAqL1xuXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gd29ya2VyTWVzc2FnZShlKSB7XG4gICAgICAvLyBpZ25vcmUgbWVzc2FnZSwgcHJpbWUgYWxyZWFkeSBmb3VuZFxuICAgICAgaWYoZm91bmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAtLXJ1bm5pbmc7XG4gICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcbiAgICAgIGlmKGRhdGEuZm91bmQpIHtcbiAgICAgICAgLy8gdGVybWluYXRlIGFsbCB3b3JrZXJzXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB3b3JrZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgd29ya2Vyc1tpXS50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBuZXcgQmlnSW50ZWdlcihkYXRhLnByaW1lLCAxNikpO1xuICAgICAgfVxuXG4gICAgICAvLyBvdmVyZmxvdywgcmVnZW5lcmF0ZSByYW5kb20gbnVtYmVyXG4gICAgICBpZihudW0uYml0TGVuZ3RoKCkgPiBiaXRzKSB7XG4gICAgICAgIG51bSA9IGdlbmVyYXRlUmFuZG9tKGJpdHMsIHJuZyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFzc2lnbiBuZXcgcmFuZ2UgdG8gY2hlY2tcbiAgICAgIHZhciBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuXG4gICAgICAvLyBzdGFydCBwcmltZSBzZWFyY2hcbiAgICAgIGUudGFyZ2V0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgaGV4OiBoZXgsXG4gICAgICAgIHdvcmtMb2FkOiB3b3JrTG9hZFxuICAgICAgfSk7XG5cbiAgICAgIG51bS5kQWRkT2Zmc2V0KHJhbmdlLCAwKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIHVzaW5nIHRoZSBnaXZlbiBudW1iZXIgb2YgYml0cyBhbmQgUk5HLlxuICpcbiAqIEBwYXJhbSBiaXRzIHRoZSBudW1iZXIgb2YgYml0cyBmb3IgdGhlIG51bWJlci5cbiAqIEBwYXJhbSBybmcgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByYW5kb20gbnVtYmVyLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbShiaXRzLCBybmcpIHtcbiAgdmFyIG51bSA9IG5ldyBCaWdJbnRlZ2VyKGJpdHMsIHJuZyk7XG4gIC8vIGZvcmNlIE1TQiBzZXRcbiAgdmFyIGJpdHMxID0gYml0cyAtIDE7XG4gIGlmKCFudW0udGVzdEJpdChiaXRzMSkpIHtcbiAgICBudW0uYml0d2lzZVRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChiaXRzMSksIG9wX29yLCBudW0pO1xuICB9XG4gIC8vIGFsaWduIG51bWJlciBvbiAzMGsrMSBib3VuZGFyeVxuICBudW0uZEFkZE9mZnNldCgzMSAtIG51bS5tb2QoVEhJUlRZKS5ieXRlVmFsdWUoKSwgMCk7XG4gIHJldHVybiBudW07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIE1pbGxlci1SYWJpbiB0ZXN0cyB0byBnZW5lcmF0ZSBhXG4gKiBwcmltZSB3aXRoIGFuIGVycm9yIHByb2JhYmlsaXR5IG9mICgxLzIpXjgwLlxuICpcbiAqIFNlZSBIYW5kYm9vayBvZiBBcHBsaWVkIENyeXB0b2dyYXBoeSBDaGFwdGVyIDQsIFRhYmxlIDQuNC5cbiAqXG4gKiBAcGFyYW0gYml0cyB0aGUgYml0IHNpemUuXG4gKlxuICogQHJldHVybiB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGl0ZXJhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGdldE1pbGxlclJhYmluVGVzdHMoYml0cykge1xuICBpZihiaXRzIDw9IDEwMCkgcmV0dXJuIDI3O1xuICBpZihiaXRzIDw9IDE1MCkgcmV0dXJuIDE4O1xuICBpZihiaXRzIDw9IDIwMCkgcmV0dXJuIDE1O1xuICBpZihiaXRzIDw9IDI1MCkgcmV0dXJuIDEyO1xuICBpZihiaXRzIDw9IDMwMCkgcmV0dXJuIDk7XG4gIGlmKGJpdHMgPD0gMzUwKSByZXR1cm4gODtcbiAgaWYoYml0cyA8PSA0MDApIHJldHVybiA3O1xuICBpZihiaXRzIDw9IDUwMCkgcmV0dXJuIDY7XG4gIGlmKGJpdHMgPD0gNjAwKSByZXR1cm4gNTtcbiAgaWYoYml0cyA8PSA4MDApIHJldHVybiA0O1xuICBpZihiaXRzIDw9IDEyNTApIHJldHVybiAzO1xuICByZXR1cm4gMjtcbn1cblxufSkoKTtcbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJwcmltZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJCaWdJbnRlZ2VyIiwianNibiIsIkdDRF8zMF9ERUxUQSIsIlRISVJUWSIsImZyb21JbnQiLCJvcF9vciIsIngiLCJ5IiwiZ2VuZXJhdGVQcm9iYWJsZVByaW1lIiwiYml0cyIsIm9wdGlvbnMiLCJjYWxsYmFjayIsImFsZ29yaXRobSIsIm5hbWUiLCJwcm5nIiwicmFuZG9tIiwicm5nIiwibmV4dEJ5dGVzIiwiYiIsImdldEJ5dGVzU3luYyIsImxlbmd0aCIsImkiLCJjaGFyQ29kZUF0IiwicHJpbWVpbmNGaW5kUHJpbWUiLCJFcnJvciIsInByaW1laW5jRmluZFByaW1lV2l0aFdvcmtlcnMiLCJwcmltZWluY0ZpbmRQcmltZVdpdGhvdXRXb3JrZXJzIiwibnVtIiwiZ2VuZXJhdGVSYW5kb20iLCJkZWx0YUlkeCIsIm1yVGVzdHMiLCJnZXRNaWxsZXJSYWJpblRlc3RzIiwiYml0TGVuZ3RoIiwibWlsbGVyUmFiaW5UZXN0cyIsIm1heEJsb2NrVGltZSIsIl9wcmltZWluYyIsInN0YXJ0IiwiRGF0ZSIsImlzUHJvYmFibGVQcmltZSIsImRBZGRPZmZzZXQiLCJ1dGlsIiwic2V0SW1tZWRpYXRlIiwiV29ya2VyIiwibnVtV29ya2VycyIsIndvcmtlcnMiLCJ3b3JrTG9hZCIsInJhbmdlIiwid29ya2VyU2NyaXB0IiwiZXN0aW1hdGVDb3JlcyIsImVyciIsImNvcmVzIiwiZ2VuZXJhdGUiLCJNYXRoIiwibWF4IiwicnVubmluZyIsImFkZEV2ZW50TGlzdGVuZXIiLCJ3b3JrZXJNZXNzYWdlIiwiZm91bmQiLCJlIiwiZGF0YSIsInRlcm1pbmF0ZSIsImhleCIsInRvU3RyaW5nIiwidGFyZ2V0IiwicG9zdE1lc3NhZ2UiLCJiaXRzMSIsInRlc3RCaXQiLCJiaXR3aXNlVG8iLCJPTkUiLCJzaGlmdExlZnQiLCJtb2QiLCJieXRlVmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/prime.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/prng.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/prng.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * A javascript implementation of a cryptographically-secure\n * Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed\n * here though the use of SHA-256 is not enforced; when generating an\n * a PRNG context, the hashing algorithm and block cipher used for\n * the generator are specified via a plugin.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\nvar _crypto = null;\nif (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions[\"node-webkit\"]) {\n    _crypto = __webpack_require__(/*! crypto */ \"crypto\");\n}\n/* PRNG API */ var prng = module.exports = forge.prng = forge.prng || {};\n/**\n * Creates a new PRNG context.\n *\n * A PRNG plugin must be passed in that will provide:\n *\n * 1. A function that initializes the key and seed of a PRNG context. It\n *   will be given a 16 byte key and a 16 byte seed. Any key expansion\n *   or transformation of the seed from a byte string into an array of\n *   integers (or similar) should be performed.\n * 2. The cryptographic function used by the generator. It takes a key and\n *   a seed.\n * 3. A seed increment function. It takes the seed and returns seed + 1.\n * 4. An api to create a message digest.\n *\n * For an example, see random.js.\n *\n * @param plugin the PRNG plugin to use.\n */ prng.create = function(plugin) {\n    var ctx = {\n        plugin: plugin,\n        key: null,\n        seed: null,\n        time: null,\n        // number of reseeds so far\n        reseeds: 0,\n        // amount of data generated so far\n        generated: 0,\n        // no initial key bytes\n        keyBytes: \"\"\n    };\n    // create 32 entropy pools (each is a message digest)\n    var md = plugin.md;\n    var pools = new Array(32);\n    for(var i = 0; i < 32; ++i){\n        pools[i] = md.create();\n    }\n    ctx.pools = pools;\n    // entropy pools are written to cyclically, starting at index 0\n    ctx.pool = 0;\n    /**\n   * Generates random bytes. The bytes may be generated synchronously or\n   * asynchronously. Web workers must use the asynchronous interface or\n   * else the behavior is undefined.\n   *\n   * @param count the number of random bytes to generate.\n   * @param [callback(err, bytes)] called once the operation completes.\n   *\n   * @return count random bytes as a string.\n   */ ctx.generate = function(count, callback) {\n        // do synchronously\n        if (!callback) {\n            return ctx.generateSync(count);\n        }\n        // simple generator using counter-based CBC\n        var cipher = ctx.plugin.cipher;\n        var increment = ctx.plugin.increment;\n        var formatKey = ctx.plugin.formatKey;\n        var formatSeed = ctx.plugin.formatSeed;\n        var b = forge.util.createBuffer();\n        // paranoid deviation from Fortuna:\n        // reset key for every request to protect previously\n        // generated random bytes should the key be discovered;\n        // there is no 100ms based reseeding because of this\n        // forced reseed for every `generate` call\n        ctx.key = null;\n        generate();\n        function generate(err) {\n            if (err) {\n                return callback(err);\n            }\n            // sufficient bytes generated\n            if (b.length() >= count) {\n                return callback(null, b.getBytes(count));\n            }\n            // if amount of data generated is greater than 1 MiB, trigger reseed\n            if (ctx.generated > 0xfffff) {\n                ctx.key = null;\n            }\n            if (ctx.key === null) {\n                // prevent stack overflow\n                return forge.util.nextTick(function() {\n                    _reseed(generate);\n                });\n            }\n            // generate the random bytes\n            var bytes = cipher(ctx.key, ctx.seed);\n            ctx.generated += bytes.length;\n            b.putBytes(bytes);\n            // generate bytes for a new key and seed\n            ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n            ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n            forge.util.setImmediate(generate);\n        }\n    };\n    /**\n   * Generates random bytes synchronously.\n   *\n   * @param count the number of random bytes to generate.\n   *\n   * @return count random bytes as a string.\n   */ ctx.generateSync = function(count) {\n        // simple generator using counter-based CBC\n        var cipher = ctx.plugin.cipher;\n        var increment = ctx.plugin.increment;\n        var formatKey = ctx.plugin.formatKey;\n        var formatSeed = ctx.plugin.formatSeed;\n        // paranoid deviation from Fortuna:\n        // reset key for every request to protect previously\n        // generated random bytes should the key be discovered;\n        // there is no 100ms based reseeding because of this\n        // forced reseed for every `generateSync` call\n        ctx.key = null;\n        var b = forge.util.createBuffer();\n        while(b.length() < count){\n            // if amount of data generated is greater than 1 MiB, trigger reseed\n            if (ctx.generated > 0xfffff) {\n                ctx.key = null;\n            }\n            if (ctx.key === null) {\n                _reseedSync();\n            }\n            // generate the random bytes\n            var bytes = cipher(ctx.key, ctx.seed);\n            ctx.generated += bytes.length;\n            b.putBytes(bytes);\n            // generate bytes for a new key and seed\n            ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n            ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n        }\n        return b.getBytes(count);\n    };\n    /**\n   * Private function that asynchronously reseeds a generator.\n   *\n   * @param callback(err) called once the operation completes.\n   */ function _reseed(callback) {\n        if (ctx.pools[0].messageLength >= 32) {\n            _seed();\n            return callback();\n        }\n        // not enough seed data...\n        var needed = 32 - ctx.pools[0].messageLength << 5;\n        ctx.seedFile(needed, function(err, bytes) {\n            if (err) {\n                return callback(err);\n            }\n            ctx.collect(bytes);\n            _seed();\n            callback();\n        });\n    }\n    /**\n   * Private function that synchronously reseeds a generator.\n   */ function _reseedSync() {\n        if (ctx.pools[0].messageLength >= 32) {\n            return _seed();\n        }\n        // not enough seed data...\n        var needed = 32 - ctx.pools[0].messageLength << 5;\n        ctx.collect(ctx.seedFileSync(needed));\n        _seed();\n    }\n    /**\n   * Private function that seeds a generator once enough bytes are available.\n   */ function _seed() {\n        // update reseed count\n        ctx.reseeds = ctx.reseeds === 0xffffffff ? 0 : ctx.reseeds + 1;\n        // goal is to update `key` via:\n        // key = hash(key + s)\n        //   where 's' is all collected entropy from selected pools, then...\n        // create a plugin-based message digest\n        var md = ctx.plugin.md.create();\n        // consume current key bytes\n        md.update(ctx.keyBytes);\n        // digest the entropy of pools whose index k meet the\n        // condition 'n mod 2^k == 0' where n is the number of reseeds\n        var _2powK = 1;\n        for(var k = 0; k < 32; ++k){\n            if (ctx.reseeds % _2powK === 0) {\n                md.update(ctx.pools[k].digest().getBytes());\n                ctx.pools[k].start();\n            }\n            _2powK = _2powK << 1;\n        }\n        // get digest for key bytes\n        ctx.keyBytes = md.digest().getBytes();\n        // paranoid deviation from Fortuna:\n        // update `seed` via `seed = hash(key)`\n        // instead of initializing to zero once and only\n        // ever incrementing it\n        md.start();\n        md.update(ctx.keyBytes);\n        var seedBytes = md.digest().getBytes();\n        // update state\n        ctx.key = ctx.plugin.formatKey(ctx.keyBytes);\n        ctx.seed = ctx.plugin.formatSeed(seedBytes);\n        ctx.generated = 0;\n    }\n    /**\n   * The built-in default seedFile. This seedFile is used when entropy\n   * is needed immediately.\n   *\n   * @param needed the number of bytes that are needed.\n   *\n   * @return the random bytes.\n   */ function defaultSeedFile(needed) {\n        // use window.crypto.getRandomValues strong source of entropy if available\n        var getRandomValues = null;\n        var globalScope = forge.util.globalScope;\n        var _crypto = globalScope.crypto || globalScope.msCrypto;\n        if (_crypto && _crypto.getRandomValues) {\n            getRandomValues = function(arr) {\n                return _crypto.getRandomValues(arr);\n            };\n        }\n        var b = forge.util.createBuffer();\n        if (getRandomValues) {\n            while(b.length() < needed){\n                // max byte length is 65536 before QuotaExceededError is thrown\n                // http://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues\n                var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);\n                var entropy = new Uint32Array(Math.floor(count));\n                try {\n                    getRandomValues(entropy);\n                    for(var i = 0; i < entropy.length; ++i){\n                        b.putInt32(entropy[i]);\n                    }\n                } catch (e) {\n                    /* only ignore QuotaExceededError */ if (!(typeof QuotaExceededError !== \"undefined\" && e instanceof QuotaExceededError)) {\n                        throw e;\n                    }\n                }\n            }\n        }\n        // be sad and add some weak random data\n        if (b.length() < needed) {\n            /* Draws from Park-Miller \"minimal standard\" 31 bit PRNG,\n      implemented with David G. Carta's optimization: with 32 bit math\n      and without division (Public Domain). */ var hi, lo, next;\n            var seed = Math.floor(Math.random() * 0x010000);\n            while(b.length() < needed){\n                lo = 16807 * (seed & 0xFFFF);\n                hi = 16807 * (seed >> 16);\n                lo += (hi & 0x7FFF) << 16;\n                lo += hi >> 15;\n                lo = (lo & 0x7FFFFFFF) + (lo >> 31);\n                seed = lo & 0xFFFFFFFF;\n                // consume lower 3 bytes of seed\n                for(var i = 0; i < 3; ++i){\n                    // throw in more pseudo random\n                    next = seed >>> (i << 3);\n                    next ^= Math.floor(Math.random() * 0x0100);\n                    b.putByte(next & 0xFF);\n                }\n            }\n        }\n        return b.getBytes(needed);\n    }\n    // initialize seed file APIs\n    if (_crypto) {\n        // use nodejs async API\n        ctx.seedFile = function(needed, callback) {\n            _crypto.randomBytes(needed, function(err, bytes) {\n                if (err) {\n                    return callback(err);\n                }\n                callback(null, bytes.toString());\n            });\n        };\n        // use nodejs sync API\n        ctx.seedFileSync = function(needed) {\n            return _crypto.randomBytes(needed).toString();\n        };\n    } else {\n        ctx.seedFile = function(needed, callback) {\n            try {\n                callback(null, defaultSeedFile(needed));\n            } catch (e) {\n                callback(e);\n            }\n        };\n        ctx.seedFileSync = defaultSeedFile;\n    }\n    /**\n   * Adds entropy to a prng ctx's accumulator.\n   *\n   * @param bytes the bytes of entropy as a string.\n   */ ctx.collect = function(bytes) {\n        // iterate over pools distributing entropy cyclically\n        var count = bytes.length;\n        for(var i = 0; i < count; ++i){\n            ctx.pools[ctx.pool].update(bytes.substr(i, 1));\n            ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;\n        }\n    };\n    /**\n   * Collects an integer of n bits.\n   *\n   * @param i the integer entropy.\n   * @param n the number of bits in the integer.\n   */ ctx.collectInt = function(i, n) {\n        var bytes = \"\";\n        for(var x = 0; x < n; x += 8){\n            bytes += String.fromCharCode(i >> x & 0xFF);\n        }\n        ctx.collect(bytes);\n    };\n    /**\n   * Registers a Web Worker to receive immediate entropy from the main thread.\n   * This method is required until Web Workers can access the native crypto\n   * API. This method should be called twice for each created worker, once in\n   * the main thread, and once in the worker itself.\n   *\n   * @param worker the worker to register.\n   */ ctx.registerWorker = function(worker) {\n        // worker receives random bytes\n        if (worker === self) {\n            ctx.seedFile = function(needed, callback) {\n                function listener(e) {\n                    var data = e.data;\n                    if (data.forge && data.forge.prng) {\n                        self.removeEventListener(\"message\", listener);\n                        callback(data.forge.prng.err, data.forge.prng.bytes);\n                    }\n                }\n                self.addEventListener(\"message\", listener);\n                self.postMessage({\n                    forge: {\n                        prng: {\n                            needed: needed\n                        }\n                    }\n                });\n            };\n        } else {\n            // main thread sends random bytes upon request\n            var listener = function(e) {\n                var data = e.data;\n                if (data.forge && data.forge.prng) {\n                    ctx.seedFile(data.forge.prng.needed, function(err, bytes) {\n                        worker.postMessage({\n                            forge: {\n                                prng: {\n                                    err: err,\n                                    bytes: bytes\n                                }\n                            }\n                        });\n                    });\n                }\n            };\n            // TODO: do we need to remove the event listener when the worker dies?\n            worker.addEventListener(\"message\", listener);\n        }\n    };\n    return ctx;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcHJuZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztDQVVDO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBRVIsSUFBSUMsVUFBVTtBQUNkLElBQUdGLE1BQU1HLElBQUksQ0FBQ0MsUUFBUSxJQUFJLENBQUNKLE1BQU1LLE9BQU8sQ0FBQ0MsaUJBQWlCLElBQ3hELENBQUNDLFFBQVFDLFFBQVEsQ0FBQyxjQUFjLEVBQUU7SUFDbENOLFVBQVVELG1CQUFPQSxDQUFDO0FBQ3BCO0FBRUEsWUFBWSxHQUNaLElBQUlRLE9BQU9DLE9BQU9DLE9BQU8sR0FBR1gsTUFBTVMsSUFBSSxHQUFHVCxNQUFNUyxJQUFJLElBQUksQ0FBQztBQUV4RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDREEsS0FBS0csTUFBTSxHQUFHLFNBQVNDLE1BQU07SUFDM0IsSUFBSUMsTUFBTTtRQUNSRCxRQUFRQTtRQUNSRSxLQUFLO1FBQ0xDLE1BQU07UUFDTkMsTUFBTTtRQUNOLDJCQUEyQjtRQUMzQkMsU0FBUztRQUNULGtDQUFrQztRQUNsQ0MsV0FBVztRQUNYLHVCQUF1QjtRQUN2QkMsVUFBVTtJQUNaO0lBRUEscURBQXFEO0lBQ3JELElBQUlDLEtBQUtSLE9BQU9RLEVBQUU7SUFDbEIsSUFBSUMsUUFBUSxJQUFJQyxNQUFNO0lBQ3RCLElBQUksSUFBSUMsSUFBSSxHQUFHQSxJQUFJLElBQUksRUFBRUEsRUFBRztRQUMxQkYsS0FBSyxDQUFDRSxFQUFFLEdBQUdILEdBQUdULE1BQU07SUFDdEI7SUFDQUUsSUFBSVEsS0FBSyxHQUFHQTtJQUVaLCtEQUErRDtJQUMvRFIsSUFBSVcsSUFBSSxHQUFHO0lBRVg7Ozs7Ozs7OztHQVNDLEdBQ0RYLElBQUlZLFFBQVEsR0FBRyxTQUFTQyxLQUFLLEVBQUVDLFFBQVE7UUFDckMsbUJBQW1CO1FBQ25CLElBQUcsQ0FBQ0EsVUFBVTtZ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QUN2QixJQUFJbUIsT0FBT25CLEVBQUVtQixJQUFJO2dCQUNqQixJQUFHQSxLQUFLekYsS0FBSyxJQUFJeUYsS0FBS3pGLEtBQUssQ0FBQ1MsSUFBSSxFQUFFO29CQUNoQ0ssSUFBSWtDLFFBQVEsQ0FBQ3lDLEtBQUt6RixLQUFLLENBQUNTLElBQUksQ0FBQ3NDLE1BQU0sRUFBRSxTQUFTWCxHQUFHLEVBQUVLLEtBQUs7d0JBQ3RENkMsT0FBT00sV0FBVyxDQUFDOzRCQUFDNUYsT0FBTztnQ0FBQ1MsTUFBTTtvQ0FBQzJCLEtBQUtBO29DQUFLSyxPQUFPQTtnQ0FBSzs0QkFBQzt3QkFBQztvQkFDN0Q7Z0JBQ0Y7WUFDRjtZQUNBLHNFQUFzRTtZQUN0RTZDLE9BQU9LLGdCQUFnQixDQUFDLFdBQVdIO1FBQ3JDO0lBQ0Y7SUFFQSxPQUFPMUU7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9wcm5nLmpzPzFjZDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIGphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmVcbiAqIFBzZXVkbyBSYW5kb20gTnVtYmVyIEdlbmVyYXRvciAoUFJORykuIFRoZSBGb3J0dW5hIGFsZ29yaXRobSBpcyBmb2xsb3dlZFxuICogaGVyZSB0aG91Z2ggdGhlIHVzZSBvZiBTSEEtMjU2IGlzIG5vdCBlbmZvcmNlZDsgd2hlbiBnZW5lcmF0aW5nIGFuXG4gKiBhIFBSTkcgY29udGV4dCwgdGhlIGhhc2hpbmcgYWxnb3JpdGhtIGFuZCBibG9jayBjaXBoZXIgdXNlZCBmb3JcbiAqIHRoZSBnZW5lcmF0b3IgYXJlIHNwZWNpZmllZCB2aWEgYSBwbHVnaW4uXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIF9jcnlwdG8gPSBudWxsO1xuaWYoZm9yZ2UudXRpbC5pc05vZGVqcyAmJiAhZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCAmJlxuICAhcHJvY2Vzcy52ZXJzaW9uc1snbm9kZS13ZWJraXQnXSkge1xuICBfY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG59XG5cbi8qIFBSTkcgQVBJICovXG52YXIgcHJuZyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucHJuZyA9IGZvcmdlLnBybmcgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBQUk5HIGNvbnRleHQuXG4gKlxuICogQSBQUk5HIHBsdWdpbiBtdXN0IGJlIHBhc3NlZCBpbiB0aGF0IHdpbGwgcHJvdmlkZTpcbiAqXG4gKiAxLiBBIGZ1bmN0aW9uIHRoYXQgaW5pdGlhbGl6ZXMgdGhlIGtleSBhbmQgc2VlZCBvZiBhIFBSTkcgY29udGV4dC4gSXRcbiAqICAgd2lsbCBiZSBnaXZlbiBhIDE2IGJ5dGUga2V5IGFuZCBhIDE2IGJ5dGUgc2VlZC4gQW55IGtleSBleHBhbnNpb25cbiAqICAgb3IgdHJhbnNmb3JtYXRpb24gb2YgdGhlIHNlZWQgZnJvbSBhIGJ5dGUgc3RyaW5nIGludG8gYW4gYXJyYXkgb2ZcbiAqICAgaW50ZWdlcnMgKG9yIHNpbWlsYXIpIHNob3VsZCBiZSBwZXJmb3JtZWQuXG4gKiAyLiBUaGUgY3J5cHRvZ3JhcGhpYyBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBnZW5lcmF0b3IuIEl0IHRha2VzIGEga2V5IGFuZFxuICogICBhIHNlZWQuXG4gKiAzLiBBIHNlZWQgaW5jcmVtZW50IGZ1bmN0aW9uLiBJdCB0YWtlcyB0aGUgc2VlZCBhbmQgcmV0dXJucyBzZWVkICsgMS5cbiAqIDQuIEFuIGFwaSB0byBjcmVhdGUgYSBtZXNzYWdlIGRpZ2VzdC5cbiAqXG4gKiBGb3IgYW4gZXhhbXBsZSwgc2VlIHJhbmRvbS5qcy5cbiAqXG4gKiBAcGFyYW0gcGx1Z2luIHRoZSBQUk5HIHBsdWdpbiB0byB1c2UuXG4gKi9cbnBybmcuY3JlYXRlID0gZnVuY3Rpb24ocGx1Z2luKSB7XG4gIHZhciBjdHggPSB7XG4gICAgcGx1Z2luOiBwbHVnaW4sXG4gICAga2V5OiBudWxsLFxuICAgIHNlZWQ6IG51bGwsXG4gICAgdGltZTogbnVsbCxcbiAgICAvLyBudW1iZXIgb2YgcmVzZWVkcyBzbyBmYXJcbiAgICByZXNlZWRzOiAwLFxuICAgIC8vIGFtb3VudCBvZiBkYXRhIGdlbmVyYXRlZCBzbyBmYXJcbiAgICBnZW5lcmF0ZWQ6IDAsXG4gICAgLy8gbm8gaW5pdGlhbCBrZXkgYnl0ZXNcbiAgICBrZXlCeXRlczogJydcbiAgfTtcblxuICAvLyBjcmVhdGUgMzIgZW50cm9weSBwb29scyAoZWFjaCBpcyBhIG1lc3NhZ2UgZGlnZXN0KVxuICB2YXIgbWQgPSBwbHVnaW4ubWQ7XG4gIHZhciBwb29scyA9IG5ldyBBcnJheSgzMik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgcG9vbHNbaV0gPSBtZC5jcmVhdGUoKTtcbiAgfVxuICBjdHgucG9vbHMgPSBwb29scztcblxuICAvLyBlbnRyb3B5IHBvb2xzIGFyZSB3cml0dGVuIHRvIGN5Y2xpY2FsbHksIHN0YXJ0aW5nIGF0IGluZGV4IDBcbiAgY3R4LnBvb2wgPSAwO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcmFuZG9tIGJ5dGVzLiBUaGUgYnl0ZXMgbWF5IGJlIGdlbmVyYXRlZCBzeW5jaHJvbm91c2x5IG9yXG4gICAqIGFzeW5jaHJvbm91c2x5LiBXZWIgd29ya2VycyBtdXN0IHVzZSB0aGUgYXN5bmNocm9ub3VzIGludGVyZmFjZSBvclxuICAgKiBlbHNlIHRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWQuXG4gICAqXG4gICAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cbiAgICogQHBhcmFtIFtjYWxsYmFjayhlcnIsIGJ5dGVzKV0gY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gICAqXG4gICAqIEByZXR1cm4gY291bnQgcmFuZG9tIGJ5dGVzIGFzIGEgc3RyaW5nLlxuICAgKi9cbiAgY3R4LmdlbmVyYXRlID0gZnVuY3Rpb24oY291bnQsIGNhbGxiYWNrKSB7XG4gICAgLy8gZG8gc3luY2hyb25vdXNseVxuICAgIGlmKCFjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGN0eC5nZW5lcmF0ZVN5bmMoY291bnQpO1xuICAgIH1cblxuICAgIC8vIHNpbXBsZSBnZW5lcmF0b3IgdXNpbmcgY291bnRlci1iYXNlZCBDQkNcbiAgICB2YXIgY2lwaGVyID0gY3R4LnBsdWdpbi5jaXBoZXI7XG4gICAgdmFyIGluY3JlbWVudCA9IGN0eC5wbHVnaW4uaW5jcmVtZW50O1xuICAgIHZhciBmb3JtYXRLZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleTtcbiAgICB2YXIgZm9ybWF0U2VlZCA9IGN0eC5wbHVnaW4uZm9ybWF0U2VlZDtcbiAgICB2YXIgYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICAvLyBwYXJhbm9pZCBkZXZpYXRpb24gZnJvbSBGb3J0dW5hOlxuICAgIC8vIHJlc2V0IGtleSBmb3IgZXZlcnkgcmVxdWVzdCB0byBwcm90ZWN0IHByZXZpb3VzbHlcbiAgICAvLyBnZW5lcmF0ZWQgcmFuZG9tIGJ5dGVzIHNob3VsZCB0aGUga2V5IGJlIGRpc2NvdmVyZWQ7XG4gICAgLy8gdGhlcmUgaXMgbm8gMTAwbXMgYmFzZWQgcmVzZWVkaW5nIGJlY2F1c2Ugb2YgdGhpc1xuICAgIC8vIGZvcmNlZCByZXNlZWQgZm9yIGV2ZXJ5IGBnZW5lcmF0ZWAgY2FsbFxuICAgIGN0eC5rZXkgPSBudWxsO1xuXG4gICAgZ2VuZXJhdGUoKTtcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlKGVycikge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICAvLyBzdWZmaWNpZW50IGJ5dGVzIGdlbmVyYXRlZFxuICAgICAgaWYoYi5sZW5ndGgoKSA+PSBjb3VudCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgYi5nZXRCeXRlcyhjb3VudCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBhbW91bnQgb2YgZGF0YSBnZW5lcmF0ZWQgaXMgZ3JlYXRlciB0aGFuIDEgTWlCLCB0cmlnZ2VyIHJlc2VlZFxuICAgICAgaWYoY3R4LmdlbmVyYXRlZCA+IDB4ZmZmZmYpIHtcbiAgICAgICAgY3R4LmtleSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmKGN0eC5rZXkgPT09IG51bGwpIHtcbiAgICAgICAgLy8gcHJldmVudCBzdGFjayBvdmVyZmxvd1xuICAgICAgICByZXR1cm4gZm9yZ2UudXRpbC5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICBfcmVzZWVkKGdlbmVyYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdlbmVyYXRlIHRoZSByYW5kb20gYnl0ZXNcbiAgICAgIHZhciBieXRlcyA9IGNpcGhlcihjdHgua2V5LCBjdHguc2VlZCk7XG4gICAgICBjdHguZ2VuZXJhdGVkICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuXG4gICAgICAvLyBnZW5lcmF0ZSBieXRlcyBmb3IgYSBuZXcga2V5IGFuZCBzZWVkXG4gICAgICBjdHgua2V5ID0gZm9ybWF0S2V5KGNpcGhlcihjdHgua2V5LCBpbmNyZW1lbnQoY3R4LnNlZWQpKSk7XG4gICAgICBjdHguc2VlZCA9IGZvcm1hdFNlZWQoY2lwaGVyKGN0eC5rZXksIGN0eC5zZWVkKSk7XG5cbiAgICAgIGZvcmdlLnV0aWwuc2V0SW1tZWRpYXRlKGdlbmVyYXRlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyByYW5kb20gYnl0ZXMgc3luY2hyb25vdXNseS5cbiAgICpcbiAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICAgKlxuICAgKiBAcmV0dXJuIGNvdW50IHJhbmRvbSBieXRlcyBhcyBhIHN0cmluZy5cbiAgICovXG4gIGN0eC5nZW5lcmF0ZVN5bmMgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIC8vIHNpbXBsZSBnZW5lcmF0b3IgdXNpbmcgY291bnRlci1iYXNlZCBDQkNcbiAgICB2YXIgY2lwaGVyID0gY3R4LnBsdWdpbi5jaXBoZXI7XG4gICAgdmFyIGluY3JlbWVudCA9IGN0eC5wbHVnaW4uaW5jcmVtZW50O1xuICAgIHZhciBmb3JtYXRLZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleTtcbiAgICB2YXIgZm9ybWF0U2VlZCA9IGN0eC5wbHVnaW4uZm9ybWF0U2VlZDtcblxuICAgIC8vIHBhcmFub2lkIGRldmlhdGlvbiBmcm9tIEZvcnR1bmE6XG4gICAgLy8gcmVzZXQga2V5IGZvciBldmVyeSByZXF1ZXN0IHRvIHByb3RlY3QgcHJldmlvdXNseVxuICAgIC8vIGdlbmVyYXRlZCByYW5kb20gYnl0ZXMgc2hvdWxkIHRoZSBrZXkgYmUgZGlzY292ZXJlZDtcbiAgICAvLyB0aGVyZSBpcyBubyAxMDBtcyBiYXNlZCByZXNlZWRpbmcgYmVjYXVzZSBvZiB0aGlzXG4gICAgLy8gZm9yY2VkIHJlc2VlZCBmb3IgZXZlcnkgYGdlbmVyYXRlU3luY2AgY2FsbFxuICAgIGN0eC5rZXkgPSBudWxsO1xuXG4gICAgdmFyIGIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHdoaWxlKGIubGVuZ3RoKCkgPCBjb3VudCkge1xuICAgICAgLy8gaWYgYW1vdW50IG9mIGRhdGEgZ2VuZXJhdGVkIGlzIGdyZWF0ZXIgdGhhbiAxIE1pQiwgdHJpZ2dlciByZXNlZWRcbiAgICAgIGlmKGN0eC5nZW5lcmF0ZWQgPiAweGZmZmZmKSB7XG4gICAgICAgIGN0eC5rZXkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZihjdHgua2V5ID09PSBudWxsKSB7XG4gICAgICAgIF9yZXNlZWRTeW5jKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdlbmVyYXRlIHRoZSByYW5kb20gYnl0ZXNcbiAgICAgIHZhciBieXRlcyA9IGNpcGhlcihjdHgua2V5LCBjdHguc2VlZCk7XG4gICAgICBjdHguZ2VuZXJhdGVkICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuXG4gICAgICAvLyBnZW5lcmF0ZSBieXRlcyBmb3IgYSBuZXcga2V5IGFuZCBzZWVkXG4gICAgICBjdHgua2V5ID0gZm9ybWF0S2V5KGNpcGhlcihjdHgua2V5LCBpbmNyZW1lbnQoY3R4LnNlZWQpKSk7XG4gICAgICBjdHguc2VlZCA9IGZvcm1hdFNlZWQoY2lwaGVyKGN0eC5rZXksIGN0eC5zZWVkKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGIuZ2V0Qnl0ZXMoY291bnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcml2YXRlIGZ1bmN0aW9uIHRoYXQgYXN5bmNocm9ub3VzbHkgcmVzZWVkcyBhIGdlbmVyYXRvci5cbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrKGVycikgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBfcmVzZWVkKGNhbGxiYWNrKSB7XG4gICAgaWYoY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGggPj0gMzIpIHtcbiAgICAgIF9zZWVkKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCBzZWVkIGRhdGEuLi5cbiAgICB2YXIgbmVlZGVkID0gKDMyIC0gY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGgpIDw8IDU7XG4gICAgY3R4LnNlZWRGaWxlKG5lZWRlZCwgZnVuY3Rpb24oZXJyLCBieXRlcykge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgY3R4LmNvbGxlY3QoYnl0ZXMpO1xuICAgICAgX3NlZWQoKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUHJpdmF0ZSBmdW5jdGlvbiB0aGF0IHN5bmNocm9ub3VzbHkgcmVzZWVkcyBhIGdlbmVyYXRvci5cbiAgICovXG4gIGZ1bmN0aW9uIF9yZXNlZWRTeW5jKCkge1xuICAgIGlmKGN0eC5wb29sc1swXS5tZXNzYWdlTGVuZ3RoID49IDMyKSB7XG4gICAgICByZXR1cm4gX3NlZWQoKTtcbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCBzZWVkIGRhdGEuLi5cbiAgICB2YXIgbmVlZGVkID0gKDMyIC0gY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGgpIDw8IDU7XG4gICAgY3R4LmNvbGxlY3QoY3R4LnNlZWRGaWxlU3luYyhuZWVkZWQpKTtcbiAgICBfc2VlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgZnVuY3Rpb24gdGhhdCBzZWVkcyBhIGdlbmVyYXRvciBvbmNlIGVub3VnaCBieXRlcyBhcmUgYXZhaWxhYmxlLlxuICAgKi9cbiAgZnVuY3Rpb24gX3NlZWQoKSB7XG4gICAgLy8gdXBkYXRlIHJlc2VlZCBjb3VudFxuICAgIGN0eC5yZXNlZWRzID0gKGN0eC5yZXNlZWRzID09PSAweGZmZmZmZmZmKSA/IDAgOiBjdHgucmVzZWVkcyArIDE7XG5cbiAgICAvLyBnb2FsIGlzIHRvIHVwZGF0ZSBga2V5YCB2aWE6XG4gICAgLy8ga2V5ID0gaGFzaChrZXkgKyBzKVxuICAgIC8vICAgd2hlcmUgJ3MnIGlzIGFsbCBjb2xsZWN0ZWQgZW50cm9weSBmcm9tIHNlbGVjdGVkIHBvb2xzLCB0aGVuLi4uXG5cbiAgICAvLyBjcmVhdGUgYSBwbHVnaW4tYmFzZWQgbWVzc2FnZSBkaWdlc3RcbiAgICB2YXIgbWQgPSBjdHgucGx1Z2luLm1kLmNyZWF0ZSgpO1xuXG4gICAgLy8gY29uc3VtZSBjdXJyZW50IGtleSBieXRlc1xuICAgIG1kLnVwZGF0ZShjdHgua2V5Qnl0ZXMpO1xuXG4gICAgLy8gZGlnZXN0IHRoZSBlbnRyb3B5IG9mIHBvb2xzIHdob3NlIGluZGV4IGsgbWVldCB0aGVcbiAgICAvLyBjb25kaXRpb24gJ24gbW9kIDJeayA9PSAwJyB3aGVyZSBuIGlzIHRoZSBudW1iZXIgb2YgcmVzZWVkc1xuICAgIHZhciBfMnBvd0sgPSAxO1xuICAgIGZvcih2YXIgayA9IDA7IGsgPCAzMjsgKytrKSB7XG4gICAgICBpZihjdHgucmVzZWVkcyAlIF8ycG93SyA9PT0gMCkge1xuICAgICAgICBtZC51cGRhdGUoY3R4LnBvb2xzW2tdLmRpZ2VzdCgpLmdldEJ5dGVzKCkpO1xuICAgICAgICBjdHgucG9vbHNba10uc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIF8ycG93SyA9IF8ycG93SyA8PCAxO1xuICAgIH1cblxuICAgIC8vIGdldCBkaWdlc3QgZm9yIGtleSBieXRlc1xuICAgIGN0eC5rZXlCeXRlcyA9IG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvLyBwYXJhbm9pZCBkZXZpYXRpb24gZnJvbSBGb3J0dW5hOlxuICAgIC8vIHVwZGF0ZSBgc2VlZGAgdmlhIGBzZWVkID0gaGFzaChrZXkpYFxuICAgIC8vIGluc3RlYWQgb2YgaW5pdGlhbGl6aW5nIHRvIHplcm8gb25jZSBhbmQgb25seVxuICAgIC8vIGV2ZXIgaW5jcmVtZW50aW5nIGl0XG4gICAgbWQuc3RhcnQoKTtcbiAgICBtZC51cGRhdGUoY3R4LmtleUJ5dGVzKTtcbiAgICB2YXIgc2VlZEJ5dGVzID0gbWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcblxuICAgIC8vIHVwZGF0ZSBzdGF0ZVxuICAgIGN0eC5rZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleShjdHgua2V5Qnl0ZXMpO1xuICAgIGN0eC5zZWVkID0gY3R4LnBsdWdpbi5mb3JtYXRTZWVkKHNlZWRCeXRlcyk7XG4gICAgY3R4LmdlbmVyYXRlZCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJ1aWx0LWluIGRlZmF1bHQgc2VlZEZpbGUuIFRoaXMgc2VlZEZpbGUgaXMgdXNlZCB3aGVuIGVudHJvcHlcbiAgICogaXMgbmVlZGVkIGltbWVkaWF0ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gbmVlZGVkIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBhcmUgbmVlZGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSByYW5kb20gYnl0ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBkZWZhdWx0U2VlZEZpbGUobmVlZGVkKSB7XG4gICAgLy8gdXNlIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHN0cm9uZyBzb3VyY2Ugb2YgZW50cm9weSBpZiBhdmFpbGFibGVcbiAgICB2YXIgZ2V0UmFuZG9tVmFsdWVzID0gbnVsbDtcbiAgICB2YXIgZ2xvYmFsU2NvcGUgPSBmb3JnZS51dGlsLmdsb2JhbFNjb3BlO1xuICAgIHZhciBfY3J5cHRvID0gZ2xvYmFsU2NvcGUuY3J5cHRvIHx8IGdsb2JhbFNjb3BlLm1zQ3J5cHRvO1xuICAgIGlmKF9jcnlwdG8gJiYgX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIGdldFJhbmRvbVZhbHVlcyA9IGZ1bmN0aW9uKGFycikge1xuICAgICAgICByZXR1cm4gX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGlmKGdldFJhbmRvbVZhbHVlcykge1xuICAgICAgd2hpbGUoYi5sZW5ndGgoKSA8IG5lZWRlZCkge1xuICAgICAgICAvLyBtYXggYnl0ZSBsZW5ndGggaXMgNjU1MzYgYmVmb3JlIFF1b3RhRXhjZWVkZWRFcnJvciBpcyB0aHJvd25cbiAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvV2ViQ3J5cHRvQVBJLyNSYW5kb21Tb3VyY2UtbWV0aG9kLWdldFJhbmRvbVZhbHVlc1xuICAgICAgICB2YXIgY291bnQgPSBNYXRoLm1heCgxLCBNYXRoLm1pbihuZWVkZWQgLSBiLmxlbmd0aCgpLCA2NTUzNikgLyA0KTtcbiAgICAgICAgdmFyIGVudHJvcHkgPSBuZXcgVWludDMyQXJyYXkoTWF0aC5mbG9vcihjb3VudCkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGdldFJhbmRvbVZhbHVlcyhlbnRyb3B5KTtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZW50cm9weS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYi5wdXRJbnQzMihlbnRyb3B5W2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIC8qIG9ubHkgaWdub3JlIFF1b3RhRXhjZWVkZWRFcnJvciAqL1xuICAgICAgICAgIGlmKCEodHlwZW9mIFF1b3RhRXhjZWVkZWRFcnJvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGUgaW5zdGFuY2VvZiBRdW90YUV4Y2VlZGVkRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGJlIHNhZCBhbmQgYWRkIHNvbWUgd2VhayByYW5kb20gZGF0YVxuICAgIGlmKGIubGVuZ3RoKCkgPCBuZWVkZWQpIHtcbiAgICAgIC8qIERyYXdzIGZyb20gUGFyay1NaWxsZXIgXCJtaW5pbWFsIHN0YW5kYXJkXCIgMzEgYml0IFBSTkcsXG4gICAgICBpbXBsZW1lbnRlZCB3aXRoIERhdmlkIEcuIENhcnRhJ3Mgb3B0aW1pemF0aW9uOiB3aXRoIDMyIGJpdCBtYXRoXG4gICAgICBhbmQgd2l0aG91dCBkaXZpc2lvbiAoUHVibGljIERvbWFpbikuICovXG4gICAgICB2YXIgaGksIGxvLCBuZXh0O1xuICAgICAgdmFyIHNlZWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweDAxMDAwMCk7XG4gICAgICB3aGlsZShiLmxlbmd0aCgpIDwgbmVlZGVkKSB7XG4gICAgICAgIGxvID0gMTY4MDcgKiAoc2VlZCAmIDB4RkZGRik7XG4gICAgICAgIGhpID0gMTY4MDcgKiAoc2VlZCA+PiAxNik7XG4gICAgICAgIGxvICs9IChoaSAmIDB4N0ZGRikgPDwgMTY7XG4gICAgICAgIGxvICs9IGhpID4+IDE1O1xuICAgICAgICBsbyA9IChsbyAmIDB4N0ZGRkZGRkYpICsgKGxvID4+IDMxKTtcbiAgICAgICAgc2VlZCA9IGxvICYgMHhGRkZGRkZGRjtcblxuICAgICAgICAvLyBjb25zdW1lIGxvd2VyIDMgYnl0ZXMgb2Ygc2VlZFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgLy8gdGhyb3cgaW4gbW9yZSBwc2V1ZG8gcmFuZG9tXG4gICAgICAgICAgbmV4dCA9IHNlZWQgPj4+IChpIDw8IDMpO1xuICAgICAgICAgIG5leHQgXj0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgwMTAwKTtcbiAgICAgICAgICBiLnB1dEJ5dGUobmV4dCAmIDB4RkYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGIuZ2V0Qnl0ZXMobmVlZGVkKTtcbiAgfVxuICAvLyBpbml0aWFsaXplIHNlZWQgZmlsZSBBUElzXG4gIGlmKF9jcnlwdG8pIHtcbiAgICAvLyB1c2Ugbm9kZWpzIGFzeW5jIEFQSVxuICAgIGN0eC5zZWVkRmlsZSA9IGZ1bmN0aW9uKG5lZWRlZCwgY2FsbGJhY2spIHtcbiAgICAgIF9jcnlwdG8ucmFuZG9tQnl0ZXMobmVlZGVkLCBmdW5jdGlvbihlcnIsIGJ5dGVzKSB7XG4gICAgICAgIGlmKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGJ5dGVzLnRvU3RyaW5nKCkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyB1c2Ugbm9kZWpzIHN5bmMgQVBJXG4gICAgY3R4LnNlZWRGaWxlU3luYyA9IGZ1bmN0aW9uKG5lZWRlZCkge1xuICAgICAgcmV0dXJuIF9jcnlwdG8ucmFuZG9tQnl0ZXMobmVlZGVkKS50b1N0cmluZygpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY3R4LnNlZWRGaWxlID0gZnVuY3Rpb24obmVlZGVkLCBjYWxsYmFjaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZGVmYXVsdFNlZWRGaWxlKG5lZWRlZCkpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY3R4LnNlZWRGaWxlU3luYyA9IGRlZmF1bHRTZWVkRmlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGVudHJvcHkgdG8gYSBwcm5nIGN0eCdzIGFjY3VtdWxhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIG9mIGVudHJvcHkgYXMgYSBzdHJpbmcuXG4gICAqL1xuICBjdHguY29sbGVjdCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgLy8gaXRlcmF0ZSBvdmVyIHBvb2xzIGRpc3RyaWJ1dGluZyBlbnRyb3B5IGN5Y2xpY2FsbHlcbiAgICB2YXIgY291bnQgPSBieXRlcy5sZW5ndGg7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIGN0eC5wb29sc1tjdHgucG9vbF0udXBkYXRlKGJ5dGVzLnN1YnN0cihpLCAxKSk7XG4gICAgICBjdHgucG9vbCA9IChjdHgucG9vbCA9PT0gMzEpID8gMCA6IGN0eC5wb29sICsgMTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbGxlY3RzIGFuIGludGVnZXIgb2YgbiBiaXRzLlxuICAgKlxuICAgKiBAcGFyYW0gaSB0aGUgaW50ZWdlciBlbnRyb3B5LlxuICAgKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIuXG4gICAqL1xuICBjdHguY29sbGVjdEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgICB2YXIgYnl0ZXMgPSAnJztcbiAgICBmb3IodmFyIHggPSAwOyB4IDwgbjsgeCArPSA4KSB7XG4gICAgICBieXRlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpID4+IHgpICYgMHhGRik7XG4gICAgfVxuICAgIGN0eC5jb2xsZWN0KGJ5dGVzKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgV2ViIFdvcmtlciB0byByZWNlaXZlIGltbWVkaWF0ZSBlbnRyb3B5IGZyb20gdGhlIG1haW4gdGhyZWFkLlxuICAgKiBUaGlzIG1ldGhvZCBpcyByZXF1aXJlZCB1bnRpbCBXZWIgV29ya2VycyBjYW4gYWNjZXNzIHRoZSBuYXRpdmUgY3J5cHRvXG4gICAqIEFQSS4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCB0d2ljZSBmb3IgZWFjaCBjcmVhdGVkIHdvcmtlciwgb25jZSBpblxuICAgKiB0aGUgbWFpbiB0aHJlYWQsIGFuZCBvbmNlIGluIHRoZSB3b3JrZXIgaXRzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0gd29ya2VyIHRoZSB3b3JrZXIgdG8gcmVnaXN0ZXIuXG4gICAqL1xuICBjdHgucmVnaXN0ZXJXb3JrZXIgPSBmdW5jdGlvbih3b3JrZXIpIHtcbiAgICAvLyB3b3JrZXIgcmVjZWl2ZXMgcmFuZG9tIGJ5dGVzXG4gICAgaWYod29ya2VyID09PSBzZWxmKSB7XG4gICAgICBjdHguc2VlZEZpbGUgPSBmdW5jdGlvbihuZWVkZWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGZ1bmN0aW9uIGxpc3RlbmVyKGUpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgICBpZihkYXRhLmZvcmdlICYmIGRhdGEuZm9yZ2UucHJuZykge1xuICAgICAgICAgICAgc2VsZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgY2FsbGJhY2soZGF0YS5mb3JnZS5wcm5nLmVyciwgZGF0YS5mb3JnZS5wcm5nLmJ5dGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtmb3JnZToge3Bybmc6IHtuZWVkZWQ6IG5lZWRlZH19fSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtYWluIHRocmVhZCBzZW5kcyByYW5kb20gYnl0ZXMgdXBvbiByZXF1ZXN0XG4gICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgICAgICBpZihkYXRhLmZvcmdlICYmIGRhdGEuZm9yZ2UucHJuZykge1xuICAgICAgICAgIGN0eC5zZWVkRmlsZShkYXRhLmZvcmdlLnBybmcubmVlZGVkLCBmdW5jdGlvbihlcnIsIGJ5dGVzKSB7XG4gICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe2ZvcmdlOiB7cHJuZzoge2VycjogZXJyLCBieXRlczogYnl0ZXN9fX0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0byByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyIHdoZW4gdGhlIHdvcmtlciBkaWVzP1xuICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBjdHg7XG59O1xuIl0sIm5hbWVzIjpbImZvcmdlIiwicmVxdWlyZSIsIl9jcnlwdG8iLCJ1dGlsIiwiaXNOb2RlanMiLCJvcHRpb25zIiwidXNlUHVyZUphdmFTY3JpcHQiLCJwcm9jZXNzIiwidmVyc2lvbnMiLCJwcm5nIiwibW9kdWxlIiwiZXhwb3J0cyIsImNyZWF0ZSIsInBsdWdpbiIsImN0eCIsImtleSIsInNlZWQiLCJ0aW1lIiwicmVzZWVkcyIsImdlbmVyYXRlZCIsImtleUJ5dGVzIiwibWQiLCJwb29scyIsIkFycmF5IiwiaSIsInBvb2wiLCJnZW5lcmF0ZSIsImNvdW50IiwiY2FsbGJhY2siLCJnZW5lcmF0ZVN5bmMiLCJjaXBoZXIiLCJpbmNyZW1lbnQiLCJmb3JtYXRLZXkiLCJmb3JtYXRTZWVkIiwiYiIsImNyZWF0ZUJ1ZmZlciIsImVyciIsImxlbmd0aCIsImdldEJ5dGVzIiwibmV4dFRpY2siLCJfcmVzZWVkIiwiYnl0ZXMiLCJwdXRCeXRlcyIsInNldEltbWVkaWF0ZSIsIl9yZXNlZWRTeW5jIiwibWVzc2FnZUxlbmd0aCIsIl9zZWVkIiwibmVlZGVkIiwic2VlZEZpbGUiLCJjb2xsZWN0Iiwic2VlZEZpbGVTeW5jIiwidXBkYXRlIiwiXzJwb3dLIiwiayIsImRpZ2VzdCIsInN0YXJ0Iiwic2VlZEJ5dGVzIiwiZGVmYXVsdFNlZWRGaWxlIiwiZ2V0UmFuZG9tVmFsdWVzIiwiZ2xvYmFsU2NvcGUiLCJjcnlwdG8iLCJtc0NyeXB0byIsImFyciIsIk1hdGgiLCJtYXgiLCJtaW4iLCJlbnRyb3B5IiwiVWludDMyQXJyYXkiLCJmbG9vciIsInB1dEludDMyIiwiZSIsIlF1b3RhRXhjZWVkZWRFcnJvciIsImhpIiwibG8iLCJuZXh0IiwicmFuZG9tIiwicHV0Qnl0ZSIsInJhbmRvbUJ5dGVzIiwidG9TdHJpbmciLCJzdWJzdHIiLCJjb2xsZWN0SW50IiwibiIsIngiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJyZWdpc3RlcldvcmtlciIsIndvcmtlciIsInNlbGYiLCJsaXN0ZW5lciIsImRhdGEiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBvc3RNZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/prng.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/pss.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/pss.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Javascript implementation of PKCS#1 PSS signature padding.\n *\n * @author Stefan Siegl\n *\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./random */ \"(rsc)/./node_modules/node-forge/lib/random.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\n// shortcut for PSS API\nvar pss = module.exports = forge.pss = forge.pss || {};\n/**\n * Creates a PSS signature scheme object.\n *\n * There are several ways to provide a salt for encoding:\n *\n * 1. Specify the saltLength only and the built-in PRNG will generate it.\n * 2. Specify the saltLength and a custom PRNG with 'getBytesSync' defined that\n *   will be used.\n * 3. Specify the salt itself as a forge.util.ByteBuffer.\n *\n * @param options the options to use:\n *          md the message digest object to use, a forge md instance.\n *          mgf the mask generation function to use, a forge mgf instance.\n *          [saltLength] the length of the salt in octets.\n *          [prng] the pseudo-random number generator to use to produce a salt.\n *          [salt] the salt to use when encoding.\n *\n * @return a signature scheme object.\n */ pss.create = function(options) {\n    // backwards compatibility w/legacy args: hash, mgf, sLen\n    if (arguments.length === 3) {\n        options = {\n            md: arguments[0],\n            mgf: arguments[1],\n            saltLength: arguments[2]\n        };\n    }\n    var hash = options.md;\n    var mgf = options.mgf;\n    var hLen = hash.digestLength;\n    var salt_ = options.salt || null;\n    if (typeof salt_ === \"string\") {\n        // assume binary-encoded string\n        salt_ = forge.util.createBuffer(salt_);\n    }\n    var sLen;\n    if (\"saltLength\" in options) {\n        sLen = options.saltLength;\n    } else if (salt_ !== null) {\n        sLen = salt_.length();\n    } else {\n        throw new Error(\"Salt length not specified or specific salt not given.\");\n    }\n    if (salt_ !== null && salt_.length() !== sLen) {\n        throw new Error(\"Given salt length does not match length of given salt.\");\n    }\n    var prng = options.prng || forge.random;\n    var pssobj = {};\n    /**\n   * Encodes a PSS signature.\n   *\n   * This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.\n   *\n   * @param md the message digest object with the hash to sign.\n   * @param modsBits the length of the RSA modulus in bits.\n   *\n   * @return the encoded message as a binary-encoded string of length\n   *           ceil((modBits - 1) / 8).\n   */ pssobj.encode = function(md, modBits) {\n        var i;\n        var emBits = modBits - 1;\n        var emLen = Math.ceil(emBits / 8);\n        /* 2. Let mHash = Hash(M), an octet string of length hLen. */ var mHash = md.digest().getBytes();\n        /* 3. If emLen < hLen + sLen + 2, output \"encoding error\" and stop. */ if (emLen < hLen + sLen + 2) {\n            throw new Error(\"Message is too long to encrypt.\");\n        }\n        /* 4. Generate a random octet string salt of length sLen; if sLen = 0,\n     *    then salt is the empty string. */ var salt;\n        if (salt_ === null) {\n            salt = prng.getBytesSync(sLen);\n        } else {\n            salt = salt_.bytes();\n        }\n        /* 5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; */ var m_ = new forge.util.ByteBuffer();\n        m_.fillWithByte(0, 8);\n        m_.putBytes(mHash);\n        m_.putBytes(salt);\n        /* 6. Let H = Hash(M'), an octet string of length hLen. */ hash.start();\n        hash.update(m_.getBytes());\n        var h = hash.digest().getBytes();\n        /* 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2\n     *    zero octets.  The length of PS may be 0. */ var ps = new forge.util.ByteBuffer();\n        ps.fillWithByte(0, emLen - sLen - hLen - 2);\n        /* 8. Let DB = PS || 0x01 || salt; DB is an octet string of length\n     *    emLen - hLen - 1. */ ps.putByte(0x01);\n        ps.putBytes(salt);\n        var db = ps.getBytes();\n        /* 9. Let dbMask = MGF(H, emLen - hLen - 1). */ var maskLen = emLen - hLen - 1;\n        var dbMask = mgf.generate(h, maskLen);\n        /* 10. Let maskedDB = DB \\xor dbMask. */ var maskedDB = \"\";\n        for(i = 0; i < maskLen; i++){\n            maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));\n        }\n        /* 11. Set the leftmost 8emLen - emBits bits of the leftmost octet in\n     *     maskedDB to zero. */ var mask = 0xFF00 >> 8 * emLen - emBits & 0xFF;\n        maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);\n        /* 12. Let EM = maskedDB || H || 0xbc.\n     * 13. Output EM. */ return maskedDB + h + String.fromCharCode(0xbc);\n    };\n    /**\n   * Verifies a PSS signature.\n   *\n   * This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.\n   *\n   * @param mHash the message digest hash, as a binary-encoded string, to\n   *         compare against the signature.\n   * @param em the encoded message, as a binary-encoded string\n   *          (RSA decryption result).\n   * @param modsBits the length of the RSA modulus in bits.\n   *\n   * @return true if the signature was verified, false if not.\n   */ pssobj.verify = function(mHash, em, modBits) {\n        var i;\n        var emBits = modBits - 1;\n        var emLen = Math.ceil(emBits / 8);\n        /* c. Convert the message representative m to an encoded message EM\n     *    of length emLen = ceil((modBits - 1) / 8) octets, where modBits\n     *    is the length in bits of the RSA modulus n */ em = em.substr(-emLen);\n        /* 3. If emLen < hLen + sLen + 2, output \"inconsistent\" and stop. */ if (emLen < hLen + sLen + 2) {\n            throw new Error(\"Inconsistent parameters to PSS signature verification.\");\n        }\n        /* 4. If the rightmost octet of EM does not have hexadecimal value\n     *    0xbc, output \"inconsistent\" and stop. */ if (em.charCodeAt(emLen - 1) !== 0xbc) {\n            throw new Error(\"Encoded message does not end in 0xBC.\");\n        }\n        /* 5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and\n     *    let H be the next hLen octets. */ var maskLen = emLen - hLen - 1;\n        var maskedDB = em.substr(0, maskLen);\n        var h = em.substr(maskLen, hLen);\n        /* 6. If the leftmost 8emLen - emBits bits of the leftmost octet in\n     *    maskedDB are not all equal to zero, output \"inconsistent\" and stop. */ var mask = 0xFF00 >> 8 * emLen - emBits & 0xFF;\n        if ((maskedDB.charCodeAt(0) & mask) !== 0) {\n            throw new Error(\"Bits beyond keysize not zero as expected.\");\n        }\n        /* 7. Let dbMask = MGF(H, emLen - hLen - 1). */ var dbMask = mgf.generate(h, maskLen);\n        /* 8. Let DB = maskedDB \\xor dbMask. */ var db = \"\";\n        for(i = 0; i < maskLen; i++){\n            db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));\n        }\n        /* 9. Set the leftmost 8emLen - emBits bits of the leftmost octet\n     * in DB to zero. */ db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);\n        /* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero\n     * or if the octet at position emLen - hLen - sLen - 1 (the leftmost\n     * position is \"position 1\") does not have hexadecimal value 0x01,\n     * output \"inconsistent\" and stop. */ var checkLen = emLen - hLen - sLen - 2;\n        for(i = 0; i < checkLen; i++){\n            if (db.charCodeAt(i) !== 0x00) {\n                throw new Error(\"Leftmost octets not zero as expected\");\n            }\n        }\n        if (db.charCodeAt(checkLen) !== 0x01) {\n            throw new Error(\"Inconsistent PSS signature, 0x01 marker not found\");\n        }\n        /* 11. Let salt be the last sLen octets of DB. */ var salt = db.substr(-sLen);\n        /* 12.  Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */ var m_ = new forge.util.ByteBuffer();\n        m_.fillWithByte(0, 8);\n        m_.putBytes(mHash);\n        m_.putBytes(salt);\n        /* 13. Let H' = Hash(M'), an octet string of length hLen. */ hash.start();\n        hash.update(m_.getBytes());\n        var h_ = hash.digest().getBytes();\n        /* 14. If H = H', output \"consistent.\" Otherwise, output \"inconsistent.\" */ return h === h_;\n    };\n    return pssobj;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcHNzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Q0FNQztBQUNELElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUVSLHVCQUF1QjtBQUN2QixJQUFJQyxNQUFNQyxPQUFPQyxPQUFPLEdBQUdKLE1BQU1FLEdBQUcsR0FBR0YsTUFBTUUsR0FBRyxJQUFJLENBQUM7QUFFckQ7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNEQSxJQUFJRyxNQUFNLEdBQUcsU0FBU0MsT0FBTztJQUMzQix5REFBeUQ7SUFDekQsSUFBR0MsVUFBVUMsTUFBTSxLQUFLLEdBQUc7UUFDekJGLFVBQVU7WUFDUkcsSUFBSUYsU0FBUyxDQUFDLEVBQUU7WUFDaEJHLEtBQUtILFNBQVMsQ0FBQyxFQUFFO1lBQ2pCSSxZQUFZSixTQUFTLENBQUMsRUFBRTtRQUMxQjtJQUNGO0lBRUEsSUFBSUssT0FBT04sUUFBUUcsRUFBRTtJQUNyQixJQUFJQyxNQUFNSixRQUFRSSxHQUFHO0lBQ3JCLElBQUlHLE9BQU9ELEtBQUtFLFlBQVk7SUFFNUIsSUFBSUMsUUFBUVQsUUFBUVUsSUFBSSxJQUFJO0lBQzVCLElBQUcsT0FBT0QsVUFBVSxVQUFVO1FBQzVCLCtCQUErQjtRQUMvQkEsUUFBUWYsTUFBTWlCLElBQUksQ0FBQ0MsWUFBWSxDQUFDSDtJQUNsQztJQUVBLElBQUlJO0lBQ0osSUFBRyxnQkFBZ0JiLFNBQVM7UUFDMUJhLE9BQU9iLFFBQVFLLFVBQVU7SUFDM0IsT0FBTyxJQUFHSSxVQUFVLE1BQU07UUFDeEJJLE9BQU9KLE1BQU1QLE1BQU07SUFDckIsT0FBTztRQUNMLE1BQU0sSUFBSVksTUFBTTtJQUNsQjtJQUVBLElBQUdMLFVBQVUsUUFBUUEsTUFBTVAsTUFBTSxPQUFPVyxNQUFNO1FBQzVDLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJQUVBLElBQUlDLE9BQU9m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O1FBQ1Y1QixLQUFLNkIsTUFBTSxDQUFDTCxHQUFHSCxRQUFRO1FBQ3ZCLElBQUl5QixLQUFLOUMsS0FBS29CLE1BQU0sR0FBR0MsUUFBUTtRQUUvQix5RUFBeUUsR0FDekUsT0FBT1MsTUFBTWdCO0lBQ2Y7SUFFQSxPQUFPbkM7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9wc3MuanM/ODdhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgUEtDUyMxIFBTUyBzaWduYXR1cmUgcGFkZGluZy5cbiAqXG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL3JhbmRvbScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIHNob3J0Y3V0IGZvciBQU1MgQVBJXG52YXIgcHNzID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wc3MgPSBmb3JnZS5wc3MgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIFBTUyBzaWduYXR1cmUgc2NoZW1lIG9iamVjdC5cbiAqXG4gKiBUaGVyZSBhcmUgc2V2ZXJhbCB3YXlzIHRvIHByb3ZpZGUgYSBzYWx0IGZvciBlbmNvZGluZzpcbiAqXG4gKiAxLiBTcGVjaWZ5IHRoZSBzYWx0TGVuZ3RoIG9ubHkgYW5kIHRoZSBidWlsdC1pbiBQUk5HIHdpbGwgZ2VuZXJhdGUgaXQuXG4gKiAyLiBTcGVjaWZ5IHRoZSBzYWx0TGVuZ3RoIGFuZCBhIGN1c3RvbSBQUk5HIHdpdGggJ2dldEJ5dGVzU3luYycgZGVmaW5lZCB0aGF0XG4gKiAgIHdpbGwgYmUgdXNlZC5cbiAqIDMuIFNwZWNpZnkgdGhlIHNhbHQgaXRzZWxmIGFzIGEgZm9yZ2UudXRpbC5CeXRlQnVmZmVyLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlLCBhIGZvcmdlIG1kIGluc3RhbmNlLlxuICogICAgICAgICAgbWdmIHRoZSBtYXNrIGdlbmVyYXRpb24gZnVuY3Rpb24gdG8gdXNlLCBhIGZvcmdlIG1nZiBpbnN0YW5jZS5cbiAqICAgICAgICAgIFtzYWx0TGVuZ3RoXSB0aGUgbGVuZ3RoIG9mIHRoZSBzYWx0IGluIG9jdGV0cy5cbiAqICAgICAgICAgIFtwcm5nXSB0aGUgcHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZSB0byBwcm9kdWNlIGEgc2FsdC5cbiAqICAgICAgICAgIFtzYWx0XSB0aGUgc2FsdCB0byB1c2Ugd2hlbiBlbmNvZGluZy5cbiAqXG4gKiBAcmV0dXJuIGEgc2lnbmF0dXJlIHNjaGVtZSBvYmplY3QuXG4gKi9cbnBzcy5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHcvbGVnYWN5IGFyZ3M6IGhhc2gsIG1nZiwgc0xlblxuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIG1kOiBhcmd1bWVudHNbMF0sXG4gICAgICBtZ2Y6IGFyZ3VtZW50c1sxXSxcbiAgICAgIHNhbHRMZW5ndGg6IGFyZ3VtZW50c1syXVxuICAgIH07XG4gIH1cblxuICB2YXIgaGFzaCA9IG9wdGlvbnMubWQ7XG4gIHZhciBtZ2YgPSBvcHRpb25zLm1nZjtcbiAgdmFyIGhMZW4gPSBoYXNoLmRpZ2VzdExlbmd0aDtcblxuICB2YXIgc2FsdF8gPSBvcHRpb25zLnNhbHQgfHwgbnVsbDtcbiAgaWYodHlwZW9mIHNhbHRfID09PSAnc3RyaW5nJykge1xuICAgIC8vIGFzc3VtZSBiaW5hcnktZW5jb2RlZCBzdHJpbmdcbiAgICBzYWx0XyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKHNhbHRfKTtcbiAgfVxuXG4gIHZhciBzTGVuO1xuICBpZignc2FsdExlbmd0aCcgaW4gb3B0aW9ucykge1xuICAgIHNMZW4gPSBvcHRpb25zLnNhbHRMZW5ndGg7XG4gIH0gZWxzZSBpZihzYWx0XyAhPT0gbnVsbCkge1xuICAgIHNMZW4gPSBzYWx0Xy5sZW5ndGgoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NhbHQgbGVuZ3RoIG5vdCBzcGVjaWZpZWQgb3Igc3BlY2lmaWMgc2FsdCBub3QgZ2l2ZW4uJyk7XG4gIH1cblxuICBpZihzYWx0XyAhPT0gbnVsbCAmJiBzYWx0Xy5sZW5ndGgoKSAhPT0gc0xlbikge1xuICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gc2FsdCBsZW5ndGggZG9lcyBub3QgbWF0Y2ggbGVuZ3RoIG9mIGdpdmVuIHNhbHQuJyk7XG4gIH1cblxuICB2YXIgcHJuZyA9IG9wdGlvbnMucHJuZyB8fCBmb3JnZS5yYW5kb207XG5cbiAgdmFyIHBzc29iaiA9IHt9O1xuXG4gIC8qKlxuICAgKiBFbmNvZGVzIGEgUFNTIHNpZ25hdHVyZS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIEVNU0EtUFNTLUVOQ09ERSBhcyBwZXIgUkZDIDM0NDcsIHNlY3Rpb24gOS4xLjEuXG4gICAqXG4gICAqIEBwYXJhbSBtZCB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHdpdGggdGhlIGhhc2ggdG8gc2lnbi5cbiAgICogQHBhcmFtIG1vZHNCaXRzIHRoZSBsZW5ndGggb2YgdGhlIFJTQSBtb2R1bHVzIGluIGJpdHMuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIGVuY29kZWQgbWVzc2FnZSBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBsZW5ndGhcbiAgICogICAgICAgICAgIGNlaWwoKG1vZEJpdHMgLSAxKSAvIDgpLlxuICAgKi9cbiAgcHNzb2JqLmVuY29kZSA9IGZ1bmN0aW9uKG1kLCBtb2RCaXRzKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGVtQml0cyA9IG1vZEJpdHMgLSAxO1xuICAgIHZhciBlbUxlbiA9IE1hdGguY2VpbChlbUJpdHMgLyA4KTtcblxuICAgIC8qIDIuIExldCBtSGFzaCA9IEhhc2goTSksIGFuIG9jdGV0IHN0cmluZyBvZiBsZW5ndGggaExlbi4gKi9cbiAgICB2YXIgbUhhc2ggPSBtZC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gICAgLyogMy4gSWYgZW1MZW4gPCBoTGVuICsgc0xlbiArIDIsIG91dHB1dCBcImVuY29kaW5nIGVycm9yXCIgYW5kIHN0b3AuICovXG4gICAgaWYoZW1MZW4gPCBoTGVuICsgc0xlbiArIDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWVzc2FnZSBpcyB0b28gbG9uZyB0byBlbmNyeXB0LicpO1xuICAgIH1cblxuICAgIC8qIDQuIEdlbmVyYXRlIGEgcmFuZG9tIG9jdGV0IHN0cmluZyBzYWx0IG9mIGxlbmd0aCBzTGVuOyBpZiBzTGVuID0gMCxcbiAgICAgKiAgICB0aGVuIHNhbHQgaXMgdGhlIGVtcHR5IHN0cmluZy4gKi9cbiAgICB2YXIgc2FsdDtcbiAgICBpZihzYWx0XyA9PT0gbnVsbCkge1xuICAgICAgc2FsdCA9IHBybmcuZ2V0Qnl0ZXNTeW5jKHNMZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzYWx0ID0gc2FsdF8uYnl0ZXMoKTtcbiAgICB9XG5cbiAgICAvKiA1LiBMZXQgTScgPSAoMHgpMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgfHwgbUhhc2ggfHwgc2FsdDsgKi9cbiAgICB2YXIgbV8gPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgbV8uZmlsbFdpdGhCeXRlKDAsIDgpO1xuICAgIG1fLnB1dEJ5dGVzKG1IYXNoKTtcbiAgICBtXy5wdXRCeXRlcyhzYWx0KTtcblxuICAgIC8qIDYuIExldCBIID0gSGFzaChNJyksIGFuIG9jdGV0IHN0cmluZyBvZiBsZW5ndGggaExlbi4gKi9cbiAgICBoYXNoLnN0YXJ0KCk7XG4gICAgaGFzaC51cGRhdGUobV8uZ2V0Qnl0ZXMoKSk7XG4gICAgdmFyIGggPSBoYXNoLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvKiA3LiBHZW5lcmF0ZSBhbiBvY3RldCBzdHJpbmcgUFMgY29uc2lzdGluZyBvZiBlbUxlbiAtIHNMZW4gLSBoTGVuIC0gMlxuICAgICAqICAgIHplcm8gb2N0ZXRzLiAgVGhlIGxlbmd0aCBvZiBQUyBtYXkgYmUgMC4gKi9cbiAgICB2YXIgcHMgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgcHMuZmlsbFdpdGhCeXRlKDAsIGVtTGVuIC0gc0xlbiAtIGhMZW4gLSAyKTtcblxuICAgIC8qIDguIExldCBEQiA9IFBTIHx8IDB4MDEgfHwgc2FsdDsgREIgaXMgYW4gb2N0ZXQgc3RyaW5nIG9mIGxlbmd0aFxuICAgICAqICAgIGVtTGVuIC0gaExlbiAtIDEuICovXG4gICAgcHMucHV0Qnl0ZSgweDAxKTtcbiAgICBwcy5wdXRCeXRlcyhzYWx0KTtcbiAgICB2YXIgZGIgPSBwcy5nZXRCeXRlcygpO1xuXG4gICAgLyogOS4gTGV0IGRiTWFzayA9IE1HRihILCBlbUxlbiAtIGhMZW4gLSAxKS4gKi9cbiAgICB2YXIgbWFza0xlbiA9IGVtTGVuIC0gaExlbiAtIDE7XG4gICAgdmFyIGRiTWFzayA9IG1nZi5nZW5lcmF0ZShoLCBtYXNrTGVuKTtcblxuICAgIC8qIDEwLiBMZXQgbWFza2VkREIgPSBEQiBcXHhvciBkYk1hc2suICovXG4gICAgdmFyIG1hc2tlZERCID0gJyc7XG4gICAgZm9yKGkgPSAwOyBpIDwgbWFza0xlbjsgaSsrKSB7XG4gICAgICBtYXNrZWREQiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRiLmNoYXJDb2RlQXQoaSkgXiBkYk1hc2suY2hhckNvZGVBdChpKSk7XG4gICAgfVxuXG4gICAgLyogMTEuIFNldCB0aGUgbGVmdG1vc3QgOGVtTGVuIC0gZW1CaXRzIGJpdHMgb2YgdGhlIGxlZnRtb3N0IG9jdGV0IGluXG4gICAgICogICAgIG1hc2tlZERCIHRvIHplcm8uICovXG4gICAgdmFyIG1hc2sgPSAoMHhGRjAwID4+ICg4ICogZW1MZW4gLSBlbUJpdHMpKSAmIDB4RkY7XG4gICAgbWFza2VkREIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hc2tlZERCLmNoYXJDb2RlQXQoMCkgJiB+bWFzaykgK1xuICAgICAgbWFza2VkREIuc3Vic3RyKDEpO1xuXG4gICAgLyogMTIuIExldCBFTSA9IG1hc2tlZERCIHx8IEggfHwgMHhiYy5cbiAgICAgKiAxMy4gT3V0cHV0IEVNLiAqL1xuICAgIHJldHVybiBtYXNrZWREQiArIGggKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4YmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWZXJpZmllcyBhIFBTUyBzaWduYXR1cmUuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyBFTVNBLVBTUy1WRVJJRlkgYXMgcGVyIFJGQyAzNDQ3LCBzZWN0aW9uIDkuMS4yLlxuICAgKlxuICAgKiBAcGFyYW0gbUhhc2ggdGhlIG1lc3NhZ2UgZGlnZXN0IGhhc2gsIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nLCB0b1xuICAgKiAgICAgICAgIGNvbXBhcmUgYWdhaW5zdCB0aGUgc2lnbmF0dXJlLlxuICAgKiBAcGFyYW0gZW0gdGhlIGVuY29kZWQgbWVzc2FnZSwgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmdcbiAgICogICAgICAgICAgKFJTQSBkZWNyeXB0aW9uIHJlc3VsdCkuXG4gICAqIEBwYXJhbSBtb2RzQml0cyB0aGUgbGVuZ3RoIG9mIHRoZSBSU0EgbW9kdWx1cyBpbiBiaXRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIHNpZ25hdHVyZSB3YXMgdmVyaWZpZWQsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIHBzc29iai52ZXJpZnkgPSBmdW5jdGlvbihtSGFzaCwgZW0sIG1vZEJpdHMpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgZW1CaXRzID0gbW9kQml0cyAtIDE7XG4gICAgdmFyIGVtTGVuID0gTWF0aC5jZWlsKGVtQml0cyAvIDgpO1xuXG4gICAgLyogYy4gQ29udmVydCB0aGUgbWVzc2FnZSByZXByZXNlbnRhdGl2ZSBtIHRvIGFuIGVuY29kZWQgbWVzc2FnZSBFTVxuICAgICAqICAgIG9mIGxlbmd0aCBlbUxlbiA9IGNlaWwoKG1vZEJpdHMgLSAxKSAvIDgpIG9jdGV0cywgd2hlcmUgbW9kQml0c1xuICAgICAqICAgIGlzIHRoZSBsZW5ndGggaW4gYml0cyBvZiB0aGUgUlNBIG1vZHVsdXMgbiAqL1xuICAgIGVtID0gZW0uc3Vic3RyKC1lbUxlbik7XG5cbiAgICAvKiAzLiBJZiBlbUxlbiA8IGhMZW4gKyBzTGVuICsgMiwgb3V0cHV0IFwiaW5jb25zaXN0ZW50XCIgYW5kIHN0b3AuICovXG4gICAgaWYoZW1MZW4gPCBoTGVuICsgc0xlbiArIDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb25zaXN0ZW50IHBhcmFtZXRlcnMgdG8gUFNTIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24uJyk7XG4gICAgfVxuXG4gICAgLyogNC4gSWYgdGhlIHJpZ2h0bW9zdCBvY3RldCBvZiBFTSBkb2VzIG5vdCBoYXZlIGhleGFkZWNpbWFsIHZhbHVlXG4gICAgICogICAgMHhiYywgb3V0cHV0IFwiaW5jb25zaXN0ZW50XCIgYW5kIHN0b3AuICovXG4gICAgaWYoZW0uY2hhckNvZGVBdChlbUxlbiAtIDEpICE9PSAweGJjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY29kZWQgbWVzc2FnZSBkb2VzIG5vdCBlbmQgaW4gMHhCQy4nKTtcbiAgICB9XG5cbiAgICAvKiA1LiBMZXQgbWFza2VkREIgYmUgdGhlIGxlZnRtb3N0IGVtTGVuIC0gaExlbiAtIDEgb2N0ZXRzIG9mIEVNLCBhbmRcbiAgICAgKiAgICBsZXQgSCBiZSB0aGUgbmV4dCBoTGVuIG9jdGV0cy4gKi9cbiAgICB2YXIgbWFza0xlbiA9IGVtTGVuIC0gaExlbiAtIDE7XG4gICAgdmFyIG1hc2tlZERCID0gZW0uc3Vic3RyKDAsIG1hc2tMZW4pO1xuICAgIHZhciBoID0gZW0uc3Vic3RyKG1hc2tMZW4sIGhMZW4pO1xuXG4gICAgLyogNi4gSWYgdGhlIGxlZnRtb3N0IDhlbUxlbiAtIGVtQml0cyBiaXRzIG9mIHRoZSBsZWZ0bW9zdCBvY3RldCBpblxuICAgICAqICAgIG1hc2tlZERCIGFyZSBub3QgYWxsIGVxdWFsIHRvIHplcm8sIG91dHB1dCBcImluY29uc2lzdGVudFwiIGFuZCBzdG9wLiAqL1xuICAgIHZhciBtYXNrID0gKDB4RkYwMCA+PiAoOCAqIGVtTGVuIC0gZW1CaXRzKSkgJiAweEZGO1xuICAgIGlmKChtYXNrZWREQi5jaGFyQ29kZUF0KDApICYgbWFzaykgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQml0cyBiZXlvbmQga2V5c2l6ZSBub3QgemVybyBhcyBleHBlY3RlZC4nKTtcbiAgICB9XG5cbiAgICAvKiA3LiBMZXQgZGJNYXNrID0gTUdGKEgsIGVtTGVuIC0gaExlbiAtIDEpLiAqL1xuICAgIHZhciBkYk1hc2sgPSBtZ2YuZ2VuZXJhdGUoaCwgbWFza0xlbik7XG5cbiAgICAvKiA4LiBMZXQgREIgPSBtYXNrZWREQiBcXHhvciBkYk1hc2suICovXG4gICAgdmFyIGRiID0gJyc7XG4gICAgZm9yKGkgPSAwOyBpIDwgbWFza0xlbjsgaSsrKSB7XG4gICAgICBkYiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hc2tlZERCLmNoYXJDb2RlQXQoaSkgXiBkYk1hc2suY2hhckNvZGVBdChpKSk7XG4gICAgfVxuXG4gICAgLyogOS4gU2V0IHRoZSBsZWZ0bW9zdCA4ZW1MZW4gLSBlbUJpdHMgYml0cyBvZiB0aGUgbGVmdG1vc3Qgb2N0ZXRcbiAgICAgKiBpbiBEQiB0byB6ZXJvLiAqL1xuICAgIGRiID0gU3RyaW5nLmZyb21DaGFyQ29kZShkYi5jaGFyQ29kZUF0KDApICYgfm1hc2spICsgZGIuc3Vic3RyKDEpO1xuXG4gICAgLyogMTAuIElmIHRoZSBlbUxlbiAtIGhMZW4gLSBzTGVuIC0gMiBsZWZ0bW9zdCBvY3RldHMgb2YgREIgYXJlIG5vdCB6ZXJvXG4gICAgICogb3IgaWYgdGhlIG9jdGV0IGF0IHBvc2l0aW9uIGVtTGVuIC0gaExlbiAtIHNMZW4gLSAxICh0aGUgbGVmdG1vc3RcbiAgICAgKiBwb3NpdGlvbiBpcyBcInBvc2l0aW9uIDFcIikgZG9lcyBub3QgaGF2ZSBoZXhhZGVjaW1hbCB2YWx1ZSAweDAxLFxuICAgICAqIG91dHB1dCBcImluY29uc2lzdGVudFwiIGFuZCBzdG9wLiAqL1xuICAgIHZhciBjaGVja0xlbiA9IGVtTGVuIC0gaExlbiAtIHNMZW4gLSAyO1xuICAgIGZvcihpID0gMDsgaSA8IGNoZWNrTGVuOyBpKyspIHtcbiAgICAgIGlmKGRiLmNoYXJDb2RlQXQoaSkgIT09IDB4MDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZWZ0bW9zdCBvY3RldHMgbm90IHplcm8gYXMgZXhwZWN0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihkYi5jaGFyQ29kZUF0KGNoZWNrTGVuKSAhPT0gMHgwMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbnNpc3RlbnQgUFNTIHNpZ25hdHVyZSwgMHgwMSBtYXJrZXIgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgLyogMTEuIExldCBzYWx0IGJlIHRoZSBsYXN0IHNMZW4gb2N0ZXRzIG9mIERCLiAqL1xuICAgIHZhciBzYWx0ID0gZGIuc3Vic3RyKC1zTGVuKTtcblxuICAgIC8qIDEyLiAgTGV0IE0nID0gKDB4KTAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIHx8IG1IYXNoIHx8IHNhbHQgKi9cbiAgICB2YXIgbV8gPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgbV8uZmlsbFdpdGhCeXRlKDAsIDgpO1xuICAgIG1fLnB1dEJ5dGVzKG1IYXNoKTtcbiAgICBtXy5wdXRCeXRlcyhzYWx0KTtcblxuICAgIC8qIDEzLiBMZXQgSCcgPSBIYXNoKE0nKSwgYW4gb2N0ZXQgc3RyaW5nIG9mIGxlbmd0aCBoTGVuLiAqL1xuICAgIGhhc2guc3RhcnQoKTtcbiAgICBoYXNoLnVwZGF0ZShtXy5nZXRCeXRlcygpKTtcbiAgICB2YXIgaF8gPSBoYXNoLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvKiAxNC4gSWYgSCA9IEgnLCBvdXRwdXQgXCJjb25zaXN0ZW50LlwiIE90aGVyd2lzZSwgb3V0cHV0IFwiaW5jb25zaXN0ZW50LlwiICovXG4gICAgcmV0dXJuIGggPT09IGhfO1xuICB9O1xuXG4gIHJldHVybiBwc3NvYmo7XG59O1xuIl0sIm5hbWVzIjpbImZvcmdlIiwicmVxdWlyZSIsInBzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJjcmVhdGUiLCJvcHRpb25zIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwibWQiLCJtZ2YiLCJzYWx0TGVuZ3RoIiwiaGFzaCIsImhMZW4iLCJkaWdlc3RMZW5ndGgiLCJzYWx0XyIsInNhbHQiLCJ1dGlsIiwiY3JlYXRlQnVmZmVyIiwic0xlbiIsIkVycm9yIiwicHJuZyIsInJhbmRvbSIsInBzc29iaiIsImVuY29kZSIsIm1vZEJpdHMiLCJpIiwiZW1CaXRzIiwiZW1MZW4iLCJNYXRoIiwiY2VpbCIsIm1IYXNoIiwiZGlnZXN0IiwiZ2V0Qnl0ZXMiLCJnZXRCeXRlc1N5bmMiLCJieXRlcyIsIm1fIiwiQnl0ZUJ1ZmZlciIsImZpbGxXaXRoQnl0ZSIsInB1dEJ5dGVzIiwic3RhcnQiLCJ1cGRhdGUiLCJoIiwicHMiLCJwdXRCeXRlIiwiZGIiLCJtYXNrTGVuIiwiZGJNYXNrIiwiZ2VuZXJhdGUiLCJtYXNrZWREQiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImNoYXJDb2RlQXQiLCJtYXNrIiwic3Vic3RyIiwidmVyaWZ5IiwiZW0iLCJjaGVja0xlbiIsImhfIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/pss.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/random.js":
/*!***********************************************!*\
  !*** ./node_modules/node-forge/lib/random.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * An API for getting cryptographically-secure random bytes. The bytes are\n * generated using the Fortuna algorithm devised by Bruce Schneier and\n * Niels Ferguson.\n *\n * Getting strong random bytes is not yet easy to do in javascript. The only\n * truish random entropy that can be collected is from the mouse, keyboard, or\n * from timing with respect to page loads, etc. This generator makes a poor\n * attempt at providing random bytes when those sources haven't yet provided\n * enough entropy to initially seed or to reseed the PRNG.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2009-2014 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./aes */ \"(rsc)/./node_modules/node-forge/lib/aes.js\");\n__webpack_require__(/*! ./sha256 */ \"(rsc)/./node_modules/node-forge/lib/sha256.js\");\n__webpack_require__(/*! ./prng */ \"(rsc)/./node_modules/node-forge/lib/prng.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\n(function() {\n    // forge.random already defined\n    if (forge.random && forge.random.getBytes) {\n        module.exports = forge.random;\n        return;\n    }\n    (function(jQuery1) {\n        // the default prng plugin, uses AES-128\n        var prng_aes = {};\n        var _prng_aes_output = new Array(4);\n        var _prng_aes_buffer = forge.util.createBuffer();\n        prng_aes.formatKey = function(key) {\n            // convert the key into 32-bit integers\n            var tmp = forge.util.createBuffer(key);\n            key = new Array(4);\n            key[0] = tmp.getInt32();\n            key[1] = tmp.getInt32();\n            key[2] = tmp.getInt32();\n            key[3] = tmp.getInt32();\n            // return the expanded key\n            return forge.aes._expandKey(key, false);\n        };\n        prng_aes.formatSeed = function(seed) {\n            // convert seed into 32-bit integers\n            var tmp = forge.util.createBuffer(seed);\n            seed = new Array(4);\n            seed[0] = tmp.getInt32();\n            seed[1] = tmp.getInt32();\n            seed[2] = tmp.getInt32();\n            seed[3] = tmp.getInt32();\n            return seed;\n        };\n        prng_aes.cipher = function(key, seed) {\n            forge.aes._updateBlock(key, seed, _prng_aes_output, false);\n            _prng_aes_buffer.putInt32(_prng_aes_output[0]);\n            _prng_aes_buffer.putInt32(_prng_aes_output[1]);\n            _prng_aes_buffer.putInt32(_prng_aes_output[2]);\n            _prng_aes_buffer.putInt32(_prng_aes_output[3]);\n            return _prng_aes_buffer.getBytes();\n        };\n        prng_aes.increment = function(seed) {\n            // FIXME: do we care about carry or signed issues?\n            ++seed[3];\n            return seed;\n        };\n        prng_aes.md = forge.md.sha256;\n        /**\n * Creates a new PRNG.\n */ function spawnPrng() {\n            var ctx = forge.prng.create(prng_aes);\n            /**\n   * Gets random bytes. If a native secure crypto API is unavailable, this\n   * method tries to make the bytes more unpredictable by drawing from data that\n   * can be collected from the user of the browser, eg: mouse movement.\n   *\n   * If a callback is given, this method will be called asynchronously.\n   *\n   * @param count the number of random bytes to get.\n   * @param [callback(err, bytes)] called once the operation completes.\n   *\n   * @return the random bytes in a string.\n   */ ctx.getBytes = function(count, callback) {\n                return ctx.generate(count, callback);\n            };\n            /**\n   * Gets random bytes asynchronously. If a native secure crypto API is\n   * unavailable, this method tries to make the bytes more unpredictable by\n   * drawing from data that can be collected from the user of the browser,\n   * eg: mouse movement.\n   *\n   * @param count the number of random bytes to get.\n   *\n   * @return the random bytes in a string.\n   */ ctx.getBytesSync = function(count) {\n                return ctx.generate(count);\n            };\n            return ctx;\n        }\n        // create default prng context\n        var _ctx = spawnPrng();\n        // add other sources of entropy only if window.crypto.getRandomValues is not\n        // available -- otherwise this source will be automatically used by the prng\n        var getRandomValues = null;\n        var globalScope = forge.util.globalScope;\n        var _crypto = globalScope.crypto || globalScope.msCrypto;\n        if (_crypto && _crypto.getRandomValues) {\n            getRandomValues = function(arr) {\n                return _crypto.getRandomValues(arr);\n            };\n        }\n        if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) {\n            // if this is a web worker, do not use weak entropy, instead register to\n            // receive strong entropy asynchronously from the main thread\n            if (true) {\n            // FIXME:\n            }\n            // get load time entropy\n            _ctx.collectInt(+new Date(), 32);\n            // add some entropy from navigator object\n            if (typeof navigator !== \"undefined\") {\n                var _navBytes = \"\";\n                for(var key in navigator){\n                    try {\n                        if (typeof navigator[key] == \"string\") {\n                            _navBytes += navigator[key];\n                        }\n                    } catch (e) {\n                    /* Some navigator keys might not be accessible, e.g. the geolocation\n          attribute throws an exception if touched in Mozilla chrome://\n          context.\n\n          Silently ignore this and just don't use this as a source of\n          entropy. */ }\n                }\n                _ctx.collect(_navBytes);\n                _navBytes = null;\n            }\n            // add mouse and keyboard collectors if jquery is available\n            if (jQuery1) {\n                // set up mouse entropy capture\n                jQuery1().mousemove(function(e) {\n                    // add mouse coords\n                    _ctx.collectInt(e.clientX, 16);\n                    _ctx.collectInt(e.clientY, 16);\n                });\n                // set up keyboard entropy capture\n                jQuery1().keypress(function(e) {\n                    _ctx.collectInt(e.charCode, 8);\n                });\n            }\n        }\n        /* Random API */ if (!forge.random) {\n            forge.random = _ctx;\n        } else {\n            // extend forge.random with _ctx\n            for(var key in _ctx){\n                forge.random[key] = _ctx[key];\n            }\n        }\n        // expose spawn PRNG\n        forge.random.createInstance = spawnPrng;\n        module.exports = forge.random;\n    })(typeof jQuery !== \"undefined\" ? jQuery : null);\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcmFuZG9tLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7OztDQWNDO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVA7SUFFRCwrQkFBK0I7SUFDL0IsSUFBR0QsTUFBTUUsTUFBTSxJQUFJRixNQUFNRSxNQUFNLENBQUNDLFFBQVEsRUFBRTtRQUN4Q0MsT0FBT0MsT0FBTyxHQUFHTCxNQUFNRSxNQUFNO1FBQzdCO0lBQ0Y7SUFFQyxVQUFTSSxPQUFNO1FBRWhCLHdDQUF3QztRQUN4QyxJQUFJQyxXQUFXLENBQUM7UUFDaEIsSUFBSUMsbUJBQW1CLElBQUlDLE1BQU07UUFDakMsSUFBSUMsbUJBQW1CVixNQUFNVyxJQUFJLENBQUNDLFlBQVk7UUFDOUNMLFNBQVNNLFNBQVMsR0FBRyxTQUFTQyxHQUFHO1lBQy9CLHVDQUF1QztZQUN2QyxJQUFJQyxNQUFNZixNQUFNVyxJQUFJLENBQUNDLFlBQVksQ0FBQ0U7WUFDbENBLE1BQU0sSUFBSUwsTUFBTTtZQUNoQkssR0FBRyxDQUFDLEVBQUUsR0FBR0MsSUFBSUMsUUFBUTtZQUNyQkYsR0FBRyxDQUFDLEVBQUUsR0FBR0MsSUFBSUMsUUFBUTtZQUNyQkYsR0FBRyxDQUFDLEVBQUUsR0FBR0MsSUFBSUMsUUFBUTtZQUNyQkYsR0FBRyxDQUFDLEVBQUUsR0FBR0MsSUFBSUMsUUFBUTtZQUVyQiwwQkFBMEI7WUFDMUIsT0FBT2hCLE1BQU1pQixHQUFHLENBQUNDLFVBQVUsQ0FBQ0osS0FBSztRQUNuQztRQUNBUCxTQUFTWSxVQUFVLEdBQUcsU0FBU0MsSUFBSTtZQUNqQyxvQ0FBb0M7WUFDcEMsSUFBSUwsTUFBTWYsTUFBTVcsSUFBSSxDQUFDQyxZQUFZLENBQUNRO1lBQ2xDQSxPQUFPLElBQUlYLE1BQU07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QUFDSSxFQUFFSSxPQUFPLEVBQUU7Z0JBQzdCO2dCQUVBLGtDQUFrQztnQkFDbENsRCxVQUFTbUQsUUFBUSxDQUFDLFNBQVNMLENBQUM7b0JBQzFCakIsS0FBS2EsVUFBVSxDQUFDSSxFQUFFTSxRQUFRLEVBQUU7Z0JBQzlCO1lBQ0Y7UUFDRjtRQUVBLGNBQWMsR0FDZCxJQUFHLENBQUMxRCxNQUFNRSxNQUFNLEVBQUU7WUFDaEJGLE1BQU1FLE1BQU0sR0FBR2lDO1FBQ2pCLE9BQU87WUFDTCxnQ0FBZ0M7WUFDaEMsSUFBSSxJQUFJckIsT0FBT3FCLEtBQU07Z0JBQ25CbkMsTUFBTUUsTUFBTSxDQUFDWSxJQUFJLEdBQUdxQixJQUFJLENBQUNyQixJQUFJO1lBQy9CO1FBQ0Y7UUFFQSxvQkFBb0I7UUFDcEJkLE1BQU1FLE1BQU0sQ0FBQ3lELGNBQWMsR0FBR2hDO1FBRTlCdkIsT0FBT0MsT0FBTyxHQUFHTCxNQUFNRSxNQUFNO0lBRTdCLEdBQUcsT0FBT0ksV0FBWSxjQUFjQSxTQUFTO0FBRTdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3JhbmRvbS5qcz9mYWI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQW4gQVBJIGZvciBnZXR0aW5nIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gYnl0ZXMuIFRoZSBieXRlcyBhcmVcbiAqIGdlbmVyYXRlZCB1c2luZyB0aGUgRm9ydHVuYSBhbGdvcml0aG0gZGV2aXNlZCBieSBCcnVjZSBTY2huZWllciBhbmRcbiAqIE5pZWxzIEZlcmd1c29uLlxuICpcbiAqIEdldHRpbmcgc3Ryb25nIHJhbmRvbSBieXRlcyBpcyBub3QgeWV0IGVhc3kgdG8gZG8gaW4gamF2YXNjcmlwdC4gVGhlIG9ubHlcbiAqIHRydWlzaCByYW5kb20gZW50cm9weSB0aGF0IGNhbiBiZSBjb2xsZWN0ZWQgaXMgZnJvbSB0aGUgbW91c2UsIGtleWJvYXJkLCBvclxuICogZnJvbSB0aW1pbmcgd2l0aCByZXNwZWN0IHRvIHBhZ2UgbG9hZHMsIGV0Yy4gVGhpcyBnZW5lcmF0b3IgbWFrZXMgYSBwb29yXG4gKiBhdHRlbXB0IGF0IHByb3ZpZGluZyByYW5kb20gYnl0ZXMgd2hlbiB0aG9zZSBzb3VyY2VzIGhhdmVuJ3QgeWV0IHByb3ZpZGVkXG4gKiBlbm91Z2ggZW50cm9weSB0byBpbml0aWFsbHkgc2VlZCBvciB0byByZXNlZWQgdGhlIFBSTkcuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL2FlcycpO1xucmVxdWlyZSgnLi9zaGEyNTYnKTtcbnJlcXVpcmUoJy4vcHJuZycpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbihmdW5jdGlvbigpIHtcblxuLy8gZm9yZ2UucmFuZG9tIGFscmVhZHkgZGVmaW5lZFxuaWYoZm9yZ2UucmFuZG9tICYmIGZvcmdlLnJhbmRvbS5nZXRCeXRlcykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnJhbmRvbTtcbiAgcmV0dXJuO1xufVxuXG4oZnVuY3Rpb24oalF1ZXJ5KSB7XG5cbi8vIHRoZSBkZWZhdWx0IHBybmcgcGx1Z2luLCB1c2VzIEFFUy0xMjhcbnZhciBwcm5nX2FlcyA9IHt9O1xudmFyIF9wcm5nX2Flc19vdXRwdXQgPSBuZXcgQXJyYXkoNCk7XG52YXIgX3BybmdfYWVzX2J1ZmZlciA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5wcm5nX2Flcy5mb3JtYXRLZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgLy8gY29udmVydCB0aGUga2V5IGludG8gMzItYml0IGludGVnZXJzXG4gIHZhciB0bXAgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihrZXkpO1xuICBrZXkgPSBuZXcgQXJyYXkoNCk7XG4gIGtleVswXSA9IHRtcC5nZXRJbnQzMigpO1xuICBrZXlbMV0gPSB0bXAuZ2V0SW50MzIoKTtcbiAga2V5WzJdID0gdG1wLmdldEludDMyKCk7XG4gIGtleVszXSA9IHRtcC5nZXRJbnQzMigpO1xuXG4gIC8vIHJldHVybiB0aGUgZXhwYW5kZWQga2V5XG4gIHJldHVybiBmb3JnZS5hZXMuX2V4cGFuZEtleShrZXksIGZhbHNlKTtcbn07XG5wcm5nX2Flcy5mb3JtYXRTZWVkID0gZnVuY3Rpb24oc2VlZCkge1xuICAvLyBjb252ZXJ0IHNlZWQgaW50byAzMi1iaXQgaW50ZWdlcnNcbiAgdmFyIHRtcCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKHNlZWQpO1xuICBzZWVkID0gbmV3IEFycmF5KDQpO1xuICBzZWVkWzBdID0gdG1wLmdldEludDMyKCk7XG4gIHNlZWRbMV0gPSB0bXAuZ2V0SW50MzIoKTtcbiAgc2VlZFsyXSA9IHRtcC5nZXRJbnQzMigpO1xuICBzZWVkWzNdID0gdG1wLmdldEludDMyKCk7XG4gIHJldHVybiBzZWVkO1xufTtcbnBybmdfYWVzLmNpcGhlciA9IGZ1bmN0aW9uKGtleSwgc2VlZCkge1xuICBmb3JnZS5hZXMuX3VwZGF0ZUJsb2NrKGtleSwgc2VlZCwgX3BybmdfYWVzX291dHB1dCwgZmFsc2UpO1xuICBfcHJuZ19hZXNfYnVmZmVyLnB1dEludDMyKF9wcm5nX2Flc19vdXRwdXRbMF0pO1xuICBfcHJuZ19hZXNfYnVmZmVyLnB1dEludDMyKF9wcm5nX2Flc19vdXRwdXRbMV0pO1xuICBfcHJuZ19hZXNfYnVmZmVyLnB1dEludDMyKF9wcm5nX2Flc19vdXRwdXRbMl0pO1xuICBfcHJuZ19hZXNfYnVmZmVyLnB1dEludDMyKF9wcm5nX2Flc19vdXRwdXRbM10pO1xuICByZXR1cm4gX3BybmdfYWVzX2J1ZmZlci5nZXRCeXRlcygpO1xufTtcbnBybmdfYWVzLmluY3JlbWVudCA9IGZ1bmN0aW9uKHNlZWQpIHtcbiAgLy8gRklYTUU6IGRvIHdlIGNhcmUgYWJvdXQgY2Fycnkgb3Igc2lnbmVkIGlzc3Vlcz9cbiAgKytzZWVkWzNdO1xuICByZXR1cm4gc2VlZDtcbn07XG5wcm5nX2Flcy5tZCA9IGZvcmdlLm1kLnNoYTI1NjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFBSTkcuXG4gKi9cbmZ1bmN0aW9uIHNwYXduUHJuZygpIHtcbiAgdmFyIGN0eCA9IGZvcmdlLnBybmcuY3JlYXRlKHBybmdfYWVzKTtcblxuICAvKipcbiAgICogR2V0cyByYW5kb20gYnl0ZXMuIElmIGEgbmF0aXZlIHNlY3VyZSBjcnlwdG8gQVBJIGlzIHVuYXZhaWxhYmxlLCB0aGlzXG4gICAqIG1ldGhvZCB0cmllcyB0byBtYWtlIHRoZSBieXRlcyBtb3JlIHVucHJlZGljdGFibGUgYnkgZHJhd2luZyBmcm9tIGRhdGEgdGhhdFxuICAgKiBjYW4gYmUgY29sbGVjdGVkIGZyb20gdGhlIHVzZXIgb2YgdGhlIGJyb3dzZXIsIGVnOiBtb3VzZSBtb3ZlbWVudC5cbiAgICpcbiAgICogSWYgYSBjYWxsYmFjayBpcyBnaXZlbiwgdGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkuXG4gICAqXG4gICAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZXQuXG4gICAqIEBwYXJhbSBbY2FsbGJhY2soZXJyLCBieXRlcyldIGNhbGxlZCBvbmNlIHRoZSBvcGVyYXRpb24gY29tcGxldGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSByYW5kb20gYnl0ZXMgaW4gYSBzdHJpbmcuXG4gICAqL1xuICBjdHguZ2V0Qnl0ZXMgPSBmdW5jdGlvbihjb3VudCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gY3R4LmdlbmVyYXRlKGNvdW50LCBjYWxsYmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgcmFuZG9tIGJ5dGVzIGFzeW5jaHJvbm91c2x5LiBJZiBhIG5hdGl2ZSBzZWN1cmUgY3J5cHRvIEFQSSBpc1xuICAgKiB1bmF2YWlsYWJsZSwgdGhpcyBtZXRob2QgdHJpZXMgdG8gbWFrZSB0aGUgYnl0ZXMgbW9yZSB1bnByZWRpY3RhYmxlIGJ5XG4gICAqIGRyYXdpbmcgZnJvbSBkYXRhIHRoYXQgY2FuIGJlIGNvbGxlY3RlZCBmcm9tIHRoZSB1c2VyIG9mIHRoZSBicm93c2VyLFxuICAgKiBlZzogbW91c2UgbW92ZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZXQuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHJhbmRvbSBieXRlcyBpbiBhIHN0cmluZy5cbiAgICovXG4gIGN0eC5nZXRCeXRlc1N5bmMgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHJldHVybiBjdHguZ2VuZXJhdGUoY291bnQpO1xuICB9O1xuXG4gIHJldHVybiBjdHg7XG59XG5cbi8vIGNyZWF0ZSBkZWZhdWx0IHBybmcgY29udGV4dFxudmFyIF9jdHggPSBzcGF3blBybmcoKTtcblxuLy8gYWRkIG90aGVyIHNvdXJjZXMgb2YgZW50cm9weSBvbmx5IGlmIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIGlzIG5vdFxuLy8gYXZhaWxhYmxlIC0tIG90aGVyd2lzZSB0aGlzIHNvdXJjZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdXNlZCBieSB0aGUgcHJuZ1xudmFyIGdldFJhbmRvbVZhbHVlcyA9IG51bGw7XG52YXIgZ2xvYmFsU2NvcGUgPSBmb3JnZS51dGlsLmdsb2JhbFNjb3BlO1xudmFyIF9jcnlwdG8gPSBnbG9iYWxTY29wZS5jcnlwdG8gfHwgZ2xvYmFsU2NvcGUubXNDcnlwdG87XG5pZihfY3J5cHRvICYmIF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIGdldFJhbmRvbVZhbHVlcyA9IGZ1bmN0aW9uKGFycikge1xuICAgIHJldHVybiBfY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpO1xuICB9O1xufVxuXG5pZihmb3JnZS5vcHRpb25zLnVzZVB1cmVKYXZhU2NyaXB0IHx8XG4gICghZm9yZ2UudXRpbC5pc05vZGVqcyAmJiAhZ2V0UmFuZG9tVmFsdWVzKSkge1xuICAvLyBpZiB0aGlzIGlzIGEgd2ViIHdvcmtlciwgZG8gbm90IHVzZSB3ZWFrIGVudHJvcHksIGluc3RlYWQgcmVnaXN0ZXIgdG9cbiAgLy8gcmVjZWl2ZSBzdHJvbmcgZW50cm9weSBhc3luY2hyb25vdXNseSBmcm9tIHRoZSBtYWluIHRocmVhZFxuICBpZih0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB3aW5kb3cuZG9jdW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIEZJWE1FOlxuICB9XG5cbiAgLy8gZ2V0IGxvYWQgdGltZSBlbnRyb3B5XG4gIF9jdHguY29sbGVjdEludCgrbmV3IERhdGUoKSwgMzIpO1xuXG4gIC8vIGFkZCBzb21lIGVudHJvcHkgZnJvbSBuYXZpZ2F0b3Igb2JqZWN0XG4gIGlmKHR5cGVvZihuYXZpZ2F0b3IpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBfbmF2Qnl0ZXMgPSAnJztcbiAgICBmb3IodmFyIGtleSBpbiBuYXZpZ2F0b3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmKHR5cGVvZihuYXZpZ2F0b3Jba2V5XSkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBfbmF2Qnl0ZXMgKz0gbmF2aWdhdG9yW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAvKiBTb21lIG5hdmlnYXRvciBrZXlzIG1pZ2h0IG5vdCBiZSBhY2Nlc3NpYmxlLCBlLmcuIHRoZSBnZW9sb2NhdGlvblxuICAgICAgICAgIGF0dHJpYnV0ZSB0aHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRvdWNoZWQgaW4gTW96aWxsYSBjaHJvbWU6Ly9cbiAgICAgICAgICBjb250ZXh0LlxuXG4gICAgICAgICAgU2lsZW50bHkgaWdub3JlIHRoaXMgYW5kIGp1c3QgZG9uJ3QgdXNlIHRoaXMgYXMgYSBzb3VyY2Ugb2ZcbiAgICAgICAgICBlbnRyb3B5LiAqL1xuICAgICAgfVxuICAgIH1cbiAgICBfY3R4LmNvbGxlY3QoX25hdkJ5dGVzKTtcbiAgICBfbmF2Qnl0ZXMgPSBudWxsO1xuICB9XG5cbiAgLy8gYWRkIG1vdXNlIGFuZCBrZXlib2FyZCBjb2xsZWN0b3JzIGlmIGpxdWVyeSBpcyBhdmFpbGFibGVcbiAgaWYoalF1ZXJ5KSB7XG4gICAgLy8gc2V0IHVwIG1vdXNlIGVudHJvcHkgY2FwdHVyZVxuICAgIGpRdWVyeSgpLm1vdXNlbW92ZShmdW5jdGlvbihlKSB7XG4gICAgICAvLyBhZGQgbW91c2UgY29vcmRzXG4gICAgICBfY3R4LmNvbGxlY3RJbnQoZS5jbGllbnRYLCAxNik7XG4gICAgICBfY3R4LmNvbGxlY3RJbnQoZS5jbGllbnRZLCAxNik7XG4gICAgfSk7XG5cbiAgICAvLyBzZXQgdXAga2V5Ym9hcmQgZW50cm9weSBjYXB0dXJlXG4gICAgalF1ZXJ5KCkua2V5cHJlc3MoZnVuY3Rpb24oZSkge1xuICAgICAgX2N0eC5jb2xsZWN0SW50KGUuY2hhckNvZGUsIDgpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qIFJhbmRvbSBBUEkgKi9cbmlmKCFmb3JnZS5yYW5kb20pIHtcbiAgZm9yZ2UucmFuZG9tID0gX2N0eDtcbn0gZWxzZSB7XG4gIC8vIGV4dGVuZCBmb3JnZS5yYW5kb20gd2l0aCBfY3R4XG4gIGZvcih2YXIga2V5IGluIF9jdHgpIHtcbiAgICBmb3JnZS5yYW5kb21ba2V5XSA9IF9jdHhba2V5XTtcbiAgfVxufVxuXG4vLyBleHBvc2Ugc3Bhd24gUFJOR1xuZm9yZ2UucmFuZG9tLmNyZWF0ZUluc3RhbmNlID0gc3Bhd25Qcm5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnJhbmRvbTtcblxufSkodHlwZW9mKGpRdWVyeSkgIT09ICd1bmRlZmluZWQnID8galF1ZXJ5IDogbnVsbCk7XG5cbn0pKCk7XG4iXSwibmFtZXMiOlsiZm9yZ2UiLCJyZXF1aXJlIiwicmFuZG9tIiwiZ2V0Qnl0ZXMiLCJtb2R1bGUiLCJleHBvcnRzIiwialF1ZXJ5IiwicHJuZ19hZXMiLCJfcHJuZ19hZXNfb3V0cHV0IiwiQXJyYXkiLCJfcHJuZ19hZXNfYnVmZmVyIiwidXRpbCIsImNyZWF0ZUJ1ZmZlciIsImZvcm1hdEtleSIsImtleSIsInRtcCIsImdldEludDMyIiwiYWVzIiwiX2V4cGFuZEtleSIsImZvcm1hdFNlZWQiLCJzZWVkIiwiY2lwaGVyIiwiX3VwZGF0ZUJsb2NrIiwicHV0SW50MzIiLCJpbmNyZW1lbnQiLCJtZCIsInNoYTI1NiIsInNwYXduUHJuZyIsImN0eCIsInBybmciLCJjcmVhdGUiLCJjb3VudCIsImNhbGxiYWNrIiwiZ2VuZXJhdGUiLCJnZXRCeXRlc1N5bmMiLCJfY3R4IiwiZ2V0UmFuZG9tVmFsdWVzIiwiZ2xvYmFsU2NvcGUiLCJfY3J5cHRvIiwiY3J5cHRvIiwibXNDcnlwdG8iLCJhcnIiLCJvcHRpb25zIiwidXNlUHVyZUphdmFTY3JpcHQiLCJpc05vZGVqcyIsIndpbmRvdyIsImRvY3VtZW50IiwidW5kZWZpbmVkIiwiY29sbGVjdEludCIsIkRhdGUiLCJuYXZpZ2F0b3IiLCJfbmF2Qnl0ZXMiLCJlIiwiY29sbGVjdCIsIm1vdXNlbW92ZSIsImNsaWVudFgiLCJjbGllbnRZIiwia2V5cHJlc3MiLCJjaGFyQ29kZSIsImNyZWF0ZUluc3RhbmNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/random.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/rc2.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/rc2.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * RC2 implementation.\n *\n * @author Stefan Siegl\n *\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n *\n * Information on the RC2 cipher is available from RFC #2268,\n * http://www.ietf.org/rfc/rfc2268.txt\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\nvar piTable = [\n    0xd9,\n    0x78,\n    0xf9,\n    0xc4,\n    0x19,\n    0xdd,\n    0xb5,\n    0xed,\n    0x28,\n    0xe9,\n    0xfd,\n    0x79,\n    0x4a,\n    0xa0,\n    0xd8,\n    0x9d,\n    0xc6,\n    0x7e,\n    0x37,\n    0x83,\n    0x2b,\n    0x76,\n    0x53,\n    0x8e,\n    0x62,\n    0x4c,\n    0x64,\n    0x88,\n    0x44,\n    0x8b,\n    0xfb,\n    0xa2,\n    0x17,\n    0x9a,\n    0x59,\n    0xf5,\n    0x87,\n    0xb3,\n    0x4f,\n    0x13,\n    0x61,\n    0x45,\n    0x6d,\n    0x8d,\n    0x09,\n    0x81,\n    0x7d,\n    0x32,\n    0xbd,\n    0x8f,\n    0x40,\n    0xeb,\n    0x86,\n    0xb7,\n    0x7b,\n    0x0b,\n    0xf0,\n    0x95,\n    0x21,\n    0x22,\n    0x5c,\n    0x6b,\n    0x4e,\n    0x82,\n    0x54,\n    0xd6,\n    0x65,\n    0x93,\n    0xce,\n    0x60,\n    0xb2,\n    0x1c,\n    0x73,\n    0x56,\n    0xc0,\n    0x14,\n    0xa7,\n    0x8c,\n    0xf1,\n    0xdc,\n    0x12,\n    0x75,\n    0xca,\n    0x1f,\n    0x3b,\n    0xbe,\n    0xe4,\n    0xd1,\n    0x42,\n    0x3d,\n    0xd4,\n    0x30,\n    0xa3,\n    0x3c,\n    0xb6,\n    0x26,\n    0x6f,\n    0xbf,\n    0x0e,\n    0xda,\n    0x46,\n    0x69,\n    0x07,\n    0x57,\n    0x27,\n    0xf2,\n    0x1d,\n    0x9b,\n    0xbc,\n    0x94,\n    0x43,\n    0x03,\n    0xf8,\n    0x11,\n    0xc7,\n    0xf6,\n    0x90,\n    0xef,\n    0x3e,\n    0xe7,\n    0x06,\n    0xc3,\n    0xd5,\n    0x2f,\n    0xc8,\n    0x66,\n    0x1e,\n    0xd7,\n    0x08,\n    0xe8,\n    0xea,\n    0xde,\n    0x80,\n    0x52,\n    0xee,\n    0xf7,\n    0x84,\n    0xaa,\n    0x72,\n    0xac,\n    0x35,\n    0x4d,\n    0x6a,\n    0x2a,\n    0x96,\n    0x1a,\n    0xd2,\n    0x71,\n    0x5a,\n    0x15,\n    0x49,\n    0x74,\n    0x4b,\n    0x9f,\n    0xd0,\n    0x5e,\n    0x04,\n    0x18,\n    0xa4,\n    0xec,\n    0xc2,\n    0xe0,\n    0x41,\n    0x6e,\n    0x0f,\n    0x51,\n    0xcb,\n    0xcc,\n    0x24,\n    0x91,\n    0xaf,\n    0x50,\n    0xa1,\n    0xf4,\n    0x70,\n    0x39,\n    0x99,\n    0x7c,\n    0x3a,\n    0x85,\n    0x23,\n    0xb8,\n    0xb4,\n    0x7a,\n    0xfc,\n    0x02,\n    0x36,\n    0x5b,\n    0x25,\n    0x55,\n    0x97,\n    0x31,\n    0x2d,\n    0x5d,\n    0xfa,\n    0x98,\n    0xe3,\n    0x8a,\n    0x92,\n    0xae,\n    0x05,\n    0xdf,\n    0x29,\n    0x10,\n    0x67,\n    0x6c,\n    0xba,\n    0xc9,\n    0xd3,\n    0x00,\n    0xe6,\n    0xcf,\n    0xe1,\n    0x9e,\n    0xa8,\n    0x2c,\n    0x63,\n    0x16,\n    0x01,\n    0x3f,\n    0x58,\n    0xe2,\n    0x89,\n    0xa9,\n    0x0d,\n    0x38,\n    0x34,\n    0x1b,\n    0xab,\n    0x33,\n    0xff,\n    0xb0,\n    0xbb,\n    0x48,\n    0x0c,\n    0x5f,\n    0xb9,\n    0xb1,\n    0xcd,\n    0x2e,\n    0xc5,\n    0xf3,\n    0xdb,\n    0x47,\n    0xe5,\n    0xa5,\n    0x9c,\n    0x77,\n    0x0a,\n    0xa6,\n    0x20,\n    0x68,\n    0xfe,\n    0x7f,\n    0xc1,\n    0xad\n];\nvar s = [\n    1,\n    2,\n    3,\n    5\n];\n/**\n * Rotate a word left by given number of bits.\n *\n * Bits that are shifted out on the left are put back in on the right\n * hand side.\n *\n * @param word The word to shift left.\n * @param bits The number of bits to shift by.\n * @return The rotated word.\n */ var rol = function(word, bits) {\n    return word << bits & 0xffff | (word & 0xffff) >> 16 - bits;\n};\n/**\n * Rotate a word right by given number of bits.\n *\n * Bits that are shifted out on the right are put back in on the left\n * hand side.\n *\n * @param word The word to shift right.\n * @param bits The number of bits to shift by.\n * @return The rotated word.\n */ var ror = function(word, bits) {\n    return (word & 0xffff) >> bits | word << 16 - bits & 0xffff;\n};\n/* RC2 API */ module.exports = forge.rc2 = forge.rc2 || {};\n/**\n * Perform RC2 key expansion as per RFC #2268, section 2.\n *\n * @param key variable-length user key (between 1 and 128 bytes)\n * @param effKeyBits number of effective key bits (default: 128)\n * @return the expanded RC2 key (ByteBuffer of 128 bytes)\n */ forge.rc2.expandKey = function(key, effKeyBits) {\n    if (typeof key === \"string\") {\n        key = forge.util.createBuffer(key);\n    }\n    effKeyBits = effKeyBits || 128;\n    /* introduce variables that match the names used in RFC #2268 */ var L = key;\n    var T = key.length();\n    var T1 = effKeyBits;\n    var T8 = Math.ceil(T1 / 8);\n    var TM = 0xff >> (T1 & 0x07);\n    var i;\n    for(i = T; i < 128; i++){\n        L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 0xff]);\n    }\n    L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);\n    for(i = 127 - T8; i >= 0; i--){\n        L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);\n    }\n    return L;\n};\n/**\n * Creates a RC2 cipher object.\n *\n * @param key the symmetric key to use (as base for key generation).\n * @param bits the number of effective key bits.\n * @param encrypt false for decryption, true for encryption.\n *\n * @return the cipher.\n */ var createCipher = function(key, bits, encrypt) {\n    var _finish = false, _input = null, _output = null, _iv = null;\n    var mixRound, mashRound;\n    var i, j, K = [];\n    /* Expand key and fill into K[] Array */ key = forge.rc2.expandKey(key, bits);\n    for(i = 0; i < 64; i++){\n        K.push(key.getInt16Le());\n    }\n    if (encrypt) {\n        /**\n     * Perform one mixing round \"in place\".\n     *\n     * @param R Array of four words to perform mixing on.\n     */ mixRound = function(R) {\n            for(i = 0; i < 4; i++){\n                R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);\n                R[i] = rol(R[i], s[i]);\n                j++;\n            }\n        };\n        /**\n     * Perform one mashing round \"in place\".\n     *\n     * @param R Array of four words to perform mashing on.\n     */ mashRound = function(R) {\n            for(i = 0; i < 4; i++){\n                R[i] += K[R[(i + 3) % 4] & 63];\n            }\n        };\n    } else {\n        /**\n     * Perform one r-mixing round \"in place\".\n     *\n     * @param R Array of four words to perform mixing on.\n     */ mixRound = function(R) {\n            for(i = 3; i >= 0; i--){\n                R[i] = ror(R[i], s[i]);\n                R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);\n                j--;\n            }\n        };\n        /**\n     * Perform one r-mashing round \"in place\".\n     *\n     * @param R Array of four words to perform mashing on.\n     */ mashRound = function(R) {\n            for(i = 3; i >= 0; i--){\n                R[i] -= K[R[(i + 3) % 4] & 63];\n            }\n        };\n    }\n    /**\n   * Run the specified cipher execution plan.\n   *\n   * This function takes four words from the input buffer, applies the IV on\n   * it (if requested) and runs the provided execution plan.\n   *\n   * The plan must be put together in form of a array of arrays.  Where the\n   * outer one is simply a list of steps to perform and the inner one needs\n   * to have two elements: the first one telling how many rounds to perform,\n   * the second one telling what to do (i.e. the function to call).\n   *\n   * @param {Array} plan The plan to execute.\n   */ var runPlan = function(plan) {\n        var R = [];\n        /* Get data from input buffer and fill the four words into R */ for(i = 0; i < 4; i++){\n            var val = _input.getInt16Le();\n            if (_iv !== null) {\n                if (encrypt) {\n                    /* We're encrypting, apply the IV first. */ val ^= _iv.getInt16Le();\n                } else {\n                    /* We're decryption, keep cipher text for next block. */ _iv.putInt16Le(val);\n                }\n            }\n            R.push(val & 0xffff);\n        }\n        /* Reset global \"j\" variable as per spec. */ j = encrypt ? 0 : 63;\n        /* Run execution plan. */ for(var ptr = 0; ptr < plan.length; ptr++){\n            for(var ctr = 0; ctr < plan[ptr][0]; ctr++){\n                plan[ptr][1](R);\n            }\n        }\n        /* Write back result to output buffer. */ for(i = 0; i < 4; i++){\n            if (_iv !== null) {\n                if (encrypt) {\n                    /* We're encrypting in CBC-mode, feed back encrypted bytes into\n             IV buffer to carry it forward to next block. */ _iv.putInt16Le(R[i]);\n                } else {\n                    R[i] ^= _iv.getInt16Le();\n                }\n            }\n            _output.putInt16Le(R[i]);\n        }\n    };\n    /* Create cipher object */ var cipher = null;\n    cipher = {\n        /**\n     * Starts or restarts the encryption or decryption process, whichever\n     * was previously configured.\n     *\n     * To use the cipher in CBC mode, iv may be given either as a string\n     * of bytes, or as a byte buffer.  For ECB mode, give null as iv.\n     *\n     * @param iv the initialization vector to use, null for ECB mode.\n     * @param output the output the buffer to write to, null to create one.\n     */ start: function(iv, output) {\n            if (iv) {\n                /* CBC mode */ if (typeof iv === \"string\") {\n                    iv = forge.util.createBuffer(iv);\n                }\n            }\n            _finish = false;\n            _input = forge.util.createBuffer();\n            _output = output || new forge.util.createBuffer();\n            _iv = iv;\n            cipher.output = _output;\n        },\n        /**\n     * Updates the next block.\n     *\n     * @param input the buffer to read from.\n     */ update: function(input) {\n            if (!_finish) {\n                // not finishing, so fill the input buffer with more input\n                _input.putBuffer(input);\n            }\n            while(_input.length() >= 8){\n                runPlan([\n                    [\n                        5,\n                        mixRound\n                    ],\n                    [\n                        1,\n                        mashRound\n                    ],\n                    [\n                        6,\n                        mixRound\n                    ],\n                    [\n                        1,\n                        mashRound\n                    ],\n                    [\n                        5,\n                        mixRound\n                    ]\n                ]);\n            }\n        },\n        /**\n     * Finishes encrypting or decrypting.\n     *\n     * @param pad a padding function to use, null for PKCS#7 padding,\n     *           signature(blockSize, buffer, decrypt).\n     *\n     * @return true if successful, false on error.\n     */ finish: function(pad) {\n            var rval = true;\n            if (encrypt) {\n                if (pad) {\n                    rval = pad(8, _input, !encrypt);\n                } else {\n                    // add PKCS#7 padding to block (each pad byte is the\n                    // value of the number of pad bytes)\n                    var padding = _input.length() === 8 ? 8 : 8 - _input.length();\n                    _input.fillWithByte(padding, padding);\n                }\n            }\n            if (rval) {\n                // do final update\n                _finish = true;\n                cipher.update();\n            }\n            if (!encrypt) {\n                // check for error: input data not a multiple of block size\n                rval = _input.length() === 0;\n                if (rval) {\n                    if (pad) {\n                        rval = pad(8, _output, !encrypt);\n                    } else {\n                        // ensure padding byte count is valid\n                        var len = _output.length();\n                        var count = _output.at(len - 1);\n                        if (count > len) {\n                            rval = false;\n                        } else {\n                            // trim off padding bytes\n                            _output.truncate(count);\n                        }\n                    }\n                }\n            }\n            return rval;\n        }\n    };\n    return cipher;\n};\n/**\n * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the\n * given symmetric key. The output will be stored in the 'output' member\n * of the returned cipher.\n *\n * The key and iv may be given as a string of bytes or a byte buffer.\n * The cipher is initialized to use 128 effective key bits.\n *\n * @param key the symmetric key to use.\n * @param iv the initialization vector to use.\n * @param output the buffer to write to, null to create one.\n *\n * @return the cipher.\n */ forge.rc2.startEncrypting = function(key, iv, output) {\n    var cipher = forge.rc2.createEncryptionCipher(key, 128);\n    cipher.start(iv, output);\n    return cipher;\n};\n/**\n * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the\n * given symmetric key.\n *\n * The key may be given as a string of bytes or a byte buffer.\n *\n * To start encrypting call start() on the cipher with an iv and optional\n * output buffer.\n *\n * @param key the symmetric key to use.\n *\n * @return the cipher.\n */ forge.rc2.createEncryptionCipher = function(key, bits) {\n    return createCipher(key, bits, true);\n};\n/**\n * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the\n * given symmetric key. The output will be stored in the 'output' member\n * of the returned cipher.\n *\n * The key and iv may be given as a string of bytes or a byte buffer.\n * The cipher is initialized to use 128 effective key bits.\n *\n * @param key the symmetric key to use.\n * @param iv the initialization vector to use.\n * @param output the buffer to write to, null to create one.\n *\n * @return the cipher.\n */ forge.rc2.startDecrypting = function(key, iv, output) {\n    var cipher = forge.rc2.createDecryptionCipher(key, 128);\n    cipher.start(iv, output);\n    return cipher;\n};\n/**\n * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the\n * given symmetric key.\n *\n * The key may be given as a string of bytes or a byte buffer.\n *\n * To start decrypting call start() on the cipher with an iv and optional\n * output buffer.\n *\n * @param key the symmetric key to use.\n *\n * @return the cipher.\n */ forge.rc2.createDecryptionCipher = function(key, bits) {\n    return createCipher(key, bits, false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcmMyLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Q0FTQztBQUNELElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCQSxtQkFBT0EsQ0FBQztBQUVSLElBQUlDLFVBQVU7SUFDWjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxRjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtDQUMzRjtBQUVELElBQUlDLElBQUk7SUFBQztJQUFHO0lBQUc7SUFBRztDQUFFO0FBRXBCOzs7Ozs7Ozs7Q0FTQyxHQUNELElBQUlDLE1BQU0sU0FBU0MsSUFBSSxFQUFFQyxJQUFJO0lBQzNCLE9BQU8sUUFBVUEsT0FBUSxTQUFXLENBQUNELE9BQU8sTUFBSyxLQUFPLEtBQUtDO0FBQy9EO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ0QsSUFBSUMsTUFBTSxTQUFTRixJQUFJLEVBQUVDLElBQUk7SUFDM0IsT0FBTyxDQUFFRCxPQUFPLE1BQUssS0FBTUMsT0FBUyxRQUFVLEtBQUtBLE9BQVM7QUFDOUQ7QUFFQSxXQUFXLEdBQ1hFLE9BQU9DLE9BQU8sR0FBR1QsTUFBTVUsR0FBRyxHQUFHVixNQUFNVSxHQUFHLElBQUks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QUFDbkQsS0FBSztJQUNuRG1DLE9BQU9DLEtBQUssQ0FBQ0MsSUFBSUM7SUFDakIsT0FBT0g7QUFDVDtBQUVBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNEL0MsTUFBTVUsR0FBRyxDQUFDcUQsc0JBQXNCLEdBQUcsU0FBU25ELEdBQUcsRUFBRU4sSUFBSTtJQUNuRCxPQUFPc0IsYUFBYWhCLEtBQUtOLE1BQU07QUFDakM7QUFFQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ0ROLE1BQU1VLEdBQUcsQ0FBQ3NELGVBQWUsR0FBRyxTQUFTcEQsR0FBRyxFQUFFcUMsRUFBRSxFQUFFQyxNQUFNO0lBQ2xELElBQUlILFNBQVMvQyxNQUFNVSxHQUFHLENBQUN1RCxzQkFBc0IsQ0FBQ3JELEtBQUs7SUFDbkRtQyxPQUFPQyxLQUFLLENBQUNDLElBQUlDO0lBQ2pCLE9BQU9IO0FBQ1Q7QUFFQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRC9DLE1BQU1VLEdBQUcsQ0FBQ3VELHNCQUFzQixHQUFHLFNBQVNyRCxHQUFHLEVBQUVOLElBQUk7SUFDbkQsT0FBT3NCLGFBQWFoQixLQUFLTixNQUFNO0FBQ2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3JjMi5qcz8wZTRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUkMyIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBhdXRob3IgU3RlZmFuIFNpZWdsXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIFN0ZWZhbiBTaWVnbCA8c3Rlc2llQGJyb2tlbnBpcGUuZGU+XG4gKlxuICogSW5mb3JtYXRpb24gb24gdGhlIFJDMiBjaXBoZXIgaXMgYXZhaWxhYmxlIGZyb20gUkZDICMyMjY4LFxuICogaHR0cDovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMjI2OC50eHRcbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBwaVRhYmxlID0gW1xuICAweGQ5LCAweDc4LCAweGY5LCAweGM0LCAweDE5LCAweGRkLCAweGI1LCAweGVkLCAweDI4LCAweGU5LCAweGZkLCAweDc5LCAweDRhLCAweGEwLCAweGQ4LCAweDlkLFxuICAweGM2LCAweDdlLCAweDM3LCAweDgzLCAweDJiLCAweDc2LCAweDUzLCAweDhlLCAweDYyLCAweDRjLCAweDY0LCAweDg4LCAweDQ0LCAweDhiLCAweGZiLCAweGEyLFxuICAweDE3LCAweDlhLCAweDU5LCAweGY1LCAweDg3LCAweGIzLCAweDRmLCAweDEzLCAweDYxLCAweDQ1LCAweDZkLCAweDhkLCAweDA5LCAweDgxLCAweDdkLCAweDMyLFxuICAweGJkLCAweDhmLCAweDQwLCAweGViLCAweDg2LCAweGI3LCAweDdiLCAweDBiLCAweGYwLCAweDk1LCAweDIxLCAweDIyLCAweDVjLCAweDZiLCAweDRlLCAweDgyLFxuICAweDU0LCAweGQ2LCAweDY1LCAweDkzLCAweGNlLCAweDYwLCAweGIyLCAweDFjLCAweDczLCAweDU2LCAweGMwLCAweDE0LCAweGE3LCAweDhjLCAweGYxLCAweGRjLFxuICAweDEyLCAweDc1LCAweGNhLCAweDFmLCAweDNiLCAweGJlLCAweGU0LCAweGQxLCAweDQyLCAweDNkLCAweGQ0LCAweDMwLCAweGEzLCAweDNjLCAweGI2LCAweDI2LFxuICAweDZmLCAweGJmLCAweDBlLCAweGRhLCAweDQ2LCAweDY5LCAweDA3LCAweDU3LCAweDI3LCAweGYyLCAweDFkLCAweDliLCAweGJjLCAweDk0LCAweDQzLCAweDAzLFxuICAweGY4LCAweDExLCAweGM3LCAweGY2LCAweDkwLCAweGVmLCAweDNlLCAweGU3LCAweDA2LCAweGMzLCAweGQ1LCAweDJmLCAweGM4LCAweDY2LCAweDFlLCAweGQ3LFxuICAweDA4LCAweGU4LCAweGVhLCAweGRlLCAweDgwLCAweDUyLCAweGVlLCAweGY3LCAweDg0LCAweGFhLCAweDcyLCAweGFjLCAweDM1LCAweDRkLCAweDZhLCAweDJhLFxuICAweDk2LCAweDFhLCAweGQyLCAweDcxLCAweDVhLCAweDE1LCAweDQ5LCAweDc0LCAweDRiLCAweDlmLCAweGQwLCAweDVlLCAweDA0LCAweDE4LCAweGE0LCAweGVjLFxuICAweGMyLCAweGUwLCAweDQxLCAweDZlLCAweDBmLCAweDUxLCAweGNiLCAweGNjLCAweDI0LCAweDkxLCAweGFmLCAweDUwLCAweGExLCAweGY0LCAweDcwLCAweDM5LFxuICAweDk5LCAweDdjLCAweDNhLCAweDg1LCAweDIzLCAweGI4LCAweGI0LCAweDdhLCAweGZjLCAweDAyLCAweDM2LCAweDViLCAweDI1LCAweDU1LCAweDk3LCAweDMxLFxuICAweDJkLCAweDVkLCAweGZhLCAweDk4LCAweGUzLCAweDhhLCAweDkyLCAweGFlLCAweDA1LCAweGRmLCAweDI5LCAweDEwLCAweDY3LCAweDZjLCAweGJhLCAweGM5LFxuICAweGQzLCAweDAwLCAweGU2LCAweGNmLCAweGUxLCAweDllLCAweGE4LCAweDJjLCAweDYzLCAweDE2LCAweDAxLCAweDNmLCAweDU4LCAweGUyLCAweDg5LCAweGE5LFxuICAweDBkLCAweDM4LCAweDM0LCAweDFiLCAweGFiLCAweDMzLCAweGZmLCAweGIwLCAweGJiLCAweDQ4LCAweDBjLCAweDVmLCAweGI5LCAweGIxLCAweGNkLCAweDJlLFxuICAweGM1LCAweGYzLCAweGRiLCAweDQ3LCAweGU1LCAweGE1LCAweDljLCAweDc3LCAweDBhLCAweGE2LCAweDIwLCAweDY4LCAweGZlLCAweDdmLCAweGMxLCAweGFkXG5dO1xuXG52YXIgcyA9IFsxLCAyLCAzLCA1XTtcblxuLyoqXG4gKiBSb3RhdGUgYSB3b3JkIGxlZnQgYnkgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKlxuICogQml0cyB0aGF0IGFyZSBzaGlmdGVkIG91dCBvbiB0aGUgbGVmdCBhcmUgcHV0IGJhY2sgaW4gb24gdGhlIHJpZ2h0XG4gKiBoYW5kIHNpZGUuXG4gKlxuICogQHBhcmFtIHdvcmQgVGhlIHdvcmQgdG8gc2hpZnQgbGVmdC5cbiAqIEBwYXJhbSBiaXRzIFRoZSBudW1iZXIgb2YgYml0cyB0byBzaGlmdCBieS5cbiAqIEByZXR1cm4gVGhlIHJvdGF0ZWQgd29yZC5cbiAqL1xudmFyIHJvbCA9IGZ1bmN0aW9uKHdvcmQsIGJpdHMpIHtcbiAgcmV0dXJuICgod29yZCA8PCBiaXRzKSAmIDB4ZmZmZikgfCAoKHdvcmQgJiAweGZmZmYpID4+ICgxNiAtIGJpdHMpKTtcbn07XG5cbi8qKlxuICogUm90YXRlIGEgd29yZCByaWdodCBieSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqXG4gKiBCaXRzIHRoYXQgYXJlIHNoaWZ0ZWQgb3V0IG9uIHRoZSByaWdodCBhcmUgcHV0IGJhY2sgaW4gb24gdGhlIGxlZnRcbiAqIGhhbmQgc2lkZS5cbiAqXG4gKiBAcGFyYW0gd29yZCBUaGUgd29yZCB0byBzaGlmdCByaWdodC5cbiAqIEBwYXJhbSBiaXRzIFRoZSBudW1iZXIgb2YgYml0cyB0byBzaGlmdCBieS5cbiAqIEByZXR1cm4gVGhlIHJvdGF0ZWQgd29yZC5cbiAqL1xudmFyIHJvciA9IGZ1bmN0aW9uKHdvcmQsIGJpdHMpIHtcbiAgcmV0dXJuICgod29yZCAmIDB4ZmZmZikgPj4gYml0cykgfCAoKHdvcmQgPDwgKDE2IC0gYml0cykpICYgMHhmZmZmKTtcbn07XG5cbi8qIFJDMiBBUEkgKi9cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UucmMyID0gZm9yZ2UucmMyIHx8IHt9O1xuXG4vKipcbiAqIFBlcmZvcm0gUkMyIGtleSBleHBhbnNpb24gYXMgcGVyIFJGQyAjMjI2OCwgc2VjdGlvbiAyLlxuICpcbiAqIEBwYXJhbSBrZXkgdmFyaWFibGUtbGVuZ3RoIHVzZXIga2V5IChiZXR3ZWVuIDEgYW5kIDEyOCBieXRlcylcbiAqIEBwYXJhbSBlZmZLZXlCaXRzIG51bWJlciBvZiBlZmZlY3RpdmUga2V5IGJpdHMgKGRlZmF1bHQ6IDEyOClcbiAqIEByZXR1cm4gdGhlIGV4cGFuZGVkIFJDMiBrZXkgKEJ5dGVCdWZmZXIgb2YgMTI4IGJ5dGVzKVxuICovXG5mb3JnZS5yYzIuZXhwYW5kS2V5ID0gZnVuY3Rpb24oa2V5LCBlZmZLZXlCaXRzKSB7XG4gIGlmKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAga2V5ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoa2V5KTtcbiAgfVxuICBlZmZLZXlCaXRzID0gZWZmS2V5Qml0cyB8fCAxMjg7XG5cbiAgLyogaW50cm9kdWNlIHZhcmlhYmxlcyB0aGF0IG1hdGNoIHRoZSBuYW1lcyB1c2VkIGluIFJGQyAjMjI2OCAqL1xuICB2YXIgTCA9IGtleTtcbiAgdmFyIFQgPSBrZXkubGVuZ3RoKCk7XG4gIHZhciBUMSA9IGVmZktleUJpdHM7XG4gIHZhciBUOCA9IE1hdGguY2VpbChUMSAvIDgpO1xuICB2YXIgVE0gPSAweGZmID4+IChUMSAmIDB4MDcpO1xuICB2YXIgaTtcblxuICBmb3IoaSA9IFQ7IGkgPCAxMjg7IGkrKykge1xuICAgIEwucHV0Qnl0ZShwaVRhYmxlWyhMLmF0KGkgLSAxKSArIEwuYXQoaSAtIFQpKSAmIDB4ZmZdKTtcbiAgfVxuXG4gIEwuc2V0QXQoMTI4IC0gVDgsIHBpVGFibGVbTC5hdCgxMjggLSBUOCkgJiBUTV0pO1xuXG4gIGZvcihpID0gMTI3IC0gVDg7IGkgPj0gMDsgaS0tKSB7XG4gICAgTC5zZXRBdChpLCBwaVRhYmxlW0wuYXQoaSArIDEpIF4gTC5hdChpICsgVDgpXSk7XG4gIH1cblxuICByZXR1cm4gTDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIFJDMiBjaXBoZXIgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlIChhcyBiYXNlIGZvciBrZXkgZ2VuZXJhdGlvbikuXG4gKiBAcGFyYW0gYml0cyB0aGUgbnVtYmVyIG9mIGVmZmVjdGl2ZSBrZXkgYml0cy5cbiAqIEBwYXJhbSBlbmNyeXB0IGZhbHNlIGZvciBkZWNyeXB0aW9uLCB0cnVlIGZvciBlbmNyeXB0aW9uLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xudmFyIGNyZWF0ZUNpcGhlciA9IGZ1bmN0aW9uKGtleSwgYml0cywgZW5jcnlwdCkge1xuICB2YXIgX2ZpbmlzaCA9IGZhbHNlLCBfaW5wdXQgPSBudWxsLCBfb3V0cHV0ID0gbnVsbCwgX2l2ID0gbnVsbDtcbiAgdmFyIG1peFJvdW5kLCBtYXNoUm91bmQ7XG4gIHZhciBpLCBqLCBLID0gW107XG5cbiAgLyogRXhwYW5kIGtleSBhbmQgZmlsbCBpbnRvIEtbXSBBcnJheSAqL1xuICBrZXkgPSBmb3JnZS5yYzIuZXhwYW5kS2V5KGtleSwgYml0cyk7XG4gIGZvcihpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICBLLnB1c2goa2V5LmdldEludDE2TGUoKSk7XG4gIH1cblxuICBpZihlbmNyeXB0KSB7XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBvbmUgbWl4aW5nIHJvdW5kIFwiaW4gcGxhY2VcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBSIEFycmF5IG9mIGZvdXIgd29yZHMgdG8gcGVyZm9ybSBtaXhpbmcgb24uXG4gICAgICovXG4gICAgbWl4Um91bmQgPSBmdW5jdGlvbihSKSB7XG4gICAgICBmb3IoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgUltpXSArPSBLW2pdICsgKFJbKGkgKyAzKSAlIDRdICYgUlsoaSArIDIpICUgNF0pICtcbiAgICAgICAgICAoKH5SWyhpICsgMykgJSA0XSkgJiBSWyhpICsgMSkgJSA0XSk7XG4gICAgICAgIFJbaV0gPSByb2woUltpXSwgc1tpXSk7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBvbmUgbWFzaGluZyByb3VuZCBcImluIHBsYWNlXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gUiBBcnJheSBvZiBmb3VyIHdvcmRzIHRvIHBlcmZvcm0gbWFzaGluZyBvbi5cbiAgICAgKi9cbiAgICBtYXNoUm91bmQgPSBmdW5jdGlvbihSKSB7XG4gICAgICBmb3IoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgUltpXSArPSBLW1JbKGkgKyAzKSAlIDRdICYgNjNdO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBvbmUgci1taXhpbmcgcm91bmQgXCJpbiBwbGFjZVwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIFIgQXJyYXkgb2YgZm91ciB3b3JkcyB0byBwZXJmb3JtIG1peGluZyBvbi5cbiAgICAgKi9cbiAgICBtaXhSb3VuZCA9IGZ1bmN0aW9uKFIpIHtcbiAgICAgIGZvcihpID0gMzsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgUltpXSA9IHJvcihSW2ldLCBzW2ldKTtcbiAgICAgICAgUltpXSAtPSBLW2pdICsgKFJbKGkgKyAzKSAlIDRdICYgUlsoaSArIDIpICUgNF0pICtcbiAgICAgICAgICAoKH5SWyhpICsgMykgJSA0XSkgJiBSWyhpICsgMSkgJSA0XSk7XG4gICAgICAgIGotLTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBvbmUgci1tYXNoaW5nIHJvdW5kIFwiaW4gcGxhY2VcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBSIEFycmF5IG9mIGZvdXIgd29yZHMgdG8gcGVyZm9ybSBtYXNoaW5nIG9uLlxuICAgICAqL1xuICAgIG1hc2hSb3VuZCA9IGZ1bmN0aW9uKFIpIHtcbiAgICAgIGZvcihpID0gMzsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgUltpXSAtPSBLW1JbKGkgKyAzKSAlIDRdICYgNjNdO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUnVuIHRoZSBzcGVjaWZpZWQgY2lwaGVyIGV4ZWN1dGlvbiBwbGFuLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGZvdXIgd29yZHMgZnJvbSB0aGUgaW5wdXQgYnVmZmVyLCBhcHBsaWVzIHRoZSBJViBvblxuICAgKiBpdCAoaWYgcmVxdWVzdGVkKSBhbmQgcnVucyB0aGUgcHJvdmlkZWQgZXhlY3V0aW9uIHBsYW4uXG4gICAqXG4gICAqIFRoZSBwbGFuIG11c3QgYmUgcHV0IHRvZ2V0aGVyIGluIGZvcm0gb2YgYSBhcnJheSBvZiBhcnJheXMuICBXaGVyZSB0aGVcbiAgICogb3V0ZXIgb25lIGlzIHNpbXBseSBhIGxpc3Qgb2Ygc3RlcHMgdG8gcGVyZm9ybSBhbmQgdGhlIGlubmVyIG9uZSBuZWVkc1xuICAgKiB0byBoYXZlIHR3byBlbGVtZW50czogdGhlIGZpcnN0IG9uZSB0ZWxsaW5nIGhvdyBtYW55IHJvdW5kcyB0byBwZXJmb3JtLFxuICAgKiB0aGUgc2Vjb25kIG9uZSB0ZWxsaW5nIHdoYXQgdG8gZG8gKGkuZS4gdGhlIGZ1bmN0aW9uIHRvIGNhbGwpLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBwbGFuIFRoZSBwbGFuIHRvIGV4ZWN1dGUuXG4gICAqL1xuICB2YXIgcnVuUGxhbiA9IGZ1bmN0aW9uKHBsYW4pIHtcbiAgICB2YXIgUiA9IFtdO1xuXG4gICAgLyogR2V0IGRhdGEgZnJvbSBpbnB1dCBidWZmZXIgYW5kIGZpbGwgdGhlIGZvdXIgd29yZHMgaW50byBSICovXG4gICAgZm9yKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICB2YXIgdmFsID0gX2lucHV0LmdldEludDE2TGUoKTtcblxuICAgICAgaWYoX2l2ICE9PSBudWxsKSB7XG4gICAgICAgIGlmKGVuY3J5cHQpIHtcbiAgICAgICAgICAvKiBXZSdyZSBlbmNyeXB0aW5nLCBhcHBseSB0aGUgSVYgZmlyc3QuICovXG4gICAgICAgICAgdmFsIF49IF9pdi5nZXRJbnQxNkxlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyogV2UncmUgZGVjcnlwdGlvbiwga2VlcCBjaXBoZXIgdGV4dCBmb3IgbmV4dCBibG9jay4gKi9cbiAgICAgICAgICBfaXYucHV0SW50MTZMZSh2YWwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIFIucHVzaCh2YWwgJiAweGZmZmYpO1xuICAgIH1cblxuICAgIC8qIFJlc2V0IGdsb2JhbCBcImpcIiB2YXJpYWJsZSBhcyBwZXIgc3BlYy4gKi9cbiAgICBqID0gZW5jcnlwdCA/IDAgOiA2MztcblxuICAgIC8qIFJ1biBleGVjdXRpb24gcGxhbi4gKi9cbiAgICBmb3IodmFyIHB0ciA9IDA7IHB0ciA8IHBsYW4ubGVuZ3RoOyBwdHIrKykge1xuICAgICAgZm9yKHZhciBjdHIgPSAwOyBjdHIgPCBwbGFuW3B0cl1bMF07IGN0cisrKSB7XG4gICAgICAgIHBsYW5bcHRyXVsxXShSKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBXcml0ZSBiYWNrIHJlc3VsdCB0byBvdXRwdXQgYnVmZmVyLiAqL1xuICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgaWYoX2l2ICE9PSBudWxsKSB7XG4gICAgICAgIGlmKGVuY3J5cHQpIHtcbiAgICAgICAgICAvKiBXZSdyZSBlbmNyeXB0aW5nIGluIENCQy1tb2RlLCBmZWVkIGJhY2sgZW5jcnlwdGVkIGJ5dGVzIGludG9cbiAgICAgICAgICAgICBJViBidWZmZXIgdG8gY2FycnkgaXQgZm9yd2FyZCB0byBuZXh0IGJsb2NrLiAqL1xuICAgICAgICAgIF9pdi5wdXRJbnQxNkxlKFJbaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFJbaV0gXj0gX2l2LmdldEludDE2TGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfb3V0cHV0LnB1dEludDE2TGUoUltpXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qIENyZWF0ZSBjaXBoZXIgb2JqZWN0ICovXG4gIHZhciBjaXBoZXIgPSBudWxsO1xuICBjaXBoZXIgPSB7XG4gICAgLyoqXG4gICAgICogU3RhcnRzIG9yIHJlc3RhcnRzIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gcHJvY2Vzcywgd2hpY2hldmVyXG4gICAgICogd2FzIHByZXZpb3VzbHkgY29uZmlndXJlZC5cbiAgICAgKlxuICAgICAqIFRvIHVzZSB0aGUgY2lwaGVyIGluIENCQyBtb2RlLCBpdiBtYXkgYmUgZ2l2ZW4gZWl0aGVyIGFzIGEgc3RyaW5nXG4gICAgICogb2YgYnl0ZXMsIG9yIGFzIGEgYnl0ZSBidWZmZXIuICBGb3IgRUNCIG1vZGUsIGdpdmUgbnVsbCBhcyBpdi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZSwgbnVsbCBmb3IgRUNCIG1vZGUuXG4gICAgICogQHBhcmFtIG91dHB1dCB0aGUgb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8sIG51bGwgdG8gY3JlYXRlIG9uZS5cbiAgICAgKi9cbiAgICBzdGFydDogZnVuY3Rpb24oaXYsIG91dHB1dCkge1xuICAgICAgaWYoaXYpIHtcbiAgICAgICAgLyogQ0JDIG1vZGUgKi9cbiAgICAgICAgaWYodHlwZW9mIGl2ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGl2ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoaXYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9maW5pc2ggPSBmYWxzZTtcbiAgICAgIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBfb3V0cHV0ID0gb3V0cHV0IHx8IG5ldyBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgX2l2ID0gaXY7XG5cbiAgICAgIGNpcGhlci5vdXRwdXQgPSBfb3V0cHV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBuZXh0IGJsb2NrLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IHRoZSBidWZmZXIgdG8gcmVhZCBmcm9tLlxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIGlmKCFfZmluaXNoKSB7XG4gICAgICAgIC8vIG5vdCBmaW5pc2hpbmcsIHNvIGZpbGwgdGhlIGlucHV0IGJ1ZmZlciB3aXRoIG1vcmUgaW5wdXRcbiAgICAgICAgX2lucHV0LnB1dEJ1ZmZlcihpbnB1dCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlKF9pbnB1dC5sZW5ndGgoKSA+PSA4KSB7XG4gICAgICAgIHJ1blBsYW4oW1xuICAgICAgICAgICAgWyA1LCBtaXhSb3VuZCBdLFxuICAgICAgICAgICAgWyAxLCBtYXNoUm91bmQgXSxcbiAgICAgICAgICAgIFsgNiwgbWl4Um91bmQgXSxcbiAgICAgICAgICAgIFsgMSwgbWFzaFJvdW5kIF0sXG4gICAgICAgICAgICBbIDUsIG1peFJvdW5kIF1cbiAgICAgICAgICBdKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluaXNoZXMgZW5jcnlwdGluZyBvciBkZWNyeXB0aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhZCBhIHBhZGRpbmcgZnVuY3Rpb24gdG8gdXNlLCBudWxsIGZvciBQS0NTIzcgcGFkZGluZyxcbiAgICAgKiAgICAgICAgICAgc2lnbmF0dXJlKGJsb2NrU2l6ZSwgYnVmZmVyLCBkZWNyeXB0KS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdHJ1ZSBpZiBzdWNjZXNzZnVsLCBmYWxzZSBvbiBlcnJvci5cbiAgICAgKi9cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKHBhZCkge1xuICAgICAgdmFyIHJ2YWwgPSB0cnVlO1xuXG4gICAgICBpZihlbmNyeXB0KSB7XG4gICAgICAgIGlmKHBhZCkge1xuICAgICAgICAgIHJ2YWwgPSBwYWQoOCwgX2lucHV0LCAhZW5jcnlwdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYWRkIFBLQ1MjNyBwYWRkaW5nIHRvIGJsb2NrIChlYWNoIHBhZCBieXRlIGlzIHRoZVxuICAgICAgICAgIC8vIHZhbHVlIG9mIHRoZSBudW1iZXIgb2YgcGFkIGJ5dGVzKVxuICAgICAgICAgIHZhciBwYWRkaW5nID0gKF9pbnB1dC5sZW5ndGgoKSA9PT0gOCkgPyA4IDogKDggLSBfaW5wdXQubGVuZ3RoKCkpO1xuICAgICAgICAgIF9pbnB1dC5maWxsV2l0aEJ5dGUocGFkZGluZywgcGFkZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYocnZhbCkge1xuICAgICAgICAvLyBkbyBmaW5hbCB1cGRhdGVcbiAgICAgICAgX2ZpbmlzaCA9IHRydWU7XG4gICAgICAgIGNpcGhlci51cGRhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYoIWVuY3J5cHQpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGVycm9yOiBpbnB1dCBkYXRhIG5vdCBhIG11bHRpcGxlIG9mIGJsb2NrIHNpemVcbiAgICAgICAgcnZhbCA9IChfaW5wdXQubGVuZ3RoKCkgPT09IDApO1xuICAgICAgICBpZihydmFsKSB7XG4gICAgICAgICAgaWYocGFkKSB7XG4gICAgICAgICAgICBydmFsID0gcGFkKDgsIF9vdXRwdXQsICFlbmNyeXB0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZW5zdXJlIHBhZGRpbmcgYnl0ZSBjb3VudCBpcyB2YWxpZFxuICAgICAgICAgICAgdmFyIGxlbiA9IF9vdXRwdXQubGVuZ3RoKCk7XG4gICAgICAgICAgICB2YXIgY291bnQgPSBfb3V0cHV0LmF0KGxlbiAtIDEpO1xuXG4gICAgICAgICAgICBpZihjb3VudCA+IGxlbikge1xuICAgICAgICAgICAgICBydmFsID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyB0cmltIG9mZiBwYWRkaW5nIGJ5dGVzXG4gICAgICAgICAgICAgIF9vdXRwdXQudHJ1bmNhdGUoY291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBSQzIgY2lwaGVyIG9iamVjdCB0byBlbmNyeXB0IGRhdGEgaW4gRUNCIG9yIENCQyBtb2RlIHVzaW5nIHRoZVxuICogZ2l2ZW4gc3ltbWV0cmljIGtleS4gVGhlIG91dHB1dCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgJ291dHB1dCcgbWVtYmVyXG4gKiBvZiB0aGUgcmV0dXJuZWQgY2lwaGVyLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcyBvciBhIGJ5dGUgYnVmZmVyLlxuICogVGhlIGNpcGhlciBpcyBpbml0aWFsaXplZCB0byB1c2UgMTI4IGVmZmVjdGl2ZSBrZXkgYml0cy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UucmMyLnN0YXJ0RW5jcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCkge1xuICB2YXIgY2lwaGVyID0gZm9yZ2UucmMyLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXIoa2V5LCAxMjgpO1xuICBjaXBoZXIuc3RhcnQoaXYsIG91dHB1dCk7XG4gIHJldHVybiBjaXBoZXI7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gUkMyIGNpcGhlciBvYmplY3QgdG8gZW5jcnlwdCBkYXRhIGluIEVDQiBvciBDQkMgbW9kZSB1c2luZyB0aGVcbiAqIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBUbyBzdGFydCBlbmNyeXB0aW5nIGNhbGwgc3RhcnQoKSBvbiB0aGUgY2lwaGVyIHdpdGggYW4gaXYgYW5kIG9wdGlvbmFsXG4gKiBvdXRwdXQgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UucmMyLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIGJpdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZUNpcGhlcihrZXksIGJpdHMsIHRydWUpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIFJDMiBjaXBoZXIgb2JqZWN0IHRvIGRlY3J5cHQgZGF0YSBpbiBFQ0Igb3IgQ0JDIG1vZGUgdXNpbmcgdGhlXG4gKiBnaXZlbiBzeW1tZXRyaWMga2V5LiBUaGUgb3V0cHV0IHdpbGwgYmUgc3RvcmVkIGluIHRoZSAnb3V0cHV0JyBtZW1iZXJcbiAqIG9mIHRoZSByZXR1cm5lZCBjaXBoZXIuXG4gKlxuICogVGhlIGtleSBhbmQgaXYgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKiBUaGUgY2lwaGVyIGlzIGluaXRpYWxpemVkIHRvIHVzZSAxMjggZWZmZWN0aXZlIGtleSBiaXRzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGl2IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdG8gdXNlLlxuICogQHBhcmFtIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5yYzIuc3RhcnREZWNyeXB0aW5nID0gZnVuY3Rpb24oa2V5LCBpdiwgb3V0cHV0KSB7XG4gIHZhciBjaXBoZXIgPSBmb3JnZS5yYzIuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcihrZXksIDEyOCk7XG4gIGNpcGhlci5zdGFydChpdiwgb3V0cHV0KTtcbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBSQzIgY2lwaGVyIG9iamVjdCB0byBkZWNyeXB0IGRhdGEgaW4gRUNCIG9yIENCQyBtb2RlIHVzaW5nIHRoZVxuICogZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqXG4gKiBUaGUga2V5IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcyBvciBhIGJ5dGUgYnVmZmVyLlxuICpcbiAqIFRvIHN0YXJ0IGRlY3J5cHRpbmcgY2FsbCBzdGFydCgpIG9uIHRoZSBjaXBoZXIgd2l0aCBhbiBpdiBhbmQgb3B0aW9uYWxcbiAqIG91dHB1dCBidWZmZXIuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5yYzIuY3JlYXRlRGVjcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgYml0cykge1xuICByZXR1cm4gY3JlYXRlQ2lwaGVyKGtleSwgYml0cywgZmFsc2UpO1xufTtcbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJwaVRhYmxlIiwicyIsInJvbCIsIndvcmQiLCJiaXRzIiwicm9yIiwibW9kdWxlIiwiZXhwb3J0cyIsInJjMiIsImV4cGFuZEtleSIsImtleSIsImVmZktleUJpdHMiLCJ1dGlsIiwiY3JlYXRlQnVmZmVyIiwiTCIsIlQiLCJsZW5ndGgiLCJUMSIsIlQ4IiwiTWF0aCIsImNlaWwiLCJUTSIsImkiLCJwdXRCeXRlIiwiYXQiLCJzZXRBdCIsImNyZWF0ZUNpcGhlciIsImVuY3J5cHQiLCJfZmluaXNoIiwiX2lucHV0IiwiX291dHB1dCIsIl9pdiIsIm1peFJvdW5kIiwibWFzaFJvdW5kIiwiaiIsIksiLCJwdXNoIiwiZ2V0SW50MTZMZSIsIlIiLCJydW5QbGFuIiwicGxhbiIsInZhbCIsInB1dEludDE2TGUiLCJwdHIiLCJjdHIiLCJjaXBoZXIiLCJzdGFydCIsIml2Iiwib3V0cHV0IiwidXBkYXRlIiwiaW5wdXQiLCJwdXRCdWZmZXIiLCJmaW5pc2giLCJwYWQiLCJydmFsIiwicGFkZGluZyIsImZpbGxXaXRoQnl0ZSIsImxlbiIsImNvdW50IiwidHJ1bmNhdGUiLCJzdGFydEVuY3J5cHRpbmciLCJjcmVhdGVFbmNyeXB0aW9uQ2lwaGVyIiwic3RhcnREZWNyeXB0aW5nIiwiY3JlYXRlRGVjcnlwdGlvbkNpcGhlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/rc2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/rsa.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/rsa.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Javascript implementation of basic RSA algorithms.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n *\n * The only algorithm currently supported for PKI is RSA.\n *\n * An RSA key is often stored in ASN.1 DER format. The SubjectPublicKeyInfo\n * ASN.1 structure is composed of an algorithm of type AlgorithmIdentifier\n * and a subjectPublicKey of type bit string.\n *\n * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\n * for the algorithm, if any. In the case of RSA, there aren't any.\n *\n * SubjectPublicKeyInfo ::= SEQUENCE {\n *   algorithm AlgorithmIdentifier,\n *   subjectPublicKey BIT STRING\n * }\n *\n * AlgorithmIdentifer ::= SEQUENCE {\n *   algorithm OBJECT IDENTIFIER,\n *   parameters ANY DEFINED BY algorithm OPTIONAL\n * }\n *\n * For an RSA public key, the subjectPublicKey is:\n *\n * RSAPublicKey ::= SEQUENCE {\n *   modulus            INTEGER,    -- n\n *   publicExponent     INTEGER     -- e\n * }\n *\n * PrivateKeyInfo ::= SEQUENCE {\n *   version                   Version,\n *   privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,\n *   privateKey                PrivateKey,\n *   attributes           [0]  IMPLICIT Attributes OPTIONAL\n * }\n *\n * Version ::= INTEGER\n * PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier\n * PrivateKey ::= OCTET STRING\n * Attributes ::= SET OF Attribute\n *\n * An RSA private key as the following structure:\n *\n * RSAPrivateKey ::= SEQUENCE {\n *   version Version,\n *   modulus INTEGER, -- n\n *   publicExponent INTEGER, -- e\n *   privateExponent INTEGER, -- d\n *   prime1 INTEGER, -- p\n *   prime2 INTEGER, -- q\n *   exponent1 INTEGER, -- d mod (p-1)\n *   exponent2 INTEGER, -- d mod (q-1)\n *   coefficient INTEGER -- (inverse of q) mod p\n * }\n *\n * Version ::= INTEGER\n *\n * The OID for the RSA key algorithm is: 1.2.840.113549.1.1.1\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./asn1 */ \"(rsc)/./node_modules/node-forge/lib/asn1.js\");\n__webpack_require__(/*! ./jsbn */ \"(rsc)/./node_modules/node-forge/lib/jsbn.js\");\n__webpack_require__(/*! ./oids */ \"(rsc)/./node_modules/node-forge/lib/oids.js\");\n__webpack_require__(/*! ./pkcs1 */ \"(rsc)/./node_modules/node-forge/lib/pkcs1.js\");\n__webpack_require__(/*! ./prime */ \"(rsc)/./node_modules/node-forge/lib/prime.js\");\n__webpack_require__(/*! ./random */ \"(rsc)/./node_modules/node-forge/lib/random.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\nif (typeof BigInteger === \"undefined\") {\n    var BigInteger = forge.jsbn.BigInteger;\n}\nvar _crypto = forge.util.isNodejs ? __webpack_require__(/*! crypto */ \"crypto\") : null;\n// shortcut for asn.1 API\nvar asn1 = forge.asn1;\n// shortcut for util API\nvar util = forge.util;\n/*\n * RSA encryption and decryption, see RFC 2313.\n */ forge.pki = forge.pki || {};\nmodule.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};\nvar pki = forge.pki;\n// for finding primes, which are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29\nvar GCD_30_DELTA = [\n    6,\n    4,\n    2,\n    4,\n    2,\n    4,\n    6,\n    2\n];\n// validator for a PrivateKeyInfo structure\nvar privateKeyValidator = {\n    // PrivateKeyInfo\n    name: \"PrivateKeyInfo\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            // Version (INTEGER)\n            name: \"PrivateKeyInfo.version\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyVersion\"\n        },\n        {\n            // privateKeyAlgorithm\n            name: \"PrivateKeyInfo.privateKeyAlgorithm\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    name: \"AlgorithmIdentifier.algorithm\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OID,\n                    constructed: false,\n                    capture: \"privateKeyOid\"\n                }\n            ]\n        },\n        {\n            // PrivateKey\n            name: \"PrivateKeyInfo\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OCTETSTRING,\n            constructed: false,\n            capture: \"privateKey\"\n        }\n    ]\n};\n// validator for an RSA private key\nvar rsaPrivateKeyValidator = {\n    // RSAPrivateKey\n    name: \"RSAPrivateKey\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            // Version (INTEGER)\n            name: \"RSAPrivateKey.version\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyVersion\"\n        },\n        {\n            // modulus (n)\n            name: \"RSAPrivateKey.modulus\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyModulus\"\n        },\n        {\n            // publicExponent (e)\n            name: \"RSAPrivateKey.publicExponent\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyPublicExponent\"\n        },\n        {\n            // privateExponent (d)\n            name: \"RSAPrivateKey.privateExponent\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyPrivateExponent\"\n        },\n        {\n            // prime1 (p)\n            name: \"RSAPrivateKey.prime1\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyPrime1\"\n        },\n        {\n            // prime2 (q)\n            name: \"RSAPrivateKey.prime2\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyPrime2\"\n        },\n        {\n            // exponent1 (d mod (p-1))\n            name: \"RSAPrivateKey.exponent1\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyExponent1\"\n        },\n        {\n            // exponent2 (d mod (q-1))\n            name: \"RSAPrivateKey.exponent2\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyExponent2\"\n        },\n        {\n            // coefficient ((inverse of q) mod p)\n            name: \"RSAPrivateKey.coefficient\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"privateKeyCoefficient\"\n        }\n    ]\n};\n// validator for an RSA public key\nvar rsaPublicKeyValidator = {\n    // RSAPublicKey\n    name: \"RSAPublicKey\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            // modulus (n)\n            name: \"RSAPublicKey.modulus\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"publicKeyModulus\"\n        },\n        {\n            // publicExponent (e)\n            name: \"RSAPublicKey.exponent\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"publicKeyExponent\"\n        }\n    ]\n};\n// validator for an SubjectPublicKeyInfo structure\n// Note: Currently only works with an RSA public key\nvar publicKeyValidator = forge.pki.rsa.publicKeyValidator = {\n    name: \"SubjectPublicKeyInfo\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    captureAsn1: \"subjectPublicKeyInfo\",\n    value: [\n        {\n            name: \"SubjectPublicKeyInfo.AlgorithmIdentifier\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    name: \"AlgorithmIdentifier.algorithm\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OID,\n                    constructed: false,\n                    capture: \"publicKeyOid\"\n                }\n            ]\n        },\n        {\n            // subjectPublicKey\n            name: \"SubjectPublicKeyInfo.subjectPublicKey\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.BITSTRING,\n            constructed: false,\n            value: [\n                {\n                    // RSAPublicKey\n                    name: \"SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.SEQUENCE,\n                    constructed: true,\n                    optional: true,\n                    captureAsn1: \"rsaPublicKey\"\n                }\n            ]\n        }\n    ]\n};\n// validator for a DigestInfo structure\nvar digestInfoValidator = {\n    name: \"DigestInfo\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"DigestInfo.DigestAlgorithm\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    name: \"DigestInfo.DigestAlgorithm.algorithmIdentifier\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OID,\n                    constructed: false,\n                    capture: \"algorithmIdentifier\"\n                },\n                {\n                    // NULL paramters\n                    name: \"DigestInfo.DigestAlgorithm.parameters\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.NULL,\n                    // captured only to check existence for md2 and md5\n                    capture: \"parameters\",\n                    optional: true,\n                    constructed: false\n                }\n            ]\n        },\n        {\n            // digest\n            name: \"DigestInfo.digest\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OCTETSTRING,\n            constructed: false,\n            capture: \"digest\"\n        }\n    ]\n};\n/**\n * Wrap digest in DigestInfo object.\n *\n * This function implements EMSA-PKCS1-v1_5-ENCODE as per RFC 3447.\n *\n * DigestInfo ::= SEQUENCE {\n *   digestAlgorithm DigestAlgorithmIdentifier,\n *   digest Digest\n * }\n *\n * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\n * Digest ::= OCTET STRING\n *\n * @param md the message digest object with the hash to sign.\n *\n * @return the encoded message (ready for RSA encrytion)\n */ var emsaPkcs1v15encode = function(md) {\n    // get the oid for the algorithm\n    var oid;\n    if (md.algorithm in pki.oids) {\n        oid = pki.oids[md.algorithm];\n    } else {\n        var error = new Error(\"Unknown message digest algorithm.\");\n        error.algorithm = md.algorithm;\n        throw error;\n    }\n    var oidBytes = asn1.oidToDer(oid).getBytes();\n    // create the digest info\n    var digestInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n    var digestAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n    digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, oidBytes));\n    digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\"));\n    var digest = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, md.digest().getBytes());\n    digestInfo.value.push(digestAlgorithm);\n    digestInfo.value.push(digest);\n    // encode digest info\n    return asn1.toDer(digestInfo).getBytes();\n};\n/**\n * Performs x^c mod n (RSA encryption or decryption operation).\n *\n * @param x the number to raise and mod.\n * @param key the key to use.\n * @param pub true if the key is public, false if private.\n *\n * @return the result of x^c mod n.\n */ var _modPow = function(x, key, pub) {\n    if (pub) {\n        return x.modPow(key.e, key.n);\n    }\n    if (!key.p || !key.q) {\n        // allow calculation without CRT params (slow)\n        return x.modPow(key.d, key.n);\n    }\n    // pre-compute dP, dQ, and qInv if necessary\n    if (!key.dP) {\n        key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));\n    }\n    if (!key.dQ) {\n        key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));\n    }\n    if (!key.qInv) {\n        key.qInv = key.q.modInverse(key.p);\n    }\n    /* Chinese remainder theorem (CRT) states:\n\n    Suppose n1, n2, ..., nk are positive integers which are pairwise\n    coprime (n1 and n2 have no common factors other than 1). For any\n    integers x1, x2, ..., xk there exists an integer x solving the\n    system of simultaneous congruences (where ~= means modularly\n    congruent so a ~= b mod n means a mod n = b mod n):\n\n    x ~= x1 mod n1\n    x ~= x2 mod n2\n    ...\n    x ~= xk mod nk\n\n    This system of congruences has a single simultaneous solution x\n    between 0 and n - 1. Furthermore, each xk solution and x itself\n    is congruent modulo the product n = n1*n2*...*nk.\n    So x1 mod n = x2 mod n = xk mod n = x mod n.\n\n    The single simultaneous solution x can be solved with the following\n    equation:\n\n    x = sum(xi*ri*si) mod n where ri = n/ni and si = ri^-1 mod ni.\n\n    Where x is less than n, xi = x mod ni.\n\n    For RSA we are only concerned with k = 2. The modulus n = pq, where\n    p and q are coprime. The RSA decryption algorithm is:\n\n    y = x^d mod n\n\n    Given the above:\n\n    x1 = x^d mod p\n    r1 = n/p = q\n    s1 = q^-1 mod p\n    x2 = x^d mod q\n    r2 = n/q = p\n    s2 = p^-1 mod q\n\n    So y = (x1r1s1 + x2r2s2) mod n\n         = ((x^d mod p)q(q^-1 mod p) + (x^d mod q)p(p^-1 mod q)) mod n\n\n    According to Fermat's Little Theorem, if the modulus P is prime,\n    for any integer A not evenly divisible by P, A^(P-1) ~= 1 mod P.\n    Since A is not divisible by P it follows that if:\n    N ~= M mod (P - 1), then A^N mod P = A^M mod P. Therefore:\n\n    A^N mod P = A^(M mod (P - 1)) mod P. (The latter takes less effort\n    to calculate). In order to calculate x^d mod p more quickly the\n    exponent d mod (p - 1) is stored in the RSA private key (the same\n    is done for x^d mod q). These values are referred to as dP and dQ\n    respectively. Therefore we now have:\n\n    y = ((x^dP mod p)q(q^-1 mod p) + (x^dQ mod q)p(p^-1 mod q)) mod n\n\n    Since we'll be reducing x^dP by modulo p (same for q) we can also\n    reduce x by p (and q respectively) before hand. Therefore, let\n\n    xp = ((x mod p)^dP mod p), and\n    xq = ((x mod q)^dQ mod q), yielding:\n\n    y = (xp*q*(q^-1 mod p) + xq*p*(p^-1 mod q)) mod n\n\n    This can be further reduced to a simple algorithm that only\n    requires 1 inverse (the q inverse is used) to be used and stored.\n    The algorithm is called Garner's algorithm. If qInv is the\n    inverse of q, we simply calculate:\n\n    y = (qInv*(xp - xq) mod p) * q + xq\n\n    However, there are two further complications. First, we need to\n    ensure that xp > xq to prevent signed BigIntegers from being used\n    so we add p until this is true (since we will be mod'ing with\n    p anyway). Then, there is a known timing attack on algorithms\n    using the CRT. To mitigate this risk, \"cryptographic blinding\"\n    should be used. This requires simply generating a random number r\n    between 0 and n-1 and its inverse and multiplying x by r^e before\n    calculating y and then multiplying y by r^-1 afterwards. Note that\n    r must be coprime with n (gcd(r, n) === 1) in order to have an\n    inverse.\n  */ // cryptographic blinding\n    var r;\n    do {\n        r = new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)), 16);\n    }while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));\n    x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);\n    // calculate xp and xq\n    var xp = x.mod(key.p).modPow(key.dP, key.p);\n    var xq = x.mod(key.q).modPow(key.dQ, key.q);\n    // xp must be larger than xq to avoid signed bit usage\n    while(xp.compareTo(xq) < 0){\n        xp = xp.add(key.p);\n    }\n    // do last step\n    var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);\n    // remove effect of random for cryptographic blinding\n    y = y.multiply(r.modInverse(key.n)).mod(key.n);\n    return y;\n};\n/**\n * NOTE: THIS METHOD IS DEPRECATED, use 'sign' on a private key object or\n * 'encrypt' on a public key object instead.\n *\n * Performs RSA encryption.\n *\n * The parameter bt controls whether to put padding bytes before the\n * message passed in. Set bt to either true or false to disable padding\n * completely (in order to handle e.g. EMSA-PSS encoding seperately before),\n * signaling whether the encryption operation is a public key operation\n * (i.e. encrypting data) or not, i.e. private key operation (data signing).\n *\n * For PKCS#1 v1.5 padding pass in the block type to use, i.e. either 0x01\n * (for signing) or 0x02 (for encryption). The key operation mode (private\n * or public) is derived from this flag in that case).\n *\n * @param m the message to encrypt as a byte string.\n * @param key the RSA key to use.\n * @param bt for PKCS#1 v1.5 padding, the block type to use\n *   (0x01 for private key, 0x02 for public),\n *   to disable padding: true = public key, false = private key.\n *\n * @return the encrypted bytes as a string.\n */ pki.rsa.encrypt = function(m, key, bt) {\n    var pub = bt;\n    var eb;\n    // get the length of the modulus in bytes\n    var k = Math.ceil(key.n.bitLength() / 8);\n    if (bt !== false && bt !== true) {\n        // legacy, default to PKCS#1 v1.5 padding\n        pub = bt === 0x02;\n        eb = _encodePkcs1_v1_5(m, key, bt);\n    } else {\n        eb = forge.util.createBuffer();\n        eb.putBytes(m);\n    }\n    // load encryption block as big integer 'x'\n    // FIXME: hex conversion inefficient, get BigInteger w/byte strings\n    var x = new BigInteger(eb.toHex(), 16);\n    // do RSA encryption\n    var y = _modPow(x, key, pub);\n    // convert y into the encrypted data byte string, if y is shorter in\n    // bytes than k, then prepend zero bytes to fill up ed\n    // FIXME: hex conversion inefficient, get BigInteger w/byte strings\n    var yhex = y.toString(16);\n    var ed = forge.util.createBuffer();\n    var zeros = k - Math.ceil(yhex.length / 2);\n    while(zeros > 0){\n        ed.putByte(0x00);\n        --zeros;\n    }\n    ed.putBytes(forge.util.hexToBytes(yhex));\n    return ed.getBytes();\n};\n/**\n * NOTE: THIS METHOD IS DEPRECATED, use 'decrypt' on a private key object or\n * 'verify' on a public key object instead.\n *\n * Performs RSA decryption.\n *\n * The parameter ml controls whether to apply PKCS#1 v1.5 padding\n * or not.  Set ml = false to disable padding removal completely\n * (in order to handle e.g. EMSA-PSS later on) and simply pass back\n * the RSA encryption block.\n *\n * @param ed the encrypted data to decrypt in as a byte string.\n * @param key the RSA key to use.\n * @param pub true for a public key operation, false for private.\n * @param ml the message length, if known, false to disable padding.\n *\n * @return the decrypted message as a byte string.\n */ pki.rsa.decrypt = function(ed, key, pub, ml) {\n    // get the length of the modulus in bytes\n    var k = Math.ceil(key.n.bitLength() / 8);\n    // error if the length of the encrypted data ED is not k\n    if (ed.length !== k) {\n        var error = new Error(\"Encrypted message length is invalid.\");\n        error.length = ed.length;\n        error.expected = k;\n        throw error;\n    }\n    // convert encrypted data into a big integer\n    // FIXME: hex conversion inefficient, get BigInteger w/byte strings\n    var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);\n    // y must be less than the modulus or it wasn't the result of\n    // a previous mod operation (encryption) using that modulus\n    if (y.compareTo(key.n) >= 0) {\n        throw new Error(\"Encrypted message is invalid.\");\n    }\n    // do RSA decryption\n    var x = _modPow(y, key, pub);\n    // create the encryption block, if x is shorter in bytes than k, then\n    // prepend zero bytes to fill up eb\n    // FIXME: hex conversion inefficient, get BigInteger w/byte strings\n    var xhex = x.toString(16);\n    var eb = forge.util.createBuffer();\n    var zeros = k - Math.ceil(xhex.length / 2);\n    while(zeros > 0){\n        eb.putByte(0x00);\n        --zeros;\n    }\n    eb.putBytes(forge.util.hexToBytes(xhex));\n    if (ml !== false) {\n        // legacy, default to PKCS#1 v1.5 padding\n        return _decodePkcs1_v1_5(eb.getBytes(), key, pub);\n    }\n    // return message\n    return eb.getBytes();\n};\n/**\n * Creates an RSA key-pair generation state object. It is used to allow\n * key-generation to be performed in steps. It also allows for a UI to\n * display progress updates.\n *\n * @param bits the size for the private key in bits, defaults to 2048.\n * @param e the public exponent to use, defaults to 65537 (0x10001).\n * @param [options] the options to use.\n *          prng a custom crypto-secure pseudo-random number generator to use,\n *            that must define \"getBytesSync\".\n *          algorithm the algorithm to use (default: 'PRIMEINC').\n *\n * @return the state object to use to generate the key-pair.\n */ pki.rsa.createKeyPairGenerationState = function(bits, e, options) {\n    // TODO: migrate step-based prime generation code to forge.prime\n    // set default bits\n    if (typeof bits === \"string\") {\n        bits = parseInt(bits, 10);\n    }\n    bits = bits || 2048;\n    // create prng with api that matches BigInteger secure random\n    options = options || {};\n    var prng = options.prng || forge.random;\n    var rng = {\n        // x is an array to fill with bytes\n        nextBytes: function(x) {\n            var b = prng.getBytesSync(x.length);\n            for(var i = 0; i < x.length; ++i){\n                x[i] = b.charCodeAt(i);\n            }\n        }\n    };\n    var algorithm = options.algorithm || \"PRIMEINC\";\n    // create PRIMEINC algorithm state\n    var rval;\n    if (algorithm === \"PRIMEINC\") {\n        rval = {\n            algorithm: algorithm,\n            state: 0,\n            bits: bits,\n            rng: rng,\n            eInt: e || 65537,\n            e: new BigInteger(null),\n            p: null,\n            q: null,\n            qBits: bits >> 1,\n            pBits: bits - (bits >> 1),\n            pqState: 0,\n            num: null,\n            keys: null\n        };\n        rval.e.fromInt(rval.eInt);\n    } else {\n        throw new Error(\"Invalid key generation algorithm: \" + algorithm);\n    }\n    return rval;\n};\n/**\n * Attempts to runs the key-generation algorithm for at most n seconds\n * (approximately) using the given state. When key-generation has completed,\n * the keys will be stored in state.keys.\n *\n * To use this function to update a UI while generating a key or to prevent\n * causing browser lockups/warnings, set \"n\" to a value other than 0. A\n * simple pattern for generating a key and showing a progress indicator is:\n *\n * var state = pki.rsa.createKeyPairGenerationState(2048);\n * var step = function() {\n *   // step key-generation, run algorithm for 100 ms, repeat\n *   if(!forge.pki.rsa.stepKeyPairGenerationState(state, 100)) {\n *     setTimeout(step, 1);\n *   } else {\n *     // key-generation complete\n *     // TODO: turn off progress indicator here\n *     // TODO: use the generated key-pair in \"state.keys\"\n *   }\n * };\n * // TODO: turn on progress indicator here\n * setTimeout(step, 0);\n *\n * @param state the state to use.\n * @param n the maximum number of milliseconds to run the algorithm for, 0\n *          to run the algorithm to completion.\n *\n * @return true if the key-generation completed, false if not.\n */ pki.rsa.stepKeyPairGenerationState = function(state, n) {\n    // set default algorithm if not set\n    if (!(\"algorithm\" in state)) {\n        state.algorithm = \"PRIMEINC\";\n    }\n    // TODO: migrate step-based prime generation code to forge.prime\n    // TODO: abstract as PRIMEINC algorithm\n    // do key generation (based on Tom Wu's rsa.js, see jsbn.js license)\n    // with some minor optimizations and designed to run in steps\n    // local state vars\n    var THIRTY = new BigInteger(null);\n    THIRTY.fromInt(30);\n    var deltaIdx = 0;\n    var op_or = function(x, y) {\n        return x | y;\n    };\n    // keep stepping until time limit is reached or done\n    var t1 = +new Date();\n    var t2;\n    var total = 0;\n    while(state.keys === null && (n <= 0 || total < n)){\n        // generate p or q\n        if (state.state === 0) {\n            /* Note: All primes are of the form:\n\n        30k+i, for i < 30 and gcd(30, i)=1, where there are 8 values for i\n\n        When we generate a random number, we always align it at 30k + 1. Each\n        time the number is determined not to be prime we add to get to the\n        next 'i', eg: if the number was at 30k + 1 we add 6. */ var bits = state.p === null ? state.pBits : state.qBits;\n            var bits1 = bits - 1;\n            // get a random number\n            if (state.pqState === 0) {\n                state.num = new BigInteger(bits, state.rng);\n                // force MSB set\n                if (!state.num.testBit(bits1)) {\n                    state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, state.num);\n                }\n                // align number on 30k+1 boundary\n                state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);\n                deltaIdx = 0;\n                ++state.pqState;\n            } else if (state.pqState === 1) {\n                // try to make the number a prime\n                if (state.num.bitLength() > bits) {\n                    // overflow, try again\n                    state.pqState = 0;\n                // do primality test\n                } else if (state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))) {\n                    ++state.pqState;\n                } else {\n                    // get next potential prime\n                    state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);\n                }\n            } else if (state.pqState === 2) {\n                // ensure number is coprime with e\n                state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;\n            } else if (state.pqState === 3) {\n                // store p or q\n                state.pqState = 0;\n                if (state.p === null) {\n                    state.p = state.num;\n                } else {\n                    state.q = state.num;\n                }\n                // advance state if both p and q are ready\n                if (state.p !== null && state.q !== null) {\n                    ++state.state;\n                }\n                state.num = null;\n            }\n        } else if (state.state === 1) {\n            // ensure p is larger than q (swap them if not)\n            if (state.p.compareTo(state.q) < 0) {\n                state.num = state.p;\n                state.p = state.q;\n                state.q = state.num;\n            }\n            ++state.state;\n        } else if (state.state === 2) {\n            // compute phi: (p - 1)(q - 1) (Euler's totient function)\n            state.p1 = state.p.subtract(BigInteger.ONE);\n            state.q1 = state.q.subtract(BigInteger.ONE);\n            state.phi = state.p1.multiply(state.q1);\n            ++state.state;\n        } else if (state.state === 3) {\n            // ensure e and phi are coprime\n            if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {\n                // phi and e are coprime, advance\n                ++state.state;\n            } else {\n                // phi and e aren't coprime, so generate a new p and q\n                state.p = null;\n                state.q = null;\n                state.state = 0;\n            }\n        } else if (state.state === 4) {\n            // create n, ensure n is has the right number of bits\n            state.n = state.p.multiply(state.q);\n            // ensure n is right number of bits\n            if (state.n.bitLength() === state.bits) {\n                // success, advance\n                ++state.state;\n            } else {\n                // failed, get new q\n                state.q = null;\n                state.state = 0;\n            }\n        } else if (state.state === 5) {\n            // set keys\n            var d = state.e.modInverse(state.phi);\n            state.keys = {\n                privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),\n                publicKey: pki.rsa.setPublicKey(state.n, state.e)\n            };\n        }\n        // update timing\n        t2 = +new Date();\n        total += t2 - t1;\n        t1 = t2;\n    }\n    return state.keys !== null;\n};\n/**\n * Generates an RSA public-private key pair in a single call.\n *\n * To generate a key-pair in steps (to allow for progress updates and to\n * prevent blocking or warnings in slow browsers) then use the key-pair\n * generation state functions.\n *\n * To generate a key-pair asynchronously (either through web-workers, if\n * available, or by breaking up the work on the main thread), pass a\n * callback function.\n *\n * @param [bits] the size for the private key in bits, defaults to 2048.\n * @param [e] the public exponent to use, defaults to 65537.\n * @param [options] options for key-pair generation, if given then 'bits'\n *            and 'e' must *not* be given:\n *          bits the size for the private key in bits, (default: 2048).\n *          e the public exponent to use, (default: 65537 (0x10001)).\n *          workerScript the worker script URL.\n *          workers the number of web workers (if supported) to use,\n *            (default: 2).\n *          workLoad the size of the work load, ie: number of possible prime\n *            numbers for each web worker to check per work assignment,\n *            (default: 100).\n *          prng a custom crypto-secure pseudo-random number generator to use,\n *            that must define \"getBytesSync\". Disables use of native APIs.\n *          algorithm the algorithm to use (default: 'PRIMEINC').\n * @param [callback(err, keypair)] called once the operation completes.\n *\n * @return an object with privateKey and publicKey properties.\n */ pki.rsa.generateKeyPair = function(bits, e, options, callback) {\n    // (bits), (options), (callback)\n    if (arguments.length === 1) {\n        if (typeof bits === \"object\") {\n            options = bits;\n            bits = undefined;\n        } else if (typeof bits === \"function\") {\n            callback = bits;\n            bits = undefined;\n        }\n    } else if (arguments.length === 2) {\n        // (bits, e), (bits, options), (bits, callback), (options, callback)\n        if (typeof bits === \"number\") {\n            if (typeof e === \"function\") {\n                callback = e;\n                e = undefined;\n            } else if (typeof e !== \"number\") {\n                options = e;\n                e = undefined;\n            }\n        } else {\n            options = bits;\n            callback = e;\n            bits = undefined;\n            e = undefined;\n        }\n    } else if (arguments.length === 3) {\n        // (bits, e, options), (bits, e, callback), (bits, options, callback)\n        if (typeof e === \"number\") {\n            if (typeof options === \"function\") {\n                callback = options;\n                options = undefined;\n            }\n        } else {\n            callback = options;\n            options = e;\n            e = undefined;\n        }\n    }\n    options = options || {};\n    if (bits === undefined) {\n        bits = options.bits || 2048;\n    }\n    if (e === undefined) {\n        e = options.e || 0x10001;\n    }\n    // use native code if permitted, available, and parameters are acceptable\n    if (!forge.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 0x10001 || e === 3)) {\n        if (callback) {\n            // try native async\n            if (_detectNodeCrypto(\"generateKeyPair\")) {\n                return _crypto.generateKeyPair(\"rsa\", {\n                    modulusLength: bits,\n                    publicExponent: e,\n                    publicKeyEncoding: {\n                        type: \"spki\",\n                        format: \"pem\"\n                    },\n                    privateKeyEncoding: {\n                        type: \"pkcs8\",\n                        format: \"pem\"\n                    }\n                }, function(err, pub, priv) {\n                    if (err) {\n                        return callback(err);\n                    }\n                    callback(null, {\n                        privateKey: pki.privateKeyFromPem(priv),\n                        publicKey: pki.publicKeyFromPem(pub)\n                    });\n                });\n            }\n            if (_detectSubtleCrypto(\"generateKey\") && _detectSubtleCrypto(\"exportKey\")) {\n                // use standard native generateKey\n                return util.globalScope.crypto.subtle.generateKey({\n                    name: \"RSASSA-PKCS1-v1_5\",\n                    modulusLength: bits,\n                    publicExponent: _intToUint8Array(e),\n                    hash: {\n                        name: \"SHA-256\"\n                    }\n                }, true, [\n                    \"sign\",\n                    \"verify\"\n                ]).then(function(pair) {\n                    return util.globalScope.crypto.subtle.exportKey(\"pkcs8\", pair.privateKey);\n                // avoiding catch(function(err) {...}) to support IE <= 8\n                }).then(undefined, function(err) {\n                    callback(err);\n                }).then(function(pkcs8) {\n                    if (pkcs8) {\n                        var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));\n                        callback(null, {\n                            privateKey: privateKey,\n                            publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)\n                        });\n                    }\n                });\n            }\n            if (_detectSubtleMsCrypto(\"generateKey\") && _detectSubtleMsCrypto(\"exportKey\")) {\n                var genOp = util.globalScope.msCrypto.subtle.generateKey({\n                    name: \"RSASSA-PKCS1-v1_5\",\n                    modulusLength: bits,\n                    publicExponent: _intToUint8Array(e),\n                    hash: {\n                        name: \"SHA-256\"\n                    }\n                }, true, [\n                    \"sign\",\n                    \"verify\"\n                ]);\n                genOp.oncomplete = function(e) {\n                    var pair = e.target.result;\n                    var exportOp = util.globalScope.msCrypto.subtle.exportKey(\"pkcs8\", pair.privateKey);\n                    exportOp.oncomplete = function(e) {\n                        var pkcs8 = e.target.result;\n                        var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));\n                        callback(null, {\n                            privateKey: privateKey,\n                            publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)\n                        });\n                    };\n                    exportOp.onerror = function(err) {\n                        callback(err);\n                    };\n                };\n                genOp.onerror = function(err) {\n                    callback(err);\n                };\n                return;\n            }\n        } else {\n            // try native sync\n            if (_detectNodeCrypto(\"generateKeyPairSync\")) {\n                var keypair = _crypto.generateKeyPairSync(\"rsa\", {\n                    modulusLength: bits,\n                    publicExponent: e,\n                    publicKeyEncoding: {\n                        type: \"spki\",\n                        format: \"pem\"\n                    },\n                    privateKeyEncoding: {\n                        type: \"pkcs8\",\n                        format: \"pem\"\n                    }\n                });\n                return {\n                    privateKey: pki.privateKeyFromPem(keypair.privateKey),\n                    publicKey: pki.publicKeyFromPem(keypair.publicKey)\n                };\n            }\n        }\n    }\n    // use JavaScript implementation\n    var state = pki.rsa.createKeyPairGenerationState(bits, e, options);\n    if (!callback) {\n        pki.rsa.stepKeyPairGenerationState(state, 0);\n        return state.keys;\n    }\n    _generateKeyPair(state, options, callback);\n};\n/**\n * Sets an RSA public key from BigIntegers modulus and exponent.\n *\n * @param n the modulus.\n * @param e the exponent.\n *\n * @return the public key.\n */ pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {\n    var key = {\n        n: n,\n        e: e\n    };\n    /**\n   * Encrypts the given data with this public key. Newer applications\n   * should use the 'RSA-OAEP' decryption scheme, 'RSAES-PKCS1-V1_5' is for\n   * legacy applications.\n   *\n   * @param data the byte string to encrypt.\n   * @param scheme the encryption scheme to use:\n   *          'RSAES-PKCS1-V1_5' (default),\n   *          'RSA-OAEP',\n   *          'RAW', 'NONE', or null to perform raw RSA encryption,\n   *          an object with an 'encode' property set to a function\n   *          with the signature 'function(data, key)' that returns\n   *          a binary-encoded string representing the encoded data.\n   * @param schemeOptions any scheme-specific options.\n   *\n   * @return the encrypted byte string.\n   */ key.encrypt = function(data, scheme, schemeOptions) {\n        if (typeof scheme === \"string\") {\n            scheme = scheme.toUpperCase();\n        } else if (scheme === undefined) {\n            scheme = \"RSAES-PKCS1-V1_5\";\n        }\n        if (scheme === \"RSAES-PKCS1-V1_5\") {\n            scheme = {\n                encode: function(m, key, pub) {\n                    return _encodePkcs1_v1_5(m, key, 0x02).getBytes();\n                }\n            };\n        } else if (scheme === \"RSA-OAEP\" || scheme === \"RSAES-OAEP\") {\n            scheme = {\n                encode: function(m, key) {\n                    return forge.pkcs1.encode_rsa_oaep(key, m, schemeOptions);\n                }\n            };\n        } else if ([\n            \"RAW\",\n            \"NONE\",\n            \"NULL\",\n            null\n        ].indexOf(scheme) !== -1) {\n            scheme = {\n                encode: function(e) {\n                    return e;\n                }\n            };\n        } else if (typeof scheme === \"string\") {\n            throw new Error('Unsupported encryption scheme: \"' + scheme + '\".');\n        }\n        // do scheme-based encoding then rsa encryption\n        var e = scheme.encode(data, key, true);\n        return pki.rsa.encrypt(e, key, true);\n    };\n    /**\n   * Verifies the given signature against the given digest.\n   *\n   * PKCS#1 supports multiple (currently two) signature schemes:\n   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.\n   *\n   * By default this implementation uses the \"old scheme\", i.e.\n   * RSASSA-PKCS1-V1_5, in which case once RSA-decrypted, the\n   * signature is an OCTET STRING that holds a DigestInfo.\n   *\n   * DigestInfo ::= SEQUENCE {\n   *   digestAlgorithm DigestAlgorithmIdentifier,\n   *   digest Digest\n   * }\n   * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\n   * Digest ::= OCTET STRING\n   *\n   * To perform PSS signature verification, provide an instance\n   * of Forge PSS object as the scheme parameter.\n   *\n   * @param digest the message digest hash to compare against the signature,\n   *          as a binary-encoded string.\n   * @param signature the signature to verify, as a binary-encoded string.\n   * @param scheme signature verification scheme to use:\n   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,\n   *          a Forge PSS object for RSASSA-PSS,\n   *          'NONE' or null for none, DigestInfo will not be expected, but\n   *            PKCS#1 v1.5 padding will still be used.\n   * @param options optional verify options\n   *          _parseAllDigestBytes testing flag to control parsing of all\n   *            digest bytes. Unsupported and not for general usage.\n   *            (default: true)\n   *\n   * @return true if the signature was verified, false if not.\n   */ key.verify = function(digest, signature, scheme, options) {\n        if (typeof scheme === \"string\") {\n            scheme = scheme.toUpperCase();\n        } else if (scheme === undefined) {\n            scheme = \"RSASSA-PKCS1-V1_5\";\n        }\n        if (options === undefined) {\n            options = {\n                _parseAllDigestBytes: true\n            };\n        }\n        if (!(\"_parseAllDigestBytes\" in options)) {\n            options._parseAllDigestBytes = true;\n        }\n        if (scheme === \"RSASSA-PKCS1-V1_5\") {\n            scheme = {\n                verify: function(digest, d) {\n                    // remove padding\n                    d = _decodePkcs1_v1_5(d, key, true);\n                    // d is ASN.1 BER-encoded DigestInfo\n                    var obj = asn1.fromDer(d, {\n                        parseAllBytes: options._parseAllDigestBytes\n                    });\n                    // validate DigestInfo\n                    var capture = {};\n                    var errors = [];\n                    if (!asn1.validate(obj, digestInfoValidator, capture, errors)) {\n                        var error = new Error(\"ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 \" + \"DigestInfo value.\");\n                        error.errors = errors;\n                        throw error;\n                    }\n                    // check hash algorithm identifier\n                    // see PKCS1-v1-5DigestAlgorithms in RFC 8017\n                    // FIXME: add support to vaidator for strict value choices\n                    var oid = asn1.derToOid(capture.algorithmIdentifier);\n                    if (!(oid === forge.oids.md2 || oid === forge.oids.md5 || oid === forge.oids.sha1 || oid === forge.oids.sha224 || oid === forge.oids.sha256 || oid === forge.oids.sha384 || oid === forge.oids.sha512 || oid === forge.oids[\"sha512-224\"] || oid === forge.oids[\"sha512-256\"])) {\n                        var error = new Error(\"Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier.\");\n                        error.oid = oid;\n                        throw error;\n                    }\n                    // special check for md2 and md5 that NULL parameters exist\n                    if (oid === forge.oids.md2 || oid === forge.oids.md5) {\n                        if (!(\"parameters\" in capture)) {\n                            throw new Error(\"ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 \" + \"DigestInfo value. \" + \"Missing algorithm identifer NULL parameters.\");\n                        }\n                    }\n                    // compare the given digest to the decrypted one\n                    return digest === capture.digest;\n                }\n            };\n        } else if (scheme === \"NONE\" || scheme === \"NULL\" || scheme === null) {\n            scheme = {\n                verify: function(digest, d) {\n                    // remove padding\n                    d = _decodePkcs1_v1_5(d, key, true);\n                    return digest === d;\n                }\n            };\n        }\n        // do rsa decryption w/o any decoding, then verify -- which does decoding\n        var d = pki.rsa.decrypt(signature, key, true, false);\n        return scheme.verify(digest, d, key.n.bitLength());\n    };\n    return key;\n};\n/**\n * Sets an RSA private key from BigIntegers modulus, exponent, primes,\n * prime exponents, and modular multiplicative inverse.\n *\n * @param n the modulus.\n * @param e the public exponent.\n * @param d the private exponent ((inverse of e) mod n).\n * @param p the first prime.\n * @param q the second prime.\n * @param dP exponent1 (d mod (p-1)).\n * @param dQ exponent2 (d mod (q-1)).\n * @param qInv ((inverse of q) mod p)\n *\n * @return the private key.\n */ pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {\n    var key = {\n        n: n,\n        e: e,\n        d: d,\n        p: p,\n        q: q,\n        dP: dP,\n        dQ: dQ,\n        qInv: qInv\n    };\n    /**\n   * Decrypts the given data with this private key. The decryption scheme\n   * must match the one used to encrypt the data.\n   *\n   * @param data the byte string to decrypt.\n   * @param scheme the decryption scheme to use:\n   *          'RSAES-PKCS1-V1_5' (default),\n   *          'RSA-OAEP',\n   *          'RAW', 'NONE', or null to perform raw RSA decryption.\n   * @param schemeOptions any scheme-specific options.\n   *\n   * @return the decrypted byte string.\n   */ key.decrypt = function(data, scheme, schemeOptions) {\n        if (typeof scheme === \"string\") {\n            scheme = scheme.toUpperCase();\n        } else if (scheme === undefined) {\n            scheme = \"RSAES-PKCS1-V1_5\";\n        }\n        // do rsa decryption w/o any decoding\n        var d = pki.rsa.decrypt(data, key, false, false);\n        if (scheme === \"RSAES-PKCS1-V1_5\") {\n            scheme = {\n                decode: _decodePkcs1_v1_5\n            };\n        } else if (scheme === \"RSA-OAEP\" || scheme === \"RSAES-OAEP\") {\n            scheme = {\n                decode: function(d, key) {\n                    return forge.pkcs1.decode_rsa_oaep(key, d, schemeOptions);\n                }\n            };\n        } else if ([\n            \"RAW\",\n            \"NONE\",\n            \"NULL\",\n            null\n        ].indexOf(scheme) !== -1) {\n            scheme = {\n                decode: function(d) {\n                    return d;\n                }\n            };\n        } else {\n            throw new Error('Unsupported encryption scheme: \"' + scheme + '\".');\n        }\n        // decode according to scheme\n        return scheme.decode(d, key, false);\n    };\n    /**\n   * Signs the given digest, producing a signature.\n   *\n   * PKCS#1 supports multiple (currently two) signature schemes:\n   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.\n   *\n   * By default this implementation uses the \"old scheme\", i.e.\n   * RSASSA-PKCS1-V1_5. In order to generate a PSS signature, provide\n   * an instance of Forge PSS object as the scheme parameter.\n   *\n   * @param md the message digest object with the hash to sign.\n   * @param scheme the signature scheme to use:\n   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,\n   *          a Forge PSS object for RSASSA-PSS,\n   *          'NONE' or null for none, DigestInfo will not be used but\n   *            PKCS#1 v1.5 padding will still be used.\n   *\n   * @return the signature as a byte string.\n   */ key.sign = function(md, scheme) {\n        /* Note: The internal implementation of RSA operations is being\n      transitioned away from a PKCS#1 v1.5 hard-coded scheme. Some legacy\n      code like the use of an encoding block identifier 'bt' will eventually\n      be removed. */ // private key operation\n        var bt = false;\n        if (typeof scheme === \"string\") {\n            scheme = scheme.toUpperCase();\n        }\n        if (scheme === undefined || scheme === \"RSASSA-PKCS1-V1_5\") {\n            scheme = {\n                encode: emsaPkcs1v15encode\n            };\n            bt = 0x01;\n        } else if (scheme === \"NONE\" || scheme === \"NULL\" || scheme === null) {\n            scheme = {\n                encode: function() {\n                    return md;\n                }\n            };\n            bt = 0x01;\n        }\n        // encode and then encrypt\n        var d = scheme.encode(md, key.n.bitLength());\n        return pki.rsa.encrypt(d, key, bt);\n    };\n    return key;\n};\n/**\n * Wraps an RSAPrivateKey ASN.1 object in an ASN.1 PrivateKeyInfo object.\n *\n * @param rsaKey the ASN.1 RSAPrivateKey.\n *\n * @return the ASN.1 PrivateKeyInfo.\n */ pki.wrapRsaPrivateKey = function(rsaKey) {\n    // PrivateKeyInfo\n    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // version (0)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),\n        // privateKeyAlgorithm\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n        ]),\n        // PrivateKey\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(rsaKey).getBytes())\n    ]);\n};\n/**\n * Converts a private key from an ASN.1 object.\n *\n * @param obj the ASN.1 representation of a PrivateKeyInfo containing an\n *          RSAPrivateKey or an RSAPrivateKey.\n *\n * @return the private key.\n */ pki.privateKeyFromAsn1 = function(obj) {\n    // get PrivateKeyInfo\n    var capture = {};\n    var errors = [];\n    if (asn1.validate(obj, privateKeyValidator, capture, errors)) {\n        obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));\n    }\n    // get RSAPrivateKey\n    capture = {};\n    errors = [];\n    if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {\n        var error = new Error(\"Cannot read private key. \" + \"ASN.1 object does not contain an RSAPrivateKey.\");\n        error.errors = errors;\n        throw error;\n    }\n    // Note: Version is currently ignored.\n    // capture.privateKeyVersion\n    // FIXME: inefficient, get a BigInteger that uses byte strings\n    var n, e, d, p, q, dP, dQ, qInv;\n    n = forge.util.createBuffer(capture.privateKeyModulus).toHex();\n    e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();\n    d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();\n    p = forge.util.createBuffer(capture.privateKeyPrime1).toHex();\n    q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();\n    dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();\n    dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();\n    qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();\n    // set private key\n    return pki.setRsaPrivateKey(new BigInteger(n, 16), new BigInteger(e, 16), new BigInteger(d, 16), new BigInteger(p, 16), new BigInteger(q, 16), new BigInteger(dP, 16), new BigInteger(dQ, 16), new BigInteger(qInv, 16));\n};\n/**\n * Converts a private key to an ASN.1 RSAPrivateKey.\n *\n * @param key the private key.\n *\n * @return the ASN.1 representation of an RSAPrivateKey.\n */ pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {\n    // RSAPrivateKey\n    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // version (0 = only 2 primes, 1 multiple primes)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),\n        // modulus (n)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)),\n        // publicExponent (e)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e)),\n        // privateExponent (d)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.d)),\n        // privateKeyPrime1 (p)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.p)),\n        // privateKeyPrime2 (q)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.q)),\n        // privateKeyExponent1 (dP)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dP)),\n        // privateKeyExponent2 (dQ)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dQ)),\n        // coefficient (qInv)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.qInv))\n    ]);\n};\n/**\n * Converts a public key from an ASN.1 SubjectPublicKeyInfo or RSAPublicKey.\n *\n * @param obj the asn1 representation of a SubjectPublicKeyInfo or RSAPublicKey.\n *\n * @return the public key.\n */ pki.publicKeyFromAsn1 = function(obj) {\n    // get SubjectPublicKeyInfo\n    var capture = {};\n    var errors = [];\n    if (asn1.validate(obj, publicKeyValidator, capture, errors)) {\n        // get oid\n        var oid = asn1.derToOid(capture.publicKeyOid);\n        if (oid !== pki.oids.rsaEncryption) {\n            var error = new Error(\"Cannot read public key. Unknown OID.\");\n            error.oid = oid;\n            throw error;\n        }\n        obj = capture.rsaPublicKey;\n    }\n    // get RSA params\n    errors = [];\n    if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {\n        var error = new Error(\"Cannot read public key. \" + \"ASN.1 object does not contain an RSAPublicKey.\");\n        error.errors = errors;\n        throw error;\n    }\n    // FIXME: inefficient, get a BigInteger that uses byte strings\n    var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();\n    var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();\n    // set public key\n    return pki.setRsaPublicKey(new BigInteger(n, 16), new BigInteger(e, 16));\n};\n/**\n * Converts a public key to an ASN.1 SubjectPublicKeyInfo.\n *\n * @param key the public key.\n *\n * @return the asn1 representation of a SubjectPublicKeyInfo.\n */ pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {\n    // SubjectPublicKeyInfo\n    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // AlgorithmIdentifier\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // algorithm\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),\n            // parameters (null)\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n        ]),\n        // subjectPublicKey\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [\n            pki.publicKeyToRSAPublicKey(key)\n        ])\n    ]);\n};\n/**\n * Converts a public key to an ASN.1 RSAPublicKey.\n *\n * @param key the public key.\n *\n * @return the asn1 representation of a RSAPublicKey.\n */ pki.publicKeyToRSAPublicKey = function(key) {\n    // RSAPublicKey\n    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // modulus (n)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)),\n        // publicExponent (e)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e))\n    ]);\n};\n/**\n * Encodes a message using PKCS#1 v1.5 padding.\n *\n * @param m the message to encode.\n * @param key the RSA key to use.\n * @param bt the block type to use, i.e. either 0x01 (for signing) or 0x02\n *          (for encryption).\n *\n * @return the padded byte buffer.\n */ function _encodePkcs1_v1_5(m, key, bt) {\n    var eb = forge.util.createBuffer();\n    // get the length of the modulus in bytes\n    var k = Math.ceil(key.n.bitLength() / 8);\n    /* use PKCS#1 v1.5 padding */ if (m.length > k - 11) {\n        var error = new Error(\"Message is too long for PKCS#1 v1.5 padding.\");\n        error.length = m.length;\n        error.max = k - 11;\n        throw error;\n    }\n    /* A block type BT, a padding string PS, and the data D shall be\n    formatted into an octet string EB, the encryption block:\n\n    EB = 00 || BT || PS || 00 || D\n\n    The block type BT shall be a single octet indicating the structure of\n    the encryption block. For this version of the document it shall have\n    value 00, 01, or 02. For a private-key operation, the block type\n    shall be 00 or 01. For a public-key operation, it shall be 02.\n\n    The padding string PS shall consist of k-3-||D|| octets. For block\n    type 00, the octets shall have value 00; for block type 01, they\n    shall have value FF; and for block type 02, they shall be\n    pseudorandomly generated and nonzero. This makes the length of the\n    encryption block EB equal to k. */ // build the encryption block\n    eb.putByte(0x00);\n    eb.putByte(bt);\n    // create the padding\n    var padNum = k - 3 - m.length;\n    var padByte;\n    // private key op\n    if (bt === 0x00 || bt === 0x01) {\n        padByte = bt === 0x00 ? 0x00 : 0xFF;\n        for(var i = 0; i < padNum; ++i){\n            eb.putByte(padByte);\n        }\n    } else {\n        // public key op\n        // pad with random non-zero values\n        while(padNum > 0){\n            var numZeros = 0;\n            var padBytes = forge.random.getBytes(padNum);\n            for(var i = 0; i < padNum; ++i){\n                padByte = padBytes.charCodeAt(i);\n                if (padByte === 0) {\n                    ++numZeros;\n                } else {\n                    eb.putByte(padByte);\n                }\n            }\n            padNum = numZeros;\n        }\n    }\n    // zero followed by message\n    eb.putByte(0x00);\n    eb.putBytes(m);\n    return eb;\n}\n/**\n * Decodes a message using PKCS#1 v1.5 padding.\n *\n * @param em the message to decode.\n * @param key the RSA key to use.\n * @param pub true if the key is a public key, false if it is private.\n * @param ml the message length, if specified.\n *\n * @return the decoded bytes.\n */ function _decodePkcs1_v1_5(em, key, pub, ml) {\n    // get the length of the modulus in bytes\n    var k = Math.ceil(key.n.bitLength() / 8);\n    /* It is an error if any of the following conditions occurs:\n\n    1. The encryption block EB cannot be parsed unambiguously.\n    2. The padding string PS consists of fewer than eight octets\n      or is inconsisent with the block type BT.\n    3. The decryption process is a public-key operation and the block\n      type BT is not 00 or 01, or the decryption process is a\n      private-key operation and the block type is not 02.\n   */ // parse the encryption block\n    var eb = forge.util.createBuffer(em);\n    var first = eb.getByte();\n    var bt = eb.getByte();\n    if (first !== 0x00 || pub && bt !== 0x00 && bt !== 0x01 || !pub && bt != 0x02 || pub && bt === 0x00 && typeof ml === \"undefined\") {\n        throw new Error(\"Encryption block is invalid.\");\n    }\n    var padNum = 0;\n    if (bt === 0x00) {\n        // check all padding bytes for 0x00\n        padNum = k - 3 - ml;\n        for(var i = 0; i < padNum; ++i){\n            if (eb.getByte() !== 0x00) {\n                throw new Error(\"Encryption block is invalid.\");\n            }\n        }\n    } else if (bt === 0x01) {\n        // find the first byte that isn't 0xFF, should be after all padding\n        padNum = 0;\n        while(eb.length() > 1){\n            if (eb.getByte() !== 0xFF) {\n                --eb.read;\n                break;\n            }\n            ++padNum;\n        }\n    } else if (bt === 0x02) {\n        // look for 0x00 byte\n        padNum = 0;\n        while(eb.length() > 1){\n            if (eb.getByte() === 0x00) {\n                --eb.read;\n                break;\n            }\n            ++padNum;\n        }\n    }\n    // zero must be 0x00 and padNum must be (k - 3 - message length)\n    var zero = eb.getByte();\n    if (zero !== 0x00 || padNum !== k - 3 - eb.length()) {\n        throw new Error(\"Encryption block is invalid.\");\n    }\n    return eb.getBytes();\n}\n/**\n * Runs the key-generation algorithm asynchronously, either in the background\n * via Web Workers, or using the main thread and setImmediate.\n *\n * @param state the key-pair generation state.\n * @param [options] options for key-pair generation:\n *          workerScript the worker script URL.\n *          workers the number of web workers (if supported) to use,\n *            (default: 2, -1 to use estimated cores minus one).\n *          workLoad the size of the work load, ie: number of possible prime\n *            numbers for each web worker to check per work assignment,\n *            (default: 100).\n * @param callback(err, keypair) called once the operation completes.\n */ function _generateKeyPair(state, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    options = options || {};\n    var opts = {\n        algorithm: {\n            name: options.algorithm || \"PRIMEINC\",\n            options: {\n                workers: options.workers || 2,\n                workLoad: options.workLoad || 100,\n                workerScript: options.workerScript\n            }\n        }\n    };\n    if (\"prng\" in options) {\n        opts.prng = options.prng;\n    }\n    generate();\n    function generate() {\n        // find p and then q (done in series to simplify)\n        getPrime(state.pBits, function(err, num) {\n            if (err) {\n                return callback(err);\n            }\n            state.p = num;\n            if (state.q !== null) {\n                return finish(err, state.q);\n            }\n            getPrime(state.qBits, finish);\n        });\n    }\n    function getPrime(bits, callback) {\n        forge.prime.generateProbablePrime(bits, opts, callback);\n    }\n    function finish(err, num) {\n        if (err) {\n            return callback(err);\n        }\n        // set q\n        state.q = num;\n        // ensure p is larger than q (swap them if not)\n        if (state.p.compareTo(state.q) < 0) {\n            var tmp = state.p;\n            state.p = state.q;\n            state.q = tmp;\n        }\n        // ensure p is coprime with e\n        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {\n            state.p = null;\n            generate();\n            return;\n        }\n        // ensure q is coprime with e\n        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {\n            state.q = null;\n            getPrime(state.qBits, finish);\n            return;\n        }\n        // compute phi: (p - 1)(q - 1) (Euler's totient function)\n        state.p1 = state.p.subtract(BigInteger.ONE);\n        state.q1 = state.q.subtract(BigInteger.ONE);\n        state.phi = state.p1.multiply(state.q1);\n        // ensure e and phi are coprime\n        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {\n            // phi and e aren't coprime, so generate a new p and q\n            state.p = state.q = null;\n            generate();\n            return;\n        }\n        // create n, ensure n is has the right number of bits\n        state.n = state.p.multiply(state.q);\n        if (state.n.bitLength() !== state.bits) {\n            // failed, get new q\n            state.q = null;\n            getPrime(state.qBits, finish);\n            return;\n        }\n        // set keys\n        var d = state.e.modInverse(state.phi);\n        state.keys = {\n            privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),\n            publicKey: pki.rsa.setPublicKey(state.n, state.e)\n        };\n        callback(null, state.keys);\n    }\n}\n/**\n * Converts a positive BigInteger into 2's-complement big-endian bytes.\n *\n * @param b the big integer to convert.\n *\n * @return the bytes.\n */ function _bnToBytes(b) {\n    // prepend 0x00 if first byte >= 0x80\n    var hex = b.toString(16);\n    if (hex[0] >= \"8\") {\n        hex = \"00\" + hex;\n    }\n    var bytes = forge.util.hexToBytes(hex);\n    // ensure integer is minimally-encoded\n    if (bytes.length > 1 && // leading 0x00 for positive integer\n    (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 0x80) === 0 || // leading 0xFF for negative integer\n    bytes.charCodeAt(0) === 0xFF && (bytes.charCodeAt(1) & 0x80) === 0x80)) {\n        return bytes.substr(1);\n    }\n    return bytes;\n}\n/**\n * Returns the required number of Miller-Rabin tests to generate a\n * prime with an error probability of (1/2)^80.\n *\n * See Handbook of Applied Cryptography Chapter 4, Table 4.4.\n *\n * @param bits the bit size.\n *\n * @return the required number of iterations.\n */ function _getMillerRabinTests(bits) {\n    if (bits <= 100) return 27;\n    if (bits <= 150) return 18;\n    if (bits <= 200) return 15;\n    if (bits <= 250) return 12;\n    if (bits <= 300) return 9;\n    if (bits <= 350) return 8;\n    if (bits <= 400) return 7;\n    if (bits <= 500) return 6;\n    if (bits <= 600) return 5;\n    if (bits <= 800) return 4;\n    if (bits <= 1250) return 3;\n    return 2;\n}\n/**\n * Performs feature detection on the Node crypto interface.\n *\n * @param fn the feature (function) to detect.\n *\n * @return true if detected, false if not.\n */ function _detectNodeCrypto(fn) {\n    return forge.util.isNodejs && typeof _crypto[fn] === \"function\";\n}\n/**\n * Performs feature detection on the SubtleCrypto interface.\n *\n * @param fn the feature (function) to detect.\n *\n * @return true if detected, false if not.\n */ function _detectSubtleCrypto(fn) {\n    return typeof util.globalScope !== \"undefined\" && typeof util.globalScope.crypto === \"object\" && typeof util.globalScope.crypto.subtle === \"object\" && typeof util.globalScope.crypto.subtle[fn] === \"function\";\n}\n/**\n * Performs feature detection on the deprecated Microsoft Internet Explorer\n * outdated SubtleCrypto interface. This function should only be used after\n * checking for the modern, standard SubtleCrypto interface.\n *\n * @param fn the feature (function) to detect.\n *\n * @return true if detected, false if not.\n */ function _detectSubtleMsCrypto(fn) {\n    return typeof util.globalScope !== \"undefined\" && typeof util.globalScope.msCrypto === \"object\" && typeof util.globalScope.msCrypto.subtle === \"object\" && typeof util.globalScope.msCrypto.subtle[fn] === \"function\";\n}\nfunction _intToUint8Array(x) {\n    var bytes = forge.util.hexToBytes(x.toString(16));\n    var buffer = new Uint8Array(bytes.length);\n    for(var i = 0; i < bytes.length; ++i){\n        buffer[i] = bytes.charCodeAt(i);\n    }\n    return buffer;\n}\nfunction _privateKeyFromJwk(jwk) {\n    if (jwk.kty !== \"RSA\") {\n        throw new Error('Unsupported key algorithm \"' + jwk.kty + '\"; algorithm must be \"RSA\".');\n    }\n    return pki.setRsaPrivateKey(_base64ToBigInt(jwk.n), _base64ToBigInt(jwk.e), _base64ToBigInt(jwk.d), _base64ToBigInt(jwk.p), _base64ToBigInt(jwk.q), _base64ToBigInt(jwk.dp), _base64ToBigInt(jwk.dq), _base64ToBigInt(jwk.qi));\n}\nfunction _publicKeyFromJwk(jwk) {\n    if (jwk.kty !== \"RSA\") {\n        throw new Error('Key algorithm must be \"RSA\".');\n    }\n    return pki.setRsaPublicKey(_base64ToBigInt(jwk.n), _base64ToBigInt(jwk.e));\n}\nfunction _base64ToBigInt(b64) {\n    return new BigInteger(forge.util.bytesToHex(forge.util.decode64(b64)), 16);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcnNhLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQThEQztBQUNELElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUVSLElBQUcsT0FBT0MsZUFBZSxhQUFhO0lBQ3BDLElBQUlBLGFBQWFGLE1BQU1HLElBQUksQ0FBQ0QsVUFBVTtBQUN4QztBQUVBLElBQUlFLFVBQVVKLE1BQU1LLElBQUksQ0FBQ0MsUUFBUSxHQUFHTCxtQkFBT0EsQ0FBQywwQkFBWTtBQUV4RCx5QkFBeUI7QUFDekIsSUFBSU0sT0FBT1AsTUFBTU8sSUFBSTtBQUVyQix3QkFBd0I7QUFDeEIsSUFBSUYsT0FBT0wsTUFBTUssSUFBSTtBQUVyQjs7Q0FFQyxHQUNETCxNQUFNUSxHQUFHLEdBQUdSLE1BQU1RLEdBQUcsSUFBSSxDQUFDO0FBQzFCQyxPQUFPQyxPQUFPLEdBQUdWLE1BQU1RLEdBQUcsQ0FBQ0csR0FBRyxHQUFHWCxNQUFNVyxHQUFHLEdBQUdYLE1BQU1XLEdBQUcsSUFBSSxDQUFDO0FBQzNELElBQUlILE1BQU1SLE1BQU1RLEdBQUc7QUFFbkIsMkVBQTJFO0FBQzNFLElBQUlJLGVBQWU7SUFBQztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0NBQUU7QUFFM0MsMkNBQTJDO0FBQzNDLElBQUlDLHNCQUFzQjtJQUN4QixpQkFBaUI7SUFDakJDLE1BQU07SUFDTkMsVUFBVVIsS0FBS1MsS0FBSyxDQUFDQyxTQUFTO0lBQzlCQyxNQUFNWCxLQUFLWSxJQUFJLENBQUNDLFFBQVE7SUFDeEJDLGFBQWE7SUFDYkMsT0FBTztRQUFDO1lBQ04sb0JBQW9CO1lBQ3BCUixNQUFNO1lBQ05DLFVBQVVSLEtBQUtTLEtBQUssQ0FBQ0MsU0FBUztZQUM5QkMsTUFBTVgsS0FBS1ksSUFBSSxDQUFDSSxPQUFPO1lBQ3ZCRixhQUFhO1lBQ2JHLFNBQVM7UUFDWDtRQUFHO1lBQ0Qsc0JBQXNCO1lBQ3RCVixNQUFNO1lBQ05DLFVBQVVSLEtBQUtTLEtBQUssQ0FBQ0MsU0FBUztZQUM5QkMsTUFBTVgsS0FBS1ksSUFBSSxDQUFDQyxRQUFRO1lBQ3hCQyxhQUFhO1lBQ2JDLE9BQU87Z0JBQUM7b0JBQ05SLE1BQU07b0JBQ05DLFVBQVVSLEtBQUtTLEtBQUssQ0FBQ0MsU0FBUztvQkFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ00sR0FBRztvQkFDbkJKLGFBQWE7b0JBQ2JHLFNBQVM7Z0JBQ1g7YUFBRTtRQUNKO1FBQUc7WUFDRCxhQUFhO1lBQ2JWLE1BQU07WUFDTkMsVUFBVVIsS0FBS1MsS0FBSyxDQUFDQyxTQUFTO1lBQzlCQyxNQUFNWCxLQUFLWSxJQUFJLENBQUNPLFdBQVc7WUFDM0JMLGFBQWE7WUFDYkcsU0FBUztRQUNYO0tBQUU7QUFDSjtBQUVBLG1DQUFtQztBQUNuQyxJQUFJRyx5QkFBeUI7SUFDM0IsZ0JBQWdCO0lBQ2hCYixNQUFNO0lBQ05DLFVBQVVSLEtBQUtTLEtBQUssQ0FBQ0MsU0FBUztJQUM5QkMsTUFBTVgsS0FBS1ksSUFBSSxDQUFDQyxRQUFRO0lBQ3hCQyxhQUFhO0lBQ2JDLE9BQU87UUFBQztZQUNOLG9CQUFvQjtZQUNwQlIsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0ksT0FBTztZQUN2QkYsYUFBYTtZQUNiRyxTQUFTO1FBQ1g7UUFBRztZQUNELGNBQWM7WUFDZFYsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0ksT0FBTztZQUN2QkYsYUFBYTtZQUNiRyxTQUFTO1FBQ1g7UUFBRztZQUNELHFCQUFxQjtZQUNyQlYsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0ksT0FBTztZQUN2QkYsYUFBYTtZQUNiRyxTQUFTO1FBQ1g7UUFBRztZQUNELHNCQUFzQjtZQUN0QlYsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0ksT0FBTztZQUN2QkYsYUFBYTtZQUNiRyxTQUFTO1FBQ1g7UUFBRztZQUNELGFBQWE7WUFDYlYsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0ksT0FBTztZQUN2QkYsYUFBYTtZQUNiRyxTQUFTO1FBQ1g7UUFBRztZQUNELGFBQWE7WUFDYlYsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0ksT0FBTztZQUN2QkYsYUFBYTtZQUNiRyxTQUFTO1FBQ1g7UUFBRztZQUNELDBCQUEwQjtZQUMxQlYsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0ksT0FBTztZQUN2QkYsYUFBYTtZQUNiRyxTQUFTO1FBQ1g7UUFBRztZQUNELDBCQUEwQjtZQUMxQlYsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0ksT0FBTztZQUN2QkYsYUFBYTtZQUNiRyxTQUFTO1FBQ1g7UUFBRztZQUNELHFDQUFxQztZQUNyQ1YsTUFBTTtZQUNOQyxVQUFVUixLQUFLUyxLQUFLLENBQUNDLFNBQVM7WUFDOUJDLE1BQU1YLEtBQUtZLElBQUksQ0FBQ0ksT0FBTztZQUN2QkYsYUFBYTtZQUNiRyxTQUFT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TztRQUNwQixNQUFNLElBQUloTyxNQUNSLGdDQUFnQytOLElBQUlDLEdBQUcsR0FBRztJQUM5QztJQUNBLE9BQU9qUSxJQUFJME0sZ0JBQWdCLENBQ3pCd0QsZ0JBQWdCRixJQUFJL00sQ0FBQyxHQUNyQmlOLGdCQUFnQkYsSUFBSWhOLENBQUMsR0FDckJrTixnQkFBZ0JGLElBQUk1TSxDQUFDLEdBQ3JCOE0sZ0JBQWdCRixJQUFJOU0sQ0FBQyxHQUNyQmdOLGdCQUFnQkYsSUFBSTdNLENBQUMsR0FDckIrTSxnQkFBZ0JGLElBQUlHLEVBQUUsR0FDdEJELGdCQUFnQkYsSUFBSUksRUFBRSxHQUN0QkYsZ0JBQWdCRixJQUFJSyxFQUFFO0FBQzFCO0FBRUEsU0FBU0Msa0JBQWtCTixHQUFHO0lBQzVCLElBQUdBLElBQUlDLEdBQUcsS0FBSyxPQUFPO1FBQ3BCLE1BQU0sSUFBSWhPLE1BQU07SUFDbEI7SUFDQSxPQUFPakMsSUFBSXNLLGVBQWUsQ0FDeEI0RixnQkFBZ0JGLElBQUkvTSxDQUFDLEdBQ3JCaU4sZ0JBQWdCRixJQUFJaE4sQ0FBQztBQUN6QjtBQUVBLFNBQVNrTixnQkFBZ0JLLEdBQUc7SUFDMUIsT0FBTyxJQUFJN1EsV0FBV0YsTUFBTUssSUFBSSxDQUFDZ0UsVUFBVSxDQUFDckUsTUFBTUssSUFBSSxDQUFDMlEsUUFBUSxDQUFDRCxPQUFPO0FBQ3pFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3JzYS5qcz8xOGExIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBiYXNpYyBSU0EgYWxnb3JpdGhtcy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKlxuICogVGhlIG9ubHkgYWxnb3JpdGhtIGN1cnJlbnRseSBzdXBwb3J0ZWQgZm9yIFBLSSBpcyBSU0EuXG4gKlxuICogQW4gUlNBIGtleSBpcyBvZnRlbiBzdG9yZWQgaW4gQVNOLjEgREVSIGZvcm1hdC4gVGhlIFN1YmplY3RQdWJsaWNLZXlJbmZvXG4gKiBBU04uMSBzdHJ1Y3R1cmUgaXMgY29tcG9zZWQgb2YgYW4gYWxnb3JpdGhtIG9mIHR5cGUgQWxnb3JpdGhtSWRlbnRpZmllclxuICogYW5kIGEgc3ViamVjdFB1YmxpY0tleSBvZiB0eXBlIGJpdCBzdHJpbmcuXG4gKlxuICogVGhlIEFsZ29yaXRobUlkZW50aWZpZXIgY29udGFpbnMgYW4gT2JqZWN0IElkZW50aWZpZXIgKE9JRCkgYW5kIHBhcmFtZXRlcnNcbiAqIGZvciB0aGUgYWxnb3JpdGhtLCBpZiBhbnkuIEluIHRoZSBjYXNlIG9mIFJTQSwgdGhlcmUgYXJlbid0IGFueS5cbiAqXG4gKiBTdWJqZWN0UHVibGljS2V5SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBhbGdvcml0aG0gQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgc3ViamVjdFB1YmxpY0tleSBCSVQgU1RSSU5HXG4gKiB9XG4gKlxuICogQWxnb3JpdGhtSWRlbnRpZmVyIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGFsZ29yaXRobSBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgcGFyYW1ldGVycyBBTlkgREVGSU5FRCBCWSBhbGdvcml0aG0gT1BUSU9OQUxcbiAqIH1cbiAqXG4gKiBGb3IgYW4gUlNBIHB1YmxpYyBrZXksIHRoZSBzdWJqZWN0UHVibGljS2V5IGlzOlxuICpcbiAqIFJTQVB1YmxpY0tleSA6Oj0gU0VRVUVOQ0Uge1xuICogICBtb2R1bHVzICAgICAgICAgICAgSU5URUdFUiwgICAgLS0gblxuICogICBwdWJsaWNFeHBvbmVudCAgICAgSU5URUdFUiAgICAgLS0gZVxuICogfVxuICpcbiAqIFByaXZhdGVLZXlJbmZvIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gICAgICAgICAgICAgICAgICAgVmVyc2lvbixcbiAqICAgcHJpdmF0ZUtleUFsZ29yaXRobSAgICAgICBQcml2YXRlS2V5QWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgcHJpdmF0ZUtleSAgICAgICAgICAgICAgICBQcml2YXRlS2V5LFxuICogICBhdHRyaWJ1dGVzICAgICAgICAgICBbMF0gIElNUExJQ0lUIEF0dHJpYnV0ZXMgT1BUSU9OQUxcbiAqIH1cbiAqXG4gKiBWZXJzaW9uIDo6PSBJTlRFR0VSXG4gKiBQcml2YXRlS2V5QWxnb3JpdGhtSWRlbnRpZmllciA6Oj0gQWxnb3JpdGhtSWRlbnRpZmllclxuICogUHJpdmF0ZUtleSA6Oj0gT0NURVQgU1RSSU5HXG4gKiBBdHRyaWJ1dGVzIDo6PSBTRVQgT0YgQXR0cmlidXRlXG4gKlxuICogQW4gUlNBIHByaXZhdGUga2V5IGFzIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxuICpcbiAqIFJTQVByaXZhdGVLZXkgOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiBWZXJzaW9uLFxuICogICBtb2R1bHVzIElOVEVHRVIsIC0tIG5cbiAqICAgcHVibGljRXhwb25lbnQgSU5URUdFUiwgLS0gZVxuICogICBwcml2YXRlRXhwb25lbnQgSU5URUdFUiwgLS0gZFxuICogICBwcmltZTEgSU5URUdFUiwgLS0gcFxuICogICBwcmltZTIgSU5URUdFUiwgLS0gcVxuICogICBleHBvbmVudDEgSU5URUdFUiwgLS0gZCBtb2QgKHAtMSlcbiAqICAgZXhwb25lbnQyIElOVEVHRVIsIC0tIGQgbW9kIChxLTEpXG4gKiAgIGNvZWZmaWNpZW50IElOVEVHRVIgLS0gKGludmVyc2Ugb2YgcSkgbW9kIHBcbiAqIH1cbiAqXG4gKiBWZXJzaW9uIDo6PSBJTlRFR0VSXG4gKlxuICogVGhlIE9JRCBmb3IgdGhlIFJTQSBrZXkgYWxnb3JpdGhtIGlzOiAxLjIuODQwLjExMzU0OS4xLjEuMVxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL2FzbjEnKTtcbnJlcXVpcmUoJy4vanNibicpO1xucmVxdWlyZSgnLi9vaWRzJyk7XG5yZXF1aXJlKCcuL3BrY3MxJyk7XG5yZXF1aXJlKCcuL3ByaW1lJyk7XG5yZXF1aXJlKCcuL3JhbmRvbScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbmlmKHR5cGVvZiBCaWdJbnRlZ2VyID09PSAndW5kZWZpbmVkJykge1xuICB2YXIgQmlnSW50ZWdlciA9IGZvcmdlLmpzYm4uQmlnSW50ZWdlcjtcbn1cblxudmFyIF9jcnlwdG8gPSBmb3JnZS51dGlsLmlzTm9kZWpzID8gcmVxdWlyZSgnY3J5cHRvJykgOiBudWxsO1xuXG4vLyBzaG9ydGN1dCBmb3IgYXNuLjEgQVBJXG52YXIgYXNuMSA9IGZvcmdlLmFzbjE7XG5cbi8vIHNob3J0Y3V0IGZvciB1dGlsIEFQSVxudmFyIHV0aWwgPSBmb3JnZS51dGlsO1xuXG4vKlxuICogUlNBIGVuY3J5cHRpb24gYW5kIGRlY3J5cHRpb24sIHNlZSBSRkMgMjMxMy5cbiAqL1xuZm9yZ2UucGtpID0gZm9yZ2UucGtpIHx8IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wa2kucnNhID0gZm9yZ2UucnNhID0gZm9yZ2UucnNhIHx8IHt9O1xudmFyIHBraSA9IGZvcmdlLnBraTtcblxuLy8gZm9yIGZpbmRpbmcgcHJpbWVzLCB3aGljaCBhcmUgMzBrK2kgZm9yIGkgPSAxLCA3LCAxMSwgMTMsIDE3LCAxOSwgMjMsIDI5XG52YXIgR0NEXzMwX0RFTFRBID0gWzYsIDQsIDIsIDQsIDIsIDQsIDYsIDJdO1xuXG4vLyB2YWxpZGF0b3IgZm9yIGEgUHJpdmF0ZUtleUluZm8gc3RydWN0dXJlXG52YXIgcHJpdmF0ZUtleVZhbGlkYXRvciA9IHtcbiAgLy8gUHJpdmF0ZUtleUluZm9cbiAgbmFtZTogJ1ByaXZhdGVLZXlJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICAvLyBWZXJzaW9uIChJTlRFR0VSKVxuICAgIG5hbWU6ICdQcml2YXRlS2V5SW5mby52ZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5VmVyc2lvbidcbiAgfSwge1xuICAgIC8vIHByaXZhdGVLZXlBbGdvcml0aG1cbiAgICBuYW1lOiAnUHJpdmF0ZUtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdBbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlPaWQnXG4gICAgfV1cbiAgfSwge1xuICAgIC8vIFByaXZhdGVLZXlcbiAgICBuYW1lOiAnUHJpdmF0ZUtleUluZm8nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5J1xuICB9XVxufTtcblxuLy8gdmFsaWRhdG9yIGZvciBhbiBSU0EgcHJpdmF0ZSBrZXlcbnZhciByc2FQcml2YXRlS2V5VmFsaWRhdG9yID0ge1xuICAvLyBSU0FQcml2YXRlS2V5XG4gIG5hbWU6ICdSU0FQcml2YXRlS2V5JyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICAvLyBWZXJzaW9uIChJTlRFR0VSKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LnZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlWZXJzaW9uJ1xuICB9LCB7XG4gICAgLy8gbW9kdWx1cyAobilcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5tb2R1bHVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5TW9kdWx1cydcbiAgfSwge1xuICAgIC8vIHB1YmxpY0V4cG9uZW50IChlKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LnB1YmxpY0V4cG9uZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5UHVibGljRXhwb25lbnQnXG4gIH0sIHtcbiAgICAvLyBwcml2YXRlRXhwb25lbnQgKGQpXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkucHJpdmF0ZUV4cG9uZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5UHJpdmF0ZUV4cG9uZW50J1xuICB9LCB7XG4gICAgLy8gcHJpbWUxIChwKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LnByaW1lMScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleVByaW1lMSdcbiAgfSwge1xuICAgIC8vIHByaW1lMiAocSlcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5wcmltZTInLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlQcmltZTInXG4gIH0sIHtcbiAgICAvLyBleHBvbmVudDEgKGQgbW9kIChwLTEpKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LmV4cG9uZW50MScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleUV4cG9uZW50MSdcbiAgfSwge1xuICAgIC8vIGV4cG9uZW50MiAoZCBtb2QgKHEtMSkpXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkuZXhwb25lbnQyJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5RXhwb25lbnQyJ1xuICB9LCB7XG4gICAgLy8gY29lZmZpY2llbnQgKChpbnZlcnNlIG9mIHEpIG1vZCBwKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LmNvZWZmaWNpZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5Q29lZmZpY2llbnQnXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIFJTQSBwdWJsaWMga2V5XG52YXIgcnNhUHVibGljS2V5VmFsaWRhdG9yID0ge1xuICAvLyBSU0FQdWJsaWNLZXlcbiAgbmFtZTogJ1JTQVB1YmxpY0tleScsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgLy8gbW9kdWx1cyAobilcbiAgICBuYW1lOiAnUlNBUHVibGljS2V5Lm1vZHVsdXMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3B1YmxpY0tleU1vZHVsdXMnXG4gIH0sIHtcbiAgICAvLyBwdWJsaWNFeHBvbmVudCAoZSlcbiAgICBuYW1lOiAnUlNBUHVibGljS2V5LmV4cG9uZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwdWJsaWNLZXlFeHBvbmVudCdcbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYW4gU3ViamVjdFB1YmxpY0tleUluZm8gc3RydWN0dXJlXG4vLyBOb3RlOiBDdXJyZW50bHkgb25seSB3b3JrcyB3aXRoIGFuIFJTQSBwdWJsaWMga2V5XG52YXIgcHVibGljS2V5VmFsaWRhdG9yID0gZm9yZ2UucGtpLnJzYS5wdWJsaWNLZXlWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdTdWJqZWN0UHVibGljS2V5SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgY2FwdHVyZUFzbjE6ICdzdWJqZWN0UHVibGljS2V5SW5mbycsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdTdWJqZWN0UHVibGljS2V5SW5mby5BbGdvcml0aG1JZGVudGlmaWVyJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ0FsZ29yaXRobUlkZW50aWZpZXIuYWxnb3JpdGhtJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAncHVibGljS2V5T2lkJ1xuICAgIH1dXG4gIH0sIHtcbiAgICAvLyBzdWJqZWN0UHVibGljS2V5XG4gICAgbmFtZTogJ1N1YmplY3RQdWJsaWNLZXlJbmZvLnN1YmplY3RQdWJsaWNLZXknLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuQklUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIC8vIFJTQVB1YmxpY0tleVxuICAgICAgbmFtZTogJ1N1YmplY3RQdWJsaWNLZXlJbmZvLnN1YmplY3RQdWJsaWNLZXkuUlNBUHVibGljS2V5JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ3JzYVB1YmxpY0tleSdcbiAgICB9XVxuICB9XVxufTtcblxuLy8gdmFsaWRhdG9yIGZvciBhIERpZ2VzdEluZm8gc3RydWN0dXJlXG52YXIgZGlnZXN0SW5mb1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0RpZ2VzdEluZm8nLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdEaWdlc3RJbmZvLkRpZ2VzdEFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdEaWdlc3RJbmZvLkRpZ2VzdEFsZ29yaXRobS5hbGdvcml0aG1JZGVudGlmaWVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnYWxnb3JpdGhtSWRlbnRpZmllcidcbiAgICB9LCB7XG4gICAgICAvLyBOVUxMIHBhcmFtdGVyc1xuICAgICAgbmFtZTogJ0RpZ2VzdEluZm8uRGlnZXN0QWxnb3JpdGhtLnBhcmFtZXRlcnMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk5VTEwsXG4gICAgICAvLyBjYXB0dXJlZCBvbmx5IHRvIGNoZWNrIGV4aXN0ZW5jZSBmb3IgbWQyIGFuZCBtZDVcbiAgICAgIGNhcHR1cmU6ICdwYXJhbWV0ZXJzJyxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlXG4gICAgfV1cbiAgfSwge1xuICAgIC8vIGRpZ2VzdFxuICAgIG5hbWU6ICdEaWdlc3RJbmZvLmRpZ2VzdCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2RpZ2VzdCdcbiAgfV1cbn07XG5cbi8qKlxuICogV3JhcCBkaWdlc3QgaW4gRGlnZXN0SW5mbyBvYmplY3QuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIEVNU0EtUEtDUzEtdjFfNS1FTkNPREUgYXMgcGVyIFJGQyAzNDQ3LlxuICpcbiAqIERpZ2VzdEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgZGlnZXN0QWxnb3JpdGhtIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGRpZ2VzdCBEaWdlc3RcbiAqIH1cbiAqXG4gKiBEaWdlc3RBbGdvcml0aG1JZGVudGlmaWVyIDo6PSBBbGdvcml0aG1JZGVudGlmaWVyXG4gKiBEaWdlc3QgOjo9IE9DVEVUIFNUUklOR1xuICpcbiAqIEBwYXJhbSBtZCB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHdpdGggdGhlIGhhc2ggdG8gc2lnbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBlbmNvZGVkIG1lc3NhZ2UgKHJlYWR5IGZvciBSU0EgZW5jcnl0aW9uKVxuICovXG52YXIgZW1zYVBrY3MxdjE1ZW5jb2RlID0gZnVuY3Rpb24obWQpIHtcbiAgLy8gZ2V0IHRoZSBvaWQgZm9yIHRoZSBhbGdvcml0aG1cbiAgdmFyIG9pZDtcbiAgaWYobWQuYWxnb3JpdGhtIGluIHBraS5vaWRzKSB7XG4gICAgb2lkID0gcGtpLm9pZHNbbWQuYWxnb3JpdGhtXTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vua25vd24gbWVzc2FnZSBkaWdlc3QgYWxnb3JpdGhtLicpO1xuICAgIGVycm9yLmFsZ29yaXRobSA9IG1kLmFsZ29yaXRobTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICB2YXIgb2lkQnl0ZXMgPSBhc24xLm9pZFRvRGVyKG9pZCkuZ2V0Qnl0ZXMoKTtcblxuICAvLyBjcmVhdGUgdGhlIGRpZ2VzdCBpbmZvXG4gIHZhciBkaWdlc3RJbmZvID0gYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuICB2YXIgZGlnZXN0QWxnb3JpdGhtID0gYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuICBkaWdlc3RBbGdvcml0aG0udmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsIG9pZEJ5dGVzKSk7XG4gIGRpZ2VzdEFsZ29yaXRobS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKFxuICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKSk7XG4gIHZhciBkaWdlc3QgPSBhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGZhbHNlLCBtZC5kaWdlc3QoKS5nZXRCeXRlcygpKTtcbiAgZGlnZXN0SW5mby52YWx1ZS5wdXNoKGRpZ2VzdEFsZ29yaXRobSk7XG4gIGRpZ2VzdEluZm8udmFsdWUucHVzaChkaWdlc3QpO1xuXG4gIC8vIGVuY29kZSBkaWdlc3QgaW5mb1xuICByZXR1cm4gYXNuMS50b0RlcihkaWdlc3RJbmZvKS5nZXRCeXRlcygpO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyB4XmMgbW9kIG4gKFJTQSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gb3BlcmF0aW9uKS5cbiAqXG4gKiBAcGFyYW0geCB0aGUgbnVtYmVyIHRvIHJhaXNlIGFuZCBtb2QuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdXNlLlxuICogQHBhcmFtIHB1YiB0cnVlIGlmIHRoZSBrZXkgaXMgcHVibGljLCBmYWxzZSBpZiBwcml2YXRlLlxuICpcbiAqIEByZXR1cm4gdGhlIHJlc3VsdCBvZiB4XmMgbW9kIG4uXG4gKi9cbnZhciBfbW9kUG93ID0gZnVuY3Rpb24oeCwga2V5LCBwdWIpIHtcbiAgaWYocHViKSB7XG4gICAgcmV0dXJuIHgubW9kUG93KGtleS5lLCBrZXkubik7XG4gIH1cblxuICBpZigha2V5LnAgfHwgIWtleS5xKSB7XG4gICAgLy8gYWxsb3cgY2FsY3VsYXRpb24gd2l0aG91dCBDUlQgcGFyYW1zIChzbG93KVxuICAgIHJldHVybiB4Lm1vZFBvdyhrZXkuZCwga2V5Lm4pO1xuICB9XG5cbiAgLy8gcHJlLWNvbXB1dGUgZFAsIGRRLCBhbmQgcUludiBpZiBuZWNlc3NhcnlcbiAgaWYoIWtleS5kUCkge1xuICAgIGtleS5kUCA9IGtleS5kLm1vZChrZXkucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkpO1xuICB9XG4gIGlmKCFrZXkuZFEpIHtcbiAgICBrZXkuZFEgPSBrZXkuZC5tb2Qoa2V5LnEuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpKTtcbiAgfVxuICBpZigha2V5LnFJbnYpIHtcbiAgICBrZXkucUludiA9IGtleS5xLm1vZEludmVyc2Uoa2V5LnApO1xuICB9XG5cbiAgLyogQ2hpbmVzZSByZW1haW5kZXIgdGhlb3JlbSAoQ1JUKSBzdGF0ZXM6XG5cbiAgICBTdXBwb3NlIG4xLCBuMiwgLi4uLCBuayBhcmUgcG9zaXRpdmUgaW50ZWdlcnMgd2hpY2ggYXJlIHBhaXJ3aXNlXG4gICAgY29wcmltZSAobjEgYW5kIG4yIGhhdmUgbm8gY29tbW9uIGZhY3RvcnMgb3RoZXIgdGhhbiAxKS4gRm9yIGFueVxuICAgIGludGVnZXJzIHgxLCB4MiwgLi4uLCB4ayB0aGVyZSBleGlzdHMgYW4gaW50ZWdlciB4IHNvbHZpbmcgdGhlXG4gICAgc3lzdGVtIG9mIHNpbXVsdGFuZW91cyBjb25ncnVlbmNlcyAod2hlcmUgfj0gbWVhbnMgbW9kdWxhcmx5XG4gICAgY29uZ3J1ZW50IHNvIGEgfj0gYiBtb2QgbiBtZWFucyBhIG1vZCBuID0gYiBtb2Qgbik6XG5cbiAgICB4IH49IHgxIG1vZCBuMVxuICAgIHggfj0geDIgbW9kIG4yXG4gICAgLi4uXG4gICAgeCB+PSB4ayBtb2QgbmtcblxuICAgIFRoaXMgc3lzdGVtIG9mIGNvbmdydWVuY2VzIGhhcyBhIHNpbmdsZSBzaW11bHRhbmVvdXMgc29sdXRpb24geFxuICAgIGJldHdlZW4gMCBhbmQgbiAtIDEuIEZ1cnRoZXJtb3JlLCBlYWNoIHhrIHNvbHV0aW9uIGFuZCB4IGl0c2VsZlxuICAgIGlzIGNvbmdydWVudCBtb2R1bG8gdGhlIHByb2R1Y3QgbiA9IG4xKm4yKi4uLipuay5cbiAgICBTbyB4MSBtb2QgbiA9IHgyIG1vZCBuID0geGsgbW9kIG4gPSB4IG1vZCBuLlxuXG4gICAgVGhlIHNpbmdsZSBzaW11bHRhbmVvdXMgc29sdXRpb24geCBjYW4gYmUgc29sdmVkIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgIGVxdWF0aW9uOlxuXG4gICAgeCA9IHN1bSh4aSpyaSpzaSkgbW9kIG4gd2hlcmUgcmkgPSBuL25pIGFuZCBzaSA9IHJpXi0xIG1vZCBuaS5cblxuICAgIFdoZXJlIHggaXMgbGVzcyB0aGFuIG4sIHhpID0geCBtb2QgbmkuXG5cbiAgICBGb3IgUlNBIHdlIGFyZSBvbmx5IGNvbmNlcm5lZCB3aXRoIGsgPSAyLiBUaGUgbW9kdWx1cyBuID0gcHEsIHdoZXJlXG4gICAgcCBhbmQgcSBhcmUgY29wcmltZS4gVGhlIFJTQSBkZWNyeXB0aW9uIGFsZ29yaXRobSBpczpcblxuICAgIHkgPSB4XmQgbW9kIG5cblxuICAgIEdpdmVuIHRoZSBhYm92ZTpcblxuICAgIHgxID0geF5kIG1vZCBwXG4gICAgcjEgPSBuL3AgPSBxXG4gICAgczEgPSBxXi0xIG1vZCBwXG4gICAgeDIgPSB4XmQgbW9kIHFcbiAgICByMiA9IG4vcSA9IHBcbiAgICBzMiA9IHBeLTEgbW9kIHFcblxuICAgIFNvIHkgPSAoeDFyMXMxICsgeDJyMnMyKSBtb2QgblxuICAgICAgICAgPSAoKHheZCBtb2QgcClxKHFeLTEgbW9kIHApICsgKHheZCBtb2QgcSlwKHBeLTEgbW9kIHEpKSBtb2QgblxuXG4gICAgQWNjb3JkaW5nIHRvIEZlcm1hdCdzIExpdHRsZSBUaGVvcmVtLCBpZiB0aGUgbW9kdWx1cyBQIGlzIHByaW1lLFxuICAgIGZvciBhbnkgaW50ZWdlciBBIG5vdCBldmVubHkgZGl2aXNpYmxlIGJ5IFAsIEFeKFAtMSkgfj0gMSBtb2QgUC5cbiAgICBTaW5jZSBBIGlzIG5vdCBkaXZpc2libGUgYnkgUCBpdCBmb2xsb3dzIHRoYXQgaWY6XG4gICAgTiB+PSBNIG1vZCAoUCAtIDEpLCB0aGVuIEFeTiBtb2QgUCA9IEFeTSBtb2QgUC4gVGhlcmVmb3JlOlxuXG4gICAgQV5OIG1vZCBQID0gQV4oTSBtb2QgKFAgLSAxKSkgbW9kIFAuIChUaGUgbGF0dGVyIHRha2VzIGxlc3MgZWZmb3J0XG4gICAgdG8gY2FsY3VsYXRlKS4gSW4gb3JkZXIgdG8gY2FsY3VsYXRlIHheZCBtb2QgcCBtb3JlIHF1aWNrbHkgdGhlXG4gICAgZXhwb25lbnQgZCBtb2QgKHAgLSAxKSBpcyBzdG9yZWQgaW4gdGhlIFJTQSBwcml2YXRlIGtleSAodGhlIHNhbWVcbiAgICBpcyBkb25lIGZvciB4XmQgbW9kIHEpLiBUaGVzZSB2YWx1ZXMgYXJlIHJlZmVycmVkIHRvIGFzIGRQIGFuZCBkUVxuICAgIHJlc3BlY3RpdmVseS4gVGhlcmVmb3JlIHdlIG5vdyBoYXZlOlxuXG4gICAgeSA9ICgoeF5kUCBtb2QgcClxKHFeLTEgbW9kIHApICsgKHheZFEgbW9kIHEpcChwXi0xIG1vZCBxKSkgbW9kIG5cblxuICAgIFNpbmNlIHdlJ2xsIGJlIHJlZHVjaW5nIHheZFAgYnkgbW9kdWxvIHAgKHNhbWUgZm9yIHEpIHdlIGNhbiBhbHNvXG4gICAgcmVkdWNlIHggYnkgcCAoYW5kIHEgcmVzcGVjdGl2ZWx5KSBiZWZvcmUgaGFuZC4gVGhlcmVmb3JlLCBsZXRcblxuICAgIHhwID0gKCh4IG1vZCBwKV5kUCBtb2QgcCksIGFuZFxuICAgIHhxID0gKCh4IG1vZCBxKV5kUSBtb2QgcSksIHlpZWxkaW5nOlxuXG4gICAgeSA9ICh4cCpxKihxXi0xIG1vZCBwKSArIHhxKnAqKHBeLTEgbW9kIHEpKSBtb2QgblxuXG4gICAgVGhpcyBjYW4gYmUgZnVydGhlciByZWR1Y2VkIHRvIGEgc2ltcGxlIGFsZ29yaXRobSB0aGF0IG9ubHlcbiAgICByZXF1aXJlcyAxIGludmVyc2UgKHRoZSBxIGludmVyc2UgaXMgdXNlZCkgdG8gYmUgdXNlZCBhbmQgc3RvcmVkLlxuICAgIFRoZSBhbGdvcml0aG0gaXMgY2FsbGVkIEdhcm5lcidzIGFsZ29yaXRobS4gSWYgcUludiBpcyB0aGVcbiAgICBpbnZlcnNlIG9mIHEsIHdlIHNpbXBseSBjYWxjdWxhdGU6XG5cbiAgICB5ID0gKHFJbnYqKHhwIC0geHEpIG1vZCBwKSAqIHEgKyB4cVxuXG4gICAgSG93ZXZlciwgdGhlcmUgYXJlIHR3byBmdXJ0aGVyIGNvbXBsaWNhdGlvbnMuIEZpcnN0LCB3ZSBuZWVkIHRvXG4gICAgZW5zdXJlIHRoYXQgeHAgPiB4cSB0byBwcmV2ZW50IHNpZ25lZCBCaWdJbnRlZ2VycyBmcm9tIGJlaW5nIHVzZWRcbiAgICBzbyB3ZSBhZGQgcCB1bnRpbCB0aGlzIGlzIHRydWUgKHNpbmNlIHdlIHdpbGwgYmUgbW9kJ2luZyB3aXRoXG4gICAgcCBhbnl3YXkpLiBUaGVuLCB0aGVyZSBpcyBhIGtub3duIHRpbWluZyBhdHRhY2sgb24gYWxnb3JpdGhtc1xuICAgIHVzaW5nIHRoZSBDUlQuIFRvIG1pdGlnYXRlIHRoaXMgcmlzaywgXCJjcnlwdG9ncmFwaGljIGJsaW5kaW5nXCJcbiAgICBzaG91bGQgYmUgdXNlZC4gVGhpcyByZXF1aXJlcyBzaW1wbHkgZ2VuZXJhdGluZyBhIHJhbmRvbSBudW1iZXIgclxuICAgIGJldHdlZW4gMCBhbmQgbi0xIGFuZCBpdHMgaW52ZXJzZSBhbmQgbXVsdGlwbHlpbmcgeCBieSByXmUgYmVmb3JlXG4gICAgY2FsY3VsYXRpbmcgeSBhbmQgdGhlbiBtdWx0aXBseWluZyB5IGJ5IHJeLTEgYWZ0ZXJ3YXJkcy4gTm90ZSB0aGF0XG4gICAgciBtdXN0IGJlIGNvcHJpbWUgd2l0aCBuIChnY2QociwgbikgPT09IDEpIGluIG9yZGVyIHRvIGhhdmUgYW5cbiAgICBpbnZlcnNlLlxuICAqL1xuXG4gIC8vIGNyeXB0b2dyYXBoaWMgYmxpbmRpbmdcbiAgdmFyIHI7XG4gIGRvIHtcbiAgICByID0gbmV3IEJpZ0ludGVnZXIoXG4gICAgICBmb3JnZS51dGlsLmJ5dGVzVG9IZXgoZm9yZ2UucmFuZG9tLmdldEJ5dGVzKGtleS5uLmJpdExlbmd0aCgpIC8gOCkpLFxuICAgICAgMTYpO1xuICB9IHdoaWxlKHIuY29tcGFyZVRvKGtleS5uKSA+PSAwIHx8ICFyLmdjZChrZXkubikuZXF1YWxzKEJpZ0ludGVnZXIuT05FKSk7XG4gIHggPSB4Lm11bHRpcGx5KHIubW9kUG93KGtleS5lLCBrZXkubikpLm1vZChrZXkubik7XG5cbiAgLy8gY2FsY3VsYXRlIHhwIGFuZCB4cVxuICB2YXIgeHAgPSB4Lm1vZChrZXkucCkubW9kUG93KGtleS5kUCwga2V5LnApO1xuICB2YXIgeHEgPSB4Lm1vZChrZXkucSkubW9kUG93KGtleS5kUSwga2V5LnEpO1xuXG4gIC8vIHhwIG11c3QgYmUgbGFyZ2VyIHRoYW4geHEgdG8gYXZvaWQgc2lnbmVkIGJpdCB1c2FnZVxuICB3aGlsZSh4cC5jb21wYXJlVG8oeHEpIDwgMCkge1xuICAgIHhwID0geHAuYWRkKGtleS5wKTtcbiAgfVxuXG4gIC8vIGRvIGxhc3Qgc3RlcFxuICB2YXIgeSA9IHhwLnN1YnRyYWN0KHhxKVxuICAgIC5tdWx0aXBseShrZXkucUludikubW9kKGtleS5wKVxuICAgIC5tdWx0aXBseShrZXkucSkuYWRkKHhxKTtcblxuICAvLyByZW1vdmUgZWZmZWN0IG9mIHJhbmRvbSBmb3IgY3J5cHRvZ3JhcGhpYyBibGluZGluZ1xuICB5ID0geS5tdWx0aXBseShyLm1vZEludmVyc2Uoa2V5Lm4pKS5tb2Qoa2V5Lm4pO1xuXG4gIHJldHVybiB5O1xufTtcblxuLyoqXG4gKiBOT1RFOiBUSElTIE1FVEhPRCBJUyBERVBSRUNBVEVELCB1c2UgJ3NpZ24nIG9uIGEgcHJpdmF0ZSBrZXkgb2JqZWN0IG9yXG4gKiAnZW5jcnlwdCcgb24gYSBwdWJsaWMga2V5IG9iamVjdCBpbnN0ZWFkLlxuICpcbiAqIFBlcmZvcm1zIFJTQSBlbmNyeXB0aW9uLlxuICpcbiAqIFRoZSBwYXJhbWV0ZXIgYnQgY29udHJvbHMgd2hldGhlciB0byBwdXQgcGFkZGluZyBieXRlcyBiZWZvcmUgdGhlXG4gKiBtZXNzYWdlIHBhc3NlZCBpbi4gU2V0IGJ0IHRvIGVpdGhlciB0cnVlIG9yIGZhbHNlIHRvIGRpc2FibGUgcGFkZGluZ1xuICogY29tcGxldGVseSAoaW4gb3JkZXIgdG8gaGFuZGxlIGUuZy4gRU1TQS1QU1MgZW5jb2Rpbmcgc2VwZXJhdGVseSBiZWZvcmUpLFxuICogc2lnbmFsaW5nIHdoZXRoZXIgdGhlIGVuY3J5cHRpb24gb3BlcmF0aW9uIGlzIGEgcHVibGljIGtleSBvcGVyYXRpb25cbiAqIChpLmUuIGVuY3J5cHRpbmcgZGF0YSkgb3Igbm90LCBpLmUuIHByaXZhdGUga2V5IG9wZXJhdGlvbiAoZGF0YSBzaWduaW5nKS5cbiAqXG4gKiBGb3IgUEtDUyMxIHYxLjUgcGFkZGluZyBwYXNzIGluIHRoZSBibG9jayB0eXBlIHRvIHVzZSwgaS5lLiBlaXRoZXIgMHgwMVxuICogKGZvciBzaWduaW5nKSBvciAweDAyIChmb3IgZW5jcnlwdGlvbikuIFRoZSBrZXkgb3BlcmF0aW9uIG1vZGUgKHByaXZhdGVcbiAqIG9yIHB1YmxpYykgaXMgZGVyaXZlZCBmcm9tIHRoaXMgZmxhZyBpbiB0aGF0IGNhc2UpLlxuICpcbiAqIEBwYXJhbSBtIHRoZSBtZXNzYWdlIHRvIGVuY3J5cHQgYXMgYSBieXRlIHN0cmluZy5cbiAqIEBwYXJhbSBrZXkgdGhlIFJTQSBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGJ0IGZvciBQS0NTIzEgdjEuNSBwYWRkaW5nLCB0aGUgYmxvY2sgdHlwZSB0byB1c2VcbiAqICAgKDB4MDEgZm9yIHByaXZhdGUga2V5LCAweDAyIGZvciBwdWJsaWMpLFxuICogICB0byBkaXNhYmxlIHBhZGRpbmc6IHRydWUgPSBwdWJsaWMga2V5LCBmYWxzZSA9IHByaXZhdGUga2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIGVuY3J5cHRlZCBieXRlcyBhcyBhIHN0cmluZy5cbiAqL1xucGtpLnJzYS5lbmNyeXB0ID0gZnVuY3Rpb24obSwga2V5LCBidCkge1xuICB2YXIgcHViID0gYnQ7XG4gIHZhciBlYjtcblxuICAvLyBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgbW9kdWx1cyBpbiBieXRlc1xuICB2YXIgayA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuXG4gIGlmKGJ0ICE9PSBmYWxzZSAmJiBidCAhPT0gdHJ1ZSkge1xuICAgIC8vIGxlZ2FjeSwgZGVmYXVsdCB0byBQS0NTIzEgdjEuNSBwYWRkaW5nXG4gICAgcHViID0gKGJ0ID09PSAweDAyKTtcbiAgICBlYiA9IF9lbmNvZGVQa2NzMV92MV81KG0sIGtleSwgYnQpO1xuICB9IGVsc2Uge1xuICAgIGViID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBlYi5wdXRCeXRlcyhtKTtcbiAgfVxuXG4gIC8vIGxvYWQgZW5jcnlwdGlvbiBibG9jayBhcyBiaWcgaW50ZWdlciAneCdcbiAgLy8gRklYTUU6IGhleCBjb252ZXJzaW9uIGluZWZmaWNpZW50LCBnZXQgQmlnSW50ZWdlciB3L2J5dGUgc3RyaW5nc1xuICB2YXIgeCA9IG5ldyBCaWdJbnRlZ2VyKGViLnRvSGV4KCksIDE2KTtcblxuICAvLyBkbyBSU0EgZW5jcnlwdGlvblxuICB2YXIgeSA9IF9tb2RQb3coeCwga2V5LCBwdWIpO1xuXG4gIC8vIGNvbnZlcnQgeSBpbnRvIHRoZSBlbmNyeXB0ZWQgZGF0YSBieXRlIHN0cmluZywgaWYgeSBpcyBzaG9ydGVyIGluXG4gIC8vIGJ5dGVzIHRoYW4gaywgdGhlbiBwcmVwZW5kIHplcm8gYnl0ZXMgdG8gZmlsbCB1cCBlZFxuICAvLyBGSVhNRTogaGV4IGNvbnZlcnNpb24gaW5lZmZpY2llbnQsIGdldCBCaWdJbnRlZ2VyIHcvYnl0ZSBzdHJpbmdzXG4gIHZhciB5aGV4ID0geS50b1N0cmluZygxNik7XG4gIHZhciBlZCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIHZhciB6ZXJvcyA9IGsgLSBNYXRoLmNlaWwoeWhleC5sZW5ndGggLyAyKTtcbiAgd2hpbGUoemVyb3MgPiAwKSB7XG4gICAgZWQucHV0Qnl0ZSgweDAwKTtcbiAgICAtLXplcm9zO1xuICB9XG4gIGVkLnB1dEJ5dGVzKGZvcmdlLnV0aWwuaGV4VG9CeXRlcyh5aGV4KSk7XG4gIHJldHVybiBlZC5nZXRCeXRlcygpO1xufTtcblxuLyoqXG4gKiBOT1RFOiBUSElTIE1FVEhPRCBJUyBERVBSRUNBVEVELCB1c2UgJ2RlY3J5cHQnIG9uIGEgcHJpdmF0ZSBrZXkgb2JqZWN0IG9yXG4gKiAndmVyaWZ5JyBvbiBhIHB1YmxpYyBrZXkgb2JqZWN0IGluc3RlYWQuXG4gKlxuICogUGVyZm9ybXMgUlNBIGRlY3J5cHRpb24uXG4gKlxuICogVGhlIHBhcmFtZXRlciBtbCBjb250cm9scyB3aGV0aGVyIHRvIGFwcGx5IFBLQ1MjMSB2MS41IHBhZGRpbmdcbiAqIG9yIG5vdC4gIFNldCBtbCA9IGZhbHNlIHRvIGRpc2FibGUgcGFkZGluZyByZW1vdmFsIGNvbXBsZXRlbHlcbiAqIChpbiBvcmRlciB0byBoYW5kbGUgZS5nLiBFTVNBLVBTUyBsYXRlciBvbikgYW5kIHNpbXBseSBwYXNzIGJhY2tcbiAqIHRoZSBSU0EgZW5jcnlwdGlvbiBibG9jay5cbiAqXG4gKiBAcGFyYW0gZWQgdGhlIGVuY3J5cHRlZCBkYXRhIHRvIGRlY3J5cHQgaW4gYXMgYSBieXRlIHN0cmluZy5cbiAqIEBwYXJhbSBrZXkgdGhlIFJTQSBrZXkgdG8gdXNlLlxuICogQHBhcmFtIHB1YiB0cnVlIGZvciBhIHB1YmxpYyBrZXkgb3BlcmF0aW9uLCBmYWxzZSBmb3IgcHJpdmF0ZS5cbiAqIEBwYXJhbSBtbCB0aGUgbWVzc2FnZSBsZW5ndGgsIGlmIGtub3duLCBmYWxzZSB0byBkaXNhYmxlIHBhZGRpbmcuXG4gKlxuICogQHJldHVybiB0aGUgZGVjcnlwdGVkIG1lc3NhZ2UgYXMgYSBieXRlIHN0cmluZy5cbiAqL1xucGtpLnJzYS5kZWNyeXB0ID0gZnVuY3Rpb24oZWQsIGtleSwgcHViLCBtbCkge1xuICAvLyBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgbW9kdWx1cyBpbiBieXRlc1xuICB2YXIgayA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuXG4gIC8vIGVycm9yIGlmIHRoZSBsZW5ndGggb2YgdGhlIGVuY3J5cHRlZCBkYXRhIEVEIGlzIG5vdCBrXG4gIGlmKGVkLmxlbmd0aCAhPT0gaykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignRW5jcnlwdGVkIG1lc3NhZ2UgbGVuZ3RoIGlzIGludmFsaWQuJyk7XG4gICAgZXJyb3IubGVuZ3RoID0gZWQubGVuZ3RoO1xuICAgIGVycm9yLmV4cGVjdGVkID0gaztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgZW5jcnlwdGVkIGRhdGEgaW50byBhIGJpZyBpbnRlZ2VyXG4gIC8vIEZJWE1FOiBoZXggY29udmVyc2lvbiBpbmVmZmljaWVudCwgZ2V0IEJpZ0ludGVnZXIgdy9ieXRlIHN0cmluZ3NcbiAgdmFyIHkgPSBuZXcgQmlnSW50ZWdlcihmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihlZCkudG9IZXgoKSwgMTYpO1xuXG4gIC8vIHkgbXVzdCBiZSBsZXNzIHRoYW4gdGhlIG1vZHVsdXMgb3IgaXQgd2Fzbid0IHRoZSByZXN1bHQgb2ZcbiAgLy8gYSBwcmV2aW91cyBtb2Qgb3BlcmF0aW9uIChlbmNyeXB0aW9uKSB1c2luZyB0aGF0IG1vZHVsdXNcbiAgaWYoeS5jb21wYXJlVG8oa2V5Lm4pID49IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRlZCBtZXNzYWdlIGlzIGludmFsaWQuJyk7XG4gIH1cblxuICAvLyBkbyBSU0EgZGVjcnlwdGlvblxuICB2YXIgeCA9IF9tb2RQb3coeSwga2V5LCBwdWIpO1xuXG4gIC8vIGNyZWF0ZSB0aGUgZW5jcnlwdGlvbiBibG9jaywgaWYgeCBpcyBzaG9ydGVyIGluIGJ5dGVzIHRoYW4gaywgdGhlblxuICAvLyBwcmVwZW5kIHplcm8gYnl0ZXMgdG8gZmlsbCB1cCBlYlxuICAvLyBGSVhNRTogaGV4IGNvbnZlcnNpb24gaW5lZmZpY2llbnQsIGdldCBCaWdJbnRlZ2VyIHcvYnl0ZSBzdHJpbmdzXG4gIHZhciB4aGV4ID0geC50b1N0cmluZygxNik7XG4gIHZhciBlYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIHZhciB6ZXJvcyA9IGsgLSBNYXRoLmNlaWwoeGhleC5sZW5ndGggLyAyKTtcbiAgd2hpbGUoemVyb3MgPiAwKSB7XG4gICAgZWIucHV0Qnl0ZSgweDAwKTtcbiAgICAtLXplcm9zO1xuICB9XG4gIGViLnB1dEJ5dGVzKGZvcmdlLnV0aWwuaGV4VG9CeXRlcyh4aGV4KSk7XG5cbiAgaWYobWwgIT09IGZhbHNlKSB7XG4gICAgLy8gbGVnYWN5LCBkZWZhdWx0IHRvIFBLQ1MjMSB2MS41IHBhZGRpbmdcbiAgICByZXR1cm4gX2RlY29kZVBrY3MxX3YxXzUoZWIuZ2V0Qnl0ZXMoKSwga2V5LCBwdWIpO1xuICB9XG5cbiAgLy8gcmV0dXJuIG1lc3NhZ2VcbiAgcmV0dXJuIGViLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gUlNBIGtleS1wYWlyIGdlbmVyYXRpb24gc3RhdGUgb2JqZWN0LiBJdCBpcyB1c2VkIHRvIGFsbG93XG4gKiBrZXktZ2VuZXJhdGlvbiB0byBiZSBwZXJmb3JtZWQgaW4gc3RlcHMuIEl0IGFsc28gYWxsb3dzIGZvciBhIFVJIHRvXG4gKiBkaXNwbGF5IHByb2dyZXNzIHVwZGF0ZXMuXG4gKlxuICogQHBhcmFtIGJpdHMgdGhlIHNpemUgZm9yIHRoZSBwcml2YXRlIGtleSBpbiBiaXRzLCBkZWZhdWx0cyB0byAyMDQ4LlxuICogQHBhcmFtIGUgdGhlIHB1YmxpYyBleHBvbmVudCB0byB1c2UsIGRlZmF1bHRzIHRvIDY1NTM3ICgweDEwMDAxKS5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAgcHJuZyBhIGN1c3RvbSBjcnlwdG8tc2VjdXJlIHBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvciB0byB1c2UsXG4gKiAgICAgICAgICAgIHRoYXQgbXVzdCBkZWZpbmUgXCJnZXRCeXRlc1N5bmNcIi5cbiAqICAgICAgICAgIGFsZ29yaXRobSB0aGUgYWxnb3JpdGhtIHRvIHVzZSAoZGVmYXVsdDogJ1BSSU1FSU5DJykuXG4gKlxuICogQHJldHVybiB0aGUgc3RhdGUgb2JqZWN0IHRvIHVzZSB0byBnZW5lcmF0ZSB0aGUga2V5LXBhaXIuXG4gKi9cbnBraS5yc2EuY3JlYXRlS2V5UGFpckdlbmVyYXRpb25TdGF0ZSA9IGZ1bmN0aW9uKGJpdHMsIGUsIG9wdGlvbnMpIHtcbiAgLy8gVE9ETzogbWlncmF0ZSBzdGVwLWJhc2VkIHByaW1lIGdlbmVyYXRpb24gY29kZSB0byBmb3JnZS5wcmltZVxuXG4gIC8vIHNldCBkZWZhdWx0IGJpdHNcbiAgaWYodHlwZW9mKGJpdHMpID09PSAnc3RyaW5nJykge1xuICAgIGJpdHMgPSBwYXJzZUludChiaXRzLCAxMCk7XG4gIH1cbiAgYml0cyA9IGJpdHMgfHwgMjA0ODtcblxuICAvLyBjcmVhdGUgcHJuZyB3aXRoIGFwaSB0aGF0IG1hdGNoZXMgQmlnSW50ZWdlciBzZWN1cmUgcmFuZG9tXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcHJuZyA9IG9wdGlvbnMucHJuZyB8fCBmb3JnZS5yYW5kb207XG4gIHZhciBybmcgPSB7XG4gICAgLy8geCBpcyBhbiBhcnJheSB0byBmaWxsIHdpdGggYnl0ZXNcbiAgICBuZXh0Qnl0ZXM6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciBiID0gcHJuZy5nZXRCeXRlc1N5bmMoeC5sZW5ndGgpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgeFtpXSA9IGIuY2hhckNvZGVBdChpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGFsZ29yaXRobSA9IG9wdGlvbnMuYWxnb3JpdGhtIHx8ICdQUklNRUlOQyc7XG5cbiAgLy8gY3JlYXRlIFBSSU1FSU5DIGFsZ29yaXRobSBzdGF0ZVxuICB2YXIgcnZhbDtcbiAgaWYoYWxnb3JpdGhtID09PSAnUFJJTUVJTkMnKSB7XG4gICAgcnZhbCA9IHtcbiAgICAgIGFsZ29yaXRobTogYWxnb3JpdGhtLFxuICAgICAgc3RhdGU6IDAsXG4gICAgICBiaXRzOiBiaXRzLFxuICAgICAgcm5nOiBybmcsXG4gICAgICBlSW50OiBlIHx8IDY1NTM3LFxuICAgICAgZTogbmV3IEJpZ0ludGVnZXIobnVsbCksXG4gICAgICBwOiBudWxsLFxuICAgICAgcTogbnVsbCxcbiAgICAgIHFCaXRzOiBiaXRzID4+IDEsXG4gICAgICBwQml0czogYml0cyAtIChiaXRzID4+IDEpLFxuICAgICAgcHFTdGF0ZTogMCxcbiAgICAgIG51bTogbnVsbCxcbiAgICAgIGtleXM6IG51bGxcbiAgICB9O1xuICAgIHJ2YWwuZS5mcm9tSW50KHJ2YWwuZUludCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSBnZW5lcmF0aW9uIGFsZ29yaXRobTogJyArIGFsZ29yaXRobSk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gcnVucyB0aGUga2V5LWdlbmVyYXRpb24gYWxnb3JpdGhtIGZvciBhdCBtb3N0IG4gc2Vjb25kc1xuICogKGFwcHJveGltYXRlbHkpIHVzaW5nIHRoZSBnaXZlbiBzdGF0ZS4gV2hlbiBrZXktZ2VuZXJhdGlvbiBoYXMgY29tcGxldGVkLFxuICogdGhlIGtleXMgd2lsbCBiZSBzdG9yZWQgaW4gc3RhdGUua2V5cy5cbiAqXG4gKiBUbyB1c2UgdGhpcyBmdW5jdGlvbiB0byB1cGRhdGUgYSBVSSB3aGlsZSBnZW5lcmF0aW5nIGEga2V5IG9yIHRvIHByZXZlbnRcbiAqIGNhdXNpbmcgYnJvd3NlciBsb2NrdXBzL3dhcm5pbmdzLCBzZXQgXCJuXCIgdG8gYSB2YWx1ZSBvdGhlciB0aGFuIDAuIEFcbiAqIHNpbXBsZSBwYXR0ZXJuIGZvciBnZW5lcmF0aW5nIGEga2V5IGFuZCBzaG93aW5nIGEgcHJvZ3Jlc3MgaW5kaWNhdG9yIGlzOlxuICpcbiAqIHZhciBzdGF0ZSA9IHBraS5yc2EuY3JlYXRlS2V5UGFpckdlbmVyYXRpb25TdGF0ZSgyMDQ4KTtcbiAqIHZhciBzdGVwID0gZnVuY3Rpb24oKSB7XG4gKiAgIC8vIHN0ZXAga2V5LWdlbmVyYXRpb24sIHJ1biBhbGdvcml0aG0gZm9yIDEwMCBtcywgcmVwZWF0XG4gKiAgIGlmKCFmb3JnZS5wa2kucnNhLnN0ZXBLZXlQYWlyR2VuZXJhdGlvblN0YXRlKHN0YXRlLCAxMDApKSB7XG4gKiAgICAgc2V0VGltZW91dChzdGVwLCAxKTtcbiAqICAgfSBlbHNlIHtcbiAqICAgICAvLyBrZXktZ2VuZXJhdGlvbiBjb21wbGV0ZVxuICogICAgIC8vIFRPRE86IHR1cm4gb2ZmIHByb2dyZXNzIGluZGljYXRvciBoZXJlXG4gKiAgICAgLy8gVE9ETzogdXNlIHRoZSBnZW5lcmF0ZWQga2V5LXBhaXIgaW4gXCJzdGF0ZS5rZXlzXCJcbiAqICAgfVxuICogfTtcbiAqIC8vIFRPRE86IHR1cm4gb24gcHJvZ3Jlc3MgaW5kaWNhdG9yIGhlcmVcbiAqIHNldFRpbWVvdXQoc3RlcCwgMCk7XG4gKlxuICogQHBhcmFtIHN0YXRlIHRoZSBzdGF0ZSB0byB1c2UuXG4gKiBAcGFyYW0gbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHJ1biB0aGUgYWxnb3JpdGhtIGZvciwgMFxuICogICAgICAgICAgdG8gcnVuIHRoZSBhbGdvcml0aG0gdG8gY29tcGxldGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIGtleS1nZW5lcmF0aW9uIGNvbXBsZXRlZCwgZmFsc2UgaWYgbm90LlxuICovXG5wa2kucnNhLnN0ZXBLZXlQYWlyR2VuZXJhdGlvblN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIG4pIHtcbiAgLy8gc2V0IGRlZmF1bHQgYWxnb3JpdGhtIGlmIG5vdCBzZXRcbiAgaWYoISgnYWxnb3JpdGhtJyBpbiBzdGF0ZSkpIHtcbiAgICBzdGF0ZS5hbGdvcml0aG0gPSAnUFJJTUVJTkMnO1xuICB9XG5cbiAgLy8gVE9ETzogbWlncmF0ZSBzdGVwLWJhc2VkIHByaW1lIGdlbmVyYXRpb24gY29kZSB0byBmb3JnZS5wcmltZVxuICAvLyBUT0RPOiBhYnN0cmFjdCBhcyBQUklNRUlOQyBhbGdvcml0aG1cblxuICAvLyBkbyBrZXkgZ2VuZXJhdGlvbiAoYmFzZWQgb24gVG9tIFd1J3MgcnNhLmpzLCBzZWUganNibi5qcyBsaWNlbnNlKVxuICAvLyB3aXRoIHNvbWUgbWlub3Igb3B0aW1pemF0aW9ucyBhbmQgZGVzaWduZWQgdG8gcnVuIGluIHN0ZXBzXG5cbiAgLy8gbG9jYWwgc3RhdGUgdmFyc1xuICB2YXIgVEhJUlRZID0gbmV3IEJpZ0ludGVnZXIobnVsbCk7XG4gIFRISVJUWS5mcm9tSW50KDMwKTtcbiAgdmFyIGRlbHRhSWR4ID0gMDtcbiAgdmFyIG9wX29yID0gZnVuY3Rpb24oeCwgeSkge3JldHVybiB4IHwgeTt9O1xuXG4gIC8vIGtlZXAgc3RlcHBpbmcgdW50aWwgdGltZSBsaW1pdCBpcyByZWFjaGVkIG9yIGRvbmVcbiAgdmFyIHQxID0gK25ldyBEYXRlKCk7XG4gIHZhciB0MjtcbiAgdmFyIHRvdGFsID0gMDtcbiAgd2hpbGUoc3RhdGUua2V5cyA9PT0gbnVsbCAmJiAobiA8PSAwIHx8IHRvdGFsIDwgbikpIHtcbiAgICAvLyBnZW5lcmF0ZSBwIG9yIHFcbiAgICBpZihzdGF0ZS5zdGF0ZSA9PT0gMCkge1xuICAgICAgLyogTm90ZTogQWxsIHByaW1lcyBhcmUgb2YgdGhlIGZvcm06XG5cbiAgICAgICAgMzBrK2ksIGZvciBpIDwgMzAgYW5kIGdjZCgzMCwgaSk9MSwgd2hlcmUgdGhlcmUgYXJlIDggdmFsdWVzIGZvciBpXG5cbiAgICAgICAgV2hlbiB3ZSBnZW5lcmF0ZSBhIHJhbmRvbSBudW1iZXIsIHdlIGFsd2F5cyBhbGlnbiBpdCBhdCAzMGsgKyAxLiBFYWNoXG4gICAgICAgIHRpbWUgdGhlIG51bWJlciBpcyBkZXRlcm1pbmVkIG5vdCB0byBiZSBwcmltZSB3ZSBhZGQgdG8gZ2V0IHRvIHRoZVxuICAgICAgICBuZXh0ICdpJywgZWc6IGlmIHRoZSBudW1iZXIgd2FzIGF0IDMwayArIDEgd2UgYWRkIDYuICovXG4gICAgICB2YXIgYml0cyA9IChzdGF0ZS5wID09PSBudWxsKSA/IHN0YXRlLnBCaXRzIDogc3RhdGUucUJpdHM7XG4gICAgICB2YXIgYml0czEgPSBiaXRzIC0gMTtcblxuICAgICAgLy8gZ2V0IGEgcmFuZG9tIG51bWJlclxuICAgICAgaWYoc3RhdGUucHFTdGF0ZSA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5udW0gPSBuZXcgQmlnSW50ZWdlcihiaXRzLCBzdGF0ZS5ybmcpO1xuICAgICAgICAvLyBmb3JjZSBNU0Igc2V0XG4gICAgICAgIGlmKCFzdGF0ZS5udW0udGVzdEJpdChiaXRzMSkpIHtcbiAgICAgICAgICBzdGF0ZS5udW0uYml0d2lzZVRvKFxuICAgICAgICAgICAgQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGJpdHMxKSwgb3Bfb3IsIHN0YXRlLm51bSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWxpZ24gbnVtYmVyIG9uIDMwaysxIGJvdW5kYXJ5XG4gICAgICAgIHN0YXRlLm51bS5kQWRkT2Zmc2V0KDMxIC0gc3RhdGUubnVtLm1vZChUSElSVFkpLmJ5dGVWYWx1ZSgpLCAwKTtcbiAgICAgICAgZGVsdGFJZHggPSAwO1xuXG4gICAgICAgICsrc3RhdGUucHFTdGF0ZTtcbiAgICAgIH0gZWxzZSBpZihzdGF0ZS5wcVN0YXRlID09PSAxKSB7XG4gICAgICAgIC8vIHRyeSB0byBtYWtlIHRoZSBudW1iZXIgYSBwcmltZVxuICAgICAgICBpZihzdGF0ZS5udW0uYml0TGVuZ3RoKCkgPiBiaXRzKSB7XG4gICAgICAgICAgLy8gb3ZlcmZsb3csIHRyeSBhZ2FpblxuICAgICAgICAgIHN0YXRlLnBxU3RhdGUgPSAwO1xuICAgICAgICAgIC8vIGRvIHByaW1hbGl0eSB0ZXN0XG4gICAgICAgIH0gZWxzZSBpZihzdGF0ZS5udW0uaXNQcm9iYWJsZVByaW1lKFxuICAgICAgICAgIF9nZXRNaWxsZXJSYWJpblRlc3RzKHN0YXRlLm51bS5iaXRMZW5ndGgoKSkpKSB7XG4gICAgICAgICAgKytzdGF0ZS5wcVN0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGdldCBuZXh0IHBvdGVudGlhbCBwcmltZVxuICAgICAgICAgIHN0YXRlLm51bS5kQWRkT2Zmc2V0KEdDRF8zMF9ERUxUQVtkZWx0YUlkeCsrICUgOF0sIDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoc3RhdGUucHFTdGF0ZSA9PT0gMikge1xuICAgICAgICAvLyBlbnN1cmUgbnVtYmVyIGlzIGNvcHJpbWUgd2l0aCBlXG4gICAgICAgIHN0YXRlLnBxU3RhdGUgPVxuICAgICAgICAgIChzdGF0ZS5udW0uc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpLmdjZChzdGF0ZS5lKVxuICAgICAgICAgICAgLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT09IDApID8gMyA6IDA7XG4gICAgICB9IGVsc2UgaWYoc3RhdGUucHFTdGF0ZSA9PT0gMykge1xuICAgICAgICAvLyBzdG9yZSBwIG9yIHFcbiAgICAgICAgc3RhdGUucHFTdGF0ZSA9IDA7XG4gICAgICAgIGlmKHN0YXRlLnAgPT09IG51bGwpIHtcbiAgICAgICAgICBzdGF0ZS5wID0gc3RhdGUubnVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnEgPSBzdGF0ZS5udW07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZHZhbmNlIHN0YXRlIGlmIGJvdGggcCBhbmQgcSBhcmUgcmVhZHlcbiAgICAgICAgaWYoc3RhdGUucCAhPT0gbnVsbCAmJiBzdGF0ZS5xICE9PSBudWxsKSB7XG4gICAgICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5udW0gPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihzdGF0ZS5zdGF0ZSA9PT0gMSkge1xuICAgICAgLy8gZW5zdXJlIHAgaXMgbGFyZ2VyIHRoYW4gcSAoc3dhcCB0aGVtIGlmIG5vdClcbiAgICAgIGlmKHN0YXRlLnAuY29tcGFyZVRvKHN0YXRlLnEpIDwgMCkge1xuICAgICAgICBzdGF0ZS5udW0gPSBzdGF0ZS5wO1xuICAgICAgICBzdGF0ZS5wID0gc3RhdGUucTtcbiAgICAgICAgc3RhdGUucSA9IHN0YXRlLm51bTtcbiAgICAgIH1cbiAgICAgICsrc3RhdGUuc3RhdGU7XG4gICAgfSBlbHNlIGlmKHN0YXRlLnN0YXRlID09PSAyKSB7XG4gICAgICAvLyBjb21wdXRlIHBoaTogKHAgLSAxKShxIC0gMSkgKEV1bGVyJ3MgdG90aWVudCBmdW5jdGlvbilcbiAgICAgIHN0YXRlLnAxID0gc3RhdGUucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICBzdGF0ZS5xMSA9IHN0YXRlLnEuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgICAgc3RhdGUucGhpID0gc3RhdGUucDEubXVsdGlwbHkoc3RhdGUucTEpO1xuICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDMpIHtcbiAgICAgIC8vIGVuc3VyZSBlIGFuZCBwaGkgYXJlIGNvcHJpbWVcbiAgICAgIGlmKHN0YXRlLnBoaS5nY2Qoc3RhdGUuZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PT0gMCkge1xuICAgICAgICAvLyBwaGkgYW5kIGUgYXJlIGNvcHJpbWUsIGFkdmFuY2VcbiAgICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBoaSBhbmQgZSBhcmVuJ3QgY29wcmltZSwgc28gZ2VuZXJhdGUgYSBuZXcgcCBhbmQgcVxuICAgICAgICBzdGF0ZS5wID0gbnVsbDtcbiAgICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICAgIHN0YXRlLnN0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDQpIHtcbiAgICAgIC8vIGNyZWF0ZSBuLCBlbnN1cmUgbiBpcyBoYXMgdGhlIHJpZ2h0IG51bWJlciBvZiBiaXRzXG4gICAgICBzdGF0ZS5uID0gc3RhdGUucC5tdWx0aXBseShzdGF0ZS5xKTtcblxuICAgICAgLy8gZW5zdXJlIG4gaXMgcmlnaHQgbnVtYmVyIG9mIGJpdHNcbiAgICAgIGlmKHN0YXRlLm4uYml0TGVuZ3RoKCkgPT09IHN0YXRlLmJpdHMpIHtcbiAgICAgICAgLy8gc3VjY2VzcywgYWR2YW5jZVxuICAgICAgICArK3N0YXRlLnN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmFpbGVkLCBnZXQgbmV3IHFcbiAgICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICAgIHN0YXRlLnN0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDUpIHtcbiAgICAgIC8vIHNldCBrZXlzXG4gICAgICB2YXIgZCA9IHN0YXRlLmUubW9kSW52ZXJzZShzdGF0ZS5waGkpO1xuICAgICAgc3RhdGUua2V5cyA9IHtcbiAgICAgICAgcHJpdmF0ZUtleTogcGtpLnJzYS5zZXRQcml2YXRlS2V5KFxuICAgICAgICAgIHN0YXRlLm4sIHN0YXRlLmUsIGQsIHN0YXRlLnAsIHN0YXRlLnEsXG4gICAgICAgICAgZC5tb2Qoc3RhdGUucDEpLCBkLm1vZChzdGF0ZS5xMSksXG4gICAgICAgICAgc3RhdGUucS5tb2RJbnZlcnNlKHN0YXRlLnApKSxcbiAgICAgICAgcHVibGljS2V5OiBwa2kucnNhLnNldFB1YmxpY0tleShzdGF0ZS5uLCBzdGF0ZS5lKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGltaW5nXG4gICAgdDIgPSArbmV3IERhdGUoKTtcbiAgICB0b3RhbCArPSB0MiAtIHQxO1xuICAgIHQxID0gdDI7XG4gIH1cblxuICByZXR1cm4gc3RhdGUua2V5cyAhPT0gbnVsbDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIFJTQSBwdWJsaWMtcHJpdmF0ZSBrZXkgcGFpciBpbiBhIHNpbmdsZSBjYWxsLlxuICpcbiAqIFRvIGdlbmVyYXRlIGEga2V5LXBhaXIgaW4gc3RlcHMgKHRvIGFsbG93IGZvciBwcm9ncmVzcyB1cGRhdGVzIGFuZCB0b1xuICogcHJldmVudCBibG9ja2luZyBvciB3YXJuaW5ncyBpbiBzbG93IGJyb3dzZXJzKSB0aGVuIHVzZSB0aGUga2V5LXBhaXJcbiAqIGdlbmVyYXRpb24gc3RhdGUgZnVuY3Rpb25zLlxuICpcbiAqIFRvIGdlbmVyYXRlIGEga2V5LXBhaXIgYXN5bmNocm9ub3VzbHkgKGVpdGhlciB0aHJvdWdoIHdlYi13b3JrZXJzLCBpZlxuICogYXZhaWxhYmxlLCBvciBieSBicmVha2luZyB1cCB0aGUgd29yayBvbiB0aGUgbWFpbiB0aHJlYWQpLCBwYXNzIGFcbiAqIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBbYml0c10gdGhlIHNpemUgZm9yIHRoZSBwcml2YXRlIGtleSBpbiBiaXRzLCBkZWZhdWx0cyB0byAyMDQ4LlxuICogQHBhcmFtIFtlXSB0aGUgcHVibGljIGV4cG9uZW50IHRvIHVzZSwgZGVmYXVsdHMgdG8gNjU1MzcuXG4gKiBAcGFyYW0gW29wdGlvbnNdIG9wdGlvbnMgZm9yIGtleS1wYWlyIGdlbmVyYXRpb24sIGlmIGdpdmVuIHRoZW4gJ2JpdHMnXG4gKiAgICAgICAgICAgIGFuZCAnZScgbXVzdCAqbm90KiBiZSBnaXZlbjpcbiAqICAgICAgICAgIGJpdHMgdGhlIHNpemUgZm9yIHRoZSBwcml2YXRlIGtleSBpbiBiaXRzLCAoZGVmYXVsdDogMjA0OCkuXG4gKiAgICAgICAgICBlIHRoZSBwdWJsaWMgZXhwb25lbnQgdG8gdXNlLCAoZGVmYXVsdDogNjU1MzcgKDB4MTAwMDEpKS5cbiAqICAgICAgICAgIHdvcmtlclNjcmlwdCB0aGUgd29ya2VyIHNjcmlwdCBVUkwuXG4gKiAgICAgICAgICB3b3JrZXJzIHRoZSBudW1iZXIgb2Ygd2ViIHdvcmtlcnMgKGlmIHN1cHBvcnRlZCkgdG8gdXNlLFxuICogICAgICAgICAgICAoZGVmYXVsdDogMikuXG4gKiAgICAgICAgICB3b3JrTG9hZCB0aGUgc2l6ZSBvZiB0aGUgd29yayBsb2FkLCBpZTogbnVtYmVyIG9mIHBvc3NpYmxlIHByaW1lXG4gKiAgICAgICAgICAgIG51bWJlcnMgZm9yIGVhY2ggd2ViIHdvcmtlciB0byBjaGVjayBwZXIgd29yayBhc3NpZ25tZW50LFxuICogICAgICAgICAgICAoZGVmYXVsdDogMTAwKS5cbiAqICAgICAgICAgIHBybmcgYSBjdXN0b20gY3J5cHRvLXNlY3VyZSBwc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgdG8gdXNlLFxuICogICAgICAgICAgICB0aGF0IG11c3QgZGVmaW5lIFwiZ2V0Qnl0ZXNTeW5jXCIuIERpc2FibGVzIHVzZSBvZiBuYXRpdmUgQVBJcy5cbiAqICAgICAgICAgIGFsZ29yaXRobSB0aGUgYWxnb3JpdGhtIHRvIHVzZSAoZGVmYXVsdDogJ1BSSU1FSU5DJykuXG4gKiBAcGFyYW0gW2NhbGxiYWNrKGVyciwga2V5cGFpcildIGNhbGxlZCBvbmNlIHRoZSBvcGVyYXRpb24gY29tcGxldGVzLlxuICpcbiAqIEByZXR1cm4gYW4gb2JqZWN0IHdpdGggcHJpdmF0ZUtleSBhbmQgcHVibGljS2V5IHByb3BlcnRpZXMuXG4gKi9cbnBraS5yc2EuZ2VuZXJhdGVLZXlQYWlyID0gZnVuY3Rpb24oYml0cywgZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgLy8gKGJpdHMpLCAob3B0aW9ucyksIChjYWxsYmFjaylcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmKHR5cGVvZiBiaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IGJpdHM7XG4gICAgICBiaXRzID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZih0eXBlb2YgYml0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBiaXRzO1xuICAgICAgYml0cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgLy8gKGJpdHMsIGUpLCAoYml0cywgb3B0aW9ucyksIChiaXRzLCBjYWxsYmFjayksIChvcHRpb25zLCBjYWxsYmFjaylcbiAgICBpZih0eXBlb2YgYml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmKHR5cGVvZiBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gZTtcbiAgICAgICAgZSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZih0eXBlb2YgZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgb3B0aW9ucyA9IGU7XG4gICAgICAgIGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBiaXRzO1xuICAgICAgY2FsbGJhY2sgPSBlO1xuICAgICAgYml0cyA9IHVuZGVmaW5lZDtcbiAgICAgIGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIC8vIChiaXRzLCBlLCBvcHRpb25zKSwgKGJpdHMsIGUsIGNhbGxiYWNrKSwgKGJpdHMsIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIGlmKHR5cGVvZiBlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0gZTtcbiAgICAgIGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZihiaXRzID09PSB1bmRlZmluZWQpIHtcbiAgICBiaXRzID0gb3B0aW9ucy5iaXRzIHx8IDIwNDg7XG4gIH1cbiAgaWYoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZSA9IG9wdGlvbnMuZSB8fCAweDEwMDAxO1xuICB9XG5cbiAgLy8gdXNlIG5hdGl2ZSBjb2RlIGlmIHBlcm1pdHRlZCwgYXZhaWxhYmxlLCBhbmQgcGFyYW1ldGVycyBhcmUgYWNjZXB0YWJsZVxuICBpZighZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCAmJiAhb3B0aW9ucy5wcm5nICYmXG4gICAgYml0cyA+PSAyNTYgJiYgYml0cyA8PSAxNjM4NCAmJiAoZSA9PT0gMHgxMDAwMSB8fCBlID09PSAzKSkge1xuICAgIGlmKGNhbGxiYWNrKSB7XG4gICAgICAvLyB0cnkgbmF0aXZlIGFzeW5jXG4gICAgICBpZihfZGV0ZWN0Tm9kZUNyeXB0bygnZ2VuZXJhdGVLZXlQYWlyJykpIHtcbiAgICAgICAgcmV0dXJuIF9jcnlwdG8uZ2VuZXJhdGVLZXlQYWlyKCdyc2EnLCB7XG4gICAgICAgICAgbW9kdWx1c0xlbmd0aDogYml0cyxcbiAgICAgICAgICBwdWJsaWNFeHBvbmVudDogZSxcbiAgICAgICAgICBwdWJsaWNLZXlFbmNvZGluZzoge1xuICAgICAgICAgICAgdHlwZTogJ3Nwa2knLFxuICAgICAgICAgICAgZm9ybWF0OiAncGVtJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJpdmF0ZUtleUVuY29kaW5nOiB7XG4gICAgICAgICAgICB0eXBlOiAncGtjczgnLFxuICAgICAgICAgICAgZm9ybWF0OiAncGVtJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBwdWIsIHByaXYpIHtcbiAgICAgICAgICBpZihlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBwa2kucHJpdmF0ZUtleUZyb21QZW0ocHJpdiksXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHBraS5wdWJsaWNLZXlGcm9tUGVtKHB1YilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZihfZGV0ZWN0U3VidGxlQ3J5cHRvKCdnZW5lcmF0ZUtleScpICYmXG4gICAgICAgIF9kZXRlY3RTdWJ0bGVDcnlwdG8oJ2V4cG9ydEtleScpKSB7XG4gICAgICAgIC8vIHVzZSBzdGFuZGFyZCBuYXRpdmUgZ2VuZXJhdGVLZXlcbiAgICAgICAgcmV0dXJuIHV0aWwuZ2xvYmFsU2NvcGUuY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleSh7XG4gICAgICAgICAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgICAgICAgICBtb2R1bHVzTGVuZ3RoOiBiaXRzLFxuICAgICAgICAgIHB1YmxpY0V4cG9uZW50OiBfaW50VG9VaW50OEFycmF5KGUpLFxuICAgICAgICAgIGhhc2g6IHtuYW1lOiAnU0hBLTI1Nid9XG4gICAgICAgIH0sIHRydWUgLyoga2V5IGNhbiBiZSBleHBvcnRlZCovLCBbJ3NpZ24nLCAndmVyaWZ5J10pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbC5nbG9iYWxTY29wZS5jcnlwdG8uc3VidGxlLmV4cG9ydEtleShcbiAgICAgICAgICAgICdwa2NzOCcsIHBhaXIucHJpdmF0ZUtleSk7XG4gICAgICAgIC8vIGF2b2lkaW5nIGNhdGNoKGZ1bmN0aW9uKGVycikgey4uLn0pIHRvIHN1cHBvcnQgSUUgPD0gOFxuICAgICAgICB9KS50aGVuKHVuZGVmaW5lZCwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihwa2NzOCkge1xuICAgICAgICAgIGlmKHBrY3M4KSB7XG4gICAgICAgICAgICB2YXIgcHJpdmF0ZUtleSA9IHBraS5wcml2YXRlS2V5RnJvbUFzbjEoXG4gICAgICAgICAgICAgIGFzbjEuZnJvbURlcihmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihwa2NzOCkpKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAgICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgcHVibGljS2V5OiBwa2kuc2V0UnNhUHVibGljS2V5KHByaXZhdGVLZXkubiwgcHJpdmF0ZUtleS5lKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmKF9kZXRlY3RTdWJ0bGVNc0NyeXB0bygnZ2VuZXJhdGVLZXknKSAmJlxuICAgICAgICBfZGV0ZWN0U3VidGxlTXNDcnlwdG8oJ2V4cG9ydEtleScpKSB7XG4gICAgICAgIHZhciBnZW5PcCA9IHV0aWwuZ2xvYmFsU2NvcGUubXNDcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICAgICAgICAgIG1vZHVsdXNMZW5ndGg6IGJpdHMsXG4gICAgICAgICAgcHVibGljRXhwb25lbnQ6IF9pbnRUb1VpbnQ4QXJyYXkoZSksXG4gICAgICAgICAgaGFzaDoge25hbWU6ICdTSEEtMjU2J31cbiAgICAgICAgfSwgdHJ1ZSAvKiBrZXkgY2FuIGJlIGV4cG9ydGVkKi8sIFsnc2lnbicsICd2ZXJpZnknXSk7XG4gICAgICAgIGdlbk9wLm9uY29tcGxldGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgdmFyIHBhaXIgPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgdmFyIGV4cG9ydE9wID0gdXRpbC5nbG9iYWxTY29wZS5tc0NyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KFxuICAgICAgICAgICAgJ3BrY3M4JywgcGFpci5wcml2YXRlS2V5KTtcbiAgICAgICAgICBleHBvcnRPcC5vbmNvbXBsZXRlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIHBrY3M4ID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgdmFyIHByaXZhdGVLZXkgPSBwa2kucHJpdmF0ZUtleUZyb21Bc24xKFxuICAgICAgICAgICAgICBhc24xLmZyb21EZXIoZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIocGtjczgpKSk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXksXG4gICAgICAgICAgICAgIHB1YmxpY0tleTogcGtpLnNldFJzYVB1YmxpY0tleShwcml2YXRlS2V5Lm4sIHByaXZhdGVLZXkuZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgZXhwb3J0T3Aub25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBnZW5PcC5vbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0cnkgbmF0aXZlIHN5bmNcbiAgICAgIGlmKF9kZXRlY3ROb2RlQ3J5cHRvKCdnZW5lcmF0ZUtleVBhaXJTeW5jJykpIHtcbiAgICAgICAgdmFyIGtleXBhaXIgPSBfY3J5cHRvLmdlbmVyYXRlS2V5UGFpclN5bmMoJ3JzYScsIHtcbiAgICAgICAgICBtb2R1bHVzTGVuZ3RoOiBiaXRzLFxuICAgICAgICAgIHB1YmxpY0V4cG9uZW50OiBlLFxuICAgICAgICAgIHB1YmxpY0tleUVuY29kaW5nOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3BraScsXG4gICAgICAgICAgICBmb3JtYXQ6ICdwZW0nXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcml2YXRlS2V5RW5jb2Rpbmc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdwa2NzOCcsXG4gICAgICAgICAgICBmb3JtYXQ6ICdwZW0nXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwcml2YXRlS2V5OiBwa2kucHJpdmF0ZUtleUZyb21QZW0oa2V5cGFpci5wcml2YXRlS2V5KSxcbiAgICAgICAgICBwdWJsaWNLZXk6IHBraS5wdWJsaWNLZXlGcm9tUGVtKGtleXBhaXIucHVibGljS2V5KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHVzZSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uXG4gIHZhciBzdGF0ZSA9IHBraS5yc2EuY3JlYXRlS2V5UGFpckdlbmVyYXRpb25TdGF0ZShiaXRzLCBlLCBvcHRpb25zKTtcbiAgaWYoIWNhbGxiYWNrKSB7XG4gICAgcGtpLnJzYS5zdGVwS2V5UGFpckdlbmVyYXRpb25TdGF0ZShzdGF0ZSwgMCk7XG4gICAgcmV0dXJuIHN0YXRlLmtleXM7XG4gIH1cbiAgX2dlbmVyYXRlS2V5UGFpcihzdGF0ZSwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTZXRzIGFuIFJTQSBwdWJsaWMga2V5IGZyb20gQmlnSW50ZWdlcnMgbW9kdWx1cyBhbmQgZXhwb25lbnQuXG4gKlxuICogQHBhcmFtIG4gdGhlIG1vZHVsdXMuXG4gKiBAcGFyYW0gZSB0aGUgZXhwb25lbnQuXG4gKlxuICogQHJldHVybiB0aGUgcHVibGljIGtleS5cbiAqL1xucGtpLnNldFJzYVB1YmxpY0tleSA9IHBraS5yc2Euc2V0UHVibGljS2V5ID0gZnVuY3Rpb24obiwgZSkge1xuICB2YXIga2V5ID0ge1xuICAgIG46IG4sXG4gICAgZTogZVxuICB9O1xuXG4gIC8qKlxuICAgKiBFbmNyeXB0cyB0aGUgZ2l2ZW4gZGF0YSB3aXRoIHRoaXMgcHVibGljIGtleS4gTmV3ZXIgYXBwbGljYXRpb25zXG4gICAqIHNob3VsZCB1c2UgdGhlICdSU0EtT0FFUCcgZGVjcnlwdGlvbiBzY2hlbWUsICdSU0FFUy1QS0NTMS1WMV81JyBpcyBmb3JcbiAgICogbGVnYWN5IGFwcGxpY2F0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgdGhlIGJ5dGUgc3RyaW5nIHRvIGVuY3J5cHQuXG4gICAqIEBwYXJhbSBzY2hlbWUgdGhlIGVuY3J5cHRpb24gc2NoZW1lIHRvIHVzZTpcbiAgICogICAgICAgICAgJ1JTQUVTLVBLQ1MxLVYxXzUnIChkZWZhdWx0KSxcbiAgICogICAgICAgICAgJ1JTQS1PQUVQJyxcbiAgICogICAgICAgICAgJ1JBVycsICdOT05FJywgb3IgbnVsbCB0byBwZXJmb3JtIHJhdyBSU0EgZW5jcnlwdGlvbixcbiAgICogICAgICAgICAgYW4gb2JqZWN0IHdpdGggYW4gJ2VuY29kZScgcHJvcGVydHkgc2V0IHRvIGEgZnVuY3Rpb25cbiAgICogICAgICAgICAgd2l0aCB0aGUgc2lnbmF0dXJlICdmdW5jdGlvbihkYXRhLCBrZXkpJyB0aGF0IHJldHVybnNcbiAgICogICAgICAgICAgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBlbmNvZGVkIGRhdGEuXG4gICAqIEBwYXJhbSBzY2hlbWVPcHRpb25zIGFueSBzY2hlbWUtc3BlY2lmaWMgb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybiB0aGUgZW5jcnlwdGVkIGJ5dGUgc3RyaW5nLlxuICAgKi9cbiAga2V5LmVuY3J5cHQgPSBmdW5jdGlvbihkYXRhLCBzY2hlbWUsIHNjaGVtZU9wdGlvbnMpIHtcbiAgICBpZih0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgc2NoZW1lID0gc2NoZW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzY2hlbWUgPSAnUlNBRVMtUEtDUzEtVjFfNSc7XG4gICAgfVxuXG4gICAgaWYoc2NoZW1lID09PSAnUlNBRVMtUEtDUzEtVjFfNScpIHtcbiAgICAgIHNjaGVtZSA9IHtcbiAgICAgICAgZW5jb2RlOiBmdW5jdGlvbihtLCBrZXksIHB1Yikge1xuICAgICAgICAgIHJldHVybiBfZW5jb2RlUGtjczFfdjFfNShtLCBrZXksIDB4MDIpLmdldEJ5dGVzKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gJ1JTQS1PQUVQJyB8fCBzY2hlbWUgPT09ICdSU0FFUy1PQUVQJykge1xuICAgICAgc2NoZW1lID0ge1xuICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uKG0sIGtleSkge1xuICAgICAgICAgIHJldHVybiBmb3JnZS5wa2NzMS5lbmNvZGVfcnNhX29hZXAoa2V5LCBtLCBzY2hlbWVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYoWydSQVcnLCAnTk9ORScsICdOVUxMJywgbnVsbF0uaW5kZXhPZihzY2hlbWUpICE9PSAtMSkge1xuICAgICAgc2NoZW1lID0ge2VuY29kZTogZnVuY3Rpb24oZSkge3JldHVybiBlO319O1xuICAgIH0gZWxzZSBpZih0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBlbmNyeXB0aW9uIHNjaGVtZTogXCInICsgc2NoZW1lICsgJ1wiLicpO1xuICAgIH1cblxuICAgIC8vIGRvIHNjaGVtZS1iYXNlZCBlbmNvZGluZyB0aGVuIHJzYSBlbmNyeXB0aW9uXG4gICAgdmFyIGUgPSBzY2hlbWUuZW5jb2RlKGRhdGEsIGtleSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHBraS5yc2EuZW5jcnlwdChlLCBrZXksIHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGUgZ2l2ZW4gc2lnbmF0dXJlIGFnYWluc3QgdGhlIGdpdmVuIGRpZ2VzdC5cbiAgICpcbiAgICogUEtDUyMxIHN1cHBvcnRzIG11bHRpcGxlIChjdXJyZW50bHkgdHdvKSBzaWduYXR1cmUgc2NoZW1lczpcbiAgICogUlNBU1NBLVBLQ1MxLVYxXzUgYW5kIFJTQVNTQS1QU1MuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQgdGhpcyBpbXBsZW1lbnRhdGlvbiB1c2VzIHRoZSBcIm9sZCBzY2hlbWVcIiwgaS5lLlxuICAgKiBSU0FTU0EtUEtDUzEtVjFfNSwgaW4gd2hpY2ggY2FzZSBvbmNlIFJTQS1kZWNyeXB0ZWQsIHRoZVxuICAgKiBzaWduYXR1cmUgaXMgYW4gT0NURVQgU1RSSU5HIHRoYXQgaG9sZHMgYSBEaWdlc3RJbmZvLlxuICAgKlxuICAgKiBEaWdlc3RJbmZvIDo6PSBTRVFVRU5DRSB7XG4gICAqICAgZGlnZXN0QWxnb3JpdGhtIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gICAqICAgZGlnZXN0IERpZ2VzdFxuICAgKiB9XG4gICAqIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAgICogRGlnZXN0IDo6PSBPQ1RFVCBTVFJJTkdcbiAgICpcbiAgICogVG8gcGVyZm9ybSBQU1Mgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiwgcHJvdmlkZSBhbiBpbnN0YW5jZVxuICAgKiBvZiBGb3JnZSBQU1Mgb2JqZWN0IGFzIHRoZSBzY2hlbWUgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0gZGlnZXN0IHRoZSBtZXNzYWdlIGRpZ2VzdCBoYXNoIHRvIGNvbXBhcmUgYWdhaW5zdCB0aGUgc2lnbmF0dXJlLFxuICAgKiAgICAgICAgICBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZy5cbiAgICogQHBhcmFtIHNpZ25hdHVyZSB0aGUgc2lnbmF0dXJlIHRvIHZlcmlmeSwgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcuXG4gICAqIEBwYXJhbSBzY2hlbWUgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBzY2hlbWUgdG8gdXNlOlxuICAgKiAgICAgICAgICAnUlNBU1NBLVBLQ1MxLVYxXzUnIG9yIHVuZGVmaW5lZCBmb3IgUlNBU1NBIFBLQ1MjMSB2MS41LFxuICAgKiAgICAgICAgICBhIEZvcmdlIFBTUyBvYmplY3QgZm9yIFJTQVNTQS1QU1MsXG4gICAqICAgICAgICAgICdOT05FJyBvciBudWxsIGZvciBub25lLCBEaWdlc3RJbmZvIHdpbGwgbm90IGJlIGV4cGVjdGVkLCBidXRcbiAgICogICAgICAgICAgICBQS0NTIzEgdjEuNSBwYWRkaW5nIHdpbGwgc3RpbGwgYmUgdXNlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9uYWwgdmVyaWZ5IG9wdGlvbnNcbiAgICogICAgICAgICAgX3BhcnNlQWxsRGlnZXN0Qnl0ZXMgdGVzdGluZyBmbGFnIHRvIGNvbnRyb2wgcGFyc2luZyBvZiBhbGxcbiAgICogICAgICAgICAgICBkaWdlc3QgYnl0ZXMuIFVuc3VwcG9ydGVkIGFuZCBub3QgZm9yIGdlbmVyYWwgdXNhZ2UuXG4gICAqICAgICAgICAgICAgKGRlZmF1bHQ6IHRydWUpXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIHdhcyB2ZXJpZmllZCwgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAga2V5LnZlcmlmeSA9IGZ1bmN0aW9uKGRpZ2VzdCwgc2lnbmF0dXJlLCBzY2hlbWUsIG9wdGlvbnMpIHtcbiAgICBpZih0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgc2NoZW1lID0gc2NoZW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzY2hlbWUgPSAnUlNBU1NBLVBLQ1MxLVYxXzUnO1xuICAgIH1cbiAgICBpZihvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIF9wYXJzZUFsbERpZ2VzdEJ5dGVzOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZighKCdfcGFyc2VBbGxEaWdlc3RCeXRlcycgaW4gb3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnMuX3BhcnNlQWxsRGlnZXN0Qnl0ZXMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmKHNjaGVtZSA9PT0gJ1JTQVNTQS1QS0NTMS1WMV81Jykge1xuICAgICAgc2NoZW1lID0ge1xuICAgICAgICB2ZXJpZnk6IGZ1bmN0aW9uKGRpZ2VzdCwgZCkge1xuICAgICAgICAgIC8vIHJlbW92ZSBwYWRkaW5nXG4gICAgICAgICAgZCA9IF9kZWNvZGVQa2NzMV92MV81KGQsIGtleSwgdHJ1ZSk7XG4gICAgICAgICAgLy8gZCBpcyBBU04uMSBCRVItZW5jb2RlZCBEaWdlc3RJbmZvXG4gICAgICAgICAgdmFyIG9iaiA9IGFzbjEuZnJvbURlcihkLCB7XG4gICAgICAgICAgICBwYXJzZUFsbEJ5dGVzOiBvcHRpb25zLl9wYXJzZUFsbERpZ2VzdEJ5dGVzXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyB2YWxpZGF0ZSBEaWdlc3RJbmZvXG4gICAgICAgICAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgICAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCBkaWdlc3RJbmZvVmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdBU04uMSBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhIHZhbGlkIFJTQVNTQS1QS0NTMS12MV81ICcgK1xuICAgICAgICAgICAgICAnRGlnZXN0SW5mbyB2YWx1ZS4nKTtcbiAgICAgICAgICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjaGVjayBoYXNoIGFsZ29yaXRobSBpZGVudGlmaWVyXG4gICAgICAgICAgLy8gc2VlIFBLQ1MxLXYxLTVEaWdlc3RBbGdvcml0aG1zIGluIFJGQyA4MDE3XG4gICAgICAgICAgLy8gRklYTUU6IGFkZCBzdXBwb3J0IHRvIHZhaWRhdG9yIGZvciBzdHJpY3QgdmFsdWUgY2hvaWNlc1xuICAgICAgICAgIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuYWxnb3JpdGhtSWRlbnRpZmllcik7XG4gICAgICAgICAgaWYoIShvaWQgPT09IGZvcmdlLm9pZHMubWQyIHx8XG4gICAgICAgICAgICBvaWQgPT09IGZvcmdlLm9pZHMubWQ1IHx8XG4gICAgICAgICAgICBvaWQgPT09IGZvcmdlLm9pZHMuc2hhMSB8fFxuICAgICAgICAgICAgb2lkID09PSBmb3JnZS5vaWRzLnNoYTIyNCB8fFxuICAgICAgICAgICAgb2lkID09PSBmb3JnZS5vaWRzLnNoYTI1NiB8fFxuICAgICAgICAgICAgb2lkID09PSBmb3JnZS5vaWRzLnNoYTM4NCB8fFxuICAgICAgICAgICAgb2lkID09PSBmb3JnZS5vaWRzLnNoYTUxMiB8fFxuICAgICAgICAgICAgb2lkID09PSBmb3JnZS5vaWRzWydzaGE1MTItMjI0J10gfHxcbiAgICAgICAgICAgIG9pZCA9PT0gZm9yZ2Uub2lkc1snc2hhNTEyLTI1NiddKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnVW5rbm93biBSU0FTU0EtUEtDUzEtdjFfNSBEaWdlc3RBbGdvcml0aG0gaWRlbnRpZmllci4nKTtcbiAgICAgICAgICAgIGVycm9yLm9pZCA9IG9pZDtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHNwZWNpYWwgY2hlY2sgZm9yIG1kMiBhbmQgbWQ1IHRoYXQgTlVMTCBwYXJhbWV0ZXJzIGV4aXN0XG4gICAgICAgICAgaWYob2lkID09PSBmb3JnZS5vaWRzLm1kMiB8fCBvaWQgPT09IGZvcmdlLm9pZHMubWQ1KSB7XG4gICAgICAgICAgICBpZighKCdwYXJhbWV0ZXJzJyBpbiBjYXB0dXJlKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ0FTTi4xIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgdmFsaWQgUlNBU1NBLVBLQ1MxLXYxXzUgJyArXG4gICAgICAgICAgICAgICAgJ0RpZ2VzdEluZm8gdmFsdWUuICcgK1xuICAgICAgICAgICAgICAgICdNaXNzaW5nIGFsZ29yaXRobSBpZGVudGlmZXIgTlVMTCBwYXJhbWV0ZXJzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNvbXBhcmUgdGhlIGdpdmVuIGRpZ2VzdCB0byB0aGUgZGVjcnlwdGVkIG9uZVxuICAgICAgICAgIHJldHVybiBkaWdlc3QgPT09IGNhcHR1cmUuZGlnZXN0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZihzY2hlbWUgPT09ICdOT05FJyB8fCBzY2hlbWUgPT09ICdOVUxMJyB8fCBzY2hlbWUgPT09IG51bGwpIHtcbiAgICAgIHNjaGVtZSA9IHtcbiAgICAgICAgdmVyaWZ5OiBmdW5jdGlvbihkaWdlc3QsIGQpIHtcbiAgICAgICAgICAvLyByZW1vdmUgcGFkZGluZ1xuICAgICAgICAgIGQgPSBfZGVjb2RlUGtjczFfdjFfNShkLCBrZXksIHRydWUpO1xuICAgICAgICAgIHJldHVybiBkaWdlc3QgPT09IGQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZG8gcnNhIGRlY3J5cHRpb24gdy9vIGFueSBkZWNvZGluZywgdGhlbiB2ZXJpZnkgLS0gd2hpY2ggZG9lcyBkZWNvZGluZ1xuICAgIHZhciBkID0gcGtpLnJzYS5kZWNyeXB0KHNpZ25hdHVyZSwga2V5LCB0cnVlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHNjaGVtZS52ZXJpZnkoZGlnZXN0LCBkLCBrZXkubi5iaXRMZW5ndGgoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGtleTtcbn07XG5cbi8qKlxuICogU2V0cyBhbiBSU0EgcHJpdmF0ZSBrZXkgZnJvbSBCaWdJbnRlZ2VycyBtb2R1bHVzLCBleHBvbmVudCwgcHJpbWVzLFxuICogcHJpbWUgZXhwb25lbnRzLCBhbmQgbW9kdWxhciBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlLlxuICpcbiAqIEBwYXJhbSBuIHRoZSBtb2R1bHVzLlxuICogQHBhcmFtIGUgdGhlIHB1YmxpYyBleHBvbmVudC5cbiAqIEBwYXJhbSBkIHRoZSBwcml2YXRlIGV4cG9uZW50ICgoaW52ZXJzZSBvZiBlKSBtb2QgbikuXG4gKiBAcGFyYW0gcCB0aGUgZmlyc3QgcHJpbWUuXG4gKiBAcGFyYW0gcSB0aGUgc2Vjb25kIHByaW1lLlxuICogQHBhcmFtIGRQIGV4cG9uZW50MSAoZCBtb2QgKHAtMSkpLlxuICogQHBhcmFtIGRRIGV4cG9uZW50MiAoZCBtb2QgKHEtMSkpLlxuICogQHBhcmFtIHFJbnYgKChpbnZlcnNlIG9mIHEpIG1vZCBwKVxuICpcbiAqIEByZXR1cm4gdGhlIHByaXZhdGUga2V5LlxuICovXG5wa2kuc2V0UnNhUHJpdmF0ZUtleSA9IHBraS5yc2Euc2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uKFxuICBuLCBlLCBkLCBwLCBxLCBkUCwgZFEsIHFJbnYpIHtcbiAgdmFyIGtleSA9IHtcbiAgICBuOiBuLFxuICAgIGU6IGUsXG4gICAgZDogZCxcbiAgICBwOiBwLFxuICAgIHE6IHEsXG4gICAgZFA6IGRQLFxuICAgIGRROiBkUSxcbiAgICBxSW52OiBxSW52XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY3J5cHRzIHRoZSBnaXZlbiBkYXRhIHdpdGggdGhpcyBwcml2YXRlIGtleS4gVGhlIGRlY3J5cHRpb24gc2NoZW1lXG4gICAqIG11c3QgbWF0Y2ggdGhlIG9uZSB1c2VkIHRvIGVuY3J5cHQgdGhlIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIHRoZSBieXRlIHN0cmluZyB0byBkZWNyeXB0LlxuICAgKiBAcGFyYW0gc2NoZW1lIHRoZSBkZWNyeXB0aW9uIHNjaGVtZSB0byB1c2U6XG4gICAqICAgICAgICAgICdSU0FFUy1QS0NTMS1WMV81JyAoZGVmYXVsdCksXG4gICAqICAgICAgICAgICdSU0EtT0FFUCcsXG4gICAqICAgICAgICAgICdSQVcnLCAnTk9ORScsIG9yIG51bGwgdG8gcGVyZm9ybSByYXcgUlNBIGRlY3J5cHRpb24uXG4gICAqIEBwYXJhbSBzY2hlbWVPcHRpb25zIGFueSBzY2hlbWUtc3BlY2lmaWMgb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybiB0aGUgZGVjcnlwdGVkIGJ5dGUgc3RyaW5nLlxuICAgKi9cbiAga2V5LmRlY3J5cHQgPSBmdW5jdGlvbihkYXRhLCBzY2hlbWUsIHNjaGVtZU9wdGlvbnMpIHtcbiAgICBpZih0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgc2NoZW1lID0gc2NoZW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzY2hlbWUgPSAnUlNBRVMtUEtDUzEtVjFfNSc7XG4gICAgfVxuXG4gICAgLy8gZG8gcnNhIGRlY3J5cHRpb24gdy9vIGFueSBkZWNvZGluZ1xuICAgIHZhciBkID0gcGtpLnJzYS5kZWNyeXB0KGRhdGEsIGtleSwgZmFsc2UsIGZhbHNlKTtcblxuICAgIGlmKHNjaGVtZSA9PT0gJ1JTQUVTLVBLQ1MxLVYxXzUnKSB7XG4gICAgICBzY2hlbWUgPSB7ZGVjb2RlOiBfZGVjb2RlUGtjczFfdjFfNX07XG4gICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gJ1JTQS1PQUVQJyB8fCBzY2hlbWUgPT09ICdSU0FFUy1PQUVQJykge1xuICAgICAgc2NoZW1lID0ge1xuICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uKGQsIGtleSkge1xuICAgICAgICAgIHJldHVybiBmb3JnZS5wa2NzMS5kZWNvZGVfcnNhX29hZXAoa2V5LCBkLCBzY2hlbWVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYoWydSQVcnLCAnTk9ORScsICdOVUxMJywgbnVsbF0uaW5kZXhPZihzY2hlbWUpICE9PSAtMSkge1xuICAgICAgc2NoZW1lID0ge2RlY29kZTogZnVuY3Rpb24oZCkge3JldHVybiBkO319O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGVuY3J5cHRpb24gc2NoZW1lOiBcIicgKyBzY2hlbWUgKyAnXCIuJyk7XG4gICAgfVxuXG4gICAgLy8gZGVjb2RlIGFjY29yZGluZyB0byBzY2hlbWVcbiAgICByZXR1cm4gc2NoZW1lLmRlY29kZShkLCBrZXksIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2lnbnMgdGhlIGdpdmVuIGRpZ2VzdCwgcHJvZHVjaW5nIGEgc2lnbmF0dXJlLlxuICAgKlxuICAgKiBQS0NTIzEgc3VwcG9ydHMgbXVsdGlwbGUgKGN1cnJlbnRseSB0d28pIHNpZ25hdHVyZSBzY2hlbWVzOlxuICAgKiBSU0FTU0EtUEtDUzEtVjFfNSBhbmQgUlNBU1NBLVBTUy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCB0aGlzIGltcGxlbWVudGF0aW9uIHVzZXMgdGhlIFwib2xkIHNjaGVtZVwiLCBpLmUuXG4gICAqIFJTQVNTQS1QS0NTMS1WMV81LiBJbiBvcmRlciB0byBnZW5lcmF0ZSBhIFBTUyBzaWduYXR1cmUsIHByb3ZpZGVcbiAgICogYW4gaW5zdGFuY2Ugb2YgRm9yZ2UgUFNTIG9iamVjdCBhcyB0aGUgc2NoZW1lIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3Qgd2l0aCB0aGUgaGFzaCB0byBzaWduLlxuICAgKiBAcGFyYW0gc2NoZW1lIHRoZSBzaWduYXR1cmUgc2NoZW1lIHRvIHVzZTpcbiAgICogICAgICAgICAgJ1JTQVNTQS1QS0NTMS1WMV81JyBvciB1bmRlZmluZWQgZm9yIFJTQVNTQSBQS0NTIzEgdjEuNSxcbiAgICogICAgICAgICAgYSBGb3JnZSBQU1Mgb2JqZWN0IGZvciBSU0FTU0EtUFNTLFxuICAgKiAgICAgICAgICAnTk9ORScgb3IgbnVsbCBmb3Igbm9uZSwgRGlnZXN0SW5mbyB3aWxsIG5vdCBiZSB1c2VkIGJ1dFxuICAgKiAgICAgICAgICAgIFBLQ1MjMSB2MS41IHBhZGRpbmcgd2lsbCBzdGlsbCBiZSB1c2VkLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBzaWduYXR1cmUgYXMgYSBieXRlIHN0cmluZy5cbiAgICovXG4gIGtleS5zaWduID0gZnVuY3Rpb24obWQsIHNjaGVtZSkge1xuICAgIC8qIE5vdGU6IFRoZSBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBSU0Egb3BlcmF0aW9ucyBpcyBiZWluZ1xuICAgICAgdHJhbnNpdGlvbmVkIGF3YXkgZnJvbSBhIFBLQ1MjMSB2MS41IGhhcmQtY29kZWQgc2NoZW1lLiBTb21lIGxlZ2FjeVxuICAgICAgY29kZSBsaWtlIHRoZSB1c2Ugb2YgYW4gZW5jb2RpbmcgYmxvY2sgaWRlbnRpZmllciAnYnQnIHdpbGwgZXZlbnR1YWxseVxuICAgICAgYmUgcmVtb3ZlZC4gKi9cblxuICAgIC8vIHByaXZhdGUga2V5IG9wZXJhdGlvblxuICAgIHZhciBidCA9IGZhbHNlO1xuXG4gICAgaWYodHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNjaGVtZSA9IHNjaGVtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmKHNjaGVtZSA9PT0gdW5kZWZpbmVkIHx8IHNjaGVtZSA9PT0gJ1JTQVNTQS1QS0NTMS1WMV81Jykge1xuICAgICAgc2NoZW1lID0ge2VuY29kZTogZW1zYVBrY3MxdjE1ZW5jb2RlfTtcbiAgICAgIGJ0ID0gMHgwMTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSAnTk9ORScgfHwgc2NoZW1lID09PSAnTlVMTCcgfHwgc2NoZW1lID09PSBudWxsKSB7XG4gICAgICBzY2hlbWUgPSB7ZW5jb2RlOiBmdW5jdGlvbigpIHtyZXR1cm4gbWQ7fX07XG4gICAgICBidCA9IDB4MDE7XG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIGFuZCB0aGVuIGVuY3J5cHRcbiAgICB2YXIgZCA9IHNjaGVtZS5lbmNvZGUobWQsIGtleS5uLmJpdExlbmd0aCgpKTtcbiAgICByZXR1cm4gcGtpLnJzYS5lbmNyeXB0KGQsIGtleSwgYnQpO1xuICB9O1xuXG4gIHJldHVybiBrZXk7XG59O1xuXG4vKipcbiAqIFdyYXBzIGFuIFJTQVByaXZhdGVLZXkgQVNOLjEgb2JqZWN0IGluIGFuIEFTTi4xIFByaXZhdGVLZXlJbmZvIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gcnNhS2V5IHRoZSBBU04uMSBSU0FQcml2YXRlS2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIEFTTi4xIFByaXZhdGVLZXlJbmZvLlxuICovXG5wa2kud3JhcFJzYVByaXZhdGVLZXkgPSBmdW5jdGlvbihyc2FLZXkpIHtcbiAgLy8gUHJpdmF0ZUtleUluZm9cbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uICgwKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBhc24xLmludGVnZXJUb0RlcigwKS5nZXRCeXRlcygpKSxcbiAgICAvLyBwcml2YXRlS2V5QWxnb3JpdGhtXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5yc2FFbmNyeXB0aW9uKS5nZXRCeXRlcygpKSxcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgIF0pLFxuICAgIC8vIFByaXZhdGVLZXlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSxcbiAgICAgIGFzbjEudG9EZXIocnNhS2V5KS5nZXRCeXRlcygpKVxuICBdKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwcml2YXRlIGtleSBmcm9tIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBBU04uMSByZXByZXNlbnRhdGlvbiBvZiBhIFByaXZhdGVLZXlJbmZvIGNvbnRhaW5pbmcgYW5cbiAqICAgICAgICAgIFJTQVByaXZhdGVLZXkgb3IgYW4gUlNBUHJpdmF0ZUtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwcml2YXRlIGtleS5cbiAqL1xucGtpLnByaXZhdGVLZXlGcm9tQXNuMSA9IGZ1bmN0aW9uKG9iaikge1xuICAvLyBnZXQgUHJpdmF0ZUtleUluZm9cbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZihhc24xLnZhbGlkYXRlKG9iaiwgcHJpdmF0ZUtleVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIG9iaiA9IGFzbjEuZnJvbURlcihmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXkpKTtcbiAgfVxuXG4gIC8vIGdldCBSU0FQcml2YXRlS2V5XG4gIGNhcHR1cmUgPSB7fTtcbiAgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKG9iaiwgcnNhUHJpdmF0ZUtleVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgcHJpdmF0ZSBrZXkuICcgK1xuICAgICAgJ0FTTi4xIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGFuIFJTQVByaXZhdGVLZXkuJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gTm90ZTogVmVyc2lvbiBpcyBjdXJyZW50bHkgaWdub3JlZC5cbiAgLy8gY2FwdHVyZS5wcml2YXRlS2V5VmVyc2lvblxuICAvLyBGSVhNRTogaW5lZmZpY2llbnQsIGdldCBhIEJpZ0ludGVnZXIgdGhhdCB1c2VzIGJ5dGUgc3RyaW5nc1xuICB2YXIgbiwgZSwgZCwgcCwgcSwgZFAsIGRRLCBxSW52O1xuICBuID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5TW9kdWx1cykudG9IZXgoKTtcbiAgZSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleVB1YmxpY0V4cG9uZW50KS50b0hleCgpO1xuICBkID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5UHJpdmF0ZUV4cG9uZW50KS50b0hleCgpO1xuICBwID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5UHJpbWUxKS50b0hleCgpO1xuICBxID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5UHJpbWUyKS50b0hleCgpO1xuICBkUCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleUV4cG9uZW50MSkudG9IZXgoKTtcbiAgZFEgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlFeHBvbmVudDIpLnRvSGV4KCk7XG4gIHFJbnYgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlDb2VmZmljaWVudCkudG9IZXgoKTtcblxuICAvLyBzZXQgcHJpdmF0ZSBrZXlcbiAgcmV0dXJuIHBraS5zZXRSc2FQcml2YXRlS2V5KFxuICAgIG5ldyBCaWdJbnRlZ2VyKG4sIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihlLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIoZCwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKHAsIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihxLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIoZFAsIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihkUSwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKHFJbnYsIDE2KSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgcHJpdmF0ZSBrZXkgdG8gYW4gQVNOLjEgUlNBUHJpdmF0ZUtleS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBwcml2YXRlIGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSByZXByZXNlbnRhdGlvbiBvZiBhbiBSU0FQcml2YXRlS2V5LlxuICovXG5wa2kucHJpdmF0ZUtleVRvQXNuMSA9IHBraS5wcml2YXRlS2V5VG9SU0FQcml2YXRlS2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gIC8vIFJTQVByaXZhdGVLZXlcbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uICgwID0gb25seSAyIHByaW1lcywgMSBtdWx0aXBsZSBwcmltZXMpXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGFzbjEuaW50ZWdlclRvRGVyKDApLmdldEJ5dGVzKCkpLFxuICAgIC8vIG1vZHVsdXMgKG4pXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5Lm4pKSxcbiAgICAvLyBwdWJsaWNFeHBvbmVudCAoZSlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkuZSkpLFxuICAgIC8vIHByaXZhdGVFeHBvbmVudCAoZClcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkuZCkpLFxuICAgIC8vIHByaXZhdGVLZXlQcmltZTEgKHApXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5LnApKSxcbiAgICAvLyBwcml2YXRlS2V5UHJpbWUyIChxKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5xKSksXG4gICAgLy8gcHJpdmF0ZUtleUV4cG9uZW50MSAoZFApXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5LmRQKSksXG4gICAgLy8gcHJpdmF0ZUtleUV4cG9uZW50MiAoZFEpXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5LmRRKSksXG4gICAgLy8gY29lZmZpY2llbnQgKHFJbnYpXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5LnFJbnYpKVxuICBdKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IGZyb20gYW4gQVNOLjEgU3ViamVjdFB1YmxpY0tleUluZm8gb3IgUlNBUHVibGljS2V5LlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBTdWJqZWN0UHVibGljS2V5SW5mbyBvciBSU0FQdWJsaWNLZXkuXG4gKlxuICogQHJldHVybiB0aGUgcHVibGljIGtleS5cbiAqL1xucGtpLnB1YmxpY0tleUZyb21Bc24xID0gZnVuY3Rpb24ob2JqKSB7XG4gIC8vIGdldCBTdWJqZWN0UHVibGljS2V5SW5mb1xuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKGFzbjEudmFsaWRhdGUob2JqLCBwdWJsaWNLZXlWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAvLyBnZXQgb2lkXG4gICAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5wdWJsaWNLZXlPaWQpO1xuICAgIGlmKG9pZCAhPT0gcGtpLm9pZHMucnNhRW5jcnlwdGlvbikge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwdWJsaWMga2V5LiBVbmtub3duIE9JRC4nKTtcbiAgICAgIGVycm9yLm9pZCA9IG9pZDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBvYmogPSBjYXB0dXJlLnJzYVB1YmxpY0tleTtcbiAgfVxuXG4gIC8vIGdldCBSU0EgcGFyYW1zXG4gIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIHJzYVB1YmxpY0tleVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgcHVibGljIGtleS4gJyArXG4gICAgICAnQVNOLjEgb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gYW4gUlNBUHVibGljS2V5LicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIEZJWE1FOiBpbmVmZmljaWVudCwgZ2V0IGEgQmlnSW50ZWdlciB0aGF0IHVzZXMgYnl0ZSBzdHJpbmdzXG4gIHZhciBuID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wdWJsaWNLZXlNb2R1bHVzKS50b0hleCgpO1xuICB2YXIgZSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHVibGljS2V5RXhwb25lbnQpLnRvSGV4KCk7XG5cbiAgLy8gc2V0IHB1YmxpYyBrZXlcbiAgcmV0dXJuIHBraS5zZXRSc2FQdWJsaWNLZXkoXG4gICAgbmV3IEJpZ0ludGVnZXIobiwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKGUsIDE2KSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgcHVibGljIGtleSB0byBhbiBBU04uMSBTdWJqZWN0UHVibGljS2V5SW5mby5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBwdWJsaWMga2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBTdWJqZWN0UHVibGljS2V5SW5mby5cbiAqL1xucGtpLnB1YmxpY0tleVRvQXNuMSA9IHBraS5wdWJsaWNLZXlUb1N1YmplY3RQdWJsaWNLZXlJbmZvID0gZnVuY3Rpb24oa2V5KSB7XG4gIC8vIFN1YmplY3RQdWJsaWNLZXlJbmZvXG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gQWxnb3JpdGhtSWRlbnRpZmllclxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIC8vIGFsZ29yaXRobVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzLnJzYUVuY3J5cHRpb24pLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gcGFyYW1ldGVycyAobnVsbClcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgIF0pLFxuICAgIC8vIHN1YmplY3RQdWJsaWNLZXlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJJVFNUUklORywgZmFsc2UsIFtcbiAgICAgIHBraS5wdWJsaWNLZXlUb1JTQVB1YmxpY0tleShrZXkpXG4gICAgXSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgcHVibGljIGtleSB0byBhbiBBU04uMSBSU0FQdWJsaWNLZXkuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgcHVibGljIGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhc24xIHJlcHJlc2VudGF0aW9uIG9mIGEgUlNBUHVibGljS2V5LlxuICovXG5wa2kucHVibGljS2V5VG9SU0FQdWJsaWNLZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgLy8gUlNBUHVibGljS2V5XG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gbW9kdWx1cyAobilcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkubikpLFxuICAgIC8vIHB1YmxpY0V4cG9uZW50IChlKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5lKSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSBtZXNzYWdlIHVzaW5nIFBLQ1MjMSB2MS41IHBhZGRpbmcuXG4gKlxuICogQHBhcmFtIG0gdGhlIG1lc3NhZ2UgdG8gZW5jb2RlLlxuICogQHBhcmFtIGtleSB0aGUgUlNBIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gYnQgdGhlIGJsb2NrIHR5cGUgdG8gdXNlLCBpLmUuIGVpdGhlciAweDAxIChmb3Igc2lnbmluZykgb3IgMHgwMlxuICogICAgICAgICAgKGZvciBlbmNyeXB0aW9uKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwYWRkZWQgYnl0ZSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIF9lbmNvZGVQa2NzMV92MV81KG0sIGtleSwgYnQpIHtcbiAgdmFyIGViID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcblxuICAvLyBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgbW9kdWx1cyBpbiBieXRlc1xuICB2YXIgayA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuXG4gIC8qIHVzZSBQS0NTIzEgdjEuNSBwYWRkaW5nICovXG4gIGlmKG0ubGVuZ3RoID4gKGsgLSAxMSkpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ01lc3NhZ2UgaXMgdG9vIGxvbmcgZm9yIFBLQ1MjMSB2MS41IHBhZGRpbmcuJyk7XG4gICAgZXJyb3IubGVuZ3RoID0gbS5sZW5ndGg7XG4gICAgZXJyb3IubWF4ID0gayAtIDExO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLyogQSBibG9jayB0eXBlIEJULCBhIHBhZGRpbmcgc3RyaW5nIFBTLCBhbmQgdGhlIGRhdGEgRCBzaGFsbCBiZVxuICAgIGZvcm1hdHRlZCBpbnRvIGFuIG9jdGV0IHN0cmluZyBFQiwgdGhlIGVuY3J5cHRpb24gYmxvY2s6XG5cbiAgICBFQiA9IDAwIHx8IEJUIHx8IFBTIHx8IDAwIHx8IERcblxuICAgIFRoZSBibG9jayB0eXBlIEJUIHNoYWxsIGJlIGEgc2luZ2xlIG9jdGV0IGluZGljYXRpbmcgdGhlIHN0cnVjdHVyZSBvZlxuICAgIHRoZSBlbmNyeXB0aW9uIGJsb2NrLiBGb3IgdGhpcyB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCBpdCBzaGFsbCBoYXZlXG4gICAgdmFsdWUgMDAsIDAxLCBvciAwMi4gRm9yIGEgcHJpdmF0ZS1rZXkgb3BlcmF0aW9uLCB0aGUgYmxvY2sgdHlwZVxuICAgIHNoYWxsIGJlIDAwIG9yIDAxLiBGb3IgYSBwdWJsaWMta2V5IG9wZXJhdGlvbiwgaXQgc2hhbGwgYmUgMDIuXG5cbiAgICBUaGUgcGFkZGluZyBzdHJpbmcgUFMgc2hhbGwgY29uc2lzdCBvZiBrLTMtfHxEfHwgb2N0ZXRzLiBGb3IgYmxvY2tcbiAgICB0eXBlIDAwLCB0aGUgb2N0ZXRzIHNoYWxsIGhhdmUgdmFsdWUgMDA7IGZvciBibG9jayB0eXBlIDAxLCB0aGV5XG4gICAgc2hhbGwgaGF2ZSB2YWx1ZSBGRjsgYW5kIGZvciBibG9jayB0eXBlIDAyLCB0aGV5IHNoYWxsIGJlXG4gICAgcHNldWRvcmFuZG9tbHkgZ2VuZXJhdGVkIGFuZCBub256ZXJvLiBUaGlzIG1ha2VzIHRoZSBsZW5ndGggb2YgdGhlXG4gICAgZW5jcnlwdGlvbiBibG9jayBFQiBlcXVhbCB0byBrLiAqL1xuXG4gIC8vIGJ1aWxkIHRoZSBlbmNyeXB0aW9uIGJsb2NrXG4gIGViLnB1dEJ5dGUoMHgwMCk7XG4gIGViLnB1dEJ5dGUoYnQpO1xuXG4gIC8vIGNyZWF0ZSB0aGUgcGFkZGluZ1xuICB2YXIgcGFkTnVtID0gayAtIDMgLSBtLmxlbmd0aDtcbiAgdmFyIHBhZEJ5dGU7XG4gIC8vIHByaXZhdGUga2V5IG9wXG4gIGlmKGJ0ID09PSAweDAwIHx8IGJ0ID09PSAweDAxKSB7XG4gICAgcGFkQnl0ZSA9IChidCA9PT0gMHgwMCkgPyAweDAwIDogMHhGRjtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGFkTnVtOyArK2kpIHtcbiAgICAgIGViLnB1dEJ5dGUocGFkQnl0ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHB1YmxpYyBrZXkgb3BcbiAgICAvLyBwYWQgd2l0aCByYW5kb20gbm9uLXplcm8gdmFsdWVzXG4gICAgd2hpbGUocGFkTnVtID4gMCkge1xuICAgICAgdmFyIG51bVplcm9zID0gMDtcbiAgICAgIHZhciBwYWRCeXRlcyA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlcyhwYWROdW0pO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHBhZE51bTsgKytpKSB7XG4gICAgICAgIHBhZEJ5dGUgPSBwYWRCeXRlcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZihwYWRCeXRlID09PSAwKSB7XG4gICAgICAgICAgKytudW1aZXJvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlYi5wdXRCeXRlKHBhZEJ5dGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYWROdW0gPSBudW1aZXJvcztcbiAgICB9XG4gIH1cblxuICAvLyB6ZXJvIGZvbGxvd2VkIGJ5IG1lc3NhZ2VcbiAgZWIucHV0Qnl0ZSgweDAwKTtcbiAgZWIucHV0Qnl0ZXMobSk7XG5cbiAgcmV0dXJuIGViO1xufVxuXG4vKipcbiAqIERlY29kZXMgYSBtZXNzYWdlIHVzaW5nIFBLQ1MjMSB2MS41IHBhZGRpbmcuXG4gKlxuICogQHBhcmFtIGVtIHRoZSBtZXNzYWdlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBrZXkgdGhlIFJTQSBrZXkgdG8gdXNlLlxuICogQHBhcmFtIHB1YiB0cnVlIGlmIHRoZSBrZXkgaXMgYSBwdWJsaWMga2V5LCBmYWxzZSBpZiBpdCBpcyBwcml2YXRlLlxuICogQHBhcmFtIG1sIHRoZSBtZXNzYWdlIGxlbmd0aCwgaWYgc3BlY2lmaWVkLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlY29kZWQgYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIF9kZWNvZGVQa2NzMV92MV81KGVtLCBrZXksIHB1YiwgbWwpIHtcbiAgLy8gZ2V0IHRoZSBsZW5ndGggb2YgdGhlIG1vZHVsdXMgaW4gYnl0ZXNcbiAgdmFyIGsgPSBNYXRoLmNlaWwoa2V5Lm4uYml0TGVuZ3RoKCkgLyA4KTtcblxuICAvKiBJdCBpcyBhbiBlcnJvciBpZiBhbnkgb2YgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIG9jY3VyczpcblxuICAgIDEuIFRoZSBlbmNyeXB0aW9uIGJsb2NrIEVCIGNhbm5vdCBiZSBwYXJzZWQgdW5hbWJpZ3VvdXNseS5cbiAgICAyLiBUaGUgcGFkZGluZyBzdHJpbmcgUFMgY29uc2lzdHMgb2YgZmV3ZXIgdGhhbiBlaWdodCBvY3RldHNcbiAgICAgIG9yIGlzIGluY29uc2lzZW50IHdpdGggdGhlIGJsb2NrIHR5cGUgQlQuXG4gICAgMy4gVGhlIGRlY3J5cHRpb24gcHJvY2VzcyBpcyBhIHB1YmxpYy1rZXkgb3BlcmF0aW9uIGFuZCB0aGUgYmxvY2tcbiAgICAgIHR5cGUgQlQgaXMgbm90IDAwIG9yIDAxLCBvciB0aGUgZGVjcnlwdGlvbiBwcm9jZXNzIGlzIGFcbiAgICAgIHByaXZhdGUta2V5IG9wZXJhdGlvbiBhbmQgdGhlIGJsb2NrIHR5cGUgaXMgbm90IDAyLlxuICAgKi9cblxuICAvLyBwYXJzZSB0aGUgZW5jcnlwdGlvbiBibG9ja1xuICB2YXIgZWIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihlbSk7XG4gIHZhciBmaXJzdCA9IGViLmdldEJ5dGUoKTtcbiAgdmFyIGJ0ID0gZWIuZ2V0Qnl0ZSgpO1xuICBpZihmaXJzdCAhPT0gMHgwMCB8fFxuICAgIChwdWIgJiYgYnQgIT09IDB4MDAgJiYgYnQgIT09IDB4MDEpIHx8XG4gICAgKCFwdWIgJiYgYnQgIT0gMHgwMikgfHxcbiAgICAocHViICYmIGJ0ID09PSAweDAwICYmIHR5cGVvZihtbCkgPT09ICd1bmRlZmluZWQnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiBibG9jayBpcyBpbnZhbGlkLicpO1xuICB9XG5cbiAgdmFyIHBhZE51bSA9IDA7XG4gIGlmKGJ0ID09PSAweDAwKSB7XG4gICAgLy8gY2hlY2sgYWxsIHBhZGRpbmcgYnl0ZXMgZm9yIDB4MDBcbiAgICBwYWROdW0gPSBrIC0gMyAtIG1sO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYWROdW07ICsraSkge1xuICAgICAgaWYoZWIuZ2V0Qnl0ZSgpICE9PSAweDAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiBibG9jayBpcyBpbnZhbGlkLicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmKGJ0ID09PSAweDAxKSB7XG4gICAgLy8gZmluZCB0aGUgZmlyc3QgYnl0ZSB0aGF0IGlzbid0IDB4RkYsIHNob3VsZCBiZSBhZnRlciBhbGwgcGFkZGluZ1xuICAgIHBhZE51bSA9IDA7XG4gICAgd2hpbGUoZWIubGVuZ3RoKCkgPiAxKSB7XG4gICAgICBpZihlYi5nZXRCeXRlKCkgIT09IDB4RkYpIHtcbiAgICAgICAgLS1lYi5yZWFkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgICsrcGFkTnVtO1xuICAgIH1cbiAgfSBlbHNlIGlmKGJ0ID09PSAweDAyKSB7XG4gICAgLy8gbG9vayBmb3IgMHgwMCBieXRlXG4gICAgcGFkTnVtID0gMDtcbiAgICB3aGlsZShlYi5sZW5ndGgoKSA+IDEpIHtcbiAgICAgIGlmKGViLmdldEJ5dGUoKSA9PT0gMHgwMCkge1xuICAgICAgICAtLWViLnJlYWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgKytwYWROdW07XG4gICAgfVxuICB9XG5cbiAgLy8gemVybyBtdXN0IGJlIDB4MDAgYW5kIHBhZE51bSBtdXN0IGJlIChrIC0gMyAtIG1lc3NhZ2UgbGVuZ3RoKVxuICB2YXIgemVybyA9IGViLmdldEJ5dGUoKTtcbiAgaWYoemVybyAhPT0gMHgwMCB8fCBwYWROdW0gIT09IChrIC0gMyAtIGViLmxlbmd0aCgpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiBibG9jayBpcyBpbnZhbGlkLicpO1xuICB9XG5cbiAgcmV0dXJuIGViLmdldEJ5dGVzKCk7XG59XG5cbi8qKlxuICogUnVucyB0aGUga2V5LWdlbmVyYXRpb24gYWxnb3JpdGhtIGFzeW5jaHJvbm91c2x5LCBlaXRoZXIgaW4gdGhlIGJhY2tncm91bmRcbiAqIHZpYSBXZWIgV29ya2Vycywgb3IgdXNpbmcgdGhlIG1haW4gdGhyZWFkIGFuZCBzZXRJbW1lZGlhdGUuXG4gKlxuICogQHBhcmFtIHN0YXRlIHRoZSBrZXktcGFpciBnZW5lcmF0aW9uIHN0YXRlLlxuICogQHBhcmFtIFtvcHRpb25zXSBvcHRpb25zIGZvciBrZXktcGFpciBnZW5lcmF0aW9uOlxuICogICAgICAgICAgd29ya2VyU2NyaXB0IHRoZSB3b3JrZXIgc2NyaXB0IFVSTC5cbiAqICAgICAgICAgIHdvcmtlcnMgdGhlIG51bWJlciBvZiB3ZWIgd29ya2VycyAoaWYgc3VwcG9ydGVkKSB0byB1c2UsXG4gKiAgICAgICAgICAgIChkZWZhdWx0OiAyLCAtMSB0byB1c2UgZXN0aW1hdGVkIGNvcmVzIG1pbnVzIG9uZSkuXG4gKiAgICAgICAgICB3b3JrTG9hZCB0aGUgc2l6ZSBvZiB0aGUgd29yayBsb2FkLCBpZTogbnVtYmVyIG9mIHBvc3NpYmxlIHByaW1lXG4gKiAgICAgICAgICAgIG51bWJlcnMgZm9yIGVhY2ggd2ViIHdvcmtlciB0byBjaGVjayBwZXIgd29yayBhc3NpZ25tZW50LFxuICogICAgICAgICAgICAoZGVmYXVsdDogMTAwKS5cbiAqIEBwYXJhbSBjYWxsYmFjayhlcnIsIGtleXBhaXIpIGNhbGxlZCBvbmNlIHRoZSBvcGVyYXRpb24gY29tcGxldGVzLlxuICovXG5mdW5jdGlvbiBfZ2VuZXJhdGVLZXlQYWlyKHN0YXRlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIG9wdHMgPSB7XG4gICAgYWxnb3JpdGhtOiB7XG4gICAgICBuYW1lOiBvcHRpb25zLmFsZ29yaXRobSB8fCAnUFJJTUVJTkMnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICB3b3JrZXJzOiBvcHRpb25zLndvcmtlcnMgfHwgMixcbiAgICAgICAgd29ya0xvYWQ6IG9wdGlvbnMud29ya0xvYWQgfHwgMTAwLFxuICAgICAgICB3b3JrZXJTY3JpcHQ6IG9wdGlvbnMud29ya2VyU2NyaXB0XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBpZigncHJuZycgaW4gb3B0aW9ucykge1xuICAgIG9wdHMucHJuZyA9IG9wdGlvbnMucHJuZztcbiAgfVxuXG4gIGdlbmVyYXRlKCk7XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGUoKSB7XG4gICAgLy8gZmluZCBwIGFuZCB0aGVuIHEgKGRvbmUgaW4gc2VyaWVzIHRvIHNpbXBsaWZ5KVxuICAgIGdldFByaW1lKHN0YXRlLnBCaXRzLCBmdW5jdGlvbihlcnIsIG51bSkge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucCA9IG51bTtcbiAgICAgIGlmKHN0YXRlLnEgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZpbmlzaChlcnIsIHN0YXRlLnEpO1xuICAgICAgfVxuICAgICAgZ2V0UHJpbWUoc3RhdGUucUJpdHMsIGZpbmlzaCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQcmltZShiaXRzLCBjYWxsYmFjaykge1xuICAgIGZvcmdlLnByaW1lLmdlbmVyYXRlUHJvYmFibGVQcmltZShiaXRzLCBvcHRzLCBjYWxsYmFjayk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2goZXJyLCBudW0pIHtcbiAgICBpZihlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIH1cblxuICAgIC8vIHNldCBxXG4gICAgc3RhdGUucSA9IG51bTtcblxuICAgIC8vIGVuc3VyZSBwIGlzIGxhcmdlciB0aGFuIHEgKHN3YXAgdGhlbSBpZiBub3QpXG4gICAgaWYoc3RhdGUucC5jb21wYXJlVG8oc3RhdGUucSkgPCAwKSB7XG4gICAgICB2YXIgdG1wID0gc3RhdGUucDtcbiAgICAgIHN0YXRlLnAgPSBzdGF0ZS5xO1xuICAgICAgc3RhdGUucSA9IHRtcDtcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgcCBpcyBjb3ByaW1lIHdpdGggZVxuICAgIGlmKHN0YXRlLnAuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpLmdjZChzdGF0ZS5lKVxuICAgICAgLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgIT09IDApIHtcbiAgICAgIHN0YXRlLnAgPSBudWxsO1xuICAgICAgZ2VuZXJhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgcSBpcyBjb3ByaW1lIHdpdGggZVxuICAgIGlmKHN0YXRlLnEuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpLmdjZChzdGF0ZS5lKVxuICAgICAgLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgIT09IDApIHtcbiAgICAgIHN0YXRlLnEgPSBudWxsO1xuICAgICAgZ2V0UHJpbWUoc3RhdGUucUJpdHMsIGZpbmlzaCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY29tcHV0ZSBwaGk6IChwIC0gMSkocSAtIDEpIChFdWxlcidzIHRvdGllbnQgZnVuY3Rpb24pXG4gICAgc3RhdGUucDEgPSBzdGF0ZS5wLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcbiAgICBzdGF0ZS5xMSA9IHN0YXRlLnEuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgIHN0YXRlLnBoaSA9IHN0YXRlLnAxLm11bHRpcGx5KHN0YXRlLnExKTtcblxuICAgIC8vIGVuc3VyZSBlIGFuZCBwaGkgYXJlIGNvcHJpbWVcbiAgICBpZihzdGF0ZS5waGkuZ2NkKHN0YXRlLmUpLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgIT09IDApIHtcbiAgICAgIC8vIHBoaSBhbmQgZSBhcmVuJ3QgY29wcmltZSwgc28gZ2VuZXJhdGUgYSBuZXcgcCBhbmQgcVxuICAgICAgc3RhdGUucCA9IHN0YXRlLnEgPSBudWxsO1xuICAgICAgZ2VuZXJhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgbiwgZW5zdXJlIG4gaXMgaGFzIHRoZSByaWdodCBudW1iZXIgb2YgYml0c1xuICAgIHN0YXRlLm4gPSBzdGF0ZS5wLm11bHRpcGx5KHN0YXRlLnEpO1xuICAgIGlmKHN0YXRlLm4uYml0TGVuZ3RoKCkgIT09IHN0YXRlLmJpdHMpIHtcbiAgICAgIC8vIGZhaWxlZCwgZ2V0IG5ldyBxXG4gICAgICBzdGF0ZS5xID0gbnVsbDtcbiAgICAgIGdldFByaW1lKHN0YXRlLnFCaXRzLCBmaW5pc2gpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNldCBrZXlzXG4gICAgdmFyIGQgPSBzdGF0ZS5lLm1vZEludmVyc2Uoc3RhdGUucGhpKTtcbiAgICBzdGF0ZS5rZXlzID0ge1xuICAgICAgcHJpdmF0ZUtleTogcGtpLnJzYS5zZXRQcml2YXRlS2V5KFxuICAgICAgICBzdGF0ZS5uLCBzdGF0ZS5lLCBkLCBzdGF0ZS5wLCBzdGF0ZS5xLFxuICAgICAgICBkLm1vZChzdGF0ZS5wMSksIGQubW9kKHN0YXRlLnExKSxcbiAgICAgICAgc3RhdGUucS5tb2RJbnZlcnNlKHN0YXRlLnApKSxcbiAgICAgIHB1YmxpY0tleTogcGtpLnJzYS5zZXRQdWJsaWNLZXkoc3RhdGUubiwgc3RhdGUuZSlcbiAgICB9O1xuXG4gICAgY2FsbGJhY2sobnVsbCwgc3RhdGUua2V5cyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHBvc2l0aXZlIEJpZ0ludGVnZXIgaW50byAyJ3MtY29tcGxlbWVudCBiaWctZW5kaWFuIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBiaWcgaW50ZWdlciB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGVzLlxuICovXG5mdW5jdGlvbiBfYm5Ub0J5dGVzKGIpIHtcbiAgLy8gcHJlcGVuZCAweDAwIGlmIGZpcnN0IGJ5dGUgPj0gMHg4MFxuICB2YXIgaGV4ID0gYi50b1N0cmluZygxNik7XG4gIGlmKGhleFswXSA+PSAnOCcpIHtcbiAgICBoZXggPSAnMDAnICsgaGV4O1xuICB9XG4gIHZhciBieXRlcyA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhoZXgpO1xuXG4gIC8vIGVuc3VyZSBpbnRlZ2VyIGlzIG1pbmltYWxseS1lbmNvZGVkXG4gIGlmKGJ5dGVzLmxlbmd0aCA+IDEgJiZcbiAgICAvLyBsZWFkaW5nIDB4MDAgZm9yIHBvc2l0aXZlIGludGVnZXJcbiAgICAoKGJ5dGVzLmNoYXJDb2RlQXQoMCkgPT09IDAgJiZcbiAgICAoYnl0ZXMuY2hhckNvZGVBdCgxKSAmIDB4ODApID09PSAwKSB8fFxuICAgIC8vIGxlYWRpbmcgMHhGRiBmb3IgbmVnYXRpdmUgaW50ZWdlclxuICAgIChieXRlcy5jaGFyQ29kZUF0KDApID09PSAweEZGICYmXG4gICAgKGJ5dGVzLmNoYXJDb2RlQXQoMSkgJiAweDgwKSA9PT0gMHg4MCkpKSB7XG4gICAgcmV0dXJuIGJ5dGVzLnN1YnN0cigxKTtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIE1pbGxlci1SYWJpbiB0ZXN0cyB0byBnZW5lcmF0ZSBhXG4gKiBwcmltZSB3aXRoIGFuIGVycm9yIHByb2JhYmlsaXR5IG9mICgxLzIpXjgwLlxuICpcbiAqIFNlZSBIYW5kYm9vayBvZiBBcHBsaWVkIENyeXB0b2dyYXBoeSBDaGFwdGVyIDQsIFRhYmxlIDQuNC5cbiAqXG4gKiBAcGFyYW0gYml0cyB0aGUgYml0IHNpemUuXG4gKlxuICogQHJldHVybiB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGl0ZXJhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIF9nZXRNaWxsZXJSYWJpblRlc3RzKGJpdHMpIHtcbiAgaWYoYml0cyA8PSAxMDApIHJldHVybiAyNztcbiAgaWYoYml0cyA8PSAxNTApIHJldHVybiAxODtcbiAgaWYoYml0cyA8PSAyMDApIHJldHVybiAxNTtcbiAgaWYoYml0cyA8PSAyNTApIHJldHVybiAxMjtcbiAgaWYoYml0cyA8PSAzMDApIHJldHVybiA5O1xuICBpZihiaXRzIDw9IDM1MCkgcmV0dXJuIDg7XG4gIGlmKGJpdHMgPD0gNDAwKSByZXR1cm4gNztcbiAgaWYoYml0cyA8PSA1MDApIHJldHVybiA2O1xuICBpZihiaXRzIDw9IDYwMCkgcmV0dXJuIDU7XG4gIGlmKGJpdHMgPD0gODAwKSByZXR1cm4gNDtcbiAgaWYoYml0cyA8PSAxMjUwKSByZXR1cm4gMztcbiAgcmV0dXJuIDI7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgZmVhdHVyZSBkZXRlY3Rpb24gb24gdGhlIE5vZGUgY3J5cHRvIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0gZm4gdGhlIGZlYXR1cmUgKGZ1bmN0aW9uKSB0byBkZXRlY3QuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIGRldGVjdGVkLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIF9kZXRlY3ROb2RlQ3J5cHRvKGZuKSB7XG4gIHJldHVybiBmb3JnZS51dGlsLmlzTm9kZWpzICYmIHR5cGVvZiBfY3J5cHRvW2ZuXSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBmZWF0dXJlIGRldGVjdGlvbiBvbiB0aGUgU3VidGxlQ3J5cHRvIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0gZm4gdGhlIGZlYXR1cmUgKGZ1bmN0aW9uKSB0byBkZXRlY3QuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIGRldGVjdGVkLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIF9kZXRlY3RTdWJ0bGVDcnlwdG8oZm4pIHtcbiAgcmV0dXJuICh0eXBlb2YgdXRpbC5nbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgdXRpbC5nbG9iYWxTY29wZS5jcnlwdG8gPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHV0aWwuZ2xvYmFsU2NvcGUuY3J5cHRvLnN1YnRsZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgdXRpbC5nbG9iYWxTY29wZS5jcnlwdG8uc3VidGxlW2ZuXSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgZmVhdHVyZSBkZXRlY3Rpb24gb24gdGhlIGRlcHJlY2F0ZWQgTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXG4gKiBvdXRkYXRlZCBTdWJ0bGVDcnlwdG8gaW50ZXJmYWNlLiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIHVzZWQgYWZ0ZXJcbiAqIGNoZWNraW5nIGZvciB0aGUgbW9kZXJuLCBzdGFuZGFyZCBTdWJ0bGVDcnlwdG8gaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSBmbiB0aGUgZmVhdHVyZSAoZnVuY3Rpb24pIHRvIGRldGVjdC5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgZGV0ZWN0ZWQsIGZhbHNlIGlmIG5vdC5cbiAqL1xuZnVuY3Rpb24gX2RldGVjdFN1YnRsZU1zQ3J5cHRvKGZuKSB7XG4gIHJldHVybiAodHlwZW9mIHV0aWwuZ2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHV0aWwuZ2xvYmFsU2NvcGUubXNDcnlwdG8gPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHV0aWwuZ2xvYmFsU2NvcGUubXNDcnlwdG8uc3VidGxlID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB1dGlsLmdsb2JhbFNjb3BlLm1zQ3J5cHRvLnN1YnRsZVtmbl0gPT09ICdmdW5jdGlvbicpO1xufVxuXG5mdW5jdGlvbiBfaW50VG9VaW50OEFycmF5KHgpIHtcbiAgdmFyIGJ5dGVzID0gZm9yZ2UudXRpbC5oZXhUb0J5dGVzKHgudG9TdHJpbmcoMTYpKTtcbiAgdmFyIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmxlbmd0aCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7ICsraSkge1xuICAgIGJ1ZmZlcltpXSA9IGJ5dGVzLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gX3ByaXZhdGVLZXlGcm9tSndrKGp3aykge1xuICBpZihqd2sua3R5ICE9PSAnUlNBJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdVbnN1cHBvcnRlZCBrZXkgYWxnb3JpdGhtIFwiJyArIGp3ay5rdHkgKyAnXCI7IGFsZ29yaXRobSBtdXN0IGJlIFwiUlNBXCIuJyk7XG4gIH1cbiAgcmV0dXJuIHBraS5zZXRSc2FQcml2YXRlS2V5KFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2subiksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5lKSxcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLmQpLFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2sucCksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5xKSxcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLmRwKSxcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLmRxKSxcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLnFpKSk7XG59XG5cbmZ1bmN0aW9uIF9wdWJsaWNLZXlGcm9tSndrKGp3aykge1xuICBpZihqd2sua3R5ICE9PSAnUlNBJykge1xuICAgIHRocm93IG5ldyBFcnJvcignS2V5IGFsZ29yaXRobSBtdXN0IGJlIFwiUlNBXCIuJyk7XG4gIH1cbiAgcmV0dXJuIHBraS5zZXRSc2FQdWJsaWNLZXkoXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5uKSxcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLmUpKTtcbn1cblxuZnVuY3Rpb24gX2Jhc2U2NFRvQmlnSW50KGI2NCkge1xuICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoZm9yZ2UudXRpbC5ieXRlc1RvSGV4KGZvcmdlLnV0aWwuZGVjb2RlNjQoYjY0KSksIDE2KTtcbn1cbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJCaWdJbnRlZ2VyIiwianNibiIsIl9jcnlwdG8iLCJ1dGlsIiwiaXNOb2RlanMiLCJhc24xIiwicGtpIiwibW9kdWxlIiwiZXhwb3J0cyIsInJzYSIsIkdDRF8zMF9ERUxUQSIsInByaXZhdGVLZXlWYWxpZGF0b3IiLCJuYW1lIiwidGFnQ2xhc3MiLCJDbGFzcyIsIlVOSVZFUlNBTCIsInR5cGUiLCJUeXBlIiwiU0VRVUVOQ0UiLCJjb25zdHJ1Y3RlZCIsInZhbHVlIiwiSU5URUdFUiIsImNhcHR1cmUiLCJPSUQiLCJPQ1RFVFNUUklORyIsInJzYVByaXZhdGVLZXlWYWxpZGF0b3IiLCJyc2FQdWJsaWNLZXlWYWxpZGF0b3IiLCJwdWJsaWNLZXlWYWxpZGF0b3IiLCJjYXB0dXJlQXNuMSIsIkJJVFNUUklORyIsIm9wdGlvbmFsIiwiZGlnZXN0SW5mb1ZhbGlkYXRvciIsIk5VTEwiLCJlbXNhUGtjczF2MTVlbmNvZGUiLCJtZCIsIm9pZCIsImFsZ29yaXRobSIsIm9pZHMiLCJlcnJvciIsIkVycm9yIiwib2lkQnl0ZXMiLCJvaWRUb0RlciIsImdldEJ5dGVzIiwiZGlnZXN0SW5mbyIsImNyZWF0ZSIsImRpZ2VzdEFsZ29yaXRobSIsInB1c2giLCJkaWdlc3QiLCJ0b0RlciIsIl9tb2RQb3ciLCJ4Iiwia2V5IiwicHViIiwibW9kUG93IiwiZSIsIm4iLCJwIiwicSIsImQiLCJkUCIsIm1vZCIsInN1YnRyYWN0IiwiT05FIiwiZFEiLCJxSW52IiwibW9kSW52ZXJzZSIsInIiLCJieXRlc1RvSGV4IiwicmFuZG9tIiwiYml0TGVuZ3RoIiwiY29tcGFyZVRvIiwiZ2NkIiwiZXF1YWxzIiwibXVsdGlwbHkiLCJ4cCIsInhxIiwiYWRkIiwieSIsImVuY3J5cHQiLCJtIiwiYnQiLCJlYiIsImsiLCJNYXRoIiwiY2VpbCIsIl9lbmNvZGVQa2NzMV92MV81IiwiY3JlYXRlQnVmZmVyIiwicHV0Qnl0ZXMiLCJ0b0hleCIsInloZXgiLCJ0b1N0cmluZyIsImVkIiwiemVyb3MiLCJsZW5ndGgiLCJwdXRCeXRlIiwiaGV4VG9CeXRlcyIsImRlY3J5cHQiLCJtbCIsImV4cGVjdGVkIiwieGhleCIsIl9kZWNvZGVQa2NzMV92MV81IiwiY3JlYXRlS2V5UGFpckdlbmVyYXRpb25TdGF0ZSIsImJpdHMiLCJvcHRpb25zIiwicGFyc2VJbnQiLCJwcm5nIiwicm5nIiwibmV4dEJ5dGVzIiwiYiIsImdldEJ5dGVzU3luYyIsImkiLCJjaGFyQ29kZUF0IiwicnZhbCIsInN0YXRlIiwiZUludCIsInFCaXRzIiwicEJpdHMiLCJwcVN0YXRlIiwibnVtIiwia2V5cyIsImZyb21JbnQiLCJzdGVwS2V5UGFpckdlbmVyYXRpb25TdGF0ZSIsIlRISVJUWSIsImRlbHRhSWR4Iiwib3Bfb3IiLCJ0MSIsIkRhdGUiLCJ0MiIsInRvdGFsIiwiYml0czEiLCJ0ZXN0Qml0IiwiYml0d2lzZVRvIiwic2hpZnRMZWZ0IiwiZEFkZE9mZnNldCIsImJ5dGVWYWx1ZSIsImlzUHJvYmFibGVQcmltZSIsIl9nZXRNaWxsZXJSYWJpblRlc3RzIiwicDEiLCJxMSIsInBoaSIsInByaXZhdGVLZXkiLCJzZXRQcml2YXRlS2V5IiwicHVibGljS2V5Iiwic2V0UHVibGljS2V5IiwiZ2VuZXJhdGVLZXlQYWlyIiwiY2FsbGJhY2siLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJ1c2VQdXJlSmF2YVNjcmlwdCIsIl9kZXRlY3ROb2RlQ3J5cHRvIiwibW9kdWx1c0xlbmd0aCIsInB1YmxpY0V4cG9uZW50IiwicHVibGljS2V5RW5jb2RpbmciLCJmb3JtYXQiLCJwcml2YXRlS2V5RW5jb2RpbmciLCJlcnIiLCJwcml2IiwicHJpdmF0ZUtleUZyb21QZW0iLCJwdWJsaWNLZXlGcm9tUGVtIiwiX2RldGVjdFN1YnRsZUNyeXB0byIsImdsb2JhbFNjb3BlIiwiY3J5cHRvIiwic3VidGxlIiwiZ2VuZXJhdGVLZXkiLCJfaW50VG9VaW50OEFycmF5IiwiaGFzaCIsInRoZW4iLCJwYWlyIiwiZXhwb3J0S2V5IiwicGtjczgiLCJwcml2YXRlS2V5RnJvbUFzbjEiLCJmcm9tRGVyIiwic2V0UnNhUHVibGljS2V5IiwiX2RldGVjdFN1YnRsZU1zQ3J5cHRvIiwiZ2VuT3AiLCJtc0NyeXB0byIsIm9uY29tcGxldGUiLCJ0YXJnZXQiLCJyZXN1bHQiLCJleHBvcnRPcCIsIm9uZXJyb3IiLCJrZXlwYWlyIiwiZ2VuZXJhdGVLZXlQYWlyU3luYyIsIl9nZW5lcmF0ZUtleVBhaXIiLCJkYXRhIiwic2NoZW1lIiwic2NoZW1lT3B0aW9ucyIsInRvVXBwZXJDYXNlIiwiZW5jb2RlIiwicGtjczEiLCJlbmNvZGVfcnNhX29hZXAiLCJpbmRleE9mIiwidmVyaWZ5Iiwic2lnbmF0dXJlIiwiX3BhcnNlQWxsRGlnZXN0Qnl0ZXMiLCJvYmoiLCJwYXJzZUFsbEJ5dGVzIiwiZXJyb3JzIiwidmFsaWRhdGUiLCJkZXJUb09pZCIsImFsZ29yaXRobUlkZW50aWZpZXIiLCJtZDIiLCJtZDUiLCJzaGExIiwic2hhMjI0Iiwic2hhMjU2Iiwic2hhMzg0Iiwic2hhNTEyIiwic2V0UnNhUHJpdmF0ZUtleSIsImRlY29kZSIsImRlY29kZV9yc2Ffb2FlcCIsInNpZ24iLCJ3cmFwUnNhUHJpdmF0ZUtleSIsInJzYUtleSIsImludGVnZXJUb0RlciIsInJzYUVuY3J5cHRpb24iLCJwcml2YXRlS2V5TW9kdWx1cyIsInByaXZhdGVLZXlQdWJsaWNFeHBvbmVudCIsInByaXZhdGVLZXlQcml2YXRlRXhwb25lbnQiLCJwcml2YXRlS2V5UHJpbWUxIiwicHJpdmF0ZUtleVByaW1lMiIsInByaXZhdGVLZXlFeHBvbmVudDEiLCJwcml2YXRlS2V5RXhwb25lbnQyIiwicHJpdmF0ZUtleUNvZWZmaWNpZW50IiwicHJpdmF0ZUtleVRvQXNuMSIsInByaXZhdGVLZXlUb1JTQVByaXZhdGVLZXkiLCJfYm5Ub0J5dGVzIiwicHVibGljS2V5RnJvbUFzbjEiLCJwdWJsaWNLZXlPaWQiLCJyc2FQdWJsaWNLZXkiLCJwdWJsaWNLZXlNb2R1bHVzIiwicHVibGljS2V5RXhwb25lbnQiLCJwdWJsaWNLZXlUb0FzbjEiLCJwdWJsaWNLZXlUb1N1YmplY3RQdWJsaWNLZXlJbmZvIiwicHVibGljS2V5VG9SU0FQdWJsaWNLZXkiLCJtYXgiLCJwYWROdW0iLCJwYWRCeXRlIiwibnVtWmVyb3MiLCJwYWRCeXRlcyIsImVtIiwiZmlyc3QiLCJnZXRCeXRlIiwicmVhZCIsInplcm8iLCJvcHRzIiwid29ya2VycyIsIndvcmtMb2FkIiwid29ya2VyU2NyaXB0IiwiZ2VuZXJhdGUiLCJnZXRQcmltZSIsImZpbmlzaCIsInByaW1lIiwiZ2VuZXJhdGVQcm9iYWJsZVByaW1lIiwidG1wIiwiaGV4IiwiYnl0ZXMiLCJzdWJzdHIiLCJmbiIsImJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJfcHJpdmF0ZUtleUZyb21Kd2siLCJqd2siLCJrdHkiLCJfYmFzZTY0VG9CaWdJbnQiLCJkcCIsImRxIiwicWkiLCJfcHVibGljS2V5RnJvbUp3ayIsImI2NCIsImRlY29kZTY0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/rsa.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/sha1.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/sha1.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Secure Hash Algorithm with 160-bit digest (SHA-1) implementation.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2015 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./md */ \"(rsc)/./node_modules/node-forge/lib/md.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\nvar sha1 = module.exports = forge.sha1 = forge.sha1 || {};\nforge.md.sha1 = forge.md.algorithms.sha1 = sha1;\n/**\n * Creates a SHA-1 message digest object.\n *\n * @return a message digest object.\n */ sha1.create = function() {\n    // do initialization as necessary\n    if (!_initialized) {\n        _init();\n    }\n    // SHA-1 state contains five 32-bit integers\n    var _state = null;\n    // input buffer\n    var _input = forge.util.createBuffer();\n    // used for word storage\n    var _w = new Array(80);\n    // message digest object\n    var md = {\n        algorithm: \"sha1\",\n        blockLength: 64,\n        digestLength: 20,\n        // 56-bit length of message so far (does not including padding)\n        messageLength: 0,\n        // true message length\n        fullMessageLength: null,\n        // size of message length in bytes\n        messageLengthSize: 8\n    };\n    /**\n   * Starts the digest.\n   *\n   * @return this digest object.\n   */ md.start = function() {\n        // up to 56-bit message length for convenience\n        md.messageLength = 0;\n        // full message length (set md.messageLength64 for backwards-compatibility)\n        md.fullMessageLength = md.messageLength64 = [];\n        var int32s = md.messageLengthSize / 4;\n        for(var i = 0; i < int32s; ++i){\n            md.fullMessageLength.push(0);\n        }\n        _input = forge.util.createBuffer();\n        _state = {\n            h0: 0x67452301,\n            h1: 0xEFCDAB89,\n            h2: 0x98BADCFE,\n            h3: 0x10325476,\n            h4: 0xC3D2E1F0\n        };\n        return md;\n    };\n    // start digest automatically for first time\n    md.start();\n    /**\n   * Updates the digest with the given message input. The given input can\n   * treated as raw input (no encoding will be applied) or an encoding of\n   * 'utf8' maybe given to encode the input using UTF-8.\n   *\n   * @param msg the message input to update with.\n   * @param encoding the encoding to use (default: 'raw', other: 'utf8').\n   *\n   * @return this digest object.\n   */ md.update = function(msg, encoding) {\n        if (encoding === \"utf8\") {\n            msg = forge.util.encodeUtf8(msg);\n        }\n        // update message length\n        var len = msg.length;\n        md.messageLength += len;\n        len = [\n            len / 0x100000000 >>> 0,\n            len >>> 0\n        ];\n        for(var i = md.fullMessageLength.length - 1; i >= 0; --i){\n            md.fullMessageLength[i] += len[1];\n            len[1] = len[0] + (md.fullMessageLength[i] / 0x100000000 >>> 0);\n            md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\n            len[0] = len[1] / 0x100000000 >>> 0;\n        }\n        // add bytes to input buffer\n        _input.putBytes(msg);\n        // process bytes\n        _update(_state, _w, _input);\n        // compact input buffer every 2K or if empty\n        if (_input.read > 2048 || _input.length() === 0) {\n            _input.compact();\n        }\n        return md;\n    };\n    /**\n   * Produces the digest.\n   *\n   * @return a byte buffer containing the digest value.\n   */ md.digest = function() {\n        /* Note: Here we copy the remaining bytes in the input buffer and\n    add the appropriate SHA-1 padding. Then we do the final update\n    on a copy of the state so that if the user wants to get\n    intermediate digests they can do so. */ /* Determine the number of bytes that must be added to the message\n    to ensure its length is congruent to 448 mod 512. In other words,\n    the data to be digested must be a multiple of 512 bits (or 128 bytes).\n    This data includes the message, some padding, and the length of the\n    message. Since the length of the message will be encoded as 8 bytes (64\n    bits), that means that the last segment of the data must have 56 bytes\n    (448 bits) of message and padding. Therefore, the length of the message\n    plus the padding must be congruent to 448 mod 512 because\n    512 - 128 = 448.\n\n    In order to fill up the message length it must be filled with\n    padding that begins with 1 bit followed by all 0 bits. Padding\n    must *always* be present, so if the message length is already\n    congruent to 448 mod 512, then 512 padding bits must be added. */ var finalBlock = forge.util.createBuffer();\n        finalBlock.putBytes(_input.bytes());\n        // compute remaining size to be digested (include message length size)\n        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;\n        // add padding for overflow blockSize - overflow\n        // _padding starts with 1 byte with first bit is set (byte value 128), then\n        // there may be up to (blockSize - 1) other pad bytes\n        var overflow = remaining & md.blockLength - 1;\n        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\n        // serialize message length in bits in big-endian order; since length\n        // is stored in bytes we multiply by 8 and add carry from next int\n        var next, carry;\n        var bits = md.fullMessageLength[0] * 8;\n        for(var i = 0; i < md.fullMessageLength.length - 1; ++i){\n            next = md.fullMessageLength[i + 1] * 8;\n            carry = next / 0x100000000 >>> 0;\n            bits += carry;\n            finalBlock.putInt32(bits >>> 0);\n            bits = next >>> 0;\n        }\n        finalBlock.putInt32(bits);\n        var s2 = {\n            h0: _state.h0,\n            h1: _state.h1,\n            h2: _state.h2,\n            h3: _state.h3,\n            h4: _state.h4\n        };\n        _update(s2, _w, finalBlock);\n        var rval = forge.util.createBuffer();\n        rval.putInt32(s2.h0);\n        rval.putInt32(s2.h1);\n        rval.putInt32(s2.h2);\n        rval.putInt32(s2.h3);\n        rval.putInt32(s2.h4);\n        return rval;\n    };\n    return md;\n};\n// sha-1 padding bytes not initialized yet\nvar _padding = null;\nvar _initialized = false;\n/**\n * Initializes the constant tables.\n */ function _init() {\n    // create padding\n    _padding = String.fromCharCode(128);\n    _padding += forge.util.fillString(String.fromCharCode(0x00), 64);\n    // now initialized\n    _initialized = true;\n}\n/**\n * Updates a SHA-1 state with the given byte buffer.\n *\n * @param s the SHA-1 state to update.\n * @param w the array to use to store words.\n * @param bytes the byte buffer to update with.\n */ function _update(s, w, bytes) {\n    // consume 512 bit (64 byte) chunks\n    var t, a, b, c, d, e, f, i;\n    var len = bytes.length();\n    while(len >= 64){\n        // the w array will be populated with sixteen 32-bit big-endian words\n        // and then extended into 80 32-bit words according to SHA-1 algorithm\n        // and for 32-79 using Max Locktyukhin's optimization\n        // initialize hash value for this chunk\n        a = s.h0;\n        b = s.h1;\n        c = s.h2;\n        d = s.h3;\n        e = s.h4;\n        // round 1\n        for(i = 0; i < 16; ++i){\n            t = bytes.getInt32();\n            w[i] = t;\n            f = d ^ b & (c ^ d);\n            t = (a << 5 | a >>> 27) + f + e + 0x5A827999 + t;\n            e = d;\n            d = c;\n            // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n            c = (b << 30 | b >>> 2) >>> 0;\n            b = a;\n            a = t;\n        }\n        for(; i < 20; ++i){\n            t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];\n            t = t << 1 | t >>> 31;\n            w[i] = t;\n            f = d ^ b & (c ^ d);\n            t = (a << 5 | a >>> 27) + f + e + 0x5A827999 + t;\n            e = d;\n            d = c;\n            // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n            c = (b << 30 | b >>> 2) >>> 0;\n            b = a;\n            a = t;\n        }\n        // round 2\n        for(; i < 32; ++i){\n            t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];\n            t = t << 1 | t >>> 31;\n            w[i] = t;\n            f = b ^ c ^ d;\n            t = (a << 5 | a >>> 27) + f + e + 0x6ED9EBA1 + t;\n            e = d;\n            d = c;\n            // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n            c = (b << 30 | b >>> 2) >>> 0;\n            b = a;\n            a = t;\n        }\n        for(; i < 40; ++i){\n            t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];\n            t = t << 2 | t >>> 30;\n            w[i] = t;\n            f = b ^ c ^ d;\n            t = (a << 5 | a >>> 27) + f + e + 0x6ED9EBA1 + t;\n            e = d;\n            d = c;\n            // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n            c = (b << 30 | b >>> 2) >>> 0;\n            b = a;\n            a = t;\n        }\n        // round 3\n        for(; i < 60; ++i){\n            t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];\n            t = t << 2 | t >>> 30;\n            w[i] = t;\n            f = b & c | d & (b ^ c);\n            t = (a << 5 | a >>> 27) + f + e + 0x8F1BBCDC + t;\n            e = d;\n            d = c;\n            // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n            c = (b << 30 | b >>> 2) >>> 0;\n            b = a;\n            a = t;\n        }\n        // round 4\n        for(; i < 80; ++i){\n            t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];\n            t = t << 2 | t >>> 30;\n            w[i] = t;\n            f = b ^ c ^ d;\n            t = (a << 5 | a >>> 27) + f + e + 0xCA62C1D6 + t;\n            e = d;\n            d = c;\n            // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n            c = (b << 30 | b >>> 2) >>> 0;\n            b = a;\n            a = t;\n        }\n        // update hash state\n        s.h0 = s.h0 + a | 0;\n        s.h1 = s.h1 + b | 0;\n        s.h2 = s.h2 + c | 0;\n        s.h3 = s.h3 + d | 0;\n        s.h4 = s.h4 + e | 0;\n        len -= 64;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvc2hhMS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0NBTUM7QUFDRCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixJQUFJQyxPQUFPQyxPQUFPQyxPQUFPLEdBQUdKLE1BQU1FLElBQUksR0FBR0YsTUFBTUUsSUFBSSxJQUFJLENBQUM7QUFDeERGLE1BQU1LLEVBQUUsQ0FBQ0gsSUFBSSxHQUFHRixNQUFNSyxFQUFFLENBQUNDLFVBQVUsQ0FBQ0osSUFBSSxHQUFHQTtBQUUzQzs7OztDQUlDLEdBQ0RBLEtBQUtLLE1BQU0sR0FBRztJQUNaLGlDQUFpQztJQUNqQyxJQUFHLENBQUNDLGNBQWM7UUFDaEJDO0lBQ0Y7SUFFQSw0Q0FBNEM7SUFDNUMsSUFBSUMsU0FBUztJQUViLGVBQWU7SUFDZixJQUFJQyxTQUFTWCxNQUFNWSxJQUFJLENBQUNDLFlBQVk7SUFFcEMsd0JBQXdCO0lBQ3hCLElBQUlDLEtBQUssSUFBSUMsTUFBTTtJQUVuQix3QkFBd0I7SUFDeEIsSUFBSVYsS0FBSztRQUNQVyxXQUFXO1FBQ1hDLGFBQWE7UUFDYkMsY0FBYztRQUNkLCtEQUErRDtRQUMvREMsZUFBZTtRQUNmLHNCQUFzQjtRQUN0QkMsbUJBQW1CO1FBQ25CLGtDQUFrQztRQUNsQ0MsbUJBQW1CO0lBQ3JCO0lBRUE7Ozs7R0FJQyxHQUNEaEIsR0FBR2lCLEtBQUssR0FBRztRQUNULDhDQUE4QztRQUM5Q2pCLEdBQUdjLGFBQWEsR0FBRztRQUVuQiwyRUFBMkU7UUFDM0VkLEdBQUdlLGlCQUFpQixHQUFHZixHQUFHa0IsZUFBZSxHQUFHLEVBQUU7UUFDOUMsSUFBSUMsU0FBU25CLEdBQUdnQixpQkFBaUIsR0FBRztRQUNwQyxJQUFJLElBQUlJLElBQUksR0FBR0EsSUFBSUQsUUFBUSxFQUFFQyxFQUFHO1lBQzlCcEIsR0FBR2UsaUJBQWlCLENBQUNNLElBQUksQ0FBQztRQUM1QjtRQUNBZixTQUFTWCxNQUFNWSxJQUFJLENBQUNDLFlBQVk7UUFDaENILFNBQVM7WUFDUGlCLElBQUk7WUFDSkMsSUFBSTtZQUNKQyxJQUFJO1lBQ0pDLElBQUk7WUFDSkMsSUFBSTtRQUNOO1FBQ0EsT0FBTzFCO0lBQ1Q7SUFDQSw0Q0FBNEM7SUFDNUNBLEdBQUdpQixLQUFLO0lBRVI7Ozs7Ozs7OztHQVNDLEdBQ0RqQixHQUFHMkIsTUFBTSxHQUFHLFNBQVNDLEdBQUcsRUFBRUMsUUFBUTtRQUNoQyxJQUFHQSxhQUFhLFFBQVE7WUFDdEJELE1BQU1qQyxNQUFNWSxJQUFJLENBQUN1QixVQUFVLENBQUNGO1FBQzlCO1FBRUEsd0JBQXdCO1FBQ3hCLElBQUlHLE1BQU1ILElBQUlJLE1BQU07UUFDcEJoQyxHQUFHYyxhQUFhLElBQUlpQjtRQUNwQkEsTUFBTTtZQUFFQSxNQUFNLGdCQUFpQjtZQUFHQSxRQUFRO1NBQUU7UUFDNUMsSUFBSSxJQUFJWCxJQUFJcEIsR0FBR2UsaUJBQWlCLENBQUNpQixNQUFNLEdBQUcsR0FBR1osS0FBSyxHQUFHLEVBQUVBLEVBQUc7WUFDeERwQixHQUFHZSxpQkFBaUIsQ0FBQ0ssRUFBRSxJQUFJVyxHQUFHLENBQUMsRUFBRTtZQUNqQ0EsR0FBRyxDQUFDLEVBQUUsR0FBR0EsR0FBRyxDQUFDLEVBQUUsR0FBSSxJQUFJaEIsaUJBQWlCLENBQUNLLEVBQUUsR0FBRyxnQkFBaUI7WUFDL0RwQixHQUFHZSxpQkFBaUIsQ0FBQ0ssRUFBRSxHQUFHcEIsR0FBR2UsaUJBQWlCLENBQUNLLEVBQUUsS0FBSztZQUN0RFcsR0FBRyxDQUFDLEVBQUUsR0FBSSxHQUFJLENBQUMsRUFBRSxHQUFHLGdCQUFpQjtRQUN2QztRQUVBLDRCQUE0QjtRQUM1QnpCLE9BQU8yQixRQUFRLENBQUNMO1FBRWhCLGdCQUFnQjtRQUNoQk0sUUFBUTdCLFFBQVFJLElBQUlIO1FBRXBCLDRDQUE0QztRQUM1QyxJQUFHQSxPQUFPNkIsSUFBSSxHQUFHLFFBQVE3QixPQUFPMEIsTUFBTSxPQUFPLEdBQUc7WUFDOUMxQixPQUFPOEIsT0FBTztRQUNoQjtRQUVBLE9BQU9wQztJQUNUO0lBRUE7Ozs7R0FJQyxHQUNEQSxHQUFHcUMsTUFBTSxHQUFHO1FBQ1Y7Ozt5Q0FHcUMsR0FFckM7Ozs7Ozs7Ozs7Ozs7bUVBYStELEdBRS9ELElBQUlDLGFBQWEzQyxNQUFNWSxJQUFJLENBQUNDLFlBQVk7UUFDeEM4QixXQUFXTCxRQUFRLENBQUMzQixPQUFPaUMsS0FBSztRQUVoQyxzRUFBc0U7UUFDdEUsSUFBSUMsWUFDRnhDLEdBQUdlLGlCQUFpQixDQUFDZixHQUFHZSxpQkFBaUIsQ0FBQ2lCLE1BQU0sR0FBRyxFQUFFLEdBQ3JEaEMsR0FBR2dCLGlCQUFpQjtRQUV0QixnREFBZ0Q7UUFDaEQsMkVBQTJFO1FBQzNFLHFEQUFxRDtRQUNyRCxJQUFJeUIsV0FBV0QsWUFBYXhDLEdBQUdZLFdBQVcsR0FBRztRQUM3QzBCLFdBQVdMLFFBQVEsQ0FBQ1MsU0FBU0MsTUFBTSxDQUFDLEdBQUczQyxHQUFHWSxXQUFXLEdBQUc2QjtRQUV4RCxxRUFBcUU7UUFDckUsa0VBQWtFO1FBQ2xFLElBQUlHLE1BQU1DO1FBQ1YsSUFBSUMsT0FBTzlDLEdBQUdlLGlCQUFpQixDQUFDLEVBQUUsR0FBRztRQUNyQyxJQUFJLElBQUlLLElBQUksR0FBR0EsSUFBSXBCLEdBQUdlLGlCQUFpQixDQUFDaUIsTUFBTSxHQUFHLEdBQUcsRUFBRVosRUFBRztZQUN2RHdCLE9BQU81QyxHQUFHZSxpQkFBaUIsQ0FBQ0ssSUFBSSxFQUFFLEdBQUc7WUFDckN5QixRQUFRLE9BQVEsZ0JBQWlCO1lBQ2pDQyxRQUFRRDtZQUNSUCxXQUFXUyxRQUFRLENBQUNELFNBQVM7WUFDN0JBLE9BQU9GLFNBQVM7UUFDbEI7UUFDQU4sV0FBV1MsUUFBUSxDQUFDRDtRQUVwQixJQUFJRSxLQUFLO1lBQ1AxQixJQUFJakIsT0FBT2lCLEVBQUU7WUFDYkMsSUFBSWxCLE9BQU9rQixFQUFFO1lBQ2JDLElBQUluQixPQUFPbUIsRUFBRTtZQUNiQyxJQUFJcEIsT0FBT29CLEVBQUU7WUFDYkMsSUFBSXJCLE9BQU9xQixFQUFFO1FBQ2Y7UUFDQVEsUUFBUWMsSUFBSXZDLElBQUk2QjtRQUNoQixJQUFJVyxPQUFPdEQsTUFBTVksSUFBSSxDQUFDQyxZQUFZO1FBQ2xDeUMsS0FBS0YsUUFBUSxDQUFDQyxHQUFHMUIsRUFBRTtRQUNuQjJCLEtBQUtGLFFBQVEsQ0FBQ0MsR0FBR3pCLEVBQUU7UUFDbkIwQixLQUFLRixRQUFRLENBQUNDLEdBQUd4QixFQUFFO1FBQ25CeUIsS0FBS0YsUUFBUSxDQUFDQyxHQUFHdkIsRUFBRTtRQUNuQndCLEtBQUtGLFFBQVEsQ0FBQ0MsR0FBR3RCLEVBQUU7UUFDbkIsT0FBT3VCO0lBQ1Q7SUFFQSxPQUFPakQ7QUFDVDtBQUVBLDBDQUEwQztBQUMxQyxJQUFJMEMsV0FBVztBQUNmLElBQUl2QyxlQUFlO0FBRW5COztDQUVDLEdBQ0QsU0FBU0M7SUFDUCxpQkFBaUI7SUFDakJzQyxXQUFXUSxPQUFPQyxZQUFZLENBQUM7SUFDL0JULFlBQVkvQyxNQUFNWSxJQUFJLENBQUM2QyxVQUFVLENBQUNGLE9BQU9DLFlBQVksQ0FBQyxPQUFPO0lBRTdELGtCQUFrQjtJQUNsQmhELGVBQWU7QUFDakI7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTK0IsUUFBUW1CLENBQUMsRUFBRUMsQ0FBQyxFQUFFZixLQUFLO0lBQzFCLG1DQUFtQztJQUNuQyxJQUFJZ0IsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR3pDO0lBQ3pCLElBQUlXLE1BQU1RLE1BQU1QLE1BQU07SUFDdEIsTUFBTUQsT0FBTyxHQUFJO1FBQ2YscUVBQXFFO1FBQ3JFLHNFQUFzRTtRQUN0RSxxREFBcUQ7UUFFckQsdUNBQXVDO1FBQ3ZDeUIsSUFBSUgsRUFBRS9CLEVBQUU7UUFDUm1DLElBQUlKLEVBQUU5QixFQUFFO1FBQ1JtQyxJQUFJTCxFQUFFN0IsRUFBRTtRQUNSbUMsSUFBSU4sRUFBRTVCLEVBQUU7UUFDUm1DLElBQUlQLEVBQUUzQixFQUFFO1FBRVIsVUFBVTtRQUNWLElBQUlOLElBQUksR0FBR0EsSUFBSSxJQUFJLEVBQUVBLEVBQUc7WUFDdEJtQyxJQUFJaEIsTUFBTXVCLFFBQVE7WUFDbEJSLENBQUMsQ0FBQ2xDLEVBQUUsR0FBR21DO1lBQ1BNLElBQUlGLElBQUtGLElBQUtDLENBQUFBLElBQUlDLENBQUFBO1lBQ2xCSixJQUFJLENBQUMsS0FBTSxJQUFNQyxNQUFNLEVBQUUsSUFBS0ssSUFBSUQsSUFBSSxhQUFhTDtZQUNuREssSUFBSUQ7WUFDSkEsSUFBSUQ7WUFDSiw0REFBNEQ7WUFDNURBLElBQUksQ0FBQyxLQUFNLEtBQU9ELE1BQU0sQ0FBQyxNQUFPO1lBQ2hDQSxJQUFJRDtZQUNKQSxJQUFJRDtRQUNOO1FBQ0EsTUFBTW5DLElBQUksSUFBSSxFQUFFQSxFQUFHO1lBQ2pCbUMsSUFBS0QsQ0FBQyxDQUFDbEMsSUFBSSxFQUFFLEdBQUdrQyxDQUFDLENBQUNsQyxJQUFJLEVBQUUsR0FBR2tDLENBQUMsQ0FBQ2xDLElBQUksR0FBRyxHQUFHa0MsQ0FBQyxDQUFDbEMsSUFBSSxHQUFHO1lBQ2hEbUMsSUFBSSxLQUFNLElBQU1BLE1BQU07WUFDdEJELENBQUMsQ0FBQ2xDLEVBQUUsR0FBR21DO1lBQ1BNLElBQUlGLElBQUtGLElBQUtDLENBQUFBLElBQUlDLENBQUFBO1lBQ2xCSixJQUFJLENBQUMsS0FBTSxJQUFNQyxNQUFNLEVBQUUsSUFBS0ssSUFBSUQsSUFBSSxhQUFhTDtZQUNuREssSUFBSUQ7WUFDSkEsSUFBSUQ7WUFDSiw0REFBNEQ7WUFDNURBLElBQUksQ0FBQyxLQUFNLEtBQU9ELE1BQU0sQ0FBQyxNQUFPO1lBQ2hDQSxJQUFJRDtZQUNKQSxJQUFJRDtRQUNOO1FBQ0EsVUFBVTtRQUNWLE1BQU1uQyxJQUFJLElBQUksRUFBRUEsRUFBRztZQUNqQm1DLElBQUtELENBQUMsQ0FBQ2xDLElBQUksRUFBRSxHQUFHa0MsQ0FBQyxDQUFDbEMsSUFBSSxFQUFFLEdBQUdrQyxDQUFDLENBQUNsQyxJQUFJLEdBQUcsR0FBR2tDLENBQUMsQ0FBQ2xDLElBQUksR0FBRztZQUNoRG1DLElBQUksS0FBTSxJQUFNQSxNQUFNO1lBQ3RCRCxDQUFDLENBQUNsQyxFQUFFLEdBQUdtQztZQUNQTSxJQUFJSixJQUFJQyxJQUFJQztZQUNaSixJQUFJLENBQUMsS0FBTSxJQUFNQyxNQUFNLEVBQUUsSUFBS0ssSUFBSUQsSUFBSSxhQUFhTDtZQUNuREssSUFBSUQ7WUFDSkEsSUFBSUQ7WUFDSiw0REFBNEQ7WUFDNURBLElBQUksQ0FBQyxLQUFNLEtBQU9ELE1BQU0sQ0FBQyxNQUFPO1lBQ2hDQSxJQUFJRDtZQUNKQSxJQUFJRDtRQUNOO1FBQ0EsTUFBTW5DLElBQUksSUFBSSxFQUFFQSxFQUFHO1lBQ2pCbUMsSUFBS0QsQ0FBQyxDQUFDbEMsSUFBSSxFQUFFLEdBQUdrQyxDQUFDLENBQUNsQyxJQUFJLEdBQUcsR0FBR2tDLENBQUMsQ0FBQ2xDLElBQUksR0FBRyxHQUFHa0MsQ0FBQyxDQUFDbEMsSUFBSSxHQUFHO1lBQ2pEbUMsSUFBSSxLQUFNLElBQU1BLE1BQU07WUFDdEJELENBQUMsQ0FBQ2xDLEVBQUUsR0FBR21DO1lBQ1BNLElBQUlKLElBQUlDLElBQUlDO1lBQ1pKLElBQUksQ0FBQyxLQUFNLElBQU1DLE1BQU0sRUFBRSxJQUFLSyxJQUFJRCxJQUFJLGFBQWFMO1lBQ25ESyxJQUFJRDtZQUNKQSxJQUFJRDtZQUNKLDREQUE0RDtZQUM1REEsSUFBSSxDQUFDLEtBQU0sS0FBT0QsTUFBTSxDQUFDLE1BQU87WUFDaENBLElBQUlEO1lBQ0pBLElBQUlEO1FBQ047UUFDQSxVQUFVO1FBQ1YsTUFBTW5DLElBQUksSUFBSSxFQUFFQSxFQUFHO1lBQ2pCbUMsSUFBS0QsQ0FBQyxDQUFDbEMsSUFBSSxFQUFFLEdBQUdrQyxDQUFDLENBQUNsQyxJQUFJLEdBQUcsR0FBR2tDLENBQUMsQ0FBQ2xDLElBQUksR0FBRyxHQUFHa0MsQ0FBQyxDQUFDbEMsSUFBSSxHQUFHO1lBQ2pEbUMsSUFBSSxLQUFNLElBQU1BLE1BQU07WUFDdEJELENBQUMsQ0FBQ2xDLEVBQUUsR0FBR21DO1lBQ1BNLElBQUksSUFBS0gsSUFBTUMsSUFBS0YsQ0FBQUEsSUFBSUMsQ0FBQUE7WUFDeEJILElBQUksQ0FBQyxLQUFNLElBQU1DLE1BQU0sRUFBRSxJQUFLSyxJQUFJRCxJQUFJLGFBQWFMO1lBQ25ESyxJQUFJRDtZQUNKQSxJQUFJRDtZQUNKLDREQUE0RDtZQUM1REEsSUFBSSxDQUFDLEtBQU0sS0FBT0QsTUFBTSxDQUFDLE1BQU87WUFDaENBLElBQUlEO1lBQ0pBLElBQUlEO1FBQ047UUFDQSxVQUFVO1FBQ1YsTUFBTW5DLElBQUksSUFBSSxFQUFFQSxFQUFHO1lBQ2pCbUMsSUFBS0QsQ0FBQyxDQUFDbEMsSUFBSSxFQUFFLEdBQUdrQyxDQUFDLENBQUNsQyxJQUFJLEdBQUcsR0FBR2tDLENBQUMsQ0FBQ2xDLElBQUksR0FBRyxHQUFHa0MsQ0FBQyxDQUFDbEMsSUFBSSxHQUFHO1lBQ2pEbUMsSUFBSSxLQUFNLElBQU1BLE1BQU07WUFDdEJELENBQUMsQ0FBQ2xDLEVBQUUsR0FBR21DO1lBQ1BNLElBQUlKLElBQUlDLElBQUlDO1lBQ1pKLElBQUksQ0FBQyxLQUFNLElBQU1DLE1BQU0sRUFBRSxJQUFLSyxJQUFJRCxJQUFJLGFBQWFMO1lBQ25ESyxJQUFJRDtZQUNKQSxJQUFJRDtZQUNKLDREQUE0RDtZQUM1REEsSUFBSSxDQUFDLEtBQU0sS0FBT0QsTUFBTSxDQUFDLE1BQU87WUFDaENBLElBQUlEO1lBQ0pBLElBQUlEO1FBQ047UUFFQSxvQkFBb0I7UUFDcEJGLEVBQUUvQixFQUFFLEdBQUcsRUFBR0EsRUFBRSxHQUFHa0MsSUFBSztRQUNwQkgsRUFBRTlCLEVBQUUsR0FBRyxFQUFHQSxFQUFFLEdBQUdrQyxJQUFLO1FBQ3BCSixFQUFFN0IsRUFBRSxHQUFHLEVBQUdBLEVBQUUsR0FBR2tDLElBQUs7UUFDcEJMLEVBQUU1QixFQUFFLEdBQUcsRUFBR0EsRUFBRSxHQUFHa0MsSUFBSztRQUNwQk4sRUFBRTNCLEVBQUUsR0FBRyxFQUFHQSxFQUFFLEdBQUdrQyxJQUFLO1FBRXBCN0IsT0FBTztJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvc2hhMS5qcz9jMjg5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2VjdXJlIEhhc2ggQWxnb3JpdGhtIHdpdGggMTYwLWJpdCBkaWdlc3QgKFNIQS0xKSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vbWQnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgc2hhMSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2Uuc2hhMSA9IGZvcmdlLnNoYTEgfHwge307XG5mb3JnZS5tZC5zaGExID0gZm9yZ2UubWQuYWxnb3JpdGhtcy5zaGExID0gc2hhMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgU0hBLTEgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0LlxuICpcbiAqIEByZXR1cm4gYSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKi9cbnNoYTEuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIGRvIGluaXRpYWxpemF0aW9uIGFzIG5lY2Vzc2FyeVxuICBpZighX2luaXRpYWxpemVkKSB7XG4gICAgX2luaXQoKTtcbiAgfVxuXG4gIC8vIFNIQS0xIHN0YXRlIGNvbnRhaW5zIGZpdmUgMzItYml0IGludGVnZXJzXG4gIHZhciBfc3RhdGUgPSBudWxsO1xuXG4gIC8vIGlucHV0IGJ1ZmZlclxuICB2YXIgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcblxuICAvLyB1c2VkIGZvciB3b3JkIHN0b3JhZ2VcbiAgdmFyIF93ID0gbmV3IEFycmF5KDgwKTtcblxuICAvLyBtZXNzYWdlIGRpZ2VzdCBvYmplY3RcbiAgdmFyIG1kID0ge1xuICAgIGFsZ29yaXRobTogJ3NoYTEnLFxuICAgIGJsb2NrTGVuZ3RoOiA2NCxcbiAgICBkaWdlc3RMZW5ndGg6IDIwLFxuICAgIC8vIDU2LWJpdCBsZW5ndGggb2YgbWVzc2FnZSBzbyBmYXIgKGRvZXMgbm90IGluY2x1ZGluZyBwYWRkaW5nKVxuICAgIG1lc3NhZ2VMZW5ndGg6IDAsXG4gICAgLy8gdHJ1ZSBtZXNzYWdlIGxlbmd0aFxuICAgIGZ1bGxNZXNzYWdlTGVuZ3RoOiBudWxsLFxuICAgIC8vIHNpemUgb2YgbWVzc2FnZSBsZW5ndGggaW4gYnl0ZXNcbiAgICBtZXNzYWdlTGVuZ3RoU2l6ZTogOFxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHVwIHRvIDU2LWJpdCBtZXNzYWdlIGxlbmd0aCBmb3IgY29udmVuaWVuY2VcbiAgICBtZC5tZXNzYWdlTGVuZ3RoID0gMDtcblxuICAgIC8vIGZ1bGwgbWVzc2FnZSBsZW5ndGggKHNldCBtZC5tZXNzYWdlTGVuZ3RoNjQgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5KVxuICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoID0gbWQubWVzc2FnZUxlbmd0aDY0ID0gW107XG4gICAgdmFyIGludDMycyA9IG1kLm1lc3NhZ2VMZW5ndGhTaXplIC8gNDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgaW50MzJzOyArK2kpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLnB1c2goMCk7XG4gICAgfVxuICAgIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgX3N0YXRlID0ge1xuICAgICAgaDA6IDB4Njc0NTIzMDEsXG4gICAgICBoMTogMHhFRkNEQUI4OSxcbiAgICAgIGgyOiAweDk4QkFEQ0ZFLFxuICAgICAgaDM6IDB4MTAzMjU0NzYsXG4gICAgICBoNDogMHhDM0QyRTFGMFxuICAgIH07XG4gICAgcmV0dXJuIG1kO1xuICB9O1xuICAvLyBzdGFydCBkaWdlc3QgYXV0b21hdGljYWxseSBmb3IgZmlyc3QgdGltZVxuICBtZC5zdGFydCgpO1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBkaWdlc3Qgd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZSBpbnB1dC4gVGhlIGdpdmVuIGlucHV0IGNhblxuICAgKiB0cmVhdGVkIGFzIHJhdyBpbnB1dCAobm8gZW5jb2Rpbmcgd2lsbCBiZSBhcHBsaWVkKSBvciBhbiBlbmNvZGluZyBvZlxuICAgKiAndXRmOCcgbWF5YmUgZ2l2ZW4gdG8gZW5jb2RlIHRoZSBpbnB1dCB1c2luZyBVVEYtOC5cbiAgICpcbiAgICogQHBhcmFtIG1zZyB0aGUgbWVzc2FnZSBpbnB1dCB0byB1cGRhdGUgd2l0aC5cbiAgICogQHBhcmFtIGVuY29kaW5nIHRoZSBlbmNvZGluZyB0byB1c2UgKGRlZmF1bHQ6ICdyYXcnLCBvdGhlcjogJ3V0ZjgnKS5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC51cGRhdGUgPSBmdW5jdGlvbihtc2csIGVuY29kaW5nKSB7XG4gICAgaWYoZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgbXNnID0gZm9yZ2UudXRpbC5lbmNvZGVVdGY4KG1zZyk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIG1lc3NhZ2UgbGVuZ3RoXG4gICAgdmFyIGxlbiA9IG1zZy5sZW5ndGg7XG4gICAgbWQubWVzc2FnZUxlbmd0aCArPSBsZW47XG4gICAgbGVuID0gWyhsZW4gLyAweDEwMDAwMDAwMCkgPj4+IDAsIGxlbiA+Pj4gMF07XG4gICAgZm9yKHZhciBpID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldICs9IGxlblsxXTtcbiAgICAgIGxlblsxXSA9IGxlblswXSArICgobWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gLyAweDEwMDAwMDAwMCkgPj4+IDApO1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA+Pj4gMDtcbiAgICAgIGxlblswXSA9ICgobGVuWzFdIC8gMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYnl0ZXMgdG8gaW5wdXQgYnVmZmVyXG4gICAgX2lucHV0LnB1dEJ5dGVzKG1zZyk7XG5cbiAgICAvLyBwcm9jZXNzIGJ5dGVzXG4gICAgX3VwZGF0ZShfc3RhdGUsIF93LCBfaW5wdXQpO1xuXG4gICAgLy8gY29tcGFjdCBpbnB1dCBidWZmZXIgZXZlcnkgMksgb3IgaWYgZW1wdHlcbiAgICBpZihfaW5wdXQucmVhZCA+IDIwNDggfHwgX2lucHV0Lmxlbmd0aCgpID09PSAwKSB7XG4gICAgICBfaW5wdXQuY29tcGFjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtZDtcbiAgfTtcblxuICAvKipcbiAgICogUHJvZHVjZXMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiBhIGJ5dGUgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGRpZ2VzdCB2YWx1ZS5cbiAgICovXG4gIG1kLmRpZ2VzdCA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIE5vdGU6IEhlcmUgd2UgY29weSB0aGUgcmVtYWluaW5nIGJ5dGVzIGluIHRoZSBpbnB1dCBidWZmZXIgYW5kXG4gICAgYWRkIHRoZSBhcHByb3ByaWF0ZSBTSEEtMSBwYWRkaW5nLiBUaGVuIHdlIGRvIHRoZSBmaW5hbCB1cGRhdGVcbiAgICBvbiBhIGNvcHkgb2YgdGhlIHN0YXRlIHNvIHRoYXQgaWYgdGhlIHVzZXIgd2FudHMgdG8gZ2V0XG4gICAgaW50ZXJtZWRpYXRlIGRpZ2VzdHMgdGhleSBjYW4gZG8gc28uICovXG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBieXRlcyB0aGF0IG11c3QgYmUgYWRkZWQgdG8gdGhlIG1lc3NhZ2VcbiAgICB0byBlbnN1cmUgaXRzIGxlbmd0aCBpcyBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIuIEluIG90aGVyIHdvcmRzLFxuICAgIHRoZSBkYXRhIHRvIGJlIGRpZ2VzdGVkIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA1MTIgYml0cyAob3IgMTI4IGJ5dGVzKS5cbiAgICBUaGlzIGRhdGEgaW5jbHVkZXMgdGhlIG1lc3NhZ2UsIHNvbWUgcGFkZGluZywgYW5kIHRoZSBsZW5ndGggb2YgdGhlXG4gICAgbWVzc2FnZS4gU2luY2UgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZSB3aWxsIGJlIGVuY29kZWQgYXMgOCBieXRlcyAoNjRcbiAgICBiaXRzKSwgdGhhdCBtZWFucyB0aGF0IHRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGRhdGEgbXVzdCBoYXZlIDU2IGJ5dGVzXG4gICAgKDQ0OCBiaXRzKSBvZiBtZXNzYWdlIGFuZCBwYWRkaW5nLiBUaGVyZWZvcmUsIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2VcbiAgICBwbHVzIHRoZSBwYWRkaW5nIG11c3QgYmUgY29uZ3J1ZW50IHRvIDQ0OCBtb2QgNTEyIGJlY2F1c2VcbiAgICA1MTIgLSAxMjggPSA0NDguXG5cbiAgICBJbiBvcmRlciB0byBmaWxsIHVwIHRoZSBtZXNzYWdlIGxlbmd0aCBpdCBtdXN0IGJlIGZpbGxlZCB3aXRoXG4gICAgcGFkZGluZyB0aGF0IGJlZ2lucyB3aXRoIDEgYml0IGZvbGxvd2VkIGJ5IGFsbCAwIGJpdHMuIFBhZGRpbmdcbiAgICBtdXN0ICphbHdheXMqIGJlIHByZXNlbnQsIHNvIGlmIHRoZSBtZXNzYWdlIGxlbmd0aCBpcyBhbHJlYWR5XG4gICAgY29uZ3J1ZW50IHRvIDQ0OCBtb2QgNTEyLCB0aGVuIDUxMiBwYWRkaW5nIGJpdHMgbXVzdCBiZSBhZGRlZC4gKi9cblxuICAgIHZhciBmaW5hbEJsb2NrID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBmaW5hbEJsb2NrLnB1dEJ5dGVzKF9pbnB1dC5ieXRlcygpKTtcblxuICAgIC8vIGNvbXB1dGUgcmVtYWluaW5nIHNpemUgdG8gYmUgZGlnZXN0ZWQgKGluY2x1ZGUgbWVzc2FnZSBsZW5ndGggc2l6ZSlcbiAgICB2YXIgcmVtYWluaW5nID0gKFxuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMV0gK1xuICAgICAgbWQubWVzc2FnZUxlbmd0aFNpemUpO1xuXG4gICAgLy8gYWRkIHBhZGRpbmcgZm9yIG92ZXJmbG93IGJsb2NrU2l6ZSAtIG92ZXJmbG93XG4gICAgLy8gX3BhZGRpbmcgc3RhcnRzIHdpdGggMSBieXRlIHdpdGggZmlyc3QgYml0IGlzIHNldCAoYnl0ZSB2YWx1ZSAxMjgpLCB0aGVuXG4gICAgLy8gdGhlcmUgbWF5IGJlIHVwIHRvIChibG9ja1NpemUgLSAxKSBvdGhlciBwYWQgYnl0ZXNcbiAgICB2YXIgb3ZlcmZsb3cgPSByZW1haW5pbmcgJiAobWQuYmxvY2tMZW5ndGggLSAxKTtcbiAgICBmaW5hbEJsb2NrLnB1dEJ5dGVzKF9wYWRkaW5nLnN1YnN0cigwLCBtZC5ibG9ja0xlbmd0aCAtIG92ZXJmbG93KSk7XG5cbiAgICAvLyBzZXJpYWxpemUgbWVzc2FnZSBsZW5ndGggaW4gYml0cyBpbiBiaWctZW5kaWFuIG9yZGVyOyBzaW5jZSBsZW5ndGhcbiAgICAvLyBpcyBzdG9yZWQgaW4gYnl0ZXMgd2UgbXVsdGlwbHkgYnkgOCBhbmQgYWRkIGNhcnJ5IGZyb20gbmV4dCBpbnRcbiAgICB2YXIgbmV4dCwgY2Fycnk7XG4gICAgdmFyIGJpdHMgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFswXSAqIDg7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgbmV4dCA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2kgKyAxXSAqIDg7XG4gICAgICBjYXJyeSA9IChuZXh0IC8gMHgxMDAwMDAwMDApID4+PiAwO1xuICAgICAgYml0cyArPSBjYXJyeTtcbiAgICAgIGZpbmFsQmxvY2sucHV0SW50MzIoYml0cyA+Pj4gMCk7XG4gICAgICBiaXRzID0gbmV4dCA+Pj4gMDtcbiAgICB9XG4gICAgZmluYWxCbG9jay5wdXRJbnQzMihiaXRzKTtcblxuICAgIHZhciBzMiA9IHtcbiAgICAgIGgwOiBfc3RhdGUuaDAsXG4gICAgICBoMTogX3N0YXRlLmgxLFxuICAgICAgaDI6IF9zdGF0ZS5oMixcbiAgICAgIGgzOiBfc3RhdGUuaDMsXG4gICAgICBoNDogX3N0YXRlLmg0XG4gICAgfTtcbiAgICBfdXBkYXRlKHMyLCBfdywgZmluYWxCbG9jayk7XG4gICAgdmFyIHJ2YWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDApO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDEpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDIpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDMpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDQpO1xuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gIHJldHVybiBtZDtcbn07XG5cbi8vIHNoYS0xIHBhZGRpbmcgYnl0ZXMgbm90IGluaXRpYWxpemVkIHlldFxudmFyIF9wYWRkaW5nID0gbnVsbDtcbnZhciBfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY29uc3RhbnQgdGFibGVzLlxuICovXG5mdW5jdGlvbiBfaW5pdCgpIHtcbiAgLy8gY3JlYXRlIHBhZGRpbmdcbiAgX3BhZGRpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyOCk7XG4gIF9wYWRkaW5nICs9IGZvcmdlLnV0aWwuZmlsbFN0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MDApLCA2NCk7XG5cbiAgLy8gbm93IGluaXRpYWxpemVkXG4gIF9pbml0aWFsaXplZCA9IHRydWU7XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIFNIQS0xIHN0YXRlIHdpdGggdGhlIGdpdmVuIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBzIHRoZSBTSEEtMSBzdGF0ZSB0byB1cGRhdGUuXG4gKiBAcGFyYW0gdyB0aGUgYXJyYXkgdG8gdXNlIHRvIHN0b3JlIHdvcmRzLlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byB1cGRhdGUgd2l0aC5cbiAqL1xuZnVuY3Rpb24gX3VwZGF0ZShzLCB3LCBieXRlcykge1xuICAvLyBjb25zdW1lIDUxMiBiaXQgKDY0IGJ5dGUpIGNodW5rc1xuICB2YXIgdCwgYSwgYiwgYywgZCwgZSwgZiwgaTtcbiAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aCgpO1xuICB3aGlsZShsZW4gPj0gNjQpIHtcbiAgICAvLyB0aGUgdyBhcnJheSB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIHNpeHRlZW4gMzItYml0IGJpZy1lbmRpYW4gd29yZHNcbiAgICAvLyBhbmQgdGhlbiBleHRlbmRlZCBpbnRvIDgwIDMyLWJpdCB3b3JkcyBhY2NvcmRpbmcgdG8gU0hBLTEgYWxnb3JpdGhtXG4gICAgLy8gYW5kIGZvciAzMi03OSB1c2luZyBNYXggTG9ja3R5dWtoaW4ncyBvcHRpbWl6YXRpb25cblxuICAgIC8vIGluaXRpYWxpemUgaGFzaCB2YWx1ZSBmb3IgdGhpcyBjaHVua1xuICAgIGEgPSBzLmgwO1xuICAgIGIgPSBzLmgxO1xuICAgIGMgPSBzLmgyO1xuICAgIGQgPSBzLmgzO1xuICAgIGUgPSBzLmg0O1xuXG4gICAgLy8gcm91bmQgMVxuICAgIGZvcihpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIHQgPSBieXRlcy5nZXRJbnQzMigpO1xuICAgICAgd1tpXSA9IHQ7XG4gICAgICBmID0gZCBeIChiICYgKGMgXiBkKSk7XG4gICAgICB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIDB4NUE4Mjc5OTkgKyB0O1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG4gICAgZm9yKDsgaSA8IDIwOyArK2kpIHtcbiAgICAgIHQgPSAod1tpIC0gM10gXiB3W2kgLSA4XSBeIHdbaSAtIDE0XSBeIHdbaSAtIDE2XSk7XG4gICAgICB0ID0gKHQgPDwgMSkgfCAodCA+Pj4gMzEpO1xuICAgICAgd1tpXSA9IHQ7XG4gICAgICBmID0gZCBeIChiICYgKGMgXiBkKSk7XG4gICAgICB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIDB4NUE4Mjc5OTkgKyB0O1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG4gICAgLy8gcm91bmQgMlxuICAgIGZvcig7IGkgPCAzMjsgKytpKSB7XG4gICAgICB0ID0gKHdbaSAtIDNdIF4gd1tpIC0gOF0gXiB3W2kgLSAxNF0gXiB3W2kgLSAxNl0pO1xuICAgICAgdCA9ICh0IDw8IDEpIHwgKHQgPj4+IDMxKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgMHg2RUQ5RUJBMSArIHQ7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cbiAgICBmb3IoOyBpIDwgNDA7ICsraSkge1xuICAgICAgdCA9ICh3W2kgLSA2XSBeIHdbaSAtIDE2XSBeIHdbaSAtIDI4XSBeIHdbaSAtIDMyXSk7XG4gICAgICB0ID0gKHQgPDwgMikgfCAodCA+Pj4gMzApO1xuICAgICAgd1tpXSA9IHQ7XG4gICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDZFRDlFQkExICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIC8vIHJvdW5kIDNcbiAgICBmb3IoOyBpIDwgNjA7ICsraSkge1xuICAgICAgdCA9ICh3W2kgLSA2XSBeIHdbaSAtIDE2XSBeIHdbaSAtIDI4XSBeIHdbaSAtIDMyXSk7XG4gICAgICB0ID0gKHQgPDwgMikgfCAodCA+Pj4gMzApO1xuICAgICAgd1tpXSA9IHQ7XG4gICAgICBmID0gKGIgJiBjKSB8IChkICYgKGIgXiBjKSk7XG4gICAgICB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIDB4OEYxQkJDREMgKyB0O1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG4gICAgLy8gcm91bmQgNFxuICAgIGZvcig7IGkgPCA4MDsgKytpKSB7XG4gICAgICB0ID0gKHdbaSAtIDZdIF4gd1tpIC0gMTZdIF4gd1tpIC0gMjhdIF4gd1tpIC0gMzJdKTtcbiAgICAgIHQgPSAodCA8PCAyKSB8ICh0ID4+PiAzMCk7XG4gICAgICB3W2ldID0gdDtcbiAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIDB4Q0E2MkMxRDYgKyB0O1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgaGFzaCBzdGF0ZVxuICAgIHMuaDAgPSAocy5oMCArIGEpIHwgMDtcbiAgICBzLmgxID0gKHMuaDEgKyBiKSB8IDA7XG4gICAgcy5oMiA9IChzLmgyICsgYykgfCAwO1xuICAgIHMuaDMgPSAocy5oMyArIGQpIHwgMDtcbiAgICBzLmg0ID0gKHMuaDQgKyBlKSB8IDA7XG5cbiAgICBsZW4gLT0gNjQ7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJzaGExIiwibW9kdWxlIiwiZXhwb3J0cyIsIm1kIiwiYWxnb3JpdGhtcyIsImNyZWF0ZSIsIl9pbml0aWFsaXplZCIsIl9pbml0IiwiX3N0YXRlIiwiX2lucHV0IiwidXRpbCIsImNyZWF0ZUJ1ZmZlciIsIl93IiwiQXJyYXkiLCJhbGdvcml0aG0iLCJibG9ja0xlbmd0aCIsImRpZ2VzdExlbmd0aCIsIm1lc3NhZ2VMZW5ndGgiLCJmdWxsTWVzc2FnZUxlbmd0aCIsIm1lc3NhZ2VMZW5ndGhTaXplIiwic3RhcnQiLCJtZXNzYWdlTGVuZ3RoNjQiLCJpbnQzMnMiLCJpIiwicHVzaCIsImgwIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJ1cGRhdGUiLCJtc2ciLCJlbmNvZGluZyIsImVuY29kZVV0ZjgiLCJsZW4iLCJsZW5ndGgiLCJwdXRCeXRlcyIsIl91cGRhdGUiLCJyZWFkIiwiY29tcGFjdCIsImRpZ2VzdCIsImZpbmFsQmxvY2siLCJieXRlcyIsInJlbWFpbmluZyIsIm92ZXJmbG93IiwiX3BhZGRpbmciLCJzdWJzdHIiLCJuZXh0IiwiY2FycnkiLCJiaXRzIiwicHV0SW50MzIiLCJzMiIsInJ2YWwiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJmaWxsU3RyaW5nIiwicyIsInciLCJ0IiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZ2V0SW50MzIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/sha1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/sha256.js":
/*!***********************************************!*\
  !*** ./node_modules/node-forge/lib/sha256.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Secure Hash Algorithm with 256-bit digest (SHA-256) implementation.\n *\n * See FIPS 180-2 for details.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2015 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./md */ \"(rsc)/./node_modules/node-forge/lib/md.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\nvar sha256 = module.exports = forge.sha256 = forge.sha256 || {};\nforge.md.sha256 = forge.md.algorithms.sha256 = sha256;\n/**\n * Creates a SHA-256 message digest object.\n *\n * @return a message digest object.\n */ sha256.create = function() {\n    // do initialization as necessary\n    if (!_initialized) {\n        _init();\n    }\n    // SHA-256 state contains eight 32-bit integers\n    var _state = null;\n    // input buffer\n    var _input = forge.util.createBuffer();\n    // used for word storage\n    var _w = new Array(64);\n    // message digest object\n    var md = {\n        algorithm: \"sha256\",\n        blockLength: 64,\n        digestLength: 32,\n        // 56-bit length of message so far (does not including padding)\n        messageLength: 0,\n        // true message length\n        fullMessageLength: null,\n        // size of message length in bytes\n        messageLengthSize: 8\n    };\n    /**\n   * Starts the digest.\n   *\n   * @return this digest object.\n   */ md.start = function() {\n        // up to 56-bit message length for convenience\n        md.messageLength = 0;\n        // full message length (set md.messageLength64 for backwards-compatibility)\n        md.fullMessageLength = md.messageLength64 = [];\n        var int32s = md.messageLengthSize / 4;\n        for(var i = 0; i < int32s; ++i){\n            md.fullMessageLength.push(0);\n        }\n        _input = forge.util.createBuffer();\n        _state = {\n            h0: 0x6A09E667,\n            h1: 0xBB67AE85,\n            h2: 0x3C6EF372,\n            h3: 0xA54FF53A,\n            h4: 0x510E527F,\n            h5: 0x9B05688C,\n            h6: 0x1F83D9AB,\n            h7: 0x5BE0CD19\n        };\n        return md;\n    };\n    // start digest automatically for first time\n    md.start();\n    /**\n   * Updates the digest with the given message input. The given input can\n   * treated as raw input (no encoding will be applied) or an encoding of\n   * 'utf8' maybe given to encode the input using UTF-8.\n   *\n   * @param msg the message input to update with.\n   * @param encoding the encoding to use (default: 'raw', other: 'utf8').\n   *\n   * @return this digest object.\n   */ md.update = function(msg, encoding) {\n        if (encoding === \"utf8\") {\n            msg = forge.util.encodeUtf8(msg);\n        }\n        // update message length\n        var len = msg.length;\n        md.messageLength += len;\n        len = [\n            len / 0x100000000 >>> 0,\n            len >>> 0\n        ];\n        for(var i = md.fullMessageLength.length - 1; i >= 0; --i){\n            md.fullMessageLength[i] += len[1];\n            len[1] = len[0] + (md.fullMessageLength[i] / 0x100000000 >>> 0);\n            md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\n            len[0] = len[1] / 0x100000000 >>> 0;\n        }\n        // add bytes to input buffer\n        _input.putBytes(msg);\n        // process bytes\n        _update(_state, _w, _input);\n        // compact input buffer every 2K or if empty\n        if (_input.read > 2048 || _input.length() === 0) {\n            _input.compact();\n        }\n        return md;\n    };\n    /**\n   * Produces the digest.\n   *\n   * @return a byte buffer containing the digest value.\n   */ md.digest = function() {\n        /* Note: Here we copy the remaining bytes in the input buffer and\n    add the appropriate SHA-256 padding. Then we do the final update\n    on a copy of the state so that if the user wants to get\n    intermediate digests they can do so. */ /* Determine the number of bytes that must be added to the message\n    to ensure its length is congruent to 448 mod 512. In other words,\n    the data to be digested must be a multiple of 512 bits (or 128 bytes).\n    This data includes the message, some padding, and the length of the\n    message. Since the length of the message will be encoded as 8 bytes (64\n    bits), that means that the last segment of the data must have 56 bytes\n    (448 bits) of message and padding. Therefore, the length of the message\n    plus the padding must be congruent to 448 mod 512 because\n    512 - 128 = 448.\n\n    In order to fill up the message length it must be filled with\n    padding that begins with 1 bit followed by all 0 bits. Padding\n    must *always* be present, so if the message length is already\n    congruent to 448 mod 512, then 512 padding bits must be added. */ var finalBlock = forge.util.createBuffer();\n        finalBlock.putBytes(_input.bytes());\n        // compute remaining size to be digested (include message length size)\n        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;\n        // add padding for overflow blockSize - overflow\n        // _padding starts with 1 byte with first bit is set (byte value 128), then\n        // there may be up to (blockSize - 1) other pad bytes\n        var overflow = remaining & md.blockLength - 1;\n        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\n        // serialize message length in bits in big-endian order; since length\n        // is stored in bytes we multiply by 8 and add carry from next int\n        var next, carry;\n        var bits = md.fullMessageLength[0] * 8;\n        for(var i = 0; i < md.fullMessageLength.length - 1; ++i){\n            next = md.fullMessageLength[i + 1] * 8;\n            carry = next / 0x100000000 >>> 0;\n            bits += carry;\n            finalBlock.putInt32(bits >>> 0);\n            bits = next >>> 0;\n        }\n        finalBlock.putInt32(bits);\n        var s2 = {\n            h0: _state.h0,\n            h1: _state.h1,\n            h2: _state.h2,\n            h3: _state.h3,\n            h4: _state.h4,\n            h5: _state.h5,\n            h6: _state.h6,\n            h7: _state.h7\n        };\n        _update(s2, _w, finalBlock);\n        var rval = forge.util.createBuffer();\n        rval.putInt32(s2.h0);\n        rval.putInt32(s2.h1);\n        rval.putInt32(s2.h2);\n        rval.putInt32(s2.h3);\n        rval.putInt32(s2.h4);\n        rval.putInt32(s2.h5);\n        rval.putInt32(s2.h6);\n        rval.putInt32(s2.h7);\n        return rval;\n    };\n    return md;\n};\n// sha-256 padding bytes not initialized yet\nvar _padding = null;\nvar _initialized = false;\n// table of constants\nvar _k = null;\n/**\n * Initializes the constant tables.\n */ function _init() {\n    // create padding\n    _padding = String.fromCharCode(128);\n    _padding += forge.util.fillString(String.fromCharCode(0x00), 64);\n    // create K table for SHA-256\n    _k = [\n        0x428a2f98,\n        0x71374491,\n        0xb5c0fbcf,\n        0xe9b5dba5,\n        0x3956c25b,\n        0x59f111f1,\n        0x923f82a4,\n        0xab1c5ed5,\n        0xd807aa98,\n        0x12835b01,\n        0x243185be,\n        0x550c7dc3,\n        0x72be5d74,\n        0x80deb1fe,\n        0x9bdc06a7,\n        0xc19bf174,\n        0xe49b69c1,\n        0xefbe4786,\n        0x0fc19dc6,\n        0x240ca1cc,\n        0x2de92c6f,\n        0x4a7484aa,\n        0x5cb0a9dc,\n        0x76f988da,\n        0x983e5152,\n        0xa831c66d,\n        0xb00327c8,\n        0xbf597fc7,\n        0xc6e00bf3,\n        0xd5a79147,\n        0x06ca6351,\n        0x14292967,\n        0x27b70a85,\n        0x2e1b2138,\n        0x4d2c6dfc,\n        0x53380d13,\n        0x650a7354,\n        0x766a0abb,\n        0x81c2c92e,\n        0x92722c85,\n        0xa2bfe8a1,\n        0xa81a664b,\n        0xc24b8b70,\n        0xc76c51a3,\n        0xd192e819,\n        0xd6990624,\n        0xf40e3585,\n        0x106aa070,\n        0x19a4c116,\n        0x1e376c08,\n        0x2748774c,\n        0x34b0bcb5,\n        0x391c0cb3,\n        0x4ed8aa4a,\n        0x5b9cca4f,\n        0x682e6ff3,\n        0x748f82ee,\n        0x78a5636f,\n        0x84c87814,\n        0x8cc70208,\n        0x90befffa,\n        0xa4506ceb,\n        0xbef9a3f7,\n        0xc67178f2\n    ];\n    // now initialized\n    _initialized = true;\n}\n/**\n * Updates a SHA-256 state with the given byte buffer.\n *\n * @param s the SHA-256 state to update.\n * @param w the array to use to store words.\n * @param bytes the byte buffer to update with.\n */ function _update(s, w, bytes) {\n    // consume 512 bit (64 byte) chunks\n    var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;\n    var len = bytes.length();\n    while(len >= 64){\n        // the w array will be populated with sixteen 32-bit big-endian words\n        // and then extended into 64 32-bit words according to SHA-256\n        for(i = 0; i < 16; ++i){\n            w[i] = bytes.getInt32();\n        }\n        for(; i < 64; ++i){\n            // XOR word 2 words ago rot right 17, rot right 19, shft right 10\n            t1 = w[i - 2];\n            t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;\n            // XOR word 15 words ago rot right 7, rot right 18, shft right 3\n            t2 = w[i - 15];\n            t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;\n            // sum(t1, word 7 ago, t2, word 16 ago) modulo 2^32\n            w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;\n        }\n        // initialize hash value for this chunk\n        a = s.h0;\n        b = s.h1;\n        c = s.h2;\n        d = s.h3;\n        e = s.h4;\n        f = s.h5;\n        g = s.h6;\n        h = s.h7;\n        // round function\n        for(i = 0; i < 64; ++i){\n            // Sum1(e)\n            s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);\n            // Ch(e, f, g) (optimized the same way as SHA-1)\n            ch = g ^ e & (f ^ g);\n            // Sum0(a)\n            s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);\n            // Maj(a, b, c) (optimized the same way as SHA-1)\n            maj = a & b | c & (a ^ b);\n            // main algorithm\n            t1 = h + s1 + ch + _k[i] + w[i];\n            t2 = s0 + maj;\n            h = g;\n            g = f;\n            f = e;\n            // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n            // can't truncate with `| 0`\n            e = d + t1 >>> 0;\n            d = c;\n            c = b;\n            b = a;\n            // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n            // can't truncate with `| 0`\n            a = t1 + t2 >>> 0;\n        }\n        // update hash state\n        s.h0 = s.h0 + a | 0;\n        s.h1 = s.h1 + b | 0;\n        s.h2 = s.h2 + c | 0;\n        s.h3 = s.h3 + d | 0;\n        s.h4 = s.h4 + e | 0;\n        s.h5 = s.h5 + f | 0;\n        s.h6 = s.h6 + g | 0;\n        s.h7 = s.h7 + h | 0;\n        len -= 64;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvc2hhMjU2LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVIsSUFBSUMsU0FBU0MsT0FBT0MsT0FBTyxHQUFHSixNQUFNRSxNQUFNLEdBQUdGLE1BQU1FLE1BQU0sSUFBSSxDQUFDO0FBQzlERixNQUFNSyxFQUFFLENBQUNILE1BQU0sR0FBR0YsTUFBTUssRUFBRSxDQUFDQyxVQUFVLENBQUNKLE1BQU0sR0FBR0E7QUFFL0M7Ozs7Q0FJQyxHQUNEQSxPQUFPSyxNQUFNLEdBQUc7SUFDZCxpQ0FBaUM7SUFDakMsSUFBRyxDQUFDQyxjQUFjO1FBQ2hCQztJQUNGO0lBRUEsK0NBQStDO0lBQy9DLElBQUlDLFNBQVM7SUFFYixlQUFlO0lBQ2YsSUFBSUMsU0FBU1gsTUFBTVksSUFBSSxDQUFDQyxZQUFZO0lBRXBDLHdCQUF3QjtJQUN4QixJQUFJQyxLQUFLLElBQUlDLE1BQU07SUFFbkIsd0JBQXdCO0lBQ3hCLElBQUlWLEtBQUs7UUFDUFcsV0FBVztRQUNYQyxhQUFhO1FBQ2JDLGNBQWM7UUFDZCwrREFBK0Q7UUFDL0RDLGVBQWU7UUFDZixzQkFBc0I7UUFDdEJDLG1CQUFtQjtRQUNuQixrQ0FBa0M7UUFDbENDLG1CQUFtQjtJQUNyQjtJQUVBOzs7O0dBSUMsR0FDRGhCLEdBQUdpQixLQUFLLEdBQUc7UUFDVCw4Q0FBOEM7UUFDOUNqQixHQUFHYyxhQUFhLEdBQUc7UUFFbkIsMkVBQTJFO1FBQzNFZCxHQUFHZSxpQkFBaUIsR0FBR2YsR0FBR2tCLGVBQWUsR0FBRyxFQUFFO1FBQzlDLElBQUlDLFNBQVNuQixHQUFHZ0IsaUJBQWlCLEdBQUc7UUFDcEMsSUFBSSxJQUFJSSxJQUFJLEdBQUdBLElBQUlELFFBQVEsRUFBRUMsRUFBRztZQUM5QnBCLEdBQUdlLGlCQUFpQixD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QUNKQSxJQUFJRDtZQUNKQSxJQUFJRDtZQUNKLDREQUE0RDtZQUM1RCw0QkFBNEI7WUFDNUJBLElBQUksS0FBTUwsT0FBUTtRQUNwQjtRQUVBLG9CQUFvQjtRQUNwQkgsRUFBRW5DLEVBQUUsR0FBRyxFQUFHQSxFQUFFLEdBQUcyQyxJQUFLO1FBQ3BCUixFQUFFbEMsRUFBRSxHQUFHLEVBQUdBLEVBQUUsR0FBRzJDLElBQUs7UUFDcEJULEVBQUVqQyxFQUFFLEdBQUcsRUFBR0EsRUFBRSxHQUFHMkMsSUFBSztRQUNwQlYsRUFBRWhDLEVBQUUsR0FBRyxFQUFHQSxFQUFFLEdBQUcyQyxJQUFLO1FBQ3BCWCxFQUFFL0IsRUFBRSxHQUFHLEVBQUdBLEVBQUUsR0FBRzJDLElBQUs7UUFDcEJaLEVBQUU5QixFQUFFLEdBQUcsRUFBR0EsRUFBRSxHQUFHMkMsSUFBSztRQUNwQmIsRUFBRTdCLEVBQUUsR0FBRyxFQUFHQSxFQUFFLEdBQUcyQyxJQUFLO1FBQ3BCZCxFQUFFNUIsRUFBRSxHQUFHLEVBQUdBLEVBQUUsR0FBRzJDLElBQUs7UUFDcEJ0QyxPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9zaGEyNTYuanM/ZjMyZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNlY3VyZSBIYXNoIEFsZ29yaXRobSB3aXRoIDI1Ni1iaXQgZGlnZXN0IChTSEEtMjU2KSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBTZWUgRklQUyAxODAtMiBmb3IgZGV0YWlscy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vbWQnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgc2hhMjU2ID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5zaGEyNTYgPSBmb3JnZS5zaGEyNTYgfHwge307XG5mb3JnZS5tZC5zaGEyNTYgPSBmb3JnZS5tZC5hbGdvcml0aG1zLnNoYTI1NiA9IHNoYTI1NjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgU0hBLTI1NiBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKlxuICogQHJldHVybiBhIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqL1xuc2hhMjU2LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBkbyBpbml0aWFsaXphdGlvbiBhcyBuZWNlc3NhcnlcbiAgaWYoIV9pbml0aWFsaXplZCkge1xuICAgIF9pbml0KCk7XG4gIH1cblxuICAvLyBTSEEtMjU2IHN0YXRlIGNvbnRhaW5zIGVpZ2h0IDMyLWJpdCBpbnRlZ2Vyc1xuICB2YXIgX3N0YXRlID0gbnVsbDtcblxuICAvLyBpbnB1dCBidWZmZXJcbiAgdmFyIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gdXNlZCBmb3Igd29yZCBzdG9yYWdlXG4gIHZhciBfdyA9IG5ldyBBcnJheSg2NCk7XG5cbiAgLy8gbWVzc2FnZSBkaWdlc3Qgb2JqZWN0XG4gIHZhciBtZCA9IHtcbiAgICBhbGdvcml0aG06ICdzaGEyNTYnLFxuICAgIGJsb2NrTGVuZ3RoOiA2NCxcbiAgICBkaWdlc3RMZW5ndGg6IDMyLFxuICAgIC8vIDU2LWJpdCBsZW5ndGggb2YgbWVzc2FnZSBzbyBmYXIgKGRvZXMgbm90IGluY2x1ZGluZyBwYWRkaW5nKVxuICAgIG1lc3NhZ2VMZW5ndGg6IDAsXG4gICAgLy8gdHJ1ZSBtZXNzYWdlIGxlbmd0aFxuICAgIGZ1bGxNZXNzYWdlTGVuZ3RoOiBudWxsLFxuICAgIC8vIHNpemUgb2YgbWVzc2FnZSBsZW5ndGggaW4gYnl0ZXNcbiAgICBtZXNzYWdlTGVuZ3RoU2l6ZTogOFxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHVwIHRvIDU2LWJpdCBtZXNzYWdlIGxlbmd0aCBmb3IgY29udmVuaWVuY2VcbiAgICBtZC5tZXNzYWdlTGVuZ3RoID0gMDtcblxuICAgIC8vIGZ1bGwgbWVzc2FnZSBsZW5ndGggKHNldCBtZC5tZXNzYWdlTGVuZ3RoNjQgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5KVxuICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoID0gbWQubWVzc2FnZUxlbmd0aDY0ID0gW107XG4gICAgdmFyIGludDMycyA9IG1kLm1lc3NhZ2VMZW5ndGhTaXplIC8gNDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgaW50MzJzOyArK2kpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLnB1c2goMCk7XG4gICAgfVxuICAgIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgX3N0YXRlID0ge1xuICAgICAgaDA6IDB4NkEwOUU2NjcsXG4gICAgICBoMTogMHhCQjY3QUU4NSxcbiAgICAgIGgyOiAweDNDNkVGMzcyLFxuICAgICAgaDM6IDB4QTU0RkY1M0EsXG4gICAgICBoNDogMHg1MTBFNTI3RixcbiAgICAgIGg1OiAweDlCMDU2ODhDLFxuICAgICAgaDY6IDB4MUY4M0Q5QUIsXG4gICAgICBoNzogMHg1QkUwQ0QxOVxuICAgIH07XG4gICAgcmV0dXJuIG1kO1xuICB9O1xuICAvLyBzdGFydCBkaWdlc3QgYXV0b21hdGljYWxseSBmb3IgZmlyc3QgdGltZVxuICBtZC5zdGFydCgpO1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBkaWdlc3Qgd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZSBpbnB1dC4gVGhlIGdpdmVuIGlucHV0IGNhblxuICAgKiB0cmVhdGVkIGFzIHJhdyBpbnB1dCAobm8gZW5jb2Rpbmcgd2lsbCBiZSBhcHBsaWVkKSBvciBhbiBlbmNvZGluZyBvZlxuICAgKiAndXRmOCcgbWF5YmUgZ2l2ZW4gdG8gZW5jb2RlIHRoZSBpbnB1dCB1c2luZyBVVEYtOC5cbiAgICpcbiAgICogQHBhcmFtIG1zZyB0aGUgbWVzc2FnZSBpbnB1dCB0byB1cGRhdGUgd2l0aC5cbiAgICogQHBhcmFtIGVuY29kaW5nIHRoZSBlbmNvZGluZyB0byB1c2UgKGRlZmF1bHQ6ICdyYXcnLCBvdGhlcjogJ3V0ZjgnKS5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC51cGRhdGUgPSBmdW5jdGlvbihtc2csIGVuY29kaW5nKSB7XG4gICAgaWYoZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgbXNnID0gZm9yZ2UudXRpbC5lbmNvZGVVdGY4KG1zZyk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIG1lc3NhZ2UgbGVuZ3RoXG4gICAgdmFyIGxlbiA9IG1zZy5sZW5ndGg7XG4gICAgbWQubWVzc2FnZUxlbmd0aCArPSBsZW47XG4gICAgbGVuID0gWyhsZW4gLyAweDEwMDAwMDAwMCkgPj4+IDAsIGxlbiA+Pj4gMF07XG4gICAgZm9yKHZhciBpID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldICs9IGxlblsxXTtcbiAgICAgIGxlblsxXSA9IGxlblswXSArICgobWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gLyAweDEwMDAwMDAwMCkgPj4+IDApO1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA+Pj4gMDtcbiAgICAgIGxlblswXSA9ICgobGVuWzFdIC8gMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYnl0ZXMgdG8gaW5wdXQgYnVmZmVyXG4gICAgX2lucHV0LnB1dEJ5dGVzKG1zZyk7XG5cbiAgICAvLyBwcm9jZXNzIGJ5dGVzXG4gICAgX3VwZGF0ZShfc3RhdGUsIF93LCBfaW5wdXQpO1xuXG4gICAgLy8gY29tcGFjdCBpbnB1dCBidWZmZXIgZXZlcnkgMksgb3IgaWYgZW1wdHlcbiAgICBpZihfaW5wdXQucmVhZCA+IDIwNDggfHwgX2lucHV0Lmxlbmd0aCgpID09PSAwKSB7XG4gICAgICBfaW5wdXQuY29tcGFjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtZDtcbiAgfTtcblxuICAvKipcbiAgICogUHJvZHVjZXMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiBhIGJ5dGUgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGRpZ2VzdCB2YWx1ZS5cbiAgICovXG4gIG1kLmRpZ2VzdCA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIE5vdGU6IEhlcmUgd2UgY29weSB0aGUgcmVtYWluaW5nIGJ5dGVzIGluIHRoZSBpbnB1dCBidWZmZXIgYW5kXG4gICAgYWRkIHRoZSBhcHByb3ByaWF0ZSBTSEEtMjU2IHBhZGRpbmcuIFRoZW4gd2UgZG8gdGhlIGZpbmFsIHVwZGF0ZVxuICAgIG9uIGEgY29weSBvZiB0aGUgc3RhdGUgc28gdGhhdCBpZiB0aGUgdXNlciB3YW50cyB0byBnZXRcbiAgICBpbnRlcm1lZGlhdGUgZGlnZXN0cyB0aGV5IGNhbiBkbyBzby4gKi9cblxuICAgIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgbXVzdCBiZSBhZGRlZCB0byB0aGUgbWVzc2FnZVxuICAgIHRvIGVuc3VyZSBpdHMgbGVuZ3RoIGlzIGNvbmdydWVudCB0byA0NDggbW9kIDUxMi4gSW4gb3RoZXIgd29yZHMsXG4gICAgdGhlIGRhdGEgdG8gYmUgZGlnZXN0ZWQgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDUxMiBiaXRzIChvciAxMjggYnl0ZXMpLlxuICAgIFRoaXMgZGF0YSBpbmNsdWRlcyB0aGUgbWVzc2FnZSwgc29tZSBwYWRkaW5nLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICBtZXNzYWdlLiBTaW5jZSB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlIHdpbGwgYmUgZW5jb2RlZCBhcyA4IGJ5dGVzICg2NFxuICAgIGJpdHMpLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgZGF0YSBtdXN0IGhhdmUgNTYgYnl0ZXNcbiAgICAoNDQ4IGJpdHMpIG9mIG1lc3NhZ2UgYW5kIHBhZGRpbmcuIFRoZXJlZm9yZSwgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZVxuICAgIHBsdXMgdGhlIHBhZGRpbmcgbXVzdCBiZSBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIgYmVjYXVzZVxuICAgIDUxMiAtIDEyOCA9IDQ0OC5cblxuICAgIEluIG9yZGVyIHRvIGZpbGwgdXAgdGhlIG1lc3NhZ2UgbGVuZ3RoIGl0IG11c3QgYmUgZmlsbGVkIHdpdGhcbiAgICBwYWRkaW5nIHRoYXQgYmVnaW5zIHdpdGggMSBiaXQgZm9sbG93ZWQgYnkgYWxsIDAgYml0cy4gUGFkZGluZ1xuICAgIG11c3QgKmFsd2F5cyogYmUgcHJlc2VudCwgc28gaWYgdGhlIG1lc3NhZ2UgbGVuZ3RoIGlzIGFscmVhZHlcbiAgICBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIsIHRoZW4gNTEyIHBhZGRpbmcgYml0cyBtdXN0IGJlIGFkZGVkLiAqL1xuXG4gICAgdmFyIGZpbmFsQmxvY2sgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX2lucHV0LmJ5dGVzKCkpO1xuXG4gICAgLy8gY29tcHV0ZSByZW1haW5pbmcgc2l6ZSB0byBiZSBkaWdlc3RlZCAoaW5jbHVkZSBtZXNzYWdlIGxlbmd0aCBzaXplKVxuICAgIHZhciByZW1haW5pbmcgPSAoXG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFttZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxXSArXG4gICAgICBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSk7XG5cbiAgICAvLyBhZGQgcGFkZGluZyBmb3Igb3ZlcmZsb3cgYmxvY2tTaXplIC0gb3ZlcmZsb3dcbiAgICAvLyBfcGFkZGluZyBzdGFydHMgd2l0aCAxIGJ5dGUgd2l0aCBmaXJzdCBiaXQgaXMgc2V0IChieXRlIHZhbHVlIDEyOCksIHRoZW5cbiAgICAvLyB0aGVyZSBtYXkgYmUgdXAgdG8gKGJsb2NrU2l6ZSAtIDEpIG90aGVyIHBhZCBieXRlc1xuICAgIHZhciBvdmVyZmxvdyA9IHJlbWFpbmluZyAmIChtZC5ibG9ja0xlbmd0aCAtIDEpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX3BhZGRpbmcuc3Vic3RyKDAsIG1kLmJsb2NrTGVuZ3RoIC0gb3ZlcmZsb3cpKTtcblxuICAgIC8vIHNlcmlhbGl6ZSBtZXNzYWdlIGxlbmd0aCBpbiBiaXRzIGluIGJpZy1lbmRpYW4gb3JkZXI7IHNpbmNlIGxlbmd0aFxuICAgIC8vIGlzIHN0b3JlZCBpbiBieXRlcyB3ZSBtdWx0aXBseSBieSA4IGFuZCBhZGQgY2FycnkgZnJvbSBuZXh0IGludFxuICAgIHZhciBuZXh0LCBjYXJyeTtcbiAgICB2YXIgYml0cyA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoWzBdICogODtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBuZXh0ID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaSArIDFdICogODtcbiAgICAgIGNhcnJ5ID0gKG5leHQgLyAweDEwMDAwMDAwMCkgPj4+IDA7XG4gICAgICBiaXRzICs9IGNhcnJ5O1xuICAgICAgZmluYWxCbG9jay5wdXRJbnQzMihiaXRzID4+PiAwKTtcbiAgICAgIGJpdHMgPSBuZXh0ID4+PiAwO1xuICAgIH1cbiAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMpO1xuXG4gICAgdmFyIHMyID0ge1xuICAgICAgaDA6IF9zdGF0ZS5oMCxcbiAgICAgIGgxOiBfc3RhdGUuaDEsXG4gICAgICBoMjogX3N0YXRlLmgyLFxuICAgICAgaDM6IF9zdGF0ZS5oMyxcbiAgICAgIGg0OiBfc3RhdGUuaDQsXG4gICAgICBoNTogX3N0YXRlLmg1LFxuICAgICAgaDY6IF9zdGF0ZS5oNixcbiAgICAgIGg3OiBfc3RhdGUuaDdcbiAgICB9O1xuICAgIF91cGRhdGUoczIsIF93LCBmaW5hbEJsb2NrKTtcbiAgICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMSk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMik7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMyk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNSk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNik7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNyk7XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgcmV0dXJuIG1kO1xufTtcblxuLy8gc2hhLTI1NiBwYWRkaW5nIGJ5dGVzIG5vdCBpbml0aWFsaXplZCB5ZXRcbnZhciBfcGFkZGluZyA9IG51bGw7XG52YXIgX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8vIHRhYmxlIG9mIGNvbnN0YW50c1xudmFyIF9rID0gbnVsbDtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY29uc3RhbnQgdGFibGVzLlxuICovXG5mdW5jdGlvbiBfaW5pdCgpIHtcbiAgLy8gY3JlYXRlIHBhZGRpbmdcbiAgX3BhZGRpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyOCk7XG4gIF9wYWRkaW5nICs9IGZvcmdlLnV0aWwuZmlsbFN0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MDApLCA2NCk7XG5cbiAgLy8gY3JlYXRlIEsgdGFibGUgZm9yIFNIQS0yNTZcbiAgX2sgPSBbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSxcbiAgICAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsXG4gICAgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLFxuICAgIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNyxcbiAgICAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsXG4gICAgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLFxuICAgIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSxcbiAgICAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsXG4gICAgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMl07XG5cbiAgLy8gbm93IGluaXRpYWxpemVkXG4gIF9pbml0aWFsaXplZCA9IHRydWU7XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIFNIQS0yNTYgc3RhdGUgd2l0aCB0aGUgZ2l2ZW4gYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIHMgdGhlIFNIQS0yNTYgc3RhdGUgdG8gdXBkYXRlLlxuICogQHBhcmFtIHcgdGhlIGFycmF5IHRvIHVzZSB0byBzdG9yZSB3b3Jkcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gdXBkYXRlIHdpdGguXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGUocywgdywgYnl0ZXMpIHtcbiAgLy8gY29uc3VtZSA1MTIgYml0ICg2NCBieXRlKSBjaHVua3NcbiAgdmFyIHQxLCB0MiwgczAsIHMxLCBjaCwgbWFqLCBpLCBhLCBiLCBjLCBkLCBlLCBmLCBnLCBoO1xuICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoKCk7XG4gIHdoaWxlKGxlbiA+PSA2NCkge1xuICAgIC8vIHRoZSB3IGFycmF5IHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggc2l4dGVlbiAzMi1iaXQgYmlnLWVuZGlhbiB3b3Jkc1xuICAgIC8vIGFuZCB0aGVuIGV4dGVuZGVkIGludG8gNjQgMzItYml0IHdvcmRzIGFjY29yZGluZyB0byBTSEEtMjU2XG4gICAgZm9yKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgd1tpXSA9IGJ5dGVzLmdldEludDMyKCk7XG4gICAgfVxuICAgIGZvcig7IGkgPCA2NDsgKytpKSB7XG4gICAgICAvLyBYT1Igd29yZCAyIHdvcmRzIGFnbyByb3QgcmlnaHQgMTcsIHJvdCByaWdodCAxOSwgc2hmdCByaWdodCAxMFxuICAgICAgdDEgPSB3W2kgLSAyXTtcbiAgICAgIHQxID1cbiAgICAgICAgKCh0MSA+Pj4gMTcpIHwgKHQxIDw8IDE1KSkgXlxuICAgICAgICAoKHQxID4+PiAxOSkgfCAodDEgPDwgMTMpKSBeXG4gICAgICAgICh0MSA+Pj4gMTApO1xuICAgICAgLy8gWE9SIHdvcmQgMTUgd29yZHMgYWdvIHJvdCByaWdodCA3LCByb3QgcmlnaHQgMTgsIHNoZnQgcmlnaHQgM1xuICAgICAgdDIgPSB3W2kgLSAxNV07XG4gICAgICB0MiA9XG4gICAgICAgICgodDIgPj4+IDcpIHwgKHQyIDw8IDI1KSkgXlxuICAgICAgICAoKHQyID4+PiAxOCkgfCAodDIgPDwgMTQpKSBeXG4gICAgICAgICh0MiA+Pj4gMyk7XG4gICAgICAvLyBzdW0odDEsIHdvcmQgNyBhZ28sIHQyLCB3b3JkIDE2IGFnbykgbW9kdWxvIDJeMzJcbiAgICAgIHdbaV0gPSAodDEgKyB3W2kgLSA3XSArIHQyICsgd1tpIC0gMTZdKSB8IDA7XG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbGl6ZSBoYXNoIHZhbHVlIGZvciB0aGlzIGNodW5rXG4gICAgYSA9IHMuaDA7XG4gICAgYiA9IHMuaDE7XG4gICAgYyA9IHMuaDI7XG4gICAgZCA9IHMuaDM7XG4gICAgZSA9IHMuaDQ7XG4gICAgZiA9IHMuaDU7XG4gICAgZyA9IHMuaDY7XG4gICAgaCA9IHMuaDc7XG5cbiAgICAvLyByb3VuZCBmdW5jdGlvblxuICAgIGZvcihpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICAgIC8vIFN1bTEoZSlcbiAgICAgIHMxID1cbiAgICAgICAgKChlID4+PiA2KSB8IChlIDw8IDI2KSkgXlxuICAgICAgICAoKGUgPj4+IDExKSB8IChlIDw8IDIxKSkgXlxuICAgICAgICAoKGUgPj4+IDI1KSB8IChlIDw8IDcpKTtcbiAgICAgIC8vIENoKGUsIGYsIGcpIChvcHRpbWl6ZWQgdGhlIHNhbWUgd2F5IGFzIFNIQS0xKVxuICAgICAgY2ggPSBnIF4gKGUgJiAoZiBeIGcpKTtcbiAgICAgIC8vIFN1bTAoYSlcbiAgICAgIHMwID1cbiAgICAgICAgKChhID4+PiAyKSB8IChhIDw8IDMwKSkgXlxuICAgICAgICAoKGEgPj4+IDEzKSB8IChhIDw8IDE5KSkgXlxuICAgICAgICAoKGEgPj4+IDIyKSB8IChhIDw8IDEwKSk7XG4gICAgICAvLyBNYWooYSwgYiwgYykgKG9wdGltaXplZCB0aGUgc2FtZSB3YXkgYXMgU0hBLTEpXG4gICAgICBtYWogPSAoYSAmIGIpIHwgKGMgJiAoYSBeIGIpKTtcblxuICAgICAgLy8gbWFpbiBhbGdvcml0aG1cbiAgICAgIHQxID0gaCArIHMxICsgY2ggKyBfa1tpXSArIHdbaV07XG4gICAgICB0MiA9IHMwICsgbWFqO1xuICAgICAgaCA9IGc7XG4gICAgICBnID0gZjtcbiAgICAgIGYgPSBlO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICAvLyBjYW4ndCB0cnVuY2F0ZSB3aXRoIGB8IDBgXG4gICAgICBlID0gKGQgKyB0MSkgPj4+IDA7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBiO1xuICAgICAgYiA9IGE7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIC8vIGNhbid0IHRydW5jYXRlIHdpdGggYHwgMGBcbiAgICAgIGEgPSAodDEgKyB0MikgPj4+IDA7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGhhc2ggc3RhdGVcbiAgICBzLmgwID0gKHMuaDAgKyBhKSB8IDA7XG4gICAgcy5oMSA9IChzLmgxICsgYikgfCAwO1xuICAgIHMuaDIgPSAocy5oMiArIGMpIHwgMDtcbiAgICBzLmgzID0gKHMuaDMgKyBkKSB8IDA7XG4gICAgcy5oNCA9IChzLmg0ICsgZSkgfCAwO1xuICAgIHMuaDUgPSAocy5oNSArIGYpIHwgMDtcbiAgICBzLmg2ID0gKHMuaDYgKyBnKSB8IDA7XG4gICAgcy5oNyA9IChzLmg3ICsgaCkgfCAwO1xuICAgIGxlbiAtPSA2NDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbImZvcmdlIiwicmVxdWlyZSIsInNoYTI1NiIsIm1vZHVsZSIsImV4cG9ydHMiLCJtZCIsImFsZ29yaXRobXMiLCJjcmVhdGUiLCJfaW5pdGlhbGl6ZWQiLCJfaW5pdCIsIl9zdGF0ZSIsIl9pbnB1dCIsInV0aWwiLCJjcmVhdGVCdWZmZXIiLCJfdyIsIkFycmF5IiwiYWxnb3JpdGhtIiwiYmxvY2tMZW5ndGgiLCJkaWdlc3RMZW5ndGgiLCJtZXNzYWdlTGVuZ3RoIiwiZnVsbE1lc3NhZ2VMZW5ndGgiLCJtZXNzYWdlTGVuZ3RoU2l6ZSIsInN0YXJ0IiwibWVzc2FnZUxlbmd0aDY0IiwiaW50MzJzIiwiaSIsInB1c2giLCJoMCIsImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiIsImg3IiwidXBkYXRlIiwibXNnIiwiZW5jb2RpbmciLCJlbmNvZGVVdGY4IiwibGVuIiwibGVuZ3RoIiwicHV0Qnl0ZXMiLCJfdXBkYXRlIiwicmVhZCIsImNvbXBhY3QiLCJkaWdlc3QiLCJmaW5hbEJsb2NrIiwiYnl0ZXMiLCJyZW1haW5pbmciLCJvdmVyZmxvdyIsIl9wYWRkaW5nIiwic3Vic3RyIiwibmV4dCIsImNhcnJ5IiwiYml0cyIsInB1dEludDMyIiwiczIiLCJydmFsIiwiX2siLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJmaWxsU3RyaW5nIiwicyIsInciLCJ0MSIsInQyIiwiczAiLCJzMSIsImNoIiwibWFqIiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImgiLCJnZXRJbnQzMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/sha256.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/sha512.js":
/*!***********************************************!*\
  !*** ./node_modules/node-forge/lib/sha512.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Secure Hash Algorithm with a 1024-bit block size implementation.\n *\n * This includes: SHA-512, SHA-384, SHA-512/224, and SHA-512/256. For\n * SHA-256 (block size 512 bits), see sha256.js.\n *\n * See FIPS 180-4 for details.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2014-2015 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./md */ \"(rsc)/./node_modules/node-forge/lib/md.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\nvar sha512 = module.exports = forge.sha512 = forge.sha512 || {};\n// SHA-512\nforge.md.sha512 = forge.md.algorithms.sha512 = sha512;\n// SHA-384\nvar sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};\nsha384.create = function() {\n    return sha512.create(\"SHA-384\");\n};\nforge.md.sha384 = forge.md.algorithms.sha384 = sha384;\n// SHA-512/256\nforge.sha512.sha256 = forge.sha512.sha256 || {\n    create: function() {\n        return sha512.create(\"SHA-512/256\");\n    }\n};\nforge.md[\"sha512/256\"] = forge.md.algorithms[\"sha512/256\"] = forge.sha512.sha256;\n// SHA-512/224\nforge.sha512.sha224 = forge.sha512.sha224 || {\n    create: function() {\n        return sha512.create(\"SHA-512/224\");\n    }\n};\nforge.md[\"sha512/224\"] = forge.md.algorithms[\"sha512/224\"] = forge.sha512.sha224;\n/**\n * Creates a SHA-2 message digest object.\n *\n * @param algorithm the algorithm to use (SHA-512, SHA-384, SHA-512/224,\n *          SHA-512/256).\n *\n * @return a message digest object.\n */ sha512.create = function(algorithm) {\n    // do initialization as necessary\n    if (!_initialized) {\n        _init();\n    }\n    if (typeof algorithm === \"undefined\") {\n        algorithm = \"SHA-512\";\n    }\n    if (!(algorithm in _states)) {\n        throw new Error(\"Invalid SHA-512 algorithm: \" + algorithm);\n    }\n    // SHA-512 state contains eight 64-bit integers (each as two 32-bit ints)\n    var _state = _states[algorithm];\n    var _h = null;\n    // input buffer\n    var _input = forge.util.createBuffer();\n    // used for 64-bit word storage\n    var _w = new Array(80);\n    for(var wi = 0; wi < 80; ++wi){\n        _w[wi] = new Array(2);\n    }\n    // determine digest length by algorithm name (default)\n    var digestLength = 64;\n    switch(algorithm){\n        case \"SHA-384\":\n            digestLength = 48;\n            break;\n        case \"SHA-512/256\":\n            digestLength = 32;\n            break;\n        case \"SHA-512/224\":\n            digestLength = 28;\n            break;\n    }\n    // message digest object\n    var md = {\n        // SHA-512 => sha512\n        algorithm: algorithm.replace(\"-\", \"\").toLowerCase(),\n        blockLength: 128,\n        digestLength: digestLength,\n        // 56-bit length of message so far (does not including padding)\n        messageLength: 0,\n        // true message length\n        fullMessageLength: null,\n        // size of message length in bytes\n        messageLengthSize: 16\n    };\n    /**\n   * Starts the digest.\n   *\n   * @return this digest object.\n   */ md.start = function() {\n        // up to 56-bit message length for convenience\n        md.messageLength = 0;\n        // full message length (set md.messageLength128 for backwards-compatibility)\n        md.fullMessageLength = md.messageLength128 = [];\n        var int32s = md.messageLengthSize / 4;\n        for(var i = 0; i < int32s; ++i){\n            md.fullMessageLength.push(0);\n        }\n        _input = forge.util.createBuffer();\n        _h = new Array(_state.length);\n        for(var i = 0; i < _state.length; ++i){\n            _h[i] = _state[i].slice(0);\n        }\n        return md;\n    };\n    // start digest automatically for first time\n    md.start();\n    /**\n   * Updates the digest with the given message input. The given input can\n   * treated as raw input (no encoding will be applied) or an encoding of\n   * 'utf8' maybe given to encode the input using UTF-8.\n   *\n   * @param msg the message input to update with.\n   * @param encoding the encoding to use (default: 'raw', other: 'utf8').\n   *\n   * @return this digest object.\n   */ md.update = function(msg, encoding) {\n        if (encoding === \"utf8\") {\n            msg = forge.util.encodeUtf8(msg);\n        }\n        // update message length\n        var len = msg.length;\n        md.messageLength += len;\n        len = [\n            len / 0x100000000 >>> 0,\n            len >>> 0\n        ];\n        for(var i = md.fullMessageLength.length - 1; i >= 0; --i){\n            md.fullMessageLength[i] += len[1];\n            len[1] = len[0] + (md.fullMessageLength[i] / 0x100000000 >>> 0);\n            md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\n            len[0] = len[1] / 0x100000000 >>> 0;\n        }\n        // add bytes to input buffer\n        _input.putBytes(msg);\n        // process bytes\n        _update(_h, _w, _input);\n        // compact input buffer every 2K or if empty\n        if (_input.read > 2048 || _input.length() === 0) {\n            _input.compact();\n        }\n        return md;\n    };\n    /**\n   * Produces the digest.\n   *\n   * @return a byte buffer containing the digest value.\n   */ md.digest = function() {\n        /* Note: Here we copy the remaining bytes in the input buffer and\n    add the appropriate SHA-512 padding. Then we do the final update\n    on a copy of the state so that if the user wants to get\n    intermediate digests they can do so. */ /* Determine the number of bytes that must be added to the message\n    to ensure its length is congruent to 896 mod 1024. In other words,\n    the data to be digested must be a multiple of 1024 bits (or 128 bytes).\n    This data includes the message, some padding, and the length of the\n    message. Since the length of the message will be encoded as 16 bytes (128\n    bits), that means that the last segment of the data must have 112 bytes\n    (896 bits) of message and padding. Therefore, the length of the message\n    plus the padding must be congruent to 896 mod 1024 because\n    1024 - 128 = 896.\n\n    In order to fill up the message length it must be filled with\n    padding that begins with 1 bit followed by all 0 bits. Padding\n    must *always* be present, so if the message length is already\n    congruent to 896 mod 1024, then 1024 padding bits must be added. */ var finalBlock = forge.util.createBuffer();\n        finalBlock.putBytes(_input.bytes());\n        // compute remaining size to be digested (include message length size)\n        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;\n        // add padding for overflow blockSize - overflow\n        // _padding starts with 1 byte with first bit is set (byte value 128), then\n        // there may be up to (blockSize - 1) other pad bytes\n        var overflow = remaining & md.blockLength - 1;\n        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\n        // serialize message length in bits in big-endian order; since length\n        // is stored in bytes we multiply by 8 and add carry from next int\n        var next, carry;\n        var bits = md.fullMessageLength[0] * 8;\n        for(var i = 0; i < md.fullMessageLength.length - 1; ++i){\n            next = md.fullMessageLength[i + 1] * 8;\n            carry = next / 0x100000000 >>> 0;\n            bits += carry;\n            finalBlock.putInt32(bits >>> 0);\n            bits = next >>> 0;\n        }\n        finalBlock.putInt32(bits);\n        var h = new Array(_h.length);\n        for(var i = 0; i < _h.length; ++i){\n            h[i] = _h[i].slice(0);\n        }\n        _update(h, _w, finalBlock);\n        var rval = forge.util.createBuffer();\n        var hlen;\n        if (algorithm === \"SHA-512\") {\n            hlen = h.length;\n        } else if (algorithm === \"SHA-384\") {\n            hlen = h.length - 2;\n        } else {\n            hlen = h.length - 4;\n        }\n        for(var i = 0; i < hlen; ++i){\n            rval.putInt32(h[i][0]);\n            if (i !== hlen - 1 || algorithm !== \"SHA-512/224\") {\n                rval.putInt32(h[i][1]);\n            }\n        }\n        return rval;\n    };\n    return md;\n};\n// sha-512 padding bytes not initialized yet\nvar _padding = null;\nvar _initialized = false;\n// table of constants\nvar _k = null;\n// initial hash states\nvar _states = null;\n/**\n * Initializes the constant tables.\n */ function _init() {\n    // create padding\n    _padding = String.fromCharCode(128);\n    _padding += forge.util.fillString(String.fromCharCode(0x00), 128);\n    // create K table for SHA-512\n    _k = [\n        [\n            0x428a2f98,\n            0xd728ae22\n        ],\n        [\n            0x71374491,\n            0x23ef65cd\n        ],\n        [\n            0xb5c0fbcf,\n            0xec4d3b2f\n        ],\n        [\n            0xe9b5dba5,\n            0x8189dbbc\n        ],\n        [\n            0x3956c25b,\n            0xf348b538\n        ],\n        [\n            0x59f111f1,\n            0xb605d019\n        ],\n        [\n            0x923f82a4,\n            0xaf194f9b\n        ],\n        [\n            0xab1c5ed5,\n            0xda6d8118\n        ],\n        [\n            0xd807aa98,\n            0xa3030242\n        ],\n        [\n            0x12835b01,\n            0x45706fbe\n        ],\n        [\n            0x243185be,\n            0x4ee4b28c\n        ],\n        [\n            0x550c7dc3,\n            0xd5ffb4e2\n        ],\n        [\n            0x72be5d74,\n            0xf27b896f\n        ],\n        [\n            0x80deb1fe,\n            0x3b1696b1\n        ],\n        [\n            0x9bdc06a7,\n            0x25c71235\n        ],\n        [\n            0xc19bf174,\n            0xcf692694\n        ],\n        [\n            0xe49b69c1,\n            0x9ef14ad2\n        ],\n        [\n            0xefbe4786,\n            0x384f25e3\n        ],\n        [\n            0x0fc19dc6,\n            0x8b8cd5b5\n        ],\n        [\n            0x240ca1cc,\n            0x77ac9c65\n        ],\n        [\n            0x2de92c6f,\n            0x592b0275\n        ],\n        [\n            0x4a7484aa,\n            0x6ea6e483\n        ],\n        [\n            0x5cb0a9dc,\n            0xbd41fbd4\n        ],\n        [\n            0x76f988da,\n            0x831153b5\n        ],\n        [\n            0x983e5152,\n            0xee66dfab\n        ],\n        [\n            0xa831c66d,\n            0x2db43210\n        ],\n        [\n            0xb00327c8,\n            0x98fb213f\n        ],\n        [\n            0xbf597fc7,\n            0xbeef0ee4\n        ],\n        [\n            0xc6e00bf3,\n            0x3da88fc2\n        ],\n        [\n            0xd5a79147,\n            0x930aa725\n        ],\n        [\n            0x06ca6351,\n            0xe003826f\n        ],\n        [\n            0x14292967,\n            0x0a0e6e70\n        ],\n        [\n            0x27b70a85,\n            0x46d22ffc\n        ],\n        [\n            0x2e1b2138,\n            0x5c26c926\n        ],\n        [\n            0x4d2c6dfc,\n            0x5ac42aed\n        ],\n        [\n            0x53380d13,\n            0x9d95b3df\n        ],\n        [\n            0x650a7354,\n            0x8baf63de\n        ],\n        [\n            0x766a0abb,\n            0x3c77b2a8\n        ],\n        [\n            0x81c2c92e,\n            0x47edaee6\n        ],\n        [\n            0x92722c85,\n            0x1482353b\n        ],\n        [\n            0xa2bfe8a1,\n            0x4cf10364\n        ],\n        [\n            0xa81a664b,\n            0xbc423001\n        ],\n        [\n            0xc24b8b70,\n            0xd0f89791\n        ],\n        [\n            0xc76c51a3,\n            0x0654be30\n        ],\n        [\n            0xd192e819,\n            0xd6ef5218\n        ],\n        [\n            0xd6990624,\n            0x5565a910\n        ],\n        [\n            0xf40e3585,\n            0x5771202a\n        ],\n        [\n            0x106aa070,\n            0x32bbd1b8\n        ],\n        [\n            0x19a4c116,\n            0xb8d2d0c8\n        ],\n        [\n            0x1e376c08,\n            0x5141ab53\n        ],\n        [\n            0x2748774c,\n            0xdf8eeb99\n        ],\n        [\n            0x34b0bcb5,\n            0xe19b48a8\n        ],\n        [\n            0x391c0cb3,\n            0xc5c95a63\n        ],\n        [\n            0x4ed8aa4a,\n            0xe3418acb\n        ],\n        [\n            0x5b9cca4f,\n            0x7763e373\n        ],\n        [\n            0x682e6ff3,\n            0xd6b2b8a3\n        ],\n        [\n            0x748f82ee,\n            0x5defb2fc\n        ],\n        [\n            0x78a5636f,\n            0x43172f60\n        ],\n        [\n            0x84c87814,\n            0xa1f0ab72\n        ],\n        [\n            0x8cc70208,\n            0x1a6439ec\n        ],\n        [\n            0x90befffa,\n            0x23631e28\n        ],\n        [\n            0xa4506ceb,\n            0xde82bde9\n        ],\n        [\n            0xbef9a3f7,\n            0xb2c67915\n        ],\n        [\n            0xc67178f2,\n            0xe372532b\n        ],\n        [\n            0xca273ece,\n            0xea26619c\n        ],\n        [\n            0xd186b8c7,\n            0x21c0c207\n        ],\n        [\n            0xeada7dd6,\n            0xcde0eb1e\n        ],\n        [\n            0xf57d4f7f,\n            0xee6ed178\n        ],\n        [\n            0x06f067aa,\n            0x72176fba\n        ],\n        [\n            0x0a637dc5,\n            0xa2c898a6\n        ],\n        [\n            0x113f9804,\n            0xbef90dae\n        ],\n        [\n            0x1b710b35,\n            0x131c471b\n        ],\n        [\n            0x28db77f5,\n            0x23047d84\n        ],\n        [\n            0x32caab7b,\n            0x40c72493\n        ],\n        [\n            0x3c9ebe0a,\n            0x15c9bebc\n        ],\n        [\n            0x431d67c4,\n            0x9c100d4c\n        ],\n        [\n            0x4cc5d4be,\n            0xcb3e42b6\n        ],\n        [\n            0x597f299c,\n            0xfc657e2a\n        ],\n        [\n            0x5fcb6fab,\n            0x3ad6faec\n        ],\n        [\n            0x6c44198c,\n            0x4a475817\n        ]\n    ];\n    // initial hash states\n    _states = {};\n    _states[\"SHA-512\"] = [\n        [\n            0x6a09e667,\n            0xf3bcc908\n        ],\n        [\n            0xbb67ae85,\n            0x84caa73b\n        ],\n        [\n            0x3c6ef372,\n            0xfe94f82b\n        ],\n        [\n            0xa54ff53a,\n            0x5f1d36f1\n        ],\n        [\n            0x510e527f,\n            0xade682d1\n        ],\n        [\n            0x9b05688c,\n            0x2b3e6c1f\n        ],\n        [\n            0x1f83d9ab,\n            0xfb41bd6b\n        ],\n        [\n            0x5be0cd19,\n            0x137e2179\n        ]\n    ];\n    _states[\"SHA-384\"] = [\n        [\n            0xcbbb9d5d,\n            0xc1059ed8\n        ],\n        [\n            0x629a292a,\n            0x367cd507\n        ],\n        [\n            0x9159015a,\n            0x3070dd17\n        ],\n        [\n            0x152fecd8,\n            0xf70e5939\n        ],\n        [\n            0x67332667,\n            0xffc00b31\n        ],\n        [\n            0x8eb44a87,\n            0x68581511\n        ],\n        [\n            0xdb0c2e0d,\n            0x64f98fa7\n        ],\n        [\n            0x47b5481d,\n            0xbefa4fa4\n        ]\n    ];\n    _states[\"SHA-512/256\"] = [\n        [\n            0x22312194,\n            0xFC2BF72C\n        ],\n        [\n            0x9F555FA3,\n            0xC84C64C2\n        ],\n        [\n            0x2393B86B,\n            0x6F53B151\n        ],\n        [\n            0x96387719,\n            0x5940EABD\n        ],\n        [\n            0x96283EE2,\n            0xA88EFFE3\n        ],\n        [\n            0xBE5E1E25,\n            0x53863992\n        ],\n        [\n            0x2B0199FC,\n            0x2C85B8AA\n        ],\n        [\n            0x0EB72DDC,\n            0x81C52CA2\n        ]\n    ];\n    _states[\"SHA-512/224\"] = [\n        [\n            0x8C3D37C8,\n            0x19544DA2\n        ],\n        [\n            0x73E19966,\n            0x89DCD4D6\n        ],\n        [\n            0x1DFAB7AE,\n            0x32FF9C82\n        ],\n        [\n            0x679DD514,\n            0x582F9FCF\n        ],\n        [\n            0x0F6D2B69,\n            0x7BD44DA8\n        ],\n        [\n            0x77E36F73,\n            0x04C48942\n        ],\n        [\n            0x3F9D85A8,\n            0x6A1D36C8\n        ],\n        [\n            0x1112E6AD,\n            0x91D692A1\n        ]\n    ];\n    // now initialized\n    _initialized = true;\n}\n/**\n * Updates a SHA-512 state with the given byte buffer.\n *\n * @param s the SHA-512 state to update.\n * @param w the array to use to store words.\n * @param bytes the byte buffer to update with.\n */ function _update(s, w, bytes) {\n    // consume 512 bit (128 byte) chunks\n    var t1_hi, t1_lo;\n    var t2_hi, t2_lo;\n    var s0_hi, s0_lo;\n    var s1_hi, s1_lo;\n    var ch_hi, ch_lo;\n    var maj_hi, maj_lo;\n    var a_hi, a_lo;\n    var b_hi, b_lo;\n    var c_hi, c_lo;\n    var d_hi, d_lo;\n    var e_hi, e_lo;\n    var f_hi, f_lo;\n    var g_hi, g_lo;\n    var h_hi, h_lo;\n    var i, hi, lo, w2, w7, w15, w16;\n    var len = bytes.length();\n    while(len >= 128){\n        // the w array will be populated with sixteen 64-bit big-endian words\n        // and then extended into 64 64-bit words according to SHA-512\n        for(i = 0; i < 16; ++i){\n            w[i][0] = bytes.getInt32() >>> 0;\n            w[i][1] = bytes.getInt32() >>> 0;\n        }\n        for(; i < 80; ++i){\n            // for word 2 words ago: ROTR 19(x) ^ ROTR 61(x) ^ SHR 6(x)\n            w2 = w[i - 2];\n            hi = w2[0];\n            lo = w2[1];\n            // high bits\n            t1_hi = ((hi >>> 19 | lo << 13) ^ // ROTR 19\n            (lo >>> 29 | hi << 3) ^ // ROTR 61/(swap + ROTR 29)\n            hi >>> 6) >>> 0; // SHR 6\n            // low bits\n            t1_lo = ((hi << 13 | lo >>> 19) ^ // ROTR 19\n            (lo << 3 | hi >>> 29) ^ // ROTR 61/(swap + ROTR 29)\n            (hi << 26 | lo >>> 6)) >>> 0; // SHR 6\n            // for word 15 words ago: ROTR 1(x) ^ ROTR 8(x) ^ SHR 7(x)\n            w15 = w[i - 15];\n            hi = w15[0];\n            lo = w15[1];\n            // high bits\n            t2_hi = ((hi >>> 1 | lo << 31) ^ // ROTR 1\n            (hi >>> 8 | lo << 24) ^ // ROTR 8\n            hi >>> 7) >>> 0; // SHR 7\n            // low bits\n            t2_lo = ((hi << 31 | lo >>> 1) ^ // ROTR 1\n            (hi << 24 | lo >>> 8) ^ // ROTR 8\n            (hi << 25 | lo >>> 7)) >>> 0; // SHR 7\n            // sum(t1, word 7 ago, t2, word 16 ago) modulo 2^64 (carry lo overflow)\n            w7 = w[i - 7];\n            w16 = w[i - 16];\n            lo = t1_lo + w7[1] + t2_lo + w16[1];\n            w[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 0x100000000 >>> 0) >>> 0;\n            w[i][1] = lo >>> 0;\n        }\n        // initialize hash value for this chunk\n        a_hi = s[0][0];\n        a_lo = s[0][1];\n        b_hi = s[1][0];\n        b_lo = s[1][1];\n        c_hi = s[2][0];\n        c_lo = s[2][1];\n        d_hi = s[3][0];\n        d_lo = s[3][1];\n        e_hi = s[4][0];\n        e_lo = s[4][1];\n        f_hi = s[5][0];\n        f_lo = s[5][1];\n        g_hi = s[6][0];\n        g_lo = s[6][1];\n        h_hi = s[7][0];\n        h_lo = s[7][1];\n        // round function\n        for(i = 0; i < 80; ++i){\n            // Sum1(e) = ROTR 14(e) ^ ROTR 18(e) ^ ROTR 41(e)\n            s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14\n            (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18\n            (e_lo >>> 9 | e_hi << 23)) >>> 0; // ROTR 41/(swap + ROTR 9)\n            s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14\n            (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18\n            (e_lo << 23 | e_hi >>> 9)) >>> 0; // ROTR 41/(swap + ROTR 9)\n            // Ch(e, f, g) (optimized the same way as SHA-1)\n            ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;\n            ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;\n            // Sum0(a) = ROTR 28(a) ^ ROTR 34(a) ^ ROTR 39(a)\n            s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28\n            (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)\n            (a_lo >>> 7 | a_hi << 25)) >>> 0; // ROTR 39/(swap + ROTR 7)\n            s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28\n            (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)\n            (a_lo << 25 | a_hi >>> 7)) >>> 0; // ROTR 39/(swap + ROTR 7)\n            // Maj(a, b, c) (optimized the same way as SHA-1)\n            maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;\n            maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;\n            // main algorithm\n            // t1 = (h + s1 + ch + _k[i] + _w[i]) modulo 2^64 (carry lo overflow)\n            lo = h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1];\n            t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + (lo / 0x100000000 >>> 0) >>> 0;\n            t1_lo = lo >>> 0;\n            // t2 = s0 + maj modulo 2^64 (carry lo overflow)\n            lo = s0_lo + maj_lo;\n            t2_hi = s0_hi + maj_hi + (lo / 0x100000000 >>> 0) >>> 0;\n            t2_lo = lo >>> 0;\n            h_hi = g_hi;\n            h_lo = g_lo;\n            g_hi = f_hi;\n            g_lo = f_lo;\n            f_hi = e_hi;\n            f_lo = e_lo;\n            // e = (d + t1) modulo 2^64 (carry lo overflow)\n            lo = d_lo + t1_lo;\n            e_hi = d_hi + t1_hi + (lo / 0x100000000 >>> 0) >>> 0;\n            e_lo = lo >>> 0;\n            d_hi = c_hi;\n            d_lo = c_lo;\n            c_hi = b_hi;\n            c_lo = b_lo;\n            b_hi = a_hi;\n            b_lo = a_lo;\n            // a = (t1 + t2) modulo 2^64 (carry lo overflow)\n            lo = t1_lo + t2_lo;\n            a_hi = t1_hi + t2_hi + (lo / 0x100000000 >>> 0) >>> 0;\n            a_lo = lo >>> 0;\n        }\n        // update hash state (additional modulo 2^64)\n        lo = s[0][1] + a_lo;\n        s[0][0] = s[0][0] + a_hi + (lo / 0x100000000 >>> 0) >>> 0;\n        s[0][1] = lo >>> 0;\n        lo = s[1][1] + b_lo;\n        s[1][0] = s[1][0] + b_hi + (lo / 0x100000000 >>> 0) >>> 0;\n        s[1][1] = lo >>> 0;\n        lo = s[2][1] + c_lo;\n        s[2][0] = s[2][0] + c_hi + (lo / 0x100000000 >>> 0) >>> 0;\n        s[2][1] = lo >>> 0;\n        lo = s[3][1] + d_lo;\n        s[3][0] = s[3][0] + d_hi + (lo / 0x100000000 >>> 0) >>> 0;\n        s[3][1] = lo >>> 0;\n        lo = s[4][1] + e_lo;\n        s[4][0] = s[4][0] + e_hi + (lo / 0x100000000 >>> 0) >>> 0;\n        s[4][1] = lo >>> 0;\n        lo = s[5][1] + f_lo;\n        s[5][0] = s[5][0] + f_hi + (lo / 0x100000000 >>> 0) >>> 0;\n        s[5][1] = lo >>> 0;\n        lo = s[6][1] + g_lo;\n        s[6][0] = s[6][0] + g_hi + (lo / 0x100000000 >>> 0) >>> 0;\n        s[6][1] = lo >>> 0;\n        lo = s[7][1] + h_lo;\n        s[7][0] = s[7][0] + h_hi + (lo / 0x100000000 >>> 0) >>> 0;\n        s[7][1] = lo >>> 0;\n        len -= 128;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvc2hhNTEyLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztDQVdDO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVIsSUFBSUMsU0FBU0MsT0FBT0MsT0FBTyxHQUFHSixNQUFNRSxNQUFNLEdBQUdGLE1BQU1FLE1BQU0sSUFBSSxDQUFDO0FBRTlELFVBQVU7QUFDVkYsTUFBTUssRUFBRSxDQUFDSCxNQUFNLEdBQUdGLE1BQU1LLEVBQUUsQ0FBQ0MsVUFBVSxDQUFDSixNQUFNLEdBQUdBO0FBRS9DLFVBQVU7QUFDVixJQUFJSyxTQUFTUCxNQUFNTyxNQUFNLEdBQUdQLE1BQU1FLE1BQU0sQ0FBQ0ssTUFBTSxHQUFHUCxNQUFNRSxNQUFNLENBQUNLLE1BQU0sSUFBSSxDQUFDO0FBQzFFQSxPQUFPQyxNQUFNLEdBQUc7SUFDZCxPQUFPTixPQUFPTSxNQUFNLENBQUM7QUFDdkI7QUFDQVIsTUFBTUssRUFBRSxDQUFDRSxNQUFNLEdBQUdQLE1BQU1LLEVBQUUsQ0FBQ0MsVUFBVSxDQUFDQyxNQUFNLEdBQUdBO0FBRS9DLGNBQWM7QUFDZFAsTUFBTUUsTUFBTSxDQUFDTyxNQUFNLEdBQUdULE1BQU1FLE1BQU0sQ0FBQ08sTUFBTSxJQUFJO0lBQzNDRCxRQUFRO1FBQ04sT0FBT04sT0FBT00sTUFBTSxDQUFDO0lBQ3ZCO0FBQ0Y7QUFDQVIsTUFBTUssRUFBRSxDQUFDLGFBQWEsR0FBR0wsTUFBTUssRUFBRSxDQUFDQyxVQUFVLENBQUMsYUFBYSxHQUN4RE4sTUFBTUUsTUFBTSxDQUFDTyxNQUFNO0FBRXJCLGNBQWM7QUFDZFQsTUFBTUUsTUFBTSxDQUFDUSxNQUFNLEdBQUdWLE1BQU1FLE1BQU0sQ0FBQ1EsTUFBTSxJQUFJO0lBQzNDRixRQUFRO1FBQ04sT0FBT04sT0FBT00sTUFBTSxDQUFDO0lBQ3ZCO0FBQ0Y7QUFDQVIs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QVc7UUFDbEQ7WUFBQztZQUFZO1NBQVc7UUFBRTtZQUFDO1lBQVk7U0FBVztRQUNsRDtZQUFDO1lBQVk7U0FBVztRQUFFO1lBQUM7WUFBWTtTQUFXO1FBQ2xEO1lBQUM7WUFBWTtTQUFXO1FBQUU7WUFBQztZQUFZO1NBQVc7UUFDbEQ7WUFBQztZQUFZO1NBQVc7UUFBRTtZQUFDO1lBQVk7U0FBVztRQUNsRDtZQUFDO1lBQVk7U0FBVztRQUFFO1lBQUM7WUFBWTtTQUFXO1FBQ2xEO1lBQUM7WUFBWTtTQUFXO1FBQUU7WUFBQztZQUFZO1NBQVc7UUFDbEQ7WUFBQztZQUFZO1NBQVc7UUFBRTtZQUFDO1lBQVk7U0FBVztRQUNsRDtZQUFDO1lBQVk7U0FBVztRQUFFO1lBQUM7WUFBWTtTQUFXO1FBQ2xEO1lBQUM7WUFBWTtTQUFXO1FBQUU7WUFBQztZQUFZO1NBQVc7UUFDbEQ7WUFBQztZQUFZO1NBQVc7UUFBRTtZQUFDO1lBQVk7U0FBVztRQUNsRDtZQUFDO1lBQVk7U0FBVztRQUFFO1lBQUM7WUFBWTtTQUFXO1FBQ2xEO1lBQUM7WUFBWTtTQUFXO1FBQUU7WUFBQztZQUFZO1NBQVc7UUFDbEQ7WUFBQztZQUFZO1NBQVc7UUFBRTtZQUFDO1lBQVk7U0FBVztRQUNsRDtZQUFDO1lBQVk7U0FBVztRQUFFO1lBQUM7WUFBWTtTQUFXO1FBQ2xEO1lBQUM7WUFBWTtTQUFXO1FBQUU7WUFBQztZQUFZO1NBQVc7UUFDbEQ7WUFBQztZQUFZO1NBQVc7UUFBRTtZQUFDO1lBQVk7U0FBVztRQUNsRDtZQUFDO1lBQVk7U0FBVztRQUFFO1lBQUM7WUFBWTtTQUFXO1FBQ2xEO1lBQUM7WUFBWTtTQUFXO1FBQUU7WUFBQztZQUFZO1NBQVc7UUFDbEQ7WUFBQztZQUFZO1NBQVc7UUFBRTtZQUFDO1lBQVk7U0FBVztRQUNsRDtZQUFDO1lBQVk7U0FBVztRQUFFO1lBQUM7WUFBWTtTQUFXO1FBQ2xEO1lBQUM7WUFBWTtTQUFXO1FBQUU7WUFBQztZQUFZO1NBQVc7UUFDbEQ7WUFBQztZQUFZO1NBQVc7UUFBRTtZQUFDO1lBQVk7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R0FBRzRCLE9BQVEsTUFBTSxnQkFBaUIsT0FBUTtRQUM1RDVCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHK0IsT0FBTztRQUVqQnRELE9BQU87SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3NoYTUxMi5qcz9hMjMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2VjdXJlIEhhc2ggQWxnb3JpdGhtIHdpdGggYSAxMDI0LWJpdCBibG9jayBzaXplIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFRoaXMgaW5jbHVkZXM6IFNIQS01MTIsIFNIQS0zODQsIFNIQS01MTIvMjI0LCBhbmQgU0hBLTUxMi8yNTYuIEZvclxuICogU0hBLTI1NiAoYmxvY2sgc2l6ZSA1MTIgYml0cyksIHNlZSBzaGEyNTYuanMuXG4gKlxuICogU2VlIEZJUFMgMTgwLTQgZm9yIGRldGFpbHMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL21kJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIHNoYTUxMiA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2Uuc2hhNTEyID0gZm9yZ2Uuc2hhNTEyIHx8IHt9O1xuXG4vLyBTSEEtNTEyXG5mb3JnZS5tZC5zaGE1MTIgPSBmb3JnZS5tZC5hbGdvcml0aG1zLnNoYTUxMiA9IHNoYTUxMjtcblxuLy8gU0hBLTM4NFxudmFyIHNoYTM4NCA9IGZvcmdlLnNoYTM4NCA9IGZvcmdlLnNoYTUxMi5zaGEzODQgPSBmb3JnZS5zaGE1MTIuc2hhMzg0IHx8IHt9O1xuc2hhMzg0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gc2hhNTEyLmNyZWF0ZSgnU0hBLTM4NCcpO1xufTtcbmZvcmdlLm1kLnNoYTM4NCA9IGZvcmdlLm1kLmFsZ29yaXRobXMuc2hhMzg0ID0gc2hhMzg0O1xuXG4vLyBTSEEtNTEyLzI1NlxuZm9yZ2Uuc2hhNTEyLnNoYTI1NiA9IGZvcmdlLnNoYTUxMi5zaGEyNTYgfHwge1xuICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzaGE1MTIuY3JlYXRlKCdTSEEtNTEyLzI1NicpO1xuICB9XG59O1xuZm9yZ2UubWRbJ3NoYTUxMi8yNTYnXSA9IGZvcmdlLm1kLmFsZ29yaXRobXNbJ3NoYTUxMi8yNTYnXSA9XG4gIGZvcmdlLnNoYTUxMi5zaGEyNTY7XG5cbi8vIFNIQS01MTIvMjI0XG5mb3JnZS5zaGE1MTIuc2hhMjI0ID0gZm9yZ2Uuc2hhNTEyLnNoYTIyNCB8fCB7XG4gIGNyZWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNoYTUxMi5jcmVhdGUoJ1NIQS01MTIvMjI0Jyk7XG4gIH1cbn07XG5mb3JnZS5tZFsnc2hhNTEyLzIyNCddID0gZm9yZ2UubWQuYWxnb3JpdGhtc1snc2hhNTEyLzIyNCddID1cbiAgZm9yZ2Uuc2hhNTEyLnNoYTIyNDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgU0hBLTIgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBhbGdvcml0aG0gdGhlIGFsZ29yaXRobSB0byB1c2UgKFNIQS01MTIsIFNIQS0zODQsIFNIQS01MTIvMjI0LFxuICogICAgICAgICAgU0hBLTUxMi8yNTYpLlxuICpcbiAqIEByZXR1cm4gYSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKi9cbnNoYTUxMi5jcmVhdGUgPSBmdW5jdGlvbihhbGdvcml0aG0pIHtcbiAgLy8gZG8gaW5pdGlhbGl6YXRpb24gYXMgbmVjZXNzYXJ5XG4gIGlmKCFfaW5pdGlhbGl6ZWQpIHtcbiAgICBfaW5pdCgpO1xuICB9XG5cbiAgaWYodHlwZW9mIGFsZ29yaXRobSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBhbGdvcml0aG0gPSAnU0hBLTUxMic7XG4gIH1cblxuICBpZighKGFsZ29yaXRobSBpbiBfc3RhdGVzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBTSEEtNTEyIGFsZ29yaXRobTogJyArIGFsZ29yaXRobSk7XG4gIH1cblxuICAvLyBTSEEtNTEyIHN0YXRlIGNvbnRhaW5zIGVpZ2h0IDY0LWJpdCBpbnRlZ2VycyAoZWFjaCBhcyB0d28gMzItYml0IGludHMpXG4gIHZhciBfc3RhdGUgPSBfc3RhdGVzW2FsZ29yaXRobV07XG4gIHZhciBfaCA9IG51bGw7XG5cbiAgLy8gaW5wdXQgYnVmZmVyXG4gIHZhciBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIHVzZWQgZm9yIDY0LWJpdCB3b3JkIHN0b3JhZ2VcbiAgdmFyIF93ID0gbmV3IEFycmF5KDgwKTtcbiAgZm9yKHZhciB3aSA9IDA7IHdpIDwgODA7ICsrd2kpIHtcbiAgICBfd1t3aV0gPSBuZXcgQXJyYXkoMik7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgZGlnZXN0IGxlbmd0aCBieSBhbGdvcml0aG0gbmFtZSAoZGVmYXVsdClcbiAgdmFyIGRpZ2VzdExlbmd0aCA9IDY0O1xuICBzd2l0Y2goYWxnb3JpdGhtKSB7XG4gICAgY2FzZSAnU0hBLTM4NCc6XG4gICAgICBkaWdlc3RMZW5ndGggPSA0ODtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1NIQS01MTIvMjU2JzpcbiAgICAgIGRpZ2VzdExlbmd0aCA9IDMyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnU0hBLTUxMi8yMjQnOlxuICAgICAgZGlnZXN0TGVuZ3RoID0gMjg7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIG1lc3NhZ2UgZGlnZXN0IG9iamVjdFxuICB2YXIgbWQgPSB7XG4gICAgLy8gU0hBLTUxMiA9PiBzaGE1MTJcbiAgICBhbGdvcml0aG06IGFsZ29yaXRobS5yZXBsYWNlKCctJywgJycpLnRvTG93ZXJDYXNlKCksXG4gICAgYmxvY2tMZW5ndGg6IDEyOCxcbiAgICBkaWdlc3RMZW5ndGg6IGRpZ2VzdExlbmd0aCxcbiAgICAvLyA1Ni1iaXQgbGVuZ3RoIG9mIG1lc3NhZ2Ugc28gZmFyIChkb2VzIG5vdCBpbmNsdWRpbmcgcGFkZGluZylcbiAgICBtZXNzYWdlTGVuZ3RoOiAwLFxuICAgIC8vIHRydWUgbWVzc2FnZSBsZW5ndGhcbiAgICBmdWxsTWVzc2FnZUxlbmd0aDogbnVsbCxcbiAgICAvLyBzaXplIG9mIG1lc3NhZ2UgbGVuZ3RoIGluIGJ5dGVzXG4gICAgbWVzc2FnZUxlbmd0aFNpemU6IDE2XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgZGlnZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRoaXMgZGlnZXN0IG9iamVjdC5cbiAgICovXG4gIG1kLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gdXAgdG8gNTYtYml0IG1lc3NhZ2UgbGVuZ3RoIGZvciBjb252ZW5pZW5jZVxuICAgIG1kLm1lc3NhZ2VMZW5ndGggPSAwO1xuXG4gICAgLy8gZnVsbCBtZXNzYWdlIGxlbmd0aCAoc2V0IG1kLm1lc3NhZ2VMZW5ndGgxMjggZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5KVxuICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoID0gbWQubWVzc2FnZUxlbmd0aDEyOCA9IFtdO1xuICAgIHZhciBpbnQzMnMgPSBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSAvIDQ7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGludDMyczsgKytpKSB7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aC5wdXNoKDApO1xuICAgIH1cbiAgICBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIF9oID0gbmV3IEFycmF5KF9zdGF0ZS5sZW5ndGgpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBfc3RhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgIF9oW2ldID0gX3N0YXRlW2ldLnNsaWNlKDApO1xuICAgIH1cbiAgICByZXR1cm4gbWQ7XG4gIH07XG4gIC8vIHN0YXJ0IGRpZ2VzdCBhdXRvbWF0aWNhbGx5IGZvciBmaXJzdCB0aW1lXG4gIG1kLnN0YXJ0KCk7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGRpZ2VzdCB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlIGlucHV0LiBUaGUgZ2l2ZW4gaW5wdXQgY2FuXG4gICAqIHRyZWF0ZWQgYXMgcmF3IGlucHV0IChubyBlbmNvZGluZyB3aWxsIGJlIGFwcGxpZWQpIG9yIGFuIGVuY29kaW5nIG9mXG4gICAqICd1dGY4JyBtYXliZSBnaXZlbiB0byBlbmNvZGUgdGhlIGlucHV0IHVzaW5nIFVURi04LlxuICAgKlxuICAgKiBAcGFyYW0gbXNnIHRoZSBtZXNzYWdlIGlucHV0IHRvIHVwZGF0ZSB3aXRoLlxuICAgKiBAcGFyYW0gZW5jb2RpbmcgdGhlIGVuY29kaW5nIHRvIHVzZSAoZGVmYXVsdDogJ3JhdycsIG90aGVyOiAndXRmOCcpLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoaXMgZGlnZXN0IG9iamVjdC5cbiAgICovXG4gIG1kLnVwZGF0ZSA9IGZ1bmN0aW9uKG1zZywgZW5jb2RpbmcpIHtcbiAgICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICBtc2cgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgobXNnKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgbWVzc2FnZSBsZW5ndGhcbiAgICB2YXIgbGVuID0gbXNnLmxlbmd0aDtcbiAgICBtZC5tZXNzYWdlTGVuZ3RoICs9IGxlbjtcbiAgICBsZW4gPSBbKGxlbiAvIDB4MTAwMDAwMDAwKSA+Pj4gMCwgbGVuID4+PiAwXTtcbiAgICBmb3IodmFyIGkgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gKz0gbGVuWzFdO1xuICAgICAgbGVuWzFdID0gbGVuWzBdICsgKChtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSAvIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldID4+PiAwO1xuICAgICAgbGVuWzBdID0gKChsZW5bMV0gLyAweDEwMDAwMDAwMCkgPj4+IDApO1xuICAgIH1cblxuICAgIC8vIGFkZCBieXRlcyB0byBpbnB1dCBidWZmZXJcbiAgICBfaW5wdXQucHV0Qnl0ZXMobXNnKTtcblxuICAgIC8vIHByb2Nlc3MgYnl0ZXNcbiAgICBfdXBkYXRlKF9oLCBfdywgX2lucHV0KTtcblxuICAgIC8vIGNvbXBhY3QgaW5wdXQgYnVmZmVyIGV2ZXJ5IDJLIG9yIGlmIGVtcHR5XG4gICAgaWYoX2lucHV0LnJlYWQgPiAyMDQ4IHx8IF9pbnB1dC5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgX2lucHV0LmNvbXBhY3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIHRoZSBkaWdlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gYSBieXRlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBkaWdlc3QgdmFsdWUuXG4gICAqL1xuICBtZC5kaWdlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBOb3RlOiBIZXJlIHdlIGNvcHkgdGhlIHJlbWFpbmluZyBieXRlcyBpbiB0aGUgaW5wdXQgYnVmZmVyIGFuZFxuICAgIGFkZCB0aGUgYXBwcm9wcmlhdGUgU0hBLTUxMiBwYWRkaW5nLiBUaGVuIHdlIGRvIHRoZSBmaW5hbCB1cGRhdGVcbiAgICBvbiBhIGNvcHkgb2YgdGhlIHN0YXRlIHNvIHRoYXQgaWYgdGhlIHVzZXIgd2FudHMgdG8gZ2V0XG4gICAgaW50ZXJtZWRpYXRlIGRpZ2VzdHMgdGhleSBjYW4gZG8gc28uICovXG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBieXRlcyB0aGF0IG11c3QgYmUgYWRkZWQgdG8gdGhlIG1lc3NhZ2VcbiAgICB0byBlbnN1cmUgaXRzIGxlbmd0aCBpcyBjb25ncnVlbnQgdG8gODk2IG1vZCAxMDI0LiBJbiBvdGhlciB3b3JkcyxcbiAgICB0aGUgZGF0YSB0byBiZSBkaWdlc3RlZCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTAyNCBiaXRzIChvciAxMjggYnl0ZXMpLlxuICAgIFRoaXMgZGF0YSBpbmNsdWRlcyB0aGUgbWVzc2FnZSwgc29tZSBwYWRkaW5nLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICBtZXNzYWdlLiBTaW5jZSB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlIHdpbGwgYmUgZW5jb2RlZCBhcyAxNiBieXRlcyAoMTI4XG4gICAgYml0cyksIHRoYXQgbWVhbnMgdGhhdCB0aGUgbGFzdCBzZWdtZW50IG9mIHRoZSBkYXRhIG11c3QgaGF2ZSAxMTIgYnl0ZXNcbiAgICAoODk2IGJpdHMpIG9mIG1lc3NhZ2UgYW5kIHBhZGRpbmcuIFRoZXJlZm9yZSwgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZVxuICAgIHBsdXMgdGhlIHBhZGRpbmcgbXVzdCBiZSBjb25ncnVlbnQgdG8gODk2IG1vZCAxMDI0IGJlY2F1c2VcbiAgICAxMDI0IC0gMTI4ID0gODk2LlxuXG4gICAgSW4gb3JkZXIgdG8gZmlsbCB1cCB0aGUgbWVzc2FnZSBsZW5ndGggaXQgbXVzdCBiZSBmaWxsZWQgd2l0aFxuICAgIHBhZGRpbmcgdGhhdCBiZWdpbnMgd2l0aCAxIGJpdCBmb2xsb3dlZCBieSBhbGwgMCBiaXRzLiBQYWRkaW5nXG4gICAgbXVzdCAqYWx3YXlzKiBiZSBwcmVzZW50LCBzbyBpZiB0aGUgbWVzc2FnZSBsZW5ndGggaXMgYWxyZWFkeVxuICAgIGNvbmdydWVudCB0byA4OTYgbW9kIDEwMjQsIHRoZW4gMTAyNCBwYWRkaW5nIGJpdHMgbXVzdCBiZSBhZGRlZC4gKi9cblxuICAgIHZhciBmaW5hbEJsb2NrID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBmaW5hbEJsb2NrLnB1dEJ5dGVzKF9pbnB1dC5ieXRlcygpKTtcblxuICAgIC8vIGNvbXB1dGUgcmVtYWluaW5nIHNpemUgdG8gYmUgZGlnZXN0ZWQgKGluY2x1ZGUgbWVzc2FnZSBsZW5ndGggc2l6ZSlcbiAgICB2YXIgcmVtYWluaW5nID0gKFxuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMV0gK1xuICAgICAgbWQubWVzc2FnZUxlbmd0aFNpemUpO1xuXG4gICAgLy8gYWRkIHBhZGRpbmcgZm9yIG92ZXJmbG93IGJsb2NrU2l6ZSAtIG92ZXJmbG93XG4gICAgLy8gX3BhZGRpbmcgc3RhcnRzIHdpdGggMSBieXRlIHdpdGggZmlyc3QgYml0IGlzIHNldCAoYnl0ZSB2YWx1ZSAxMjgpLCB0aGVuXG4gICAgLy8gdGhlcmUgbWF5IGJlIHVwIHRvIChibG9ja1NpemUgLSAxKSBvdGhlciBwYWQgYnl0ZXNcbiAgICB2YXIgb3ZlcmZsb3cgPSByZW1haW5pbmcgJiAobWQuYmxvY2tMZW5ndGggLSAxKTtcbiAgICBmaW5hbEJsb2NrLnB1dEJ5dGVzKF9wYWRkaW5nLnN1YnN0cigwLCBtZC5ibG9ja0xlbmd0aCAtIG92ZXJmbG93KSk7XG5cbiAgICAvLyBzZXJpYWxpemUgbWVzc2FnZSBsZW5ndGggaW4gYml0cyBpbiBiaWctZW5kaWFuIG9yZGVyOyBzaW5jZSBsZW5ndGhcbiAgICAvLyBpcyBzdG9yZWQgaW4gYnl0ZXMgd2UgbXVsdGlwbHkgYnkgOCBhbmQgYWRkIGNhcnJ5IGZyb20gbmV4dCBpbnRcbiAgICB2YXIgbmV4dCwgY2Fycnk7XG4gICAgdmFyIGJpdHMgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFswXSAqIDg7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgbmV4dCA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2kgKyAxXSAqIDg7XG4gICAgICBjYXJyeSA9IChuZXh0IC8gMHgxMDAwMDAwMDApID4+PiAwO1xuICAgICAgYml0cyArPSBjYXJyeTtcbiAgICAgIGZpbmFsQmxvY2sucHV0SW50MzIoYml0cyA+Pj4gMCk7XG4gICAgICBiaXRzID0gbmV4dCA+Pj4gMDtcbiAgICB9XG4gICAgZmluYWxCbG9jay5wdXRJbnQzMihiaXRzKTtcblxuICAgIHZhciBoID0gbmV3IEFycmF5KF9oLmxlbmd0aCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IF9oLmxlbmd0aDsgKytpKSB7XG4gICAgICBoW2ldID0gX2hbaV0uc2xpY2UoMCk7XG4gICAgfVxuICAgIF91cGRhdGUoaCwgX3csIGZpbmFsQmxvY2spO1xuICAgIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB2YXIgaGxlbjtcbiAgICBpZihhbGdvcml0aG0gPT09ICdTSEEtNTEyJykge1xuICAgICAgaGxlbiA9IGgubGVuZ3RoO1xuICAgIH0gZWxzZSBpZihhbGdvcml0aG0gPT09ICdTSEEtMzg0Jykge1xuICAgICAgaGxlbiA9IGgubGVuZ3RoIC0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgaGxlbiA9IGgubGVuZ3RoIC0gNDtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGhsZW47ICsraSkge1xuICAgICAgcnZhbC5wdXRJbnQzMihoW2ldWzBdKTtcbiAgICAgIGlmKGkgIT09IGhsZW4gLSAxIHx8IGFsZ29yaXRobSAhPT0gJ1NIQS01MTIvMjI0Jykge1xuICAgICAgICBydmFsLnB1dEludDMyKGhbaV1bMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICByZXR1cm4gbWQ7XG59O1xuXG4vLyBzaGEtNTEyIHBhZGRpbmcgYnl0ZXMgbm90IGluaXRpYWxpemVkIHlldFxudmFyIF9wYWRkaW5nID0gbnVsbDtcbnZhciBfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuLy8gdGFibGUgb2YgY29uc3RhbnRzXG52YXIgX2sgPSBudWxsO1xuXG4vLyBpbml0aWFsIGhhc2ggc3RhdGVzXG52YXIgX3N0YXRlcyA9IG51bGw7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbnN0YW50IHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gX2luaXQoKSB7XG4gIC8vIGNyZWF0ZSBwYWRkaW5nXG4gIF9wYWRkaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxMjgpO1xuICBfcGFkZGluZyArPSBmb3JnZS51dGlsLmZpbGxTdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZSgweDAwKSwgMTI4KTtcblxuICAvLyBjcmVhdGUgSyB0YWJsZSBmb3IgU0hBLTUxMlxuICBfayA9IFtcbiAgICBbMHg0MjhhMmY5OCwgMHhkNzI4YWUyMl0sIFsweDcxMzc0NDkxLCAweDIzZWY2NWNkXSxcbiAgICBbMHhiNWMwZmJjZiwgMHhlYzRkM2IyZl0sIFsweGU5YjVkYmE1LCAweDgxODlkYmJjXSxcbiAgICBbMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOF0sIFsweDU5ZjExMWYxLCAweGI2MDVkMDE5XSxcbiAgICBbMHg5MjNmODJhNCwgMHhhZjE5NGY5Yl0sIFsweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4XSxcbiAgICBbMHhkODA3YWE5OCwgMHhhMzAzMDI0Ml0sIFsweDEyODM1YjAxLCAweDQ1NzA2ZmJlXSxcbiAgICBbMHgyNDMxODViZSwgMHg0ZWU0YjI4Y10sIFsweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyXSxcbiAgICBbMHg3MmJlNWQ3NCwgMHhmMjdiODk2Zl0sIFsweDgwZGViMWZlLCAweDNiMTY5NmIxXSxcbiAgICBbMHg5YmRjMDZhNywgMHgyNWM3MTIzNV0sIFsweGMxOWJmMTc0LCAweGNmNjkyNjk0XSxcbiAgICBbMHhlNDliNjljMSwgMHg5ZWYxNGFkMl0sIFsweGVmYmU0Nzg2LCAweDM4NGYyNWUzXSxcbiAgICBbMHgwZmMxOWRjNiwgMHg4YjhjZDViNV0sIFsweDI0MGNhMWNjLCAweDc3YWM5YzY1XSxcbiAgICBbMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NV0sIFsweDRhNzQ4NGFhLCAweDZlYTZlNDgzXSxcbiAgICBbMHg1Y2IwYTlkYywgMHhiZDQxZmJkNF0sIFsweDc2Zjk4OGRhLCAweDgzMTE1M2I1XSxcbiAgICBbMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYl0sIFsweGE4MzFjNjZkLCAweDJkYjQzMjEwXSxcbiAgICBbMHhiMDAzMjdjOCwgMHg5OGZiMjEzZl0sIFsweGJmNTk3ZmM3LCAweGJlZWYwZWU0XSxcbiAgICBbMHhjNmUwMGJmMywgMHgzZGE4OGZjMl0sIFsweGQ1YTc5MTQ3LCAweDkzMGFhNzI1XSxcbiAgICBbMHgwNmNhNjM1MSwgMHhlMDAzODI2Zl0sIFsweDE0MjkyOTY3LCAweDBhMGU2ZTcwXSxcbiAgICBbMHgyN2I3MGE4NSwgMHg0NmQyMmZmY10sIFsweDJlMWIyMTM4LCAweDVjMjZjOTI2XSxcbiAgICBbMHg0ZDJjNmRmYywgMHg1YWM0MmFlZF0sIFsweDUzMzgwZDEzLCAweDlkOTViM2RmXSxcbiAgICBbMHg2NTBhNzM1NCwgMHg4YmFmNjNkZV0sIFsweDc2NmEwYWJiLCAweDNjNzdiMmE4XSxcbiAgICBbMHg4MWMyYzkyZSwgMHg0N2VkYWVlNl0sIFsweDkyNzIyYzg1LCAweDE0ODIzNTNiXSxcbiAgICBbMHhhMmJmZThhMSwgMHg0Y2YxMDM2NF0sIFsweGE4MWE2NjRiLCAweGJjNDIzMDAxXSxcbiAgICBbMHhjMjRiOGI3MCwgMHhkMGY4OTc5MV0sIFsweGM3NmM1MWEzLCAweDA2NTRiZTMwXSxcbiAgICBbMHhkMTkyZTgxOSwgMHhkNmVmNTIxOF0sIFsweGQ2OTkwNjI0LCAweDU1NjVhOTEwXSxcbiAgICBbMHhmNDBlMzU4NSwgMHg1NzcxMjAyYV0sIFsweDEwNmFhMDcwLCAweDMyYmJkMWI4XSxcbiAgICBbMHgxOWE0YzExNiwgMHhiOGQyZDBjOF0sIFsweDFlMzc2YzA4LCAweDUxNDFhYjUzXSxcbiAgICBbMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OV0sIFsweDM0YjBiY2I1LCAweGUxOWI0OGE4XSxcbiAgICBbMHgzOTFjMGNiMywgMHhjNWM5NWE2M10sIFsweDRlZDhhYTRhLCAweGUzNDE4YWNiXSxcbiAgICBbMHg1YjljY2E0ZiwgMHg3NzYzZTM3M10sIFsweDY4MmU2ZmYzLCAweGQ2YjJiOGEzXSxcbiAgICBbMHg3NDhmODJlZSwgMHg1ZGVmYjJmY10sIFsweDc4YTU2MzZmLCAweDQzMTcyZjYwXSxcbiAgICBbMHg4NGM4NzgxNCwgMHhhMWYwYWI3Ml0sIFsweDhjYzcwMjA4LCAweDFhNjQzOWVjXSxcbiAgICBbMHg5MGJlZmZmYSwgMHgyMzYzMWUyOF0sIFsweGE0NTA2Y2ViLCAweGRlODJiZGU5XSxcbiAgICBbMHhiZWY5YTNmNywgMHhiMmM2NzkxNV0sIFsweGM2NzE3OGYyLCAweGUzNzI1MzJiXSxcbiAgICBbMHhjYTI3M2VjZSwgMHhlYTI2NjE5Y10sIFsweGQxODZiOGM3LCAweDIxYzBjMjA3XSxcbiAgICBbMHhlYWRhN2RkNiwgMHhjZGUwZWIxZV0sIFsweGY1N2Q0ZjdmLCAweGVlNmVkMTc4XSxcbiAgICBbMHgwNmYwNjdhYSwgMHg3MjE3NmZiYV0sIFsweDBhNjM3ZGM1LCAweGEyYzg5OGE2XSxcbiAgICBbMHgxMTNmOTgwNCwgMHhiZWY5MGRhZV0sIFsweDFiNzEwYjM1LCAweDEzMWM0NzFiXSxcbiAgICBbMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NF0sIFsweDMyY2FhYjdiLCAweDQwYzcyNDkzXSxcbiAgICBbMHgzYzllYmUwYSwgMHgxNWM5YmViY10sIFsweDQzMWQ2N2M0LCAweDljMTAwZDRjXSxcbiAgICBbMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNl0sIFsweDU5N2YyOTljLCAweGZjNjU3ZTJhXSxcbiAgICBbMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlY10sIFsweDZjNDQxOThjLCAweDRhNDc1ODE3XVxuICBdO1xuXG4gIC8vIGluaXRpYWwgaGFzaCBzdGF0ZXNcbiAgX3N0YXRlcyA9IHt9O1xuICBfc3RhdGVzWydTSEEtNTEyJ10gPSBbXG4gICAgWzB4NmEwOWU2NjcsIDB4ZjNiY2M5MDhdLFxuICAgIFsweGJiNjdhZTg1LCAweDg0Y2FhNzNiXSxcbiAgICBbMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYl0sXG4gICAgWzB4YTU0ZmY1M2EsIDB4NWYxZDM2ZjFdLFxuICAgIFsweDUxMGU1MjdmLCAweGFkZTY4MmQxXSxcbiAgICBbMHg5YjA1Njg4YywgMHgyYjNlNmMxZl0sXG4gICAgWzB4MWY4M2Q5YWIsIDB4ZmI0MWJkNmJdLFxuICAgIFsweDViZTBjZDE5LCAweDEzN2UyMTc5XVxuICBdO1xuICBfc3RhdGVzWydTSEEtMzg0J10gPSBbXG4gICAgWzB4Y2JiYjlkNWQsIDB4YzEwNTllZDhdLFxuICAgIFsweDYyOWEyOTJhLCAweDM2N2NkNTA3XSxcbiAgICBbMHg5MTU5MDE1YSwgMHgzMDcwZGQxN10sXG4gICAgWzB4MTUyZmVjZDgsIDB4ZjcwZTU5MzldLFxuICAgIFsweDY3MzMyNjY3LCAweGZmYzAwYjMxXSxcbiAgICBbMHg4ZWI0NGE4NywgMHg2ODU4MTUxMV0sXG4gICAgWzB4ZGIwYzJlMGQsIDB4NjRmOThmYTddLFxuICAgIFsweDQ3YjU0ODFkLCAweGJlZmE0ZmE0XVxuICBdO1xuICBfc3RhdGVzWydTSEEtNTEyLzI1NiddID0gW1xuICAgIFsweDIyMzEyMTk0LCAweEZDMkJGNzJDXSxcbiAgICBbMHg5RjU1NUZBMywgMHhDODRDNjRDMl0sXG4gICAgWzB4MjM5M0I4NkIsIDB4NkY1M0IxNTFdLFxuICAgIFsweDk2Mzg3NzE5LCAweDU5NDBFQUJEXSxcbiAgICBbMHg5NjI4M0VFMiwgMHhBODhFRkZFM10sXG4gICAgWzB4QkU1RTFFMjUsIDB4NTM4NjM5OTJdLFxuICAgIFsweDJCMDE5OUZDLCAweDJDODVCOEFBXSxcbiAgICBbMHgwRUI3MkREQywgMHg4MUM1MkNBMl1cbiAgXTtcbiAgX3N0YXRlc1snU0hBLTUxMi8yMjQnXSA9IFtcbiAgICBbMHg4QzNEMzdDOCwgMHgxOTU0NERBMl0sXG4gICAgWzB4NzNFMTk5NjYsIDB4ODlEQ0Q0RDZdLFxuICAgIFsweDFERkFCN0FFLCAweDMyRkY5QzgyXSxcbiAgICBbMHg2NzlERDUxNCwgMHg1ODJGOUZDRl0sXG4gICAgWzB4MEY2RDJCNjksIDB4N0JENDREQThdLFxuICAgIFsweDc3RTM2RjczLCAweDA0QzQ4OTQyXSxcbiAgICBbMHgzRjlEODVBOCwgMHg2QTFEMzZDOF0sXG4gICAgWzB4MTExMkU2QUQsIDB4OTFENjkyQTFdXG4gIF07XG5cbiAgLy8gbm93IGluaXRpYWxpemVkXG4gIF9pbml0aWFsaXplZCA9IHRydWU7XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIFNIQS01MTIgc3RhdGUgd2l0aCB0aGUgZ2l2ZW4gYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIHMgdGhlIFNIQS01MTIgc3RhdGUgdG8gdXBkYXRlLlxuICogQHBhcmFtIHcgdGhlIGFycmF5IHRvIHVzZSB0byBzdG9yZSB3b3Jkcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gdXBkYXRlIHdpdGguXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGUocywgdywgYnl0ZXMpIHtcbiAgLy8gY29uc3VtZSA1MTIgYml0ICgxMjggYnl0ZSkgY2h1bmtzXG4gIHZhciB0MV9oaSwgdDFfbG87XG4gIHZhciB0Ml9oaSwgdDJfbG87XG4gIHZhciBzMF9oaSwgczBfbG87XG4gIHZhciBzMV9oaSwgczFfbG87XG4gIHZhciBjaF9oaSwgY2hfbG87XG4gIHZhciBtYWpfaGksIG1hal9sbztcbiAgdmFyIGFfaGksIGFfbG87XG4gIHZhciBiX2hpLCBiX2xvO1xuICB2YXIgY19oaSwgY19sbztcbiAgdmFyIGRfaGksIGRfbG87XG4gIHZhciBlX2hpLCBlX2xvO1xuICB2YXIgZl9oaSwgZl9sbztcbiAgdmFyIGdfaGksIGdfbG87XG4gIHZhciBoX2hpLCBoX2xvO1xuICB2YXIgaSwgaGksIGxvLCB3MiwgdzcsIHcxNSwgdzE2O1xuICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoKCk7XG4gIHdoaWxlKGxlbiA+PSAxMjgpIHtcbiAgICAvLyB0aGUgdyBhcnJheSB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIHNpeHRlZW4gNjQtYml0IGJpZy1lbmRpYW4gd29yZHNcbiAgICAvLyBhbmQgdGhlbiBleHRlbmRlZCBpbnRvIDY0IDY0LWJpdCB3b3JkcyBhY2NvcmRpbmcgdG8gU0hBLTUxMlxuICAgIGZvcihpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIHdbaV1bMF0gPSBieXRlcy5nZXRJbnQzMigpID4+PiAwO1xuICAgICAgd1tpXVsxXSA9IGJ5dGVzLmdldEludDMyKCkgPj4+IDA7XG4gICAgfVxuICAgIGZvcig7IGkgPCA4MDsgKytpKSB7XG4gICAgICAvLyBmb3Igd29yZCAyIHdvcmRzIGFnbzogUk9UUiAxOSh4KSBeIFJPVFIgNjEoeCkgXiBTSFIgNih4KVxuICAgICAgdzIgPSB3W2kgLSAyXTtcbiAgICAgIGhpID0gdzJbMF07XG4gICAgICBsbyA9IHcyWzFdO1xuXG4gICAgICAvLyBoaWdoIGJpdHNcbiAgICAgIHQxX2hpID0gKFxuICAgICAgICAoKGhpID4+PiAxOSkgfCAobG8gPDwgMTMpKSBeIC8vIFJPVFIgMTlcbiAgICAgICAgKChsbyA+Pj4gMjkpIHwgKGhpIDw8IDMpKSBeIC8vIFJPVFIgNjEvKHN3YXAgKyBST1RSIDI5KVxuICAgICAgICAoaGkgPj4+IDYpKSA+Pj4gMDsgLy8gU0hSIDZcbiAgICAgIC8vIGxvdyBiaXRzXG4gICAgICB0MV9sbyA9IChcbiAgICAgICAgKChoaSA8PCAxMykgfCAobG8gPj4+IDE5KSkgXiAvLyBST1RSIDE5XG4gICAgICAgICgobG8gPDwgMykgfCAoaGkgPj4+IDI5KSkgXiAvLyBST1RSIDYxLyhzd2FwICsgUk9UUiAyOSlcbiAgICAgICAgKChoaSA8PCAyNikgfCAobG8gPj4+IDYpKSkgPj4+IDA7IC8vIFNIUiA2XG5cbiAgICAgIC8vIGZvciB3b3JkIDE1IHdvcmRzIGFnbzogUk9UUiAxKHgpIF4gUk9UUiA4KHgpIF4gU0hSIDcoeClcbiAgICAgIHcxNSA9IHdbaSAtIDE1XTtcbiAgICAgIGhpID0gdzE1WzBdO1xuICAgICAgbG8gPSB3MTVbMV07XG5cbiAgICAgIC8vIGhpZ2ggYml0c1xuICAgICAgdDJfaGkgPSAoXG4gICAgICAgICgoaGkgPj4+IDEpIHwgKGxvIDw8IDMxKSkgXiAvLyBST1RSIDFcbiAgICAgICAgKChoaSA+Pj4gOCkgfCAobG8gPDwgMjQpKSBeIC8vIFJPVFIgOFxuICAgICAgICAoaGkgPj4+IDcpKSA+Pj4gMDsgLy8gU0hSIDdcbiAgICAgIC8vIGxvdyBiaXRzXG4gICAgICB0Ml9sbyA9IChcbiAgICAgICAgKChoaSA8PCAzMSkgfCAobG8gPj4+IDEpKSBeIC8vIFJPVFIgMVxuICAgICAgICAoKGhpIDw8IDI0KSB8IChsbyA+Pj4gOCkpIF4gLy8gUk9UUiA4XG4gICAgICAgICgoaGkgPDwgMjUpIHwgKGxvID4+PiA3KSkpID4+PiAwOyAvLyBTSFIgN1xuXG4gICAgICAvLyBzdW0odDEsIHdvcmQgNyBhZ28sIHQyLCB3b3JkIDE2IGFnbykgbW9kdWxvIDJeNjQgKGNhcnJ5IGxvIG92ZXJmbG93KVxuICAgICAgdzcgPSB3W2kgLSA3XTtcbiAgICAgIHcxNiA9IHdbaSAtIDE2XTtcbiAgICAgIGxvID0gKHQxX2xvICsgdzdbMV0gKyB0Ml9sbyArIHcxNlsxXSk7XG4gICAgICB3W2ldWzBdID0gKHQxX2hpICsgdzdbMF0gKyB0Ml9oaSArIHcxNlswXSArXG4gICAgICAgICgobG8gLyAweDEwMDAwMDAwMCkgPj4+IDApKSA+Pj4gMDtcbiAgICAgIHdbaV1bMV0gPSBsbyA+Pj4gMDtcbiAgICB9XG5cbiAgICAvLyBpbml0aWFsaXplIGhhc2ggdmFsdWUgZm9yIHRoaXMgY2h1bmtcbiAgICBhX2hpID0gc1swXVswXTtcbiAgICBhX2xvID0gc1swXVsxXTtcbiAgICBiX2hpID0gc1sxXVswXTtcbiAgICBiX2xvID0gc1sxXVsxXTtcbiAgICBjX2hpID0gc1syXVswXTtcbiAgICBjX2xvID0gc1syXVsxXTtcbiAgICBkX2hpID0gc1szXVswXTtcbiAgICBkX2xvID0gc1szXVsxXTtcbiAgICBlX2hpID0gc1s0XVswXTtcbiAgICBlX2xvID0gc1s0XVsxXTtcbiAgICBmX2hpID0gc1s1XVswXTtcbiAgICBmX2xvID0gc1s1XVsxXTtcbiAgICBnX2hpID0gc1s2XVswXTtcbiAgICBnX2xvID0gc1s2XVsxXTtcbiAgICBoX2hpID0gc1s3XVswXTtcbiAgICBoX2xvID0gc1s3XVsxXTtcblxuICAgIC8vIHJvdW5kIGZ1bmN0aW9uXG4gICAgZm9yKGkgPSAwOyBpIDwgODA7ICsraSkge1xuICAgICAgLy8gU3VtMShlKSA9IFJPVFIgMTQoZSkgXiBST1RSIDE4KGUpIF4gUk9UUiA0MShlKVxuICAgICAgczFfaGkgPSAoXG4gICAgICAgICgoZV9oaSA+Pj4gMTQpIHwgKGVfbG8gPDwgMTgpKSBeIC8vIFJPVFIgMTRcbiAgICAgICAgKChlX2hpID4+PiAxOCkgfCAoZV9sbyA8PCAxNCkpIF4gLy8gUk9UUiAxOFxuICAgICAgICAoKGVfbG8gPj4+IDkpIHwgKGVfaGkgPDwgMjMpKSkgPj4+IDA7IC8vIFJPVFIgNDEvKHN3YXAgKyBST1RSIDkpXG4gICAgICBzMV9sbyA9IChcbiAgICAgICAgKChlX2hpIDw8IDE4KSB8IChlX2xvID4+PiAxNCkpIF4gLy8gUk9UUiAxNFxuICAgICAgICAoKGVfaGkgPDwgMTQpIHwgKGVfbG8gPj4+IDE4KSkgXiAvLyBST1RSIDE4XG4gICAgICAgICgoZV9sbyA8PCAyMykgfCAoZV9oaSA+Pj4gOSkpKSA+Pj4gMDsgLy8gUk9UUiA0MS8oc3dhcCArIFJPVFIgOSlcblxuICAgICAgLy8gQ2goZSwgZiwgZykgKG9wdGltaXplZCB0aGUgc2FtZSB3YXkgYXMgU0hBLTEpXG4gICAgICBjaF9oaSA9IChnX2hpIF4gKGVfaGkgJiAoZl9oaSBeIGdfaGkpKSkgPj4+IDA7XG4gICAgICBjaF9sbyA9IChnX2xvIF4gKGVfbG8gJiAoZl9sbyBeIGdfbG8pKSkgPj4+IDA7XG5cbiAgICAgIC8vIFN1bTAoYSkgPSBST1RSIDI4KGEpIF4gUk9UUiAzNChhKSBeIFJPVFIgMzkoYSlcbiAgICAgIHMwX2hpID0gKFxuICAgICAgICAoKGFfaGkgPj4+IDI4KSB8IChhX2xvIDw8IDQpKSBeIC8vIFJPVFIgMjhcbiAgICAgICAgKChhX2xvID4+PiAyKSB8IChhX2hpIDw8IDMwKSkgXiAvLyBST1RSIDM0Lyhzd2FwICsgUk9UUiAyKVxuICAgICAgICAoKGFfbG8gPj4+IDcpIHwgKGFfaGkgPDwgMjUpKSkgPj4+IDA7IC8vIFJPVFIgMzkvKHN3YXAgKyBST1RSIDcpXG4gICAgICBzMF9sbyA9IChcbiAgICAgICAgKChhX2hpIDw8IDQpIHwgKGFfbG8gPj4+IDI4KSkgXiAvLyBST1RSIDI4XG4gICAgICAgICgoYV9sbyA8PCAzMCkgfCAoYV9oaSA+Pj4gMikpIF4gLy8gUk9UUiAzNC8oc3dhcCArIFJPVFIgMilcbiAgICAgICAgKChhX2xvIDw8IDI1KSB8IChhX2hpID4+PiA3KSkpID4+PiAwOyAvLyBST1RSIDM5Lyhzd2FwICsgUk9UUiA3KVxuXG4gICAgICAvLyBNYWooYSwgYiwgYykgKG9wdGltaXplZCB0aGUgc2FtZSB3YXkgYXMgU0hBLTEpXG4gICAgICBtYWpfaGkgPSAoKGFfaGkgJiBiX2hpKSB8IChjX2hpICYgKGFfaGkgXiBiX2hpKSkpID4+PiAwO1xuICAgICAgbWFqX2xvID0gKChhX2xvICYgYl9sbykgfCAoY19sbyAmIChhX2xvIF4gYl9sbykpKSA+Pj4gMDtcblxuICAgICAgLy8gbWFpbiBhbGdvcml0aG1cbiAgICAgIC8vIHQxID0gKGggKyBzMSArIGNoICsgX2tbaV0gKyBfd1tpXSkgbW9kdWxvIDJeNjQgKGNhcnJ5IGxvIG92ZXJmbG93KVxuICAgICAgbG8gPSAoaF9sbyArIHMxX2xvICsgY2hfbG8gKyBfa1tpXVsxXSArIHdbaV1bMV0pO1xuICAgICAgdDFfaGkgPSAoaF9oaSArIHMxX2hpICsgY2hfaGkgKyBfa1tpXVswXSArIHdbaV1bMF0gK1xuICAgICAgICAoKGxvIC8gMHgxMDAwMDAwMDApID4+PiAwKSkgPj4+IDA7XG4gICAgICB0MV9sbyA9IGxvID4+PiAwO1xuXG4gICAgICAvLyB0MiA9IHMwICsgbWFqIG1vZHVsbyAyXjY0IChjYXJyeSBsbyBvdmVyZmxvdylcbiAgICAgIGxvID0gczBfbG8gKyBtYWpfbG87XG4gICAgICB0Ml9oaSA9IChzMF9oaSArIG1hal9oaSArICgobG8gLyAweDEwMDAwMDAwMCkgPj4+IDApKSA+Pj4gMDtcbiAgICAgIHQyX2xvID0gbG8gPj4+IDA7XG5cbiAgICAgIGhfaGkgPSBnX2hpO1xuICAgICAgaF9sbyA9IGdfbG87XG5cbiAgICAgIGdfaGkgPSBmX2hpO1xuICAgICAgZ19sbyA9IGZfbG87XG5cbiAgICAgIGZfaGkgPSBlX2hpO1xuICAgICAgZl9sbyA9IGVfbG87XG5cbiAgICAgIC8vIGUgPSAoZCArIHQxKSBtb2R1bG8gMl42NCAoY2FycnkgbG8gb3ZlcmZsb3cpXG4gICAgICBsbyA9IGRfbG8gKyB0MV9sbztcbiAgICAgIGVfaGkgPSAoZF9oaSArIHQxX2hpICsgKChsbyAvIDB4MTAwMDAwMDAwKSA+Pj4gMCkpID4+PiAwO1xuICAgICAgZV9sbyA9IGxvID4+PiAwO1xuXG4gICAgICBkX2hpID0gY19oaTtcbiAgICAgIGRfbG8gPSBjX2xvO1xuXG4gICAgICBjX2hpID0gYl9oaTtcbiAgICAgIGNfbG8gPSBiX2xvO1xuXG4gICAgICBiX2hpID0gYV9oaTtcbiAgICAgIGJfbG8gPSBhX2xvO1xuXG4gICAgICAvLyBhID0gKHQxICsgdDIpIG1vZHVsbyAyXjY0IChjYXJyeSBsbyBvdmVyZmxvdylcbiAgICAgIGxvID0gdDFfbG8gKyB0Ml9sbztcbiAgICAgIGFfaGkgPSAodDFfaGkgKyB0Ml9oaSArICgobG8gLyAweDEwMDAwMDAwMCkgPj4+IDApKSA+Pj4gMDtcbiAgICAgIGFfbG8gPSBsbyA+Pj4gMDtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgaGFzaCBzdGF0ZSAoYWRkaXRpb25hbCBtb2R1bG8gMl42NClcbiAgICBsbyA9IHNbMF1bMV0gKyBhX2xvO1xuICAgIHNbMF1bMF0gPSAoc1swXVswXSArIGFfaGkgKyAoKGxvIC8gMHgxMDAwMDAwMDApID4+PiAwKSkgPj4+IDA7XG4gICAgc1swXVsxXSA9IGxvID4+PiAwO1xuXG4gICAgbG8gPSBzWzFdWzFdICsgYl9sbztcbiAgICBzWzFdWzBdID0gKHNbMV1bMF0gKyBiX2hpICsgKChsbyAvIDB4MTAwMDAwMDAwKSA+Pj4gMCkpID4+PiAwO1xuICAgIHNbMV1bMV0gPSBsbyA+Pj4gMDtcblxuICAgIGxvID0gc1syXVsxXSArIGNfbG87XG4gICAgc1syXVswXSA9IChzWzJdWzBdICsgY19oaSArICgobG8gLyAweDEwMDAwMDAwMCkgPj4+IDApKSA+Pj4gMDtcbiAgICBzWzJdWzFdID0gbG8gPj4+IDA7XG5cbiAgICBsbyA9IHNbM11bMV0gKyBkX2xvO1xuICAgIHNbM11bMF0gPSAoc1szXVswXSArIGRfaGkgKyAoKGxvIC8gMHgxMDAwMDAwMDApID4+PiAwKSkgPj4+IDA7XG4gICAgc1szXVsxXSA9IGxvID4+PiAwO1xuXG4gICAgbG8gPSBzWzRdWzFdICsgZV9sbztcbiAgICBzWzRdWzBdID0gKHNbNF1bMF0gKyBlX2hpICsgKChsbyAvIDB4MTAwMDAwMDAwKSA+Pj4gMCkpID4+PiAwO1xuICAgIHNbNF1bMV0gPSBsbyA+Pj4gMDtcblxuICAgIGxvID0gc1s1XVsxXSArIGZfbG87XG4gICAgc1s1XVswXSA9IChzWzVdWzBdICsgZl9oaSArICgobG8gLyAweDEwMDAwMDAwMCkgPj4+IDApKSA+Pj4gMDtcbiAgICBzWzVdWzFdID0gbG8gPj4+IDA7XG5cbiAgICBsbyA9IHNbNl1bMV0gKyBnX2xvO1xuICAgIHNbNl1bMF0gPSAoc1s2XVswXSArIGdfaGkgKyAoKGxvIC8gMHgxMDAwMDAwMDApID4+PiAwKSkgPj4+IDA7XG4gICAgc1s2XVsxXSA9IGxvID4+PiAwO1xuXG4gICAgbG8gPSBzWzddWzFdICsgaF9sbztcbiAgICBzWzddWzBdID0gKHNbN11bMF0gKyBoX2hpICsgKChsbyAvIDB4MTAwMDAwMDAwKSA+Pj4gMCkpID4+PiAwO1xuICAgIHNbN11bMV0gPSBsbyA+Pj4gMDtcblxuICAgIGxlbiAtPSAxMjg7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJmb3JnZSIsInJlcXVpcmUiLCJzaGE1MTIiLCJtb2R1bGUiLCJleHBvcnRzIiwibWQiLCJhbGdvcml0aG1zIiwic2hhMzg0IiwiY3JlYXRlIiwic2hhMjU2Iiwic2hhMjI0IiwiYWxnb3JpdGhtIiwiX2luaXRpYWxpemVkIiwiX2luaXQiLCJfc3RhdGVzIiwiRXJyb3IiLCJfc3RhdGUiLCJfaCIsIl9pbnB1dCIsInV0aWwiLCJjcmVhdGVCdWZmZXIiLCJfdyIsIkFycmF5Iiwid2kiLCJkaWdlc3RMZW5ndGgiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJibG9ja0xlbmd0aCIsIm1lc3NhZ2VMZW5ndGgiLCJmdWxsTWVzc2FnZUxlbmd0aCIsIm1lc3NhZ2VMZW5ndGhTaXplIiwic3RhcnQiLCJtZXNzYWdlTGVuZ3RoMTI4IiwiaW50MzJzIiwiaSIsInB1c2giLCJsZW5ndGgiLCJzbGljZSIsInVwZGF0ZSIsIm1zZyIsImVuY29kaW5nIiwiZW5jb2RlVXRmOCIsImxlbiIsInB1dEJ5dGVzIiwiX3VwZGF0ZSIsInJlYWQiLCJjb21wYWN0IiwiZGlnZXN0IiwiZmluYWxCbG9jayIsImJ5dGVzIiwicmVtYWluaW5nIiwib3ZlcmZsb3ciLCJfcGFkZGluZyIsInN1YnN0ciIsIm5leHQiLCJjYXJyeSIsImJpdHMiLCJwdXRJbnQzMiIsImgiLCJydmFsIiwiaGxlbiIsIl9rIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZmlsbFN0cmluZyIsInMiLCJ3IiwidDFfaGkiLCJ0MV9sbyIsInQyX2hpIiwidDJfbG8iLCJzMF9oaSIsInMwX2xvIiwiczFfaGkiLCJzMV9sbyIsImNoX2hpIiwiY2hfbG8iLCJtYWpfaGkiLCJtYWpfbG8iLCJhX2hpIiwiYV9sbyIsImJfaGkiLCJiX2xvIiwiY19oaSIsImNfbG8iLCJkX2hpIiwiZF9sbyIsImVfaGkiLCJlX2xvIiwiZl9oaSIsImZfbG8iLCJnX2hpIiwiZ19sbyIsImhfaGkiLCJoX2xvIiwiaGkiLCJsbyIsIncyIiwidzciLCJ3MTUiLCJ3MTYiLCJnZXRJbnQzMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/sha512.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/ssh.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/ssh.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Functions to output keys in SSH-friendly formats.\n *\n * This is part of the Forge project which may be used under the terms of\n * either the BSD License or the GNU General Public License (GPL) Version 2.\n *\n * See: https://github.com/digitalbazaar/forge/blob/cbebca3780658703d925b61b2caffb1d263a6c1d/LICENSE\n *\n * @author https://github.com/shellac\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./aes */ \"(rsc)/./node_modules/node-forge/lib/aes.js\");\n__webpack_require__(/*! ./hmac */ \"(rsc)/./node_modules/node-forge/lib/hmac.js\");\n__webpack_require__(/*! ./md5 */ \"(rsc)/./node_modules/node-forge/lib/md5.js\");\n__webpack_require__(/*! ./sha1 */ \"(rsc)/./node_modules/node-forge/lib/sha1.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\nvar ssh = module.exports = forge.ssh = forge.ssh || {};\n/**\n * Encodes (and optionally encrypts) a private RSA key as a Putty PPK file.\n *\n * @param privateKey the key.\n * @param passphrase a passphrase to protect the key (falsy for no encryption).\n * @param comment a comment to include in the key file.\n *\n * @return the PPK file as a string.\n */ ssh.privateKeyToPutty = function(privateKey, passphrase, comment) {\n    comment = comment || \"\";\n    passphrase = passphrase || \"\";\n    var algorithm = \"ssh-rsa\";\n    var encryptionAlgorithm = passphrase === \"\" ? \"none\" : \"aes256-cbc\";\n    var ppk = \"PuTTY-User-Key-File-2: \" + algorithm + \"\\r\\n\";\n    ppk += \"Encryption: \" + encryptionAlgorithm + \"\\r\\n\";\n    ppk += \"Comment: \" + comment + \"\\r\\n\";\n    // public key into buffer for ppk\n    var pubbuffer = forge.util.createBuffer();\n    _addStringToBuffer(pubbuffer, algorithm);\n    _addBigIntegerToBuffer(pubbuffer, privateKey.e);\n    _addBigIntegerToBuffer(pubbuffer, privateKey.n);\n    // write public key\n    var pub = forge.util.encode64(pubbuffer.bytes(), 64);\n    var length = Math.floor(pub.length / 66) + 1; // 66 = 64 + \\r\\n\n    ppk += \"Public-Lines: \" + length + \"\\r\\n\";\n    ppk += pub;\n    // private key into a buffer\n    var privbuffer = forge.util.createBuffer();\n    _addBigIntegerToBuffer(privbuffer, privateKey.d);\n    _addBigIntegerToBuffer(privbuffer, privateKey.p);\n    _addBigIntegerToBuffer(privbuffer, privateKey.q);\n    _addBigIntegerToBuffer(privbuffer, privateKey.qInv);\n    // optionally encrypt the private key\n    var priv;\n    if (!passphrase) {\n        // use the unencrypted buffer\n        priv = forge.util.encode64(privbuffer.bytes(), 64);\n    } else {\n        // encrypt RSA key using passphrase\n        var encLen = privbuffer.length() + 16 - 1;\n        encLen -= encLen % 16;\n        // pad private key with sha1-d data -- needs to be a multiple of 16\n        var padding = _sha1(privbuffer.bytes());\n        padding.truncate(padding.length() - encLen + privbuffer.length());\n        privbuffer.putBuffer(padding);\n        var aeskey = forge.util.createBuffer();\n        aeskey.putBuffer(_sha1(\"\\x00\\x00\\x00\\x00\", passphrase));\n        aeskey.putBuffer(_sha1(\"\\x00\\x00\\x00\\x01\", passphrase));\n        // encrypt some bytes using CBC mode\n        // key is 40 bytes, so truncate *by* 8 bytes\n        var cipher = forge.aes.createEncryptionCipher(aeskey.truncate(8), \"CBC\");\n        cipher.start(forge.util.createBuffer().fillWithByte(0, 16));\n        cipher.update(privbuffer.copy());\n        cipher.finish();\n        var encrypted = cipher.output;\n        // Note: this appears to differ from Putty -- is forge wrong, or putty?\n        // due to padding we finish as an exact multiple of 16\n        encrypted.truncate(16); // all padding\n        priv = forge.util.encode64(encrypted.bytes(), 64);\n    }\n    // output private key\n    length = Math.floor(priv.length / 66) + 1; // 64 + \\r\\n\n    ppk += \"\\r\\nPrivate-Lines: \" + length + \"\\r\\n\";\n    ppk += priv;\n    // MAC\n    var mackey = _sha1(\"putty-private-key-file-mac-key\", passphrase);\n    var macbuffer = forge.util.createBuffer();\n    _addStringToBuffer(macbuffer, algorithm);\n    _addStringToBuffer(macbuffer, encryptionAlgorithm);\n    _addStringToBuffer(macbuffer, comment);\n    macbuffer.putInt32(pubbuffer.length());\n    macbuffer.putBuffer(pubbuffer);\n    macbuffer.putInt32(privbuffer.length());\n    macbuffer.putBuffer(privbuffer);\n    var hmac = forge.hmac.create();\n    hmac.start(\"sha1\", mackey);\n    hmac.update(macbuffer.bytes());\n    ppk += \"\\r\\nPrivate-MAC: \" + hmac.digest().toHex() + \"\\r\\n\";\n    return ppk;\n};\n/**\n * Encodes a public RSA key as an OpenSSH file.\n *\n * @param key the key.\n * @param comment a comment.\n *\n * @return the public key in OpenSSH format.\n */ ssh.publicKeyToOpenSSH = function(key, comment) {\n    var type = \"ssh-rsa\";\n    comment = comment || \"\";\n    var buffer = forge.util.createBuffer();\n    _addStringToBuffer(buffer, type);\n    _addBigIntegerToBuffer(buffer, key.e);\n    _addBigIntegerToBuffer(buffer, key.n);\n    return type + \" \" + forge.util.encode64(buffer.bytes()) + \" \" + comment;\n};\n/**\n * Encodes a private RSA key as an OpenSSH file.\n *\n * @param key the key.\n * @param passphrase a passphrase to protect the key (falsy for no encryption).\n *\n * @return the public key in OpenSSH format.\n */ ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {\n    if (!passphrase) {\n        return forge.pki.privateKeyToPem(privateKey);\n    }\n    // OpenSSH private key is just a legacy format, it seems\n    return forge.pki.encryptRsaPrivateKey(privateKey, passphrase, {\n        legacy: true,\n        algorithm: \"aes128\"\n    });\n};\n/**\n * Gets the SSH fingerprint for the given public key.\n *\n * @param options the options to use.\n *          [md] the message digest object to use (defaults to forge.md.md5).\n *          [encoding] an alternative output encoding, such as 'hex'\n *            (defaults to none, outputs a byte buffer).\n *          [delimiter] the delimiter to use between bytes for 'hex' encoded\n *            output, eg: ':' (defaults to none).\n *\n * @return the fingerprint as a byte buffer or other encoding based on options.\n */ ssh.getPublicKeyFingerprint = function(key, options) {\n    options = options || {};\n    var md = options.md || forge.md.md5.create();\n    var type = \"ssh-rsa\";\n    var buffer = forge.util.createBuffer();\n    _addStringToBuffer(buffer, type);\n    _addBigIntegerToBuffer(buffer, key.e);\n    _addBigIntegerToBuffer(buffer, key.n);\n    // hash public key bytes\n    md.start();\n    md.update(buffer.getBytes());\n    var digest = md.digest();\n    if (options.encoding === \"hex\") {\n        var hex = digest.toHex();\n        if (options.delimiter) {\n            return hex.match(/.{2}/g).join(options.delimiter);\n        }\n        return hex;\n    } else if (options.encoding === \"binary\") {\n        return digest.getBytes();\n    } else if (options.encoding) {\n        throw new Error('Unknown encoding \"' + options.encoding + '\".');\n    }\n    return digest;\n};\n/**\n * Adds len(val) then val to a buffer.\n *\n * @param buffer the buffer to add to.\n * @param val a big integer.\n */ function _addBigIntegerToBuffer(buffer, val) {\n    var hexVal = val.toString(16);\n    // ensure 2s complement +ve\n    if (hexVal[0] >= \"8\") {\n        hexVal = \"00\" + hexVal;\n    }\n    var bytes = forge.util.hexToBytes(hexVal);\n    buffer.putInt32(bytes.length);\n    buffer.putBytes(bytes);\n}\n/**\n * Adds len(val) then val to a buffer.\n *\n * @param buffer the buffer to add to.\n * @param val a string.\n */ function _addStringToBuffer(buffer, val) {\n    buffer.putInt32(val.length);\n    buffer.putString(val);\n}\n/**\n * Hashes the arguments into one value using SHA-1.\n *\n * @return the sha1 hash of the provided arguments.\n */ function _sha1() {\n    var sha = forge.md.sha1.create();\n    var num = arguments.length;\n    for(var i = 0; i < num; ++i){\n        sha.update(arguments[i]);\n    }\n    return sha.digest();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvc3NoLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Q0FTQztBQUNELElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUVSLElBQUlDLE1BQU1DLE9BQU9DLE9BQU8sR0FBR0osTUFBTUUsR0FBRyxHQUFHRixNQUFNRSxHQUFHLElBQUksQ0FBQztBQUVyRDs7Ozs7Ozs7Q0FRQyxHQUNEQSxJQUFJRyxpQkFBaUIsR0FBRyxTQUFTQyxVQUFVLEVBQUVDLFVBQVUsRUFBRUMsT0FBTztJQUM5REEsVUFBVUEsV0FBVztJQUNyQkQsYUFBYUEsY0FBYztJQUMzQixJQUFJRSxZQUFZO0lBQ2hCLElBQUlDLHNCQUFzQixlQUFnQixLQUFNLFNBQVM7SUFFekQsSUFBSUMsTUFBTSw0QkFBNEJGLFlBQVk7SUFDbERFLE9BQU8saUJBQWlCRCxzQkFBc0I7SUFDOUNDLE9BQU8sY0FBY0gsVUFBVTtJQUUvQixpQ0FBaUM7SUFDakMsSUFBSUksWUFBWVosTUFBTWEsSUFBSSxDQUFDQyxZQUFZO0lBQ3ZDQyxtQkFBbUJILFdBQVdIO0lBQzlCTyx1QkFBdUJKLFdBQVdOLFdBQVdXLENBQUM7SUFDOUNELHVCQUF1QkosV0FBV04sV0FBV1ksQ0FBQztJQUU5QyxtQkFBbUI7SUFDbkIsSUFBSUMsTUFBTW5CLE1BQU1hLElBQUksQ0FBQ08sUUFBUSxDQUFDUixVQUFVUyxLQUFLLElBQUk7SUFDakQsSUFBSUMsU0FBU0MsS0FBS0MsS0FBSyxDQUFDTCxJQUFJRyxNQUFNLEdBQUcsTUFBTSxHQUFHLGlCQUFpQjtJQUMvRFgsT0FBTyxtQkFBbUJXLFNBQVM7SUFDbkNYLE9BQU9RO0lBRVAsNEJBQTRCO0lBQzVCLElBQUlNLGFBQWF6QixNQUFNYSxJQUFJLENBQUNDLFlBQVk7SUFDeENFLHVCQUF1QlMsWUFBWW5CLFdBQVdvQixDQUFDO0lBQy9DVix1QkFBdUJTLFlBQVluQixXQUFXcUIsQ0FBQztJQUMvQ1gsdUJBQXVCUyxZQUFZbkIsV0FBV3NCLENBQUM7SUFDL0NaLHVCQUF1QlMsWUFBWW5CLFdBQVd1QixJQUFJO0lBRWxELHFDQUFxQztJQUNyQyxJQUFJQztJQUNKLElBQUcsQ0FBQ3ZCLFlBQVk7UUFDZCw2QkFBNkI7UUFDN0J1QixPQUFPOUIsTUFBTWEsSUFBSSxDQUFDTyxRQUFRLENBQUNLLFdBQVdKLEtBQUssSUFBSTtJQUNqRCxPQUFPO1FBQ0wsbUNBQW1DO1FBQ25DLElBQUlVLFNBQVNOLFdBQVdILE1BQU0sS0FBSyxLQUFLO1FBQ3hDUyxVQUFVQSxTQUFTO1FBRW5CLG1FQUFtRTtRQUNuRSxJQUFJQyxVQUFVQyxNQUFNUixXQUFXSixLQUFLO1FBRXBDVyxRQUFRRSxRQUFRLENBQUNGLFFBQVFWLE1BQU0sS0FBS1MsU0FBU04sV0FBV0gsTUFBTTtRQUM5REcsV0FBV1UsU0FBUyxDQUFDSDtRQUVyQixJQUFJSSxTQUFTcEMsTUFBTWEsSUFBSSxDQUFDQyxZQUFZO1FBQ3BDc0IsT0FBT0QsU0FBUyxDQUFDRixNQUFNLG9CQUFvQjFCO1FBQzNDNkIsT0FBT0QsU0FBUyxDQUFDRixNQUFNLG9CQUFvQjFCO1FBRTNDLG9DQUFvQztRQUNwQyw0Q0FBNEM7UUFDNUMsSUFBSThCLFNBQVNyQyxNQUFNc0MsR0FBRyxDQUFDQyxzQkFBc0IsQ0FBQ0gsT0FBT0YsUUFBUSxDQUFDLElBQUk7UUFDbEVHLE9BQU9HLEtBQUssQ0FBQ3hDLE1BQU1hLElBQUksQ0FBQ0MsWUFBWSxHQUFHMkIsWUFBWSxDQUFDLEdBQUc7UUFDdkRKLE9BQU9LLE1BQU0sQ0FBQ2pCLFdBQVdrQixJQUFJO1FBQzdCTixPQUFPTyxNQUFNO1FBQ2IsSUFBSUMsWUFBWVIsT0FBT1MsTUFBTTtRQUU3Qix1RUFBdUU7UUFDdkUsc0RBQXNEO1FBQ3RERCxVQUFVWCxRQUFRLENBQUMsS0FBSyxjQUFjO1FBRXRDSixPQUFPOUIsTUFBTWEsSUFBSSxDQUFDTyxRQUFRLENBQUN5QixVQUFVeEIsS0FBSyxJQUFJO0lBQ2hEO0lBRUEscUJBQXFCO0lBQ3JCQyxTQUFTQyxLQUFLQyxLQUFLLENBQUNNLEtBQUtSLE1BQU0sR0FBRyxNQUFNLEdBQUcsWUFBWTtJQUN2RFgsT0FBTyx3QkFBd0JXLFNBQVM7SUFDeENYLE9BQU9tQjtJQUVQLE1BQU07SUFDTixJQUFJaUIsU0FBU2QsTUFBTSxrQ0FBa0MxQjtJQUVyRCxJQUFJeUMsWUFBWWhELE1BQU1hLElBQUksQ0FBQ0MsWUFBWTtJQUN2Q0MsbUJBQW1CaUMsV0FBV3ZDO0lBQzlCTSxtQkFBbUJpQyxXQUFXdEM7SUFDOUJLLG1CQUFtQmlDLFdBQVd4QztJQUM5QndDLFVBQVVDLFFBQVEsQ0FBQ3JDLFVBQVVVLE1BQU07SUFDbkMwQixVQUFVYixTQUFTLENBQUN2QjtJQUNwQm9DLFVBQVVDLFFBQVEsQ0FBQ3hCLFdBQVdILE1BQU07SUFDcEMwQixVQUFVYixTQUFTLENBQUNWO0lBRXBCLElBQUl5QixPQUFPbEQsTUFBTWtELElBQUksQ0FBQ0MsTUFBTTtJQUM1QkQsS0FBS1YsS0FBSyxDQUFDLFFBQVFPO0lBQ25CRyxLQUFLUixNQUFNLENBQUNNLFVBQVUzQixLQUFLO0lBRTNCVixPQUFPLHNCQUFzQnVDLEtBQUtFLE1BQU0sR0FBR0MsS0FBSyxLQUFLO0lBRXJELE9BQU8xQztBQUNUO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNEVCxJQUFJb0Qsa0JBQWtCLEdBQUcsU0FBU0MsR0FBRyxFQUFFL0MsT0FBTztJQUM1QyxJQUFJZ0QsT0FBTztJQUNYaEQsVUFBVUEsV0FBVztJQUVyQixJQUFJaUQsU0FBU3pELE1BQU1hLElBQUksQ0FBQ0MsWUFBWTtJQUNwQ0MsbUJBQW1CMEMsUUFBUUQ7SUFDM0J4Qyx1QkFBdUJ5QyxRQUFRRixJQUFJdEMsQ0FBQztJQUNwQ0QsdUJBQXVCeUMsUUFBUUYsSUFBSXJDLENBQUM7SUFFcEMsT0FBT3NDLE9BQU8sTUFBTXhELE1BQU1hLElBQUksQ0FBQ08sUUFBUSxDQUFDcUMsT0FBT3BDLEtBQUssTUFBTSxNQUFNYjtBQUNsRTtBQUVBOzs7Ozs7O0NBT0MsR0FDRE4sSUFBSXdELG1CQUFtQixHQUFHLFNBQVNwRCxVQUFVLEVBQUVDLFVBQVU7SUFDdkQsSUFBRyxDQUFDQSxZQUFZO1FBQ2QsT0FBT1AsTUFBTTJELEdBQUcsQ0FBQ0MsZUFBZSxDQUFDdEQ7SUFDbkM7SUFDQSx3REFBd0Q7SUFDeEQsT0FBT04sTUFBTTJELEdBQUcsQ0FBQ0Usb0JBQW9CLENBQUN2RCxZQUFZQyxZQUNoRDtRQUFDdUQsUUFBUTtRQUFNckQsV0FBVztJQUFRO0FBQ3RDO0FBRUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDRFAsSUFBSTZELHVCQUF1QixHQUFHLFNBQVNSLEdBQUcsRUFBRVMsT0FBTztJQUNqREEsVUFBVUEsV0FBVyxDQUFDO0lBQ3RCLElBQUlDLEtBQUtELFFBQVFDLEVBQUUsSUFBSWpFLE1BQU1pRSxFQUFFLENBQUNDLEdBQUcsQ0FBQ2YsTUFBTTtJQUUxQyxJQUFJSyxPQUFPO0lBQ1gsSUFBSUMsU0FBU3pELE1BQU1hLElBQUksQ0FBQ0MsWUFBWTtJQUNwQ0MsbUJBQW1CMEMsUUFBUUQ7SUFDM0J4Qyx1QkFBdUJ5QyxRQUFRRixJQUFJdEMsQ0FBQztJQUNwQ0QsdUJBQXVCeUMsUUFBUUYsSUFBSXJDLENBQUM7SUFFcEMsd0JBQXdCO0lBQ3hCK0MsR0FBR3pCLEtBQUs7SUFDUnlCLEdBQUd2QixNQUFNLENBQUNlLE9BQU9VLFFBQVE7SUFDekIsSUFBSWYsU0FBU2EsR0FBR2IsTUFBTTtJQUN0QixJQUFHWSxRQUFRSSxRQUFRLEtBQUssT0FBTztRQUM3QixJQUFJQyxNQUFNakIsT0FBT0MsS0FBSztRQUN0QixJQUFHVyxRQUFRTSxTQUFTLEVBQUU7WUFDcEIsT0FBT0QsSUFBSUUsS0FBSyxDQUFDLFNBQVNDLElBQUksQ0FBQ1IsUUFBUU0sU0FBUztRQUNsRDtRQUNBLE9BQU9EO0lBQ1QsT0FBTyxJQUFHTCxRQUFRSSxRQUFRLEtBQUssVUFBVTtRQUN2QyxPQUFPaEIsT0FBT2UsUUFBUTtJQUN4QixPQUFPLElBQUdILFFBQVFJLFFBQVEsRUFBRTtRQUMxQixNQUFNLElBQUlLLE1BQU0sdUJBQXVCVCxRQUFRSSxRQUFRLEdBQUc7SUFDNUQ7SUFDQSxPQUFPaEI7QUFDVDtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU3BDLHVCQUF1QnlDLE1BQU0sRUFBRWlCLEdBQUc7SUFDekMsSUFBSUMsU0FBU0QsSUFBSUUsUUFBUSxDQUFDO0lBQzFCLDJCQUEyQjtJQUMzQixJQUFHRCxNQUFNLENBQUMsRUFBRSxJQUFJLEtBQUs7UUFDbkJBLFNBQVMsT0FBT0E7SUFDbEI7SUFDQSxJQUFJdEQsUUFBUXJCLE1BQU1hLElBQUksQ0FBQ2dFLFVBQVUsQ0FBQ0Y7SUFDbENsQixPQUFPUixRQUFRLENBQUM1QixNQUFNQyxNQUFNO0lBQzVCbUMsT0FBT3FCLFFBQVEsQ0FBQ3pEO0FBQ2xCO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTTixtQkFBbUIwQyxNQUFNLEVBQUVpQixHQUFHO0lBQ3JDakIsT0FBT1IsUUFBUSxDQUFDeUIsSUFBSXBELE1BQU07SUFDMUJtQyxPQUFPc0IsU0FBUyxDQUFDTDtBQUNuQjtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTekM7SUFDUCxJQUFJK0MsTUFBTWhGLE1BQU1pRSxFQUFFLENBQUNnQixJQUFJLENBQUM5QixNQUFNO0lBQzlCLElBQUkrQixNQUFNQyxVQUFVN0QsTUFBTTtJQUMxQixJQUFLLElBQUk4RCxJQUFJLEdBQUdBLElBQUlGLEtBQUssRUFBRUUsRUFBRztRQUM1QkosSUFBSXRDLE1BQU0sQ0FBQ3lDLFNBQVMsQ0FBQ0MsRUFBRTtJQUN6QjtJQUNBLE9BQU9KLElBQUk1QixNQUFNO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3NzaC5qcz84MGQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRnVuY3Rpb25zIHRvIG91dHB1dCBrZXlzIGluIFNTSC1mcmllbmRseSBmb3JtYXRzLlxuICpcbiAqIFRoaXMgaXMgcGFydCBvZiB0aGUgRm9yZ2UgcHJvamVjdCB3aGljaCBtYXkgYmUgdXNlZCB1bmRlciB0aGUgdGVybXMgb2ZcbiAqIGVpdGhlciB0aGUgQlNEIExpY2Vuc2Ugb3IgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIChHUEwpIFZlcnNpb24gMi5cbiAqXG4gKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kaWdpdGFsYmF6YWFyL2ZvcmdlL2Jsb2IvY2JlYmNhMzc4MDY1ODcwM2Q5MjViNjFiMmNhZmZiMWQyNjNhNmMxZC9MSUNFTlNFXG4gKlxuICogQGF1dGhvciBodHRwczovL2dpdGh1Yi5jb20vc2hlbGxhY1xuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL2FlcycpO1xucmVxdWlyZSgnLi9obWFjJyk7XG5yZXF1aXJlKCcuL21kNScpO1xucmVxdWlyZSgnLi9zaGExJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIHNzaCA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2Uuc3NoID0gZm9yZ2Uuc3NoIHx8IHt9O1xuXG4vKipcbiAqIEVuY29kZXMgKGFuZCBvcHRpb25hbGx5IGVuY3J5cHRzKSBhIHByaXZhdGUgUlNBIGtleSBhcyBhIFB1dHR5IFBQSyBmaWxlLlxuICpcbiAqIEBwYXJhbSBwcml2YXRlS2V5IHRoZSBrZXkuXG4gKiBAcGFyYW0gcGFzc3BocmFzZSBhIHBhc3NwaHJhc2UgdG8gcHJvdGVjdCB0aGUga2V5IChmYWxzeSBmb3Igbm8gZW5jcnlwdGlvbikuXG4gKiBAcGFyYW0gY29tbWVudCBhIGNvbW1lbnQgdG8gaW5jbHVkZSBpbiB0aGUga2V5IGZpbGUuXG4gKlxuICogQHJldHVybiB0aGUgUFBLIGZpbGUgYXMgYSBzdHJpbmcuXG4gKi9cbnNzaC5wcml2YXRlS2V5VG9QdXR0eSA9IGZ1bmN0aW9uKHByaXZhdGVLZXksIHBhc3NwaHJhc2UsIGNvbW1lbnQpIHtcbiAgY29tbWVudCA9IGNvbW1lbnQgfHwgJyc7XG4gIHBhc3NwaHJhc2UgPSBwYXNzcGhyYXNlIHx8ICcnO1xuICB2YXIgYWxnb3JpdGhtID0gJ3NzaC1yc2EnO1xuICB2YXIgZW5jcnlwdGlvbkFsZ29yaXRobSA9IChwYXNzcGhyYXNlID09PSAnJykgPyAnbm9uZScgOiAnYWVzMjU2LWNiYyc7XG5cbiAgdmFyIHBwayA9ICdQdVRUWS1Vc2VyLUtleS1GaWxlLTI6ICcgKyBhbGdvcml0aG0gKyAnXFxyXFxuJztcbiAgcHBrICs9ICdFbmNyeXB0aW9uOiAnICsgZW5jcnlwdGlvbkFsZ29yaXRobSArICdcXHJcXG4nO1xuICBwcGsgKz0gJ0NvbW1lbnQ6ICcgKyBjb21tZW50ICsgJ1xcclxcbic7XG5cbiAgLy8gcHVibGljIGtleSBpbnRvIGJ1ZmZlciBmb3IgcHBrXG4gIHZhciBwdWJidWZmZXIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICBfYWRkU3RyaW5nVG9CdWZmZXIocHViYnVmZmVyLCBhbGdvcml0aG0pO1xuICBfYWRkQmlnSW50ZWdlclRvQnVmZmVyKHB1YmJ1ZmZlciwgcHJpdmF0ZUtleS5lKTtcbiAgX2FkZEJpZ0ludGVnZXJUb0J1ZmZlcihwdWJidWZmZXIsIHByaXZhdGVLZXkubik7XG5cbiAgLy8gd3JpdGUgcHVibGljIGtleVxuICB2YXIgcHViID0gZm9yZ2UudXRpbC5lbmNvZGU2NChwdWJidWZmZXIuYnl0ZXMoKSwgNjQpO1xuICB2YXIgbGVuZ3RoID0gTWF0aC5mbG9vcihwdWIubGVuZ3RoIC8gNjYpICsgMTsgLy8gNjYgPSA2NCArIFxcclxcblxuICBwcGsgKz0gJ1B1YmxpYy1MaW5lczogJyArIGxlbmd0aCArICdcXHJcXG4nO1xuICBwcGsgKz0gcHViO1xuXG4gIC8vIHByaXZhdGUga2V5IGludG8gYSBidWZmZXJcbiAgdmFyIHByaXZidWZmZXIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICBfYWRkQmlnSW50ZWdlclRvQnVmZmVyKHByaXZidWZmZXIsIHByaXZhdGVLZXkuZCk7XG4gIF9hZGRCaWdJbnRlZ2VyVG9CdWZmZXIocHJpdmJ1ZmZlciwgcHJpdmF0ZUtleS5wKTtcbiAgX2FkZEJpZ0ludGVnZXJUb0J1ZmZlcihwcml2YnVmZmVyLCBwcml2YXRlS2V5LnEpO1xuICBfYWRkQmlnSW50ZWdlclRvQnVmZmVyKHByaXZidWZmZXIsIHByaXZhdGVLZXkucUludik7XG5cbiAgLy8gb3B0aW9uYWxseSBlbmNyeXB0IHRoZSBwcml2YXRlIGtleVxuICB2YXIgcHJpdjtcbiAgaWYoIXBhc3NwaHJhc2UpIHtcbiAgICAvLyB1c2UgdGhlIHVuZW5jcnlwdGVkIGJ1ZmZlclxuICAgIHByaXYgPSBmb3JnZS51dGlsLmVuY29kZTY0KHByaXZidWZmZXIuYnl0ZXMoKSwgNjQpO1xuICB9IGVsc2Uge1xuICAgIC8vIGVuY3J5cHQgUlNBIGtleSB1c2luZyBwYXNzcGhyYXNlXG4gICAgdmFyIGVuY0xlbiA9IHByaXZidWZmZXIubGVuZ3RoKCkgKyAxNiAtIDE7XG4gICAgZW5jTGVuIC09IGVuY0xlbiAlIDE2O1xuXG4gICAgLy8gcGFkIHByaXZhdGUga2V5IHdpdGggc2hhMS1kIGRhdGEgLS0gbmVlZHMgdG8gYmUgYSBtdWx0aXBsZSBvZiAxNlxuICAgIHZhciBwYWRkaW5nID0gX3NoYTEocHJpdmJ1ZmZlci5ieXRlcygpKTtcblxuICAgIHBhZGRpbmcudHJ1bmNhdGUocGFkZGluZy5sZW5ndGgoKSAtIGVuY0xlbiArIHByaXZidWZmZXIubGVuZ3RoKCkpO1xuICAgIHByaXZidWZmZXIucHV0QnVmZmVyKHBhZGRpbmcpO1xuXG4gICAgdmFyIGFlc2tleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgYWVza2V5LnB1dEJ1ZmZlcihfc2hhMSgnXFx4MDBcXHgwMFxceDAwXFx4MDAnLCBwYXNzcGhyYXNlKSk7XG4gICAgYWVza2V5LnB1dEJ1ZmZlcihfc2hhMSgnXFx4MDBcXHgwMFxceDAwXFx4MDEnLCBwYXNzcGhyYXNlKSk7XG5cbiAgICAvLyBlbmNyeXB0IHNvbWUgYnl0ZXMgdXNpbmcgQ0JDIG1vZGVcbiAgICAvLyBrZXkgaXMgNDAgYnl0ZXMsIHNvIHRydW5jYXRlICpieSogOCBieXRlc1xuICAgIHZhciBjaXBoZXIgPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcihhZXNrZXkudHJ1bmNhdGUoOCksICdDQkMnKTtcbiAgICBjaXBoZXIuc3RhcnQoZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKS5maWxsV2l0aEJ5dGUoMCwgMTYpKTtcbiAgICBjaXBoZXIudXBkYXRlKHByaXZidWZmZXIuY29weSgpKTtcbiAgICBjaXBoZXIuZmluaXNoKCk7XG4gICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5vdXRwdXQ7XG5cbiAgICAvLyBOb3RlOiB0aGlzIGFwcGVhcnMgdG8gZGlmZmVyIGZyb20gUHV0dHkgLS0gaXMgZm9yZ2Ugd3JvbmcsIG9yIHB1dHR5P1xuICAgIC8vIGR1ZSB0byBwYWRkaW5nIHdlIGZpbmlzaCBhcyBhbiBleGFjdCBtdWx0aXBsZSBvZiAxNlxuICAgIGVuY3J5cHRlZC50cnVuY2F0ZSgxNik7IC8vIGFsbCBwYWRkaW5nXG5cbiAgICBwcml2ID0gZm9yZ2UudXRpbC5lbmNvZGU2NChlbmNyeXB0ZWQuYnl0ZXMoKSwgNjQpO1xuICB9XG5cbiAgLy8gb3V0cHV0IHByaXZhdGUga2V5XG4gIGxlbmd0aCA9IE1hdGguZmxvb3IocHJpdi5sZW5ndGggLyA2NikgKyAxOyAvLyA2NCArIFxcclxcblxuICBwcGsgKz0gJ1xcclxcblByaXZhdGUtTGluZXM6ICcgKyBsZW5ndGggKyAnXFxyXFxuJztcbiAgcHBrICs9IHByaXY7XG5cbiAgLy8gTUFDXG4gIHZhciBtYWNrZXkgPSBfc2hhMSgncHV0dHktcHJpdmF0ZS1rZXktZmlsZS1tYWMta2V5JywgcGFzc3BocmFzZSk7XG5cbiAgdmFyIG1hY2J1ZmZlciA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIF9hZGRTdHJpbmdUb0J1ZmZlcihtYWNidWZmZXIsIGFsZ29yaXRobSk7XG4gIF9hZGRTdHJpbmdUb0J1ZmZlcihtYWNidWZmZXIsIGVuY3J5cHRpb25BbGdvcml0aG0pO1xuICBfYWRkU3RyaW5nVG9CdWZmZXIobWFjYnVmZmVyLCBjb21tZW50KTtcbiAgbWFjYnVmZmVyLnB1dEludDMyKHB1YmJ1ZmZlci5sZW5ndGgoKSk7XG4gIG1hY2J1ZmZlci5wdXRCdWZmZXIocHViYnVmZmVyKTtcbiAgbWFjYnVmZmVyLnB1dEludDMyKHByaXZidWZmZXIubGVuZ3RoKCkpO1xuICBtYWNidWZmZXIucHV0QnVmZmVyKHByaXZidWZmZXIpO1xuXG4gIHZhciBobWFjID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgaG1hYy5zdGFydCgnc2hhMScsIG1hY2tleSk7XG4gIGhtYWMudXBkYXRlKG1hY2J1ZmZlci5ieXRlcygpKTtcblxuICBwcGsgKz0gJ1xcclxcblByaXZhdGUtTUFDOiAnICsgaG1hYy5kaWdlc3QoKS50b0hleCgpICsgJ1xcclxcbic7XG5cbiAgcmV0dXJuIHBwaztcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIHB1YmxpYyBSU0Ega2V5IGFzIGFuIE9wZW5TU0ggZmlsZS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkuXG4gKiBAcGFyYW0gY29tbWVudCBhIGNvbW1lbnQuXG4gKlxuICogQHJldHVybiB0aGUgcHVibGljIGtleSBpbiBPcGVuU1NIIGZvcm1hdC5cbiAqL1xuc3NoLnB1YmxpY0tleVRvT3BlblNTSCA9IGZ1bmN0aW9uKGtleSwgY29tbWVudCkge1xuICB2YXIgdHlwZSA9ICdzc2gtcnNhJztcbiAgY29tbWVudCA9IGNvbW1lbnQgfHwgJyc7XG5cbiAgdmFyIGJ1ZmZlciA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIF9hZGRTdHJpbmdUb0J1ZmZlcihidWZmZXIsIHR5cGUpO1xuICBfYWRkQmlnSW50ZWdlclRvQnVmZmVyKGJ1ZmZlciwga2V5LmUpO1xuICBfYWRkQmlnSW50ZWdlclRvQnVmZmVyKGJ1ZmZlciwga2V5Lm4pO1xuXG4gIHJldHVybiB0eXBlICsgJyAnICsgZm9yZ2UudXRpbC5lbmNvZGU2NChidWZmZXIuYnl0ZXMoKSkgKyAnICcgKyBjb21tZW50O1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgcHJpdmF0ZSBSU0Ega2V5IGFzIGFuIE9wZW5TU0ggZmlsZS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkuXG4gKiBAcGFyYW0gcGFzc3BocmFzZSBhIHBhc3NwaHJhc2UgdG8gcHJvdGVjdCB0aGUga2V5IChmYWxzeSBmb3Igbm8gZW5jcnlwdGlvbikuXG4gKlxuICogQHJldHVybiB0aGUgcHVibGljIGtleSBpbiBPcGVuU1NIIGZvcm1hdC5cbiAqL1xuc3NoLnByaXZhdGVLZXlUb09wZW5TU0ggPSBmdW5jdGlvbihwcml2YXRlS2V5LCBwYXNzcGhyYXNlKSB7XG4gIGlmKCFwYXNzcGhyYXNlKSB7XG4gICAgcmV0dXJuIGZvcmdlLnBraS5wcml2YXRlS2V5VG9QZW0ocHJpdmF0ZUtleSk7XG4gIH1cbiAgLy8gT3BlblNTSCBwcml2YXRlIGtleSBpcyBqdXN0IGEgbGVnYWN5IGZvcm1hdCwgaXQgc2VlbXNcbiAgcmV0dXJuIGZvcmdlLnBraS5lbmNyeXB0UnNhUHJpdmF0ZUtleShwcml2YXRlS2V5LCBwYXNzcGhyYXNlLFxuICAgIHtsZWdhY3k6IHRydWUsIGFsZ29yaXRobTogJ2FlczEyOCd9KTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgU1NIIGZpbmdlcnByaW50IGZvciB0aGUgZ2l2ZW4gcHVibGljIGtleS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2UuXG4gKiAgICAgICAgICBbbWRdIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIChkZWZhdWx0cyB0byBmb3JnZS5tZC5tZDUpLlxuICogICAgICAgICAgW2VuY29kaW5nXSBhbiBhbHRlcm5hdGl2ZSBvdXRwdXQgZW5jb2RpbmcsIHN1Y2ggYXMgJ2hleCdcbiAqICAgICAgICAgICAgKGRlZmF1bHRzIHRvIG5vbmUsIG91dHB1dHMgYSBieXRlIGJ1ZmZlcikuXG4gKiAgICAgICAgICBbZGVsaW1pdGVyXSB0aGUgZGVsaW1pdGVyIHRvIHVzZSBiZXR3ZWVuIGJ5dGVzIGZvciAnaGV4JyBlbmNvZGVkXG4gKiAgICAgICAgICAgIG91dHB1dCwgZWc6ICc6JyAoZGVmYXVsdHMgdG8gbm9uZSkuXG4gKlxuICogQHJldHVybiB0aGUgZmluZ2VycHJpbnQgYXMgYSBieXRlIGJ1ZmZlciBvciBvdGhlciBlbmNvZGluZyBiYXNlZCBvbiBvcHRpb25zLlxuICovXG5zc2guZ2V0UHVibGljS2V5RmluZ2VycHJpbnQgPSBmdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBtZCA9IG9wdGlvbnMubWQgfHwgZm9yZ2UubWQubWQ1LmNyZWF0ZSgpO1xuXG4gIHZhciB0eXBlID0gJ3NzaC1yc2EnO1xuICB2YXIgYnVmZmVyID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgX2FkZFN0cmluZ1RvQnVmZmVyKGJ1ZmZlciwgdHlwZSk7XG4gIF9hZGRCaWdJbnRlZ2VyVG9CdWZmZXIoYnVmZmVyLCBrZXkuZSk7XG4gIF9hZGRCaWdJbnRlZ2VyVG9CdWZmZXIoYnVmZmVyLCBrZXkubik7XG5cbiAgLy8gaGFzaCBwdWJsaWMga2V5IGJ5dGVzXG4gIG1kLnN0YXJ0KCk7XG4gIG1kLnVwZGF0ZShidWZmZXIuZ2V0Qnl0ZXMoKSk7XG4gIHZhciBkaWdlc3QgPSBtZC5kaWdlc3QoKTtcbiAgaWYob3B0aW9ucy5lbmNvZGluZyA9PT0gJ2hleCcpIHtcbiAgICB2YXIgaGV4ID0gZGlnZXN0LnRvSGV4KCk7XG4gICAgaWYob3B0aW9ucy5kZWxpbWl0ZXIpIHtcbiAgICAgIHJldHVybiBoZXgubWF0Y2goLy57Mn0vZykuam9pbihvcHRpb25zLmRlbGltaXRlcik7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG4gIH0gZWxzZSBpZihvcHRpb25zLmVuY29kaW5nID09PSAnYmluYXJ5Jykge1xuICAgIHJldHVybiBkaWdlc3QuZ2V0Qnl0ZXMoKTtcbiAgfSBlbHNlIGlmKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcgXCInICsgb3B0aW9ucy5lbmNvZGluZyArICdcIi4nKTtcbiAgfVxuICByZXR1cm4gZGlnZXN0O1xufTtcblxuLyoqXG4gKiBBZGRzIGxlbih2YWwpIHRoZW4gdmFsIHRvIGEgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBidWZmZXIgdGhlIGJ1ZmZlciB0byBhZGQgdG8uXG4gKiBAcGFyYW0gdmFsIGEgYmlnIGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIF9hZGRCaWdJbnRlZ2VyVG9CdWZmZXIoYnVmZmVyLCB2YWwpIHtcbiAgdmFyIGhleFZhbCA9IHZhbC50b1N0cmluZygxNik7XG4gIC8vIGVuc3VyZSAycyBjb21wbGVtZW50ICt2ZVxuICBpZihoZXhWYWxbMF0gPj0gJzgnKSB7XG4gICAgaGV4VmFsID0gJzAwJyArIGhleFZhbDtcbiAgfVxuICB2YXIgYnl0ZXMgPSBmb3JnZS51dGlsLmhleFRvQnl0ZXMoaGV4VmFsKTtcbiAgYnVmZmVyLnB1dEludDMyKGJ5dGVzLmxlbmd0aCk7XG4gIGJ1ZmZlci5wdXRCeXRlcyhieXRlcyk7XG59XG5cbi8qKlxuICogQWRkcyBsZW4odmFsKSB0aGVuIHZhbCB0byBhIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gYnVmZmVyIHRoZSBidWZmZXIgdG8gYWRkIHRvLlxuICogQHBhcmFtIHZhbCBhIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gX2FkZFN0cmluZ1RvQnVmZmVyKGJ1ZmZlciwgdmFsKSB7XG4gIGJ1ZmZlci5wdXRJbnQzMih2YWwubGVuZ3RoKTtcbiAgYnVmZmVyLnB1dFN0cmluZyh2YWwpO1xufVxuXG4vKipcbiAqIEhhc2hlcyB0aGUgYXJndW1lbnRzIGludG8gb25lIHZhbHVlIHVzaW5nIFNIQS0xLlxuICpcbiAqIEByZXR1cm4gdGhlIHNoYTEgaGFzaCBvZiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiBfc2hhMSgpIHtcbiAgdmFyIHNoYSA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIHZhciBudW0gPSBhcmd1bWVudHMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgKytpKSB7XG4gICAgc2hhLnVwZGF0ZShhcmd1bWVudHNbaV0pO1xuICB9XG4gIHJldHVybiBzaGEuZGlnZXN0KCk7XG59XG4iXSwibmFtZXMiOlsiZm9yZ2UiLCJyZXF1aXJlIiwic3NoIiwibW9kdWxlIiwiZXhwb3J0cyIsInByaXZhdGVLZXlUb1B1dHR5IiwicHJpdmF0ZUtleSIsInBhc3NwaHJhc2UiLCJjb21tZW50IiwiYWxnb3JpdGhtIiwiZW5jcnlwdGlvbkFsZ29yaXRobSIsInBwayIsInB1YmJ1ZmZlciIsInV0aWwiLCJjcmVhdGVCdWZmZXIiLCJfYWRkU3RyaW5nVG9CdWZmZXIiLCJfYWRkQmlnSW50ZWdlclRvQnVmZmVyIiwiZSIsIm4iLCJwdWIiLCJlbmNvZGU2NCIsImJ5dGVzIiwibGVuZ3RoIiwiTWF0aCIsImZsb29yIiwicHJpdmJ1ZmZlciIsImQiLCJwIiwicSIsInFJbnYiLCJwcml2IiwiZW5jTGVuIiwicGFkZGluZyIsIl9zaGExIiwidHJ1bmNhdGUiLCJwdXRCdWZmZXIiLCJhZXNrZXkiLCJjaXBoZXIiLCJhZXMiLCJjcmVhdGVFbmNyeXB0aW9uQ2lwaGVyIiwic3RhcnQiLCJmaWxsV2l0aEJ5dGUiLCJ1cGRhdGUiLCJjb3B5IiwiZmluaXNoIiwiZW5jcnlwdGVkIiwib3V0cHV0IiwibWFja2V5IiwibWFjYnVmZmVyIiwicHV0SW50MzIiLCJobWFjIiwiY3JlYXRlIiwiZGlnZXN0IiwidG9IZXgiLCJwdWJsaWNLZXlUb09wZW5TU0giLCJrZXkiLCJ0eXBlIiwiYnVmZmVyIiwicHJpdmF0ZUtleVRvT3BlblNTSCIsInBraSIsInByaXZhdGVLZXlUb1BlbSIsImVuY3J5cHRSc2FQcml2YXRlS2V5IiwibGVnYWN5IiwiZ2V0UHVibGljS2V5RmluZ2VycHJpbnQiLCJvcHRpb25zIiwibWQiLCJtZDUiLCJnZXRCeXRlcyIsImVuY29kaW5nIiwiaGV4IiwiZGVsaW1pdGVyIiwibWF0Y2giLCJqb2luIiwiRXJyb3IiLCJ2YWwiLCJoZXhWYWwiLCJ0b1N0cmluZyIsImhleFRvQnl0ZXMiLCJwdXRCeXRlcyIsInB1dFN0cmluZyIsInNoYSIsInNoYTEiLCJudW0iLCJhcmd1bWVudHMiLCJpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/ssh.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/tls.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/tls.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * A Javascript implementation of Transport Layer Security (TLS).\n *\n * @author Dave Longley\n *\n * Copyright (c) 2009-2014 Digital Bazaar, Inc.\n *\n * The TLS Handshake Protocol involves the following steps:\n *\n * - Exchange hello messages to agree on algorithms, exchange random values,\n * and check for session resumption.\n *\n * - Exchange the necessary cryptographic parameters to allow the client and\n * server to agree on a premaster secret.\n *\n * - Exchange certificates and cryptographic information to allow the client\n * and server to authenticate themselves.\n *\n * - Generate a master secret from the premaster secret and exchanged random\n * values.\n *\n * - Provide security parameters to the record layer.\n *\n * - Allow the client and server to verify that their peer has calculated the\n * same security parameters and that the handshake occurred without tampering\n * by an attacker.\n *\n * Up to 4 different messages may be sent during a key exchange. The server\n * certificate, the server key exchange, the client certificate, and the\n * client key exchange.\n *\n * A typical handshake (from the client's perspective).\n *\n * 1. Client sends ClientHello.\n * 2. Client receives ServerHello.\n * 3. Client receives optional Certificate.\n * 4. Client receives optional ServerKeyExchange.\n * 5. Client receives ServerHelloDone.\n * 6. Client sends optional Certificate.\n * 7. Client sends ClientKeyExchange.\n * 8. Client sends optional CertificateVerify.\n * 9. Client sends ChangeCipherSpec.\n * 10. Client sends Finished.\n * 11. Client receives ChangeCipherSpec.\n * 12. Client receives Finished.\n * 13. Client sends/receives application data.\n *\n * To reuse an existing session:\n *\n * 1. Client sends ClientHello with session ID for reuse.\n * 2. Client receives ServerHello with same session ID if reusing.\n * 3. Client receives ChangeCipherSpec message if reusing.\n * 4. Client receives Finished.\n * 5. Client sends ChangeCipherSpec.\n * 6. Client sends Finished.\n *\n * Note: Client ignores HelloRequest if in the middle of a handshake.\n *\n * Record Layer:\n *\n * The record layer fragments information blocks into TLSPlaintext records\n * carrying data in chunks of 2^14 bytes or less. Client message boundaries are\n * not preserved in the record layer (i.e., multiple client messages of the\n * same ContentType MAY be coalesced into a single TLSPlaintext record, or a\n * single message MAY be fragmented across several records).\n *\n * struct {\n *   uint8 major;\n *   uint8 minor;\n * } ProtocolVersion;\n *\n * struct {\n *   ContentType type;\n *   ProtocolVersion version;\n *   uint16 length;\n *   opaque fragment[TLSPlaintext.length];\n * } TLSPlaintext;\n *\n * type:\n *   The higher-level protocol used to process the enclosed fragment.\n *\n * version:\n *   The version of the protocol being employed. TLS Version 1.2 uses version\n *   {3, 3}. TLS Version 1.0 uses version {3, 1}. Note that a client that\n *   supports multiple versions of TLS may not know what version will be\n *   employed before it receives the ServerHello.\n *\n * length:\n *   The length (in bytes) of the following TLSPlaintext.fragment. The length\n *   MUST NOT exceed 2^14 = 16384 bytes.\n *\n * fragment:\n *   The application data. This data is transparent and treated as an\n *   independent block to be dealt with by the higher-level protocol specified\n *   by the type field.\n *\n * Implementations MUST NOT send zero-length fragments of Handshake, Alert, or\n * ChangeCipherSpec content types. Zero-length fragments of Application data\n * MAY be sent as they are potentially useful as a traffic analysis\n * countermeasure.\n *\n * Note: Data of different TLS record layer content types MAY be interleaved.\n * Application data is generally of lower precedence for transmission than\n * other content types. However, records MUST be delivered to the network in\n * the same order as they are protected by the record layer. Recipients MUST\n * receive and process interleaved application layer traffic during handshakes\n * subsequent to the first one on a connection.\n *\n * struct {\n *   ContentType type;       // same as TLSPlaintext.type\n *   ProtocolVersion version;// same as TLSPlaintext.version\n *   uint16 length;\n *   opaque fragment[TLSCompressed.length];\n * } TLSCompressed;\n *\n * length:\n *   The length (in bytes) of the following TLSCompressed.fragment.\n *   The length MUST NOT exceed 2^14 + 1024.\n *\n * fragment:\n *   The compressed form of TLSPlaintext.fragment.\n *\n * Note: A CompressionMethod.null operation is an identity operation; no fields\n * are altered. In this implementation, since no compression is supported,\n * uncompressed records are always the same as compressed records.\n *\n * Encryption Information:\n *\n * The encryption and MAC functions translate a TLSCompressed structure into a\n * TLSCiphertext. The decryption functions reverse the process. The MAC of the\n * record also includes a sequence number so that missing, extra, or repeated\n * messages are detectable.\n *\n * struct {\n *   ContentType type;\n *   ProtocolVersion version;\n *   uint16 length;\n *   select (SecurityParameters.cipher_type) {\n *     case stream: GenericStreamCipher;\n *     case block:  GenericBlockCipher;\n *     case aead:   GenericAEADCipher;\n *   } fragment;\n * } TLSCiphertext;\n *\n * type:\n *   The type field is identical to TLSCompressed.type.\n *\n * version:\n *   The version field is identical to TLSCompressed.version.\n *\n * length:\n *   The length (in bytes) of the following TLSCiphertext.fragment.\n *   The length MUST NOT exceed 2^14 + 2048.\n *\n * fragment:\n *   The encrypted form of TLSCompressed.fragment, with the MAC.\n *\n * Note: Only CBC Block Ciphers are supported by this implementation.\n *\n * The TLSCompressed.fragment structures are converted to/from block\n * TLSCiphertext.fragment structures.\n *\n * struct {\n *   opaque IV[SecurityParameters.record_iv_length];\n *   block-ciphered struct {\n *     opaque content[TLSCompressed.length];\n *     opaque MAC[SecurityParameters.mac_length];\n *     uint8 padding[GenericBlockCipher.padding_length];\n *     uint8 padding_length;\n *   };\n * } GenericBlockCipher;\n *\n * The MAC is generated as described in Section 6.2.3.1.\n *\n * IV:\n *   The Initialization Vector (IV) SHOULD be chosen at random, and MUST be\n *   unpredictable. Note that in versions of TLS prior to 1.1, there was no\n *   IV field, and the last ciphertext block of the previous record (the \"CBC\n *   residue\") was used as the IV. This was changed to prevent the attacks\n *   described in [CBCATT]. For block ciphers, the IV length is of length\n *   SecurityParameters.record_iv_length, which is equal to the\n *   SecurityParameters.block_size.\n *\n * padding:\n *   Padding that is added to force the length of the plaintext to be an\n *   integral multiple of the block cipher's block length. The padding MAY be\n *   any length up to 255 bytes, as long as it results in the\n *   TLSCiphertext.length being an integral multiple of the block length.\n *   Lengths longer than necessary might be desirable to frustrate attacks on\n *   a protocol that are based on analysis of the lengths of exchanged\n *   messages. Each uint8 in the padding data vector MUST be filled with the\n *   padding length value. The receiver MUST check this padding and MUST use\n *   the bad_record_mac alert to indicate padding errors.\n *\n * padding_length:\n *   The padding length MUST be such that the total size of the\n *   GenericBlockCipher structure is a multiple of the cipher's block length.\n *   Legal values range from zero to 255, inclusive. This length specifies the\n *   length of the padding field exclusive of the padding_length field itself.\n *\n * The encrypted data length (TLSCiphertext.length) is one more than the sum of\n * SecurityParameters.block_length, TLSCompressed.length,\n * SecurityParameters.mac_length, and padding_length.\n *\n * Example: If the block length is 8 bytes, the content length\n * (TLSCompressed.length) is 61 bytes, and the MAC length is 20 bytes, then the\n * length before padding is 82 bytes (this does not include the IV. Thus, the\n * padding length modulo 8 must be equal to 6 in order to make the total length\n * an even multiple of 8 bytes (the block length). The padding length can be\n * 6, 14, 22, and so on, through 254. If the padding length were the minimum\n * necessary, 6, the padding would be 6 bytes, each containing the value 6.\n * Thus, the last 8 octets of the GenericBlockCipher before block encryption\n * would be xx 06 06 06 06 06 06 06, where xx is the last octet of the MAC.\n *\n * Note: With block ciphers in CBC mode (Cipher Block Chaining), it is critical\n * that the entire plaintext of the record be known before any ciphertext is\n * transmitted. Otherwise, it is possible for the attacker to mount the attack\n * described in [CBCATT].\n *\n * Implementation note: Canvel et al. [CBCTIME] have demonstrated a timing\n * attack on CBC padding based on the time required to compute the MAC. In\n * order to defend against this attack, implementations MUST ensure that\n * record processing time is essentially the same whether or not the padding\n * is correct. In general, the best way to do this is to compute the MAC even\n * if the padding is incorrect, and only then reject the packet. For instance,\n * if the pad appears to be incorrect, the implementation might assume a\n * zero-length pad and then compute the MAC. This leaves a small timing\n * channel, since MAC performance depends, to some extent, on the size of the\n * data fragment, but it is not believed to be large enough to be exploitable,\n * due to the large block size of existing MACs and the small size of the\n * timing signal.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./asn1 */ \"(rsc)/./node_modules/node-forge/lib/asn1.js\");\n__webpack_require__(/*! ./hmac */ \"(rsc)/./node_modules/node-forge/lib/hmac.js\");\n__webpack_require__(/*! ./md5 */ \"(rsc)/./node_modules/node-forge/lib/md5.js\");\n__webpack_require__(/*! ./pem */ \"(rsc)/./node_modules/node-forge/lib/pem.js\");\n__webpack_require__(/*! ./pki */ \"(rsc)/./node_modules/node-forge/lib/pki.js\");\n__webpack_require__(/*! ./random */ \"(rsc)/./node_modules/node-forge/lib/random.js\");\n__webpack_require__(/*! ./sha1 */ \"(rsc)/./node_modules/node-forge/lib/sha1.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\n/**\n * Generates pseudo random bytes by mixing the result of two hash functions,\n * MD5 and SHA-1.\n *\n * prf_TLS1(secret, label, seed) =\n *   P_MD5(S1, label + seed) XOR P_SHA-1(S2, label + seed);\n *\n * Each P_hash function functions as follows:\n *\n * P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +\n *                        HMAC_hash(secret, A(2) + seed) +\n *                        HMAC_hash(secret, A(3) + seed) + ...\n * A() is defined as:\n *   A(0) = seed\n *   A(i) = HMAC_hash(secret, A(i-1))\n *\n * The '+' operator denotes concatenation.\n *\n * As many iterations A(N) as are needed are performed to generate enough\n * pseudo random byte output. If an iteration creates more data than is\n * necessary, then it is truncated.\n *\n * Therefore:\n * A(1) = HMAC_hash(secret, A(0))\n *      = HMAC_hash(secret, seed)\n * A(2) = HMAC_hash(secret, A(1))\n *      = HMAC_hash(secret, HMAC_hash(secret, seed))\n *\n * Therefore:\n * P_hash(secret, seed) =\n *   HMAC_hash(secret, HMAC_hash(secret, A(0)) + seed) +\n *   HMAC_hash(secret, HMAC_hash(secret, A(1)) + seed) +\n *   ...\n *\n * Therefore:\n * P_hash(secret, seed) =\n *   HMAC_hash(secret, HMAC_hash(secret, seed) + seed) +\n *   HMAC_hash(secret, HMAC_hash(secret, HMAC_hash(secret, seed)) + seed) +\n *   ...\n *\n * @param secret the secret to use.\n * @param label the label to use.\n * @param seed the seed value to use.\n * @param length the number of bytes to generate.\n *\n * @return the pseudo random bytes in a byte buffer.\n */ var prf_TLS1 = function(secret, label, seed, length) {\n    var rval = forge.util.createBuffer();\n    /* For TLS 1.0, the secret is split in half, into two secrets of equal\n    length. If the secret has an odd length then the last byte of the first\n    half will be the same as the first byte of the second. The length of the\n    two secrets is half of the secret rounded up. */ var idx = secret.length >> 1;\n    var slen = idx + (secret.length & 1);\n    var s1 = secret.substr(0, slen);\n    var s2 = secret.substr(idx, slen);\n    var ai = forge.util.createBuffer();\n    var hmac = forge.hmac.create();\n    seed = label + seed;\n    // determine the number of iterations that must be performed to generate\n    // enough output bytes, md5 creates 16 byte hashes, sha1 creates 20\n    var md5itr = Math.ceil(length / 16);\n    var sha1itr = Math.ceil(length / 20);\n    // do md5 iterations\n    hmac.start(\"MD5\", s1);\n    var md5bytes = forge.util.createBuffer();\n    ai.putBytes(seed);\n    for(var i = 0; i < md5itr; ++i){\n        // HMAC_hash(secret, A(i-1))\n        hmac.start(null, null);\n        hmac.update(ai.getBytes());\n        ai.putBuffer(hmac.digest());\n        // HMAC_hash(secret, A(i) + seed)\n        hmac.start(null, null);\n        hmac.update(ai.bytes() + seed);\n        md5bytes.putBuffer(hmac.digest());\n    }\n    // do sha1 iterations\n    hmac.start(\"SHA1\", s2);\n    var sha1bytes = forge.util.createBuffer();\n    ai.clear();\n    ai.putBytes(seed);\n    for(var i = 0; i < sha1itr; ++i){\n        // HMAC_hash(secret, A(i-1))\n        hmac.start(null, null);\n        hmac.update(ai.getBytes());\n        ai.putBuffer(hmac.digest());\n        // HMAC_hash(secret, A(i) + seed)\n        hmac.start(null, null);\n        hmac.update(ai.bytes() + seed);\n        sha1bytes.putBuffer(hmac.digest());\n    }\n    // XOR the md5 bytes with the sha1 bytes\n    rval.putBytes(forge.util.xorBytes(md5bytes.getBytes(), sha1bytes.getBytes(), length));\n    return rval;\n};\n/**\n * Generates pseudo random bytes using a SHA256 algorithm. For TLS 1.2.\n *\n * @param secret the secret to use.\n * @param label the label to use.\n * @param seed the seed value to use.\n * @param length the number of bytes to generate.\n *\n * @return the pseudo random bytes in a byte buffer.\n */ var prf_sha256 = function(secret, label, seed, length) {\n// FIXME: implement me for TLS 1.2\n};\n/**\n * Gets a MAC for a record using the SHA-1 hash algorithm.\n *\n * @param key the mac key.\n * @param state the sequence number (array of two 32-bit integers).\n * @param record the record.\n *\n * @return the sha-1 hash (20 bytes) for the given record.\n */ var hmac_sha1 = function(key, seqNum, record) {\n    /* MAC is computed like so:\n  HMAC_hash(\n    key, seqNum +\n      TLSCompressed.type +\n      TLSCompressed.version +\n      TLSCompressed.length +\n      TLSCompressed.fragment)\n  */ var hmac = forge.hmac.create();\n    hmac.start(\"SHA1\", key);\n    var b = forge.util.createBuffer();\n    b.putInt32(seqNum[0]);\n    b.putInt32(seqNum[1]);\n    b.putByte(record.type);\n    b.putByte(record.version.major);\n    b.putByte(record.version.minor);\n    b.putInt16(record.length);\n    b.putBytes(record.fragment.bytes());\n    hmac.update(b.getBytes());\n    return hmac.digest().getBytes();\n};\n/**\n * Compresses the TLSPlaintext record into a TLSCompressed record using the\n * deflate algorithm.\n *\n * @param c the TLS connection.\n * @param record the TLSPlaintext record to compress.\n * @param s the ConnectionState to use.\n *\n * @return true on success, false on failure.\n */ var deflate = function(c, record, s) {\n    var rval = false;\n    try {\n        var bytes = c.deflate(record.fragment.getBytes());\n        record.fragment = forge.util.createBuffer(bytes);\n        record.length = bytes.length;\n        rval = true;\n    } catch (ex) {\n    // deflate error, fail out\n    }\n    return rval;\n};\n/**\n * Decompresses the TLSCompressed record into a TLSPlaintext record using the\n * deflate algorithm.\n *\n * @param c the TLS connection.\n * @param record the TLSCompressed record to decompress.\n * @param s the ConnectionState to use.\n *\n * @return true on success, false on failure.\n */ var inflate = function(c, record, s) {\n    var rval = false;\n    try {\n        var bytes = c.inflate(record.fragment.getBytes());\n        record.fragment = forge.util.createBuffer(bytes);\n        record.length = bytes.length;\n        rval = true;\n    } catch (ex) {\n    // inflate error, fail out\n    }\n    return rval;\n};\n/**\n * Reads a TLS variable-length vector from a byte buffer.\n *\n * Variable-length vectors are defined by specifying a subrange of legal\n * lengths, inclusively, using the notation <floor..ceiling>. When these are\n * encoded, the actual length precedes the vector's contents in the byte\n * stream. The length will be in the form of a number consuming as many bytes\n * as required to hold the vector's specified maximum (ceiling) length. A\n * variable-length vector with an actual length field of zero is referred to\n * as an empty vector.\n *\n * @param b the byte buffer.\n * @param lenBytes the number of bytes required to store the length.\n *\n * @return the resulting byte buffer.\n */ var readVector = function(b, lenBytes) {\n    var len = 0;\n    switch(lenBytes){\n        case 1:\n            len = b.getByte();\n            break;\n        case 2:\n            len = b.getInt16();\n            break;\n        case 3:\n            len = b.getInt24();\n            break;\n        case 4:\n            len = b.getInt32();\n            break;\n    }\n    // read vector bytes into a new buffer\n    return forge.util.createBuffer(b.getBytes(len));\n};\n/**\n * Writes a TLS variable-length vector to a byte buffer.\n *\n * @param b the byte buffer.\n * @param lenBytes the number of bytes required to store the length.\n * @param v the byte buffer vector.\n */ var writeVector = function(b, lenBytes, v) {\n    // encode length at the start of the vector, where the number of bytes for\n    // the length is the maximum number of bytes it would take to encode the\n    // vector's ceiling\n    b.putInt(v.length(), lenBytes << 3);\n    b.putBuffer(v);\n};\n/**\n * The tls implementation.\n */ var tls = {};\n/**\n * Version: TLS 1.2 = 3.3, TLS 1.1 = 3.2, TLS 1.0 = 3.1. Both TLS 1.1 and\n * TLS 1.2 were still too new (ie: openSSL didn't implement them) at the time\n * of this implementation so TLS 1.0 was implemented instead.\n */ tls.Versions = {\n    TLS_1_0: {\n        major: 3,\n        minor: 1\n    },\n    TLS_1_1: {\n        major: 3,\n        minor: 2\n    },\n    TLS_1_2: {\n        major: 3,\n        minor: 3\n    }\n};\ntls.SupportedVersions = [\n    tls.Versions.TLS_1_1,\n    tls.Versions.TLS_1_0\n];\ntls.Version = tls.SupportedVersions[0];\n/**\n * Maximum fragment size. True maximum is 16384, but we fragment before that\n * to allow for unusual small increases during compression.\n */ tls.MaxFragment = 16384 - 1024;\n/**\n * Whether this entity is considered the \"client\" or \"server\".\n * enum { server, client } ConnectionEnd;\n */ tls.ConnectionEnd = {\n    server: 0,\n    client: 1\n};\n/**\n * Pseudo-random function algorithm used to generate keys from the master\n * secret.\n * enum { tls_prf_sha256 } PRFAlgorithm;\n */ tls.PRFAlgorithm = {\n    tls_prf_sha256: 0\n};\n/**\n * Bulk encryption algorithms.\n * enum { null, rc4, des3, aes } BulkCipherAlgorithm;\n */ tls.BulkCipherAlgorithm = {\n    none: null,\n    rc4: 0,\n    des3: 1,\n    aes: 2\n};\n/**\n * Cipher types.\n * enum { stream, block, aead } CipherType;\n */ tls.CipherType = {\n    stream: 0,\n    block: 1,\n    aead: 2\n};\n/**\n * MAC (Message Authentication Code) algorithms.\n * enum { null, hmac_md5, hmac_sha1, hmac_sha256,\n *   hmac_sha384, hmac_sha512} MACAlgorithm;\n */ tls.MACAlgorithm = {\n    none: null,\n    hmac_md5: 0,\n    hmac_sha1: 1,\n    hmac_sha256: 2,\n    hmac_sha384: 3,\n    hmac_sha512: 4\n};\n/**\n * Compression algorithms.\n * enum { null(0), deflate(1), (255) } CompressionMethod;\n */ tls.CompressionMethod = {\n    none: 0,\n    deflate: 1\n};\n/**\n * TLS record content types.\n * enum {\n *   change_cipher_spec(20), alert(21), handshake(22),\n *   application_data(23), (255)\n * } ContentType;\n */ tls.ContentType = {\n    change_cipher_spec: 20,\n    alert: 21,\n    handshake: 22,\n    application_data: 23,\n    heartbeat: 24\n};\n/**\n * TLS handshake types.\n * enum {\n *   hello_request(0), client_hello(1), server_hello(2),\n *   certificate(11), server_key_exchange (12),\n *   certificate_request(13), server_hello_done(14),\n *   certificate_verify(15), client_key_exchange(16),\n *   finished(20), (255)\n * } HandshakeType;\n */ tls.HandshakeType = {\n    hello_request: 0,\n    client_hello: 1,\n    server_hello: 2,\n    certificate: 11,\n    server_key_exchange: 12,\n    certificate_request: 13,\n    server_hello_done: 14,\n    certificate_verify: 15,\n    client_key_exchange: 16,\n    finished: 20\n};\n/**\n * TLS Alert Protocol.\n *\n * enum { warning(1), fatal(2), (255) } AlertLevel;\n *\n * enum {\n *   close_notify(0),\n *   unexpected_message(10),\n *   bad_record_mac(20),\n *   decryption_failed(21),\n *   record_overflow(22),\n *   decompression_failure(30),\n *   handshake_failure(40),\n *   bad_certificate(42),\n *   unsupported_certificate(43),\n *   certificate_revoked(44),\n *   certificate_expired(45),\n *   certificate_unknown(46),\n *   illegal_parameter(47),\n *   unknown_ca(48),\n *   access_denied(49),\n *   decode_error(50),\n *   decrypt_error(51),\n *   export_restriction(60),\n *   protocol_version(70),\n *   insufficient_security(71),\n *   internal_error(80),\n *   user_canceled(90),\n *   no_renegotiation(100),\n *   (255)\n * } AlertDescription;\n *\n * struct {\n *   AlertLevel level;\n *   AlertDescription description;\n * } Alert;\n */ tls.Alert = {};\ntls.Alert.Level = {\n    warning: 1,\n    fatal: 2\n};\ntls.Alert.Description = {\n    close_notify: 0,\n    unexpected_message: 10,\n    bad_record_mac: 20,\n    decryption_failed: 21,\n    record_overflow: 22,\n    decompression_failure: 30,\n    handshake_failure: 40,\n    bad_certificate: 42,\n    unsupported_certificate: 43,\n    certificate_revoked: 44,\n    certificate_expired: 45,\n    certificate_unknown: 46,\n    illegal_parameter: 47,\n    unknown_ca: 48,\n    access_denied: 49,\n    decode_error: 50,\n    decrypt_error: 51,\n    export_restriction: 60,\n    protocol_version: 70,\n    insufficient_security: 71,\n    internal_error: 80,\n    user_canceled: 90,\n    no_renegotiation: 100\n};\n/**\n * TLS Heartbeat Message types.\n * enum {\n *   heartbeat_request(1),\n *   heartbeat_response(2),\n *   (255)\n * } HeartbeatMessageType;\n */ tls.HeartbeatMessageType = {\n    heartbeat_request: 1,\n    heartbeat_response: 2\n};\n/**\n * Supported cipher suites.\n */ tls.CipherSuites = {};\n/**\n * Gets a supported cipher suite from its 2 byte ID.\n *\n * @param twoBytes two bytes in a string.\n *\n * @return the matching supported cipher suite or null.\n */ tls.getCipherSuite = function(twoBytes) {\n    var rval = null;\n    for(var key in tls.CipherSuites){\n        var cs = tls.CipherSuites[key];\n        if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) {\n            rval = cs;\n            break;\n        }\n    }\n    return rval;\n};\n/**\n * Called when an unexpected record is encountered.\n *\n * @param c the connection.\n * @param record the record.\n */ tls.handleUnexpected = function(c, record) {\n    // if connection is client and closed, ignore unexpected messages\n    var ignore = !c.open && c.entity === tls.ConnectionEnd.client;\n    if (!ignore) {\n        c.error(c, {\n            message: \"Unexpected message. Received TLS record out of order.\",\n            send: true,\n            alert: {\n                level: tls.Alert.Level.fatal,\n                description: tls.Alert.Description.unexpected_message\n            }\n        });\n    }\n};\n/**\n * Called when a client receives a HelloRequest record.\n *\n * @param c the connection.\n * @param record the record.\n * @param length the length of the handshake message.\n */ tls.handleHelloRequest = function(c, record, length) {\n    // ignore renegotiation requests from the server during a handshake, but\n    // if handshaking, send a warning alert that renegotation is denied\n    if (!c.handshaking && c.handshakes > 0) {\n        // send alert warning\n        tls.queue(c, tls.createAlert(c, {\n            level: tls.Alert.Level.warning,\n            description: tls.Alert.Description.no_renegotiation\n        }));\n        tls.flush(c);\n    }\n    // continue\n    c.process();\n};\n/**\n * Parses a hello message from a ClientHello or ServerHello record.\n *\n * @param record the record to parse.\n *\n * @return the parsed message.\n */ tls.parseHelloMessage = function(c, record, length) {\n    var msg = null;\n    var client = c.entity === tls.ConnectionEnd.client;\n    // minimum of 38 bytes in message\n    if (length < 38) {\n        c.error(c, {\n            message: client ? \"Invalid ServerHello message. Message too short.\" : \"Invalid ClientHello message. Message too short.\",\n            send: true,\n            alert: {\n                level: tls.Alert.Level.fatal,\n                description: tls.Alert.Description.illegal_parameter\n            }\n        });\n    } else {\n        // use 'remaining' to calculate # of remaining bytes in the message\n        var b = record.fragment;\n        var remaining = b.length();\n        msg = {\n            version: {\n                major: b.getByte(),\n                minor: b.getByte()\n            },\n            random: forge.util.createBuffer(b.getBytes(32)),\n            session_id: readVector(b, 1),\n            extensions: []\n        };\n        if (client) {\n            msg.cipher_suite = b.getBytes(2);\n            msg.compression_method = b.getByte();\n        } else {\n            msg.cipher_suites = readVector(b, 2);\n            msg.compression_methods = readVector(b, 1);\n        }\n        // read extensions if there are any bytes left in the message\n        remaining = length - (remaining - b.length());\n        if (remaining > 0) {\n            // parse extensions\n            var exts = readVector(b, 2);\n            while(exts.length() > 0){\n                msg.extensions.push({\n                    type: [\n                        exts.getByte(),\n                        exts.getByte()\n                    ],\n                    data: readVector(exts, 2)\n                });\n            }\n            // TODO: make extension support modular\n            if (!client) {\n                for(var i = 0; i < msg.extensions.length; ++i){\n                    var ext = msg.extensions[i];\n                    // support SNI extension\n                    if (ext.type[0] === 0x00 && ext.type[1] === 0x00) {\n                        // get server name list\n                        var snl = readVector(ext.data, 2);\n                        while(snl.length() > 0){\n                            // read server name type\n                            var snType = snl.getByte();\n                            // only HostName type (0x00) is known, break out if\n                            // another type is detected\n                            if (snType !== 0x00) {\n                                break;\n                            }\n                            // add host name to server name list\n                            c.session.extensions.server_name.serverNameList.push(readVector(snl, 2).getBytes());\n                        }\n                    }\n                }\n            }\n        }\n        // version already set, do not allow version change\n        if (c.session.version) {\n            if (msg.version.major !== c.session.version.major || msg.version.minor !== c.session.version.minor) {\n                return c.error(c, {\n                    message: \"TLS version change is disallowed during renegotiation.\",\n                    send: true,\n                    alert: {\n                        level: tls.Alert.Level.fatal,\n                        description: tls.Alert.Description.protocol_version\n                    }\n                });\n            }\n        }\n        // get the chosen (ServerHello) cipher suite\n        if (client) {\n            // FIXME: should be checking configured acceptable cipher suites\n            c.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);\n        } else {\n            // get a supported preferred (ClientHello) cipher suite\n            // choose the first supported cipher suite\n            var tmp = forge.util.createBuffer(msg.cipher_suites.bytes());\n            while(tmp.length() > 0){\n                // FIXME: should be checking configured acceptable suites\n                // cipher suites take up 2 bytes\n                c.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2));\n                if (c.session.cipherSuite !== null) {\n                    break;\n                }\n            }\n        }\n        // cipher suite not supported\n        if (c.session.cipherSuite === null) {\n            return c.error(c, {\n                message: \"No cipher suites in common.\",\n                send: true,\n                alert: {\n                    level: tls.Alert.Level.fatal,\n                    description: tls.Alert.Description.handshake_failure\n                },\n                cipherSuite: forge.util.bytesToHex(msg.cipher_suite)\n            });\n        }\n        // TODO: handle compression methods\n        if (client) {\n            c.session.compressionMethod = msg.compression_method;\n        } else {\n            // no compression\n            c.session.compressionMethod = tls.CompressionMethod.none;\n        }\n    }\n    return msg;\n};\n/**\n * Creates security parameters for the given connection based on the given\n * hello message.\n *\n * @param c the TLS connection.\n * @param msg the hello message.\n */ tls.createSecurityParameters = function(c, msg) {\n    /* Note: security params are from TLS 1.2, some values like prf_algorithm\n  are ignored for TLS 1.0/1.1 and the builtin as specified in the spec is\n  used. */ // TODO: handle other options from server when more supported\n    // get client and server randoms\n    var client = c.entity === tls.ConnectionEnd.client;\n    var msgRandom = msg.random.bytes();\n    var cRandom = client ? c.session.sp.client_random : msgRandom;\n    var sRandom = client ? msgRandom : tls.createRandom().getBytes();\n    // create new security parameters\n    c.session.sp = {\n        entity: c.entity,\n        prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,\n        bulk_cipher_algorithm: null,\n        cipher_type: null,\n        enc_key_length: null,\n        block_length: null,\n        fixed_iv_length: null,\n        record_iv_length: null,\n        mac_algorithm: null,\n        mac_length: null,\n        mac_key_length: null,\n        compression_algorithm: c.session.compressionMethod,\n        pre_master_secret: null,\n        master_secret: null,\n        client_random: cRandom,\n        server_random: sRandom\n    };\n};\n/**\n * Called when a client receives a ServerHello record.\n *\n * When a ServerHello message will be sent:\n *   The server will send this message in response to a client hello message\n *   when it was able to find an acceptable set of algorithms. If it cannot\n *   find such a match, it will respond with a handshake failure alert.\n *\n * uint24 length;\n * struct {\n *   ProtocolVersion server_version;\n *   Random random;\n *   SessionID session_id;\n *   CipherSuite cipher_suite;\n *   CompressionMethod compression_method;\n *   select(extensions_present) {\n *     case false:\n *       struct {};\n *     case true:\n *       Extension extensions<0..2^16-1>;\n *   };\n * } ServerHello;\n *\n * @param c the connection.\n * @param record the record.\n * @param length the length of the handshake message.\n */ tls.handleServerHello = function(c, record, length) {\n    var msg = tls.parseHelloMessage(c, record, length);\n    if (c.fail) {\n        return;\n    }\n    // ensure server version is compatible\n    if (msg.version.minor <= c.version.minor) {\n        c.version.minor = msg.version.minor;\n    } else {\n        return c.error(c, {\n            message: \"Incompatible TLS version.\",\n            send: true,\n            alert: {\n                level: tls.Alert.Level.fatal,\n                description: tls.Alert.Description.protocol_version\n            }\n        });\n    }\n    // indicate session version has been set\n    c.session.version = c.version;\n    // get the session ID from the message\n    var sessionId = msg.session_id.bytes();\n    // if the session ID is not blank and matches the cached one, resume\n    // the session\n    if (sessionId.length > 0 && sessionId === c.session.id) {\n        // resuming session, expect a ChangeCipherSpec next\n        c.expect = SCC;\n        c.session.resuming = true;\n        // get new server random\n        c.session.sp.server_random = msg.random.bytes();\n    } else {\n        // not resuming, expect a server Certificate message next\n        c.expect = SCE;\n        c.session.resuming = false;\n        // create new security parameters\n        tls.createSecurityParameters(c, msg);\n    }\n    // set new session ID\n    c.session.id = sessionId;\n    // continue\n    c.process();\n};\n/**\n * Called when a server receives a ClientHello record.\n *\n * When a ClientHello message will be sent:\n *   When a client first connects to a server it is required to send the\n *   client hello as its first message. The client can also send a client\n *   hello in response to a hello request or on its own initiative in order\n *   to renegotiate the security parameters in an existing connection.\n *\n * @param c the connection.\n * @param record the record.\n * @param length the length of the handshake message.\n */ tls.handleClientHello = function(c, record, length) {\n    var msg = tls.parseHelloMessage(c, record, length);\n    if (c.fail) {\n        return;\n    }\n    // get the session ID from the message\n    var sessionId = msg.session_id.bytes();\n    // see if the given session ID is in the cache\n    var session = null;\n    if (c.sessionCache) {\n        session = c.sessionCache.getSession(sessionId);\n        if (session === null) {\n            // session ID not found\n            sessionId = \"\";\n        } else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {\n            // if session version is incompatible with client version, do not resume\n            session = null;\n            sessionId = \"\";\n        }\n    }\n    // no session found to resume, generate a new session ID\n    if (sessionId.length === 0) {\n        sessionId = forge.random.getBytes(32);\n    }\n    // update session\n    c.session.id = sessionId;\n    c.session.clientHelloVersion = msg.version;\n    c.session.sp = {};\n    if (session) {\n        // use version and security parameters from resumed session\n        c.version = c.session.version = session.version;\n        c.session.sp = session.sp;\n    } else {\n        // use highest compatible minor version\n        var version;\n        for(var i = 1; i < tls.SupportedVersions.length; ++i){\n            version = tls.SupportedVersions[i];\n            if (version.minor <= msg.version.minor) {\n                break;\n            }\n        }\n        c.version = {\n            major: version.major,\n            minor: version.minor\n        };\n        c.session.version = c.version;\n    }\n    // if a session is set, resume it\n    if (session !== null) {\n        // resuming session, expect a ChangeCipherSpec next\n        c.expect = CCC;\n        c.session.resuming = true;\n        // get new client random\n        c.session.sp.client_random = msg.random.bytes();\n    } else {\n        // not resuming, expect a Certificate or ClientKeyExchange\n        c.expect = c.verifyClient !== false ? CCE : CKE;\n        c.session.resuming = false;\n        // create new security parameters\n        tls.createSecurityParameters(c, msg);\n    }\n    // connection now open\n    c.open = true;\n    // queue server hello\n    tls.queue(c, tls.createRecord(c, {\n        type: tls.ContentType.handshake,\n        data: tls.createServerHello(c)\n    }));\n    if (c.session.resuming) {\n        // queue change cipher spec message\n        tls.queue(c, tls.createRecord(c, {\n            type: tls.ContentType.change_cipher_spec,\n            data: tls.createChangeCipherSpec()\n        }));\n        // create pending state\n        c.state.pending = tls.createConnectionState(c);\n        // change current write state to pending write state\n        c.state.current.write = c.state.pending.write;\n        // queue finished\n        tls.queue(c, tls.createRecord(c, {\n            type: tls.ContentType.handshake,\n            data: tls.createFinished(c)\n        }));\n    } else {\n        // queue server certificate\n        tls.queue(c, tls.createRecord(c, {\n            type: tls.ContentType.handshake,\n            data: tls.createCertificate(c)\n        }));\n        if (!c.fail) {\n            // queue server key exchange\n            tls.queue(c, tls.createRecord(c, {\n                type: tls.ContentType.handshake,\n                data: tls.createServerKeyExchange(c)\n            }));\n            // request client certificate if set\n            if (c.verifyClient !== false) {\n                // queue certificate request\n                tls.queue(c, tls.createRecord(c, {\n                    type: tls.ContentType.handshake,\n                    data: tls.createCertificateRequest(c)\n                }));\n            }\n            // queue server hello done\n            tls.queue(c, tls.createRecord(c, {\n                type: tls.ContentType.handshake,\n                data: tls.createServerHelloDone(c)\n            }));\n        }\n    }\n    // send records\n    tls.flush(c);\n    // continue\n    c.process();\n};\n/**\n * Called when a client receives a Certificate record.\n *\n * When this message will be sent:\n *   The server must send a certificate whenever the agreed-upon key exchange\n *   method is not an anonymous one. This message will always immediately\n *   follow the server hello message.\n *\n * Meaning of this message:\n *   The certificate type must be appropriate for the selected cipher suite's\n *   key exchange algorithm, and is generally an X.509v3 certificate. It must\n *   contain a key which matches the key exchange method, as follows. Unless\n *   otherwise specified, the signing algorithm for the certificate must be\n *   the same as the algorithm for the certificate key. Unless otherwise\n *   specified, the public key may be of any length.\n *\n * opaque ASN.1Cert<1..2^24-1>;\n * struct {\n *   ASN.1Cert certificate_list<1..2^24-1>;\n * } Certificate;\n *\n * @param c the connection.\n * @param record the record.\n * @param length the length of the handshake message.\n */ tls.handleCertificate = function(c, record, length) {\n    // minimum of 3 bytes in message\n    if (length < 3) {\n        return c.error(c, {\n            message: \"Invalid Certificate message. Message too short.\",\n            send: true,\n            alert: {\n                level: tls.Alert.Level.fatal,\n                description: tls.Alert.Description.illegal_parameter\n            }\n        });\n    }\n    var b = record.fragment;\n    var msg = {\n        certificate_list: readVector(b, 3)\n    };\n    /* The sender's certificate will be first in the list (chain), each\n    subsequent one that follows will certify the previous one, but root\n    certificates (self-signed) that specify the certificate authority may\n    be omitted under the assumption that clients must already possess it. */ var cert, asn1;\n    var certs = [];\n    try {\n        while(msg.certificate_list.length() > 0){\n            // each entry in msg.certificate_list is a vector with 3 len bytes\n            cert = readVector(msg.certificate_list, 3);\n            asn1 = forge.asn1.fromDer(cert);\n            cert = forge.pki.certificateFromAsn1(asn1, true);\n            certs.push(cert);\n        }\n    } catch (ex) {\n        return c.error(c, {\n            message: \"Could not parse certificate list.\",\n            cause: ex,\n            send: true,\n            alert: {\n                level: tls.Alert.Level.fatal,\n                description: tls.Alert.Description.bad_certificate\n            }\n        });\n    }\n    // ensure at least 1 certificate was provided if in client-mode\n    // or if verifyClient was set to true to require a certificate\n    // (as opposed to 'optional')\n    var client = c.entity === tls.ConnectionEnd.client;\n    if ((client || c.verifyClient === true) && certs.length === 0) {\n        // error, no certificate\n        c.error(c, {\n            message: client ? \"No server certificate provided.\" : \"No client certificate provided.\",\n            send: true,\n            alert: {\n                level: tls.Alert.Level.fatal,\n                description: tls.Alert.Description.illegal_parameter\n            }\n        });\n    } else if (certs.length === 0) {\n        // no certs to verify\n        // expect a ServerKeyExchange or ClientKeyExchange message next\n        c.expect = client ? SKE : CKE;\n    } else {\n        // save certificate in session\n        if (client) {\n            c.session.serverCertificate = certs[0];\n        } else {\n            c.session.clientCertificate = certs[0];\n        }\n        if (tls.verifyCertificateChain(c, certs)) {\n            // expect a ServerKeyExchange or ClientKeyExchange message next\n            c.expect = client ? SKE : CKE;\n        }\n    }\n    // continue\n    c.process();\n};\n/**\n * Called when a client receives a ServerKeyExchange record.\n *\n * When this message will be sent:\n *   This message will be sent immediately after the server certificate\n *   message (or the server hello message, if this is an anonymous\n *   negotiation).\n *\n *   The server key exchange message is sent by the server only when the\n *   server certificate message (if sent) does not contain enough data to\n *   allow the client to exchange a premaster secret.\n *\n * Meaning of this message:\n *   This message conveys cryptographic information to allow the client to\n *   communicate the premaster secret: either an RSA public key to encrypt\n *   the premaster secret with, or a Diffie-Hellman public key with which the\n *   client can complete a key exchange (with the result being the premaster\n *   secret.)\n *\n * enum {\n *   dhe_dss, dhe_rsa, dh_anon, rsa, dh_dss, dh_rsa\n * } KeyExchangeAlgorithm;\n *\n * struct {\n *   opaque dh_p<1..2^16-1>;\n *   opaque dh_g<1..2^16-1>;\n *   opaque dh_Ys<1..2^16-1>;\n * } ServerDHParams;\n *\n * struct {\n *   select(KeyExchangeAlgorithm) {\n *     case dh_anon:\n *       ServerDHParams params;\n *     case dhe_dss:\n *     case dhe_rsa:\n *       ServerDHParams params;\n *       digitally-signed struct {\n *         opaque client_random[32];\n *         opaque server_random[32];\n *         ServerDHParams params;\n *       } signed_params;\n *     case rsa:\n *     case dh_dss:\n *     case dh_rsa:\n *       struct {};\n *   };\n * } ServerKeyExchange;\n *\n * @param c the connection.\n * @param record the record.\n * @param length the length of the handshake message.\n */ tls.handleServerKeyExchange = function(c, record, length) {\n    // this implementation only supports RSA, no Diffie-Hellman support\n    // so any length > 0 is invalid\n    if (length > 0) {\n        return c.error(c, {\n            message: \"Invalid key parameters. Only RSA is supported.\",\n            send: true,\n            alert: {\n                level: tls.Alert.Level.fatal,\n                description: tls.Alert.Description.unsupported_certificate\n            }\n        });\n    }\n    // expect an optional CertificateRequest message next\n    c.expect = SCR;\n    // continue\n    c.process();\n};\n/**\n * Called when a client receives a ClientKeyExchange record.\n *\n * @param c the connection.\n * @param record the record.\n * @param length the length of the handshake message.\n */ tls.handleClientKeyExchange = function(c, record, length) {\n    // this implementation only supports RSA, no Diffie-Hellman support\n    // so any length < 48 is invalid\n    if (length < 48) {\n        return c.error(c, {\n            message: \"Invalid key parameters. Only RSA is supported.\",\n            send: true,\n            alert: {\n                level: tls.Alert.Level.fatal,\n                description: tls.Alert.Description.unsupported_certificate\n            }\n        });\n    }\n    var b = record.fragment;\n    var msg = {\n        enc_pre_master_secret: readVector(b, 2).getBytes()\n    };\n    // do rsa decryption\n    var privateKey = null;\n    if (c.getPrivateKey) {\n        try {\n            privateKey = c.getPrivateKey(c, c.session.serverCertificate);\n            privateKey = forge.pki.privateKeyFromPem(privateKey);\n        } catch (ex) {\n            c.error(c, {\n                message: \"Could not get private key.\",\n                cause: ex,\n                send: true,\n                alert: {\n                    level: tls.Alert.Level.fatal,\n                    description: tls.Alert.Description.internal_error\n                }\n            });\n        }\n    }\n    if (privateKey === null) {\n        return c.error(c, {\n            message: \"No private key set.\",\n            send: true,\n            alert: {\n                level: tls.Alert.Level.fatal,\n                description: tls.Alert.Description.internal_error\n            }\n        });\n    }\n    try {\n        // decrypt 48-byte pre-master secret\n        var sp = c.session.sp;\n        sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);\n        // ensure client hello version matches first 2 bytes\n        var version = c.session.clientHelloVersion;\n        if (version.major !== sp.pre_master_secret.charCodeAt(0) || version.minor !== sp.pre_master_secret.charCodeAt(1)) {\n            // error, do not send alert (see BLEI attack below)\n            throw new Error(\"TLS version rollback attack detected.\");\n        }\n    } catch (ex) {\n        /* Note: Daniel Bleichenbacher [BLEI] can be used to attack a\n      TLS server which is using PKCS#1 encoded RSA, so instead of\n      failing here, we generate 48 random bytes and use that as\n      the pre-master secret. */ sp.pre_master_secret = forge.random.getBytes(48);\n    }\n    // expect a CertificateVerify message if a Certificate was received that\n    // does not have fixed Diffie-Hellman params, otherwise expect\n    // ChangeCipherSpec\n    c.expect = CCC;\n    if (c.session.clientCertificate !== null) {\n        // only RSA support, so expect CertificateVerify\n        // TODO: support Diffie-Hellman\n        c.expect = CCV;\n    }\n    // continue\n    c.process();\n};\n/**\n * Called when a client receives a CertificateRequest record.\n *\n * When this message will be sent:\n *   A non-anonymous server can optionally request a certificate from the\n *   client, if appropriate for the selected cipher suite. This message, if\n *   sent, will immediately follow the Server Key Exchange message (if it is\n *   sent; otherwise, the Server Certificate message).\n *\n * enum {\n *   rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),\n *   rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),\n *   fortezza_dms_RESERVED(20), (255)\n * } ClientCertificateType;\n *\n * opaque DistinguishedName<1..2^16-1>;\n *\n * struct {\n *   ClientCertificateType certificate_types<1..2^8-1>;\n *   SignatureAndHashAlgorithm supported_signature_algorithms<2^16-1>;\n *   DistinguishedName certificate_authorities<0..2^16-1>;\n * } CertificateRequest;\n *\n * @param c the connection.\n * @param record the record.\n * @param length the length of the handshake message.\n */ tls.handleCertificateRequest = function(c, record, length) {\n    // minimum of 3 bytes in message\n    if (length < 3) {\n        return c.error(c, {\n            message: \"Invalid CertificateRequest. Message too short.\",\n            send: true,\n            alert: {\n                level: tls.Alert.Level.fatal,\n                description: tls.Alert.Description.illegal_parameter\n            }\n        });\n    }\n    // TODO: TLS 1.2+ has different format including\n    // SignatureAndHashAlgorithm after cert types\n    var b = record.fragment;\n    var msg = {\n        certificate_types: readVector(b, 1),\n        certificate_authorities: readVector(b, 2)\n    };\n    // save certificate request in session\n    c.session.certificateRequest = msg;\n    // expect a ServerHelloDone message next\n    c.expect = SHD;\n    // continue\n    c.process();\n};\n/**\n * Called when a server receives a CertificateVerify record.\n *\n * @param c the connection.\n * @param record the record.\n * @param length the length of the handshake message.\n */ tls.handleCertificateVerify = function(c, record, length) {\n    if (length < 2) {\n        return c.error(c, {\n            message: \"Invalid CertificateVerify. Message too short.\",\n            send: true,\n            alert: {\n                level: tls.Alert.Level.fatal,\n                description: tls.Alert.Description.illegal_parameter\n            }\n        });\n    }\n    // rewind to get full bytes for message so it can be manually\n    // digested below (special case for CertificateVerify messages because\n    // they must be digested *after* handling as opposed to all others)\n    var b = record.fragment;\n    b.read -= 4;\n    var msgBytes = b.bytes();\n    b.read += 4;\n    var msg = {\n        signature: readVector(b, 2).getBytes()\n    };\n    // TODO: add support for DSA\n    // generate data to verify\n    var verify = forge.util.createBuffer();\n    verify.putBuffer(c.session.md5.digest());\n    verify.putBuffer(c.session.sha1.digest());\n    verify = verify.getBytes();\n    try {\n        var cert = c.session.clientCertificate;\n        /*b = forge.pki.rsa.decrypt(\n      msg.signature, cert.publicKey, true, verify.length);\n    if(b !== verify) {*/ if (!cert.publicKey.verify(verify, msg.signature, \"NONE\")) {\n            throw new Error(\"CertificateVerify signature does not match.\");\n        }\n        // digest message now that it has been handled\n        c.session.md5.update(msgBytes);\n        c.session.sha1.update(msgBytes);\n    } catch (ex) {\n        return c.error(c, {\n            message: \"Bad signature in CertificateVerify.\",\n            send: true,\n            alert: {\n                level: tls.Alert.Level.fatal,\n                description: tls.Alert.Description.handshake_failure\n            }\n        });\n    }\n    // expect ChangeCipherSpec\n    c.expect = CCC;\n    // continue\n    c.process();\n};\n/**\n * Called when a client receives a ServerHelloDone record.\n *\n * When this message will be sent:\n *   The server hello done message is sent by the server to indicate the end\n *   of the server hello and associated messages. After sending this message\n *   the server will wait for a client response.\n *\n * Meaning of this message:\n *   This message means that the server is done sending messages to support\n *   the key exchange, and the client can proceed with its phase of the key\n *   exchange.\n *\n *   Upon receipt of the server hello done message the client should verify\n *   that the server provided a valid certificate if required and check that\n *   the server hello parameters are acceptable.\n *\n * struct {} ServerHelloDone;\n *\n * @param c the connection.\n * @param record the record.\n * @param length the length of the handshake message.\n */ tls.handleServerHelloDone = function(c, record, length) {\n    // len must be 0 bytes\n    if (length > 0) {\n        return c.error(c, {\n            message: \"Invalid ServerHelloDone message. Invalid length.\",\n            send: true,\n            alert: {\n                level: tls.Alert.Level.fatal,\n                description: tls.Alert.Description.record_overflow\n            }\n        });\n    }\n    if (c.serverCertificate === null) {\n        // no server certificate was provided\n        var error = {\n            message: \"No server certificate provided. Not enough security.\",\n            send: true,\n            alert: {\n                level: tls.Alert.Level.fatal,\n                description: tls.Alert.Description.insufficient_security\n            }\n        };\n        // call application callback\n        var depth = 0;\n        var ret = c.verify(c, error.alert.description, depth, []);\n        if (ret !== true) {\n            // check for custom alert info\n            if (ret || ret === 0) {\n                // set custom message and alert description\n                if (typeof ret === \"object\" && !forge.util.isArray(ret)) {\n                    if (ret.message) {\n                        error.message = ret.message;\n                    }\n                    if (ret.alert) {\n                        error.alert.description = ret.alert;\n                    }\n                } else if (typeof ret === \"number\") {\n                    // set custom alert description\n                    error.alert.description = ret;\n                }\n            }\n            // send error\n            return c.error(c, error);\n        }\n    }\n    // create client certificate message if requested\n    if (c.session.certificateRequest !== null) {\n        record = tls.createRecord(c, {\n            type: tls.ContentType.handshake,\n            data: tls.createCertificate(c)\n        });\n        tls.queue(c, record);\n    }\n    // create client key exchange message\n    record = tls.createRecord(c, {\n        type: tls.ContentType.handshake,\n        data: tls.createClientKeyExchange(c)\n    });\n    tls.queue(c, record);\n    // expect no messages until the following callback has been called\n    c.expect = SER;\n    // create callback to handle client signature (for client-certs)\n    var callback = function(c, signature) {\n        if (c.session.certificateRequest !== null && c.session.clientCertificate !== null) {\n            // create certificate verify message\n            tls.queue(c, tls.createRecord(c, {\n                type: tls.ContentType.handshake,\n                data: tls.createCertificateVerify(c, signature)\n            }));\n        }\n        // create change cipher spec message\n        tls.queue(c, tls.createRecord(c, {\n            type: tls.ContentType.change_cipher_spec,\n            data: tls.createChangeCipherSpec()\n        }));\n        // create pending state\n        c.state.pending = tls.createConnectionState(c);\n        // change current write state to pending write state\n        c.state.current.write = c.state.pending.write;\n        // create finished message\n        tls.queue(c, tls.createRecord(c, {\n            type: tls.ContentType.handshake,\n            data: tls.createFinished(c)\n        }));\n        // expect a server ChangeCipherSpec message next\n        c.expect = SCC;\n        // send records\n        tls.flush(c);\n        // continue\n        c.process();\n    };\n    // if there is no certificate request or no client certificate, do\n    // callback immediately\n    if (c.session.certificateRequest === null || c.session.clientCertificate === null) {\n        return callback(c, null);\n    }\n    // otherwise get the client signature\n    tls.getClientSignature(c, callback);\n};\n/**\n * Called when a ChangeCipherSpec record is received.\n *\n * @param c the connection.\n * @param record the record.\n */ tls.handleChangeCipherSpec = function(c, record) {\n    if (record.fragment.getByte() !== 0x01) {\n        return c.error(c, {\n            message: \"Invalid ChangeCipherSpec message received.\",\n            send: true,\n            alert: {\n                level: tls.Alert.Level.fatal,\n                description: tls.Alert.Description.illegal_parameter\n            }\n        });\n    }\n    // create pending state if:\n    // 1. Resuming session in client mode OR\n    // 2. NOT resuming session in server mode\n    var client = c.entity === tls.ConnectionEnd.client;\n    if (c.session.resuming && client || !c.session.resuming && !client) {\n        c.state.pending = tls.createConnectionState(c);\n    }\n    // change current read state to pending read state\n    c.state.current.read = c.state.pending.read;\n    // clear pending state if:\n    // 1. NOT resuming session in client mode OR\n    // 2. resuming a session in server mode\n    if (!c.session.resuming && client || c.session.resuming && !client) {\n        c.state.pending = null;\n    }\n    // expect a Finished record next\n    c.expect = client ? SFI : CFI;\n    // continue\n    c.process();\n};\n/**\n * Called when a Finished record is received.\n *\n * When this message will be sent:\n *   A finished message is always sent immediately after a change\n *   cipher spec message to verify that the key exchange and\n *   authentication processes were successful. It is essential that a\n *   change cipher spec message be received between the other\n *   handshake messages and the Finished message.\n *\n * Meaning of this message:\n *   The finished message is the first protected with the just-\n *   negotiated algorithms, keys, and secrets. Recipients of finished\n *   messages must verify that the contents are correct.  Once a side\n *   has sent its Finished message and received and validated the\n *   Finished message from its peer, it may begin to send and receive\n *   application data over the connection.\n *\n * struct {\n *   opaque verify_data[verify_data_length];\n * } Finished;\n *\n * verify_data\n *   PRF(master_secret, finished_label, Hash(handshake_messages))\n *     [0..verify_data_length-1];\n *\n * finished_label\n *   For Finished messages sent by the client, the string\n *   \"client finished\". For Finished messages sent by the server, the\n *   string \"server finished\".\n *\n * verify_data_length depends on the cipher suite. If it is not specified\n * by the cipher suite, then it is 12. Versions of TLS < 1.2 always used\n * 12 bytes.\n *\n * @param c the connection.\n * @param record the record.\n * @param length the length of the handshake message.\n */ tls.handleFinished = function(c, record, length) {\n    // rewind to get full bytes for message so it can be manually\n    // digested below (special case for Finished messages because they\n    // must be digested *after* handling as opposed to all others)\n    var b = record.fragment;\n    b.read -= 4;\n    var msgBytes = b.bytes();\n    b.read += 4;\n    // message contains only verify_data\n    var vd = record.fragment.getBytes();\n    // ensure verify data is correct\n    b = forge.util.createBuffer();\n    b.putBuffer(c.session.md5.digest());\n    b.putBuffer(c.session.sha1.digest());\n    // set label based on entity type\n    var client = c.entity === tls.ConnectionEnd.client;\n    var label = client ? \"server finished\" : \"client finished\";\n    // TODO: determine prf function and verify length for TLS 1.2\n    var sp = c.session.sp;\n    var vdl = 12;\n    var prf = prf_TLS1;\n    b = prf(sp.master_secret, label, b.getBytes(), vdl);\n    if (b.getBytes() !== vd) {\n        return c.error(c, {\n            message: \"Invalid verify_data in Finished message.\",\n            send: true,\n            alert: {\n                level: tls.Alert.Level.fatal,\n                description: tls.Alert.Description.decrypt_error\n            }\n        });\n    }\n    // digest finished message now that it has been handled\n    c.session.md5.update(msgBytes);\n    c.session.sha1.update(msgBytes);\n    // resuming session as client or NOT resuming session as server\n    if (c.session.resuming && client || !c.session.resuming && !client) {\n        // create change cipher spec message\n        tls.queue(c, tls.createRecord(c, {\n            type: tls.ContentType.change_cipher_spec,\n            data: tls.createChangeCipherSpec()\n        }));\n        // change current write state to pending write state, clear pending\n        c.state.current.write = c.state.pending.write;\n        c.state.pending = null;\n        // create finished message\n        tls.queue(c, tls.createRecord(c, {\n            type: tls.ContentType.handshake,\n            data: tls.createFinished(c)\n        }));\n    }\n    // expect application data next\n    c.expect = client ? SAD : CAD;\n    // handshake complete\n    c.handshaking = false;\n    ++c.handshakes;\n    // save access to peer certificate\n    c.peerCertificate = client ? c.session.serverCertificate : c.session.clientCertificate;\n    // send records\n    tls.flush(c);\n    // now connected\n    c.isConnected = true;\n    c.connected(c);\n    // continue\n    c.process();\n};\n/**\n * Called when an Alert record is received.\n *\n * @param c the connection.\n * @param record the record.\n */ tls.handleAlert = function(c, record) {\n    // read alert\n    var b = record.fragment;\n    var alert = {\n        level: b.getByte(),\n        description: b.getByte()\n    };\n    // TODO: consider using a table?\n    // get appropriate message\n    var msg;\n    switch(alert.description){\n        case tls.Alert.Description.close_notify:\n            msg = \"Connection closed.\";\n            break;\n        case tls.Alert.Description.unexpected_message:\n            msg = \"Unexpected message.\";\n            break;\n        case tls.Alert.Description.bad_record_mac:\n            msg = \"Bad record MAC.\";\n            break;\n        case tls.Alert.Description.decryption_failed:\n            msg = \"Decryption failed.\";\n            break;\n        case tls.Alert.Description.record_overflow:\n            msg = \"Record overflow.\";\n            break;\n        case tls.Alert.Description.decompression_failure:\n            msg = \"Decompression failed.\";\n            break;\n        case tls.Alert.Description.handshake_failure:\n            msg = \"Handshake failure.\";\n            break;\n        case tls.Alert.Description.bad_certificate:\n            msg = \"Bad certificate.\";\n            break;\n        case tls.Alert.Description.unsupported_certificate:\n            msg = \"Unsupported certificate.\";\n            break;\n        case tls.Alert.Description.certificate_revoked:\n            msg = \"Certificate revoked.\";\n            break;\n        case tls.Alert.Description.certificate_expired:\n            msg = \"Certificate expired.\";\n            break;\n        case tls.Alert.Description.certificate_unknown:\n            msg = \"Certificate unknown.\";\n            break;\n        case tls.Alert.Description.illegal_parameter:\n            msg = \"Illegal parameter.\";\n            break;\n        case tls.Alert.Description.unknown_ca:\n            msg = \"Unknown certificate authority.\";\n            break;\n        case tls.Alert.Description.access_denied:\n            msg = \"Access denied.\";\n            break;\n        case tls.Alert.Description.decode_error:\n            msg = \"Decode error.\";\n            break;\n        case tls.Alert.Description.decrypt_error:\n            msg = \"Decrypt error.\";\n            break;\n        case tls.Alert.Description.export_restriction:\n            msg = \"Export restriction.\";\n            break;\n        case tls.Alert.Description.protocol_version:\n            msg = \"Unsupported protocol version.\";\n            break;\n        case tls.Alert.Description.insufficient_security:\n            msg = \"Insufficient security.\";\n            break;\n        case tls.Alert.Description.internal_error:\n            msg = \"Internal error.\";\n            break;\n        case tls.Alert.Description.user_canceled:\n            msg = \"User canceled.\";\n            break;\n        case tls.Alert.Description.no_renegotiation:\n            msg = \"Renegotiation not supported.\";\n            break;\n        default:\n            msg = \"Unknown error.\";\n            break;\n    }\n    // close connection on close_notify, not an error\n    if (alert.description === tls.Alert.Description.close_notify) {\n        return c.close();\n    }\n    // call error handler\n    c.error(c, {\n        message: msg,\n        send: false,\n        // origin is the opposite end\n        origin: c.entity === tls.ConnectionEnd.client ? \"server\" : \"client\",\n        alert: alert\n    });\n    // continue\n    c.process();\n};\n/**\n * Called when a Handshake record is received.\n *\n * @param c the connection.\n * @param record the record.\n */ tls.handleHandshake = function(c, record) {\n    // get the handshake type and message length\n    var b = record.fragment;\n    var type = b.getByte();\n    var length = b.getInt24();\n    // see if the record fragment doesn't yet contain the full message\n    if (length > b.length()) {\n        // cache the record, clear its fragment, and reset the buffer read\n        // pointer before the type and length were read\n        c.fragmented = record;\n        record.fragment = forge.util.createBuffer();\n        b.read -= 4;\n        // continue\n        return c.process();\n    }\n    // full message now available, clear cache, reset read pointer to\n    // before type and length\n    c.fragmented = null;\n    b.read -= 4;\n    // save the handshake bytes for digestion after handler is found\n    // (include type and length of handshake msg)\n    var bytes = b.bytes(length + 4);\n    // restore read pointer\n    b.read += 4;\n    // handle expected message\n    if (type in hsTable[c.entity][c.expect]) {\n        // initialize server session\n        if (c.entity === tls.ConnectionEnd.server && !c.open && !c.fail) {\n            c.handshaking = true;\n            c.session = {\n                version: null,\n                extensions: {\n                    server_name: {\n                        serverNameList: []\n                    }\n                },\n                cipherSuite: null,\n                compressionMethod: null,\n                serverCertificate: null,\n                clientCertificate: null,\n                md5: forge.md.md5.create(),\n                sha1: forge.md.sha1.create()\n            };\n        }\n        /* Update handshake messages digest. Finished and CertificateVerify\n      messages are not digested here. They can't be digested as part of\n      the verify_data that they contain. These messages are manually\n      digested in their handlers. HelloRequest messages are simply never\n      included in the handshake message digest according to spec. */ if (type !== tls.HandshakeType.hello_request && type !== tls.HandshakeType.certificate_verify && type !== tls.HandshakeType.finished) {\n            c.session.md5.update(bytes);\n            c.session.sha1.update(bytes);\n        }\n        // handle specific handshake type record\n        hsTable[c.entity][c.expect][type](c, record, length);\n    } else {\n        // unexpected record\n        tls.handleUnexpected(c, record);\n    }\n};\n/**\n * Called when an ApplicationData record is received.\n *\n * @param c the connection.\n * @param record the record.\n */ tls.handleApplicationData = function(c, record) {\n    // buffer data, notify that its ready\n    c.data.putBuffer(record.fragment);\n    c.dataReady(c);\n    // continue\n    c.process();\n};\n/**\n * Called when a Heartbeat record is received.\n *\n * @param c the connection.\n * @param record the record.\n */ tls.handleHeartbeat = function(c, record) {\n    // get the heartbeat type and payload\n    var b = record.fragment;\n    var type = b.getByte();\n    var length = b.getInt16();\n    var payload = b.getBytes(length);\n    if (type === tls.HeartbeatMessageType.heartbeat_request) {\n        // discard request during handshake or if length is too large\n        if (c.handshaking || length > payload.length) {\n            // continue\n            return c.process();\n        }\n        // retransmit payload\n        tls.queue(c, tls.createRecord(c, {\n            type: tls.ContentType.heartbeat,\n            data: tls.createHeartbeat(tls.HeartbeatMessageType.heartbeat_response, payload)\n        }));\n        tls.flush(c);\n    } else if (type === tls.HeartbeatMessageType.heartbeat_response) {\n        // check payload against expected payload, discard heartbeat if no match\n        if (payload !== c.expectedHeartbeatPayload) {\n            // continue\n            return c.process();\n        }\n        // notify that a valid heartbeat was received\n        if (c.heartbeatReceived) {\n            c.heartbeatReceived(c, forge.util.createBuffer(payload));\n        }\n    }\n    // continue\n    c.process();\n};\n/**\n * The transistional state tables for receiving TLS records. It maps the\n * current TLS engine state and a received record to a function to handle the\n * record and update the state.\n *\n * For instance, if the current state is SHE, then the TLS engine is expecting\n * a ServerHello record. Once a record is received, the handler function is\n * looked up using the state SHE and the record's content type.\n *\n * The resulting function will either be an error handler or a record handler.\n * The function will take whatever action is appropriate and update the state\n * for the next record.\n *\n * The states are all based on possible server record types. Note that the\n * client will never specifically expect to receive a HelloRequest or an alert\n * from the server so there is no state that reflects this. These messages may\n * occur at any time.\n *\n * There are two tables for mapping states because there is a second tier of\n * types for handshake messages. Once a record with a content type of handshake\n * is received, the handshake record handler will look up the handshake type in\n * the secondary map to get its appropriate handler.\n *\n * Valid message orders are as follows:\n *\n * =======================FULL HANDSHAKE======================\n * Client                                               Server\n *\n * ClientHello                  -------->\n *                                                 ServerHello\n *                                                Certificate*\n *                                          ServerKeyExchange*\n *                                         CertificateRequest*\n *                              <--------      ServerHelloDone\n * Certificate*\n * ClientKeyExchange\n * CertificateVerify*\n * [ChangeCipherSpec]\n * Finished                     -------->\n *                                          [ChangeCipherSpec]\n *                              <--------             Finished\n * Application Data             <------->     Application Data\n *\n * =====================SESSION RESUMPTION=====================\n * Client                                                Server\n *\n * ClientHello                   -------->\n *                                                  ServerHello\n *                                           [ChangeCipherSpec]\n *                               <--------             Finished\n * [ChangeCipherSpec]\n * Finished                      -------->\n * Application Data              <------->     Application Data\n */ // client expect states (indicate which records are expected to be received)\nvar SHE = 0; // rcv server hello\nvar SCE = 1; // rcv server certificate\nvar SKE = 2; // rcv server key exchange\nvar SCR = 3; // rcv certificate request\nvar SHD = 4; // rcv server hello done\nvar SCC = 5; // rcv change cipher spec\nvar SFI = 6; // rcv finished\nvar SAD = 7; // rcv application data\nvar SER = 8; // not expecting any messages at this point\n// server expect states\nvar CHE = 0; // rcv client hello\nvar CCE = 1; // rcv client certificate\nvar CKE = 2; // rcv client key exchange\nvar CCV = 3; // rcv certificate verify\nvar CCC = 4; // rcv change cipher spec\nvar CFI = 5; // rcv finished\nvar CAD = 6; // rcv application data\nvar CER = 7; // not expecting any messages at this point\n// map client current expect state and content type to function\nvar __ = tls.handleUnexpected;\nvar R0 = tls.handleChangeCipherSpec;\nvar R1 = tls.handleAlert;\nvar R2 = tls.handleHandshake;\nvar R3 = tls.handleApplicationData;\nvar R4 = tls.handleHeartbeat;\nvar ctTable = [];\nctTable[tls.ConnectionEnd.client] = [\n    //      CC,AL,HS,AD,HB\n    /*SHE*/ [\n        __,\n        R1,\n        R2,\n        __,\n        R4\n    ],\n    /*SCE*/ [\n        __,\n        R1,\n        R2,\n        __,\n        R4\n    ],\n    /*SKE*/ [\n        __,\n        R1,\n        R2,\n        __,\n        R4\n    ],\n    /*SCR*/ [\n        __,\n        R1,\n        R2,\n        __,\n        R4\n    ],\n    /*SHD*/ [\n        __,\n        R1,\n        R2,\n        __,\n        R4\n    ],\n    /*SCC*/ [\n        R0,\n        R1,\n        __,\n        __,\n        R4\n    ],\n    /*SFI*/ [\n        __,\n        R1,\n        R2,\n        __,\n        R4\n    ],\n    /*SAD*/ [\n        __,\n        R1,\n        R2,\n        R3,\n        R4\n    ],\n    /*SER*/ [\n        __,\n        R1,\n        R2,\n        __,\n        R4\n    ]\n];\n// map server current expect state and content type to function\nctTable[tls.ConnectionEnd.server] = [\n    //      CC,AL,HS,AD\n    /*CHE*/ [\n        __,\n        R1,\n        R2,\n        __,\n        R4\n    ],\n    /*CCE*/ [\n        __,\n        R1,\n        R2,\n        __,\n        R4\n    ],\n    /*CKE*/ [\n        __,\n        R1,\n        R2,\n        __,\n        R4\n    ],\n    /*CCV*/ [\n        __,\n        R1,\n        R2,\n        __,\n        R4\n    ],\n    /*CCC*/ [\n        R0,\n        R1,\n        __,\n        __,\n        R4\n    ],\n    /*CFI*/ [\n        __,\n        R1,\n        R2,\n        __,\n        R4\n    ],\n    /*CAD*/ [\n        __,\n        R1,\n        R2,\n        R3,\n        R4\n    ],\n    /*CER*/ [\n        __,\n        R1,\n        R2,\n        __,\n        R4\n    ]\n];\n// map client current expect state and handshake type to function\nvar H0 = tls.handleHelloRequest;\nvar H1 = tls.handleServerHello;\nvar H2 = tls.handleCertificate;\nvar H3 = tls.handleServerKeyExchange;\nvar H4 = tls.handleCertificateRequest;\nvar H5 = tls.handleServerHelloDone;\nvar H6 = tls.handleFinished;\nvar hsTable = [];\nhsTable[tls.ConnectionEnd.client] = [\n    //      HR,01,SH,03,04,05,06,07,08,09,10,SC,SK,CR,HD,15,CK,17,18,19,FI\n    /*SHE*/ [\n        __,\n        __,\n        H1,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __\n    ],\n    /*SCE*/ [\n        H0,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        H2,\n        H3,\n        H4,\n        H5,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __\n    ],\n    /*SKE*/ [\n        H0,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        H3,\n        H4,\n        H5,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __\n    ],\n    /*SCR*/ [\n        H0,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        H4,\n        H5,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __\n    ],\n    /*SHD*/ [\n        H0,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        H5,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __\n    ],\n    /*SCC*/ [\n        H0,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __\n    ],\n    /*SFI*/ [\n        H0,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        H6\n    ],\n    /*SAD*/ [\n        H0,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __\n    ],\n    /*SER*/ [\n        H0,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __\n    ]\n];\n// map server current expect state and handshake type to function\n// Note: CAD[CH] does not map to FB because renegotation is prohibited\nvar H7 = tls.handleClientHello;\nvar H8 = tls.handleClientKeyExchange;\nvar H9 = tls.handleCertificateVerify;\nhsTable[tls.ConnectionEnd.server] = [\n    //      01,CH,02,03,04,05,06,07,08,09,10,CC,12,13,14,CV,CK,17,18,19,FI\n    /*CHE*/ [\n        __,\n        H7,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __\n    ],\n    /*CCE*/ [\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        H2,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __\n    ],\n    /*CKE*/ [\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        H8,\n        __,\n        __,\n        __,\n        __\n    ],\n    /*CCV*/ [\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        H9,\n        __,\n        __,\n        __,\n        __,\n        __\n    ],\n    /*CCC*/ [\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __\n    ],\n    /*CFI*/ [\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        H6\n    ],\n    /*CAD*/ [\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __\n    ],\n    /*CER*/ [\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __,\n        __\n    ]\n];\n/**\n * Generates the master_secret and keys using the given security parameters.\n *\n * The security parameters for a TLS connection state are defined as such:\n *\n * struct {\n *   ConnectionEnd          entity;\n *   PRFAlgorithm           prf_algorithm;\n *   BulkCipherAlgorithm    bulk_cipher_algorithm;\n *   CipherType             cipher_type;\n *   uint8                  enc_key_length;\n *   uint8                  block_length;\n *   uint8                  fixed_iv_length;\n *   uint8                  record_iv_length;\n *   MACAlgorithm           mac_algorithm;\n *   uint8                  mac_length;\n *   uint8                  mac_key_length;\n *   CompressionMethod      compression_algorithm;\n *   opaque                 master_secret[48];\n *   opaque                 client_random[32];\n *   opaque                 server_random[32];\n * } SecurityParameters;\n *\n * Note that this definition is from TLS 1.2. In TLS 1.0 some of these\n * parameters are ignored because, for instance, the PRFAlgorithm is a\n * builtin-fixed algorithm combining iterations of MD5 and SHA-1 in TLS 1.0.\n *\n * The Record Protocol requires an algorithm to generate keys required by the\n * current connection state.\n *\n * The master secret is expanded into a sequence of secure bytes, which is then\n * split to a client write MAC key, a server write MAC key, a client write\n * encryption key, and a server write encryption key. In TLS 1.0 a client write\n * IV and server write IV are also generated. Each of these is generated from\n * the byte sequence in that order. Unused values are empty. In TLS 1.2, some\n * AEAD ciphers may additionally require a client write IV and a server write\n * IV (see Section 6.2.3.3).\n *\n * When keys, MAC keys, and IVs are generated, the master secret is used as an\n * entropy source.\n *\n * To generate the key material, compute:\n *\n * master_secret = PRF(pre_master_secret, \"master secret\",\n *                     ClientHello.random + ServerHello.random)\n *\n * key_block = PRF(SecurityParameters.master_secret,\n *                 \"key expansion\",\n *                 SecurityParameters.server_random +\n *                 SecurityParameters.client_random);\n *\n * until enough output has been generated. Then, the key_block is\n * partitioned as follows:\n *\n * client_write_MAC_key[SecurityParameters.mac_key_length]\n * server_write_MAC_key[SecurityParameters.mac_key_length]\n * client_write_key[SecurityParameters.enc_key_length]\n * server_write_key[SecurityParameters.enc_key_length]\n * client_write_IV[SecurityParameters.fixed_iv_length]\n * server_write_IV[SecurityParameters.fixed_iv_length]\n *\n * In TLS 1.2, the client_write_IV and server_write_IV are only generated for\n * implicit nonce techniques as described in Section 3.2.1 of [AEAD]. This\n * implementation uses TLS 1.0 so IVs are generated.\n *\n * Implementation note: The currently defined cipher suite which requires the\n * most material is AES_256_CBC_SHA256. It requires 2 x 32 byte keys and 2 x 32\n * byte MAC keys, for a total 128 bytes of key material. In TLS 1.0 it also\n * requires 2 x 16 byte IVs, so it actually takes 160 bytes of key material.\n *\n * @param c the connection.\n * @param sp the security parameters to use.\n *\n * @return the security keys.\n */ tls.generateKeys = function(c, sp) {\n    // TLS_RSA_WITH_AES_128_CBC_SHA (required to be compliant with TLS 1.2) &\n    // TLS_RSA_WITH_AES_256_CBC_SHA are the only cipher suites implemented\n    // at present\n    // TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA is required to be compliant with\n    // TLS 1.0 but we don't care right now because AES is better and we have\n    // an implementation for it\n    // TODO: TLS 1.2 implementation\n    /*\n  // determine the PRF\n  var prf;\n  switch(sp.prf_algorithm) {\n  case tls.PRFAlgorithm.tls_prf_sha256:\n    prf = prf_sha256;\n    break;\n  default:\n    // should never happen\n    throw new Error('Invalid PRF');\n  }\n  */ // TLS 1.0/1.1 implementation\n    var prf = prf_TLS1;\n    // concatenate server and client random\n    var random = sp.client_random + sp.server_random;\n    // only create master secret if session is new\n    if (!c.session.resuming) {\n        // create master secret, clean up pre-master secret\n        sp.master_secret = prf(sp.pre_master_secret, \"master secret\", random, 48).bytes();\n        sp.pre_master_secret = null;\n    }\n    // generate the amount of key material needed\n    random = sp.server_random + sp.client_random;\n    var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length;\n    // include IV for TLS/1.0\n    var tls10 = c.version.major === tls.Versions.TLS_1_0.major && c.version.minor === tls.Versions.TLS_1_0.minor;\n    if (tls10) {\n        length += 2 * sp.fixed_iv_length;\n    }\n    var km = prf(sp.master_secret, \"key expansion\", random, length);\n    // split the key material into the MAC and encryption keys\n    var rval = {\n        client_write_MAC_key: km.getBytes(sp.mac_key_length),\n        server_write_MAC_key: km.getBytes(sp.mac_key_length),\n        client_write_key: km.getBytes(sp.enc_key_length),\n        server_write_key: km.getBytes(sp.enc_key_length)\n    };\n    // include TLS 1.0 IVs\n    if (tls10) {\n        rval.client_write_IV = km.getBytes(sp.fixed_iv_length);\n        rval.server_write_IV = km.getBytes(sp.fixed_iv_length);\n    }\n    return rval;\n};\n/**\n * Creates a new initialized TLS connection state. A connection state has\n * a read mode and a write mode.\n *\n * compression state:\n *   The current state of the compression algorithm.\n *\n * cipher state:\n *   The current state of the encryption algorithm. This will consist of the\n *   scheduled key for that connection. For stream ciphers, this will also\n *   contain whatever state information is necessary to allow the stream to\n *   continue to encrypt or decrypt data.\n *\n * MAC key:\n *   The MAC key for the connection.\n *\n * sequence number:\n *   Each connection state contains a sequence number, which is maintained\n *   separately for read and write states. The sequence number MUST be set to\n *   zero whenever a connection state is made the active state. Sequence\n *   numbers are of type uint64 and may not exceed 2^64-1. Sequence numbers do\n *   not wrap. If a TLS implementation would need to wrap a sequence number,\n *   it must renegotiate instead. A sequence number is incremented after each\n *   record: specifically, the first record transmitted under a particular\n *   connection state MUST use sequence number 0.\n *\n * @param c the connection.\n *\n * @return the new initialized TLS connection state.\n */ tls.createConnectionState = function(c) {\n    var client = c.entity === tls.ConnectionEnd.client;\n    var createMode = function() {\n        var mode = {\n            // two 32-bit numbers, first is most significant\n            sequenceNumber: [\n                0,\n                0\n            ],\n            macKey: null,\n            macLength: 0,\n            macFunction: null,\n            cipherState: null,\n            cipherFunction: function(record) {\n                return true;\n            },\n            compressionState: null,\n            compressFunction: function(record) {\n                return true;\n            },\n            updateSequenceNumber: function() {\n                if (mode.sequenceNumber[1] === 0xFFFFFFFF) {\n                    mode.sequenceNumber[1] = 0;\n                    ++mode.sequenceNumber[0];\n                } else {\n                    ++mode.sequenceNumber[1];\n                }\n            }\n        };\n        return mode;\n    };\n    var state = {\n        read: createMode(),\n        write: createMode()\n    };\n    // update function in read mode will decrypt then decompress a record\n    state.read.update = function(c, record) {\n        if (!state.read.cipherFunction(record, state.read)) {\n            c.error(c, {\n                message: \"Could not decrypt record or bad MAC.\",\n                send: true,\n                alert: {\n                    level: tls.Alert.Level.fatal,\n                    // doesn't matter if decryption failed or MAC was\n                    // invalid, return the same error so as not to reveal\n                    // which one occurred\n                    description: tls.Alert.Description.bad_record_mac\n                }\n            });\n        } else if (!state.read.compressFunction(c, record, state.read)) {\n            c.error(c, {\n                message: \"Could not decompress record.\",\n                send: true,\n                alert: {\n                    level: tls.Alert.Level.fatal,\n                    description: tls.Alert.Description.decompression_failure\n                }\n            });\n        }\n        return !c.fail;\n    };\n    // update function in write mode will compress then encrypt a record\n    state.write.update = function(c, record) {\n        if (!state.write.compressFunction(c, record, state.write)) {\n            // error, but do not send alert since it would require\n            // compression as well\n            c.error(c, {\n                message: \"Could not compress record.\",\n                send: false,\n                alert: {\n                    level: tls.Alert.Level.fatal,\n                    description: tls.Alert.Description.internal_error\n                }\n            });\n        } else if (!state.write.cipherFunction(record, state.write)) {\n            // error, but do not send alert since it would require\n            // encryption as well\n            c.error(c, {\n                message: \"Could not encrypt record.\",\n                send: false,\n                alert: {\n                    level: tls.Alert.Level.fatal,\n                    description: tls.Alert.Description.internal_error\n                }\n            });\n        }\n        return !c.fail;\n    };\n    // handle security parameters\n    if (c.session) {\n        var sp = c.session.sp;\n        c.session.cipherSuite.initSecurityParameters(sp);\n        // generate keys\n        sp.keys = tls.generateKeys(c, sp);\n        state.read.macKey = client ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;\n        state.write.macKey = client ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;\n        // cipher suite setup\n        c.session.cipherSuite.initConnectionState(state, c, sp);\n        // compression setup\n        switch(sp.compression_algorithm){\n            case tls.CompressionMethod.none:\n                break;\n            case tls.CompressionMethod.deflate:\n                state.read.compressFunction = inflate;\n                state.write.compressFunction = deflate;\n                break;\n            default:\n                throw new Error(\"Unsupported compression algorithm.\");\n        }\n    }\n    return state;\n};\n/**\n * Creates a Random structure.\n *\n * struct {\n *   uint32 gmt_unix_time;\n *   opaque random_bytes[28];\n * } Random;\n *\n * gmt_unix_time:\n *   The current time and date in standard UNIX 32-bit format (seconds since\n *   the midnight starting Jan 1, 1970, UTC, ignoring leap seconds) according\n *   to the sender's internal clock. Clocks are not required to be set\n *   correctly by the basic TLS protocol; higher-level or application\n *   protocols may define additional requirements. Note that, for historical\n *   reasons, the data element is named using GMT, the predecessor of the\n *   current worldwide time base, UTC.\n * random_bytes:\n *   28 bytes generated by a secure random number generator.\n *\n * @return the Random structure as a byte array.\n */ tls.createRandom = function() {\n    // get UTC milliseconds\n    var d = new Date();\n    var utc = +d + d.getTimezoneOffset() * 60000;\n    var rval = forge.util.createBuffer();\n    rval.putInt32(utc);\n    rval.putBytes(forge.random.getBytes(28));\n    return rval;\n};\n/**\n * Creates a TLS record with the given type and data.\n *\n * @param c the connection.\n * @param options:\n *   type: the record type.\n *   data: the plain text data in a byte buffer.\n *\n * @return the created record.\n */ tls.createRecord = function(c, options) {\n    if (!options.data) {\n        return null;\n    }\n    var record = {\n        type: options.type,\n        version: {\n            major: c.version.major,\n            minor: c.version.minor\n        },\n        length: options.data.length(),\n        fragment: options.data\n    };\n    return record;\n};\n/**\n * Creates a TLS alert record.\n *\n * @param c the connection.\n * @param alert:\n *   level: the TLS alert level.\n *   description: the TLS alert description.\n *\n * @return the created alert record.\n */ tls.createAlert = function(c, alert) {\n    var b = forge.util.createBuffer();\n    b.putByte(alert.level);\n    b.putByte(alert.description);\n    return tls.createRecord(c, {\n        type: tls.ContentType.alert,\n        data: b\n    });\n};\n/* The structure of a TLS handshake message.\n *\n * struct {\n *    HandshakeType msg_type;    // handshake type\n *    uint24 length;             // bytes in message\n *    select(HandshakeType) {\n *       case hello_request:       HelloRequest;\n *       case client_hello:        ClientHello;\n *       case server_hello:        ServerHello;\n *       case certificate:         Certificate;\n *       case server_key_exchange: ServerKeyExchange;\n *       case certificate_request: CertificateRequest;\n *       case server_hello_done:   ServerHelloDone;\n *       case certificate_verify:  CertificateVerify;\n *       case client_key_exchange: ClientKeyExchange;\n *       case finished:            Finished;\n *    } body;\n * } Handshake;\n */ /**\n * Creates a ClientHello message.\n *\n * opaque SessionID<0..32>;\n * enum { null(0), deflate(1), (255) } CompressionMethod;\n * uint8 CipherSuite[2];\n *\n * struct {\n *   ProtocolVersion client_version;\n *   Random random;\n *   SessionID session_id;\n *   CipherSuite cipher_suites<2..2^16-2>;\n *   CompressionMethod compression_methods<1..2^8-1>;\n *   select(extensions_present) {\n *     case false:\n *       struct {};\n *     case true:\n *       Extension extensions<0..2^16-1>;\n *   };\n * } ClientHello;\n *\n * The extension format for extended client hellos and server hellos is:\n *\n * struct {\n *   ExtensionType extension_type;\n *   opaque extension_data<0..2^16-1>;\n * } Extension;\n *\n * Here:\n *\n * - \"extension_type\" identifies the particular extension type.\n * - \"extension_data\" contains information specific to the particular\n * extension type.\n *\n * The extension types defined in this document are:\n *\n * enum {\n *   server_name(0), max_fragment_length(1),\n *   client_certificate_url(2), trusted_ca_keys(3),\n *   truncated_hmac(4), status_request(5), (65535)\n * } ExtensionType;\n *\n * @param c the connection.\n *\n * @return the ClientHello byte buffer.\n */ tls.createClientHello = function(c) {\n    // save hello version\n    c.session.clientHelloVersion = {\n        major: c.version.major,\n        minor: c.version.minor\n    };\n    // create supported cipher suites\n    var cipherSuites = forge.util.createBuffer();\n    for(var i = 0; i < c.cipherSuites.length; ++i){\n        var cs = c.cipherSuites[i];\n        cipherSuites.putByte(cs.id[0]);\n        cipherSuites.putByte(cs.id[1]);\n    }\n    var cSuites = cipherSuites.length();\n    // create supported compression methods, null always supported, but\n    // also support deflate if connection has inflate and deflate methods\n    var compressionMethods = forge.util.createBuffer();\n    compressionMethods.putByte(tls.CompressionMethod.none);\n    // FIXME: deflate support disabled until issues with raw deflate data\n    // without zlib headers are resolved\n    /*\n  if(c.inflate !== null && c.deflate !== null) {\n    compressionMethods.putByte(tls.CompressionMethod.deflate);\n  }\n  */ var cMethods = compressionMethods.length();\n    // create TLS SNI (server name indication) extension if virtual host\n    // has been specified, see RFC 3546\n    var extensions = forge.util.createBuffer();\n    if (c.virtualHost) {\n        // create extension struct\n        var ext = forge.util.createBuffer();\n        ext.putByte(0x00); // type server_name (ExtensionType is 2 bytes)\n        ext.putByte(0x00);\n        /* In order to provide the server name, clients MAY include an\n     * extension of type \"server_name\" in the (extended) client hello.\n     * The \"extension_data\" field of this extension SHALL contain\n     * \"ServerNameList\" where:\n     *\n     * struct {\n     *   NameType name_type;\n     *   select(name_type) {\n     *     case host_name: HostName;\n     *   } name;\n     * } ServerName;\n     *\n     * enum {\n     *   host_name(0), (255)\n     * } NameType;\n     *\n     * opaque HostName<1..2^16-1>;\n     *\n     * struct {\n     *   ServerName server_name_list<1..2^16-1>\n     * } ServerNameList;\n     */ var serverName = forge.util.createBuffer();\n        serverName.putByte(0x00); // type host_name\n        writeVector(serverName, 2, forge.util.createBuffer(c.virtualHost));\n        // ServerNameList is in extension_data\n        var snList = forge.util.createBuffer();\n        writeVector(snList, 2, serverName);\n        writeVector(ext, 2, snList);\n        extensions.putBuffer(ext);\n    }\n    var extLength = extensions.length();\n    if (extLength > 0) {\n        // add extension vector length\n        extLength += 2;\n    }\n    // determine length of the handshake message\n    // cipher suites and compression methods size will need to be\n    // updated if more get added to the list\n    var sessionId = c.session.id;\n    var length = sessionId.length + 1 + // session ID vector\n    2 + // version (major + minor)\n    4 + 28 + // random time and random bytes\n    2 + cSuites + // cipher suites vector\n    1 + cMethods + // compression methods vector\n    extLength; // extensions vector\n    // build record fragment\n    var rval = forge.util.createBuffer();\n    rval.putByte(tls.HandshakeType.client_hello);\n    rval.putInt24(length); // handshake length\n    rval.putByte(c.version.major); // major version\n    rval.putByte(c.version.minor); // minor version\n    rval.putBytes(c.session.sp.client_random); // random time + bytes\n    writeVector(rval, 1, forge.util.createBuffer(sessionId));\n    writeVector(rval, 2, cipherSuites);\n    writeVector(rval, 1, compressionMethods);\n    if (extLength > 0) {\n        writeVector(rval, 2, extensions);\n    }\n    return rval;\n};\n/**\n * Creates a ServerHello message.\n *\n * @param c the connection.\n *\n * @return the ServerHello byte buffer.\n */ tls.createServerHello = function(c) {\n    // determine length of the handshake message\n    var sessionId = c.session.id;\n    var length = sessionId.length + 1 + // session ID vector\n    2 + // version (major + minor)\n    4 + 28 + // random time and random bytes\n    2 + // chosen cipher suite\n    1; // chosen compression method\n    // build record fragment\n    var rval = forge.util.createBuffer();\n    rval.putByte(tls.HandshakeType.server_hello);\n    rval.putInt24(length); // handshake length\n    rval.putByte(c.version.major); // major version\n    rval.putByte(c.version.minor); // minor version\n    rval.putBytes(c.session.sp.server_random); // random time + bytes\n    writeVector(rval, 1, forge.util.createBuffer(sessionId));\n    rval.putByte(c.session.cipherSuite.id[0]);\n    rval.putByte(c.session.cipherSuite.id[1]);\n    rval.putByte(c.session.compressionMethod);\n    return rval;\n};\n/**\n * Creates a Certificate message.\n *\n * When this message will be sent:\n *   This is the first message the client can send after receiving a server\n *   hello done message and the first message the server can send after\n *   sending a ServerHello. This client message is only sent if the server\n *   requests a certificate. If no suitable certificate is available, the\n *   client should send a certificate message containing no certificates. If\n *   client authentication is required by the server for the handshake to\n *   continue, it may respond with a fatal handshake failure alert.\n *\n * opaque ASN.1Cert<1..2^24-1>;\n *\n * struct {\n *   ASN.1Cert certificate_list<0..2^24-1>;\n * } Certificate;\n *\n * @param c the connection.\n *\n * @return the Certificate byte buffer.\n */ tls.createCertificate = function(c) {\n    // TODO: check certificate request to ensure types are supported\n    // get a certificate (a certificate as a PEM string)\n    var client = c.entity === tls.ConnectionEnd.client;\n    var cert = null;\n    if (c.getCertificate) {\n        var hint;\n        if (client) {\n            hint = c.session.certificateRequest;\n        } else {\n            hint = c.session.extensions.server_name.serverNameList;\n        }\n        cert = c.getCertificate(c, hint);\n    }\n    // buffer to hold certificate list\n    var certList = forge.util.createBuffer();\n    if (cert !== null) {\n        try {\n            // normalize cert to a chain of certificates\n            if (!forge.util.isArray(cert)) {\n                cert = [\n                    cert\n                ];\n            }\n            var asn1 = null;\n            for(var i = 0; i < cert.length; ++i){\n                var msg = forge.pem.decode(cert[i])[0];\n                if (msg.type !== \"CERTIFICATE\" && msg.type !== \"X509 CERTIFICATE\" && msg.type !== \"TRUSTED CERTIFICATE\") {\n                    var error = new Error(\"Could not convert certificate from PEM; PEM \" + 'header type is not \"CERTIFICATE\", \"X509 CERTIFICATE\", or ' + '\"TRUSTED CERTIFICATE\".');\n                    error.headerType = msg.type;\n                    throw error;\n                }\n                if (msg.procType && msg.procType.type === \"ENCRYPTED\") {\n                    throw new Error(\"Could not convert certificate from PEM; PEM is encrypted.\");\n                }\n                var der = forge.util.createBuffer(msg.body);\n                if (asn1 === null) {\n                    asn1 = forge.asn1.fromDer(der.bytes(), false);\n                }\n                // certificate entry is itself a vector with 3 length bytes\n                var certBuffer = forge.util.createBuffer();\n                writeVector(certBuffer, 3, der);\n                // add cert vector to cert list vector\n                certList.putBuffer(certBuffer);\n            }\n            // save certificate\n            cert = forge.pki.certificateFromAsn1(asn1);\n            if (client) {\n                c.session.clientCertificate = cert;\n            } else {\n                c.session.serverCertificate = cert;\n            }\n        } catch (ex) {\n            return c.error(c, {\n                message: \"Could not send certificate list.\",\n                cause: ex,\n                send: true,\n                alert: {\n                    level: tls.Alert.Level.fatal,\n                    description: tls.Alert.Description.bad_certificate\n                }\n            });\n        }\n    }\n    // determine length of the handshake message\n    var length = 3 + certList.length(); // cert list vector\n    // build record fragment\n    var rval = forge.util.createBuffer();\n    rval.putByte(tls.HandshakeType.certificate);\n    rval.putInt24(length);\n    writeVector(rval, 3, certList);\n    return rval;\n};\n/**\n * Creates a ClientKeyExchange message.\n *\n * When this message will be sent:\n *   This message is always sent by the client. It will immediately follow the\n *   client certificate message, if it is sent. Otherwise it will be the first\n *   message sent by the client after it receives the server hello done\n *   message.\n *\n * Meaning of this message:\n *   With this message, the premaster secret is set, either though direct\n *   transmission of the RSA-encrypted secret, or by the transmission of\n *   Diffie-Hellman parameters which will allow each side to agree upon the\n *   same premaster secret. When the key exchange method is DH_RSA or DH_DSS,\n *   client certification has been requested, and the client was able to\n *   respond with a certificate which contained a Diffie-Hellman public key\n *   whose parameters (group and generator) matched those specified by the\n *   server in its certificate, this message will not contain any data.\n *\n * Meaning of this message:\n *   If RSA is being used for key agreement and authentication, the client\n *   generates a 48-byte premaster secret, encrypts it using the public key\n *   from the server's certificate or the temporary RSA key provided in a\n *   server key exchange message, and sends the result in an encrypted\n *   premaster secret message. This structure is a variant of the client\n *   key exchange message, not a message in itself.\n *\n * struct {\n *   select(KeyExchangeAlgorithm) {\n *     case rsa: EncryptedPreMasterSecret;\n *     case diffie_hellman: ClientDiffieHellmanPublic;\n *   } exchange_keys;\n * } ClientKeyExchange;\n *\n * struct {\n *   ProtocolVersion client_version;\n *   opaque random[46];\n * } PreMasterSecret;\n *\n * struct {\n *   public-key-encrypted PreMasterSecret pre_master_secret;\n * } EncryptedPreMasterSecret;\n *\n * A public-key-encrypted element is encoded as a vector <0..2^16-1>.\n *\n * @param c the connection.\n *\n * @return the ClientKeyExchange byte buffer.\n */ tls.createClientKeyExchange = function(c) {\n    // create buffer to encrypt\n    var b = forge.util.createBuffer();\n    // add highest client-supported protocol to help server avoid version\n    // rollback attacks\n    b.putByte(c.session.clientHelloVersion.major);\n    b.putByte(c.session.clientHelloVersion.minor);\n    // generate and add 46 random bytes\n    b.putBytes(forge.random.getBytes(46));\n    // save pre-master secret\n    var sp = c.session.sp;\n    sp.pre_master_secret = b.getBytes();\n    // RSA-encrypt the pre-master secret\n    var key = c.session.serverCertificate.publicKey;\n    b = key.encrypt(sp.pre_master_secret);\n    /* Note: The encrypted pre-master secret will be stored in a\n    public-key-encrypted opaque vector that has the length prefixed using\n    2 bytes, so include those 2 bytes in the handshake message length. This\n    is done as a minor optimization instead of calling writeVector(). */ // determine length of the handshake message\n    var length = b.length + 2;\n    // build record fragment\n    var rval = forge.util.createBuffer();\n    rval.putByte(tls.HandshakeType.client_key_exchange);\n    rval.putInt24(length);\n    // add vector length bytes\n    rval.putInt16(b.length);\n    rval.putBytes(b);\n    return rval;\n};\n/**\n * Creates a ServerKeyExchange message.\n *\n * @param c the connection.\n *\n * @return the ServerKeyExchange byte buffer.\n */ tls.createServerKeyExchange = function(c) {\n    // this implementation only supports RSA, no Diffie-Hellman support,\n    // so this record is empty\n    // determine length of the handshake message\n    var length = 0;\n    // build record fragment\n    var rval = forge.util.createBuffer();\n    if (length > 0) {\n        rval.putByte(tls.HandshakeType.server_key_exchange);\n        rval.putInt24(length);\n    }\n    return rval;\n};\n/**\n * Gets the signed data used to verify a client-side certificate. See\n * tls.createCertificateVerify() for details.\n *\n * @param c the connection.\n * @param callback the callback to call once the signed data is ready.\n */ tls.getClientSignature = function(c, callback) {\n    // generate data to RSA encrypt\n    var b = forge.util.createBuffer();\n    b.putBuffer(c.session.md5.digest());\n    b.putBuffer(c.session.sha1.digest());\n    b = b.getBytes();\n    // create default signing function as necessary\n    c.getSignature = c.getSignature || function(c, b, callback) {\n        // do rsa encryption, call callback\n        var privateKey = null;\n        if (c.getPrivateKey) {\n            try {\n                privateKey = c.getPrivateKey(c, c.session.clientCertificate);\n                privateKey = forge.pki.privateKeyFromPem(privateKey);\n            } catch (ex) {\n                c.error(c, {\n                    message: \"Could not get private key.\",\n                    cause: ex,\n                    send: true,\n                    alert: {\n                        level: tls.Alert.Level.fatal,\n                        description: tls.Alert.Description.internal_error\n                    }\n                });\n            }\n        }\n        if (privateKey === null) {\n            c.error(c, {\n                message: \"No private key set.\",\n                send: true,\n                alert: {\n                    level: tls.Alert.Level.fatal,\n                    description: tls.Alert.Description.internal_error\n                }\n            });\n        } else {\n            b = privateKey.sign(b, null);\n        }\n        callback(c, b);\n    };\n    // get client signature\n    c.getSignature(c, b, callback);\n};\n/**\n * Creates a CertificateVerify message.\n *\n * Meaning of this message:\n *   This structure conveys the client's Diffie-Hellman public value\n *   (Yc) if it was not already included in the client's certificate.\n *   The encoding used for Yc is determined by the enumerated\n *   PublicValueEncoding. This structure is a variant of the client\n *   key exchange message, not a message in itself.\n *\n * When this message will be sent:\n *   This message is used to provide explicit verification of a client\n *   certificate. This message is only sent following a client\n *   certificate that has signing capability (i.e. all certificates\n *   except those containing fixed Diffie-Hellman parameters). When\n *   sent, it will immediately follow the client key exchange message.\n *\n * struct {\n *   Signature signature;\n * } CertificateVerify;\n *\n * CertificateVerify.signature.md5_hash\n *   MD5(handshake_messages);\n *\n * Certificate.signature.sha_hash\n *   SHA(handshake_messages);\n *\n * Here handshake_messages refers to all handshake messages sent or\n * received starting at client hello up to but not including this\n * message, including the type and length fields of the handshake\n * messages.\n *\n * select(SignatureAlgorithm) {\n *   case anonymous: struct { };\n *   case rsa:\n *     digitally-signed struct {\n *       opaque md5_hash[16];\n *       opaque sha_hash[20];\n *     };\n *   case dsa:\n *     digitally-signed struct {\n *       opaque sha_hash[20];\n *     };\n * } Signature;\n *\n * In digital signing, one-way hash functions are used as input for a\n * signing algorithm. A digitally-signed element is encoded as an opaque\n * vector <0..2^16-1>, where the length is specified by the signing\n * algorithm and key.\n *\n * In RSA signing, a 36-byte structure of two hashes (one SHA and one\n * MD5) is signed (encrypted with the private key). It is encoded with\n * PKCS #1 block type 0 or type 1 as described in [PKCS1].\n *\n * In DSS, the 20 bytes of the SHA hash are run directly through the\n * Digital Signing Algorithm with no additional hashing.\n *\n * @param c the connection.\n * @param signature the signature to include in the message.\n *\n * @return the CertificateVerify byte buffer.\n */ tls.createCertificateVerify = function(c, signature) {\n    /* Note: The signature will be stored in a \"digitally-signed\" opaque\n    vector that has the length prefixed using 2 bytes, so include those\n    2 bytes in the handshake message length. This is done as a minor\n    optimization instead of calling writeVector(). */ // determine length of the handshake message\n    var length = signature.length + 2;\n    // build record fragment\n    var rval = forge.util.createBuffer();\n    rval.putByte(tls.HandshakeType.certificate_verify);\n    rval.putInt24(length);\n    // add vector length bytes\n    rval.putInt16(signature.length);\n    rval.putBytes(signature);\n    return rval;\n};\n/**\n * Creates a CertificateRequest message.\n *\n * @param c the connection.\n *\n * @return the CertificateRequest byte buffer.\n */ tls.createCertificateRequest = function(c) {\n    // TODO: support other certificate types\n    var certTypes = forge.util.createBuffer();\n    // common RSA certificate type\n    certTypes.putByte(0x01);\n    // add distinguished names from CA store\n    var cAs = forge.util.createBuffer();\n    for(var key in c.caStore.certs){\n        var cert = c.caStore.certs[key];\n        var dn = forge.pki.distinguishedNameToAsn1(cert.subject);\n        var byteBuffer = forge.asn1.toDer(dn);\n        cAs.putInt16(byteBuffer.length());\n        cAs.putBuffer(byteBuffer);\n    }\n    // TODO: TLS 1.2+ has a different format\n    // determine length of the handshake message\n    var length = 1 + certTypes.length() + 2 + cAs.length();\n    // build record fragment\n    var rval = forge.util.createBuffer();\n    rval.putByte(tls.HandshakeType.certificate_request);\n    rval.putInt24(length);\n    writeVector(rval, 1, certTypes);\n    writeVector(rval, 2, cAs);\n    return rval;\n};\n/**\n * Creates a ServerHelloDone message.\n *\n * @param c the connection.\n *\n * @return the ServerHelloDone byte buffer.\n */ tls.createServerHelloDone = function(c) {\n    // build record fragment\n    var rval = forge.util.createBuffer();\n    rval.putByte(tls.HandshakeType.server_hello_done);\n    rval.putInt24(0);\n    return rval;\n};\n/**\n * Creates a ChangeCipherSpec message.\n *\n * The change cipher spec protocol exists to signal transitions in\n * ciphering strategies. The protocol consists of a single message,\n * which is encrypted and compressed under the current (not the pending)\n * connection state. The message consists of a single byte of value 1.\n *\n * struct {\n *   enum { change_cipher_spec(1), (255) } type;\n * } ChangeCipherSpec;\n *\n * @return the ChangeCipherSpec byte buffer.\n */ tls.createChangeCipherSpec = function() {\n    var rval = forge.util.createBuffer();\n    rval.putByte(0x01);\n    return rval;\n};\n/**\n * Creates a Finished message.\n *\n * struct {\n *   opaque verify_data[12];\n * } Finished;\n *\n * verify_data\n *   PRF(master_secret, finished_label, MD5(handshake_messages) +\n *   SHA-1(handshake_messages)) [0..11];\n *\n * finished_label\n *   For Finished messages sent by the client, the string \"client\n *   finished\". For Finished messages sent by the server, the\n *   string \"server finished\".\n *\n * handshake_messages\n *   All of the data from all handshake messages up to but not\n *   including this message. This is only data visible at the\n *   handshake layer and does not include record layer headers.\n *   This is the concatenation of all the Handshake structures as\n *   defined in 7.4 exchanged thus far.\n *\n * @param c the connection.\n *\n * @return the Finished byte buffer.\n */ tls.createFinished = function(c) {\n    // generate verify_data\n    var b = forge.util.createBuffer();\n    b.putBuffer(c.session.md5.digest());\n    b.putBuffer(c.session.sha1.digest());\n    // TODO: determine prf function and verify length for TLS 1.2\n    var client = c.entity === tls.ConnectionEnd.client;\n    var sp = c.session.sp;\n    var vdl = 12;\n    var prf = prf_TLS1;\n    var label = client ? \"client finished\" : \"server finished\";\n    b = prf(sp.master_secret, label, b.getBytes(), vdl);\n    // build record fragment\n    var rval = forge.util.createBuffer();\n    rval.putByte(tls.HandshakeType.finished);\n    rval.putInt24(b.length());\n    rval.putBuffer(b);\n    return rval;\n};\n/**\n * Creates a HeartbeatMessage (See RFC 6520).\n *\n * struct {\n *   HeartbeatMessageType type;\n *   uint16 payload_length;\n *   opaque payload[HeartbeatMessage.payload_length];\n *   opaque padding[padding_length];\n * } HeartbeatMessage;\n *\n * The total length of a HeartbeatMessage MUST NOT exceed 2^14 or\n * max_fragment_length when negotiated as defined in [RFC6066].\n *\n * type: The message type, either heartbeat_request or heartbeat_response.\n *\n * payload_length: The length of the payload.\n *\n * payload: The payload consists of arbitrary content.\n *\n * padding: The padding is random content that MUST be ignored by the\n *   receiver. The length of a HeartbeatMessage is TLSPlaintext.length\n *   for TLS and DTLSPlaintext.length for DTLS. Furthermore, the\n *   length of the type field is 1 byte, and the length of the\n *   payload_length is 2. Therefore, the padding_length is\n *   TLSPlaintext.length - payload_length - 3 for TLS and\n *   DTLSPlaintext.length - payload_length - 3 for DTLS. The\n *   padding_length MUST be at least 16.\n *\n * The sender of a HeartbeatMessage MUST use a random padding of at\n * least 16 bytes. The padding of a received HeartbeatMessage message\n * MUST be ignored.\n *\n * If the payload_length of a received HeartbeatMessage is too large,\n * the received HeartbeatMessage MUST be discarded silently.\n *\n * @param c the connection.\n * @param type the tls.HeartbeatMessageType.\n * @param payload the heartbeat data to send as the payload.\n * @param [payloadLength] the payload length to use, defaults to the\n *          actual payload length.\n *\n * @return the HeartbeatRequest byte buffer.\n */ tls.createHeartbeat = function(type, payload, payloadLength) {\n    if (typeof payloadLength === \"undefined\") {\n        payloadLength = payload.length;\n    }\n    // build record fragment\n    var rval = forge.util.createBuffer();\n    rval.putByte(type); // heartbeat message type\n    rval.putInt16(payloadLength); // payload length\n    rval.putBytes(payload); // payload\n    // padding\n    var plaintextLength = rval.length();\n    var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);\n    rval.putBytes(forge.random.getBytes(paddingLength));\n    return rval;\n};\n/**\n * Fragments, compresses, encrypts, and queues a record for delivery.\n *\n * @param c the connection.\n * @param record the record to queue.\n */ tls.queue = function(c, record) {\n    // error during record creation\n    if (!record) {\n        return;\n    }\n    if (record.fragment.length() === 0) {\n        if (record.type === tls.ContentType.handshake || record.type === tls.ContentType.alert || record.type === tls.ContentType.change_cipher_spec) {\n            // Empty handshake, alert of change cipher spec messages are not allowed per the TLS specification and should not be sent.\n            return;\n        }\n    }\n    // if the record is a handshake record, update handshake hashes\n    if (record.type === tls.ContentType.handshake) {\n        var bytes = record.fragment.bytes();\n        c.session.md5.update(bytes);\n        c.session.sha1.update(bytes);\n        bytes = null;\n    }\n    // handle record fragmentation\n    var records;\n    if (record.fragment.length() <= tls.MaxFragment) {\n        records = [\n            record\n        ];\n    } else {\n        // fragment data as long as it is too long\n        records = [];\n        var data = record.fragment.bytes();\n        while(data.length > tls.MaxFragment){\n            records.push(tls.createRecord(c, {\n                type: record.type,\n                data: forge.util.createBuffer(data.slice(0, tls.MaxFragment))\n            }));\n            data = data.slice(tls.MaxFragment);\n        }\n        // add last record\n        if (data.length > 0) {\n            records.push(tls.createRecord(c, {\n                type: record.type,\n                data: forge.util.createBuffer(data)\n            }));\n        }\n    }\n    // compress and encrypt all fragmented records\n    for(var i = 0; i < records.length && !c.fail; ++i){\n        // update the record using current write state\n        var rec = records[i];\n        var s = c.state.current.write;\n        if (s.update(c, rec)) {\n            // store record\n            c.records.push(rec);\n        }\n    }\n};\n/**\n * Flushes all queued records to the output buffer and calls the\n * tlsDataReady() handler on the given connection.\n *\n * @param c the connection.\n *\n * @return true on success, false on failure.\n */ tls.flush = function(c) {\n    for(var i = 0; i < c.records.length; ++i){\n        var record = c.records[i];\n        // add record header and fragment\n        c.tlsData.putByte(record.type);\n        c.tlsData.putByte(record.version.major);\n        c.tlsData.putByte(record.version.minor);\n        c.tlsData.putInt16(record.fragment.length());\n        c.tlsData.putBuffer(c.records[i].fragment);\n    }\n    c.records = [];\n    return c.tlsDataReady(c);\n};\n/**\n * Maps a pki.certificateError to a tls.Alert.Description.\n *\n * @param error the error to map.\n *\n * @return the alert description.\n */ var _certErrorToAlertDesc = function(error) {\n    switch(error){\n        case true:\n            return true;\n        case forge.pki.certificateError.bad_certificate:\n            return tls.Alert.Description.bad_certificate;\n        case forge.pki.certificateError.unsupported_certificate:\n            return tls.Alert.Description.unsupported_certificate;\n        case forge.pki.certificateError.certificate_revoked:\n            return tls.Alert.Description.certificate_revoked;\n        case forge.pki.certificateError.certificate_expired:\n            return tls.Alert.Description.certificate_expired;\n        case forge.pki.certificateError.certificate_unknown:\n            return tls.Alert.Description.certificate_unknown;\n        case forge.pki.certificateError.unknown_ca:\n            return tls.Alert.Description.unknown_ca;\n        default:\n            return tls.Alert.Description.bad_certificate;\n    }\n};\n/**\n * Maps a tls.Alert.Description to a pki.certificateError.\n *\n * @param desc the alert description.\n *\n * @return the certificate error.\n */ var _alertDescToCertError = function(desc) {\n    switch(desc){\n        case true:\n            return true;\n        case tls.Alert.Description.bad_certificate:\n            return forge.pki.certificateError.bad_certificate;\n        case tls.Alert.Description.unsupported_certificate:\n            return forge.pki.certificateError.unsupported_certificate;\n        case tls.Alert.Description.certificate_revoked:\n            return forge.pki.certificateError.certificate_revoked;\n        case tls.Alert.Description.certificate_expired:\n            return forge.pki.certificateError.certificate_expired;\n        case tls.Alert.Description.certificate_unknown:\n            return forge.pki.certificateError.certificate_unknown;\n        case tls.Alert.Description.unknown_ca:\n            return forge.pki.certificateError.unknown_ca;\n        default:\n            return forge.pki.certificateError.bad_certificate;\n    }\n};\n/**\n * Verifies a certificate chain against the given connection's\n * Certificate Authority store.\n *\n * @param c the TLS connection.\n * @param chain the certificate chain to verify, with the root or highest\n *          authority at the end.\n *\n * @return true if successful, false if not.\n */ tls.verifyCertificateChain = function(c, chain) {\n    try {\n        // Make a copy of c.verifyOptions so that we can modify options.verify\n        // without modifying c.verifyOptions.\n        var options = {};\n        for(var key in c.verifyOptions){\n            options[key] = c.verifyOptions[key];\n        }\n        options.verify = function(vfd, depth, chain) {\n            // convert pki.certificateError to tls alert description\n            var desc = _certErrorToAlertDesc(vfd);\n            // call application callback\n            var ret = c.verify(c, vfd, depth, chain);\n            if (ret !== true) {\n                if (typeof ret === \"object\" && !forge.util.isArray(ret)) {\n                    // throw custom error\n                    var error = new Error(\"The application rejected the certificate.\");\n                    error.send = true;\n                    error.alert = {\n                        level: tls.Alert.Level.fatal,\n                        description: tls.Alert.Description.bad_certificate\n                    };\n                    if (ret.message) {\n                        error.message = ret.message;\n                    }\n                    if (ret.alert) {\n                        error.alert.description = ret.alert;\n                    }\n                    throw error;\n                }\n                // convert tls alert description to pki.certificateError\n                if (ret !== vfd) {\n                    ret = _alertDescToCertError(ret);\n                }\n            }\n            return ret;\n        };\n        // verify chain\n        forge.pki.verifyCertificateChain(c.caStore, chain, options);\n    } catch (ex) {\n        // build tls error if not already customized\n        var err = ex;\n        if (typeof err !== \"object\" || forge.util.isArray(err)) {\n            err = {\n                send: true,\n                alert: {\n                    level: tls.Alert.Level.fatal,\n                    description: _certErrorToAlertDesc(ex)\n                }\n            };\n        }\n        if (!(\"send\" in err)) {\n            err.send = true;\n        }\n        if (!(\"alert\" in err)) {\n            err.alert = {\n                level: tls.Alert.Level.fatal,\n                description: _certErrorToAlertDesc(err.error)\n            };\n        }\n        // send error\n        c.error(c, err);\n    }\n    return !c.fail;\n};\n/**\n * Creates a new TLS session cache.\n *\n * @param cache optional map of session ID to cached session.\n * @param capacity the maximum size for the cache (default: 100).\n *\n * @return the new TLS session cache.\n */ tls.createSessionCache = function(cache, capacity) {\n    var rval = null;\n    // assume input is already a session cache object\n    if (cache && cache.getSession && cache.setSession && cache.order) {\n        rval = cache;\n    } else {\n        // create cache\n        rval = {};\n        rval.cache = cache || {};\n        rval.capacity = Math.max(capacity || 100, 1);\n        rval.order = [];\n        // store order for sessions, delete session overflow\n        for(var key in cache){\n            if (rval.order.length <= capacity) {\n                rval.order.push(key);\n            } else {\n                delete cache[key];\n            }\n        }\n        // get a session from a session ID (or get any session)\n        rval.getSession = function(sessionId) {\n            var session = null;\n            var key = null;\n            // if session ID provided, use it\n            if (sessionId) {\n                key = forge.util.bytesToHex(sessionId);\n            } else if (rval.order.length > 0) {\n                // get first session from cache\n                key = rval.order[0];\n            }\n            if (key !== null && key in rval.cache) {\n                // get cached session and remove from cache\n                session = rval.cache[key];\n                delete rval.cache[key];\n                for(var i in rval.order){\n                    if (rval.order[i] === key) {\n                        rval.order.splice(i, 1);\n                        break;\n                    }\n                }\n            }\n            return session;\n        };\n        // set a session in the cache\n        rval.setSession = function(sessionId, session) {\n            // remove session from cache if at capacity\n            if (rval.order.length === rval.capacity) {\n                var key = rval.order.shift();\n                delete rval.cache[key];\n            }\n            // add session to cache\n            var key = forge.util.bytesToHex(sessionId);\n            rval.order.push(key);\n            rval.cache[key] = session;\n        };\n    }\n    return rval;\n};\n/**\n * Creates a new TLS connection.\n *\n * See public createConnection() docs for more details.\n *\n * @param options the options for this connection.\n *\n * @return the new TLS connection.\n */ tls.createConnection = function(options) {\n    var caStore = null;\n    if (options.caStore) {\n        // if CA store is an array, convert it to a CA store object\n        if (forge.util.isArray(options.caStore)) {\n            caStore = forge.pki.createCaStore(options.caStore);\n        } else {\n            caStore = options.caStore;\n        }\n    } else {\n        // create empty CA store\n        caStore = forge.pki.createCaStore();\n    }\n    // setup default cipher suites\n    var cipherSuites = options.cipherSuites || null;\n    if (cipherSuites === null) {\n        cipherSuites = [];\n        for(var key in tls.CipherSuites){\n            cipherSuites.push(tls.CipherSuites[key]);\n        }\n    }\n    // set default entity\n    var entity = options.server || false ? tls.ConnectionEnd.server : tls.ConnectionEnd.client;\n    // create session cache if requested\n    var sessionCache = options.sessionCache ? tls.createSessionCache(options.sessionCache) : null;\n    // create TLS connection\n    var c = {\n        version: {\n            major: tls.Version.major,\n            minor: tls.Version.minor\n        },\n        entity: entity,\n        sessionId: options.sessionId,\n        caStore: caStore,\n        sessionCache: sessionCache,\n        cipherSuites: cipherSuites,\n        connected: options.connected,\n        virtualHost: options.virtualHost || null,\n        verifyClient: options.verifyClient || false,\n        verify: options.verify || function(cn, vfd, dpth, cts) {\n            return vfd;\n        },\n        verifyOptions: options.verifyOptions || {},\n        getCertificate: options.getCertificate || null,\n        getPrivateKey: options.getPrivateKey || null,\n        getSignature: options.getSignature || null,\n        input: forge.util.createBuffer(),\n        tlsData: forge.util.createBuffer(),\n        data: forge.util.createBuffer(),\n        tlsDataReady: options.tlsDataReady,\n        dataReady: options.dataReady,\n        heartbeatReceived: options.heartbeatReceived,\n        closed: options.closed,\n        error: function(c, ex) {\n            // set origin if not set\n            ex.origin = ex.origin || (c.entity === tls.ConnectionEnd.client ? \"client\" : \"server\");\n            // send TLS alert\n            if (ex.send) {\n                tls.queue(c, tls.createAlert(c, ex.alert));\n                tls.flush(c);\n            }\n            // error is fatal by default\n            var fatal = ex.fatal !== false;\n            if (fatal) {\n                // set fail flag\n                c.fail = true;\n            }\n            // call error handler first\n            options.error(c, ex);\n            if (fatal) {\n                // fatal error, close connection, do not clear fail\n                c.close(false);\n            }\n        },\n        deflate: options.deflate || null,\n        inflate: options.inflate || null\n    };\n    /**\n   * Resets a closed TLS connection for reuse. Called in c.close().\n   *\n   * @param clearFail true to clear the fail flag (default: true).\n   */ c.reset = function(clearFail) {\n        c.version = {\n            major: tls.Version.major,\n            minor: tls.Version.minor\n        };\n        c.record = null;\n        c.session = null;\n        c.peerCertificate = null;\n        c.state = {\n            pending: null,\n            current: null\n        };\n        c.expect = c.entity === tls.ConnectionEnd.client ? SHE : CHE;\n        c.fragmented = null;\n        c.records = [];\n        c.open = false;\n        c.handshakes = 0;\n        c.handshaking = false;\n        c.isConnected = false;\n        c.fail = !(clearFail || typeof clearFail === \"undefined\");\n        c.input.clear();\n        c.tlsData.clear();\n        c.data.clear();\n        c.state.current = tls.createConnectionState(c);\n    };\n    // do initial reset of connection\n    c.reset();\n    /**\n   * Updates the current TLS engine state based on the given record.\n   *\n   * @param c the TLS connection.\n   * @param record the TLS record to act on.\n   */ var _update = function(c, record) {\n        // get record handler (align type in table by subtracting lowest)\n        var aligned = record.type - tls.ContentType.change_cipher_spec;\n        var handlers = ctTable[c.entity][c.expect];\n        if (aligned in handlers) {\n            handlers[aligned](c, record);\n        } else {\n            // unexpected record\n            tls.handleUnexpected(c, record);\n        }\n    };\n    /**\n   * Reads the record header and initializes the next record on the given\n   * connection.\n   *\n   * @param c the TLS connection with the next record.\n   *\n   * @return 0 if the input data could be processed, otherwise the\n   *         number of bytes required for data to be processed.\n   */ var _readRecordHeader = function(c) {\n        var rval = 0;\n        // get input buffer and its length\n        var b = c.input;\n        var len = b.length();\n        // need at least 5 bytes to initialize a record\n        if (len < 5) {\n            rval = 5 - len;\n        } else {\n            // enough bytes for header\n            // initialize record\n            c.record = {\n                type: b.getByte(),\n                version: {\n                    major: b.getByte(),\n                    minor: b.getByte()\n                },\n                length: b.getInt16(),\n                fragment: forge.util.createBuffer(),\n                ready: false\n            };\n            // check record version\n            var compatibleVersion = c.record.version.major === c.version.major;\n            if (compatibleVersion && c.session && c.session.version) {\n                // session version already set, require same minor version\n                compatibleVersion = c.record.version.minor === c.version.minor;\n            }\n            if (!compatibleVersion) {\n                c.error(c, {\n                    message: \"Incompatible TLS version.\",\n                    send: true,\n                    alert: {\n                        level: tls.Alert.Level.fatal,\n                        description: tls.Alert.Description.protocol_version\n                    }\n                });\n            }\n        }\n        return rval;\n    };\n    /**\n   * Reads the next record's contents and appends its message to any\n   * previously fragmented message.\n   *\n   * @param c the TLS connection with the next record.\n   *\n   * @return 0 if the input data could be processed, otherwise the\n   *         number of bytes required for data to be processed.\n   */ var _readRecord = function(c) {\n        var rval = 0;\n        // ensure there is enough input data to get the entire record\n        var b = c.input;\n        var len = b.length();\n        if (len < c.record.length) {\n            // not enough data yet, return how much is required\n            rval = c.record.length - len;\n        } else {\n            // there is enough data to parse the pending record\n            // fill record fragment and compact input buffer\n            c.record.fragment.putBytes(b.getBytes(c.record.length));\n            b.compact();\n            // update record using current read state\n            var s = c.state.current.read;\n            if (s.update(c, c.record)) {\n                // see if there is a previously fragmented message that the\n                // new record's message fragment should be appended to\n                if (c.fragmented !== null) {\n                    // if the record type matches a previously fragmented\n                    // record, append the record fragment to it\n                    if (c.fragmented.type === c.record.type) {\n                        // concatenate record fragments\n                        c.fragmented.fragment.putBuffer(c.record.fragment);\n                        c.record = c.fragmented;\n                    } else {\n                        // error, invalid fragmented record\n                        c.error(c, {\n                            message: \"Invalid fragmented record.\",\n                            send: true,\n                            alert: {\n                                level: tls.Alert.Level.fatal,\n                                description: tls.Alert.Description.unexpected_message\n                            }\n                        });\n                    }\n                }\n                // record is now ready\n                c.record.ready = true;\n            }\n        }\n        return rval;\n    };\n    /**\n   * Performs a handshake using the TLS Handshake Protocol, as a client.\n   *\n   * This method should only be called if the connection is in client mode.\n   *\n   * @param sessionId the session ID to use, null to start a new one.\n   */ c.handshake = function(sessionId) {\n        // error to call this in non-client mode\n        if (c.entity !== tls.ConnectionEnd.client) {\n            // not fatal error\n            c.error(c, {\n                message: \"Cannot initiate handshake as a server.\",\n                fatal: false\n            });\n        } else if (c.handshaking) {\n            // handshake is already in progress, fail but not fatal error\n            c.error(c, {\n                message: \"Handshake already in progress.\",\n                fatal: false\n            });\n        } else {\n            // clear fail flag on reuse\n            if (c.fail && !c.open && c.handshakes === 0) {\n                c.fail = false;\n            }\n            // now handshaking\n            c.handshaking = true;\n            // default to blank (new session)\n            sessionId = sessionId || \"\";\n            // if a session ID was specified, try to find it in the cache\n            var session = null;\n            if (sessionId.length > 0) {\n                if (c.sessionCache) {\n                    session = c.sessionCache.getSession(sessionId);\n                }\n                // matching session not found in cache, clear session ID\n                if (session === null) {\n                    sessionId = \"\";\n                }\n            }\n            // no session given, grab a session from the cache, if available\n            if (sessionId.length === 0 && c.sessionCache) {\n                session = c.sessionCache.getSession();\n                if (session !== null) {\n                    sessionId = session.id;\n                }\n            }\n            // set up session\n            c.session = {\n                id: sessionId,\n                version: null,\n                cipherSuite: null,\n                compressionMethod: null,\n                serverCertificate: null,\n                certificateRequest: null,\n                clientCertificate: null,\n                sp: {},\n                md5: forge.md.md5.create(),\n                sha1: forge.md.sha1.create()\n            };\n            // use existing session information\n            if (session) {\n                // only update version on connection, session version not yet set\n                c.version = session.version;\n                c.session.sp = session.sp;\n            }\n            // generate new client random\n            c.session.sp.client_random = tls.createRandom().getBytes();\n            // connection now open\n            c.open = true;\n            // send hello\n            tls.queue(c, tls.createRecord(c, {\n                type: tls.ContentType.handshake,\n                data: tls.createClientHello(c)\n            }));\n            tls.flush(c);\n        }\n    };\n    /**\n   * Called when TLS protocol data has been received from somewhere and should\n   * be processed by the TLS engine.\n   *\n   * @param data the TLS protocol data, as a string, to process.\n   *\n   * @return 0 if the data could be processed, otherwise the number of bytes\n   *         required for data to be processed.\n   */ c.process = function(data) {\n        var rval = 0;\n        // buffer input data\n        if (data) {\n            c.input.putBytes(data);\n        }\n        // process next record if no failure, process will be called after\n        // each record is handled (since handling can be asynchronous)\n        if (!c.fail) {\n            // reset record if ready and now empty\n            if (c.record !== null && c.record.ready && c.record.fragment.isEmpty()) {\n                c.record = null;\n            }\n            // if there is no pending record, try to read record header\n            if (c.record === null) {\n                rval = _readRecordHeader(c);\n            }\n            // read the next record (if record not yet ready)\n            if (!c.fail && c.record !== null && !c.record.ready) {\n                rval = _readRecord(c);\n            }\n            // record ready to be handled, update engine state\n            if (!c.fail && c.record !== null && c.record.ready) {\n                _update(c, c.record);\n            }\n        }\n        return rval;\n    };\n    /**\n   * Requests that application data be packaged into a TLS record. The\n   * tlsDataReady handler will be called when the TLS record(s) have been\n   * prepared.\n   *\n   * @param data the application data, as a raw 'binary' encoded string, to\n   *          be sent; to send utf-16/utf-8 string data, use the return value\n   *          of util.encodeUtf8(str).\n   *\n   * @return true on success, false on failure.\n   */ c.prepare = function(data) {\n        tls.queue(c, tls.createRecord(c, {\n            type: tls.ContentType.application_data,\n            data: forge.util.createBuffer(data)\n        }));\n        return tls.flush(c);\n    };\n    /**\n   * Requests that a heartbeat request be packaged into a TLS record for\n   * transmission. The tlsDataReady handler will be called when TLS record(s)\n   * have been prepared.\n   *\n   * When a heartbeat response has been received, the heartbeatReceived\n   * handler will be called with the matching payload. This handler can\n   * be used to clear a retransmission timer, etc.\n   *\n   * @param payload the heartbeat data to send as the payload in the message.\n   * @param [payloadLength] the payload length to use, defaults to the\n   *          actual payload length.\n   *\n   * @return true on success, false on failure.\n   */ c.prepareHeartbeatRequest = function(payload, payloadLength) {\n        if (payload instanceof forge.util.ByteBuffer) {\n            payload = payload.bytes();\n        }\n        if (typeof payloadLength === \"undefined\") {\n            payloadLength = payload.length;\n        }\n        c.expectedHeartbeatPayload = payload;\n        tls.queue(c, tls.createRecord(c, {\n            type: tls.ContentType.heartbeat,\n            data: tls.createHeartbeat(tls.HeartbeatMessageType.heartbeat_request, payload, payloadLength)\n        }));\n        return tls.flush(c);\n    };\n    /**\n   * Closes the connection (sends a close_notify alert).\n   *\n   * @param clearFail true to clear the fail flag (default: true).\n   */ c.close = function(clearFail) {\n        // save session if connection didn't fail\n        if (!c.fail && c.sessionCache && c.session) {\n            // only need to preserve session ID, version, and security params\n            var session = {\n                id: c.session.id,\n                version: c.session.version,\n                sp: c.session.sp\n            };\n            session.sp.keys = null;\n            c.sessionCache.setSession(session.id, session);\n        }\n        if (c.open) {\n            // connection no longer open, clear input\n            c.open = false;\n            c.input.clear();\n            // if connected or handshaking, send an alert\n            if (c.isConnected || c.handshaking) {\n                c.isConnected = c.handshaking = false;\n                // send close_notify alert\n                tls.queue(c, tls.createAlert(c, {\n                    level: tls.Alert.Level.warning,\n                    description: tls.Alert.Description.close_notify\n                }));\n                tls.flush(c);\n            }\n            // call handler\n            c.closed(c);\n        }\n        // reset TLS connection, do not clear fail flag\n        c.reset(clearFail);\n    };\n    return c;\n};\n/* TLS API */ module.exports = forge.tls = forge.tls || {};\n// expose non-functions\nfor(var key in tls){\n    if (typeof tls[key] !== \"function\") {\n        forge.tls[key] = tls[key];\n    }\n}\n// expose prf_tls1 for testing\nforge.tls.prf_tls1 = prf_TLS1;\n// expose sha1 hmac method\nforge.tls.hmac_sha1 = hmac_sha1;\n// expose session cache creation\nforge.tls.createSessionCache = tls.createSessionCache;\n/**\n * Creates a new TLS connection. This does not make any assumptions about the\n * transport layer that TLS is working on top of, ie: it does not assume there\n * is a TCP/IP connection or establish one. A TLS connection is totally\n * abstracted away from the layer is runs on top of, it merely establishes a\n * secure channel between a client\" and a \"server\".\n *\n * A TLS connection contains 4 connection states: pending read and write, and\n * current read and write.\n *\n * At initialization, the current read and write states will be null. Only once\n * the security parameters have been set and the keys have been generated can\n * the pending states be converted into current states. Current states will be\n * updated for each record processed.\n *\n * A custom certificate verify callback may be provided to check information\n * like the common name on the server's certificate. It will be called for\n * every certificate in the chain. It has the following signature:\n *\n * variable func(c, certs, index, preVerify)\n * Where:\n * c         The TLS connection\n * verified  Set to true if certificate was verified, otherwise the alert\n *           tls.Alert.Description for why the certificate failed.\n * depth     The current index in the chain, where 0 is the server's cert.\n * certs     The certificate chain, *NOTE* if the server was anonymous then\n *           the chain will be empty.\n *\n * The function returns true on success and on failure either the appropriate\n * tls.Alert.Description or an object with 'alert' set to the appropriate\n * tls.Alert.Description and 'message' set to a custom error message. If true\n * is not returned then the connection will abort using, in order of\n * availability, first the returned alert description, second the preVerify\n * alert description, and lastly the default 'bad_certificate'.\n *\n * There are three callbacks that can be used to make use of client-side\n * certificates where each takes the TLS connection as the first parameter:\n *\n * getCertificate(conn, hint)\n *   The second parameter is a hint as to which certificate should be\n *   returned. If the connection entity is a client, then the hint will be\n *   the CertificateRequest message from the server that is part of the\n *   TLS protocol. If the connection entity is a server, then it will be\n *   the servername list provided via an SNI extension the ClientHello, if\n *   one was provided (empty array if not). The hint can be examined to\n *   determine which certificate to use (advanced). Most implementations\n *   will just return a certificate. The return value must be a\n *   PEM-formatted certificate or an array of PEM-formatted certificates\n *   that constitute a certificate chain, with the first in the array/chain\n *   being the client's certificate.\n * getPrivateKey(conn, certificate)\n *   The second parameter is an forge.pki X.509 certificate object that\n *   is associated with the requested private key. The return value must\n *   be a PEM-formatted private key.\n * getSignature(conn, bytes, callback)\n *   This callback can be used instead of getPrivateKey if the private key\n *   is not directly accessible in javascript or should not be. For\n *   instance, a secure external web service could provide the signature\n *   in exchange for appropriate credentials. The second parameter is a\n *   string of bytes to be signed that are part of the TLS protocol. These\n *   bytes are used to verify that the private key for the previously\n *   provided client-side certificate is accessible to the client. The\n *   callback is a function that takes 2 parameters, the TLS connection\n *   and the RSA encrypted (signed) bytes as a string. This callback must\n *   be called once the signature is ready.\n *\n * @param options the options for this connection:\n *   server: true if the connection is server-side, false for client.\n *   sessionId: a session ID to reuse, null for a new connection.\n *   caStore: an array of certificates to trust.\n *   sessionCache: a session cache to use.\n *   cipherSuites: an optional array of cipher suites to use,\n *     see tls.CipherSuites.\n *   connected: function(conn) called when the first handshake completes.\n *   virtualHost: the virtual server name to use in a TLS SNI extension.\n *   verifyClient: true to require a client certificate in server mode,\n *     'optional' to request one, false not to (default: false).\n *   verify: a handler used to custom verify certificates in the chain.\n *   verifyOptions: an object with options for the certificate chain validation.\n *     See documentation of pki.verifyCertificateChain for possible options.\n *     verifyOptions.verify is ignored. If you wish to specify a verify handler\n *     use the verify key.\n *   getCertificate: an optional callback used to get a certificate or\n *     a chain of certificates (as an array).\n *   getPrivateKey: an optional callback used to get a private key.\n *   getSignature: an optional callback used to get a signature.\n *   tlsDataReady: function(conn) called when TLS protocol data has been\n *     prepared and is ready to be used (typically sent over a socket\n *     connection to its destination), read from conn.tlsData buffer.\n *   dataReady: function(conn) called when application data has\n *     been parsed from a TLS record and should be consumed by the\n *     application, read from conn.data buffer.\n *   closed: function(conn) called when the connection has been closed.\n *   error: function(conn, error) called when there was an error.\n *   deflate: function(inBytes) if provided, will deflate TLS records using\n *     the deflate algorithm if the server supports it.\n *   inflate: function(inBytes) if provided, will inflate TLS records using\n *     the deflate algorithm if the server supports it.\n *\n * @return the new TLS connection.\n */ forge.tls.createConnection = tls.createConnection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvdGxzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1T0M7QUFDRCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQThDQyxHQUNELElBQUlDLFdBQVcsU0FBU0MsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsTUFBTTtJQUNqRCxJQUFJQyxPQUFPUCxNQUFNUSxJQUFJLENBQUNDLFlBQVk7SUFFbEM7OztrREFHZ0QsR0FDaEQsSUFBSUMsTUFBT1AsT0FBT0csTUFBTSxJQUFJO0lBQzVCLElBQUlLLE9BQU9ELE1BQU9QLENBQUFBLE9BQU9HLE1BQU0sR0FBRztJQUNsQyxJQUFJTSxLQUFLVCxPQUFPVSxNQUFNLENBQUMsR0FBR0Y7SUFDMUIsSUFBSUcsS0FBS1gsT0FBT1UsTUFBTSxDQUFDSCxLQUFLQztJQUM1QixJQUFJSSxLQUFLZixNQUFNUSxJQUFJLENBQUNDLFlBQVk7SUFDaEMsSUFBSU8sT0FBT2hCLE1BQU1nQixJQUFJLENBQUND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QWM7QUFDM0IsSUFBSWMsVUFBVSxFQUFFO0FBQ2hCQSxPQUFPLENBQUN4TyxJQUFJUSxhQUFhLENBQUNFLE1BQU0sQ0FBQyxHQUFHO0lBQ3BDLHNFQUFzRTtJQUN0RSxLQUFLLEdBQUU7UUFBQzBPO1FBQUdBO1FBQUdRO1FBQUdSO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO0tBQUc7SUFDdkUsS0FBSyxHQUFFO1FBQUNPO1FBQUdQO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdTO1FBQUdDO1FBQUdDO1FBQUdDO1FBQUdaO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO0tBQUc7SUFDdkUsS0FBSyxHQUFFO1FBQUNPO1FBQUdQO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdVO1FBQUdDO1FBQUdDO1FBQUdaO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO0tBQUc7SUFDdkUsS0FBSyxHQUFFO1FBQUNPO1FBQUdQO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdXO1FBQUdDO1FBQUdaO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO0tBQUc7SUFDdkUsS0FBSyxHQUFFO1FBQUNPO1FBQUdQO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdZO1FBQUdaO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO0tBQUc7SUFDdkUsS0FBSyxHQUFFO1FBQUNPO1FBQUdQO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO0tBQUc7SUFDdkUsS0FBSyxHQUFFO1FBQUNPO1FBQUdQO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdhO0tBQUc7SUFDdkUsS0FBSyxHQUFFO1FBQUNOO1FBQUdQO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO0tBQUc7SUFDdkUsS0FBSyxHQUFFO1FBQUNPO1FBQUdQO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO0tBQUc7Q0FDdEU7QUFFRCxpRUFBaUU7QUFDakUsc0VBQXNFO0FBQ3RFLElBQUljLEtBQUtsUSxJQUFJcUosaUJBQWlCO0FBQzlCLElBQUk4RyxLQUFLblEsSUFBSXlMLHVCQUF1QjtBQUNwQyxJQUFJMkUsS0FBS3BRLElBQUlzTSx1QkFBdUI7QUFDcENrQyxPQUFPLENBQUN4TyxJQUFJUSxhQUFhLENBQUNDLE1BQU0sQ0FBQyxHQUFHO0lBQ3BDLHNFQUFzRTtJQUN0RSxLQUFLLEdBQUU7UUFBQzJPO1FBQUdjO1FBQUdkO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO0tBQUc7SUFDdkUsS0FBSyxHQUFFO1FBQUNBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdTO1FBQUdUO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO0tBQUc7SUFDdkUsS0FBSyxHQUFFO1FBQUNBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdlO1FBQUdmO1FBQUdBO1FBQUdBO1FBQUdBO0tBQUc7SUFDdkUsS0FBSyxHQUFFO1FBQUNBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdBO1FBQUdnQjtRQUFHaEI7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7S0FBRztJQUN2RSxLQUFLLEdBQUU7UUFBQ0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7S0FBRztJQUN2RSxLQUFLLEdBQUU7UUFBQ0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR2E7S0FBRztJQUN2RSxLQUFLLEdBQUU7UUFBQ2I7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7S0FBRztJQUN2RSxLQUFLLEdBQUU7UUFBQ0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7UUFBR0E7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Q1Q7QUFFQSxXQUFXLEdBQ1gyWCxPQUFPQyxPQUFPLEdBQUc3YSxNQUFNK0QsR0FBRyxHQUFHL0QsTUFBTStELEdBQUcsSUFBSSxDQUFDO0FBRTNDLHVCQUF1QjtBQUN2QixJQUFJLElBQUkzQixPQUFPMkIsSUFBSztJQUNsQixJQUFHLE9BQU9BLEdBQUcsQ0FBQzNCLElBQUksS0FBSyxZQUFZO1FBQ2pDcEMsTUFBTStELEdBQUcsQ0FBQzNCLElBQUksR0FBRzJCLEdBQUcsQ0FBQzNCLElBQUk7SUFDM0I7QUFDRjtBQUVBLDhCQUE4QjtBQUM5QnBDLE1BQU0rRCxHQUFHLENBQUMrVyxRQUFRLEdBQUc1YTtBQUVyQiwwQkFBMEI7QUFDMUJGLE1BQU0rRCxHQUFHLENBQUM1QixTQUFTLEdBQUdBO0FBRXRCLGdDQUFnQztBQUNoQ25DLE1BQU0rRCxHQUFHLENBQUNpVixrQkFBa0IsR0FBR2pWLElBQUlpVixrQkFBa0I7QUFFckQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvR0MsR0FDRGhaLE1BQU0rRCxHQUFHLENBQUN3VixnQkFBZ0IsR0FBR3hWLElBQUl3VixnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvdGxzLmpzPzc0M2IiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgVHJhbnNwb3J0IExheWVyIFNlY3VyaXR5IChUTFMpLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDA5LTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqXG4gKiBUaGUgVExTIEhhbmRzaGFrZSBQcm90b2NvbCBpbnZvbHZlcyB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICpcbiAqIC0gRXhjaGFuZ2UgaGVsbG8gbWVzc2FnZXMgdG8gYWdyZWUgb24gYWxnb3JpdGhtcywgZXhjaGFuZ2UgcmFuZG9tIHZhbHVlcyxcbiAqIGFuZCBjaGVjayBmb3Igc2Vzc2lvbiByZXN1bXB0aW9uLlxuICpcbiAqIC0gRXhjaGFuZ2UgdGhlIG5lY2Vzc2FyeSBjcnlwdG9ncmFwaGljIHBhcmFtZXRlcnMgdG8gYWxsb3cgdGhlIGNsaWVudCBhbmRcbiAqIHNlcnZlciB0byBhZ3JlZSBvbiBhIHByZW1hc3RlciBzZWNyZXQuXG4gKlxuICogLSBFeGNoYW5nZSBjZXJ0aWZpY2F0ZXMgYW5kIGNyeXB0b2dyYXBoaWMgaW5mb3JtYXRpb24gdG8gYWxsb3cgdGhlIGNsaWVudFxuICogYW5kIHNlcnZlciB0byBhdXRoZW50aWNhdGUgdGhlbXNlbHZlcy5cbiAqXG4gKiAtIEdlbmVyYXRlIGEgbWFzdGVyIHNlY3JldCBmcm9tIHRoZSBwcmVtYXN0ZXIgc2VjcmV0IGFuZCBleGNoYW5nZWQgcmFuZG9tXG4gKiB2YWx1ZXMuXG4gKlxuICogLSBQcm92aWRlIHNlY3VyaXR5IHBhcmFtZXRlcnMgdG8gdGhlIHJlY29yZCBsYXllci5cbiAqXG4gKiAtIEFsbG93IHRoZSBjbGllbnQgYW5kIHNlcnZlciB0byB2ZXJpZnkgdGhhdCB0aGVpciBwZWVyIGhhcyBjYWxjdWxhdGVkIHRoZVxuICogc2FtZSBzZWN1cml0eSBwYXJhbWV0ZXJzIGFuZCB0aGF0IHRoZSBoYW5kc2hha2Ugb2NjdXJyZWQgd2l0aG91dCB0YW1wZXJpbmdcbiAqIGJ5IGFuIGF0dGFja2VyLlxuICpcbiAqIFVwIHRvIDQgZGlmZmVyZW50IG1lc3NhZ2VzIG1heSBiZSBzZW50IGR1cmluZyBhIGtleSBleGNoYW5nZS4gVGhlIHNlcnZlclxuICogY2VydGlmaWNhdGUsIHRoZSBzZXJ2ZXIga2V5IGV4Y2hhbmdlLCB0aGUgY2xpZW50IGNlcnRpZmljYXRlLCBhbmQgdGhlXG4gKiBjbGllbnQga2V5IGV4Y2hhbmdlLlxuICpcbiAqIEEgdHlwaWNhbCBoYW5kc2hha2UgKGZyb20gdGhlIGNsaWVudCdzIHBlcnNwZWN0aXZlKS5cbiAqXG4gKiAxLiBDbGllbnQgc2VuZHMgQ2xpZW50SGVsbG8uXG4gKiAyLiBDbGllbnQgcmVjZWl2ZXMgU2VydmVySGVsbG8uXG4gKiAzLiBDbGllbnQgcmVjZWl2ZXMgb3B0aW9uYWwgQ2VydGlmaWNhdGUuXG4gKiA0LiBDbGllbnQgcmVjZWl2ZXMgb3B0aW9uYWwgU2VydmVyS2V5RXhjaGFuZ2UuXG4gKiA1LiBDbGllbnQgcmVjZWl2ZXMgU2VydmVySGVsbG9Eb25lLlxuICogNi4gQ2xpZW50IHNlbmRzIG9wdGlvbmFsIENlcnRpZmljYXRlLlxuICogNy4gQ2xpZW50IHNlbmRzIENsaWVudEtleUV4Y2hhbmdlLlxuICogOC4gQ2xpZW50IHNlbmRzIG9wdGlvbmFsIENlcnRpZmljYXRlVmVyaWZ5LlxuICogOS4gQ2xpZW50IHNlbmRzIENoYW5nZUNpcGhlclNwZWMuXG4gKiAxMC4gQ2xpZW50IHNlbmRzIEZpbmlzaGVkLlxuICogMTEuIENsaWVudCByZWNlaXZlcyBDaGFuZ2VDaXBoZXJTcGVjLlxuICogMTIuIENsaWVudCByZWNlaXZlcyBGaW5pc2hlZC5cbiAqIDEzLiBDbGllbnQgc2VuZHMvcmVjZWl2ZXMgYXBwbGljYXRpb24gZGF0YS5cbiAqXG4gKiBUbyByZXVzZSBhbiBleGlzdGluZyBzZXNzaW9uOlxuICpcbiAqIDEuIENsaWVudCBzZW5kcyBDbGllbnRIZWxsbyB3aXRoIHNlc3Npb24gSUQgZm9yIHJldXNlLlxuICogMi4gQ2xpZW50IHJlY2VpdmVzIFNlcnZlckhlbGxvIHdpdGggc2FtZSBzZXNzaW9uIElEIGlmIHJldXNpbmcuXG4gKiAzLiBDbGllbnQgcmVjZWl2ZXMgQ2hhbmdlQ2lwaGVyU3BlYyBtZXNzYWdlIGlmIHJldXNpbmcuXG4gKiA0LiBDbGllbnQgcmVjZWl2ZXMgRmluaXNoZWQuXG4gKiA1LiBDbGllbnQgc2VuZHMgQ2hhbmdlQ2lwaGVyU3BlYy5cbiAqIDYuIENsaWVudCBzZW5kcyBGaW5pc2hlZC5cbiAqXG4gKiBOb3RlOiBDbGllbnQgaWdub3JlcyBIZWxsb1JlcXVlc3QgaWYgaW4gdGhlIG1pZGRsZSBvZiBhIGhhbmRzaGFrZS5cbiAqXG4gKiBSZWNvcmQgTGF5ZXI6XG4gKlxuICogVGhlIHJlY29yZCBsYXllciBmcmFnbWVudHMgaW5mb3JtYXRpb24gYmxvY2tzIGludG8gVExTUGxhaW50ZXh0IHJlY29yZHNcbiAqIGNhcnJ5aW5nIGRhdGEgaW4gY2h1bmtzIG9mIDJeMTQgYnl0ZXMgb3IgbGVzcy4gQ2xpZW50IG1lc3NhZ2UgYm91bmRhcmllcyBhcmVcbiAqIG5vdCBwcmVzZXJ2ZWQgaW4gdGhlIHJlY29yZCBsYXllciAoaS5lLiwgbXVsdGlwbGUgY2xpZW50IG1lc3NhZ2VzIG9mIHRoZVxuICogc2FtZSBDb250ZW50VHlwZSBNQVkgYmUgY29hbGVzY2VkIGludG8gYSBzaW5nbGUgVExTUGxhaW50ZXh0IHJlY29yZCwgb3IgYVxuICogc2luZ2xlIG1lc3NhZ2UgTUFZIGJlIGZyYWdtZW50ZWQgYWNyb3NzIHNldmVyYWwgcmVjb3JkcykuXG4gKlxuICogc3RydWN0IHtcbiAqICAgdWludDggbWFqb3I7XG4gKiAgIHVpbnQ4IG1pbm9yO1xuICogfSBQcm90b2NvbFZlcnNpb247XG4gKlxuICogc3RydWN0IHtcbiAqICAgQ29udGVudFR5cGUgdHlwZTtcbiAqICAgUHJvdG9jb2xWZXJzaW9uIHZlcnNpb247XG4gKiAgIHVpbnQxNiBsZW5ndGg7XG4gKiAgIG9wYXF1ZSBmcmFnbWVudFtUTFNQbGFpbnRleHQubGVuZ3RoXTtcbiAqIH0gVExTUGxhaW50ZXh0O1xuICpcbiAqIHR5cGU6XG4gKiAgIFRoZSBoaWdoZXItbGV2ZWwgcHJvdG9jb2wgdXNlZCB0byBwcm9jZXNzIHRoZSBlbmNsb3NlZCBmcmFnbWVudC5cbiAqXG4gKiB2ZXJzaW9uOlxuICogICBUaGUgdmVyc2lvbiBvZiB0aGUgcHJvdG9jb2wgYmVpbmcgZW1wbG95ZWQuIFRMUyBWZXJzaW9uIDEuMiB1c2VzIHZlcnNpb25cbiAqICAgezMsIDN9LiBUTFMgVmVyc2lvbiAxLjAgdXNlcyB2ZXJzaW9uIHszLCAxfS4gTm90ZSB0aGF0IGEgY2xpZW50IHRoYXRcbiAqICAgc3VwcG9ydHMgbXVsdGlwbGUgdmVyc2lvbnMgb2YgVExTIG1heSBub3Qga25vdyB3aGF0IHZlcnNpb24gd2lsbCBiZVxuICogICBlbXBsb3llZCBiZWZvcmUgaXQgcmVjZWl2ZXMgdGhlIFNlcnZlckhlbGxvLlxuICpcbiAqIGxlbmd0aDpcbiAqICAgVGhlIGxlbmd0aCAoaW4gYnl0ZXMpIG9mIHRoZSBmb2xsb3dpbmcgVExTUGxhaW50ZXh0LmZyYWdtZW50LiBUaGUgbGVuZ3RoXG4gKiAgIE1VU1QgTk9UIGV4Y2VlZCAyXjE0ID0gMTYzODQgYnl0ZXMuXG4gKlxuICogZnJhZ21lbnQ6XG4gKiAgIFRoZSBhcHBsaWNhdGlvbiBkYXRhLiBUaGlzIGRhdGEgaXMgdHJhbnNwYXJlbnQgYW5kIHRyZWF0ZWQgYXMgYW5cbiAqICAgaW5kZXBlbmRlbnQgYmxvY2sgdG8gYmUgZGVhbHQgd2l0aCBieSB0aGUgaGlnaGVyLWxldmVsIHByb3RvY29sIHNwZWNpZmllZFxuICogICBieSB0aGUgdHlwZSBmaWVsZC5cbiAqXG4gKiBJbXBsZW1lbnRhdGlvbnMgTVVTVCBOT1Qgc2VuZCB6ZXJvLWxlbmd0aCBmcmFnbWVudHMgb2YgSGFuZHNoYWtlLCBBbGVydCwgb3JcbiAqIENoYW5nZUNpcGhlclNwZWMgY29udGVudCB0eXBlcy4gWmVyby1sZW5ndGggZnJhZ21lbnRzIG9mIEFwcGxpY2F0aW9uIGRhdGFcbiAqIE1BWSBiZSBzZW50IGFzIHRoZXkgYXJlIHBvdGVudGlhbGx5IHVzZWZ1bCBhcyBhIHRyYWZmaWMgYW5hbHlzaXNcbiAqIGNvdW50ZXJtZWFzdXJlLlxuICpcbiAqIE5vdGU6IERhdGEgb2YgZGlmZmVyZW50IFRMUyByZWNvcmQgbGF5ZXIgY29udGVudCB0eXBlcyBNQVkgYmUgaW50ZXJsZWF2ZWQuXG4gKiBBcHBsaWNhdGlvbiBkYXRhIGlzIGdlbmVyYWxseSBvZiBsb3dlciBwcmVjZWRlbmNlIGZvciB0cmFuc21pc3Npb24gdGhhblxuICogb3RoZXIgY29udGVudCB0eXBlcy4gSG93ZXZlciwgcmVjb3JkcyBNVVNUIGJlIGRlbGl2ZXJlZCB0byB0aGUgbmV0d29yayBpblxuICogdGhlIHNhbWUgb3JkZXIgYXMgdGhleSBhcmUgcHJvdGVjdGVkIGJ5IHRoZSByZWNvcmQgbGF5ZXIuIFJlY2lwaWVudHMgTVVTVFxuICogcmVjZWl2ZSBhbmQgcHJvY2VzcyBpbnRlcmxlYXZlZCBhcHBsaWNhdGlvbiBsYXllciB0cmFmZmljIGR1cmluZyBoYW5kc2hha2VzXG4gKiBzdWJzZXF1ZW50IHRvIHRoZSBmaXJzdCBvbmUgb24gYSBjb25uZWN0aW9uLlxuICpcbiAqIHN0cnVjdCB7XG4gKiAgIENvbnRlbnRUeXBlIHR5cGU7ICAgICAgIC8vIHNhbWUgYXMgVExTUGxhaW50ZXh0LnR5cGVcbiAqICAgUHJvdG9jb2xWZXJzaW9uIHZlcnNpb247Ly8gc2FtZSBhcyBUTFNQbGFpbnRleHQudmVyc2lvblxuICogICB1aW50MTYgbGVuZ3RoO1xuICogICBvcGFxdWUgZnJhZ21lbnRbVExTQ29tcHJlc3NlZC5sZW5ndGhdO1xuICogfSBUTFNDb21wcmVzc2VkO1xuICpcbiAqIGxlbmd0aDpcbiAqICAgVGhlIGxlbmd0aCAoaW4gYnl0ZXMpIG9mIHRoZSBmb2xsb3dpbmcgVExTQ29tcHJlc3NlZC5mcmFnbWVudC5cbiAqICAgVGhlIGxlbmd0aCBNVVNUIE5PVCBleGNlZWQgMl4xNCArIDEwMjQuXG4gKlxuICogZnJhZ21lbnQ6XG4gKiAgIFRoZSBjb21wcmVzc2VkIGZvcm0gb2YgVExTUGxhaW50ZXh0LmZyYWdtZW50LlxuICpcbiAqIE5vdGU6IEEgQ29tcHJlc3Npb25NZXRob2QubnVsbCBvcGVyYXRpb24gaXMgYW4gaWRlbnRpdHkgb3BlcmF0aW9uOyBubyBmaWVsZHNcbiAqIGFyZSBhbHRlcmVkLiBJbiB0aGlzIGltcGxlbWVudGF0aW9uLCBzaW5jZSBubyBjb21wcmVzc2lvbiBpcyBzdXBwb3J0ZWQsXG4gKiB1bmNvbXByZXNzZWQgcmVjb3JkcyBhcmUgYWx3YXlzIHRoZSBzYW1lIGFzIGNvbXByZXNzZWQgcmVjb3Jkcy5cbiAqXG4gKiBFbmNyeXB0aW9uIEluZm9ybWF0aW9uOlxuICpcbiAqIFRoZSBlbmNyeXB0aW9uIGFuZCBNQUMgZnVuY3Rpb25zIHRyYW5zbGF0ZSBhIFRMU0NvbXByZXNzZWQgc3RydWN0dXJlIGludG8gYVxuICogVExTQ2lwaGVydGV4dC4gVGhlIGRlY3J5cHRpb24gZnVuY3Rpb25zIHJldmVyc2UgdGhlIHByb2Nlc3MuIFRoZSBNQUMgb2YgdGhlXG4gKiByZWNvcmQgYWxzbyBpbmNsdWRlcyBhIHNlcXVlbmNlIG51bWJlciBzbyB0aGF0IG1pc3NpbmcsIGV4dHJhLCBvciByZXBlYXRlZFxuICogbWVzc2FnZXMgYXJlIGRldGVjdGFibGUuXG4gKlxuICogc3RydWN0IHtcbiAqICAgQ29udGVudFR5cGUgdHlwZTtcbiAqICAgUHJvdG9jb2xWZXJzaW9uIHZlcnNpb247XG4gKiAgIHVpbnQxNiBsZW5ndGg7XG4gKiAgIHNlbGVjdCAoU2VjdXJpdHlQYXJhbWV0ZXJzLmNpcGhlcl90eXBlKSB7XG4gKiAgICAgY2FzZSBzdHJlYW06IEdlbmVyaWNTdHJlYW1DaXBoZXI7XG4gKiAgICAgY2FzZSBibG9jazogIEdlbmVyaWNCbG9ja0NpcGhlcjtcbiAqICAgICBjYXNlIGFlYWQ6ICAgR2VuZXJpY0FFQURDaXBoZXI7XG4gKiAgIH0gZnJhZ21lbnQ7XG4gKiB9IFRMU0NpcGhlcnRleHQ7XG4gKlxuICogdHlwZTpcbiAqICAgVGhlIHR5cGUgZmllbGQgaXMgaWRlbnRpY2FsIHRvIFRMU0NvbXByZXNzZWQudHlwZS5cbiAqXG4gKiB2ZXJzaW9uOlxuICogICBUaGUgdmVyc2lvbiBmaWVsZCBpcyBpZGVudGljYWwgdG8gVExTQ29tcHJlc3NlZC52ZXJzaW9uLlxuICpcbiAqIGxlbmd0aDpcbiAqICAgVGhlIGxlbmd0aCAoaW4gYnl0ZXMpIG9mIHRoZSBmb2xsb3dpbmcgVExTQ2lwaGVydGV4dC5mcmFnbWVudC5cbiAqICAgVGhlIGxlbmd0aCBNVVNUIE5PVCBleGNlZWQgMl4xNCArIDIwNDguXG4gKlxuICogZnJhZ21lbnQ6XG4gKiAgIFRoZSBlbmNyeXB0ZWQgZm9ybSBvZiBUTFNDb21wcmVzc2VkLmZyYWdtZW50LCB3aXRoIHRoZSBNQUMuXG4gKlxuICogTm90ZTogT25seSBDQkMgQmxvY2sgQ2lwaGVycyBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb24uXG4gKlxuICogVGhlIFRMU0NvbXByZXNzZWQuZnJhZ21lbnQgc3RydWN0dXJlcyBhcmUgY29udmVydGVkIHRvL2Zyb20gYmxvY2tcbiAqIFRMU0NpcGhlcnRleHQuZnJhZ21lbnQgc3RydWN0dXJlcy5cbiAqXG4gKiBzdHJ1Y3Qge1xuICogICBvcGFxdWUgSVZbU2VjdXJpdHlQYXJhbWV0ZXJzLnJlY29yZF9pdl9sZW5ndGhdO1xuICogICBibG9jay1jaXBoZXJlZCBzdHJ1Y3Qge1xuICogICAgIG9wYXF1ZSBjb250ZW50W1RMU0NvbXByZXNzZWQubGVuZ3RoXTtcbiAqICAgICBvcGFxdWUgTUFDW1NlY3VyaXR5UGFyYW1ldGVycy5tYWNfbGVuZ3RoXTtcbiAqICAgICB1aW50OCBwYWRkaW5nW0dlbmVyaWNCbG9ja0NpcGhlci5wYWRkaW5nX2xlbmd0aF07XG4gKiAgICAgdWludDggcGFkZGluZ19sZW5ndGg7XG4gKiAgIH07XG4gKiB9IEdlbmVyaWNCbG9ja0NpcGhlcjtcbiAqXG4gKiBUaGUgTUFDIGlzIGdlbmVyYXRlZCBhcyBkZXNjcmliZWQgaW4gU2VjdGlvbiA2LjIuMy4xLlxuICpcbiAqIElWOlxuICogICBUaGUgSW5pdGlhbGl6YXRpb24gVmVjdG9yIChJVikgU0hPVUxEIGJlIGNob3NlbiBhdCByYW5kb20sIGFuZCBNVVNUIGJlXG4gKiAgIHVucHJlZGljdGFibGUuIE5vdGUgdGhhdCBpbiB2ZXJzaW9ucyBvZiBUTFMgcHJpb3IgdG8gMS4xLCB0aGVyZSB3YXMgbm9cbiAqICAgSVYgZmllbGQsIGFuZCB0aGUgbGFzdCBjaXBoZXJ0ZXh0IGJsb2NrIG9mIHRoZSBwcmV2aW91cyByZWNvcmQgKHRoZSBcIkNCQ1xuICogICByZXNpZHVlXCIpIHdhcyB1c2VkIGFzIHRoZSBJVi4gVGhpcyB3YXMgY2hhbmdlZCB0byBwcmV2ZW50IHRoZSBhdHRhY2tzXG4gKiAgIGRlc2NyaWJlZCBpbiBbQ0JDQVRUXS4gRm9yIGJsb2NrIGNpcGhlcnMsIHRoZSBJViBsZW5ndGggaXMgb2YgbGVuZ3RoXG4gKiAgIFNlY3VyaXR5UGFyYW1ldGVycy5yZWNvcmRfaXZfbGVuZ3RoLCB3aGljaCBpcyBlcXVhbCB0byB0aGVcbiAqICAgU2VjdXJpdHlQYXJhbWV0ZXJzLmJsb2NrX3NpemUuXG4gKlxuICogcGFkZGluZzpcbiAqICAgUGFkZGluZyB0aGF0IGlzIGFkZGVkIHRvIGZvcmNlIHRoZSBsZW5ndGggb2YgdGhlIHBsYWludGV4dCB0byBiZSBhblxuICogICBpbnRlZ3JhbCBtdWx0aXBsZSBvZiB0aGUgYmxvY2sgY2lwaGVyJ3MgYmxvY2sgbGVuZ3RoLiBUaGUgcGFkZGluZyBNQVkgYmVcbiAqICAgYW55IGxlbmd0aCB1cCB0byAyNTUgYnl0ZXMsIGFzIGxvbmcgYXMgaXQgcmVzdWx0cyBpbiB0aGVcbiAqICAgVExTQ2lwaGVydGV4dC5sZW5ndGggYmVpbmcgYW4gaW50ZWdyYWwgbXVsdGlwbGUgb2YgdGhlIGJsb2NrIGxlbmd0aC5cbiAqICAgTGVuZ3RocyBsb25nZXIgdGhhbiBuZWNlc3NhcnkgbWlnaHQgYmUgZGVzaXJhYmxlIHRvIGZydXN0cmF0ZSBhdHRhY2tzIG9uXG4gKiAgIGEgcHJvdG9jb2wgdGhhdCBhcmUgYmFzZWQgb24gYW5hbHlzaXMgb2YgdGhlIGxlbmd0aHMgb2YgZXhjaGFuZ2VkXG4gKiAgIG1lc3NhZ2VzLiBFYWNoIHVpbnQ4IGluIHRoZSBwYWRkaW5nIGRhdGEgdmVjdG9yIE1VU1QgYmUgZmlsbGVkIHdpdGggdGhlXG4gKiAgIHBhZGRpbmcgbGVuZ3RoIHZhbHVlLiBUaGUgcmVjZWl2ZXIgTVVTVCBjaGVjayB0aGlzIHBhZGRpbmcgYW5kIE1VU1QgdXNlXG4gKiAgIHRoZSBiYWRfcmVjb3JkX21hYyBhbGVydCB0byBpbmRpY2F0ZSBwYWRkaW5nIGVycm9ycy5cbiAqXG4gKiBwYWRkaW5nX2xlbmd0aDpcbiAqICAgVGhlIHBhZGRpbmcgbGVuZ3RoIE1VU1QgYmUgc3VjaCB0aGF0IHRoZSB0b3RhbCBzaXplIG9mIHRoZVxuICogICBHZW5lcmljQmxvY2tDaXBoZXIgc3RydWN0dXJlIGlzIGEgbXVsdGlwbGUgb2YgdGhlIGNpcGhlcidzIGJsb2NrIGxlbmd0aC5cbiAqICAgTGVnYWwgdmFsdWVzIHJhbmdlIGZyb20gemVybyB0byAyNTUsIGluY2x1c2l2ZS4gVGhpcyBsZW5ndGggc3BlY2lmaWVzIHRoZVxuICogICBsZW5ndGggb2YgdGhlIHBhZGRpbmcgZmllbGQgZXhjbHVzaXZlIG9mIHRoZSBwYWRkaW5nX2xlbmd0aCBmaWVsZCBpdHNlbGYuXG4gKlxuICogVGhlIGVuY3J5cHRlZCBkYXRhIGxlbmd0aCAoVExTQ2lwaGVydGV4dC5sZW5ndGgpIGlzIG9uZSBtb3JlIHRoYW4gdGhlIHN1bSBvZlxuICogU2VjdXJpdHlQYXJhbWV0ZXJzLmJsb2NrX2xlbmd0aCwgVExTQ29tcHJlc3NlZC5sZW5ndGgsXG4gKiBTZWN1cml0eVBhcmFtZXRlcnMubWFjX2xlbmd0aCwgYW5kIHBhZGRpbmdfbGVuZ3RoLlxuICpcbiAqIEV4YW1wbGU6IElmIHRoZSBibG9jayBsZW5ndGggaXMgOCBieXRlcywgdGhlIGNvbnRlbnQgbGVuZ3RoXG4gKiAoVExTQ29tcHJlc3NlZC5sZW5ndGgpIGlzIDYxIGJ5dGVzLCBhbmQgdGhlIE1BQyBsZW5ndGggaXMgMjAgYnl0ZXMsIHRoZW4gdGhlXG4gKiBsZW5ndGggYmVmb3JlIHBhZGRpbmcgaXMgODIgYnl0ZXMgKHRoaXMgZG9lcyBub3QgaW5jbHVkZSB0aGUgSVYuIFRodXMsIHRoZVxuICogcGFkZGluZyBsZW5ndGggbW9kdWxvIDggbXVzdCBiZSBlcXVhbCB0byA2IGluIG9yZGVyIHRvIG1ha2UgdGhlIHRvdGFsIGxlbmd0aFxuICogYW4gZXZlbiBtdWx0aXBsZSBvZiA4IGJ5dGVzICh0aGUgYmxvY2sgbGVuZ3RoKS4gVGhlIHBhZGRpbmcgbGVuZ3RoIGNhbiBiZVxuICogNiwgMTQsIDIyLCBhbmQgc28gb24sIHRocm91Z2ggMjU0LiBJZiB0aGUgcGFkZGluZyBsZW5ndGggd2VyZSB0aGUgbWluaW11bVxuICogbmVjZXNzYXJ5LCA2LCB0aGUgcGFkZGluZyB3b3VsZCBiZSA2IGJ5dGVzLCBlYWNoIGNvbnRhaW5pbmcgdGhlIHZhbHVlIDYuXG4gKiBUaHVzLCB0aGUgbGFzdCA4IG9jdGV0cyBvZiB0aGUgR2VuZXJpY0Jsb2NrQ2lwaGVyIGJlZm9yZSBibG9jayBlbmNyeXB0aW9uXG4gKiB3b3VsZCBiZSB4eCAwNiAwNiAwNiAwNiAwNiAwNiAwNiwgd2hlcmUgeHggaXMgdGhlIGxhc3Qgb2N0ZXQgb2YgdGhlIE1BQy5cbiAqXG4gKiBOb3RlOiBXaXRoIGJsb2NrIGNpcGhlcnMgaW4gQ0JDIG1vZGUgKENpcGhlciBCbG9jayBDaGFpbmluZyksIGl0IGlzIGNyaXRpY2FsXG4gKiB0aGF0IHRoZSBlbnRpcmUgcGxhaW50ZXh0IG9mIHRoZSByZWNvcmQgYmUga25vd24gYmVmb3JlIGFueSBjaXBoZXJ0ZXh0IGlzXG4gKiB0cmFuc21pdHRlZC4gT3RoZXJ3aXNlLCBpdCBpcyBwb3NzaWJsZSBmb3IgdGhlIGF0dGFja2VyIHRvIG1vdW50IHRoZSBhdHRhY2tcbiAqIGRlc2NyaWJlZCBpbiBbQ0JDQVRUXS5cbiAqXG4gKiBJbXBsZW1lbnRhdGlvbiBub3RlOiBDYW52ZWwgZXQgYWwuIFtDQkNUSU1FXSBoYXZlIGRlbW9uc3RyYXRlZCBhIHRpbWluZ1xuICogYXR0YWNrIG9uIENCQyBwYWRkaW5nIGJhc2VkIG9uIHRoZSB0aW1lIHJlcXVpcmVkIHRvIGNvbXB1dGUgdGhlIE1BQy4gSW5cbiAqIG9yZGVyIHRvIGRlZmVuZCBhZ2FpbnN0IHRoaXMgYXR0YWNrLCBpbXBsZW1lbnRhdGlvbnMgTVVTVCBlbnN1cmUgdGhhdFxuICogcmVjb3JkIHByb2Nlc3NpbmcgdGltZSBpcyBlc3NlbnRpYWxseSB0aGUgc2FtZSB3aGV0aGVyIG9yIG5vdCB0aGUgcGFkZGluZ1xuICogaXMgY29ycmVjdC4gSW4gZ2VuZXJhbCwgdGhlIGJlc3Qgd2F5IHRvIGRvIHRoaXMgaXMgdG8gY29tcHV0ZSB0aGUgTUFDIGV2ZW5cbiAqIGlmIHRoZSBwYWRkaW5nIGlzIGluY29ycmVjdCwgYW5kIG9ubHkgdGhlbiByZWplY3QgdGhlIHBhY2tldC4gRm9yIGluc3RhbmNlLFxuICogaWYgdGhlIHBhZCBhcHBlYXJzIHRvIGJlIGluY29ycmVjdCwgdGhlIGltcGxlbWVudGF0aW9uIG1pZ2h0IGFzc3VtZSBhXG4gKiB6ZXJvLWxlbmd0aCBwYWQgYW5kIHRoZW4gY29tcHV0ZSB0aGUgTUFDLiBUaGlzIGxlYXZlcyBhIHNtYWxsIHRpbWluZ1xuICogY2hhbm5lbCwgc2luY2UgTUFDIHBlcmZvcm1hbmNlIGRlcGVuZHMsIHRvIHNvbWUgZXh0ZW50LCBvbiB0aGUgc2l6ZSBvZiB0aGVcbiAqIGRhdGEgZnJhZ21lbnQsIGJ1dCBpdCBpcyBub3QgYmVsaWV2ZWQgdG8gYmUgbGFyZ2UgZW5vdWdoIHRvIGJlIGV4cGxvaXRhYmxlLFxuICogZHVlIHRvIHRoZSBsYXJnZSBibG9jayBzaXplIG9mIGV4aXN0aW5nIE1BQ3MgYW5kIHRoZSBzbWFsbCBzaXplIG9mIHRoZVxuICogdGltaW5nIHNpZ25hbC5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9hc24xJyk7XG5yZXF1aXJlKCcuL2htYWMnKTtcbnJlcXVpcmUoJy4vbWQ1Jyk7XG5yZXF1aXJlKCcuL3BlbScpO1xucmVxdWlyZSgnLi9wa2knKTtcbnJlcXVpcmUoJy4vcmFuZG9tJyk7XG5yZXF1aXJlKCcuL3NoYTEnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBwc2V1ZG8gcmFuZG9tIGJ5dGVzIGJ5IG1peGluZyB0aGUgcmVzdWx0IG9mIHR3byBoYXNoIGZ1bmN0aW9ucyxcbiAqIE1ENSBhbmQgU0hBLTEuXG4gKlxuICogcHJmX1RMUzEoc2VjcmV0LCBsYWJlbCwgc2VlZCkgPVxuICogICBQX01ENShTMSwgbGFiZWwgKyBzZWVkKSBYT1IgUF9TSEEtMShTMiwgbGFiZWwgKyBzZWVkKTtcbiAqXG4gKiBFYWNoIFBfaGFzaCBmdW5jdGlvbiBmdW5jdGlvbnMgYXMgZm9sbG93czpcbiAqXG4gKiBQX2hhc2goc2VjcmV0LCBzZWVkKSA9IEhNQUNfaGFzaChzZWNyZXQsIEEoMSkgKyBzZWVkKSArXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIEhNQUNfaGFzaChzZWNyZXQsIEEoMikgKyBzZWVkKSArXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIEhNQUNfaGFzaChzZWNyZXQsIEEoMykgKyBzZWVkKSArIC4uLlxuICogQSgpIGlzIGRlZmluZWQgYXM6XG4gKiAgIEEoMCkgPSBzZWVkXG4gKiAgIEEoaSkgPSBITUFDX2hhc2goc2VjcmV0LCBBKGktMSkpXG4gKlxuICogVGhlICcrJyBvcGVyYXRvciBkZW5vdGVzIGNvbmNhdGVuYXRpb24uXG4gKlxuICogQXMgbWFueSBpdGVyYXRpb25zIEEoTikgYXMgYXJlIG5lZWRlZCBhcmUgcGVyZm9ybWVkIHRvIGdlbmVyYXRlIGVub3VnaFxuICogcHNldWRvIHJhbmRvbSBieXRlIG91dHB1dC4gSWYgYW4gaXRlcmF0aW9uIGNyZWF0ZXMgbW9yZSBkYXRhIHRoYW4gaXNcbiAqIG5lY2Vzc2FyeSwgdGhlbiBpdCBpcyB0cnVuY2F0ZWQuXG4gKlxuICogVGhlcmVmb3JlOlxuICogQSgxKSA9IEhNQUNfaGFzaChzZWNyZXQsIEEoMCkpXG4gKiAgICAgID0gSE1BQ19oYXNoKHNlY3JldCwgc2VlZClcbiAqIEEoMikgPSBITUFDX2hhc2goc2VjcmV0LCBBKDEpKVxuICogICAgICA9IEhNQUNfaGFzaChzZWNyZXQsIEhNQUNfaGFzaChzZWNyZXQsIHNlZWQpKVxuICpcbiAqIFRoZXJlZm9yZTpcbiAqIFBfaGFzaChzZWNyZXQsIHNlZWQpID1cbiAqICAgSE1BQ19oYXNoKHNlY3JldCwgSE1BQ19oYXNoKHNlY3JldCwgQSgwKSkgKyBzZWVkKSArXG4gKiAgIEhNQUNfaGFzaChzZWNyZXQsIEhNQUNfaGFzaChzZWNyZXQsIEEoMSkpICsgc2VlZCkgK1xuICogICAuLi5cbiAqXG4gKiBUaGVyZWZvcmU6XG4gKiBQX2hhc2goc2VjcmV0LCBzZWVkKSA9XG4gKiAgIEhNQUNfaGFzaChzZWNyZXQsIEhNQUNfaGFzaChzZWNyZXQsIHNlZWQpICsgc2VlZCkgK1xuICogICBITUFDX2hhc2goc2VjcmV0LCBITUFDX2hhc2goc2VjcmV0LCBITUFDX2hhc2goc2VjcmV0LCBzZWVkKSkgKyBzZWVkKSArXG4gKiAgIC4uLlxuICpcbiAqIEBwYXJhbSBzZWNyZXQgdGhlIHNlY3JldCB0byB1c2UuXG4gKiBAcGFyYW0gbGFiZWwgdGhlIGxhYmVsIHRvIHVzZS5cbiAqIEBwYXJhbSBzZWVkIHRoZSBzZWVkIHZhbHVlIHRvIHVzZS5cbiAqIEBwYXJhbSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0byBnZW5lcmF0ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwc2V1ZG8gcmFuZG9tIGJ5dGVzIGluIGEgYnl0ZSBidWZmZXIuXG4gKi9cbnZhciBwcmZfVExTMSA9IGZ1bmN0aW9uKHNlY3JldCwgbGFiZWwsIHNlZWQsIGxlbmd0aCkge1xuICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLyogRm9yIFRMUyAxLjAsIHRoZSBzZWNyZXQgaXMgc3BsaXQgaW4gaGFsZiwgaW50byB0d28gc2VjcmV0cyBvZiBlcXVhbFxuICAgIGxlbmd0aC4gSWYgdGhlIHNlY3JldCBoYXMgYW4gb2RkIGxlbmd0aCB0aGVuIHRoZSBsYXN0IGJ5dGUgb2YgdGhlIGZpcnN0XG4gICAgaGFsZiB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSBmaXJzdCBieXRlIG9mIHRoZSBzZWNvbmQuIFRoZSBsZW5ndGggb2YgdGhlXG4gICAgdHdvIHNlY3JldHMgaXMgaGFsZiBvZiB0aGUgc2VjcmV0IHJvdW5kZWQgdXAuICovXG4gIHZhciBpZHggPSAoc2VjcmV0Lmxlbmd0aCA+PiAxKTtcbiAgdmFyIHNsZW4gPSBpZHggKyAoc2VjcmV0Lmxlbmd0aCAmIDEpO1xuICB2YXIgczEgPSBzZWNyZXQuc3Vic3RyKDAsIHNsZW4pO1xuICB2YXIgczIgPSBzZWNyZXQuc3Vic3RyKGlkeCwgc2xlbik7XG4gIHZhciBhaSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIHZhciBobWFjID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgc2VlZCA9IGxhYmVsICsgc2VlZDtcblxuICAvLyBkZXRlcm1pbmUgdGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRoYXQgbXVzdCBiZSBwZXJmb3JtZWQgdG8gZ2VuZXJhdGVcbiAgLy8gZW5vdWdoIG91dHB1dCBieXRlcywgbWQ1IGNyZWF0ZXMgMTYgYnl0ZSBoYXNoZXMsIHNoYTEgY3JlYXRlcyAyMFxuICB2YXIgbWQ1aXRyID0gTWF0aC5jZWlsKGxlbmd0aCAvIDE2KTtcbiAgdmFyIHNoYTFpdHIgPSBNYXRoLmNlaWwobGVuZ3RoIC8gMjApO1xuXG4gIC8vIGRvIG1kNSBpdGVyYXRpb25zXG4gIGhtYWMuc3RhcnQoJ01ENScsIHMxKTtcbiAgdmFyIG1kNWJ5dGVzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgYWkucHV0Qnl0ZXMoc2VlZCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBtZDVpdHI7ICsraSkge1xuICAgIC8vIEhNQUNfaGFzaChzZWNyZXQsIEEoaS0xKSlcbiAgICBobWFjLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgIGhtYWMudXBkYXRlKGFpLmdldEJ5dGVzKCkpO1xuICAgIGFpLnB1dEJ1ZmZlcihobWFjLmRpZ2VzdCgpKTtcblxuICAgIC8vIEhNQUNfaGFzaChzZWNyZXQsIEEoaSkgKyBzZWVkKVxuICAgIGhtYWMuc3RhcnQobnVsbCwgbnVsbCk7XG4gICAgaG1hYy51cGRhdGUoYWkuYnl0ZXMoKSArIHNlZWQpO1xuICAgIG1kNWJ5dGVzLnB1dEJ1ZmZlcihobWFjLmRpZ2VzdCgpKTtcbiAgfVxuXG4gIC8vIGRvIHNoYTEgaXRlcmF0aW9uc1xuICBobWFjLnN0YXJ0KCdTSEExJywgczIpO1xuICB2YXIgc2hhMWJ5dGVzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgYWkuY2xlYXIoKTtcbiAgYWkucHV0Qnl0ZXMoc2VlZCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzaGExaXRyOyArK2kpIHtcbiAgICAvLyBITUFDX2hhc2goc2VjcmV0LCBBKGktMSkpXG4gICAgaG1hYy5zdGFydChudWxsLCBudWxsKTtcbiAgICBobWFjLnVwZGF0ZShhaS5nZXRCeXRlcygpKTtcbiAgICBhaS5wdXRCdWZmZXIoaG1hYy5kaWdlc3QoKSk7XG5cbiAgICAvLyBITUFDX2hhc2goc2VjcmV0LCBBKGkpICsgc2VlZClcbiAgICBobWFjLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgIGhtYWMudXBkYXRlKGFpLmJ5dGVzKCkgKyBzZWVkKTtcbiAgICBzaGExYnl0ZXMucHV0QnVmZmVyKGhtYWMuZGlnZXN0KCkpO1xuICB9XG5cbiAgLy8gWE9SIHRoZSBtZDUgYnl0ZXMgd2l0aCB0aGUgc2hhMSBieXRlc1xuICBydmFsLnB1dEJ5dGVzKGZvcmdlLnV0aWwueG9yQnl0ZXMoXG4gICAgbWQ1Ynl0ZXMuZ2V0Qnl0ZXMoKSwgc2hhMWJ5dGVzLmdldEJ5dGVzKCksIGxlbmd0aCkpO1xuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgcHNldWRvIHJhbmRvbSBieXRlcyB1c2luZyBhIFNIQTI1NiBhbGdvcml0aG0uIEZvciBUTFMgMS4yLlxuICpcbiAqIEBwYXJhbSBzZWNyZXQgdGhlIHNlY3JldCB0byB1c2UuXG4gKiBAcGFyYW0gbGFiZWwgdGhlIGxhYmVsIHRvIHVzZS5cbiAqIEBwYXJhbSBzZWVkIHRoZSBzZWVkIHZhbHVlIHRvIHVzZS5cbiAqIEBwYXJhbSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0byBnZW5lcmF0ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwc2V1ZG8gcmFuZG9tIGJ5dGVzIGluIGEgYnl0ZSBidWZmZXIuXG4gKi9cbnZhciBwcmZfc2hhMjU2ID0gZnVuY3Rpb24oc2VjcmV0LCBsYWJlbCwgc2VlZCwgbGVuZ3RoKSB7XG4gICAvLyBGSVhNRTogaW1wbGVtZW50IG1lIGZvciBUTFMgMS4yXG59O1xuXG4vKipcbiAqIEdldHMgYSBNQUMgZm9yIGEgcmVjb3JkIHVzaW5nIHRoZSBTSEEtMSBoYXNoIGFsZ29yaXRobS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBtYWMga2V5LlxuICogQHBhcmFtIHN0YXRlIHRoZSBzZXF1ZW5jZSBudW1iZXIgKGFycmF5IG9mIHR3byAzMi1iaXQgaW50ZWdlcnMpLlxuICogQHBhcmFtIHJlY29yZCB0aGUgcmVjb3JkLlxuICpcbiAqIEByZXR1cm4gdGhlIHNoYS0xIGhhc2ggKDIwIGJ5dGVzKSBmb3IgdGhlIGdpdmVuIHJlY29yZC5cbiAqL1xudmFyIGhtYWNfc2hhMSA9IGZ1bmN0aW9uKGtleSwgc2VxTnVtLCByZWNvcmQpIHtcbiAgLyogTUFDIGlzIGNvbXB1dGVkIGxpa2Ugc286XG4gIEhNQUNfaGFzaChcbiAgICBrZXksIHNlcU51bSArXG4gICAgICBUTFNDb21wcmVzc2VkLnR5cGUgK1xuICAgICAgVExTQ29tcHJlc3NlZC52ZXJzaW9uICtcbiAgICAgIFRMU0NvbXByZXNzZWQubGVuZ3RoICtcbiAgICAgIFRMU0NvbXByZXNzZWQuZnJhZ21lbnQpXG4gICovXG4gIHZhciBobWFjID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgaG1hYy5zdGFydCgnU0hBMScsIGtleSk7XG4gIHZhciBiID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgYi5wdXRJbnQzMihzZXFOdW1bMF0pO1xuICBiLnB1dEludDMyKHNlcU51bVsxXSk7XG4gIGIucHV0Qnl0ZShyZWNvcmQudHlwZSk7XG4gIGIucHV0Qnl0ZShyZWNvcmQudmVyc2lvbi5tYWpvcik7XG4gIGIucHV0Qnl0ZShyZWNvcmQudmVyc2lvbi5taW5vcik7XG4gIGIucHV0SW50MTYocmVjb3JkLmxlbmd0aCk7XG4gIGIucHV0Qnl0ZXMocmVjb3JkLmZyYWdtZW50LmJ5dGVzKCkpO1xuICBobWFjLnVwZGF0ZShiLmdldEJ5dGVzKCkpO1xuICByZXR1cm4gaG1hYy5kaWdlc3QoKS5nZXRCeXRlcygpO1xufTtcblxuLyoqXG4gKiBDb21wcmVzc2VzIHRoZSBUTFNQbGFpbnRleHQgcmVjb3JkIGludG8gYSBUTFNDb21wcmVzc2VkIHJlY29yZCB1c2luZyB0aGVcbiAqIGRlZmxhdGUgYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSBjIHRoZSBUTFMgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSByZWNvcmQgdGhlIFRMU1BsYWludGV4dCByZWNvcmQgdG8gY29tcHJlc3MuXG4gKiBAcGFyYW0gcyB0aGUgQ29ubmVjdGlvblN0YXRlIHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZS5cbiAqL1xudmFyIGRlZmxhdGUgPSBmdW5jdGlvbihjLCByZWNvcmQsIHMpIHtcbiAgdmFyIHJ2YWwgPSBmYWxzZTtcblxuICB0cnkge1xuICAgIHZhciBieXRlcyA9IGMuZGVmbGF0ZShyZWNvcmQuZnJhZ21lbnQuZ2V0Qnl0ZXMoKSk7XG4gICAgcmVjb3JkLmZyYWdtZW50ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoYnl0ZXMpO1xuICAgIHJlY29yZC5sZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gICAgcnZhbCA9IHRydWU7XG4gIH0gY2F0Y2goZXgpIHtcbiAgICAvLyBkZWZsYXRlIGVycm9yLCBmYWlsIG91dFxuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIERlY29tcHJlc3NlcyB0aGUgVExTQ29tcHJlc3NlZCByZWNvcmQgaW50byBhIFRMU1BsYWludGV4dCByZWNvcmQgdXNpbmcgdGhlXG4gKiBkZWZsYXRlIGFsZ29yaXRobS5cbiAqXG4gKiBAcGFyYW0gYyB0aGUgVExTIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0gcmVjb3JkIHRoZSBUTFNDb21wcmVzc2VkIHJlY29yZCB0byBkZWNvbXByZXNzLlxuICogQHBhcmFtIHMgdGhlIENvbm5lY3Rpb25TdGF0ZSB0byB1c2UuXG4gKlxuICogQHJldHVybiB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmUuXG4gKi9cbnZhciBpbmZsYXRlID0gZnVuY3Rpb24oYywgcmVjb3JkLCBzKSB7XG4gIHZhciBydmFsID0gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICB2YXIgYnl0ZXMgPSBjLmluZmxhdGUocmVjb3JkLmZyYWdtZW50LmdldEJ5dGVzKCkpO1xuICAgIHJlY29yZC5mcmFnbWVudCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKTtcbiAgICByZWNvcmQubGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgIHJ2YWwgPSB0cnVlO1xuICB9IGNhdGNoKGV4KSB7XG4gICAgLy8gaW5mbGF0ZSBlcnJvciwgZmFpbCBvdXRcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIFRMUyB2YXJpYWJsZS1sZW5ndGggdmVjdG9yIGZyb20gYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBWYXJpYWJsZS1sZW5ndGggdmVjdG9ycyBhcmUgZGVmaW5lZCBieSBzcGVjaWZ5aW5nIGEgc3VicmFuZ2Ugb2YgbGVnYWxcbiAqIGxlbmd0aHMsIGluY2x1c2l2ZWx5LCB1c2luZyB0aGUgbm90YXRpb24gPGZsb29yLi5jZWlsaW5nPi4gV2hlbiB0aGVzZSBhcmVcbiAqIGVuY29kZWQsIHRoZSBhY3R1YWwgbGVuZ3RoIHByZWNlZGVzIHRoZSB2ZWN0b3IncyBjb250ZW50cyBpbiB0aGUgYnl0ZVxuICogc3RyZWFtLiBUaGUgbGVuZ3RoIHdpbGwgYmUgaW4gdGhlIGZvcm0gb2YgYSBudW1iZXIgY29uc3VtaW5nIGFzIG1hbnkgYnl0ZXNcbiAqIGFzIHJlcXVpcmVkIHRvIGhvbGQgdGhlIHZlY3RvcidzIHNwZWNpZmllZCBtYXhpbXVtIChjZWlsaW5nKSBsZW5ndGguIEFcbiAqIHZhcmlhYmxlLWxlbmd0aCB2ZWN0b3Igd2l0aCBhbiBhY3R1YWwgbGVuZ3RoIGZpZWxkIG9mIHplcm8gaXMgcmVmZXJyZWQgdG9cbiAqIGFzIGFuIGVtcHR5IHZlY3Rvci5cbiAqXG4gKiBAcGFyYW0gYiB0aGUgYnl0ZSBidWZmZXIuXG4gKiBAcGFyYW0gbGVuQnl0ZXMgdGhlIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byBzdG9yZSB0aGUgbGVuZ3RoLlxuICpcbiAqIEByZXR1cm4gdGhlIHJlc3VsdGluZyBieXRlIGJ1ZmZlci5cbiAqL1xudmFyIHJlYWRWZWN0b3IgPSBmdW5jdGlvbihiLCBsZW5CeXRlcykge1xuICB2YXIgbGVuID0gMDtcbiAgc3dpdGNoKGxlbkJ5dGVzKSB7XG4gIGNhc2UgMTpcbiAgICBsZW4gPSBiLmdldEJ5dGUoKTtcbiAgICBicmVhaztcbiAgY2FzZSAyOlxuICAgIGxlbiA9IGIuZ2V0SW50MTYoKTtcbiAgICBicmVhaztcbiAgY2FzZSAzOlxuICAgIGxlbiA9IGIuZ2V0SW50MjQoKTtcbiAgICBicmVhaztcbiAgY2FzZSA0OlxuICAgIGxlbiA9IGIuZ2V0SW50MzIoKTtcbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIHJlYWQgdmVjdG9yIGJ5dGVzIGludG8gYSBuZXcgYnVmZmVyXG4gIHJldHVybiBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihiLmdldEJ5dGVzKGxlbikpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBUTFMgdmFyaWFibGUtbGVuZ3RoIHZlY3RvciB0byBhIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBieXRlIGJ1ZmZlci5cbiAqIEBwYXJhbSBsZW5CeXRlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHJlcXVpcmVkIHRvIHN0b3JlIHRoZSBsZW5ndGguXG4gKiBAcGFyYW0gdiB0aGUgYnl0ZSBidWZmZXIgdmVjdG9yLlxuICovXG52YXIgd3JpdGVWZWN0b3IgPSBmdW5jdGlvbihiLCBsZW5CeXRlcywgdikge1xuICAvLyBlbmNvZGUgbGVuZ3RoIGF0IHRoZSBzdGFydCBvZiB0aGUgdmVjdG9yLCB3aGVyZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGZvclxuICAvLyB0aGUgbGVuZ3RoIGlzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBieXRlcyBpdCB3b3VsZCB0YWtlIHRvIGVuY29kZSB0aGVcbiAgLy8gdmVjdG9yJ3MgY2VpbGluZ1xuICBiLnB1dEludCh2Lmxlbmd0aCgpLCBsZW5CeXRlcyA8PCAzKTtcbiAgYi5wdXRCdWZmZXIodik7XG59O1xuXG4vKipcbiAqIFRoZSB0bHMgaW1wbGVtZW50YXRpb24uXG4gKi9cbnZhciB0bHMgPSB7fTtcblxuLyoqXG4gKiBWZXJzaW9uOiBUTFMgMS4yID0gMy4zLCBUTFMgMS4xID0gMy4yLCBUTFMgMS4wID0gMy4xLiBCb3RoIFRMUyAxLjEgYW5kXG4gKiBUTFMgMS4yIHdlcmUgc3RpbGwgdG9vIG5ldyAoaWU6IG9wZW5TU0wgZGlkbid0IGltcGxlbWVudCB0aGVtKSBhdCB0aGUgdGltZVxuICogb2YgdGhpcyBpbXBsZW1lbnRhdGlvbiBzbyBUTFMgMS4wIHdhcyBpbXBsZW1lbnRlZCBpbnN0ZWFkLlxuICovXG50bHMuVmVyc2lvbnMgPSB7XG4gIFRMU18xXzA6IHttYWpvcjogMywgbWlub3I6IDF9LFxuICBUTFNfMV8xOiB7bWFqb3I6IDMsIG1pbm9yOiAyfSxcbiAgVExTXzFfMjoge21ham9yOiAzLCBtaW5vcjogM31cbn07XG50bHMuU3VwcG9ydGVkVmVyc2lvbnMgPSBbXG4gIHRscy5WZXJzaW9ucy5UTFNfMV8xLFxuICB0bHMuVmVyc2lvbnMuVExTXzFfMFxuXTtcbnRscy5WZXJzaW9uID0gdGxzLlN1cHBvcnRlZFZlcnNpb25zWzBdO1xuXG4vKipcbiAqIE1heGltdW0gZnJhZ21lbnQgc2l6ZS4gVHJ1ZSBtYXhpbXVtIGlzIDE2Mzg0LCBidXQgd2UgZnJhZ21lbnQgYmVmb3JlIHRoYXRcbiAqIHRvIGFsbG93IGZvciB1bnVzdWFsIHNtYWxsIGluY3JlYXNlcyBkdXJpbmcgY29tcHJlc3Npb24uXG4gKi9cbnRscy5NYXhGcmFnbWVudCA9IDE2Mzg0IC0gMTAyNDtcblxuLyoqXG4gKiBXaGV0aGVyIHRoaXMgZW50aXR5IGlzIGNvbnNpZGVyZWQgdGhlIFwiY2xpZW50XCIgb3IgXCJzZXJ2ZXJcIi5cbiAqIGVudW0geyBzZXJ2ZXIsIGNsaWVudCB9IENvbm5lY3Rpb25FbmQ7XG4gKi9cbnRscy5Db25uZWN0aW9uRW5kID0ge1xuICBzZXJ2ZXI6IDAsXG4gIGNsaWVudDogMVxufTtcblxuLyoqXG4gKiBQc2V1ZG8tcmFuZG9tIGZ1bmN0aW9uIGFsZ29yaXRobSB1c2VkIHRvIGdlbmVyYXRlIGtleXMgZnJvbSB0aGUgbWFzdGVyXG4gKiBzZWNyZXQuXG4gKiBlbnVtIHsgdGxzX3ByZl9zaGEyNTYgfSBQUkZBbGdvcml0aG07XG4gKi9cbnRscy5QUkZBbGdvcml0aG0gPSB7XG4gIHRsc19wcmZfc2hhMjU2OiAwXG59O1xuXG4vKipcbiAqIEJ1bGsgZW5jcnlwdGlvbiBhbGdvcml0aG1zLlxuICogZW51bSB7IG51bGwsIHJjNCwgZGVzMywgYWVzIH0gQnVsa0NpcGhlckFsZ29yaXRobTtcbiAqL1xudGxzLkJ1bGtDaXBoZXJBbGdvcml0aG0gPSB7XG4gIG5vbmU6IG51bGwsXG4gIHJjNDogMCxcbiAgZGVzMzogMSxcbiAgYWVzOiAyXG59O1xuXG4vKipcbiAqIENpcGhlciB0eXBlcy5cbiAqIGVudW0geyBzdHJlYW0sIGJsb2NrLCBhZWFkIH0gQ2lwaGVyVHlwZTtcbiAqL1xudGxzLkNpcGhlclR5cGUgPSB7XG4gIHN0cmVhbTogMCxcbiAgYmxvY2s6IDEsXG4gIGFlYWQ6IDJcbn07XG5cbi8qKlxuICogTUFDIChNZXNzYWdlIEF1dGhlbnRpY2F0aW9uIENvZGUpIGFsZ29yaXRobXMuXG4gKiBlbnVtIHsgbnVsbCwgaG1hY19tZDUsIGhtYWNfc2hhMSwgaG1hY19zaGEyNTYsXG4gKiAgIGhtYWNfc2hhMzg0LCBobWFjX3NoYTUxMn0gTUFDQWxnb3JpdGhtO1xuICovXG50bHMuTUFDQWxnb3JpdGhtID0ge1xuICBub25lOiBudWxsLFxuICBobWFjX21kNTogMCxcbiAgaG1hY19zaGExOiAxLFxuICBobWFjX3NoYTI1NjogMixcbiAgaG1hY19zaGEzODQ6IDMsXG4gIGhtYWNfc2hhNTEyOiA0XG59O1xuXG4vKipcbiAqIENvbXByZXNzaW9uIGFsZ29yaXRobXMuXG4gKiBlbnVtIHsgbnVsbCgwKSwgZGVmbGF0ZSgxKSwgKDI1NSkgfSBDb21wcmVzc2lvbk1ldGhvZDtcbiAqL1xudGxzLkNvbXByZXNzaW9uTWV0aG9kID0ge1xuICBub25lOiAwLFxuICBkZWZsYXRlOiAxXG59O1xuXG4vKipcbiAqIFRMUyByZWNvcmQgY29udGVudCB0eXBlcy5cbiAqIGVudW0ge1xuICogICBjaGFuZ2VfY2lwaGVyX3NwZWMoMjApLCBhbGVydCgyMSksIGhhbmRzaGFrZSgyMiksXG4gKiAgIGFwcGxpY2F0aW9uX2RhdGEoMjMpLCAoMjU1KVxuICogfSBDb250ZW50VHlwZTtcbiAqL1xudGxzLkNvbnRlbnRUeXBlID0ge1xuICBjaGFuZ2VfY2lwaGVyX3NwZWM6IDIwLFxuICBhbGVydDogMjEsXG4gIGhhbmRzaGFrZTogMjIsXG4gIGFwcGxpY2F0aW9uX2RhdGE6IDIzLFxuICBoZWFydGJlYXQ6IDI0XG59O1xuXG4vKipcbiAqIFRMUyBoYW5kc2hha2UgdHlwZXMuXG4gKiBlbnVtIHtcbiAqICAgaGVsbG9fcmVxdWVzdCgwKSwgY2xpZW50X2hlbGxvKDEpLCBzZXJ2ZXJfaGVsbG8oMiksXG4gKiAgIGNlcnRpZmljYXRlKDExKSwgc2VydmVyX2tleV9leGNoYW5nZSAoMTIpLFxuICogICBjZXJ0aWZpY2F0ZV9yZXF1ZXN0KDEzKSwgc2VydmVyX2hlbGxvX2RvbmUoMTQpLFxuICogICBjZXJ0aWZpY2F0ZV92ZXJpZnkoMTUpLCBjbGllbnRfa2V5X2V4Y2hhbmdlKDE2KSxcbiAqICAgZmluaXNoZWQoMjApLCAoMjU1KVxuICogfSBIYW5kc2hha2VUeXBlO1xuICovXG50bHMuSGFuZHNoYWtlVHlwZSA9IHtcbiAgaGVsbG9fcmVxdWVzdDogMCxcbiAgY2xpZW50X2hlbGxvOiAxLFxuICBzZXJ2ZXJfaGVsbG86IDIsXG4gIGNlcnRpZmljYXRlOiAxMSxcbiAgc2VydmVyX2tleV9leGNoYW5nZTogMTIsXG4gIGNlcnRpZmljYXRlX3JlcXVlc3Q6IDEzLFxuICBzZXJ2ZXJfaGVsbG9fZG9uZTogMTQsXG4gIGNlcnRpZmljYXRlX3ZlcmlmeTogMTUsXG4gIGNsaWVudF9rZXlfZXhjaGFuZ2U6IDE2LFxuICBmaW5pc2hlZDogMjBcbn07XG5cbi8qKlxuICogVExTIEFsZXJ0IFByb3RvY29sLlxuICpcbiAqIGVudW0geyB3YXJuaW5nKDEpLCBmYXRhbCgyKSwgKDI1NSkgfSBBbGVydExldmVsO1xuICpcbiAqIGVudW0ge1xuICogICBjbG9zZV9ub3RpZnkoMCksXG4gKiAgIHVuZXhwZWN0ZWRfbWVzc2FnZSgxMCksXG4gKiAgIGJhZF9yZWNvcmRfbWFjKDIwKSxcbiAqICAgZGVjcnlwdGlvbl9mYWlsZWQoMjEpLFxuICogICByZWNvcmRfb3ZlcmZsb3coMjIpLFxuICogICBkZWNvbXByZXNzaW9uX2ZhaWx1cmUoMzApLFxuICogICBoYW5kc2hha2VfZmFpbHVyZSg0MCksXG4gKiAgIGJhZF9jZXJ0aWZpY2F0ZSg0MiksXG4gKiAgIHVuc3VwcG9ydGVkX2NlcnRpZmljYXRlKDQzKSxcbiAqICAgY2VydGlmaWNhdGVfcmV2b2tlZCg0NCksXG4gKiAgIGNlcnRpZmljYXRlX2V4cGlyZWQoNDUpLFxuICogICBjZXJ0aWZpY2F0ZV91bmtub3duKDQ2KSxcbiAqICAgaWxsZWdhbF9wYXJhbWV0ZXIoNDcpLFxuICogICB1bmtub3duX2NhKDQ4KSxcbiAqICAgYWNjZXNzX2RlbmllZCg0OSksXG4gKiAgIGRlY29kZV9lcnJvcig1MCksXG4gKiAgIGRlY3J5cHRfZXJyb3IoNTEpLFxuICogICBleHBvcnRfcmVzdHJpY3Rpb24oNjApLFxuICogICBwcm90b2NvbF92ZXJzaW9uKDcwKSxcbiAqICAgaW5zdWZmaWNpZW50X3NlY3VyaXR5KDcxKSxcbiAqICAgaW50ZXJuYWxfZXJyb3IoODApLFxuICogICB1c2VyX2NhbmNlbGVkKDkwKSxcbiAqICAgbm9fcmVuZWdvdGlhdGlvbigxMDApLFxuICogICAoMjU1KVxuICogfSBBbGVydERlc2NyaXB0aW9uO1xuICpcbiAqIHN0cnVjdCB7XG4gKiAgIEFsZXJ0TGV2ZWwgbGV2ZWw7XG4gKiAgIEFsZXJ0RGVzY3JpcHRpb24gZGVzY3JpcHRpb247XG4gKiB9IEFsZXJ0O1xuICovXG50bHMuQWxlcnQgPSB7fTtcbnRscy5BbGVydC5MZXZlbCA9IHtcbiAgd2FybmluZzogMSxcbiAgZmF0YWw6IDJcbn07XG50bHMuQWxlcnQuRGVzY3JpcHRpb24gPSB7XG4gIGNsb3NlX25vdGlmeTogMCxcbiAgdW5leHBlY3RlZF9tZXNzYWdlOiAxMCxcbiAgYmFkX3JlY29yZF9tYWM6IDIwLFxuICBkZWNyeXB0aW9uX2ZhaWxlZDogMjEsXG4gIHJlY29yZF9vdmVyZmxvdzogMjIsXG4gIGRlY29tcHJlc3Npb25fZmFpbHVyZTogMzAsXG4gIGhhbmRzaGFrZV9mYWlsdXJlOiA0MCxcbiAgYmFkX2NlcnRpZmljYXRlOiA0MixcbiAgdW5zdXBwb3J0ZWRfY2VydGlmaWNhdGU6IDQzLFxuICBjZXJ0aWZpY2F0ZV9yZXZva2VkOiA0NCxcbiAgY2VydGlmaWNhdGVfZXhwaXJlZDogNDUsXG4gIGNlcnRpZmljYXRlX3Vua25vd246IDQ2LFxuICBpbGxlZ2FsX3BhcmFtZXRlcjogNDcsXG4gIHVua25vd25fY2E6IDQ4LFxuICBhY2Nlc3NfZGVuaWVkOiA0OSxcbiAgZGVjb2RlX2Vycm9yOiA1MCxcbiAgZGVjcnlwdF9lcnJvcjogNTEsXG4gIGV4cG9ydF9yZXN0cmljdGlvbjogNjAsXG4gIHByb3RvY29sX3ZlcnNpb246IDcwLFxuICBpbnN1ZmZpY2llbnRfc2VjdXJpdHk6IDcxLFxuICBpbnRlcm5hbF9lcnJvcjogODAsXG4gIHVzZXJfY2FuY2VsZWQ6IDkwLFxuICBub19yZW5lZ290aWF0aW9uOiAxMDBcbn07XG5cbi8qKlxuICogVExTIEhlYXJ0YmVhdCBNZXNzYWdlIHR5cGVzLlxuICogZW51bSB7XG4gKiAgIGhlYXJ0YmVhdF9yZXF1ZXN0KDEpLFxuICogICBoZWFydGJlYXRfcmVzcG9uc2UoMiksXG4gKiAgICgyNTUpXG4gKiB9IEhlYXJ0YmVhdE1lc3NhZ2VUeXBlO1xuICovXG50bHMuSGVhcnRiZWF0TWVzc2FnZVR5cGUgPSB7XG4gIGhlYXJ0YmVhdF9yZXF1ZXN0OiAxLFxuICBoZWFydGJlYXRfcmVzcG9uc2U6IDJcbn07XG5cbi8qKlxuICogU3VwcG9ydGVkIGNpcGhlciBzdWl0ZXMuXG4gKi9cbnRscy5DaXBoZXJTdWl0ZXMgPSB7fTtcblxuLyoqXG4gKiBHZXRzIGEgc3VwcG9ydGVkIGNpcGhlciBzdWl0ZSBmcm9tIGl0cyAyIGJ5dGUgSUQuXG4gKlxuICogQHBhcmFtIHR3b0J5dGVzIHR3byBieXRlcyBpbiBhIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBtYXRjaGluZyBzdXBwb3J0ZWQgY2lwaGVyIHN1aXRlIG9yIG51bGwuXG4gKi9cbnRscy5nZXRDaXBoZXJTdWl0ZSA9IGZ1bmN0aW9uKHR3b0J5dGVzKSB7XG4gIHZhciBydmFsID0gbnVsbDtcbiAgZm9yKHZhciBrZXkgaW4gdGxzLkNpcGhlclN1aXRlcykge1xuICAgIHZhciBjcyA9IHRscy5DaXBoZXJTdWl0ZXNba2V5XTtcbiAgICBpZihjcy5pZFswXSA9PT0gdHdvQnl0ZXMuY2hhckNvZGVBdCgwKSAmJlxuICAgICAgY3MuaWRbMV0gPT09IHR3b0J5dGVzLmNoYXJDb2RlQXQoMSkpIHtcbiAgICAgIHJ2YWwgPSBjcztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gYW4gdW5leHBlY3RlZCByZWNvcmQgaXMgZW5jb3VudGVyZWQuXG4gKlxuICogQHBhcmFtIGMgdGhlIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0gcmVjb3JkIHRoZSByZWNvcmQuXG4gKi9cbnRscy5oYW5kbGVVbmV4cGVjdGVkID0gZnVuY3Rpb24oYywgcmVjb3JkKSB7XG4gIC8vIGlmIGNvbm5lY3Rpb24gaXMgY2xpZW50IGFuZCBjbG9zZWQsIGlnbm9yZSB1bmV4cGVjdGVkIG1lc3NhZ2VzXG4gIHZhciBpZ25vcmUgPSAoIWMub3BlbiAmJiBjLmVudGl0eSA9PT0gdGxzLkNvbm5lY3Rpb25FbmQuY2xpZW50KTtcbiAgaWYoIWlnbm9yZSkge1xuICAgIGMuZXJyb3IoYywge1xuICAgICAgbWVzc2FnZTogJ1VuZXhwZWN0ZWQgbWVzc2FnZS4gUmVjZWl2ZWQgVExTIHJlY29yZCBvdXQgb2Ygb3JkZXIuJyxcbiAgICAgIHNlbmQ6IHRydWUsXG4gICAgICBhbGVydDoge1xuICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLnVuZXhwZWN0ZWRfbWVzc2FnZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGEgY2xpZW50IHJlY2VpdmVzIGEgSGVsbG9SZXF1ZXN0IHJlY29yZC5cbiAqXG4gKiBAcGFyYW0gYyB0aGUgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSByZWNvcmQgdGhlIHJlY29yZC5cbiAqIEBwYXJhbSBsZW5ndGggdGhlIGxlbmd0aCBvZiB0aGUgaGFuZHNoYWtlIG1lc3NhZ2UuXG4gKi9cbnRscy5oYW5kbGVIZWxsb1JlcXVlc3QgPSBmdW5jdGlvbihjLCByZWNvcmQsIGxlbmd0aCkge1xuICAvLyBpZ25vcmUgcmVuZWdvdGlhdGlvbiByZXF1ZXN0cyBmcm9tIHRoZSBzZXJ2ZXIgZHVyaW5nIGEgaGFuZHNoYWtlLCBidXRcbiAgLy8gaWYgaGFuZHNoYWtpbmcsIHNlbmQgYSB3YXJuaW5nIGFsZXJ0IHRoYXQgcmVuZWdvdGF0aW9uIGlzIGRlbmllZFxuICBpZighYy5oYW5kc2hha2luZyAmJiBjLmhhbmRzaGFrZXMgPiAwKSB7XG4gICAgLy8gc2VuZCBhbGVydCB3YXJuaW5nXG4gICAgdGxzLnF1ZXVlKGMsIHRscy5jcmVhdGVBbGVydChjLCB7XG4gICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC53YXJuaW5nLFxuICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24ubm9fcmVuZWdvdGlhdGlvblxuICAgIH0pKTtcbiAgICB0bHMuZmx1c2goYyk7XG4gIH1cblxuICAvLyBjb250aW51ZVxuICBjLnByb2Nlc3MoKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgaGVsbG8gbWVzc2FnZSBmcm9tIGEgQ2xpZW50SGVsbG8gb3IgU2VydmVySGVsbG8gcmVjb3JkLlxuICpcbiAqIEBwYXJhbSByZWNvcmQgdGhlIHJlY29yZCB0byBwYXJzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwYXJzZWQgbWVzc2FnZS5cbiAqL1xudGxzLnBhcnNlSGVsbG9NZXNzYWdlID0gZnVuY3Rpb24oYywgcmVjb3JkLCBsZW5ndGgpIHtcbiAgdmFyIG1zZyA9IG51bGw7XG5cbiAgdmFyIGNsaWVudCA9IChjLmVudGl0eSA9PT0gdGxzLkNvbm5lY3Rpb25FbmQuY2xpZW50KTtcblxuICAvLyBtaW5pbXVtIG9mIDM4IGJ5dGVzIGluIG1lc3NhZ2VcbiAgaWYobGVuZ3RoIDwgMzgpIHtcbiAgICBjLmVycm9yKGMsIHtcbiAgICAgIG1lc3NhZ2U6IGNsaWVudCA/XG4gICAgICAgICdJbnZhbGlkIFNlcnZlckhlbGxvIG1lc3NhZ2UuIE1lc3NhZ2UgdG9vIHNob3J0LicgOlxuICAgICAgICAnSW52YWxpZCBDbGllbnRIZWxsbyBtZXNzYWdlLiBNZXNzYWdlIHRvbyBzaG9ydC4nLFxuICAgICAgc2VuZDogdHJ1ZSxcbiAgICAgIGFsZXJ0OiB7XG4gICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwuZmF0YWwsXG4gICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24uaWxsZWdhbF9wYXJhbWV0ZXJcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgJ3JlbWFpbmluZycgdG8gY2FsY3VsYXRlICMgb2YgcmVtYWluaW5nIGJ5dGVzIGluIHRoZSBtZXNzYWdlXG4gICAgdmFyIGIgPSByZWNvcmQuZnJhZ21lbnQ7XG4gICAgdmFyIHJlbWFpbmluZyA9IGIubGVuZ3RoKCk7XG4gICAgbXNnID0ge1xuICAgICAgdmVyc2lvbjoge1xuICAgICAgICBtYWpvcjogYi5nZXRCeXRlKCksXG4gICAgICAgIG1pbm9yOiBiLmdldEJ5dGUoKVxuICAgICAgfSxcbiAgICAgIHJhbmRvbTogZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoYi5nZXRCeXRlcygzMikpLFxuICAgICAgc2Vzc2lvbl9pZDogcmVhZFZlY3RvcihiLCAxKSxcbiAgICAgIGV4dGVuc2lvbnM6IFtdXG4gICAgfTtcbiAgICBpZihjbGllbnQpIHtcbiAgICAgIG1zZy5jaXBoZXJfc3VpdGUgPSBiLmdldEJ5dGVzKDIpO1xuICAgICAgbXNnLmNvbXByZXNzaW9uX21ldGhvZCA9IGIuZ2V0Qnl0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtc2cuY2lwaGVyX3N1aXRlcyA9IHJlYWRWZWN0b3IoYiwgMik7XG4gICAgICBtc2cuY29tcHJlc3Npb25fbWV0aG9kcyA9IHJlYWRWZWN0b3IoYiwgMSk7XG4gICAgfVxuXG4gICAgLy8gcmVhZCBleHRlbnNpb25zIGlmIHRoZXJlIGFyZSBhbnkgYnl0ZXMgbGVmdCBpbiB0aGUgbWVzc2FnZVxuICAgIHJlbWFpbmluZyA9IGxlbmd0aCAtIChyZW1haW5pbmcgLSBiLmxlbmd0aCgpKTtcbiAgICBpZihyZW1haW5pbmcgPiAwKSB7XG4gICAgICAvLyBwYXJzZSBleHRlbnNpb25zXG4gICAgICB2YXIgZXh0cyA9IHJlYWRWZWN0b3IoYiwgMik7XG4gICAgICB3aGlsZShleHRzLmxlbmd0aCgpID4gMCkge1xuICAgICAgICBtc2cuZXh0ZW5zaW9ucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBbZXh0cy5nZXRCeXRlKCksIGV4dHMuZ2V0Qnl0ZSgpXSxcbiAgICAgICAgICBkYXRhOiByZWFkVmVjdG9yKGV4dHMsIDIpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBtYWtlIGV4dGVuc2lvbiBzdXBwb3J0IG1vZHVsYXJcbiAgICAgIGlmKCFjbGllbnQpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1zZy5leHRlbnNpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGV4dCA9IG1zZy5leHRlbnNpb25zW2ldO1xuXG4gICAgICAgICAgLy8gc3VwcG9ydCBTTkkgZXh0ZW5zaW9uXG4gICAgICAgICAgaWYoZXh0LnR5cGVbMF0gPT09IDB4MDAgJiYgZXh0LnR5cGVbMV0gPT09IDB4MDApIHtcbiAgICAgICAgICAgIC8vIGdldCBzZXJ2ZXIgbmFtZSBsaXN0XG4gICAgICAgICAgICB2YXIgc25sID0gcmVhZFZlY3RvcihleHQuZGF0YSwgMik7XG4gICAgICAgICAgICB3aGlsZShzbmwubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgICAgICAgIC8vIHJlYWQgc2VydmVyIG5hbWUgdHlwZVxuICAgICAgICAgICAgICB2YXIgc25UeXBlID0gc25sLmdldEJ5dGUoKTtcblxuICAgICAgICAgICAgICAvLyBvbmx5IEhvc3ROYW1lIHR5cGUgKDB4MDApIGlzIGtub3duLCBicmVhayBvdXQgaWZcbiAgICAgICAgICAgICAgLy8gYW5vdGhlciB0eXBlIGlzIGRldGVjdGVkXG4gICAgICAgICAgICAgIGlmKHNuVHlwZSAhPT0gMHgwMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gYWRkIGhvc3QgbmFtZSB0byBzZXJ2ZXIgbmFtZSBsaXN0XG4gICAgICAgICAgICAgIGMuc2Vzc2lvbi5leHRlbnNpb25zLnNlcnZlcl9uYW1lLnNlcnZlck5hbWVMaXN0LnB1c2goXG4gICAgICAgICAgICAgICAgcmVhZFZlY3RvcihzbmwsIDIpLmdldEJ5dGVzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHZlcnNpb24gYWxyZWFkeSBzZXQsIGRvIG5vdCBhbGxvdyB2ZXJzaW9uIGNoYW5nZVxuICAgIGlmKGMuc2Vzc2lvbi52ZXJzaW9uKSB7XG4gICAgICBpZihtc2cudmVyc2lvbi5tYWpvciAhPT0gYy5zZXNzaW9uLnZlcnNpb24ubWFqb3IgfHxcbiAgICAgICAgbXNnLnZlcnNpb24ubWlub3IgIT09IGMuc2Vzc2lvbi52ZXJzaW9uLm1pbm9yKSB7XG4gICAgICAgIHJldHVybiBjLmVycm9yKGMsIHtcbiAgICAgICAgICBtZXNzYWdlOiAnVExTIHZlcnNpb24gY2hhbmdlIGlzIGRpc2FsbG93ZWQgZHVyaW5nIHJlbmVnb3RpYXRpb24uJyxcbiAgICAgICAgICBzZW5kOiB0cnVlLFxuICAgICAgICAgIGFsZXJ0OiB7XG4gICAgICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHRscy5BbGVydC5EZXNjcmlwdGlvbi5wcm90b2NvbF92ZXJzaW9uXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIGNob3NlbiAoU2VydmVySGVsbG8pIGNpcGhlciBzdWl0ZVxuICAgIGlmKGNsaWVudCkge1xuICAgICAgLy8gRklYTUU6IHNob3VsZCBiZSBjaGVja2luZyBjb25maWd1cmVkIGFjY2VwdGFibGUgY2lwaGVyIHN1aXRlc1xuICAgICAgYy5zZXNzaW9uLmNpcGhlclN1aXRlID0gdGxzLmdldENpcGhlclN1aXRlKG1zZy5jaXBoZXJfc3VpdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBnZXQgYSBzdXBwb3J0ZWQgcHJlZmVycmVkIChDbGllbnRIZWxsbykgY2lwaGVyIHN1aXRlXG4gICAgICAvLyBjaG9vc2UgdGhlIGZpcnN0IHN1cHBvcnRlZCBjaXBoZXIgc3VpdGVcbiAgICAgIHZhciB0bXAgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihtc2cuY2lwaGVyX3N1aXRlcy5ieXRlcygpKTtcbiAgICAgIHdoaWxlKHRtcC5sZW5ndGgoKSA+IDApIHtcbiAgICAgICAgLy8gRklYTUU6IHNob3VsZCBiZSBjaGVja2luZyBjb25maWd1cmVkIGFjY2VwdGFibGUgc3VpdGVzXG4gICAgICAgIC8vIGNpcGhlciBzdWl0ZXMgdGFrZSB1cCAyIGJ5dGVzXG4gICAgICAgIGMuc2Vzc2lvbi5jaXBoZXJTdWl0ZSA9IHRscy5nZXRDaXBoZXJTdWl0ZSh0bXAuZ2V0Qnl0ZXMoMikpO1xuICAgICAgICBpZihjLnNlc3Npb24uY2lwaGVyU3VpdGUgIT09IG51bGwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNpcGhlciBzdWl0ZSBub3Qgc3VwcG9ydGVkXG4gICAgaWYoYy5zZXNzaW9uLmNpcGhlclN1aXRlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gYy5lcnJvcihjLCB7XG4gICAgICAgIG1lc3NhZ2U6ICdObyBjaXBoZXIgc3VpdGVzIGluIGNvbW1vbi4nLFxuICAgICAgICBzZW5kOiB0cnVlLFxuICAgICAgICBhbGVydDoge1xuICAgICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwuZmF0YWwsXG4gICAgICAgICAgZGVzY3JpcHRpb246IHRscy5BbGVydC5EZXNjcmlwdGlvbi5oYW5kc2hha2VfZmFpbHVyZVxuICAgICAgICB9LFxuICAgICAgICBjaXBoZXJTdWl0ZTogZm9yZ2UudXRpbC5ieXRlc1RvSGV4KG1zZy5jaXBoZXJfc3VpdGUpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBoYW5kbGUgY29tcHJlc3Npb24gbWV0aG9kc1xuICAgIGlmKGNsaWVudCkge1xuICAgICAgYy5zZXNzaW9uLmNvbXByZXNzaW9uTWV0aG9kID0gbXNnLmNvbXByZXNzaW9uX21ldGhvZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm8gY29tcHJlc3Npb25cbiAgICAgIGMuc2Vzc2lvbi5jb21wcmVzc2lvbk1ldGhvZCA9IHRscy5Db21wcmVzc2lvbk1ldGhvZC5ub25lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtc2c7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgc2VjdXJpdHkgcGFyYW1ldGVycyBmb3IgdGhlIGdpdmVuIGNvbm5lY3Rpb24gYmFzZWQgb24gdGhlIGdpdmVuXG4gKiBoZWxsbyBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBjIHRoZSBUTFMgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSBtc2cgdGhlIGhlbGxvIG1lc3NhZ2UuXG4gKi9cbnRscy5jcmVhdGVTZWN1cml0eVBhcmFtZXRlcnMgPSBmdW5jdGlvbihjLCBtc2cpIHtcbiAgLyogTm90ZTogc2VjdXJpdHkgcGFyYW1zIGFyZSBmcm9tIFRMUyAxLjIsIHNvbWUgdmFsdWVzIGxpa2UgcHJmX2FsZ29yaXRobVxuICBhcmUgaWdub3JlZCBmb3IgVExTIDEuMC8xLjEgYW5kIHRoZSBidWlsdGluIGFzIHNwZWNpZmllZCBpbiB0aGUgc3BlYyBpc1xuICB1c2VkLiAqL1xuXG4gIC8vIFRPRE86IGhhbmRsZSBvdGhlciBvcHRpb25zIGZyb20gc2VydmVyIHdoZW4gbW9yZSBzdXBwb3J0ZWRcblxuICAvLyBnZXQgY2xpZW50IGFuZCBzZXJ2ZXIgcmFuZG9tc1xuICB2YXIgY2xpZW50ID0gKGMuZW50aXR5ID09PSB0bHMuQ29ubmVjdGlvbkVuZC5jbGllbnQpO1xuICB2YXIgbXNnUmFuZG9tID0gbXNnLnJhbmRvbS5ieXRlcygpO1xuICB2YXIgY1JhbmRvbSA9IGNsaWVudCA/IGMuc2Vzc2lvbi5zcC5jbGllbnRfcmFuZG9tIDogbXNnUmFuZG9tO1xuICB2YXIgc1JhbmRvbSA9IGNsaWVudCA/IG1zZ1JhbmRvbSA6IHRscy5jcmVhdGVSYW5kb20oKS5nZXRCeXRlcygpO1xuXG4gIC8vIGNyZWF0ZSBuZXcgc2VjdXJpdHkgcGFyYW1ldGVyc1xuICBjLnNlc3Npb24uc3AgPSB7XG4gICAgZW50aXR5OiBjLmVudGl0eSxcbiAgICBwcmZfYWxnb3JpdGhtOiB0bHMuUFJGQWxnb3JpdGhtLnRsc19wcmZfc2hhMjU2LFxuICAgIGJ1bGtfY2lwaGVyX2FsZ29yaXRobTogbnVsbCxcbiAgICBjaXBoZXJfdHlwZTogbnVsbCxcbiAgICBlbmNfa2V5X2xlbmd0aDogbnVsbCxcbiAgICBibG9ja19sZW5ndGg6IG51bGwsXG4gICAgZml4ZWRfaXZfbGVuZ3RoOiBudWxsLFxuICAgIHJlY29yZF9pdl9sZW5ndGg6IG51bGwsXG4gICAgbWFjX2FsZ29yaXRobTogbnVsbCxcbiAgICBtYWNfbGVuZ3RoOiBudWxsLFxuICAgIG1hY19rZXlfbGVuZ3RoOiBudWxsLFxuICAgIGNvbXByZXNzaW9uX2FsZ29yaXRobTogYy5zZXNzaW9uLmNvbXByZXNzaW9uTWV0aG9kLFxuICAgIHByZV9tYXN0ZXJfc2VjcmV0OiBudWxsLFxuICAgIG1hc3Rlcl9zZWNyZXQ6IG51bGwsXG4gICAgY2xpZW50X3JhbmRvbTogY1JhbmRvbSxcbiAgICBzZXJ2ZXJfcmFuZG9tOiBzUmFuZG9tXG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGEgY2xpZW50IHJlY2VpdmVzIGEgU2VydmVySGVsbG8gcmVjb3JkLlxuICpcbiAqIFdoZW4gYSBTZXJ2ZXJIZWxsbyBtZXNzYWdlIHdpbGwgYmUgc2VudDpcbiAqICAgVGhlIHNlcnZlciB3aWxsIHNlbmQgdGhpcyBtZXNzYWdlIGluIHJlc3BvbnNlIHRvIGEgY2xpZW50IGhlbGxvIG1lc3NhZ2VcbiAqICAgd2hlbiBpdCB3YXMgYWJsZSB0byBmaW5kIGFuIGFjY2VwdGFibGUgc2V0IG9mIGFsZ29yaXRobXMuIElmIGl0IGNhbm5vdFxuICogICBmaW5kIHN1Y2ggYSBtYXRjaCwgaXQgd2lsbCByZXNwb25kIHdpdGggYSBoYW5kc2hha2UgZmFpbHVyZSBhbGVydC5cbiAqXG4gKiB1aW50MjQgbGVuZ3RoO1xuICogc3RydWN0IHtcbiAqICAgUHJvdG9jb2xWZXJzaW9uIHNlcnZlcl92ZXJzaW9uO1xuICogICBSYW5kb20gcmFuZG9tO1xuICogICBTZXNzaW9uSUQgc2Vzc2lvbl9pZDtcbiAqICAgQ2lwaGVyU3VpdGUgY2lwaGVyX3N1aXRlO1xuICogICBDb21wcmVzc2lvbk1ldGhvZCBjb21wcmVzc2lvbl9tZXRob2Q7XG4gKiAgIHNlbGVjdChleHRlbnNpb25zX3ByZXNlbnQpIHtcbiAqICAgICBjYXNlIGZhbHNlOlxuICogICAgICAgc3RydWN0IHt9O1xuICogICAgIGNhc2UgdHJ1ZTpcbiAqICAgICAgIEV4dGVuc2lvbiBleHRlbnNpb25zPDAuLjJeMTYtMT47XG4gKiAgIH07XG4gKiB9IFNlcnZlckhlbGxvO1xuICpcbiAqIEBwYXJhbSBjIHRoZSBjb25uZWN0aW9uLlxuICogQHBhcmFtIHJlY29yZCB0aGUgcmVjb3JkLlxuICogQHBhcmFtIGxlbmd0aCB0aGUgbGVuZ3RoIG9mIHRoZSBoYW5kc2hha2UgbWVzc2FnZS5cbiAqL1xudGxzLmhhbmRsZVNlcnZlckhlbGxvID0gZnVuY3Rpb24oYywgcmVjb3JkLCBsZW5ndGgpIHtcbiAgdmFyIG1zZyA9IHRscy5wYXJzZUhlbGxvTWVzc2FnZShjLCByZWNvcmQsIGxlbmd0aCk7XG4gIGlmKGMuZmFpbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGVuc3VyZSBzZXJ2ZXIgdmVyc2lvbiBpcyBjb21wYXRpYmxlXG4gIGlmKG1zZy52ZXJzaW9uLm1pbm9yIDw9IGMudmVyc2lvbi5taW5vcikge1xuICAgIGMudmVyc2lvbi5taW5vciA9IG1zZy52ZXJzaW9uLm1pbm9yO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjLmVycm9yKGMsIHtcbiAgICAgIG1lc3NhZ2U6ICdJbmNvbXBhdGlibGUgVExTIHZlcnNpb24uJyxcbiAgICAgIHNlbmQ6IHRydWUsXG4gICAgICBhbGVydDoge1xuICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLnByb3RvY29sX3ZlcnNpb25cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIGluZGljYXRlIHNlc3Npb24gdmVyc2lvbiBoYXMgYmVlbiBzZXRcbiAgYy5zZXNzaW9uLnZlcnNpb24gPSBjLnZlcnNpb247XG5cbiAgLy8gZ2V0IHRoZSBzZXNzaW9uIElEIGZyb20gdGhlIG1lc3NhZ2VcbiAgdmFyIHNlc3Npb25JZCA9IG1zZy5zZXNzaW9uX2lkLmJ5dGVzKCk7XG5cbiAgLy8gaWYgdGhlIHNlc3Npb24gSUQgaXMgbm90IGJsYW5rIGFuZCBtYXRjaGVzIHRoZSBjYWNoZWQgb25lLCByZXN1bWVcbiAgLy8gdGhlIHNlc3Npb25cbiAgaWYoc2Vzc2lvbklkLmxlbmd0aCA+IDAgJiYgc2Vzc2lvbklkID09PSBjLnNlc3Npb24uaWQpIHtcbiAgICAvLyByZXN1bWluZyBzZXNzaW9uLCBleHBlY3QgYSBDaGFuZ2VDaXBoZXJTcGVjIG5leHRcbiAgICBjLmV4cGVjdCA9IFNDQztcbiAgICBjLnNlc3Npb24ucmVzdW1pbmcgPSB0cnVlO1xuXG4gICAgLy8gZ2V0IG5ldyBzZXJ2ZXIgcmFuZG9tXG4gICAgYy5zZXNzaW9uLnNwLnNlcnZlcl9yYW5kb20gPSBtc2cucmFuZG9tLmJ5dGVzKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm90IHJlc3VtaW5nLCBleHBlY3QgYSBzZXJ2ZXIgQ2VydGlmaWNhdGUgbWVzc2FnZSBuZXh0XG4gICAgYy5leHBlY3QgPSBTQ0U7XG4gICAgYy5zZXNzaW9uLnJlc3VtaW5nID0gZmFsc2U7XG5cbiAgICAvLyBjcmVhdGUgbmV3IHNlY3VyaXR5IHBhcmFtZXRlcnNcbiAgICB0bHMuY3JlYXRlU2VjdXJpdHlQYXJhbWV0ZXJzKGMsIG1zZyk7XG4gIH1cblxuICAvLyBzZXQgbmV3IHNlc3Npb24gSURcbiAgYy5zZXNzaW9uLmlkID0gc2Vzc2lvbklkO1xuXG4gIC8vIGNvbnRpbnVlXG4gIGMucHJvY2VzcygpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBhIHNlcnZlciByZWNlaXZlcyBhIENsaWVudEhlbGxvIHJlY29yZC5cbiAqXG4gKiBXaGVuIGEgQ2xpZW50SGVsbG8gbWVzc2FnZSB3aWxsIGJlIHNlbnQ6XG4gKiAgIFdoZW4gYSBjbGllbnQgZmlyc3QgY29ubmVjdHMgdG8gYSBzZXJ2ZXIgaXQgaXMgcmVxdWlyZWQgdG8gc2VuZCB0aGVcbiAqICAgY2xpZW50IGhlbGxvIGFzIGl0cyBmaXJzdCBtZXNzYWdlLiBUaGUgY2xpZW50IGNhbiBhbHNvIHNlbmQgYSBjbGllbnRcbiAqICAgaGVsbG8gaW4gcmVzcG9uc2UgdG8gYSBoZWxsbyByZXF1ZXN0IG9yIG9uIGl0cyBvd24gaW5pdGlhdGl2ZSBpbiBvcmRlclxuICogICB0byByZW5lZ290aWF0ZSB0aGUgc2VjdXJpdHkgcGFyYW1ldGVycyBpbiBhbiBleGlzdGluZyBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSBjIHRoZSBjb25uZWN0aW9uLlxuICogQHBhcmFtIHJlY29yZCB0aGUgcmVjb3JkLlxuICogQHBhcmFtIGxlbmd0aCB0aGUgbGVuZ3RoIG9mIHRoZSBoYW5kc2hha2UgbWVzc2FnZS5cbiAqL1xudGxzLmhhbmRsZUNsaWVudEhlbGxvID0gZnVuY3Rpb24oYywgcmVjb3JkLCBsZW5ndGgpIHtcbiAgdmFyIG1zZyA9IHRscy5wYXJzZUhlbGxvTWVzc2FnZShjLCByZWNvcmQsIGxlbmd0aCk7XG4gIGlmKGMuZmFpbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGdldCB0aGUgc2Vzc2lvbiBJRCBmcm9tIHRoZSBtZXNzYWdlXG4gIHZhciBzZXNzaW9uSWQgPSBtc2cuc2Vzc2lvbl9pZC5ieXRlcygpO1xuXG4gIC8vIHNlZSBpZiB0aGUgZ2l2ZW4gc2Vzc2lvbiBJRCBpcyBpbiB0aGUgY2FjaGVcbiAgdmFyIHNlc3Npb24gPSBudWxsO1xuICBpZihjLnNlc3Npb25DYWNoZSkge1xuICAgIHNlc3Npb24gPSBjLnNlc3Npb25DYWNoZS5nZXRTZXNzaW9uKHNlc3Npb25JZCk7XG4gICAgaWYoc2Vzc2lvbiA9PT0gbnVsbCkge1xuICAgICAgLy8gc2Vzc2lvbiBJRCBub3QgZm91bmRcbiAgICAgIHNlc3Npb25JZCA9ICcnO1xuICAgIH0gZWxzZSBpZihzZXNzaW9uLnZlcnNpb24ubWFqb3IgIT09IG1zZy52ZXJzaW9uLm1ham9yIHx8XG4gICAgICBzZXNzaW9uLnZlcnNpb24ubWlub3IgPiBtc2cudmVyc2lvbi5taW5vcikge1xuICAgICAgLy8gaWYgc2Vzc2lvbiB2ZXJzaW9uIGlzIGluY29tcGF0aWJsZSB3aXRoIGNsaWVudCB2ZXJzaW9uLCBkbyBub3QgcmVzdW1lXG4gICAgICBzZXNzaW9uID0gbnVsbDtcbiAgICAgIHNlc3Npb25JZCA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIC8vIG5vIHNlc3Npb24gZm91bmQgdG8gcmVzdW1lLCBnZW5lcmF0ZSBhIG5ldyBzZXNzaW9uIElEXG4gIGlmKHNlc3Npb25JZC5sZW5ndGggPT09IDApIHtcbiAgICBzZXNzaW9uSWQgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMoMzIpO1xuICB9XG5cbiAgLy8gdXBkYXRlIHNlc3Npb25cbiAgYy5zZXNzaW9uLmlkID0gc2Vzc2lvbklkO1xuICBjLnNlc3Npb24uY2xpZW50SGVsbG9WZXJzaW9uID0gbXNnLnZlcnNpb247XG4gIGMuc2Vzc2lvbi5zcCA9IHt9O1xuICBpZihzZXNzaW9uKSB7XG4gICAgLy8gdXNlIHZlcnNpb24gYW5kIHNlY3VyaXR5IHBhcmFtZXRlcnMgZnJvbSByZXN1bWVkIHNlc3Npb25cbiAgICBjLnZlcnNpb24gPSBjLnNlc3Npb24udmVyc2lvbiA9IHNlc3Npb24udmVyc2lvbjtcbiAgICBjLnNlc3Npb24uc3AgPSBzZXNzaW9uLnNwO1xuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBoaWdoZXN0IGNvbXBhdGlibGUgbWlub3IgdmVyc2lvblxuICAgIHZhciB2ZXJzaW9uO1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCB0bHMuU3VwcG9ydGVkVmVyc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZlcnNpb24gPSB0bHMuU3VwcG9ydGVkVmVyc2lvbnNbaV07XG4gICAgICBpZih2ZXJzaW9uLm1pbm9yIDw9IG1zZy52ZXJzaW9uLm1pbm9yKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjLnZlcnNpb24gPSB7bWFqb3I6IHZlcnNpb24ubWFqb3IsIG1pbm9yOiB2ZXJzaW9uLm1pbm9yfTtcbiAgICBjLnNlc3Npb24udmVyc2lvbiA9IGMudmVyc2lvbjtcbiAgfVxuXG4gIC8vIGlmIGEgc2Vzc2lvbiBpcyBzZXQsIHJlc3VtZSBpdFxuICBpZihzZXNzaW9uICE9PSBudWxsKSB7XG4gICAgLy8gcmVzdW1pbmcgc2Vzc2lvbiwgZXhwZWN0IGEgQ2hhbmdlQ2lwaGVyU3BlYyBuZXh0XG4gICAgYy5leHBlY3QgPSBDQ0M7XG4gICAgYy5zZXNzaW9uLnJlc3VtaW5nID0gdHJ1ZTtcblxuICAgIC8vIGdldCBuZXcgY2xpZW50IHJhbmRvbVxuICAgIGMuc2Vzc2lvbi5zcC5jbGllbnRfcmFuZG9tID0gbXNnLnJhbmRvbS5ieXRlcygpO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vdCByZXN1bWluZywgZXhwZWN0IGEgQ2VydGlmaWNhdGUgb3IgQ2xpZW50S2V5RXhjaGFuZ2VcbiAgICBjLmV4cGVjdCA9IChjLnZlcmlmeUNsaWVudCAhPT0gZmFsc2UpID8gQ0NFIDogQ0tFO1xuICAgIGMuc2Vzc2lvbi5yZXN1bWluZyA9IGZhbHNlO1xuXG4gICAgLy8gY3JlYXRlIG5ldyBzZWN1cml0eSBwYXJhbWV0ZXJzXG4gICAgdGxzLmNyZWF0ZVNlY3VyaXR5UGFyYW1ldGVycyhjLCBtc2cpO1xuICB9XG5cbiAgLy8gY29ubmVjdGlvbiBub3cgb3BlblxuICBjLm9wZW4gPSB0cnVlO1xuXG4gIC8vIHF1ZXVlIHNlcnZlciBoZWxsb1xuICB0bHMucXVldWUoYywgdGxzLmNyZWF0ZVJlY29yZChjLCB7XG4gICAgdHlwZTogdGxzLkNvbnRlbnRUeXBlLmhhbmRzaGFrZSxcbiAgICBkYXRhOiB0bHMuY3JlYXRlU2VydmVySGVsbG8oYylcbiAgfSkpO1xuXG4gIGlmKGMuc2Vzc2lvbi5yZXN1bWluZykge1xuICAgIC8vIHF1ZXVlIGNoYW5nZSBjaXBoZXIgc3BlYyBtZXNzYWdlXG4gICAgdGxzLnF1ZXVlKGMsIHRscy5jcmVhdGVSZWNvcmQoYywge1xuICAgICAgdHlwZTogdGxzLkNvbnRlbnRUeXBlLmNoYW5nZV9jaXBoZXJfc3BlYyxcbiAgICAgIGRhdGE6IHRscy5jcmVhdGVDaGFuZ2VDaXBoZXJTcGVjKClcbiAgICB9KSk7XG5cbiAgICAvLyBjcmVhdGUgcGVuZGluZyBzdGF0ZVxuICAgIGMuc3RhdGUucGVuZGluZyA9IHRscy5jcmVhdGVDb25uZWN0aW9uU3RhdGUoYyk7XG5cbiAgICAvLyBjaGFuZ2UgY3VycmVudCB3cml0ZSBzdGF0ZSB0byBwZW5kaW5nIHdyaXRlIHN0YXRlXG4gICAgYy5zdGF0ZS5jdXJyZW50LndyaXRlID0gYy5zdGF0ZS5wZW5kaW5nLndyaXRlO1xuXG4gICAgLy8gcXVldWUgZmluaXNoZWRcbiAgICB0bHMucXVldWUoYywgdGxzLmNyZWF0ZVJlY29yZChjLCB7XG4gICAgICB0eXBlOiB0bHMuQ29udGVudFR5cGUuaGFuZHNoYWtlLFxuICAgICAgZGF0YTogdGxzLmNyZWF0ZUZpbmlzaGVkKGMpXG4gICAgfSkpO1xuICB9IGVsc2Uge1xuICAgIC8vIHF1ZXVlIHNlcnZlciBjZXJ0aWZpY2F0ZVxuICAgIHRscy5xdWV1ZShjLCB0bHMuY3JlYXRlUmVjb3JkKGMsIHtcbiAgICAgIHR5cGU6IHRscy5Db250ZW50VHlwZS5oYW5kc2hha2UsXG4gICAgICBkYXRhOiB0bHMuY3JlYXRlQ2VydGlmaWNhdGUoYylcbiAgICB9KSk7XG5cbiAgICBpZighYy5mYWlsKSB7XG4gICAgICAvLyBxdWV1ZSBzZXJ2ZXIga2V5IGV4Y2hhbmdlXG4gICAgICB0bHMucXVldWUoYywgdGxzLmNyZWF0ZVJlY29yZChjLCB7XG4gICAgICAgIHR5cGU6IHRscy5Db250ZW50VHlwZS5oYW5kc2hha2UsXG4gICAgICAgIGRhdGE6IHRscy5jcmVhdGVTZXJ2ZXJLZXlFeGNoYW5nZShjKVxuICAgICAgfSkpO1xuXG4gICAgICAvLyByZXF1ZXN0IGNsaWVudCBjZXJ0aWZpY2F0ZSBpZiBzZXRcbiAgICAgIGlmKGMudmVyaWZ5Q2xpZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAvLyBxdWV1ZSBjZXJ0aWZpY2F0ZSByZXF1ZXN0XG4gICAgICAgIHRscy5xdWV1ZShjLCB0bHMuY3JlYXRlUmVjb3JkKGMsIHtcbiAgICAgICAgICB0eXBlOiB0bHMuQ29udGVudFR5cGUuaGFuZHNoYWtlLFxuICAgICAgICAgIGRhdGE6IHRscy5jcmVhdGVDZXJ0aWZpY2F0ZVJlcXVlc3QoYylcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBxdWV1ZSBzZXJ2ZXIgaGVsbG8gZG9uZVxuICAgICAgdGxzLnF1ZXVlKGMsIHRscy5jcmVhdGVSZWNvcmQoYywge1xuICAgICAgICB0eXBlOiB0bHMuQ29udGVudFR5cGUuaGFuZHNoYWtlLFxuICAgICAgICBkYXRhOiB0bHMuY3JlYXRlU2VydmVySGVsbG9Eb25lKGMpXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG5cbiAgLy8gc2VuZCByZWNvcmRzXG4gIHRscy5mbHVzaChjKTtcblxuICAvLyBjb250aW51ZVxuICBjLnByb2Nlc3MoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gYSBjbGllbnQgcmVjZWl2ZXMgYSBDZXJ0aWZpY2F0ZSByZWNvcmQuXG4gKlxuICogV2hlbiB0aGlzIG1lc3NhZ2Ugd2lsbCBiZSBzZW50OlxuICogICBUaGUgc2VydmVyIG11c3Qgc2VuZCBhIGNlcnRpZmljYXRlIHdoZW5ldmVyIHRoZSBhZ3JlZWQtdXBvbiBrZXkgZXhjaGFuZ2VcbiAqICAgbWV0aG9kIGlzIG5vdCBhbiBhbm9ueW1vdXMgb25lLiBUaGlzIG1lc3NhZ2Ugd2lsbCBhbHdheXMgaW1tZWRpYXRlbHlcbiAqICAgZm9sbG93IHRoZSBzZXJ2ZXIgaGVsbG8gbWVzc2FnZS5cbiAqXG4gKiBNZWFuaW5nIG9mIHRoaXMgbWVzc2FnZTpcbiAqICAgVGhlIGNlcnRpZmljYXRlIHR5cGUgbXVzdCBiZSBhcHByb3ByaWF0ZSBmb3IgdGhlIHNlbGVjdGVkIGNpcGhlciBzdWl0ZSdzXG4gKiAgIGtleSBleGNoYW5nZSBhbGdvcml0aG0sIGFuZCBpcyBnZW5lcmFsbHkgYW4gWC41MDl2MyBjZXJ0aWZpY2F0ZS4gSXQgbXVzdFxuICogICBjb250YWluIGEga2V5IHdoaWNoIG1hdGNoZXMgdGhlIGtleSBleGNoYW5nZSBtZXRob2QsIGFzIGZvbGxvd3MuIFVubGVzc1xuICogICBvdGhlcndpc2Ugc3BlY2lmaWVkLCB0aGUgc2lnbmluZyBhbGdvcml0aG0gZm9yIHRoZSBjZXJ0aWZpY2F0ZSBtdXN0IGJlXG4gKiAgIHRoZSBzYW1lIGFzIHRoZSBhbGdvcml0aG0gZm9yIHRoZSBjZXJ0aWZpY2F0ZSBrZXkuIFVubGVzcyBvdGhlcndpc2VcbiAqICAgc3BlY2lmaWVkLCB0aGUgcHVibGljIGtleSBtYXkgYmUgb2YgYW55IGxlbmd0aC5cbiAqXG4gKiBvcGFxdWUgQVNOLjFDZXJ0PDEuLjJeMjQtMT47XG4gKiBzdHJ1Y3Qge1xuICogICBBU04uMUNlcnQgY2VydGlmaWNhdGVfbGlzdDwxLi4yXjI0LTE+O1xuICogfSBDZXJ0aWZpY2F0ZTtcbiAqXG4gKiBAcGFyYW0gYyB0aGUgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSByZWNvcmQgdGhlIHJlY29yZC5cbiAqIEBwYXJhbSBsZW5ndGggdGhlIGxlbmd0aCBvZiB0aGUgaGFuZHNoYWtlIG1lc3NhZ2UuXG4gKi9cbnRscy5oYW5kbGVDZXJ0aWZpY2F0ZSA9IGZ1bmN0aW9uKGMsIHJlY29yZCwgbGVuZ3RoKSB7XG4gIC8vIG1pbmltdW0gb2YgMyBieXRlcyBpbiBtZXNzYWdlXG4gIGlmKGxlbmd0aCA8IDMpIHtcbiAgICByZXR1cm4gYy5lcnJvcihjLCB7XG4gICAgICBtZXNzYWdlOiAnSW52YWxpZCBDZXJ0aWZpY2F0ZSBtZXNzYWdlLiBNZXNzYWdlIHRvbyBzaG9ydC4nLFxuICAgICAgc2VuZDogdHJ1ZSxcbiAgICAgIGFsZXJ0OiB7XG4gICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwuZmF0YWwsXG4gICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24uaWxsZWdhbF9wYXJhbWV0ZXJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBiID0gcmVjb3JkLmZyYWdtZW50O1xuICB2YXIgbXNnID0ge1xuICAgIGNlcnRpZmljYXRlX2xpc3Q6IHJlYWRWZWN0b3IoYiwgMylcbiAgfTtcblxuICAvKiBUaGUgc2VuZGVyJ3MgY2VydGlmaWNhdGUgd2lsbCBiZSBmaXJzdCBpbiB0aGUgbGlzdCAoY2hhaW4pLCBlYWNoXG4gICAgc3Vic2VxdWVudCBvbmUgdGhhdCBmb2xsb3dzIHdpbGwgY2VydGlmeSB0aGUgcHJldmlvdXMgb25lLCBidXQgcm9vdFxuICAgIGNlcnRpZmljYXRlcyAoc2VsZi1zaWduZWQpIHRoYXQgc3BlY2lmeSB0aGUgY2VydGlmaWNhdGUgYXV0aG9yaXR5IG1heVxuICAgIGJlIG9taXR0ZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCBjbGllbnRzIG11c3QgYWxyZWFkeSBwb3NzZXNzIGl0LiAqL1xuICB2YXIgY2VydCwgYXNuMTtcbiAgdmFyIGNlcnRzID0gW107XG4gIHRyeSB7XG4gICAgd2hpbGUobXNnLmNlcnRpZmljYXRlX2xpc3QubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAvLyBlYWNoIGVudHJ5IGluIG1zZy5jZXJ0aWZpY2F0ZV9saXN0IGlzIGEgdmVjdG9yIHdpdGggMyBsZW4gYnl0ZXNcbiAgICAgIGNlcnQgPSByZWFkVmVjdG9yKG1zZy5jZXJ0aWZpY2F0ZV9saXN0LCAzKTtcbiAgICAgIGFzbjEgPSBmb3JnZS5hc24xLmZyb21EZXIoY2VydCk7XG4gICAgICBjZXJ0ID0gZm9yZ2UucGtpLmNlcnRpZmljYXRlRnJvbUFzbjEoYXNuMSwgdHJ1ZSk7XG4gICAgICBjZXJ0cy5wdXNoKGNlcnQpO1xuICAgIH1cbiAgfSBjYXRjaChleCkge1xuICAgIHJldHVybiBjLmVycm9yKGMsIHtcbiAgICAgIG1lc3NhZ2U6ICdDb3VsZCBub3QgcGFyc2UgY2VydGlmaWNhdGUgbGlzdC4nLFxuICAgICAgY2F1c2U6IGV4LFxuICAgICAgc2VuZDogdHJ1ZSxcbiAgICAgIGFsZXJ0OiB7XG4gICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwuZmF0YWwsXG4gICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24uYmFkX2NlcnRpZmljYXRlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBlbnN1cmUgYXQgbGVhc3QgMSBjZXJ0aWZpY2F0ZSB3YXMgcHJvdmlkZWQgaWYgaW4gY2xpZW50LW1vZGVcbiAgLy8gb3IgaWYgdmVyaWZ5Q2xpZW50IHdhcyBzZXQgdG8gdHJ1ZSB0byByZXF1aXJlIGEgY2VydGlmaWNhdGVcbiAgLy8gKGFzIG9wcG9zZWQgdG8gJ29wdGlvbmFsJylcbiAgdmFyIGNsaWVudCA9IChjLmVudGl0eSA9PT0gdGxzLkNvbm5lY3Rpb25FbmQuY2xpZW50KTtcbiAgaWYoKGNsaWVudCB8fCBjLnZlcmlmeUNsaWVudCA9PT0gdHJ1ZSkgJiYgY2VydHMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gZXJyb3IsIG5vIGNlcnRpZmljYXRlXG4gICAgYy5lcnJvcihjLCB7XG4gICAgICBtZXNzYWdlOiBjbGllbnQgP1xuICAgICAgICAnTm8gc2VydmVyIGNlcnRpZmljYXRlIHByb3ZpZGVkLicgOlxuICAgICAgICAnTm8gY2xpZW50IGNlcnRpZmljYXRlIHByb3ZpZGVkLicsXG4gICAgICBzZW5kOiB0cnVlLFxuICAgICAgYWxlcnQ6IHtcbiAgICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC5mYXRhbCxcbiAgICAgICAgZGVzY3JpcHRpb246IHRscy5BbGVydC5EZXNjcmlwdGlvbi5pbGxlZ2FsX3BhcmFtZXRlclxuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYoY2VydHMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gbm8gY2VydHMgdG8gdmVyaWZ5XG4gICAgLy8gZXhwZWN0IGEgU2VydmVyS2V5RXhjaGFuZ2Ugb3IgQ2xpZW50S2V5RXhjaGFuZ2UgbWVzc2FnZSBuZXh0XG4gICAgYy5leHBlY3QgPSBjbGllbnQgPyBTS0UgOiBDS0U7XG4gIH0gZWxzZSB7XG4gICAgLy8gc2F2ZSBjZXJ0aWZpY2F0ZSBpbiBzZXNzaW9uXG4gICAgaWYoY2xpZW50KSB7XG4gICAgICBjLnNlc3Npb24uc2VydmVyQ2VydGlmaWNhdGUgPSBjZXJ0c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYy5zZXNzaW9uLmNsaWVudENlcnRpZmljYXRlID0gY2VydHNbMF07XG4gICAgfVxuXG4gICAgaWYodGxzLnZlcmlmeUNlcnRpZmljYXRlQ2hhaW4oYywgY2VydHMpKSB7XG4gICAgICAvLyBleHBlY3QgYSBTZXJ2ZXJLZXlFeGNoYW5nZSBvciBDbGllbnRLZXlFeGNoYW5nZSBtZXNzYWdlIG5leHRcbiAgICAgIGMuZXhwZWN0ID0gY2xpZW50ID8gU0tFIDogQ0tFO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbnRpbnVlXG4gIGMucHJvY2VzcygpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBhIGNsaWVudCByZWNlaXZlcyBhIFNlcnZlcktleUV4Y2hhbmdlIHJlY29yZC5cbiAqXG4gKiBXaGVuIHRoaXMgbWVzc2FnZSB3aWxsIGJlIHNlbnQ6XG4gKiAgIFRoaXMgbWVzc2FnZSB3aWxsIGJlIHNlbnQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHNlcnZlciBjZXJ0aWZpY2F0ZVxuICogICBtZXNzYWdlIChvciB0aGUgc2VydmVyIGhlbGxvIG1lc3NhZ2UsIGlmIHRoaXMgaXMgYW4gYW5vbnltb3VzXG4gKiAgIG5lZ290aWF0aW9uKS5cbiAqXG4gKiAgIFRoZSBzZXJ2ZXIga2V5IGV4Y2hhbmdlIG1lc3NhZ2UgaXMgc2VudCBieSB0aGUgc2VydmVyIG9ubHkgd2hlbiB0aGVcbiAqICAgc2VydmVyIGNlcnRpZmljYXRlIG1lc3NhZ2UgKGlmIHNlbnQpIGRvZXMgbm90IGNvbnRhaW4gZW5vdWdoIGRhdGEgdG9cbiAqICAgYWxsb3cgdGhlIGNsaWVudCB0byBleGNoYW5nZSBhIHByZW1hc3RlciBzZWNyZXQuXG4gKlxuICogTWVhbmluZyBvZiB0aGlzIG1lc3NhZ2U6XG4gKiAgIFRoaXMgbWVzc2FnZSBjb252ZXlzIGNyeXB0b2dyYXBoaWMgaW5mb3JtYXRpb24gdG8gYWxsb3cgdGhlIGNsaWVudCB0b1xuICogICBjb21tdW5pY2F0ZSB0aGUgcHJlbWFzdGVyIHNlY3JldDogZWl0aGVyIGFuIFJTQSBwdWJsaWMga2V5IHRvIGVuY3J5cHRcbiAqICAgdGhlIHByZW1hc3RlciBzZWNyZXQgd2l0aCwgb3IgYSBEaWZmaWUtSGVsbG1hbiBwdWJsaWMga2V5IHdpdGggd2hpY2ggdGhlXG4gKiAgIGNsaWVudCBjYW4gY29tcGxldGUgYSBrZXkgZXhjaGFuZ2UgKHdpdGggdGhlIHJlc3VsdCBiZWluZyB0aGUgcHJlbWFzdGVyXG4gKiAgIHNlY3JldC4pXG4gKlxuICogZW51bSB7XG4gKiAgIGRoZV9kc3MsIGRoZV9yc2EsIGRoX2Fub24sIHJzYSwgZGhfZHNzLCBkaF9yc2FcbiAqIH0gS2V5RXhjaGFuZ2VBbGdvcml0aG07XG4gKlxuICogc3RydWN0IHtcbiAqICAgb3BhcXVlIGRoX3A8MS4uMl4xNi0xPjtcbiAqICAgb3BhcXVlIGRoX2c8MS4uMl4xNi0xPjtcbiAqICAgb3BhcXVlIGRoX1lzPDEuLjJeMTYtMT47XG4gKiB9IFNlcnZlckRIUGFyYW1zO1xuICpcbiAqIHN0cnVjdCB7XG4gKiAgIHNlbGVjdChLZXlFeGNoYW5nZUFsZ29yaXRobSkge1xuICogICAgIGNhc2UgZGhfYW5vbjpcbiAqICAgICAgIFNlcnZlckRIUGFyYW1zIHBhcmFtcztcbiAqICAgICBjYXNlIGRoZV9kc3M6XG4gKiAgICAgY2FzZSBkaGVfcnNhOlxuICogICAgICAgU2VydmVyREhQYXJhbXMgcGFyYW1zO1xuICogICAgICAgZGlnaXRhbGx5LXNpZ25lZCBzdHJ1Y3Qge1xuICogICAgICAgICBvcGFxdWUgY2xpZW50X3JhbmRvbVszMl07XG4gKiAgICAgICAgIG9wYXF1ZSBzZXJ2ZXJfcmFuZG9tWzMyXTtcbiAqICAgICAgICAgU2VydmVyREhQYXJhbXMgcGFyYW1zO1xuICogICAgICAgfSBzaWduZWRfcGFyYW1zO1xuICogICAgIGNhc2UgcnNhOlxuICogICAgIGNhc2UgZGhfZHNzOlxuICogICAgIGNhc2UgZGhfcnNhOlxuICogICAgICAgc3RydWN0IHt9O1xuICogICB9O1xuICogfSBTZXJ2ZXJLZXlFeGNoYW5nZTtcbiAqXG4gKiBAcGFyYW0gYyB0aGUgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSByZWNvcmQgdGhlIHJlY29yZC5cbiAqIEBwYXJhbSBsZW5ndGggdGhlIGxlbmd0aCBvZiB0aGUgaGFuZHNoYWtlIG1lc3NhZ2UuXG4gKi9cbnRscy5oYW5kbGVTZXJ2ZXJLZXlFeGNoYW5nZSA9IGZ1bmN0aW9uKGMsIHJlY29yZCwgbGVuZ3RoKSB7XG4gIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBSU0EsIG5vIERpZmZpZS1IZWxsbWFuIHN1cHBvcnRcbiAgLy8gc28gYW55IGxlbmd0aCA+IDAgaXMgaW52YWxpZFxuICBpZihsZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGMuZXJyb3IoYywge1xuICAgICAgbWVzc2FnZTogJ0ludmFsaWQga2V5IHBhcmFtZXRlcnMuIE9ubHkgUlNBIGlzIHN1cHBvcnRlZC4nLFxuICAgICAgc2VuZDogdHJ1ZSxcbiAgICAgIGFsZXJ0OiB7XG4gICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwuZmF0YWwsXG4gICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24udW5zdXBwb3J0ZWRfY2VydGlmaWNhdGVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIGV4cGVjdCBhbiBvcHRpb25hbCBDZXJ0aWZpY2F0ZVJlcXVlc3QgbWVzc2FnZSBuZXh0XG4gIGMuZXhwZWN0ID0gU0NSO1xuXG4gIC8vIGNvbnRpbnVlXG4gIGMucHJvY2VzcygpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBhIGNsaWVudCByZWNlaXZlcyBhIENsaWVudEtleUV4Y2hhbmdlIHJlY29yZC5cbiAqXG4gKiBAcGFyYW0gYyB0aGUgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSByZWNvcmQgdGhlIHJlY29yZC5cbiAqIEBwYXJhbSBsZW5ndGggdGhlIGxlbmd0aCBvZiB0aGUgaGFuZHNoYWtlIG1lc3NhZ2UuXG4gKi9cbnRscy5oYW5kbGVDbGllbnRLZXlFeGNoYW5nZSA9IGZ1bmN0aW9uKGMsIHJlY29yZCwgbGVuZ3RoKSB7XG4gIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBSU0EsIG5vIERpZmZpZS1IZWxsbWFuIHN1cHBvcnRcbiAgLy8gc28gYW55IGxlbmd0aCA8IDQ4IGlzIGludmFsaWRcbiAgaWYobGVuZ3RoIDwgNDgpIHtcbiAgICByZXR1cm4gYy5lcnJvcihjLCB7XG4gICAgICBtZXNzYWdlOiAnSW52YWxpZCBrZXkgcGFyYW1ldGVycy4gT25seSBSU0EgaXMgc3VwcG9ydGVkLicsXG4gICAgICBzZW5kOiB0cnVlLFxuICAgICAgYWxlcnQ6IHtcbiAgICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC5mYXRhbCxcbiAgICAgICAgZGVzY3JpcHRpb246IHRscy5BbGVydC5EZXNjcmlwdGlvbi51bnN1cHBvcnRlZF9jZXJ0aWZpY2F0ZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGIgPSByZWNvcmQuZnJhZ21lbnQ7XG4gIHZhciBtc2cgPSB7XG4gICAgZW5jX3ByZV9tYXN0ZXJfc2VjcmV0OiByZWFkVmVjdG9yKGIsIDIpLmdldEJ5dGVzKClcbiAgfTtcblxuICAvLyBkbyByc2EgZGVjcnlwdGlvblxuICB2YXIgcHJpdmF0ZUtleSA9IG51bGw7XG4gIGlmKGMuZ2V0UHJpdmF0ZUtleSkge1xuICAgIHRyeSB7XG4gICAgICBwcml2YXRlS2V5ID0gYy5nZXRQcml2YXRlS2V5KGMsIGMuc2Vzc2lvbi5zZXJ2ZXJDZXJ0aWZpY2F0ZSk7XG4gICAgICBwcml2YXRlS2V5ID0gZm9yZ2UucGtpLnByaXZhdGVLZXlGcm9tUGVtKHByaXZhdGVLZXkpO1xuICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgIGMuZXJyb3IoYywge1xuICAgICAgICBtZXNzYWdlOiAnQ291bGQgbm90IGdldCBwcml2YXRlIGtleS4nLFxuICAgICAgICBjYXVzZTogZXgsXG4gICAgICAgIHNlbmQ6IHRydWUsXG4gICAgICAgIGFsZXJ0OiB7XG4gICAgICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC5mYXRhbCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmludGVybmFsX2Vycm9yXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmKHByaXZhdGVLZXkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gYy5lcnJvcihjLCB7XG4gICAgICBtZXNzYWdlOiAnTm8gcHJpdmF0ZSBrZXkgc2V0LicsXG4gICAgICBzZW5kOiB0cnVlLFxuICAgICAgYWxlcnQ6IHtcbiAgICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC5mYXRhbCxcbiAgICAgICAgZGVzY3JpcHRpb246IHRscy5BbGVydC5EZXNjcmlwdGlvbi5pbnRlcm5hbF9lcnJvclxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBkZWNyeXB0IDQ4LWJ5dGUgcHJlLW1hc3RlciBzZWNyZXRcbiAgICB2YXIgc3AgPSBjLnNlc3Npb24uc3A7XG4gICAgc3AucHJlX21hc3Rlcl9zZWNyZXQgPSBwcml2YXRlS2V5LmRlY3J5cHQobXNnLmVuY19wcmVfbWFzdGVyX3NlY3JldCk7XG5cbiAgICAvLyBlbnN1cmUgY2xpZW50IGhlbGxvIHZlcnNpb24gbWF0Y2hlcyBmaXJzdCAyIGJ5dGVzXG4gICAgdmFyIHZlcnNpb24gPSBjLnNlc3Npb24uY2xpZW50SGVsbG9WZXJzaW9uO1xuICAgIGlmKHZlcnNpb24ubWFqb3IgIT09IHNwLnByZV9tYXN0ZXJfc2VjcmV0LmNoYXJDb2RlQXQoMCkgfHxcbiAgICAgIHZlcnNpb24ubWlub3IgIT09IHNwLnByZV9tYXN0ZXJfc2VjcmV0LmNoYXJDb2RlQXQoMSkpIHtcbiAgICAgIC8vIGVycm9yLCBkbyBub3Qgc2VuZCBhbGVydCAoc2VlIEJMRUkgYXR0YWNrIGJlbG93KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUTFMgdmVyc2lvbiByb2xsYmFjayBhdHRhY2sgZGV0ZWN0ZWQuJyk7XG4gICAgfVxuICB9IGNhdGNoKGV4KSB7XG4gICAgLyogTm90ZTogRGFuaWVsIEJsZWljaGVuYmFjaGVyIFtCTEVJXSBjYW4gYmUgdXNlZCB0byBhdHRhY2sgYVxuICAgICAgVExTIHNlcnZlciB3aGljaCBpcyB1c2luZyBQS0NTIzEgZW5jb2RlZCBSU0EsIHNvIGluc3RlYWQgb2ZcbiAgICAgIGZhaWxpbmcgaGVyZSwgd2UgZ2VuZXJhdGUgNDggcmFuZG9tIGJ5dGVzIGFuZCB1c2UgdGhhdCBhc1xuICAgICAgdGhlIHByZS1tYXN0ZXIgc2VjcmV0LiAqL1xuICAgIHNwLnByZV9tYXN0ZXJfc2VjcmV0ID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzKDQ4KTtcbiAgfVxuXG4gIC8vIGV4cGVjdCBhIENlcnRpZmljYXRlVmVyaWZ5IG1lc3NhZ2UgaWYgYSBDZXJ0aWZpY2F0ZSB3YXMgcmVjZWl2ZWQgdGhhdFxuICAvLyBkb2VzIG5vdCBoYXZlIGZpeGVkIERpZmZpZS1IZWxsbWFuIHBhcmFtcywgb3RoZXJ3aXNlIGV4cGVjdFxuICAvLyBDaGFuZ2VDaXBoZXJTcGVjXG4gIGMuZXhwZWN0ID0gQ0NDO1xuICBpZihjLnNlc3Npb24uY2xpZW50Q2VydGlmaWNhdGUgIT09IG51bGwpIHtcbiAgICAvLyBvbmx5IFJTQSBzdXBwb3J0LCBzbyBleHBlY3QgQ2VydGlmaWNhdGVWZXJpZnlcbiAgICAvLyBUT0RPOiBzdXBwb3J0IERpZmZpZS1IZWxsbWFuXG4gICAgYy5leHBlY3QgPSBDQ1Y7XG4gIH1cblxuICAvLyBjb250aW51ZVxuICBjLnByb2Nlc3MoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gYSBjbGllbnQgcmVjZWl2ZXMgYSBDZXJ0aWZpY2F0ZVJlcXVlc3QgcmVjb3JkLlxuICpcbiAqIFdoZW4gdGhpcyBtZXNzYWdlIHdpbGwgYmUgc2VudDpcbiAqICAgQSBub24tYW5vbnltb3VzIHNlcnZlciBjYW4gb3B0aW9uYWxseSByZXF1ZXN0IGEgY2VydGlmaWNhdGUgZnJvbSB0aGVcbiAqICAgY2xpZW50LCBpZiBhcHByb3ByaWF0ZSBmb3IgdGhlIHNlbGVjdGVkIGNpcGhlciBzdWl0ZS4gVGhpcyBtZXNzYWdlLCBpZlxuICogICBzZW50LCB3aWxsIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgU2VydmVyIEtleSBFeGNoYW5nZSBtZXNzYWdlIChpZiBpdCBpc1xuICogICBzZW50OyBvdGhlcndpc2UsIHRoZSBTZXJ2ZXIgQ2VydGlmaWNhdGUgbWVzc2FnZSkuXG4gKlxuICogZW51bSB7XG4gKiAgIHJzYV9zaWduKDEpLCBkc3Nfc2lnbigyKSwgcnNhX2ZpeGVkX2RoKDMpLCBkc3NfZml4ZWRfZGgoNCksXG4gKiAgIHJzYV9lcGhlbWVyYWxfZGhfUkVTRVJWRUQoNSksIGRzc19lcGhlbWVyYWxfZGhfUkVTRVJWRUQoNiksXG4gKiAgIGZvcnRlenphX2Rtc19SRVNFUlZFRCgyMCksICgyNTUpXG4gKiB9IENsaWVudENlcnRpZmljYXRlVHlwZTtcbiAqXG4gKiBvcGFxdWUgRGlzdGluZ3Vpc2hlZE5hbWU8MS4uMl4xNi0xPjtcbiAqXG4gKiBzdHJ1Y3Qge1xuICogICBDbGllbnRDZXJ0aWZpY2F0ZVR5cGUgY2VydGlmaWNhdGVfdHlwZXM8MS4uMl44LTE+O1xuICogICBTaWduYXR1cmVBbmRIYXNoQWxnb3JpdGhtIHN1cHBvcnRlZF9zaWduYXR1cmVfYWxnb3JpdGhtczwyXjE2LTE+O1xuICogICBEaXN0aW5ndWlzaGVkTmFtZSBjZXJ0aWZpY2F0ZV9hdXRob3JpdGllczwwLi4yXjE2LTE+O1xuICogfSBDZXJ0aWZpY2F0ZVJlcXVlc3Q7XG4gKlxuICogQHBhcmFtIGMgdGhlIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0gcmVjb3JkIHRoZSByZWNvcmQuXG4gKiBAcGFyYW0gbGVuZ3RoIHRoZSBsZW5ndGggb2YgdGhlIGhhbmRzaGFrZSBtZXNzYWdlLlxuICovXG50bHMuaGFuZGxlQ2VydGlmaWNhdGVSZXF1ZXN0ID0gZnVuY3Rpb24oYywgcmVjb3JkLCBsZW5ndGgpIHtcbiAgLy8gbWluaW11bSBvZiAzIGJ5dGVzIGluIG1lc3NhZ2VcbiAgaWYobGVuZ3RoIDwgMykge1xuICAgIHJldHVybiBjLmVycm9yKGMsIHtcbiAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIENlcnRpZmljYXRlUmVxdWVzdC4gTWVzc2FnZSB0b28gc2hvcnQuJyxcbiAgICAgIHNlbmQ6IHRydWUsXG4gICAgICBhbGVydDoge1xuICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmlsbGVnYWxfcGFyYW1ldGVyXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBUT0RPOiBUTFMgMS4yKyBoYXMgZGlmZmVyZW50IGZvcm1hdCBpbmNsdWRpbmdcbiAgLy8gU2lnbmF0dXJlQW5kSGFzaEFsZ29yaXRobSBhZnRlciBjZXJ0IHR5cGVzXG4gIHZhciBiID0gcmVjb3JkLmZyYWdtZW50O1xuICB2YXIgbXNnID0ge1xuICAgIGNlcnRpZmljYXRlX3R5cGVzOiByZWFkVmVjdG9yKGIsIDEpLFxuICAgIGNlcnRpZmljYXRlX2F1dGhvcml0aWVzOiByZWFkVmVjdG9yKGIsIDIpXG4gIH07XG5cbiAgLy8gc2F2ZSBjZXJ0aWZpY2F0ZSByZXF1ZXN0IGluIHNlc3Npb25cbiAgYy5zZXNzaW9uLmNlcnRpZmljYXRlUmVxdWVzdCA9IG1zZztcblxuICAvLyBleHBlY3QgYSBTZXJ2ZXJIZWxsb0RvbmUgbWVzc2FnZSBuZXh0XG4gIGMuZXhwZWN0ID0gU0hEO1xuXG4gIC8vIGNvbnRpbnVlXG4gIGMucHJvY2VzcygpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBhIHNlcnZlciByZWNlaXZlcyBhIENlcnRpZmljYXRlVmVyaWZ5IHJlY29yZC5cbiAqXG4gKiBAcGFyYW0gYyB0aGUgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSByZWNvcmQgdGhlIHJlY29yZC5cbiAqIEBwYXJhbSBsZW5ndGggdGhlIGxlbmd0aCBvZiB0aGUgaGFuZHNoYWtlIG1lc3NhZ2UuXG4gKi9cbnRscy5oYW5kbGVDZXJ0aWZpY2F0ZVZlcmlmeSA9IGZ1bmN0aW9uKGMsIHJlY29yZCwgbGVuZ3RoKSB7XG4gIGlmKGxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gYy5lcnJvcihjLCB7XG4gICAgICBtZXNzYWdlOiAnSW52YWxpZCBDZXJ0aWZpY2F0ZVZlcmlmeS4gTWVzc2FnZSB0b28gc2hvcnQuJyxcbiAgICAgIHNlbmQ6IHRydWUsXG4gICAgICBhbGVydDoge1xuICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmlsbGVnYWxfcGFyYW1ldGVyXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyByZXdpbmQgdG8gZ2V0IGZ1bGwgYnl0ZXMgZm9yIG1lc3NhZ2Ugc28gaXQgY2FuIGJlIG1hbnVhbGx5XG4gIC8vIGRpZ2VzdGVkIGJlbG93IChzcGVjaWFsIGNhc2UgZm9yIENlcnRpZmljYXRlVmVyaWZ5IG1lc3NhZ2VzIGJlY2F1c2VcbiAgLy8gdGhleSBtdXN0IGJlIGRpZ2VzdGVkICphZnRlciogaGFuZGxpbmcgYXMgb3Bwb3NlZCB0byBhbGwgb3RoZXJzKVxuICB2YXIgYiA9IHJlY29yZC5mcmFnbWVudDtcbiAgYi5yZWFkIC09IDQ7XG4gIHZhciBtc2dCeXRlcyA9IGIuYnl0ZXMoKTtcbiAgYi5yZWFkICs9IDQ7XG5cbiAgdmFyIG1zZyA9IHtcbiAgICBzaWduYXR1cmU6IHJlYWRWZWN0b3IoYiwgMikuZ2V0Qnl0ZXMoKVxuICB9O1xuXG4gIC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciBEU0FcblxuICAvLyBnZW5lcmF0ZSBkYXRhIHRvIHZlcmlmeVxuICB2YXIgdmVyaWZ5ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdmVyaWZ5LnB1dEJ1ZmZlcihjLnNlc3Npb24ubWQ1LmRpZ2VzdCgpKTtcbiAgdmVyaWZ5LnB1dEJ1ZmZlcihjLnNlc3Npb24uc2hhMS5kaWdlc3QoKSk7XG4gIHZlcmlmeSA9IHZlcmlmeS5nZXRCeXRlcygpO1xuXG4gIHRyeSB7XG4gICAgdmFyIGNlcnQgPSBjLnNlc3Npb24uY2xpZW50Q2VydGlmaWNhdGU7XG4gICAgLypiID0gZm9yZ2UucGtpLnJzYS5kZWNyeXB0KFxuICAgICAgbXNnLnNpZ25hdHVyZSwgY2VydC5wdWJsaWNLZXksIHRydWUsIHZlcmlmeS5sZW5ndGgpO1xuICAgIGlmKGIgIT09IHZlcmlmeSkgeyovXG4gICAgaWYoIWNlcnQucHVibGljS2V5LnZlcmlmeSh2ZXJpZnksIG1zZy5zaWduYXR1cmUsICdOT05FJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2VydGlmaWNhdGVWZXJpZnkgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoLicpO1xuICAgIH1cblxuICAgIC8vIGRpZ2VzdCBtZXNzYWdlIG5vdyB0aGF0IGl0IGhhcyBiZWVuIGhhbmRsZWRcbiAgICBjLnNlc3Npb24ubWQ1LnVwZGF0ZShtc2dCeXRlcyk7XG4gICAgYy5zZXNzaW9uLnNoYTEudXBkYXRlKG1zZ0J5dGVzKTtcbiAgfSBjYXRjaChleCkge1xuICAgIHJldHVybiBjLmVycm9yKGMsIHtcbiAgICAgIG1lc3NhZ2U6ICdCYWQgc2lnbmF0dXJlIGluIENlcnRpZmljYXRlVmVyaWZ5LicsXG4gICAgICBzZW5kOiB0cnVlLFxuICAgICAgYWxlcnQ6IHtcbiAgICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC5mYXRhbCxcbiAgICAgICAgZGVzY3JpcHRpb246IHRscy5BbGVydC5EZXNjcmlwdGlvbi5oYW5kc2hha2VfZmFpbHVyZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gZXhwZWN0IENoYW5nZUNpcGhlclNwZWNcbiAgYy5leHBlY3QgPSBDQ0M7XG5cbiAgLy8gY29udGludWVcbiAgYy5wcm9jZXNzKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGEgY2xpZW50IHJlY2VpdmVzIGEgU2VydmVySGVsbG9Eb25lIHJlY29yZC5cbiAqXG4gKiBXaGVuIHRoaXMgbWVzc2FnZSB3aWxsIGJlIHNlbnQ6XG4gKiAgIFRoZSBzZXJ2ZXIgaGVsbG8gZG9uZSBtZXNzYWdlIGlzIHNlbnQgYnkgdGhlIHNlcnZlciB0byBpbmRpY2F0ZSB0aGUgZW5kXG4gKiAgIG9mIHRoZSBzZXJ2ZXIgaGVsbG8gYW5kIGFzc29jaWF0ZWQgbWVzc2FnZXMuIEFmdGVyIHNlbmRpbmcgdGhpcyBtZXNzYWdlXG4gKiAgIHRoZSBzZXJ2ZXIgd2lsbCB3YWl0IGZvciBhIGNsaWVudCByZXNwb25zZS5cbiAqXG4gKiBNZWFuaW5nIG9mIHRoaXMgbWVzc2FnZTpcbiAqICAgVGhpcyBtZXNzYWdlIG1lYW5zIHRoYXQgdGhlIHNlcnZlciBpcyBkb25lIHNlbmRpbmcgbWVzc2FnZXMgdG8gc3VwcG9ydFxuICogICB0aGUga2V5IGV4Y2hhbmdlLCBhbmQgdGhlIGNsaWVudCBjYW4gcHJvY2VlZCB3aXRoIGl0cyBwaGFzZSBvZiB0aGUga2V5XG4gKiAgIGV4Y2hhbmdlLlxuICpcbiAqICAgVXBvbiByZWNlaXB0IG9mIHRoZSBzZXJ2ZXIgaGVsbG8gZG9uZSBtZXNzYWdlIHRoZSBjbGllbnQgc2hvdWxkIHZlcmlmeVxuICogICB0aGF0IHRoZSBzZXJ2ZXIgcHJvdmlkZWQgYSB2YWxpZCBjZXJ0aWZpY2F0ZSBpZiByZXF1aXJlZCBhbmQgY2hlY2sgdGhhdFxuICogICB0aGUgc2VydmVyIGhlbGxvIHBhcmFtZXRlcnMgYXJlIGFjY2VwdGFibGUuXG4gKlxuICogc3RydWN0IHt9IFNlcnZlckhlbGxvRG9uZTtcbiAqXG4gKiBAcGFyYW0gYyB0aGUgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSByZWNvcmQgdGhlIHJlY29yZC5cbiAqIEBwYXJhbSBsZW5ndGggdGhlIGxlbmd0aCBvZiB0aGUgaGFuZHNoYWtlIG1lc3NhZ2UuXG4gKi9cbnRscy5oYW5kbGVTZXJ2ZXJIZWxsb0RvbmUgPSBmdW5jdGlvbihjLCByZWNvcmQsIGxlbmd0aCkge1xuICAvLyBsZW4gbXVzdCBiZSAwIGJ5dGVzXG4gIGlmKGxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gYy5lcnJvcihjLCB7XG4gICAgICBtZXNzYWdlOiAnSW52YWxpZCBTZXJ2ZXJIZWxsb0RvbmUgbWVzc2FnZS4gSW52YWxpZCBsZW5ndGguJyxcbiAgICAgIHNlbmQ6IHRydWUsXG4gICAgICBhbGVydDoge1xuICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLnJlY29yZF9vdmVyZmxvd1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYoYy5zZXJ2ZXJDZXJ0aWZpY2F0ZSA9PT0gbnVsbCkge1xuICAgIC8vIG5vIHNlcnZlciBjZXJ0aWZpY2F0ZSB3YXMgcHJvdmlkZWRcbiAgICB2YXIgZXJyb3IgPSB7XG4gICAgICBtZXNzYWdlOiAnTm8gc2VydmVyIGNlcnRpZmljYXRlIHByb3ZpZGVkLiBOb3QgZW5vdWdoIHNlY3VyaXR5LicsXG4gICAgICBzZW5kOiB0cnVlLFxuICAgICAgYWxlcnQ6IHtcbiAgICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC5mYXRhbCxcbiAgICAgICAgZGVzY3JpcHRpb246IHRscy5BbGVydC5EZXNjcmlwdGlvbi5pbnN1ZmZpY2llbnRfc2VjdXJpdHlcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gY2FsbCBhcHBsaWNhdGlvbiBjYWxsYmFja1xuICAgIHZhciBkZXB0aCA9IDA7XG4gICAgdmFyIHJldCA9IGMudmVyaWZ5KGMsIGVycm9yLmFsZXJ0LmRlc2NyaXB0aW9uLCBkZXB0aCwgW10pO1xuICAgIGlmKHJldCAhPT0gdHJ1ZSkge1xuICAgICAgLy8gY2hlY2sgZm9yIGN1c3RvbSBhbGVydCBpbmZvXG4gICAgICBpZihyZXQgfHwgcmV0ID09PSAwKSB7XG4gICAgICAgIC8vIHNldCBjdXN0b20gbWVzc2FnZSBhbmQgYWxlcnQgZGVzY3JpcHRpb25cbiAgICAgICAgaWYodHlwZW9mIHJldCA9PT0gJ29iamVjdCcgJiYgIWZvcmdlLnV0aWwuaXNBcnJheShyZXQpKSB7XG4gICAgICAgICAgaWYocmV0Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSByZXQubWVzc2FnZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmV0LmFsZXJ0KSB7XG4gICAgICAgICAgICBlcnJvci5hbGVydC5kZXNjcmlwdGlvbiA9IHJldC5hbGVydDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZih0eXBlb2YgcmV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIC8vIHNldCBjdXN0b20gYWxlcnQgZGVzY3JpcHRpb25cbiAgICAgICAgICBlcnJvci5hbGVydC5kZXNjcmlwdGlvbiA9IHJldDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBzZW5kIGVycm9yXG4gICAgICByZXR1cm4gYy5lcnJvcihjLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLy8gY3JlYXRlIGNsaWVudCBjZXJ0aWZpY2F0ZSBtZXNzYWdlIGlmIHJlcXVlc3RlZFxuICBpZihjLnNlc3Npb24uY2VydGlmaWNhdGVSZXF1ZXN0ICE9PSBudWxsKSB7XG4gICAgcmVjb3JkID0gdGxzLmNyZWF0ZVJlY29yZChjLCB7XG4gICAgICB0eXBlOiB0bHMuQ29udGVudFR5cGUuaGFuZHNoYWtlLFxuICAgICAgZGF0YTogdGxzLmNyZWF0ZUNlcnRpZmljYXRlKGMpXG4gICAgfSk7XG4gICAgdGxzLnF1ZXVlKGMsIHJlY29yZCk7XG4gIH1cblxuICAvLyBjcmVhdGUgY2xpZW50IGtleSBleGNoYW5nZSBtZXNzYWdlXG4gIHJlY29yZCA9IHRscy5jcmVhdGVSZWNvcmQoYywge1xuICAgICB0eXBlOiB0bHMuQ29udGVudFR5cGUuaGFuZHNoYWtlLFxuICAgICBkYXRhOiB0bHMuY3JlYXRlQ2xpZW50S2V5RXhjaGFuZ2UoYylcbiAgfSk7XG4gIHRscy5xdWV1ZShjLCByZWNvcmQpO1xuXG4gIC8vIGV4cGVjdCBubyBtZXNzYWdlcyB1bnRpbCB0aGUgZm9sbG93aW5nIGNhbGxiYWNrIGhhcyBiZWVuIGNhbGxlZFxuICBjLmV4cGVjdCA9IFNFUjtcblxuICAvLyBjcmVhdGUgY2FsbGJhY2sgdG8gaGFuZGxlIGNsaWVudCBzaWduYXR1cmUgKGZvciBjbGllbnQtY2VydHMpXG4gIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKGMsIHNpZ25hdHVyZSkge1xuICAgIGlmKGMuc2Vzc2lvbi5jZXJ0aWZpY2F0ZVJlcXVlc3QgIT09IG51bGwgJiZcbiAgICAgIGMuc2Vzc2lvbi5jbGllbnRDZXJ0aWZpY2F0ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gY3JlYXRlIGNlcnRpZmljYXRlIHZlcmlmeSBtZXNzYWdlXG4gICAgICB0bHMucXVldWUoYywgdGxzLmNyZWF0ZVJlY29yZChjLCB7XG4gICAgICAgIHR5cGU6IHRscy5Db250ZW50VHlwZS5oYW5kc2hha2UsXG4gICAgICAgIGRhdGE6IHRscy5jcmVhdGVDZXJ0aWZpY2F0ZVZlcmlmeShjLCBzaWduYXR1cmUpXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGNoYW5nZSBjaXBoZXIgc3BlYyBtZXNzYWdlXG4gICAgdGxzLnF1ZXVlKGMsIHRscy5jcmVhdGVSZWNvcmQoYywge1xuICAgICAgdHlwZTogdGxzLkNvbnRlbnRUeXBlLmNoYW5nZV9jaXBoZXJfc3BlYyxcbiAgICAgIGRhdGE6IHRscy5jcmVhdGVDaGFuZ2VDaXBoZXJTcGVjKClcbiAgICB9KSk7XG5cbiAgICAvLyBjcmVhdGUgcGVuZGluZyBzdGF0ZVxuICAgIGMuc3RhdGUucGVuZGluZyA9IHRscy5jcmVhdGVDb25uZWN0aW9uU3RhdGUoYyk7XG5cbiAgICAvLyBjaGFuZ2UgY3VycmVudCB3cml0ZSBzdGF0ZSB0byBwZW5kaW5nIHdyaXRlIHN0YXRlXG4gICAgYy5zdGF0ZS5jdXJyZW50LndyaXRlID0gYy5zdGF0ZS5wZW5kaW5nLndyaXRlO1xuXG4gICAgLy8gY3JlYXRlIGZpbmlzaGVkIG1lc3NhZ2VcbiAgICB0bHMucXVldWUoYywgdGxzLmNyZWF0ZVJlY29yZChjLCB7XG4gICAgICB0eXBlOiB0bHMuQ29udGVudFR5cGUuaGFuZHNoYWtlLFxuICAgICAgZGF0YTogdGxzLmNyZWF0ZUZpbmlzaGVkKGMpXG4gICAgfSkpO1xuXG4gICAgLy8gZXhwZWN0IGEgc2VydmVyIENoYW5nZUNpcGhlclNwZWMgbWVzc2FnZSBuZXh0XG4gICAgYy5leHBlY3QgPSBTQ0M7XG5cbiAgICAvLyBzZW5kIHJlY29yZHNcbiAgICB0bHMuZmx1c2goYyk7XG5cbiAgICAvLyBjb250aW51ZVxuICAgIGMucHJvY2VzcygpO1xuICB9O1xuXG4gIC8vIGlmIHRoZXJlIGlzIG5vIGNlcnRpZmljYXRlIHJlcXVlc3Qgb3Igbm8gY2xpZW50IGNlcnRpZmljYXRlLCBkb1xuICAvLyBjYWxsYmFjayBpbW1lZGlhdGVseVxuICBpZihjLnNlc3Npb24uY2VydGlmaWNhdGVSZXF1ZXN0ID09PSBudWxsIHx8XG4gICAgYy5zZXNzaW9uLmNsaWVudENlcnRpZmljYXRlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGMsIG51bGwpO1xuICB9XG5cbiAgLy8gb3RoZXJ3aXNlIGdldCB0aGUgY2xpZW50IHNpZ25hdHVyZVxuICB0bHMuZ2V0Q2xpZW50U2lnbmF0dXJlKGMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gYSBDaGFuZ2VDaXBoZXJTcGVjIHJlY29yZCBpcyByZWNlaXZlZC5cbiAqXG4gKiBAcGFyYW0gYyB0aGUgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSByZWNvcmQgdGhlIHJlY29yZC5cbiAqL1xudGxzLmhhbmRsZUNoYW5nZUNpcGhlclNwZWMgPSBmdW5jdGlvbihjLCByZWNvcmQpIHtcbiAgaWYocmVjb3JkLmZyYWdtZW50LmdldEJ5dGUoKSAhPT0gMHgwMSkge1xuICAgIHJldHVybiBjLmVycm9yKGMsIHtcbiAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIENoYW5nZUNpcGhlclNwZWMgbWVzc2FnZSByZWNlaXZlZC4nLFxuICAgICAgc2VuZDogdHJ1ZSxcbiAgICAgIGFsZXJ0OiB7XG4gICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwuZmF0YWwsXG4gICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24uaWxsZWdhbF9wYXJhbWV0ZXJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBwZW5kaW5nIHN0YXRlIGlmOlxuICAvLyAxLiBSZXN1bWluZyBzZXNzaW9uIGluIGNsaWVudCBtb2RlIE9SXG4gIC8vIDIuIE5PVCByZXN1bWluZyBzZXNzaW9uIGluIHNlcnZlciBtb2RlXG4gIHZhciBjbGllbnQgPSAoYy5lbnRpdHkgPT09IHRscy5Db25uZWN0aW9uRW5kLmNsaWVudCk7XG4gIGlmKChjLnNlc3Npb24ucmVzdW1pbmcgJiYgY2xpZW50KSB8fCAoIWMuc2Vzc2lvbi5yZXN1bWluZyAmJiAhY2xpZW50KSkge1xuICAgIGMuc3RhdGUucGVuZGluZyA9IHRscy5jcmVhdGVDb25uZWN0aW9uU3RhdGUoYyk7XG4gIH1cblxuICAvLyBjaGFuZ2UgY3VycmVudCByZWFkIHN0YXRlIHRvIHBlbmRpbmcgcmVhZCBzdGF0ZVxuICBjLnN0YXRlLmN1cnJlbnQucmVhZCA9IGMuc3RhdGUucGVuZGluZy5yZWFkO1xuXG4gIC8vIGNsZWFyIHBlbmRpbmcgc3RhdGUgaWY6XG4gIC8vIDEuIE5PVCByZXN1bWluZyBzZXNzaW9uIGluIGNsaWVudCBtb2RlIE9SXG4gIC8vIDIuIHJlc3VtaW5nIGEgc2Vzc2lvbiBpbiBzZXJ2ZXIgbW9kZVxuICBpZigoIWMuc2Vzc2lvbi5yZXN1bWluZyAmJiBjbGllbnQpIHx8IChjLnNlc3Npb24ucmVzdW1pbmcgJiYgIWNsaWVudCkpIHtcbiAgICBjLnN0YXRlLnBlbmRpbmcgPSBudWxsO1xuICB9XG5cbiAgLy8gZXhwZWN0IGEgRmluaXNoZWQgcmVjb3JkIG5leHRcbiAgYy5leHBlY3QgPSBjbGllbnQgPyBTRkkgOiBDRkk7XG5cbiAgLy8gY29udGludWVcbiAgYy5wcm9jZXNzKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGEgRmluaXNoZWQgcmVjb3JkIGlzIHJlY2VpdmVkLlxuICpcbiAqIFdoZW4gdGhpcyBtZXNzYWdlIHdpbGwgYmUgc2VudDpcbiAqICAgQSBmaW5pc2hlZCBtZXNzYWdlIGlzIGFsd2F5cyBzZW50IGltbWVkaWF0ZWx5IGFmdGVyIGEgY2hhbmdlXG4gKiAgIGNpcGhlciBzcGVjIG1lc3NhZ2UgdG8gdmVyaWZ5IHRoYXQgdGhlIGtleSBleGNoYW5nZSBhbmRcbiAqICAgYXV0aGVudGljYXRpb24gcHJvY2Vzc2VzIHdlcmUgc3VjY2Vzc2Z1bC4gSXQgaXMgZXNzZW50aWFsIHRoYXQgYVxuICogICBjaGFuZ2UgY2lwaGVyIHNwZWMgbWVzc2FnZSBiZSByZWNlaXZlZCBiZXR3ZWVuIHRoZSBvdGhlclxuICogICBoYW5kc2hha2UgbWVzc2FnZXMgYW5kIHRoZSBGaW5pc2hlZCBtZXNzYWdlLlxuICpcbiAqIE1lYW5pbmcgb2YgdGhpcyBtZXNzYWdlOlxuICogICBUaGUgZmluaXNoZWQgbWVzc2FnZSBpcyB0aGUgZmlyc3QgcHJvdGVjdGVkIHdpdGggdGhlIGp1c3QtXG4gKiAgIG5lZ290aWF0ZWQgYWxnb3JpdGhtcywga2V5cywgYW5kIHNlY3JldHMuIFJlY2lwaWVudHMgb2YgZmluaXNoZWRcbiAqICAgbWVzc2FnZXMgbXVzdCB2ZXJpZnkgdGhhdCB0aGUgY29udGVudHMgYXJlIGNvcnJlY3QuICBPbmNlIGEgc2lkZVxuICogICBoYXMgc2VudCBpdHMgRmluaXNoZWQgbWVzc2FnZSBhbmQgcmVjZWl2ZWQgYW5kIHZhbGlkYXRlZCB0aGVcbiAqICAgRmluaXNoZWQgbWVzc2FnZSBmcm9tIGl0cyBwZWVyLCBpdCBtYXkgYmVnaW4gdG8gc2VuZCBhbmQgcmVjZWl2ZVxuICogICBhcHBsaWNhdGlvbiBkYXRhIG92ZXIgdGhlIGNvbm5lY3Rpb24uXG4gKlxuICogc3RydWN0IHtcbiAqICAgb3BhcXVlIHZlcmlmeV9kYXRhW3ZlcmlmeV9kYXRhX2xlbmd0aF07XG4gKiB9IEZpbmlzaGVkO1xuICpcbiAqIHZlcmlmeV9kYXRhXG4gKiAgIFBSRihtYXN0ZXJfc2VjcmV0LCBmaW5pc2hlZF9sYWJlbCwgSGFzaChoYW5kc2hha2VfbWVzc2FnZXMpKVxuICogICAgIFswLi52ZXJpZnlfZGF0YV9sZW5ndGgtMV07XG4gKlxuICogZmluaXNoZWRfbGFiZWxcbiAqICAgRm9yIEZpbmlzaGVkIG1lc3NhZ2VzIHNlbnQgYnkgdGhlIGNsaWVudCwgdGhlIHN0cmluZ1xuICogICBcImNsaWVudCBmaW5pc2hlZFwiLiBGb3IgRmluaXNoZWQgbWVzc2FnZXMgc2VudCBieSB0aGUgc2VydmVyLCB0aGVcbiAqICAgc3RyaW5nIFwic2VydmVyIGZpbmlzaGVkXCIuXG4gKlxuICogdmVyaWZ5X2RhdGFfbGVuZ3RoIGRlcGVuZHMgb24gdGhlIGNpcGhlciBzdWl0ZS4gSWYgaXQgaXMgbm90IHNwZWNpZmllZFxuICogYnkgdGhlIGNpcGhlciBzdWl0ZSwgdGhlbiBpdCBpcyAxMi4gVmVyc2lvbnMgb2YgVExTIDwgMS4yIGFsd2F5cyB1c2VkXG4gKiAxMiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gYyB0aGUgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSByZWNvcmQgdGhlIHJlY29yZC5cbiAqIEBwYXJhbSBsZW5ndGggdGhlIGxlbmd0aCBvZiB0aGUgaGFuZHNoYWtlIG1lc3NhZ2UuXG4gKi9cbnRscy5oYW5kbGVGaW5pc2hlZCA9IGZ1bmN0aW9uKGMsIHJlY29yZCwgbGVuZ3RoKSB7XG4gIC8vIHJld2luZCB0byBnZXQgZnVsbCBieXRlcyBmb3IgbWVzc2FnZSBzbyBpdCBjYW4gYmUgbWFudWFsbHlcbiAgLy8gZGlnZXN0ZWQgYmVsb3cgKHNwZWNpYWwgY2FzZSBmb3IgRmluaXNoZWQgbWVzc2FnZXMgYmVjYXVzZSB0aGV5XG4gIC8vIG11c3QgYmUgZGlnZXN0ZWQgKmFmdGVyKiBoYW5kbGluZyBhcyBvcHBvc2VkIHRvIGFsbCBvdGhlcnMpXG4gIHZhciBiID0gcmVjb3JkLmZyYWdtZW50O1xuICBiLnJlYWQgLT0gNDtcbiAgdmFyIG1zZ0J5dGVzID0gYi5ieXRlcygpO1xuICBiLnJlYWQgKz0gNDtcblxuICAvLyBtZXNzYWdlIGNvbnRhaW5zIG9ubHkgdmVyaWZ5X2RhdGFcbiAgdmFyIHZkID0gcmVjb3JkLmZyYWdtZW50LmdldEJ5dGVzKCk7XG5cbiAgLy8gZW5zdXJlIHZlcmlmeSBkYXRhIGlzIGNvcnJlY3RcbiAgYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIGIucHV0QnVmZmVyKGMuc2Vzc2lvbi5tZDUuZGlnZXN0KCkpO1xuICBiLnB1dEJ1ZmZlcihjLnNlc3Npb24uc2hhMS5kaWdlc3QoKSk7XG5cbiAgLy8gc2V0IGxhYmVsIGJhc2VkIG9uIGVudGl0eSB0eXBlXG4gIHZhciBjbGllbnQgPSAoYy5lbnRpdHkgPT09IHRscy5Db25uZWN0aW9uRW5kLmNsaWVudCk7XG4gIHZhciBsYWJlbCA9IGNsaWVudCA/ICdzZXJ2ZXIgZmluaXNoZWQnIDogJ2NsaWVudCBmaW5pc2hlZCc7XG5cbiAgLy8gVE9ETzogZGV0ZXJtaW5lIHByZiBmdW5jdGlvbiBhbmQgdmVyaWZ5IGxlbmd0aCBmb3IgVExTIDEuMlxuICB2YXIgc3AgPSBjLnNlc3Npb24uc3A7XG4gIHZhciB2ZGwgPSAxMjtcbiAgdmFyIHByZiA9IHByZl9UTFMxO1xuICBiID0gcHJmKHNwLm1hc3Rlcl9zZWNyZXQsIGxhYmVsLCBiLmdldEJ5dGVzKCksIHZkbCk7XG4gIGlmKGIuZ2V0Qnl0ZXMoKSAhPT0gdmQpIHtcbiAgICByZXR1cm4gYy5lcnJvcihjLCB7XG4gICAgICBtZXNzYWdlOiAnSW52YWxpZCB2ZXJpZnlfZGF0YSBpbiBGaW5pc2hlZCBtZXNzYWdlLicsXG4gICAgICBzZW5kOiB0cnVlLFxuICAgICAgYWxlcnQ6IHtcbiAgICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC5mYXRhbCxcbiAgICAgICAgZGVzY3JpcHRpb246IHRscy5BbGVydC5EZXNjcmlwdGlvbi5kZWNyeXB0X2Vycm9yXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBkaWdlc3QgZmluaXNoZWQgbWVzc2FnZSBub3cgdGhhdCBpdCBoYXMgYmVlbiBoYW5kbGVkXG4gIGMuc2Vzc2lvbi5tZDUudXBkYXRlKG1zZ0J5dGVzKTtcbiAgYy5zZXNzaW9uLnNoYTEudXBkYXRlKG1zZ0J5dGVzKTtcblxuICAvLyByZXN1bWluZyBzZXNzaW9uIGFzIGNsaWVudCBvciBOT1QgcmVzdW1pbmcgc2Vzc2lvbiBhcyBzZXJ2ZXJcbiAgaWYoKGMuc2Vzc2lvbi5yZXN1bWluZyAmJiBjbGllbnQpIHx8ICghYy5zZXNzaW9uLnJlc3VtaW5nICYmICFjbGllbnQpKSB7XG4gICAgLy8gY3JlYXRlIGNoYW5nZSBjaXBoZXIgc3BlYyBtZXNzYWdlXG4gICAgdGxzLnF1ZXVlKGMsIHRscy5jcmVhdGVSZWNvcmQoYywge1xuICAgICAgdHlwZTogdGxzLkNvbnRlbnRUeXBlLmNoYW5nZV9jaXBoZXJfc3BlYyxcbiAgICAgIGRhdGE6IHRscy5jcmVhdGVDaGFuZ2VDaXBoZXJTcGVjKClcbiAgICB9KSk7XG5cbiAgICAvLyBjaGFuZ2UgY3VycmVudCB3cml0ZSBzdGF0ZSB0byBwZW5kaW5nIHdyaXRlIHN0YXRlLCBjbGVhciBwZW5kaW5nXG4gICAgYy5zdGF0ZS5jdXJyZW50LndyaXRlID0gYy5zdGF0ZS5wZW5kaW5nLndyaXRlO1xuICAgIGMuc3RhdGUucGVuZGluZyA9IG51bGw7XG5cbiAgICAvLyBjcmVhdGUgZmluaXNoZWQgbWVzc2FnZVxuICAgIHRscy5xdWV1ZShjLCB0bHMuY3JlYXRlUmVjb3JkKGMsIHtcbiAgICAgIHR5cGU6IHRscy5Db250ZW50VHlwZS5oYW5kc2hha2UsXG4gICAgICBkYXRhOiB0bHMuY3JlYXRlRmluaXNoZWQoYylcbiAgICB9KSk7XG4gIH1cblxuICAvLyBleHBlY3QgYXBwbGljYXRpb24gZGF0YSBuZXh0XG4gIGMuZXhwZWN0ID0gY2xpZW50ID8gU0FEIDogQ0FEO1xuXG4gIC8vIGhhbmRzaGFrZSBjb21wbGV0ZVxuICBjLmhhbmRzaGFraW5nID0gZmFsc2U7XG4gICsrYy5oYW5kc2hha2VzO1xuXG4gIC8vIHNhdmUgYWNjZXNzIHRvIHBlZXIgY2VydGlmaWNhdGVcbiAgYy5wZWVyQ2VydGlmaWNhdGUgPSBjbGllbnQgP1xuICAgIGMuc2Vzc2lvbi5zZXJ2ZXJDZXJ0aWZpY2F0ZSA6IGMuc2Vzc2lvbi5jbGllbnRDZXJ0aWZpY2F0ZTtcblxuICAvLyBzZW5kIHJlY29yZHNcbiAgdGxzLmZsdXNoKGMpO1xuXG4gIC8vIG5vdyBjb25uZWN0ZWRcbiAgYy5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gIGMuY29ubmVjdGVkKGMpO1xuXG4gIC8vIGNvbnRpbnVlXG4gIGMucHJvY2VzcygpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBhbiBBbGVydCByZWNvcmQgaXMgcmVjZWl2ZWQuXG4gKlxuICogQHBhcmFtIGMgdGhlIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0gcmVjb3JkIHRoZSByZWNvcmQuXG4gKi9cbnRscy5oYW5kbGVBbGVydCA9IGZ1bmN0aW9uKGMsIHJlY29yZCkge1xuICAvLyByZWFkIGFsZXJ0XG4gIHZhciBiID0gcmVjb3JkLmZyYWdtZW50O1xuICB2YXIgYWxlcnQgPSB7XG4gICAgbGV2ZWw6IGIuZ2V0Qnl0ZSgpLFxuICAgIGRlc2NyaXB0aW9uOiBiLmdldEJ5dGUoKVxuICB9O1xuXG4gIC8vIFRPRE86IGNvbnNpZGVyIHVzaW5nIGEgdGFibGU/XG4gIC8vIGdldCBhcHByb3ByaWF0ZSBtZXNzYWdlXG4gIHZhciBtc2c7XG4gIHN3aXRjaChhbGVydC5kZXNjcmlwdGlvbikge1xuICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi5jbG9zZV9ub3RpZnk6XG4gICAgbXNnID0gJ0Nvbm5lY3Rpb24gY2xvc2VkLic7XG4gICAgYnJlYWs7XG4gIGNhc2UgdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLnVuZXhwZWN0ZWRfbWVzc2FnZTpcbiAgICBtc2cgPSAnVW5leHBlY3RlZCBtZXNzYWdlLic7XG4gICAgYnJlYWs7XG4gIGNhc2UgdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmJhZF9yZWNvcmRfbWFjOlxuICAgIG1zZyA9ICdCYWQgcmVjb3JkIE1BQy4nO1xuICAgIGJyZWFrO1xuICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi5kZWNyeXB0aW9uX2ZhaWxlZDpcbiAgICBtc2cgPSAnRGVjcnlwdGlvbiBmYWlsZWQuJztcbiAgICBicmVhaztcbiAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24ucmVjb3JkX292ZXJmbG93OlxuICAgIG1zZyA9ICdSZWNvcmQgb3ZlcmZsb3cuJztcbiAgICBicmVhaztcbiAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24uZGVjb21wcmVzc2lvbl9mYWlsdXJlOlxuICAgIG1zZyA9ICdEZWNvbXByZXNzaW9uIGZhaWxlZC4nO1xuICAgIGJyZWFrO1xuICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi5oYW5kc2hha2VfZmFpbHVyZTpcbiAgICBtc2cgPSAnSGFuZHNoYWtlIGZhaWx1cmUuJztcbiAgICBicmVhaztcbiAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24uYmFkX2NlcnRpZmljYXRlOlxuICAgIG1zZyA9ICdCYWQgY2VydGlmaWNhdGUuJztcbiAgICBicmVhaztcbiAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24udW5zdXBwb3J0ZWRfY2VydGlmaWNhdGU6XG4gICAgbXNnID0gJ1Vuc3VwcG9ydGVkIGNlcnRpZmljYXRlLic7XG4gICAgYnJlYWs7XG4gIGNhc2UgdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmNlcnRpZmljYXRlX3Jldm9rZWQ6XG4gICAgbXNnID0gJ0NlcnRpZmljYXRlIHJldm9rZWQuJztcbiAgICBicmVhaztcbiAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24uY2VydGlmaWNhdGVfZXhwaXJlZDpcbiAgICBtc2cgPSAnQ2VydGlmaWNhdGUgZXhwaXJlZC4nO1xuICAgIGJyZWFrO1xuICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi5jZXJ0aWZpY2F0ZV91bmtub3duOlxuICAgIG1zZyA9ICdDZXJ0aWZpY2F0ZSB1bmtub3duLic7XG4gICAgYnJlYWs7XG4gIGNhc2UgdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmlsbGVnYWxfcGFyYW1ldGVyOlxuICAgIG1zZyA9ICdJbGxlZ2FsIHBhcmFtZXRlci4nO1xuICAgIGJyZWFrO1xuICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi51bmtub3duX2NhOlxuICAgIG1zZyA9ICdVbmtub3duIGNlcnRpZmljYXRlIGF1dGhvcml0eS4nO1xuICAgIGJyZWFrO1xuICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi5hY2Nlc3NfZGVuaWVkOlxuICAgIG1zZyA9ICdBY2Nlc3MgZGVuaWVkLic7XG4gICAgYnJlYWs7XG4gIGNhc2UgdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmRlY29kZV9lcnJvcjpcbiAgICBtc2cgPSAnRGVjb2RlIGVycm9yLic7XG4gICAgYnJlYWs7XG4gIGNhc2UgdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmRlY3J5cHRfZXJyb3I6XG4gICAgbXNnID0gJ0RlY3J5cHQgZXJyb3IuJztcbiAgICBicmVhaztcbiAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24uZXhwb3J0X3Jlc3RyaWN0aW9uOlxuICAgIG1zZyA9ICdFeHBvcnQgcmVzdHJpY3Rpb24uJztcbiAgICBicmVhaztcbiAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24ucHJvdG9jb2xfdmVyc2lvbjpcbiAgICBtc2cgPSAnVW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvbi4nO1xuICAgIGJyZWFrO1xuICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi5pbnN1ZmZpY2llbnRfc2VjdXJpdHk6XG4gICAgbXNnID0gJ0luc3VmZmljaWVudCBzZWN1cml0eS4nO1xuICAgIGJyZWFrO1xuICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi5pbnRlcm5hbF9lcnJvcjpcbiAgICBtc2cgPSAnSW50ZXJuYWwgZXJyb3IuJztcbiAgICBicmVhaztcbiAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24udXNlcl9jYW5jZWxlZDpcbiAgICBtc2cgPSAnVXNlciBjYW5jZWxlZC4nO1xuICAgIGJyZWFrO1xuICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi5ub19yZW5lZ290aWF0aW9uOlxuICAgIG1zZyA9ICdSZW5lZ290aWF0aW9uIG5vdCBzdXBwb3J0ZWQuJztcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICBtc2cgPSAnVW5rbm93biBlcnJvci4nO1xuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gY2xvc2UgY29ubmVjdGlvbiBvbiBjbG9zZV9ub3RpZnksIG5vdCBhbiBlcnJvclxuICBpZihhbGVydC5kZXNjcmlwdGlvbiA9PT0gdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmNsb3NlX25vdGlmeSkge1xuICAgIHJldHVybiBjLmNsb3NlKCk7XG4gIH1cblxuICAvLyBjYWxsIGVycm9yIGhhbmRsZXJcbiAgYy5lcnJvcihjLCB7XG4gICAgbWVzc2FnZTogbXNnLFxuICAgIHNlbmQ6IGZhbHNlLFxuICAgIC8vIG9yaWdpbiBpcyB0aGUgb3Bwb3NpdGUgZW5kXG4gICAgb3JpZ2luOiAoYy5lbnRpdHkgPT09IHRscy5Db25uZWN0aW9uRW5kLmNsaWVudCkgPyAnc2VydmVyJyA6ICdjbGllbnQnLFxuICAgIGFsZXJ0OiBhbGVydFxuICB9KTtcblxuICAvLyBjb250aW51ZVxuICBjLnByb2Nlc3MoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gYSBIYW5kc2hha2UgcmVjb3JkIGlzIHJlY2VpdmVkLlxuICpcbiAqIEBwYXJhbSBjIHRoZSBjb25uZWN0aW9uLlxuICogQHBhcmFtIHJlY29yZCB0aGUgcmVjb3JkLlxuICovXG50bHMuaGFuZGxlSGFuZHNoYWtlID0gZnVuY3Rpb24oYywgcmVjb3JkKSB7XG4gIC8vIGdldCB0aGUgaGFuZHNoYWtlIHR5cGUgYW5kIG1lc3NhZ2UgbGVuZ3RoXG4gIHZhciBiID0gcmVjb3JkLmZyYWdtZW50O1xuICB2YXIgdHlwZSA9IGIuZ2V0Qnl0ZSgpO1xuICB2YXIgbGVuZ3RoID0gYi5nZXRJbnQyNCgpO1xuXG4gIC8vIHNlZSBpZiB0aGUgcmVjb3JkIGZyYWdtZW50IGRvZXNuJ3QgeWV0IGNvbnRhaW4gdGhlIGZ1bGwgbWVzc2FnZVxuICBpZihsZW5ndGggPiBiLmxlbmd0aCgpKSB7XG4gICAgLy8gY2FjaGUgdGhlIHJlY29yZCwgY2xlYXIgaXRzIGZyYWdtZW50LCBhbmQgcmVzZXQgdGhlIGJ1ZmZlciByZWFkXG4gICAgLy8gcG9pbnRlciBiZWZvcmUgdGhlIHR5cGUgYW5kIGxlbmd0aCB3ZXJlIHJlYWRcbiAgICBjLmZyYWdtZW50ZWQgPSByZWNvcmQ7XG4gICAgcmVjb3JkLmZyYWdtZW50ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBiLnJlYWQgLT0gNDtcblxuICAgIC8vIGNvbnRpbnVlXG4gICAgcmV0dXJuIGMucHJvY2VzcygpO1xuICB9XG5cbiAgLy8gZnVsbCBtZXNzYWdlIG5vdyBhdmFpbGFibGUsIGNsZWFyIGNhY2hlLCByZXNldCByZWFkIHBvaW50ZXIgdG9cbiAgLy8gYmVmb3JlIHR5cGUgYW5kIGxlbmd0aFxuICBjLmZyYWdtZW50ZWQgPSBudWxsO1xuICBiLnJlYWQgLT0gNDtcblxuICAvLyBzYXZlIHRoZSBoYW5kc2hha2UgYnl0ZXMgZm9yIGRpZ2VzdGlvbiBhZnRlciBoYW5kbGVyIGlzIGZvdW5kXG4gIC8vIChpbmNsdWRlIHR5cGUgYW5kIGxlbmd0aCBvZiBoYW5kc2hha2UgbXNnKVxuICB2YXIgYnl0ZXMgPSBiLmJ5dGVzKGxlbmd0aCArIDQpO1xuXG4gIC8vIHJlc3RvcmUgcmVhZCBwb2ludGVyXG4gIGIucmVhZCArPSA0O1xuXG4gIC8vIGhhbmRsZSBleHBlY3RlZCBtZXNzYWdlXG4gIGlmKHR5cGUgaW4gaHNUYWJsZVtjLmVudGl0eV1bYy5leHBlY3RdKSB7XG4gICAgLy8gaW5pdGlhbGl6ZSBzZXJ2ZXIgc2Vzc2lvblxuICAgIGlmKGMuZW50aXR5ID09PSB0bHMuQ29ubmVjdGlvbkVuZC5zZXJ2ZXIgJiYgIWMub3BlbiAmJiAhYy5mYWlsKSB7XG4gICAgICBjLmhhbmRzaGFraW5nID0gdHJ1ZTtcbiAgICAgIGMuc2Vzc2lvbiA9IHtcbiAgICAgICAgdmVyc2lvbjogbnVsbCxcbiAgICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICAgIHNlcnZlcl9uYW1lOiB7XG4gICAgICAgICAgICBzZXJ2ZXJOYW1lTGlzdDogW11cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNpcGhlclN1aXRlOiBudWxsLFxuICAgICAgICBjb21wcmVzc2lvbk1ldGhvZDogbnVsbCxcbiAgICAgICAgc2VydmVyQ2VydGlmaWNhdGU6IG51bGwsXG4gICAgICAgIGNsaWVudENlcnRpZmljYXRlOiBudWxsLFxuICAgICAgICBtZDU6IGZvcmdlLm1kLm1kNS5jcmVhdGUoKSxcbiAgICAgICAgc2hhMTogZm9yZ2UubWQuc2hhMS5jcmVhdGUoKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiBVcGRhdGUgaGFuZHNoYWtlIG1lc3NhZ2VzIGRpZ2VzdC4gRmluaXNoZWQgYW5kIENlcnRpZmljYXRlVmVyaWZ5XG4gICAgICBtZXNzYWdlcyBhcmUgbm90IGRpZ2VzdGVkIGhlcmUuIFRoZXkgY2FuJ3QgYmUgZGlnZXN0ZWQgYXMgcGFydCBvZlxuICAgICAgdGhlIHZlcmlmeV9kYXRhIHRoYXQgdGhleSBjb250YWluLiBUaGVzZSBtZXNzYWdlcyBhcmUgbWFudWFsbHlcbiAgICAgIGRpZ2VzdGVkIGluIHRoZWlyIGhhbmRsZXJzLiBIZWxsb1JlcXVlc3QgbWVzc2FnZXMgYXJlIHNpbXBseSBuZXZlclxuICAgICAgaW5jbHVkZWQgaW4gdGhlIGhhbmRzaGFrZSBtZXNzYWdlIGRpZ2VzdCBhY2NvcmRpbmcgdG8gc3BlYy4gKi9cbiAgICBpZih0eXBlICE9PSB0bHMuSGFuZHNoYWtlVHlwZS5oZWxsb19yZXF1ZXN0ICYmXG4gICAgICB0eXBlICE9PSB0bHMuSGFuZHNoYWtlVHlwZS5jZXJ0aWZpY2F0ZV92ZXJpZnkgJiZcbiAgICAgIHR5cGUgIT09IHRscy5IYW5kc2hha2VUeXBlLmZpbmlzaGVkKSB7XG4gICAgICBjLnNlc3Npb24ubWQ1LnVwZGF0ZShieXRlcyk7XG4gICAgICBjLnNlc3Npb24uc2hhMS51cGRhdGUoYnl0ZXMpO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBzcGVjaWZpYyBoYW5kc2hha2UgdHlwZSByZWNvcmRcbiAgICBoc1RhYmxlW2MuZW50aXR5XVtjLmV4cGVjdF1bdHlwZV0oYywgcmVjb3JkLCBsZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHVuZXhwZWN0ZWQgcmVjb3JkXG4gICAgdGxzLmhhbmRsZVVuZXhwZWN0ZWQoYywgcmVjb3JkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBhbiBBcHBsaWNhdGlvbkRhdGEgcmVjb3JkIGlzIHJlY2VpdmVkLlxuICpcbiAqIEBwYXJhbSBjIHRoZSBjb25uZWN0aW9uLlxuICogQHBhcmFtIHJlY29yZCB0aGUgcmVjb3JkLlxuICovXG50bHMuaGFuZGxlQXBwbGljYXRpb25EYXRhID0gZnVuY3Rpb24oYywgcmVjb3JkKSB7XG4gIC8vIGJ1ZmZlciBkYXRhLCBub3RpZnkgdGhhdCBpdHMgcmVhZHlcbiAgYy5kYXRhLnB1dEJ1ZmZlcihyZWNvcmQuZnJhZ21lbnQpO1xuICBjLmRhdGFSZWFkeShjKTtcblxuICAvLyBjb250aW51ZVxuICBjLnByb2Nlc3MoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gYSBIZWFydGJlYXQgcmVjb3JkIGlzIHJlY2VpdmVkLlxuICpcbiAqIEBwYXJhbSBjIHRoZSBjb25uZWN0aW9uLlxuICogQHBhcmFtIHJlY29yZCB0aGUgcmVjb3JkLlxuICovXG50bHMuaGFuZGxlSGVhcnRiZWF0ID0gZnVuY3Rpb24oYywgcmVjb3JkKSB7XG4gIC8vIGdldCB0aGUgaGVhcnRiZWF0IHR5cGUgYW5kIHBheWxvYWRcbiAgdmFyIGIgPSByZWNvcmQuZnJhZ21lbnQ7XG4gIHZhciB0eXBlID0gYi5nZXRCeXRlKCk7XG4gIHZhciBsZW5ndGggPSBiLmdldEludDE2KCk7XG4gIHZhciBwYXlsb2FkID0gYi5nZXRCeXRlcyhsZW5ndGgpO1xuXG4gIGlmKHR5cGUgPT09IHRscy5IZWFydGJlYXRNZXNzYWdlVHlwZS5oZWFydGJlYXRfcmVxdWVzdCkge1xuICAgIC8vIGRpc2NhcmQgcmVxdWVzdCBkdXJpbmcgaGFuZHNoYWtlIG9yIGlmIGxlbmd0aCBpcyB0b28gbGFyZ2VcbiAgICBpZihjLmhhbmRzaGFraW5nIHx8IGxlbmd0aCA+IHBheWxvYWQubGVuZ3RoKSB7XG4gICAgICAvLyBjb250aW51ZVxuICAgICAgcmV0dXJuIGMucHJvY2VzcygpO1xuICAgIH1cbiAgICAvLyByZXRyYW5zbWl0IHBheWxvYWRcbiAgICB0bHMucXVldWUoYywgdGxzLmNyZWF0ZVJlY29yZChjLCB7XG4gICAgICB0eXBlOiB0bHMuQ29udGVudFR5cGUuaGVhcnRiZWF0LFxuICAgICAgZGF0YTogdGxzLmNyZWF0ZUhlYXJ0YmVhdChcbiAgICAgICAgdGxzLkhlYXJ0YmVhdE1lc3NhZ2VUeXBlLmhlYXJ0YmVhdF9yZXNwb25zZSwgcGF5bG9hZClcbiAgICB9KSk7XG4gICAgdGxzLmZsdXNoKGMpO1xuICB9IGVsc2UgaWYodHlwZSA9PT0gdGxzLkhlYXJ0YmVhdE1lc3NhZ2VUeXBlLmhlYXJ0YmVhdF9yZXNwb25zZSkge1xuICAgIC8vIGNoZWNrIHBheWxvYWQgYWdhaW5zdCBleHBlY3RlZCBwYXlsb2FkLCBkaXNjYXJkIGhlYXJ0YmVhdCBpZiBubyBtYXRjaFxuICAgIGlmKHBheWxvYWQgIT09IGMuZXhwZWN0ZWRIZWFydGJlYXRQYXlsb2FkKSB7XG4gICAgICAvLyBjb250aW51ZVxuICAgICAgcmV0dXJuIGMucHJvY2VzcygpO1xuICAgIH1cblxuICAgIC8vIG5vdGlmeSB0aGF0IGEgdmFsaWQgaGVhcnRiZWF0IHdhcyByZWNlaXZlZFxuICAgIGlmKGMuaGVhcnRiZWF0UmVjZWl2ZWQpIHtcbiAgICAgIGMuaGVhcnRiZWF0UmVjZWl2ZWQoYywgZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIocGF5bG9hZCkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbnRpbnVlXG4gIGMucHJvY2VzcygpO1xufTtcblxuLyoqXG4gKiBUaGUgdHJhbnNpc3Rpb25hbCBzdGF0ZSB0YWJsZXMgZm9yIHJlY2VpdmluZyBUTFMgcmVjb3Jkcy4gSXQgbWFwcyB0aGVcbiAqIGN1cnJlbnQgVExTIGVuZ2luZSBzdGF0ZSBhbmQgYSByZWNlaXZlZCByZWNvcmQgdG8gYSBmdW5jdGlvbiB0byBoYW5kbGUgdGhlXG4gKiByZWNvcmQgYW5kIHVwZGF0ZSB0aGUgc3RhdGUuXG4gKlxuICogRm9yIGluc3RhbmNlLCBpZiB0aGUgY3VycmVudCBzdGF0ZSBpcyBTSEUsIHRoZW4gdGhlIFRMUyBlbmdpbmUgaXMgZXhwZWN0aW5nXG4gKiBhIFNlcnZlckhlbGxvIHJlY29yZC4gT25jZSBhIHJlY29yZCBpcyByZWNlaXZlZCwgdGhlIGhhbmRsZXIgZnVuY3Rpb24gaXNcbiAqIGxvb2tlZCB1cCB1c2luZyB0aGUgc3RhdGUgU0hFIGFuZCB0aGUgcmVjb3JkJ3MgY29udGVudCB0eXBlLlxuICpcbiAqIFRoZSByZXN1bHRpbmcgZnVuY3Rpb24gd2lsbCBlaXRoZXIgYmUgYW4gZXJyb3IgaGFuZGxlciBvciBhIHJlY29yZCBoYW5kbGVyLlxuICogVGhlIGZ1bmN0aW9uIHdpbGwgdGFrZSB3aGF0ZXZlciBhY3Rpb24gaXMgYXBwcm9wcmlhdGUgYW5kIHVwZGF0ZSB0aGUgc3RhdGVcbiAqIGZvciB0aGUgbmV4dCByZWNvcmQuXG4gKlxuICogVGhlIHN0YXRlcyBhcmUgYWxsIGJhc2VkIG9uIHBvc3NpYmxlIHNlcnZlciByZWNvcmQgdHlwZXMuIE5vdGUgdGhhdCB0aGVcbiAqIGNsaWVudCB3aWxsIG5ldmVyIHNwZWNpZmljYWxseSBleHBlY3QgdG8gcmVjZWl2ZSBhIEhlbGxvUmVxdWVzdCBvciBhbiBhbGVydFxuICogZnJvbSB0aGUgc2VydmVyIHNvIHRoZXJlIGlzIG5vIHN0YXRlIHRoYXQgcmVmbGVjdHMgdGhpcy4gVGhlc2UgbWVzc2FnZXMgbWF5XG4gKiBvY2N1ciBhdCBhbnkgdGltZS5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIHRhYmxlcyBmb3IgbWFwcGluZyBzdGF0ZXMgYmVjYXVzZSB0aGVyZSBpcyBhIHNlY29uZCB0aWVyIG9mXG4gKiB0eXBlcyBmb3IgaGFuZHNoYWtlIG1lc3NhZ2VzLiBPbmNlIGEgcmVjb3JkIHdpdGggYSBjb250ZW50IHR5cGUgb2YgaGFuZHNoYWtlXG4gKiBpcyByZWNlaXZlZCwgdGhlIGhhbmRzaGFrZSByZWNvcmQgaGFuZGxlciB3aWxsIGxvb2sgdXAgdGhlIGhhbmRzaGFrZSB0eXBlIGluXG4gKiB0aGUgc2Vjb25kYXJ5IG1hcCB0byBnZXQgaXRzIGFwcHJvcHJpYXRlIGhhbmRsZXIuXG4gKlxuICogVmFsaWQgbWVzc2FnZSBvcmRlcnMgYXJlIGFzIGZvbGxvd3M6XG4gKlxuICogPT09PT09PT09PT09PT09PT09PT09PT1GVUxMIEhBTkRTSEFLRT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENsaWVudCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VydmVyXG4gKlxuICogQ2xpZW50SGVsbG8gICAgICAgICAgICAgICAgICAtLS0tLS0tLT5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlcnZlckhlbGxvXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENlcnRpZmljYXRlKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXJ2ZXJLZXlFeGNoYW5nZSpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDZXJ0aWZpY2F0ZVJlcXVlc3QqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwtLS0tLS0tLSAgICAgIFNlcnZlckhlbGxvRG9uZVxuICogQ2VydGlmaWNhdGUqXG4gKiBDbGllbnRLZXlFeGNoYW5nZVxuICogQ2VydGlmaWNhdGVWZXJpZnkqXG4gKiBbQ2hhbmdlQ2lwaGVyU3BlY11cbiAqIEZpbmlzaGVkICAgICAgICAgICAgICAgICAgICAgLS0tLS0tLS0+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtDaGFuZ2VDaXBoZXJTcGVjXVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tLS0tLS0gICAgICAgICAgICAgRmluaXNoZWRcbiAqIEFwcGxpY2F0aW9uIERhdGEgICAgICAgICAgICAgPC0tLS0tLS0+ICAgICBBcHBsaWNhdGlvbiBEYXRhXG4gKlxuICogPT09PT09PT09PT09PT09PT09PT09U0VTU0lPTiBSRVNVTVBUSU9OPT09PT09PT09PT09PT09PT09PT09XG4gKiBDbGllbnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXJ2ZXJcbiAqXG4gKiBDbGllbnRIZWxsbyAgICAgICAgICAgICAgICAgICAtLS0tLS0tLT5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXJ2ZXJIZWxsb1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW0NoYW5nZUNpcGhlclNwZWNdXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tLS0tLS0gICAgICAgICAgICAgRmluaXNoZWRcbiAqIFtDaGFuZ2VDaXBoZXJTcGVjXVxuICogRmluaXNoZWQgICAgICAgICAgICAgICAgICAgICAgLS0tLS0tLS0+XG4gKiBBcHBsaWNhdGlvbiBEYXRhICAgICAgICAgICAgICA8LS0tLS0tLT4gICAgIEFwcGxpY2F0aW9uIERhdGFcbiAqL1xuLy8gY2xpZW50IGV4cGVjdCBzdGF0ZXMgKGluZGljYXRlIHdoaWNoIHJlY29yZHMgYXJlIGV4cGVjdGVkIHRvIGJlIHJlY2VpdmVkKVxudmFyIFNIRSA9IDA7IC8vIHJjdiBzZXJ2ZXIgaGVsbG9cbnZhciBTQ0UgPSAxOyAvLyByY3Ygc2VydmVyIGNlcnRpZmljYXRlXG52YXIgU0tFID0gMjsgLy8gcmN2IHNlcnZlciBrZXkgZXhjaGFuZ2VcbnZhciBTQ1IgPSAzOyAvLyByY3YgY2VydGlmaWNhdGUgcmVxdWVzdFxudmFyIFNIRCA9IDQ7IC8vIHJjdiBzZXJ2ZXIgaGVsbG8gZG9uZVxudmFyIFNDQyA9IDU7IC8vIHJjdiBjaGFuZ2UgY2lwaGVyIHNwZWNcbnZhciBTRkkgPSA2OyAvLyByY3YgZmluaXNoZWRcbnZhciBTQUQgPSA3OyAvLyByY3YgYXBwbGljYXRpb24gZGF0YVxudmFyIFNFUiA9IDg7IC8vIG5vdCBleHBlY3RpbmcgYW55IG1lc3NhZ2VzIGF0IHRoaXMgcG9pbnRcblxuLy8gc2VydmVyIGV4cGVjdCBzdGF0ZXNcbnZhciBDSEUgPSAwOyAvLyByY3YgY2xpZW50IGhlbGxvXG52YXIgQ0NFID0gMTsgLy8gcmN2IGNsaWVudCBjZXJ0aWZpY2F0ZVxudmFyIENLRSA9IDI7IC8vIHJjdiBjbGllbnQga2V5IGV4Y2hhbmdlXG52YXIgQ0NWID0gMzsgLy8gcmN2IGNlcnRpZmljYXRlIHZlcmlmeVxudmFyIENDQyA9IDQ7IC8vIHJjdiBjaGFuZ2UgY2lwaGVyIHNwZWNcbnZhciBDRkkgPSA1OyAvLyByY3YgZmluaXNoZWRcbnZhciBDQUQgPSA2OyAvLyByY3YgYXBwbGljYXRpb24gZGF0YVxudmFyIENFUiA9IDc7IC8vIG5vdCBleHBlY3RpbmcgYW55IG1lc3NhZ2VzIGF0IHRoaXMgcG9pbnRcblxuLy8gbWFwIGNsaWVudCBjdXJyZW50IGV4cGVjdCBzdGF0ZSBhbmQgY29udGVudCB0eXBlIHRvIGZ1bmN0aW9uXG52YXIgX18gPSB0bHMuaGFuZGxlVW5leHBlY3RlZDtcbnZhciBSMCA9IHRscy5oYW5kbGVDaGFuZ2VDaXBoZXJTcGVjO1xudmFyIFIxID0gdGxzLmhhbmRsZUFsZXJ0O1xudmFyIFIyID0gdGxzLmhhbmRsZUhhbmRzaGFrZTtcbnZhciBSMyA9IHRscy5oYW5kbGVBcHBsaWNhdGlvbkRhdGE7XG52YXIgUjQgPSB0bHMuaGFuZGxlSGVhcnRiZWF0O1xudmFyIGN0VGFibGUgPSBbXTtcbmN0VGFibGVbdGxzLkNvbm5lY3Rpb25FbmQuY2xpZW50XSA9IFtcbi8vICAgICAgQ0MsQUwsSFMsQUQsSEJcbi8qU0hFKi9bX18sUjEsUjIsX18sUjRdLFxuLypTQ0UqL1tfXyxSMSxSMixfXyxSNF0sXG4vKlNLRSovW19fLFIxLFIyLF9fLFI0XSxcbi8qU0NSKi9bX18sUjEsUjIsX18sUjRdLFxuLypTSEQqL1tfXyxSMSxSMixfXyxSNF0sXG4vKlNDQyovW1IwLFIxLF9fLF9fLFI0XSxcbi8qU0ZJKi9bX18sUjEsUjIsX18sUjRdLFxuLypTQUQqL1tfXyxSMSxSMixSMyxSNF0sXG4vKlNFUiovW19fLFIxLFIyLF9fLFI0XVxuXTtcblxuLy8gbWFwIHNlcnZlciBjdXJyZW50IGV4cGVjdCBzdGF0ZSBhbmQgY29udGVudCB0eXBlIHRvIGZ1bmN0aW9uXG5jdFRhYmxlW3Rscy5Db25uZWN0aW9uRW5kLnNlcnZlcl0gPSBbXG4vLyAgICAgIENDLEFMLEhTLEFEXG4vKkNIRSovW19fLFIxLFIyLF9fLFI0XSxcbi8qQ0NFKi9bX18sUjEsUjIsX18sUjRdLFxuLypDS0UqL1tfXyxSMSxSMixfXyxSNF0sXG4vKkNDViovW19fLFIxLFIyLF9fLFI0XSxcbi8qQ0NDKi9bUjAsUjEsX18sX18sUjRdLFxuLypDRkkqL1tfXyxSMSxSMixfXyxSNF0sXG4vKkNBRCovW19fLFIxLFIyLFIzLFI0XSxcbi8qQ0VSKi9bX18sUjEsUjIsX18sUjRdXG5dO1xuXG4vLyBtYXAgY2xpZW50IGN1cnJlbnQgZXhwZWN0IHN0YXRlIGFuZCBoYW5kc2hha2UgdHlwZSB0byBmdW5jdGlvblxudmFyIEgwID0gdGxzLmhhbmRsZUhlbGxvUmVxdWVzdDtcbnZhciBIMSA9IHRscy5oYW5kbGVTZXJ2ZXJIZWxsbztcbnZhciBIMiA9IHRscy5oYW5kbGVDZXJ0aWZpY2F0ZTtcbnZhciBIMyA9IHRscy5oYW5kbGVTZXJ2ZXJLZXlFeGNoYW5nZTtcbnZhciBINCA9IHRscy5oYW5kbGVDZXJ0aWZpY2F0ZVJlcXVlc3Q7XG52YXIgSDUgPSB0bHMuaGFuZGxlU2VydmVySGVsbG9Eb25lO1xudmFyIEg2ID0gdGxzLmhhbmRsZUZpbmlzaGVkO1xudmFyIGhzVGFibGUgPSBbXTtcbmhzVGFibGVbdGxzLkNvbm5lY3Rpb25FbmQuY2xpZW50XSA9IFtcbi8vICAgICAgSFIsMDEsU0gsMDMsMDQsMDUsMDYsMDcsMDgsMDksMTAsU0MsU0ssQ1IsSEQsMTUsQ0ssMTcsMTgsMTksRklcbi8qU0hFKi9bX18sX18sSDEsX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX19dLFxuLypTQ0UqL1tIMCxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxIMixIMyxINCxINSxfXyxfXyxfXyxfXyxfXyxfX10sXG4vKlNLRSovW0gwLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLEgzLEg0LEg1LF9fLF9fLF9fLF9fLF9fLF9fXSxcbi8qU0NSKi9bSDAsX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sSDQsSDUsX18sX18sX18sX18sX18sX19dLFxuLypTSEQqL1tIMCxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxINSxfXyxfXyxfXyxfXyxfXyxfX10sXG4vKlNDQyovW0gwLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fXSxcbi8qU0ZJKi9bSDAsX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sSDZdLFxuLypTQUQqL1tIMCxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfX10sXG4vKlNFUiovW0gwLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fXVxuXTtcblxuLy8gbWFwIHNlcnZlciBjdXJyZW50IGV4cGVjdCBzdGF0ZSBhbmQgaGFuZHNoYWtlIHR5cGUgdG8gZnVuY3Rpb25cbi8vIE5vdGU6IENBRFtDSF0gZG9lcyBub3QgbWFwIHRvIEZCIGJlY2F1c2UgcmVuZWdvdGF0aW9uIGlzIHByb2hpYml0ZWRcbnZhciBINyA9IHRscy5oYW5kbGVDbGllbnRIZWxsbztcbnZhciBIOCA9IHRscy5oYW5kbGVDbGllbnRLZXlFeGNoYW5nZTtcbnZhciBIOSA9IHRscy5oYW5kbGVDZXJ0aWZpY2F0ZVZlcmlmeTtcbmhzVGFibGVbdGxzLkNvbm5lY3Rpb25FbmQuc2VydmVyXSA9IFtcbi8vICAgICAgMDEsQ0gsMDIsMDMsMDQsMDUsMDYsMDcsMDgsMDksMTAsQ0MsMTIsMTMsMTQsQ1YsQ0ssMTcsMTgsMTksRklcbi8qQ0hFKi9bX18sSDcsX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX19dLFxuLypDQ0UqL1tfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxIMixfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfX10sXG4vKkNLRSovW19fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLEg4LF9fLF9fLF9fLF9fXSxcbi8qQ0NWKi9bX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sSDksX18sX18sX18sX18sX19dLFxuLypDQ0MqL1tfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfX10sXG4vKkNGSSovW19fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLF9fLEg2XSxcbi8qQ0FEKi9bX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX18sX19dLFxuLypDRVIqL1tfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfXyxfX11cbl07XG5cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBtYXN0ZXJfc2VjcmV0IGFuZCBrZXlzIHVzaW5nIHRoZSBnaXZlbiBzZWN1cml0eSBwYXJhbWV0ZXJzLlxuICpcbiAqIFRoZSBzZWN1cml0eSBwYXJhbWV0ZXJzIGZvciBhIFRMUyBjb25uZWN0aW9uIHN0YXRlIGFyZSBkZWZpbmVkIGFzIHN1Y2g6XG4gKlxuICogc3RydWN0IHtcbiAqICAgQ29ubmVjdGlvbkVuZCAgICAgICAgICBlbnRpdHk7XG4gKiAgIFBSRkFsZ29yaXRobSAgICAgICAgICAgcHJmX2FsZ29yaXRobTtcbiAqICAgQnVsa0NpcGhlckFsZ29yaXRobSAgICBidWxrX2NpcGhlcl9hbGdvcml0aG07XG4gKiAgIENpcGhlclR5cGUgICAgICAgICAgICAgY2lwaGVyX3R5cGU7XG4gKiAgIHVpbnQ4ICAgICAgICAgICAgICAgICAgZW5jX2tleV9sZW5ndGg7XG4gKiAgIHVpbnQ4ICAgICAgICAgICAgICAgICAgYmxvY2tfbGVuZ3RoO1xuICogICB1aW50OCAgICAgICAgICAgICAgICAgIGZpeGVkX2l2X2xlbmd0aDtcbiAqICAgdWludDggICAgICAgICAgICAgICAgICByZWNvcmRfaXZfbGVuZ3RoO1xuICogICBNQUNBbGdvcml0aG0gICAgICAgICAgIG1hY19hbGdvcml0aG07XG4gKiAgIHVpbnQ4ICAgICAgICAgICAgICAgICAgbWFjX2xlbmd0aDtcbiAqICAgdWludDggICAgICAgICAgICAgICAgICBtYWNfa2V5X2xlbmd0aDtcbiAqICAgQ29tcHJlc3Npb25NZXRob2QgICAgICBjb21wcmVzc2lvbl9hbGdvcml0aG07XG4gKiAgIG9wYXF1ZSAgICAgICAgICAgICAgICAgbWFzdGVyX3NlY3JldFs0OF07XG4gKiAgIG9wYXF1ZSAgICAgICAgICAgICAgICAgY2xpZW50X3JhbmRvbVszMl07XG4gKiAgIG9wYXF1ZSAgICAgICAgICAgICAgICAgc2VydmVyX3JhbmRvbVszMl07XG4gKiB9IFNlY3VyaXR5UGFyYW1ldGVycztcbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBkZWZpbml0aW9uIGlzIGZyb20gVExTIDEuMi4gSW4gVExTIDEuMCBzb21lIG9mIHRoZXNlXG4gKiBwYXJhbWV0ZXJzIGFyZSBpZ25vcmVkIGJlY2F1c2UsIGZvciBpbnN0YW5jZSwgdGhlIFBSRkFsZ29yaXRobSBpcyBhXG4gKiBidWlsdGluLWZpeGVkIGFsZ29yaXRobSBjb21iaW5pbmcgaXRlcmF0aW9ucyBvZiBNRDUgYW5kIFNIQS0xIGluIFRMUyAxLjAuXG4gKlxuICogVGhlIFJlY29yZCBQcm90b2NvbCByZXF1aXJlcyBhbiBhbGdvcml0aG0gdG8gZ2VuZXJhdGUga2V5cyByZXF1aXJlZCBieSB0aGVcbiAqIGN1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZS5cbiAqXG4gKiBUaGUgbWFzdGVyIHNlY3JldCBpcyBleHBhbmRlZCBpbnRvIGEgc2VxdWVuY2Ugb2Ygc2VjdXJlIGJ5dGVzLCB3aGljaCBpcyB0aGVuXG4gKiBzcGxpdCB0byBhIGNsaWVudCB3cml0ZSBNQUMga2V5LCBhIHNlcnZlciB3cml0ZSBNQUMga2V5LCBhIGNsaWVudCB3cml0ZVxuICogZW5jcnlwdGlvbiBrZXksIGFuZCBhIHNlcnZlciB3cml0ZSBlbmNyeXB0aW9uIGtleS4gSW4gVExTIDEuMCBhIGNsaWVudCB3cml0ZVxuICogSVYgYW5kIHNlcnZlciB3cml0ZSBJViBhcmUgYWxzbyBnZW5lcmF0ZWQuIEVhY2ggb2YgdGhlc2UgaXMgZ2VuZXJhdGVkIGZyb21cbiAqIHRoZSBieXRlIHNlcXVlbmNlIGluIHRoYXQgb3JkZXIuIFVudXNlZCB2YWx1ZXMgYXJlIGVtcHR5LiBJbiBUTFMgMS4yLCBzb21lXG4gKiBBRUFEIGNpcGhlcnMgbWF5IGFkZGl0aW9uYWxseSByZXF1aXJlIGEgY2xpZW50IHdyaXRlIElWIGFuZCBhIHNlcnZlciB3cml0ZVxuICogSVYgKHNlZSBTZWN0aW9uIDYuMi4zLjMpLlxuICpcbiAqIFdoZW4ga2V5cywgTUFDIGtleXMsIGFuZCBJVnMgYXJlIGdlbmVyYXRlZCwgdGhlIG1hc3RlciBzZWNyZXQgaXMgdXNlZCBhcyBhblxuICogZW50cm9weSBzb3VyY2UuXG4gKlxuICogVG8gZ2VuZXJhdGUgdGhlIGtleSBtYXRlcmlhbCwgY29tcHV0ZTpcbiAqXG4gKiBtYXN0ZXJfc2VjcmV0ID0gUFJGKHByZV9tYXN0ZXJfc2VjcmV0LCBcIm1hc3RlciBzZWNyZXRcIixcbiAqICAgICAgICAgICAgICAgICAgICAgQ2xpZW50SGVsbG8ucmFuZG9tICsgU2VydmVySGVsbG8ucmFuZG9tKVxuICpcbiAqIGtleV9ibG9jayA9IFBSRihTZWN1cml0eVBhcmFtZXRlcnMubWFzdGVyX3NlY3JldCxcbiAqICAgICAgICAgICAgICAgICBcImtleSBleHBhbnNpb25cIixcbiAqICAgICAgICAgICAgICAgICBTZWN1cml0eVBhcmFtZXRlcnMuc2VydmVyX3JhbmRvbSArXG4gKiAgICAgICAgICAgICAgICAgU2VjdXJpdHlQYXJhbWV0ZXJzLmNsaWVudF9yYW5kb20pO1xuICpcbiAqIHVudGlsIGVub3VnaCBvdXRwdXQgaGFzIGJlZW4gZ2VuZXJhdGVkLiBUaGVuLCB0aGUga2V5X2Jsb2NrIGlzXG4gKiBwYXJ0aXRpb25lZCBhcyBmb2xsb3dzOlxuICpcbiAqIGNsaWVudF93cml0ZV9NQUNfa2V5W1NlY3VyaXR5UGFyYW1ldGVycy5tYWNfa2V5X2xlbmd0aF1cbiAqIHNlcnZlcl93cml0ZV9NQUNfa2V5W1NlY3VyaXR5UGFyYW1ldGVycy5tYWNfa2V5X2xlbmd0aF1cbiAqIGNsaWVudF93cml0ZV9rZXlbU2VjdXJpdHlQYXJhbWV0ZXJzLmVuY19rZXlfbGVuZ3RoXVxuICogc2VydmVyX3dyaXRlX2tleVtTZWN1cml0eVBhcmFtZXRlcnMuZW5jX2tleV9sZW5ndGhdXG4gKiBjbGllbnRfd3JpdGVfSVZbU2VjdXJpdHlQYXJhbWV0ZXJzLmZpeGVkX2l2X2xlbmd0aF1cbiAqIHNlcnZlcl93cml0ZV9JVltTZWN1cml0eVBhcmFtZXRlcnMuZml4ZWRfaXZfbGVuZ3RoXVxuICpcbiAqIEluIFRMUyAxLjIsIHRoZSBjbGllbnRfd3JpdGVfSVYgYW5kIHNlcnZlcl93cml0ZV9JViBhcmUgb25seSBnZW5lcmF0ZWQgZm9yXG4gKiBpbXBsaWNpdCBub25jZSB0ZWNobmlxdWVzIGFzIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDMuMi4xIG9mIFtBRUFEXS4gVGhpc1xuICogaW1wbGVtZW50YXRpb24gdXNlcyBUTFMgMS4wIHNvIElWcyBhcmUgZ2VuZXJhdGVkLlxuICpcbiAqIEltcGxlbWVudGF0aW9uIG5vdGU6IFRoZSBjdXJyZW50bHkgZGVmaW5lZCBjaXBoZXIgc3VpdGUgd2hpY2ggcmVxdWlyZXMgdGhlXG4gKiBtb3N0IG1hdGVyaWFsIGlzIEFFU18yNTZfQ0JDX1NIQTI1Ni4gSXQgcmVxdWlyZXMgMiB4IDMyIGJ5dGUga2V5cyBhbmQgMiB4IDMyXG4gKiBieXRlIE1BQyBrZXlzLCBmb3IgYSB0b3RhbCAxMjggYnl0ZXMgb2Yga2V5IG1hdGVyaWFsLiBJbiBUTFMgMS4wIGl0IGFsc29cbiAqIHJlcXVpcmVzIDIgeCAxNiBieXRlIElWcywgc28gaXQgYWN0dWFsbHkgdGFrZXMgMTYwIGJ5dGVzIG9mIGtleSBtYXRlcmlhbC5cbiAqXG4gKiBAcGFyYW0gYyB0aGUgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSBzcCB0aGUgc2VjdXJpdHkgcGFyYW1ldGVycyB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgc2VjdXJpdHkga2V5cy5cbiAqL1xudGxzLmdlbmVyYXRlS2V5cyA9IGZ1bmN0aW9uKGMsIHNwKSB7XG4gIC8vIFRMU19SU0FfV0lUSF9BRVNfMTI4X0NCQ19TSEEgKHJlcXVpcmVkIHRvIGJlIGNvbXBsaWFudCB3aXRoIFRMUyAxLjIpICZcbiAgLy8gVExTX1JTQV9XSVRIX0FFU18yNTZfQ0JDX1NIQSBhcmUgdGhlIG9ubHkgY2lwaGVyIHN1aXRlcyBpbXBsZW1lbnRlZFxuICAvLyBhdCBwcmVzZW50XG5cbiAgLy8gVExTX0RIRV9EU1NfV0lUSF8zREVTX0VERV9DQkNfU0hBIGlzIHJlcXVpcmVkIHRvIGJlIGNvbXBsaWFudCB3aXRoXG4gIC8vIFRMUyAxLjAgYnV0IHdlIGRvbid0IGNhcmUgcmlnaHQgbm93IGJlY2F1c2UgQUVTIGlzIGJldHRlciBhbmQgd2UgaGF2ZVxuICAvLyBhbiBpbXBsZW1lbnRhdGlvbiBmb3IgaXRcblxuICAvLyBUT0RPOiBUTFMgMS4yIGltcGxlbWVudGF0aW9uXG4gIC8qXG4gIC8vIGRldGVybWluZSB0aGUgUFJGXG4gIHZhciBwcmY7XG4gIHN3aXRjaChzcC5wcmZfYWxnb3JpdGhtKSB7XG4gIGNhc2UgdGxzLlBSRkFsZ29yaXRobS50bHNfcHJmX3NoYTI1NjpcbiAgICBwcmYgPSBwcmZfc2hhMjU2O1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIC8vIHNob3VsZCBuZXZlciBoYXBwZW5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUFJGJyk7XG4gIH1cbiAgKi9cblxuICAvLyBUTFMgMS4wLzEuMSBpbXBsZW1lbnRhdGlvblxuICB2YXIgcHJmID0gcHJmX1RMUzE7XG5cbiAgLy8gY29uY2F0ZW5hdGUgc2VydmVyIGFuZCBjbGllbnQgcmFuZG9tXG4gIHZhciByYW5kb20gPSBzcC5jbGllbnRfcmFuZG9tICsgc3Auc2VydmVyX3JhbmRvbTtcblxuICAvLyBvbmx5IGNyZWF0ZSBtYXN0ZXIgc2VjcmV0IGlmIHNlc3Npb24gaXMgbmV3XG4gIGlmKCFjLnNlc3Npb24ucmVzdW1pbmcpIHtcbiAgICAvLyBjcmVhdGUgbWFzdGVyIHNlY3JldCwgY2xlYW4gdXAgcHJlLW1hc3RlciBzZWNyZXRcbiAgICBzcC5tYXN0ZXJfc2VjcmV0ID0gcHJmKFxuICAgICAgc3AucHJlX21hc3Rlcl9zZWNyZXQsICdtYXN0ZXIgc2VjcmV0JywgcmFuZG9tLCA0OCkuYnl0ZXMoKTtcbiAgICBzcC5wcmVfbWFzdGVyX3NlY3JldCA9IG51bGw7XG4gIH1cblxuICAvLyBnZW5lcmF0ZSB0aGUgYW1vdW50IG9mIGtleSBtYXRlcmlhbCBuZWVkZWRcbiAgcmFuZG9tID0gc3Auc2VydmVyX3JhbmRvbSArIHNwLmNsaWVudF9yYW5kb207XG4gIHZhciBsZW5ndGggPSAyICogc3AubWFjX2tleV9sZW5ndGggKyAyICogc3AuZW5jX2tleV9sZW5ndGg7XG5cbiAgLy8gaW5jbHVkZSBJViBmb3IgVExTLzEuMFxuICB2YXIgdGxzMTAgPSAoYy52ZXJzaW9uLm1ham9yID09PSB0bHMuVmVyc2lvbnMuVExTXzFfMC5tYWpvciAmJlxuICAgIGMudmVyc2lvbi5taW5vciA9PT0gdGxzLlZlcnNpb25zLlRMU18xXzAubWlub3IpO1xuICBpZih0bHMxMCkge1xuICAgIGxlbmd0aCArPSAyICogc3AuZml4ZWRfaXZfbGVuZ3RoO1xuICB9XG4gIHZhciBrbSA9IHByZihzcC5tYXN0ZXJfc2VjcmV0LCAna2V5IGV4cGFuc2lvbicsIHJhbmRvbSwgbGVuZ3RoKTtcblxuICAvLyBzcGxpdCB0aGUga2V5IG1hdGVyaWFsIGludG8gdGhlIE1BQyBhbmQgZW5jcnlwdGlvbiBrZXlzXG4gIHZhciBydmFsID0ge1xuICAgIGNsaWVudF93cml0ZV9NQUNfa2V5OiBrbS5nZXRCeXRlcyhzcC5tYWNfa2V5X2xlbmd0aCksXG4gICAgc2VydmVyX3dyaXRlX01BQ19rZXk6IGttLmdldEJ5dGVzKHNwLm1hY19rZXlfbGVuZ3RoKSxcbiAgICBjbGllbnRfd3JpdGVfa2V5OiBrbS5nZXRCeXRlcyhzcC5lbmNfa2V5X2xlbmd0aCksXG4gICAgc2VydmVyX3dyaXRlX2tleToga20uZ2V0Qnl0ZXMoc3AuZW5jX2tleV9sZW5ndGgpXG4gIH07XG5cbiAgLy8gaW5jbHVkZSBUTFMgMS4wIElWc1xuICBpZih0bHMxMCkge1xuICAgIHJ2YWwuY2xpZW50X3dyaXRlX0lWID0ga20uZ2V0Qnl0ZXMoc3AuZml4ZWRfaXZfbGVuZ3RoKTtcbiAgICBydmFsLnNlcnZlcl93cml0ZV9JViA9IGttLmdldEJ5dGVzKHNwLmZpeGVkX2l2X2xlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbml0aWFsaXplZCBUTFMgY29ubmVjdGlvbiBzdGF0ZS4gQSBjb25uZWN0aW9uIHN0YXRlIGhhc1xuICogYSByZWFkIG1vZGUgYW5kIGEgd3JpdGUgbW9kZS5cbiAqXG4gKiBjb21wcmVzc2lvbiBzdGF0ZTpcbiAqICAgVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGNvbXByZXNzaW9uIGFsZ29yaXRobS5cbiAqXG4gKiBjaXBoZXIgc3RhdGU6XG4gKiAgIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobS4gVGhpcyB3aWxsIGNvbnNpc3Qgb2YgdGhlXG4gKiAgIHNjaGVkdWxlZCBrZXkgZm9yIHRoYXQgY29ubmVjdGlvbi4gRm9yIHN0cmVhbSBjaXBoZXJzLCB0aGlzIHdpbGwgYWxzb1xuICogICBjb250YWluIHdoYXRldmVyIHN0YXRlIGluZm9ybWF0aW9uIGlzIG5lY2Vzc2FyeSB0byBhbGxvdyB0aGUgc3RyZWFtIHRvXG4gKiAgIGNvbnRpbnVlIHRvIGVuY3J5cHQgb3IgZGVjcnlwdCBkYXRhLlxuICpcbiAqIE1BQyBrZXk6XG4gKiAgIFRoZSBNQUMga2V5IGZvciB0aGUgY29ubmVjdGlvbi5cbiAqXG4gKiBzZXF1ZW5jZSBudW1iZXI6XG4gKiAgIEVhY2ggY29ubmVjdGlvbiBzdGF0ZSBjb250YWlucyBhIHNlcXVlbmNlIG51bWJlciwgd2hpY2ggaXMgbWFpbnRhaW5lZFxuICogICBzZXBhcmF0ZWx5IGZvciByZWFkIGFuZCB3cml0ZSBzdGF0ZXMuIFRoZSBzZXF1ZW5jZSBudW1iZXIgTVVTVCBiZSBzZXQgdG9cbiAqICAgemVybyB3aGVuZXZlciBhIGNvbm5lY3Rpb24gc3RhdGUgaXMgbWFkZSB0aGUgYWN0aXZlIHN0YXRlLiBTZXF1ZW5jZVxuICogICBudW1iZXJzIGFyZSBvZiB0eXBlIHVpbnQ2NCBhbmQgbWF5IG5vdCBleGNlZWQgMl42NC0xLiBTZXF1ZW5jZSBudW1iZXJzIGRvXG4gKiAgIG5vdCB3cmFwLiBJZiBhIFRMUyBpbXBsZW1lbnRhdGlvbiB3b3VsZCBuZWVkIHRvIHdyYXAgYSBzZXF1ZW5jZSBudW1iZXIsXG4gKiAgIGl0IG11c3QgcmVuZWdvdGlhdGUgaW5zdGVhZC4gQSBzZXF1ZW5jZSBudW1iZXIgaXMgaW5jcmVtZW50ZWQgYWZ0ZXIgZWFjaFxuICogICByZWNvcmQ6IHNwZWNpZmljYWxseSwgdGhlIGZpcnN0IHJlY29yZCB0cmFuc21pdHRlZCB1bmRlciBhIHBhcnRpY3VsYXJcbiAqICAgY29ubmVjdGlvbiBzdGF0ZSBNVVNUIHVzZSBzZXF1ZW5jZSBudW1iZXIgMC5cbiAqXG4gKiBAcGFyYW0gYyB0aGUgY29ubmVjdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBuZXcgaW5pdGlhbGl6ZWQgVExTIGNvbm5lY3Rpb24gc3RhdGUuXG4gKi9cbnRscy5jcmVhdGVDb25uZWN0aW9uU3RhdGUgPSBmdW5jdGlvbihjKSB7XG4gIHZhciBjbGllbnQgPSAoYy5lbnRpdHkgPT09IHRscy5Db25uZWN0aW9uRW5kLmNsaWVudCk7XG5cbiAgdmFyIGNyZWF0ZU1vZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbW9kZSA9IHtcbiAgICAgIC8vIHR3byAzMi1iaXQgbnVtYmVycywgZmlyc3QgaXMgbW9zdCBzaWduaWZpY2FudFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IFswLCAwXSxcbiAgICAgIG1hY0tleTogbnVsbCxcbiAgICAgIG1hY0xlbmd0aDogMCxcbiAgICAgIG1hY0Z1bmN0aW9uOiBudWxsLFxuICAgICAgY2lwaGVyU3RhdGU6IG51bGwsXG4gICAgICBjaXBoZXJGdW5jdGlvbjogZnVuY3Rpb24ocmVjb3JkKSB7cmV0dXJuIHRydWU7fSxcbiAgICAgIGNvbXByZXNzaW9uU3RhdGU6IG51bGwsXG4gICAgICBjb21wcmVzc0Z1bmN0aW9uOiBmdW5jdGlvbihyZWNvcmQpIHtyZXR1cm4gdHJ1ZTt9LFxuICAgICAgdXBkYXRlU2VxdWVuY2VOdW1iZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZihtb2RlLnNlcXVlbmNlTnVtYmVyWzFdID09PSAweEZGRkZGRkZGKSB7XG4gICAgICAgICAgbW9kZS5zZXF1ZW5jZU51bWJlclsxXSA9IDA7XG4gICAgICAgICAgKyttb2RlLnNlcXVlbmNlTnVtYmVyWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsrbW9kZS5zZXF1ZW5jZU51bWJlclsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG1vZGU7XG4gIH07XG4gIHZhciBzdGF0ZSA9IHtcbiAgICByZWFkOiBjcmVhdGVNb2RlKCksXG4gICAgd3JpdGU6IGNyZWF0ZU1vZGUoKVxuICB9O1xuXG4gIC8vIHVwZGF0ZSBmdW5jdGlvbiBpbiByZWFkIG1vZGUgd2lsbCBkZWNyeXB0IHRoZW4gZGVjb21wcmVzcyBhIHJlY29yZFxuICBzdGF0ZS5yZWFkLnVwZGF0ZSA9IGZ1bmN0aW9uKGMsIHJlY29yZCkge1xuICAgIGlmKCFzdGF0ZS5yZWFkLmNpcGhlckZ1bmN0aW9uKHJlY29yZCwgc3RhdGUucmVhZCkpIHtcbiAgICAgIGMuZXJyb3IoYywge1xuICAgICAgICBtZXNzYWdlOiAnQ291bGQgbm90IGRlY3J5cHQgcmVjb3JkIG9yIGJhZCBNQUMuJyxcbiAgICAgICAgc2VuZDogdHJ1ZSxcbiAgICAgICAgYWxlcnQ6IHtcbiAgICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICAgIC8vIGRvZXNuJ3QgbWF0dGVyIGlmIGRlY3J5cHRpb24gZmFpbGVkIG9yIE1BQyB3YXNcbiAgICAgICAgICAvLyBpbnZhbGlkLCByZXR1cm4gdGhlIHNhbWUgZXJyb3Igc28gYXMgbm90IHRvIHJldmVhbFxuICAgICAgICAgIC8vIHdoaWNoIG9uZSBvY2N1cnJlZFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24uYmFkX3JlY29yZF9tYWNcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmKCFzdGF0ZS5yZWFkLmNvbXByZXNzRnVuY3Rpb24oYywgcmVjb3JkLCBzdGF0ZS5yZWFkKSkge1xuICAgICAgYy5lcnJvcihjLCB7XG4gICAgICAgIG1lc3NhZ2U6ICdDb3VsZCBub3QgZGVjb21wcmVzcyByZWNvcmQuJyxcbiAgICAgICAgc2VuZDogdHJ1ZSxcbiAgICAgICAgYWxlcnQ6IHtcbiAgICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24uZGVjb21wcmVzc2lvbl9mYWlsdXJlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gIWMuZmFpbDtcbiAgfTtcblxuICAvLyB1cGRhdGUgZnVuY3Rpb24gaW4gd3JpdGUgbW9kZSB3aWxsIGNvbXByZXNzIHRoZW4gZW5jcnlwdCBhIHJlY29yZFxuICBzdGF0ZS53cml0ZS51cGRhdGUgPSBmdW5jdGlvbihjLCByZWNvcmQpIHtcbiAgICBpZighc3RhdGUud3JpdGUuY29tcHJlc3NGdW5jdGlvbihjLCByZWNvcmQsIHN0YXRlLndyaXRlKSkge1xuICAgICAgLy8gZXJyb3IsIGJ1dCBkbyBub3Qgc2VuZCBhbGVydCBzaW5jZSBpdCB3b3VsZCByZXF1aXJlXG4gICAgICAvLyBjb21wcmVzc2lvbiBhcyB3ZWxsXG4gICAgICBjLmVycm9yKGMsIHtcbiAgICAgICAgbWVzc2FnZTogJ0NvdWxkIG5vdCBjb21wcmVzcyByZWNvcmQuJyxcbiAgICAgICAgc2VuZDogZmFsc2UsXG4gICAgICAgIGFsZXJ0OiB7XG4gICAgICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC5mYXRhbCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmludGVybmFsX2Vycm9yXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZighc3RhdGUud3JpdGUuY2lwaGVyRnVuY3Rpb24ocmVjb3JkLCBzdGF0ZS53cml0ZSkpIHtcbiAgICAgIC8vIGVycm9yLCBidXQgZG8gbm90IHNlbmQgYWxlcnQgc2luY2UgaXQgd291bGQgcmVxdWlyZVxuICAgICAgLy8gZW5jcnlwdGlvbiBhcyB3ZWxsXG4gICAgICBjLmVycm9yKGMsIHtcbiAgICAgICAgbWVzc2FnZTogJ0NvdWxkIG5vdCBlbmNyeXB0IHJlY29yZC4nLFxuICAgICAgICBzZW5kOiBmYWxzZSxcbiAgICAgICAgYWxlcnQ6IHtcbiAgICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24uaW50ZXJuYWxfZXJyb3JcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAhYy5mYWlsO1xuICB9O1xuXG4gIC8vIGhhbmRsZSBzZWN1cml0eSBwYXJhbWV0ZXJzXG4gIGlmKGMuc2Vzc2lvbikge1xuICAgIHZhciBzcCA9IGMuc2Vzc2lvbi5zcDtcbiAgICBjLnNlc3Npb24uY2lwaGVyU3VpdGUuaW5pdFNlY3VyaXR5UGFyYW1ldGVycyhzcCk7XG5cbiAgICAvLyBnZW5lcmF0ZSBrZXlzXG4gICAgc3Aua2V5cyA9IHRscy5nZW5lcmF0ZUtleXMoYywgc3ApO1xuICAgIHN0YXRlLnJlYWQubWFjS2V5ID0gY2xpZW50ID9cbiAgICAgIHNwLmtleXMuc2VydmVyX3dyaXRlX01BQ19rZXkgOiBzcC5rZXlzLmNsaWVudF93cml0ZV9NQUNfa2V5O1xuICAgIHN0YXRlLndyaXRlLm1hY0tleSA9IGNsaWVudCA/XG4gICAgICBzcC5rZXlzLmNsaWVudF93cml0ZV9NQUNfa2V5IDogc3Aua2V5cy5zZXJ2ZXJfd3JpdGVfTUFDX2tleTtcblxuICAgIC8vIGNpcGhlciBzdWl0ZSBzZXR1cFxuICAgIGMuc2Vzc2lvbi5jaXBoZXJTdWl0ZS5pbml0Q29ubmVjdGlvblN0YXRlKHN0YXRlLCBjLCBzcCk7XG5cbiAgICAvLyBjb21wcmVzc2lvbiBzZXR1cFxuICAgIHN3aXRjaChzcC5jb21wcmVzc2lvbl9hbGdvcml0aG0pIHtcbiAgICBjYXNlIHRscy5Db21wcmVzc2lvbk1ldGhvZC5ub25lOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0bHMuQ29tcHJlc3Npb25NZXRob2QuZGVmbGF0ZTpcbiAgICAgIHN0YXRlLnJlYWQuY29tcHJlc3NGdW5jdGlvbiA9IGluZmxhdGU7XG4gICAgICBzdGF0ZS53cml0ZS5jb21wcmVzc0Z1bmN0aW9uID0gZGVmbGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNvbXByZXNzaW9uIGFsZ29yaXRobS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBSYW5kb20gc3RydWN0dXJlLlxuICpcbiAqIHN0cnVjdCB7XG4gKiAgIHVpbnQzMiBnbXRfdW5peF90aW1lO1xuICogICBvcGFxdWUgcmFuZG9tX2J5dGVzWzI4XTtcbiAqIH0gUmFuZG9tO1xuICpcbiAqIGdtdF91bml4X3RpbWU6XG4gKiAgIFRoZSBjdXJyZW50IHRpbWUgYW5kIGRhdGUgaW4gc3RhbmRhcmQgVU5JWCAzMi1iaXQgZm9ybWF0IChzZWNvbmRzIHNpbmNlXG4gKiAgIHRoZSBtaWRuaWdodCBzdGFydGluZyBKYW4gMSwgMTk3MCwgVVRDLCBpZ25vcmluZyBsZWFwIHNlY29uZHMpIGFjY29yZGluZ1xuICogICB0byB0aGUgc2VuZGVyJ3MgaW50ZXJuYWwgY2xvY2suIENsb2NrcyBhcmUgbm90IHJlcXVpcmVkIHRvIGJlIHNldFxuICogICBjb3JyZWN0bHkgYnkgdGhlIGJhc2ljIFRMUyBwcm90b2NvbDsgaGlnaGVyLWxldmVsIG9yIGFwcGxpY2F0aW9uXG4gKiAgIHByb3RvY29scyBtYXkgZGVmaW5lIGFkZGl0aW9uYWwgcmVxdWlyZW1lbnRzLiBOb3RlIHRoYXQsIGZvciBoaXN0b3JpY2FsXG4gKiAgIHJlYXNvbnMsIHRoZSBkYXRhIGVsZW1lbnQgaXMgbmFtZWQgdXNpbmcgR01ULCB0aGUgcHJlZGVjZXNzb3Igb2YgdGhlXG4gKiAgIGN1cnJlbnQgd29ybGR3aWRlIHRpbWUgYmFzZSwgVVRDLlxuICogcmFuZG9tX2J5dGVzOlxuICogICAyOCBieXRlcyBnZW5lcmF0ZWQgYnkgYSBzZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gKlxuICogQHJldHVybiB0aGUgUmFuZG9tIHN0cnVjdHVyZSBhcyBhIGJ5dGUgYXJyYXkuXG4gKi9cbnRscy5jcmVhdGVSYW5kb20gPSBmdW5jdGlvbigpIHtcbiAgLy8gZ2V0IFVUQyBtaWxsaXNlY29uZHNcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdXRjID0gK2QgKyBkLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMDtcbiAgdmFyIHJ2YWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICBydmFsLnB1dEludDMyKHV0Yyk7XG4gIHJ2YWwucHV0Qnl0ZXMoZm9yZ2UucmFuZG9tLmdldEJ5dGVzKDI4KSk7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgVExTIHJlY29yZCB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBkYXRhLlxuICpcbiAqIEBwYXJhbSBjIHRoZSBjb25uZWN0aW9uLlxuICogQHBhcmFtIG9wdGlvbnM6XG4gKiAgIHR5cGU6IHRoZSByZWNvcmQgdHlwZS5cbiAqICAgZGF0YTogdGhlIHBsYWluIHRleHQgZGF0YSBpbiBhIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGNyZWF0ZWQgcmVjb3JkLlxuICovXG50bHMuY3JlYXRlUmVjb3JkID0gZnVuY3Rpb24oYywgb3B0aW9ucykge1xuICBpZighb3B0aW9ucy5kYXRhKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJlY29yZCA9IHtcbiAgICB0eXBlOiBvcHRpb25zLnR5cGUsXG4gICAgdmVyc2lvbjoge1xuICAgICAgbWFqb3I6IGMudmVyc2lvbi5tYWpvcixcbiAgICAgIG1pbm9yOiBjLnZlcnNpb24ubWlub3JcbiAgICB9LFxuICAgIGxlbmd0aDogb3B0aW9ucy5kYXRhLmxlbmd0aCgpLFxuICAgIGZyYWdtZW50OiBvcHRpb25zLmRhdGFcbiAgfTtcbiAgcmV0dXJuIHJlY29yZDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIFRMUyBhbGVydCByZWNvcmQuXG4gKlxuICogQHBhcmFtIGMgdGhlIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0gYWxlcnQ6XG4gKiAgIGxldmVsOiB0aGUgVExTIGFsZXJ0IGxldmVsLlxuICogICBkZXNjcmlwdGlvbjogdGhlIFRMUyBhbGVydCBkZXNjcmlwdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjcmVhdGVkIGFsZXJ0IHJlY29yZC5cbiAqL1xudGxzLmNyZWF0ZUFsZXJ0ID0gZnVuY3Rpb24oYywgYWxlcnQpIHtcbiAgdmFyIGIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICBiLnB1dEJ5dGUoYWxlcnQubGV2ZWwpO1xuICBiLnB1dEJ5dGUoYWxlcnQuZGVzY3JpcHRpb24pO1xuICByZXR1cm4gdGxzLmNyZWF0ZVJlY29yZChjLCB7XG4gICAgdHlwZTogdGxzLkNvbnRlbnRUeXBlLmFsZXJ0LFxuICAgIGRhdGE6IGJcbiAgfSk7XG59O1xuXG4vKiBUaGUgc3RydWN0dXJlIG9mIGEgVExTIGhhbmRzaGFrZSBtZXNzYWdlLlxuICpcbiAqIHN0cnVjdCB7XG4gKiAgICBIYW5kc2hha2VUeXBlIG1zZ190eXBlOyAgICAvLyBoYW5kc2hha2UgdHlwZVxuICogICAgdWludDI0IGxlbmd0aDsgICAgICAgICAgICAgLy8gYnl0ZXMgaW4gbWVzc2FnZVxuICogICAgc2VsZWN0KEhhbmRzaGFrZVR5cGUpIHtcbiAqICAgICAgIGNhc2UgaGVsbG9fcmVxdWVzdDogICAgICAgSGVsbG9SZXF1ZXN0O1xuICogICAgICAgY2FzZSBjbGllbnRfaGVsbG86ICAgICAgICBDbGllbnRIZWxsbztcbiAqICAgICAgIGNhc2Ugc2VydmVyX2hlbGxvOiAgICAgICAgU2VydmVySGVsbG87XG4gKiAgICAgICBjYXNlIGNlcnRpZmljYXRlOiAgICAgICAgIENlcnRpZmljYXRlO1xuICogICAgICAgY2FzZSBzZXJ2ZXJfa2V5X2V4Y2hhbmdlOiBTZXJ2ZXJLZXlFeGNoYW5nZTtcbiAqICAgICAgIGNhc2UgY2VydGlmaWNhdGVfcmVxdWVzdDogQ2VydGlmaWNhdGVSZXF1ZXN0O1xuICogICAgICAgY2FzZSBzZXJ2ZXJfaGVsbG9fZG9uZTogICBTZXJ2ZXJIZWxsb0RvbmU7XG4gKiAgICAgICBjYXNlIGNlcnRpZmljYXRlX3ZlcmlmeTogIENlcnRpZmljYXRlVmVyaWZ5O1xuICogICAgICAgY2FzZSBjbGllbnRfa2V5X2V4Y2hhbmdlOiBDbGllbnRLZXlFeGNoYW5nZTtcbiAqICAgICAgIGNhc2UgZmluaXNoZWQ6ICAgICAgICAgICAgRmluaXNoZWQ7XG4gKiAgICB9IGJvZHk7XG4gKiB9IEhhbmRzaGFrZTtcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBDbGllbnRIZWxsbyBtZXNzYWdlLlxuICpcbiAqIG9wYXF1ZSBTZXNzaW9uSUQ8MC4uMzI+O1xuICogZW51bSB7IG51bGwoMCksIGRlZmxhdGUoMSksICgyNTUpIH0gQ29tcHJlc3Npb25NZXRob2Q7XG4gKiB1aW50OCBDaXBoZXJTdWl0ZVsyXTtcbiAqXG4gKiBzdHJ1Y3Qge1xuICogICBQcm90b2NvbFZlcnNpb24gY2xpZW50X3ZlcnNpb247XG4gKiAgIFJhbmRvbSByYW5kb207XG4gKiAgIFNlc3Npb25JRCBzZXNzaW9uX2lkO1xuICogICBDaXBoZXJTdWl0ZSBjaXBoZXJfc3VpdGVzPDIuLjJeMTYtMj47XG4gKiAgIENvbXByZXNzaW9uTWV0aG9kIGNvbXByZXNzaW9uX21ldGhvZHM8MS4uMl44LTE+O1xuICogICBzZWxlY3QoZXh0ZW5zaW9uc19wcmVzZW50KSB7XG4gKiAgICAgY2FzZSBmYWxzZTpcbiAqICAgICAgIHN0cnVjdCB7fTtcbiAqICAgICBjYXNlIHRydWU6XG4gKiAgICAgICBFeHRlbnNpb24gZXh0ZW5zaW9uczwwLi4yXjE2LTE+O1xuICogICB9O1xuICogfSBDbGllbnRIZWxsbztcbiAqXG4gKiBUaGUgZXh0ZW5zaW9uIGZvcm1hdCBmb3IgZXh0ZW5kZWQgY2xpZW50IGhlbGxvcyBhbmQgc2VydmVyIGhlbGxvcyBpczpcbiAqXG4gKiBzdHJ1Y3Qge1xuICogICBFeHRlbnNpb25UeXBlIGV4dGVuc2lvbl90eXBlO1xuICogICBvcGFxdWUgZXh0ZW5zaW9uX2RhdGE8MC4uMl4xNi0xPjtcbiAqIH0gRXh0ZW5zaW9uO1xuICpcbiAqIEhlcmU6XG4gKlxuICogLSBcImV4dGVuc2lvbl90eXBlXCIgaWRlbnRpZmllcyB0aGUgcGFydGljdWxhciBleHRlbnNpb24gdHlwZS5cbiAqIC0gXCJleHRlbnNpb25fZGF0YVwiIGNvbnRhaW5zIGluZm9ybWF0aW9uIHNwZWNpZmljIHRvIHRoZSBwYXJ0aWN1bGFyXG4gKiBleHRlbnNpb24gdHlwZS5cbiAqXG4gKiBUaGUgZXh0ZW5zaW9uIHR5cGVzIGRlZmluZWQgaW4gdGhpcyBkb2N1bWVudCBhcmU6XG4gKlxuICogZW51bSB7XG4gKiAgIHNlcnZlcl9uYW1lKDApLCBtYXhfZnJhZ21lbnRfbGVuZ3RoKDEpLFxuICogICBjbGllbnRfY2VydGlmaWNhdGVfdXJsKDIpLCB0cnVzdGVkX2NhX2tleXMoMyksXG4gKiAgIHRydW5jYXRlZF9obWFjKDQpLCBzdGF0dXNfcmVxdWVzdCg1KSwgKDY1NTM1KVxuICogfSBFeHRlbnNpb25UeXBlO1xuICpcbiAqIEBwYXJhbSBjIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEByZXR1cm4gdGhlIENsaWVudEhlbGxvIGJ5dGUgYnVmZmVyLlxuICovXG50bHMuY3JlYXRlQ2xpZW50SGVsbG8gPSBmdW5jdGlvbihjKSB7XG4gIC8vIHNhdmUgaGVsbG8gdmVyc2lvblxuICBjLnNlc3Npb24uY2xpZW50SGVsbG9WZXJzaW9uID0ge1xuICAgIG1ham9yOiBjLnZlcnNpb24ubWFqb3IsXG4gICAgbWlub3I6IGMudmVyc2lvbi5taW5vclxuICB9O1xuXG4gIC8vIGNyZWF0ZSBzdXBwb3J0ZWQgY2lwaGVyIHN1aXRlc1xuICB2YXIgY2lwaGVyU3VpdGVzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGMuY2lwaGVyU3VpdGVzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNzID0gYy5jaXBoZXJTdWl0ZXNbaV07XG4gICAgY2lwaGVyU3VpdGVzLnB1dEJ5dGUoY3MuaWRbMF0pO1xuICAgIGNpcGhlclN1aXRlcy5wdXRCeXRlKGNzLmlkWzFdKTtcbiAgfVxuICB2YXIgY1N1aXRlcyA9IGNpcGhlclN1aXRlcy5sZW5ndGgoKTtcblxuICAvLyBjcmVhdGUgc3VwcG9ydGVkIGNvbXByZXNzaW9uIG1ldGhvZHMsIG51bGwgYWx3YXlzIHN1cHBvcnRlZCwgYnV0XG4gIC8vIGFsc28gc3VwcG9ydCBkZWZsYXRlIGlmIGNvbm5lY3Rpb24gaGFzIGluZmxhdGUgYW5kIGRlZmxhdGUgbWV0aG9kc1xuICB2YXIgY29tcHJlc3Npb25NZXRob2RzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgY29tcHJlc3Npb25NZXRob2RzLnB1dEJ5dGUodGxzLkNvbXByZXNzaW9uTWV0aG9kLm5vbmUpO1xuICAvLyBGSVhNRTogZGVmbGF0ZSBzdXBwb3J0IGRpc2FibGVkIHVudGlsIGlzc3VlcyB3aXRoIHJhdyBkZWZsYXRlIGRhdGFcbiAgLy8gd2l0aG91dCB6bGliIGhlYWRlcnMgYXJlIHJlc29sdmVkXG4gIC8qXG4gIGlmKGMuaW5mbGF0ZSAhPT0gbnVsbCAmJiBjLmRlZmxhdGUgIT09IG51bGwpIHtcbiAgICBjb21wcmVzc2lvbk1ldGhvZHMucHV0Qnl0ZSh0bHMuQ29tcHJlc3Npb25NZXRob2QuZGVmbGF0ZSk7XG4gIH1cbiAgKi9cbiAgdmFyIGNNZXRob2RzID0gY29tcHJlc3Npb25NZXRob2RzLmxlbmd0aCgpO1xuXG4gIC8vIGNyZWF0ZSBUTFMgU05JIChzZXJ2ZXIgbmFtZSBpbmRpY2F0aW9uKSBleHRlbnNpb24gaWYgdmlydHVhbCBob3N0XG4gIC8vIGhhcyBiZWVuIHNwZWNpZmllZCwgc2VlIFJGQyAzNTQ2XG4gIHZhciBleHRlbnNpb25zID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgaWYoYy52aXJ0dWFsSG9zdCkge1xuICAgIC8vIGNyZWF0ZSBleHRlbnNpb24gc3RydWN0XG4gICAgdmFyIGV4dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgZXh0LnB1dEJ5dGUoMHgwMCk7IC8vIHR5cGUgc2VydmVyX25hbWUgKEV4dGVuc2lvblR5cGUgaXMgMiBieXRlcylcbiAgICBleHQucHV0Qnl0ZSgweDAwKTtcblxuICAgIC8qIEluIG9yZGVyIHRvIHByb3ZpZGUgdGhlIHNlcnZlciBuYW1lLCBjbGllbnRzIE1BWSBpbmNsdWRlIGFuXG4gICAgICogZXh0ZW5zaW9uIG9mIHR5cGUgXCJzZXJ2ZXJfbmFtZVwiIGluIHRoZSAoZXh0ZW5kZWQpIGNsaWVudCBoZWxsby5cbiAgICAgKiBUaGUgXCJleHRlbnNpb25fZGF0YVwiIGZpZWxkIG9mIHRoaXMgZXh0ZW5zaW9uIFNIQUxMIGNvbnRhaW5cbiAgICAgKiBcIlNlcnZlck5hbWVMaXN0XCIgd2hlcmU6XG4gICAgICpcbiAgICAgKiBzdHJ1Y3Qge1xuICAgICAqICAgTmFtZVR5cGUgbmFtZV90eXBlO1xuICAgICAqICAgc2VsZWN0KG5hbWVfdHlwZSkge1xuICAgICAqICAgICBjYXNlIGhvc3RfbmFtZTogSG9zdE5hbWU7XG4gICAgICogICB9IG5hbWU7XG4gICAgICogfSBTZXJ2ZXJOYW1lO1xuICAgICAqXG4gICAgICogZW51bSB7XG4gICAgICogICBob3N0X25hbWUoMCksICgyNTUpXG4gICAgICogfSBOYW1lVHlwZTtcbiAgICAgKlxuICAgICAqIG9wYXF1ZSBIb3N0TmFtZTwxLi4yXjE2LTE+O1xuICAgICAqXG4gICAgICogc3RydWN0IHtcbiAgICAgKiAgIFNlcnZlck5hbWUgc2VydmVyX25hbWVfbGlzdDwxLi4yXjE2LTE+XG4gICAgICogfSBTZXJ2ZXJOYW1lTGlzdDtcbiAgICAgKi9cbiAgICB2YXIgc2VydmVyTmFtZSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgc2VydmVyTmFtZS5wdXRCeXRlKDB4MDApOyAvLyB0eXBlIGhvc3RfbmFtZVxuICAgIHdyaXRlVmVjdG9yKHNlcnZlck5hbWUsIDIsIGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGMudmlydHVhbEhvc3QpKTtcblxuICAgIC8vIFNlcnZlck5hbWVMaXN0IGlzIGluIGV4dGVuc2lvbl9kYXRhXG4gICAgdmFyIHNuTGlzdCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgd3JpdGVWZWN0b3Ioc25MaXN0LCAyLCBzZXJ2ZXJOYW1lKTtcbiAgICB3cml0ZVZlY3RvcihleHQsIDIsIHNuTGlzdCk7XG4gICAgZXh0ZW5zaW9ucy5wdXRCdWZmZXIoZXh0KTtcbiAgfVxuICB2YXIgZXh0TGVuZ3RoID0gZXh0ZW5zaW9ucy5sZW5ndGgoKTtcbiAgaWYoZXh0TGVuZ3RoID4gMCkge1xuICAgIC8vIGFkZCBleHRlbnNpb24gdmVjdG9yIGxlbmd0aFxuICAgIGV4dExlbmd0aCArPSAyO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGxlbmd0aCBvZiB0aGUgaGFuZHNoYWtlIG1lc3NhZ2VcbiAgLy8gY2lwaGVyIHN1aXRlcyBhbmQgY29tcHJlc3Npb24gbWV0aG9kcyBzaXplIHdpbGwgbmVlZCB0byBiZVxuICAvLyB1cGRhdGVkIGlmIG1vcmUgZ2V0IGFkZGVkIHRvIHRoZSBsaXN0XG4gIHZhciBzZXNzaW9uSWQgPSBjLnNlc3Npb24uaWQ7XG4gIHZhciBsZW5ndGggPVxuICAgIHNlc3Npb25JZC5sZW5ndGggKyAxICsgLy8gc2Vzc2lvbiBJRCB2ZWN0b3JcbiAgICAyICsgICAgICAgICAgICAgICAgICAgIC8vIHZlcnNpb24gKG1ham9yICsgbWlub3IpXG4gICAgNCArIDI4ICsgICAgICAgICAgICAgICAvLyByYW5kb20gdGltZSBhbmQgcmFuZG9tIGJ5dGVzXG4gICAgMiArIGNTdWl0ZXMgKyAgICAgICAgICAvLyBjaXBoZXIgc3VpdGVzIHZlY3RvclxuICAgIDEgKyBjTWV0aG9kcyArICAgICAgICAgLy8gY29tcHJlc3Npb24gbWV0aG9kcyB2ZWN0b3JcbiAgICBleHRMZW5ndGg7ICAgICAgICAgICAgIC8vIGV4dGVuc2lvbnMgdmVjdG9yXG5cbiAgLy8gYnVpbGQgcmVjb3JkIGZyYWdtZW50XG4gIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgcnZhbC5wdXRCeXRlKHRscy5IYW5kc2hha2VUeXBlLmNsaWVudF9oZWxsbyk7XG4gIHJ2YWwucHV0SW50MjQobGVuZ3RoKTsgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kc2hha2UgbGVuZ3RoXG4gIHJ2YWwucHV0Qnl0ZShjLnZlcnNpb24ubWFqb3IpOyAgICAgICAgICAgICAvLyBtYWpvciB2ZXJzaW9uXG4gIHJ2YWwucHV0Qnl0ZShjLnZlcnNpb24ubWlub3IpOyAgICAgICAgICAgICAvLyBtaW5vciB2ZXJzaW9uXG4gIHJ2YWwucHV0Qnl0ZXMoYy5zZXNzaW9uLnNwLmNsaWVudF9yYW5kb20pOyAvLyByYW5kb20gdGltZSArIGJ5dGVzXG4gIHdyaXRlVmVjdG9yKHJ2YWwsIDEsIGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKHNlc3Npb25JZCkpO1xuICB3cml0ZVZlY3RvcihydmFsLCAyLCBjaXBoZXJTdWl0ZXMpO1xuICB3cml0ZVZlY3RvcihydmFsLCAxLCBjb21wcmVzc2lvbk1ldGhvZHMpO1xuICBpZihleHRMZW5ndGggPiAwKSB7XG4gICAgd3JpdGVWZWN0b3IocnZhbCwgMiwgZXh0ZW5zaW9ucyk7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBTZXJ2ZXJIZWxsbyBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBjIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEByZXR1cm4gdGhlIFNlcnZlckhlbGxvIGJ5dGUgYnVmZmVyLlxuICovXG50bHMuY3JlYXRlU2VydmVySGVsbG8gPSBmdW5jdGlvbihjKSB7XG4gIC8vIGRldGVybWluZSBsZW5ndGggb2YgdGhlIGhhbmRzaGFrZSBtZXNzYWdlXG4gIHZhciBzZXNzaW9uSWQgPSBjLnNlc3Npb24uaWQ7XG4gIHZhciBsZW5ndGggPVxuICAgIHNlc3Npb25JZC5sZW5ndGggKyAxICsgLy8gc2Vzc2lvbiBJRCB2ZWN0b3JcbiAgICAyICsgICAgICAgICAgICAgICAgICAgIC8vIHZlcnNpb24gKG1ham9yICsgbWlub3IpXG4gICAgNCArIDI4ICsgICAgICAgICAgICAgICAvLyByYW5kb20gdGltZSBhbmQgcmFuZG9tIGJ5dGVzXG4gICAgMiArICAgICAgICAgICAgICAgICAgICAvLyBjaG9zZW4gY2lwaGVyIHN1aXRlXG4gICAgMTsgICAgICAgICAgICAgICAgICAgICAvLyBjaG9zZW4gY29tcHJlc3Npb24gbWV0aG9kXG5cbiAgLy8gYnVpbGQgcmVjb3JkIGZyYWdtZW50XG4gIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgcnZhbC5wdXRCeXRlKHRscy5IYW5kc2hha2VUeXBlLnNlcnZlcl9oZWxsbyk7XG4gIHJ2YWwucHV0SW50MjQobGVuZ3RoKTsgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kc2hha2UgbGVuZ3RoXG4gIHJ2YWwucHV0Qnl0ZShjLnZlcnNpb24ubWFqb3IpOyAgICAgICAgICAgICAvLyBtYWpvciB2ZXJzaW9uXG4gIHJ2YWwucHV0Qnl0ZShjLnZlcnNpb24ubWlub3IpOyAgICAgICAgICAgICAvLyBtaW5vciB2ZXJzaW9uXG4gIHJ2YWwucHV0Qnl0ZXMoYy5zZXNzaW9uLnNwLnNlcnZlcl9yYW5kb20pOyAvLyByYW5kb20gdGltZSArIGJ5dGVzXG4gIHdyaXRlVmVjdG9yKHJ2YWwsIDEsIGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKHNlc3Npb25JZCkpO1xuICBydmFsLnB1dEJ5dGUoYy5zZXNzaW9uLmNpcGhlclN1aXRlLmlkWzBdKTtcbiAgcnZhbC5wdXRCeXRlKGMuc2Vzc2lvbi5jaXBoZXJTdWl0ZS5pZFsxXSk7XG4gIHJ2YWwucHV0Qnl0ZShjLnNlc3Npb24uY29tcHJlc3Npb25NZXRob2QpO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIENlcnRpZmljYXRlIG1lc3NhZ2UuXG4gKlxuICogV2hlbiB0aGlzIG1lc3NhZ2Ugd2lsbCBiZSBzZW50OlxuICogICBUaGlzIGlzIHRoZSBmaXJzdCBtZXNzYWdlIHRoZSBjbGllbnQgY2FuIHNlbmQgYWZ0ZXIgcmVjZWl2aW5nIGEgc2VydmVyXG4gKiAgIGhlbGxvIGRvbmUgbWVzc2FnZSBhbmQgdGhlIGZpcnN0IG1lc3NhZ2UgdGhlIHNlcnZlciBjYW4gc2VuZCBhZnRlclxuICogICBzZW5kaW5nIGEgU2VydmVySGVsbG8uIFRoaXMgY2xpZW50IG1lc3NhZ2UgaXMgb25seSBzZW50IGlmIHRoZSBzZXJ2ZXJcbiAqICAgcmVxdWVzdHMgYSBjZXJ0aWZpY2F0ZS4gSWYgbm8gc3VpdGFibGUgY2VydGlmaWNhdGUgaXMgYXZhaWxhYmxlLCB0aGVcbiAqICAgY2xpZW50IHNob3VsZCBzZW5kIGEgY2VydGlmaWNhdGUgbWVzc2FnZSBjb250YWluaW5nIG5vIGNlcnRpZmljYXRlcy4gSWZcbiAqICAgY2xpZW50IGF1dGhlbnRpY2F0aW9uIGlzIHJlcXVpcmVkIGJ5IHRoZSBzZXJ2ZXIgZm9yIHRoZSBoYW5kc2hha2UgdG9cbiAqICAgY29udGludWUsIGl0IG1heSByZXNwb25kIHdpdGggYSBmYXRhbCBoYW5kc2hha2UgZmFpbHVyZSBhbGVydC5cbiAqXG4gKiBvcGFxdWUgQVNOLjFDZXJ0PDEuLjJeMjQtMT47XG4gKlxuICogc3RydWN0IHtcbiAqICAgQVNOLjFDZXJ0IGNlcnRpZmljYXRlX2xpc3Q8MC4uMl4yNC0xPjtcbiAqIH0gQ2VydGlmaWNhdGU7XG4gKlxuICogQHBhcmFtIGMgdGhlIGNvbm5lY3Rpb24uXG4gKlxuICogQHJldHVybiB0aGUgQ2VydGlmaWNhdGUgYnl0ZSBidWZmZXIuXG4gKi9cbnRscy5jcmVhdGVDZXJ0aWZpY2F0ZSA9IGZ1bmN0aW9uKGMpIHtcbiAgLy8gVE9ETzogY2hlY2sgY2VydGlmaWNhdGUgcmVxdWVzdCB0byBlbnN1cmUgdHlwZXMgYXJlIHN1cHBvcnRlZFxuXG4gIC8vIGdldCBhIGNlcnRpZmljYXRlIChhIGNlcnRpZmljYXRlIGFzIGEgUEVNIHN0cmluZylcbiAgdmFyIGNsaWVudCA9IChjLmVudGl0eSA9PT0gdGxzLkNvbm5lY3Rpb25FbmQuY2xpZW50KTtcbiAgdmFyIGNlcnQgPSBudWxsO1xuICBpZihjLmdldENlcnRpZmljYXRlKSB7XG4gICAgdmFyIGhpbnQ7XG4gICAgaWYoY2xpZW50KSB7XG4gICAgICBoaW50ID0gYy5zZXNzaW9uLmNlcnRpZmljYXRlUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGludCA9IGMuc2Vzc2lvbi5leHRlbnNpb25zLnNlcnZlcl9uYW1lLnNlcnZlck5hbWVMaXN0O1xuICAgIH1cbiAgICBjZXJ0ID0gYy5nZXRDZXJ0aWZpY2F0ZShjLCBoaW50KTtcbiAgfVxuXG4gIC8vIGJ1ZmZlciB0byBob2xkIGNlcnRpZmljYXRlIGxpc3RcbiAgdmFyIGNlcnRMaXN0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgaWYoY2VydCAhPT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBub3JtYWxpemUgY2VydCB0byBhIGNoYWluIG9mIGNlcnRpZmljYXRlc1xuICAgICAgaWYoIWZvcmdlLnV0aWwuaXNBcnJheShjZXJ0KSkge1xuICAgICAgICBjZXJ0ID0gW2NlcnRdO1xuICAgICAgfVxuICAgICAgdmFyIGFzbjEgPSBudWxsO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNlcnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUoY2VydFtpXSlbMF07XG4gICAgICAgIGlmKG1zZy50eXBlICE9PSAnQ0VSVElGSUNBVEUnICYmXG4gICAgICAgICAgbXNnLnR5cGUgIT09ICdYNTA5IENFUlRJRklDQVRFJyAmJlxuICAgICAgICAgIG1zZy50eXBlICE9PSAnVFJVU1RFRCBDRVJUSUZJQ0FURScpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGNlcnRpZmljYXRlIGZyb20gUEVNOyBQRU0gJyArXG4gICAgICAgICAgICAnaGVhZGVyIHR5cGUgaXMgbm90IFwiQ0VSVElGSUNBVEVcIiwgXCJYNTA5IENFUlRJRklDQVRFXCIsIG9yICcgK1xuICAgICAgICAgICAgJ1wiVFJVU1RFRCBDRVJUSUZJQ0FURVwiLicpO1xuICAgICAgICAgIGVycm9yLmhlYWRlclR5cGUgPSBtc2cudHlwZTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBjZXJ0aWZpY2F0ZSBmcm9tIFBFTTsgUEVNIGlzIGVuY3J5cHRlZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZXIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihtc2cuYm9keSk7XG4gICAgICAgIGlmKGFzbjEgPT09IG51bGwpIHtcbiAgICAgICAgICBhc24xID0gZm9yZ2UuYXNuMS5mcm9tRGVyKGRlci5ieXRlcygpLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjZXJ0aWZpY2F0ZSBlbnRyeSBpcyBpdHNlbGYgYSB2ZWN0b3Igd2l0aCAzIGxlbmd0aCBieXRlc1xuICAgICAgICB2YXIgY2VydEJ1ZmZlciA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIHdyaXRlVmVjdG9yKGNlcnRCdWZmZXIsIDMsIGRlcik7XG5cbiAgICAgICAgLy8gYWRkIGNlcnQgdmVjdG9yIHRvIGNlcnQgbGlzdCB2ZWN0b3JcbiAgICAgICAgY2VydExpc3QucHV0QnVmZmVyKGNlcnRCdWZmZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyBzYXZlIGNlcnRpZmljYXRlXG4gICAgICBjZXJ0ID0gZm9yZ2UucGtpLmNlcnRpZmljYXRlRnJvbUFzbjEoYXNuMSk7XG4gICAgICBpZihjbGllbnQpIHtcbiAgICAgICAgYy5zZXNzaW9uLmNsaWVudENlcnRpZmljYXRlID0gY2VydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGMuc2Vzc2lvbi5zZXJ2ZXJDZXJ0aWZpY2F0ZSA9IGNlcnQ7XG4gICAgICB9XG4gICAgfSBjYXRjaChleCkge1xuICAgICAgcmV0dXJuIGMuZXJyb3IoYywge1xuICAgICAgICBtZXNzYWdlOiAnQ291bGQgbm90IHNlbmQgY2VydGlmaWNhdGUgbGlzdC4nLFxuICAgICAgICBjYXVzZTogZXgsXG4gICAgICAgIHNlbmQ6IHRydWUsXG4gICAgICAgIGFsZXJ0OiB7XG4gICAgICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC5mYXRhbCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmJhZF9jZXJ0aWZpY2F0ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgbGVuZ3RoIG9mIHRoZSBoYW5kc2hha2UgbWVzc2FnZVxuICB2YXIgbGVuZ3RoID0gMyArIGNlcnRMaXN0Lmxlbmd0aCgpOyAvLyBjZXJ0IGxpc3QgdmVjdG9yXG5cbiAgLy8gYnVpbGQgcmVjb3JkIGZyYWdtZW50XG4gIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgcnZhbC5wdXRCeXRlKHRscy5IYW5kc2hha2VUeXBlLmNlcnRpZmljYXRlKTtcbiAgcnZhbC5wdXRJbnQyNChsZW5ndGgpO1xuICB3cml0ZVZlY3RvcihydmFsLCAzLCBjZXJ0TGlzdCk7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgQ2xpZW50S2V5RXhjaGFuZ2UgbWVzc2FnZS5cbiAqXG4gKiBXaGVuIHRoaXMgbWVzc2FnZSB3aWxsIGJlIHNlbnQ6XG4gKiAgIFRoaXMgbWVzc2FnZSBpcyBhbHdheXMgc2VudCBieSB0aGUgY2xpZW50LiBJdCB3aWxsIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGVcbiAqICAgY2xpZW50IGNlcnRpZmljYXRlIG1lc3NhZ2UsIGlmIGl0IGlzIHNlbnQuIE90aGVyd2lzZSBpdCB3aWxsIGJlIHRoZSBmaXJzdFxuICogICBtZXNzYWdlIHNlbnQgYnkgdGhlIGNsaWVudCBhZnRlciBpdCByZWNlaXZlcyB0aGUgc2VydmVyIGhlbGxvIGRvbmVcbiAqICAgbWVzc2FnZS5cbiAqXG4gKiBNZWFuaW5nIG9mIHRoaXMgbWVzc2FnZTpcbiAqICAgV2l0aCB0aGlzIG1lc3NhZ2UsIHRoZSBwcmVtYXN0ZXIgc2VjcmV0IGlzIHNldCwgZWl0aGVyIHRob3VnaCBkaXJlY3RcbiAqICAgdHJhbnNtaXNzaW9uIG9mIHRoZSBSU0EtZW5jcnlwdGVkIHNlY3JldCwgb3IgYnkgdGhlIHRyYW5zbWlzc2lvbiBvZlxuICogICBEaWZmaWUtSGVsbG1hbiBwYXJhbWV0ZXJzIHdoaWNoIHdpbGwgYWxsb3cgZWFjaCBzaWRlIHRvIGFncmVlIHVwb24gdGhlXG4gKiAgIHNhbWUgcHJlbWFzdGVyIHNlY3JldC4gV2hlbiB0aGUga2V5IGV4Y2hhbmdlIG1ldGhvZCBpcyBESF9SU0Egb3IgREhfRFNTLFxuICogICBjbGllbnQgY2VydGlmaWNhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQsIGFuZCB0aGUgY2xpZW50IHdhcyBhYmxlIHRvXG4gKiAgIHJlc3BvbmQgd2l0aCBhIGNlcnRpZmljYXRlIHdoaWNoIGNvbnRhaW5lZCBhIERpZmZpZS1IZWxsbWFuIHB1YmxpYyBrZXlcbiAqICAgd2hvc2UgcGFyYW1ldGVycyAoZ3JvdXAgYW5kIGdlbmVyYXRvcikgbWF0Y2hlZCB0aG9zZSBzcGVjaWZpZWQgYnkgdGhlXG4gKiAgIHNlcnZlciBpbiBpdHMgY2VydGlmaWNhdGUsIHRoaXMgbWVzc2FnZSB3aWxsIG5vdCBjb250YWluIGFueSBkYXRhLlxuICpcbiAqIE1lYW5pbmcgb2YgdGhpcyBtZXNzYWdlOlxuICogICBJZiBSU0EgaXMgYmVpbmcgdXNlZCBmb3Iga2V5IGFncmVlbWVudCBhbmQgYXV0aGVudGljYXRpb24sIHRoZSBjbGllbnRcbiAqICAgZ2VuZXJhdGVzIGEgNDgtYnl0ZSBwcmVtYXN0ZXIgc2VjcmV0LCBlbmNyeXB0cyBpdCB1c2luZyB0aGUgcHVibGljIGtleVxuICogICBmcm9tIHRoZSBzZXJ2ZXIncyBjZXJ0aWZpY2F0ZSBvciB0aGUgdGVtcG9yYXJ5IFJTQSBrZXkgcHJvdmlkZWQgaW4gYVxuICogICBzZXJ2ZXIga2V5IGV4Y2hhbmdlIG1lc3NhZ2UsIGFuZCBzZW5kcyB0aGUgcmVzdWx0IGluIGFuIGVuY3J5cHRlZFxuICogICBwcmVtYXN0ZXIgc2VjcmV0IG1lc3NhZ2UuIFRoaXMgc3RydWN0dXJlIGlzIGEgdmFyaWFudCBvZiB0aGUgY2xpZW50XG4gKiAgIGtleSBleGNoYW5nZSBtZXNzYWdlLCBub3QgYSBtZXNzYWdlIGluIGl0c2VsZi5cbiAqXG4gKiBzdHJ1Y3Qge1xuICogICBzZWxlY3QoS2V5RXhjaGFuZ2VBbGdvcml0aG0pIHtcbiAqICAgICBjYXNlIHJzYTogRW5jcnlwdGVkUHJlTWFzdGVyU2VjcmV0O1xuICogICAgIGNhc2UgZGlmZmllX2hlbGxtYW46IENsaWVudERpZmZpZUhlbGxtYW5QdWJsaWM7XG4gKiAgIH0gZXhjaGFuZ2Vfa2V5cztcbiAqIH0gQ2xpZW50S2V5RXhjaGFuZ2U7XG4gKlxuICogc3RydWN0IHtcbiAqICAgUHJvdG9jb2xWZXJzaW9uIGNsaWVudF92ZXJzaW9uO1xuICogICBvcGFxdWUgcmFuZG9tWzQ2XTtcbiAqIH0gUHJlTWFzdGVyU2VjcmV0O1xuICpcbiAqIHN0cnVjdCB7XG4gKiAgIHB1YmxpYy1rZXktZW5jcnlwdGVkIFByZU1hc3RlclNlY3JldCBwcmVfbWFzdGVyX3NlY3JldDtcbiAqIH0gRW5jcnlwdGVkUHJlTWFzdGVyU2VjcmV0O1xuICpcbiAqIEEgcHVibGljLWtleS1lbmNyeXB0ZWQgZWxlbWVudCBpcyBlbmNvZGVkIGFzIGEgdmVjdG9yIDwwLi4yXjE2LTE+LlxuICpcbiAqIEBwYXJhbSBjIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEByZXR1cm4gdGhlIENsaWVudEtleUV4Y2hhbmdlIGJ5dGUgYnVmZmVyLlxuICovXG50bHMuY3JlYXRlQ2xpZW50S2V5RXhjaGFuZ2UgPSBmdW5jdGlvbihjKSB7XG4gIC8vIGNyZWF0ZSBidWZmZXIgdG8gZW5jcnlwdFxuICB2YXIgYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gYWRkIGhpZ2hlc3QgY2xpZW50LXN1cHBvcnRlZCBwcm90b2NvbCB0byBoZWxwIHNlcnZlciBhdm9pZCB2ZXJzaW9uXG4gIC8vIHJvbGxiYWNrIGF0dGFja3NcbiAgYi5wdXRCeXRlKGMuc2Vzc2lvbi5jbGllbnRIZWxsb1ZlcnNpb24ubWFqb3IpO1xuICBiLnB1dEJ5dGUoYy5zZXNzaW9uLmNsaWVudEhlbGxvVmVyc2lvbi5taW5vcik7XG5cbiAgLy8gZ2VuZXJhdGUgYW5kIGFkZCA0NiByYW5kb20gYnl0ZXNcbiAgYi5wdXRCeXRlcyhmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMoNDYpKTtcblxuICAvLyBzYXZlIHByZS1tYXN0ZXIgc2VjcmV0XG4gIHZhciBzcCA9IGMuc2Vzc2lvbi5zcDtcbiAgc3AucHJlX21hc3Rlcl9zZWNyZXQgPSBiLmdldEJ5dGVzKCk7XG5cbiAgLy8gUlNBLWVuY3J5cHQgdGhlIHByZS1tYXN0ZXIgc2VjcmV0XG4gIHZhciBrZXkgPSBjLnNlc3Npb24uc2VydmVyQ2VydGlmaWNhdGUucHVibGljS2V5O1xuICBiID0ga2V5LmVuY3J5cHQoc3AucHJlX21hc3Rlcl9zZWNyZXQpO1xuXG4gIC8qIE5vdGU6IFRoZSBlbmNyeXB0ZWQgcHJlLW1hc3RlciBzZWNyZXQgd2lsbCBiZSBzdG9yZWQgaW4gYVxuICAgIHB1YmxpYy1rZXktZW5jcnlwdGVkIG9wYXF1ZSB2ZWN0b3IgdGhhdCBoYXMgdGhlIGxlbmd0aCBwcmVmaXhlZCB1c2luZ1xuICAgIDIgYnl0ZXMsIHNvIGluY2x1ZGUgdGhvc2UgMiBieXRlcyBpbiB0aGUgaGFuZHNoYWtlIG1lc3NhZ2UgbGVuZ3RoLiBUaGlzXG4gICAgaXMgZG9uZSBhcyBhIG1pbm9yIG9wdGltaXphdGlvbiBpbnN0ZWFkIG9mIGNhbGxpbmcgd3JpdGVWZWN0b3IoKS4gKi9cblxuICAvLyBkZXRlcm1pbmUgbGVuZ3RoIG9mIHRoZSBoYW5kc2hha2UgbWVzc2FnZVxuICB2YXIgbGVuZ3RoID0gYi5sZW5ndGggKyAyO1xuXG4gIC8vIGJ1aWxkIHJlY29yZCBmcmFnbWVudFxuICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIHJ2YWwucHV0Qnl0ZSh0bHMuSGFuZHNoYWtlVHlwZS5jbGllbnRfa2V5X2V4Y2hhbmdlKTtcbiAgcnZhbC5wdXRJbnQyNChsZW5ndGgpO1xuICAvLyBhZGQgdmVjdG9yIGxlbmd0aCBieXRlc1xuICBydmFsLnB1dEludDE2KGIubGVuZ3RoKTtcbiAgcnZhbC5wdXRCeXRlcyhiKTtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBTZXJ2ZXJLZXlFeGNoYW5nZSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBjIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEByZXR1cm4gdGhlIFNlcnZlcktleUV4Y2hhbmdlIGJ5dGUgYnVmZmVyLlxuICovXG50bHMuY3JlYXRlU2VydmVyS2V5RXhjaGFuZ2UgPSBmdW5jdGlvbihjKSB7XG4gIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBSU0EsIG5vIERpZmZpZS1IZWxsbWFuIHN1cHBvcnQsXG4gIC8vIHNvIHRoaXMgcmVjb3JkIGlzIGVtcHR5XG5cbiAgLy8gZGV0ZXJtaW5lIGxlbmd0aCBvZiB0aGUgaGFuZHNoYWtlIG1lc3NhZ2VcbiAgdmFyIGxlbmd0aCA9IDA7XG5cbiAgLy8gYnVpbGQgcmVjb3JkIGZyYWdtZW50XG4gIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgaWYobGVuZ3RoID4gMCkge1xuICAgIHJ2YWwucHV0Qnl0ZSh0bHMuSGFuZHNoYWtlVHlwZS5zZXJ2ZXJfa2V5X2V4Y2hhbmdlKTtcbiAgICBydmFsLnB1dEludDI0KGxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHNpZ25lZCBkYXRhIHVzZWQgdG8gdmVyaWZ5IGEgY2xpZW50LXNpZGUgY2VydGlmaWNhdGUuIFNlZVxuICogdGxzLmNyZWF0ZUNlcnRpZmljYXRlVmVyaWZ5KCkgZm9yIGRldGFpbHMuXG4gKlxuICogQHBhcmFtIGMgdGhlIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIHRvIGNhbGwgb25jZSB0aGUgc2lnbmVkIGRhdGEgaXMgcmVhZHkuXG4gKi9cbnRscy5nZXRDbGllbnRTaWduYXR1cmUgPSBmdW5jdGlvbihjLCBjYWxsYmFjaykge1xuICAvLyBnZW5lcmF0ZSBkYXRhIHRvIFJTQSBlbmNyeXB0XG4gIHZhciBiID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgYi5wdXRCdWZmZXIoYy5zZXNzaW9uLm1kNS5kaWdlc3QoKSk7XG4gIGIucHV0QnVmZmVyKGMuc2Vzc2lvbi5zaGExLmRpZ2VzdCgpKTtcbiAgYiA9IGIuZ2V0Qnl0ZXMoKTtcblxuICAvLyBjcmVhdGUgZGVmYXVsdCBzaWduaW5nIGZ1bmN0aW9uIGFzIG5lY2Vzc2FyeVxuICBjLmdldFNpZ25hdHVyZSA9IGMuZ2V0U2lnbmF0dXJlIHx8IGZ1bmN0aW9uKGMsIGIsIGNhbGxiYWNrKSB7XG4gICAgLy8gZG8gcnNhIGVuY3J5cHRpb24sIGNhbGwgY2FsbGJhY2tcbiAgICB2YXIgcHJpdmF0ZUtleSA9IG51bGw7XG4gICAgaWYoYy5nZXRQcml2YXRlS2V5KSB7XG4gICAgICB0cnkge1xuICAgICAgICBwcml2YXRlS2V5ID0gYy5nZXRQcml2YXRlS2V5KGMsIGMuc2Vzc2lvbi5jbGllbnRDZXJ0aWZpY2F0ZSk7XG4gICAgICAgIHByaXZhdGVLZXkgPSBmb3JnZS5wa2kucHJpdmF0ZUtleUZyb21QZW0ocHJpdmF0ZUtleSk7XG4gICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgIGMuZXJyb3IoYywge1xuICAgICAgICAgIG1lc3NhZ2U6ICdDb3VsZCBub3QgZ2V0IHByaXZhdGUga2V5LicsXG4gICAgICAgICAgY2F1c2U6IGV4LFxuICAgICAgICAgIHNlbmQ6IHRydWUsXG4gICAgICAgICAgYWxlcnQ6IHtcbiAgICAgICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwuZmF0YWwsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmludGVybmFsX2Vycm9yXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYocHJpdmF0ZUtleSA9PT0gbnVsbCkge1xuICAgICAgYy5lcnJvcihjLCB7XG4gICAgICAgIG1lc3NhZ2U6ICdObyBwcml2YXRlIGtleSBzZXQuJyxcbiAgICAgICAgc2VuZDogdHJ1ZSxcbiAgICAgICAgYWxlcnQ6IHtcbiAgICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24uaW50ZXJuYWxfZXJyb3JcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGIgPSBwcml2YXRlS2V5LnNpZ24oYiwgbnVsbCk7XG4gICAgfVxuICAgIGNhbGxiYWNrKGMsIGIpO1xuICB9O1xuXG4gIC8vIGdldCBjbGllbnQgc2lnbmF0dXJlXG4gIGMuZ2V0U2lnbmF0dXJlKGMsIGIsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIENlcnRpZmljYXRlVmVyaWZ5IG1lc3NhZ2UuXG4gKlxuICogTWVhbmluZyBvZiB0aGlzIG1lc3NhZ2U6XG4gKiAgIFRoaXMgc3RydWN0dXJlIGNvbnZleXMgdGhlIGNsaWVudCdzIERpZmZpZS1IZWxsbWFuIHB1YmxpYyB2YWx1ZVxuICogICAoWWMpIGlmIGl0IHdhcyBub3QgYWxyZWFkeSBpbmNsdWRlZCBpbiB0aGUgY2xpZW50J3MgY2VydGlmaWNhdGUuXG4gKiAgIFRoZSBlbmNvZGluZyB1c2VkIGZvciBZYyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBlbnVtZXJhdGVkXG4gKiAgIFB1YmxpY1ZhbHVlRW5jb2RpbmcuIFRoaXMgc3RydWN0dXJlIGlzIGEgdmFyaWFudCBvZiB0aGUgY2xpZW50XG4gKiAgIGtleSBleGNoYW5nZSBtZXNzYWdlLCBub3QgYSBtZXNzYWdlIGluIGl0c2VsZi5cbiAqXG4gKiBXaGVuIHRoaXMgbWVzc2FnZSB3aWxsIGJlIHNlbnQ6XG4gKiAgIFRoaXMgbWVzc2FnZSBpcyB1c2VkIHRvIHByb3ZpZGUgZXhwbGljaXQgdmVyaWZpY2F0aW9uIG9mIGEgY2xpZW50XG4gKiAgIGNlcnRpZmljYXRlLiBUaGlzIG1lc3NhZ2UgaXMgb25seSBzZW50IGZvbGxvd2luZyBhIGNsaWVudFxuICogICBjZXJ0aWZpY2F0ZSB0aGF0IGhhcyBzaWduaW5nIGNhcGFiaWxpdHkgKGkuZS4gYWxsIGNlcnRpZmljYXRlc1xuICogICBleGNlcHQgdGhvc2UgY29udGFpbmluZyBmaXhlZCBEaWZmaWUtSGVsbG1hbiBwYXJhbWV0ZXJzKS4gV2hlblxuICogICBzZW50LCBpdCB3aWxsIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgY2xpZW50IGtleSBleGNoYW5nZSBtZXNzYWdlLlxuICpcbiAqIHN0cnVjdCB7XG4gKiAgIFNpZ25hdHVyZSBzaWduYXR1cmU7XG4gKiB9IENlcnRpZmljYXRlVmVyaWZ5O1xuICpcbiAqIENlcnRpZmljYXRlVmVyaWZ5LnNpZ25hdHVyZS5tZDVfaGFzaFxuICogICBNRDUoaGFuZHNoYWtlX21lc3NhZ2VzKTtcbiAqXG4gKiBDZXJ0aWZpY2F0ZS5zaWduYXR1cmUuc2hhX2hhc2hcbiAqICAgU0hBKGhhbmRzaGFrZV9tZXNzYWdlcyk7XG4gKlxuICogSGVyZSBoYW5kc2hha2VfbWVzc2FnZXMgcmVmZXJzIHRvIGFsbCBoYW5kc2hha2UgbWVzc2FnZXMgc2VudCBvclxuICogcmVjZWl2ZWQgc3RhcnRpbmcgYXQgY2xpZW50IGhlbGxvIHVwIHRvIGJ1dCBub3QgaW5jbHVkaW5nIHRoaXNcbiAqIG1lc3NhZ2UsIGluY2x1ZGluZyB0aGUgdHlwZSBhbmQgbGVuZ3RoIGZpZWxkcyBvZiB0aGUgaGFuZHNoYWtlXG4gKiBtZXNzYWdlcy5cbiAqXG4gKiBzZWxlY3QoU2lnbmF0dXJlQWxnb3JpdGhtKSB7XG4gKiAgIGNhc2UgYW5vbnltb3VzOiBzdHJ1Y3QgeyB9O1xuICogICBjYXNlIHJzYTpcbiAqICAgICBkaWdpdGFsbHktc2lnbmVkIHN0cnVjdCB7XG4gKiAgICAgICBvcGFxdWUgbWQ1X2hhc2hbMTZdO1xuICogICAgICAgb3BhcXVlIHNoYV9oYXNoWzIwXTtcbiAqICAgICB9O1xuICogICBjYXNlIGRzYTpcbiAqICAgICBkaWdpdGFsbHktc2lnbmVkIHN0cnVjdCB7XG4gKiAgICAgICBvcGFxdWUgc2hhX2hhc2hbMjBdO1xuICogICAgIH07XG4gKiB9IFNpZ25hdHVyZTtcbiAqXG4gKiBJbiBkaWdpdGFsIHNpZ25pbmcsIG9uZS13YXkgaGFzaCBmdW5jdGlvbnMgYXJlIHVzZWQgYXMgaW5wdXQgZm9yIGFcbiAqIHNpZ25pbmcgYWxnb3JpdGhtLiBBIGRpZ2l0YWxseS1zaWduZWQgZWxlbWVudCBpcyBlbmNvZGVkIGFzIGFuIG9wYXF1ZVxuICogdmVjdG9yIDwwLi4yXjE2LTE+LCB3aGVyZSB0aGUgbGVuZ3RoIGlzIHNwZWNpZmllZCBieSB0aGUgc2lnbmluZ1xuICogYWxnb3JpdGhtIGFuZCBrZXkuXG4gKlxuICogSW4gUlNBIHNpZ25pbmcsIGEgMzYtYnl0ZSBzdHJ1Y3R1cmUgb2YgdHdvIGhhc2hlcyAob25lIFNIQSBhbmQgb25lXG4gKiBNRDUpIGlzIHNpZ25lZCAoZW5jcnlwdGVkIHdpdGggdGhlIHByaXZhdGUga2V5KS4gSXQgaXMgZW5jb2RlZCB3aXRoXG4gKiBQS0NTICMxIGJsb2NrIHR5cGUgMCBvciB0eXBlIDEgYXMgZGVzY3JpYmVkIGluIFtQS0NTMV0uXG4gKlxuICogSW4gRFNTLCB0aGUgMjAgYnl0ZXMgb2YgdGhlIFNIQSBoYXNoIGFyZSBydW4gZGlyZWN0bHkgdGhyb3VnaCB0aGVcbiAqIERpZ2l0YWwgU2lnbmluZyBBbGdvcml0aG0gd2l0aCBubyBhZGRpdGlvbmFsIGhhc2hpbmcuXG4gKlxuICogQHBhcmFtIGMgdGhlIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0gc2lnbmF0dXJlIHRoZSBzaWduYXR1cmUgdG8gaW5jbHVkZSBpbiB0aGUgbWVzc2FnZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBDZXJ0aWZpY2F0ZVZlcmlmeSBieXRlIGJ1ZmZlci5cbiAqL1xudGxzLmNyZWF0ZUNlcnRpZmljYXRlVmVyaWZ5ID0gZnVuY3Rpb24oYywgc2lnbmF0dXJlKSB7XG4gIC8qIE5vdGU6IFRoZSBzaWduYXR1cmUgd2lsbCBiZSBzdG9yZWQgaW4gYSBcImRpZ2l0YWxseS1zaWduZWRcIiBvcGFxdWVcbiAgICB2ZWN0b3IgdGhhdCBoYXMgdGhlIGxlbmd0aCBwcmVmaXhlZCB1c2luZyAyIGJ5dGVzLCBzbyBpbmNsdWRlIHRob3NlXG4gICAgMiBieXRlcyBpbiB0aGUgaGFuZHNoYWtlIG1lc3NhZ2UgbGVuZ3RoLiBUaGlzIGlzIGRvbmUgYXMgYSBtaW5vclxuICAgIG9wdGltaXphdGlvbiBpbnN0ZWFkIG9mIGNhbGxpbmcgd3JpdGVWZWN0b3IoKS4gKi9cblxuICAvLyBkZXRlcm1pbmUgbGVuZ3RoIG9mIHRoZSBoYW5kc2hha2UgbWVzc2FnZVxuICB2YXIgbGVuZ3RoID0gc2lnbmF0dXJlLmxlbmd0aCArIDI7XG5cbiAgLy8gYnVpbGQgcmVjb3JkIGZyYWdtZW50XG4gIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgcnZhbC5wdXRCeXRlKHRscy5IYW5kc2hha2VUeXBlLmNlcnRpZmljYXRlX3ZlcmlmeSk7XG4gIHJ2YWwucHV0SW50MjQobGVuZ3RoKTtcbiAgLy8gYWRkIHZlY3RvciBsZW5ndGggYnl0ZXNcbiAgcnZhbC5wdXRJbnQxNihzaWduYXR1cmUubGVuZ3RoKTtcbiAgcnZhbC5wdXRCeXRlcyhzaWduYXR1cmUpO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIENlcnRpZmljYXRlUmVxdWVzdCBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBjIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEByZXR1cm4gdGhlIENlcnRpZmljYXRlUmVxdWVzdCBieXRlIGJ1ZmZlci5cbiAqL1xudGxzLmNyZWF0ZUNlcnRpZmljYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKGMpIHtcbiAgLy8gVE9ETzogc3VwcG9ydCBvdGhlciBjZXJ0aWZpY2F0ZSB0eXBlc1xuICB2YXIgY2VydFR5cGVzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcblxuICAvLyBjb21tb24gUlNBIGNlcnRpZmljYXRlIHR5cGVcbiAgY2VydFR5cGVzLnB1dEJ5dGUoMHgwMSk7XG5cbiAgLy8gYWRkIGRpc3Rpbmd1aXNoZWQgbmFtZXMgZnJvbSBDQSBzdG9yZVxuICB2YXIgY0FzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgZm9yKHZhciBrZXkgaW4gYy5jYVN0b3JlLmNlcnRzKSB7XG4gICAgdmFyIGNlcnQgPSBjLmNhU3RvcmUuY2VydHNba2V5XTtcbiAgICB2YXIgZG4gPSBmb3JnZS5wa2kuZGlzdGluZ3Vpc2hlZE5hbWVUb0FzbjEoY2VydC5zdWJqZWN0KTtcbiAgICB2YXIgYnl0ZUJ1ZmZlciA9IGZvcmdlLmFzbjEudG9EZXIoZG4pO1xuICAgIGNBcy5wdXRJbnQxNihieXRlQnVmZmVyLmxlbmd0aCgpKTtcbiAgICBjQXMucHV0QnVmZmVyKGJ5dGVCdWZmZXIpO1xuICB9XG5cbiAgLy8gVE9ETzogVExTIDEuMisgaGFzIGEgZGlmZmVyZW50IGZvcm1hdFxuXG4gIC8vIGRldGVybWluZSBsZW5ndGggb2YgdGhlIGhhbmRzaGFrZSBtZXNzYWdlXG4gIHZhciBsZW5ndGggPVxuICAgIDEgKyBjZXJ0VHlwZXMubGVuZ3RoKCkgK1xuICAgIDIgKyBjQXMubGVuZ3RoKCk7XG5cbiAgLy8gYnVpbGQgcmVjb3JkIGZyYWdtZW50XG4gIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgcnZhbC5wdXRCeXRlKHRscy5IYW5kc2hha2VUeXBlLmNlcnRpZmljYXRlX3JlcXVlc3QpO1xuICBydmFsLnB1dEludDI0KGxlbmd0aCk7XG4gIHdyaXRlVmVjdG9yKHJ2YWwsIDEsIGNlcnRUeXBlcyk7XG4gIHdyaXRlVmVjdG9yKHJ2YWwsIDIsIGNBcyk7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgU2VydmVySGVsbG9Eb25lIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGMgdGhlIGNvbm5lY3Rpb24uXG4gKlxuICogQHJldHVybiB0aGUgU2VydmVySGVsbG9Eb25lIGJ5dGUgYnVmZmVyLlxuICovXG50bHMuY3JlYXRlU2VydmVySGVsbG9Eb25lID0gZnVuY3Rpb24oYykge1xuICAvLyBidWlsZCByZWNvcmQgZnJhZ21lbnRcbiAgdmFyIHJ2YWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICBydmFsLnB1dEJ5dGUodGxzLkhhbmRzaGFrZVR5cGUuc2VydmVyX2hlbGxvX2RvbmUpO1xuICBydmFsLnB1dEludDI0KDApO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIENoYW5nZUNpcGhlclNwZWMgbWVzc2FnZS5cbiAqXG4gKiBUaGUgY2hhbmdlIGNpcGhlciBzcGVjIHByb3RvY29sIGV4aXN0cyB0byBzaWduYWwgdHJhbnNpdGlvbnMgaW5cbiAqIGNpcGhlcmluZyBzdHJhdGVnaWVzLiBUaGUgcHJvdG9jb2wgY29uc2lzdHMgb2YgYSBzaW5nbGUgbWVzc2FnZSxcbiAqIHdoaWNoIGlzIGVuY3J5cHRlZCBhbmQgY29tcHJlc3NlZCB1bmRlciB0aGUgY3VycmVudCAobm90IHRoZSBwZW5kaW5nKVxuICogY29ubmVjdGlvbiBzdGF0ZS4gVGhlIG1lc3NhZ2UgY29uc2lzdHMgb2YgYSBzaW5nbGUgYnl0ZSBvZiB2YWx1ZSAxLlxuICpcbiAqIHN0cnVjdCB7XG4gKiAgIGVudW0geyBjaGFuZ2VfY2lwaGVyX3NwZWMoMSksICgyNTUpIH0gdHlwZTtcbiAqIH0gQ2hhbmdlQ2lwaGVyU3BlYztcbiAqXG4gKiBAcmV0dXJuIHRoZSBDaGFuZ2VDaXBoZXJTcGVjIGJ5dGUgYnVmZmVyLlxuICovXG50bHMuY3JlYXRlQ2hhbmdlQ2lwaGVyU3BlYyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIHJ2YWwucHV0Qnl0ZSgweDAxKTtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBGaW5pc2hlZCBtZXNzYWdlLlxuICpcbiAqIHN0cnVjdCB7XG4gKiAgIG9wYXF1ZSB2ZXJpZnlfZGF0YVsxMl07XG4gKiB9IEZpbmlzaGVkO1xuICpcbiAqIHZlcmlmeV9kYXRhXG4gKiAgIFBSRihtYXN0ZXJfc2VjcmV0LCBmaW5pc2hlZF9sYWJlbCwgTUQ1KGhhbmRzaGFrZV9tZXNzYWdlcykgK1xuICogICBTSEEtMShoYW5kc2hha2VfbWVzc2FnZXMpKSBbMC4uMTFdO1xuICpcbiAqIGZpbmlzaGVkX2xhYmVsXG4gKiAgIEZvciBGaW5pc2hlZCBtZXNzYWdlcyBzZW50IGJ5IHRoZSBjbGllbnQsIHRoZSBzdHJpbmcgXCJjbGllbnRcbiAqICAgZmluaXNoZWRcIi4gRm9yIEZpbmlzaGVkIG1lc3NhZ2VzIHNlbnQgYnkgdGhlIHNlcnZlciwgdGhlXG4gKiAgIHN0cmluZyBcInNlcnZlciBmaW5pc2hlZFwiLlxuICpcbiAqIGhhbmRzaGFrZV9tZXNzYWdlc1xuICogICBBbGwgb2YgdGhlIGRhdGEgZnJvbSBhbGwgaGFuZHNoYWtlIG1lc3NhZ2VzIHVwIHRvIGJ1dCBub3RcbiAqICAgaW5jbHVkaW5nIHRoaXMgbWVzc2FnZS4gVGhpcyBpcyBvbmx5IGRhdGEgdmlzaWJsZSBhdCB0aGVcbiAqICAgaGFuZHNoYWtlIGxheWVyIGFuZCBkb2VzIG5vdCBpbmNsdWRlIHJlY29yZCBsYXllciBoZWFkZXJzLlxuICogICBUaGlzIGlzIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0aGUgSGFuZHNoYWtlIHN0cnVjdHVyZXMgYXNcbiAqICAgZGVmaW5lZCBpbiA3LjQgZXhjaGFuZ2VkIHRodXMgZmFyLlxuICpcbiAqIEBwYXJhbSBjIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEByZXR1cm4gdGhlIEZpbmlzaGVkIGJ5dGUgYnVmZmVyLlxuICovXG50bHMuY3JlYXRlRmluaXNoZWQgPSBmdW5jdGlvbihjKSB7XG4gIC8vIGdlbmVyYXRlIHZlcmlmeV9kYXRhXG4gIHZhciBiID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgYi5wdXRCdWZmZXIoYy5zZXNzaW9uLm1kNS5kaWdlc3QoKSk7XG4gIGIucHV0QnVmZmVyKGMuc2Vzc2lvbi5zaGExLmRpZ2VzdCgpKTtcblxuICAvLyBUT0RPOiBkZXRlcm1pbmUgcHJmIGZ1bmN0aW9uIGFuZCB2ZXJpZnkgbGVuZ3RoIGZvciBUTFMgMS4yXG4gIHZhciBjbGllbnQgPSAoYy5lbnRpdHkgPT09IHRscy5Db25uZWN0aW9uRW5kLmNsaWVudCk7XG4gIHZhciBzcCA9IGMuc2Vzc2lvbi5zcDtcbiAgdmFyIHZkbCA9IDEyO1xuICB2YXIgcHJmID0gcHJmX1RMUzE7XG4gIHZhciBsYWJlbCA9IGNsaWVudCA/ICdjbGllbnQgZmluaXNoZWQnIDogJ3NlcnZlciBmaW5pc2hlZCc7XG4gIGIgPSBwcmYoc3AubWFzdGVyX3NlY3JldCwgbGFiZWwsIGIuZ2V0Qnl0ZXMoKSwgdmRsKTtcblxuICAvLyBidWlsZCByZWNvcmQgZnJhZ21lbnRcbiAgdmFyIHJ2YWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICBydmFsLnB1dEJ5dGUodGxzLkhhbmRzaGFrZVR5cGUuZmluaXNoZWQpO1xuICBydmFsLnB1dEludDI0KGIubGVuZ3RoKCkpO1xuICBydmFsLnB1dEJ1ZmZlcihiKTtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBIZWFydGJlYXRNZXNzYWdlIChTZWUgUkZDIDY1MjApLlxuICpcbiAqIHN0cnVjdCB7XG4gKiAgIEhlYXJ0YmVhdE1lc3NhZ2VUeXBlIHR5cGU7XG4gKiAgIHVpbnQxNiBwYXlsb2FkX2xlbmd0aDtcbiAqICAgb3BhcXVlIHBheWxvYWRbSGVhcnRiZWF0TWVzc2FnZS5wYXlsb2FkX2xlbmd0aF07XG4gKiAgIG9wYXF1ZSBwYWRkaW5nW3BhZGRpbmdfbGVuZ3RoXTtcbiAqIH0gSGVhcnRiZWF0TWVzc2FnZTtcbiAqXG4gKiBUaGUgdG90YWwgbGVuZ3RoIG9mIGEgSGVhcnRiZWF0TWVzc2FnZSBNVVNUIE5PVCBleGNlZWQgMl4xNCBvclxuICogbWF4X2ZyYWdtZW50X2xlbmd0aCB3aGVuIG5lZ290aWF0ZWQgYXMgZGVmaW5lZCBpbiBbUkZDNjA2Nl0uXG4gKlxuICogdHlwZTogVGhlIG1lc3NhZ2UgdHlwZSwgZWl0aGVyIGhlYXJ0YmVhdF9yZXF1ZXN0IG9yIGhlYXJ0YmVhdF9yZXNwb25zZS5cbiAqXG4gKiBwYXlsb2FkX2xlbmd0aDogVGhlIGxlbmd0aCBvZiB0aGUgcGF5bG9hZC5cbiAqXG4gKiBwYXlsb2FkOiBUaGUgcGF5bG9hZCBjb25zaXN0cyBvZiBhcmJpdHJhcnkgY29udGVudC5cbiAqXG4gKiBwYWRkaW5nOiBUaGUgcGFkZGluZyBpcyByYW5kb20gY29udGVudCB0aGF0IE1VU1QgYmUgaWdub3JlZCBieSB0aGVcbiAqICAgcmVjZWl2ZXIuIFRoZSBsZW5ndGggb2YgYSBIZWFydGJlYXRNZXNzYWdlIGlzIFRMU1BsYWludGV4dC5sZW5ndGhcbiAqICAgZm9yIFRMUyBhbmQgRFRMU1BsYWludGV4dC5sZW5ndGggZm9yIERUTFMuIEZ1cnRoZXJtb3JlLCB0aGVcbiAqICAgbGVuZ3RoIG9mIHRoZSB0eXBlIGZpZWxkIGlzIDEgYnl0ZSwgYW5kIHRoZSBsZW5ndGggb2YgdGhlXG4gKiAgIHBheWxvYWRfbGVuZ3RoIGlzIDIuIFRoZXJlZm9yZSwgdGhlIHBhZGRpbmdfbGVuZ3RoIGlzXG4gKiAgIFRMU1BsYWludGV4dC5sZW5ndGggLSBwYXlsb2FkX2xlbmd0aCAtIDMgZm9yIFRMUyBhbmRcbiAqICAgRFRMU1BsYWludGV4dC5sZW5ndGggLSBwYXlsb2FkX2xlbmd0aCAtIDMgZm9yIERUTFMuIFRoZVxuICogICBwYWRkaW5nX2xlbmd0aCBNVVNUIGJlIGF0IGxlYXN0IDE2LlxuICpcbiAqIFRoZSBzZW5kZXIgb2YgYSBIZWFydGJlYXRNZXNzYWdlIE1VU1QgdXNlIGEgcmFuZG9tIHBhZGRpbmcgb2YgYXRcbiAqIGxlYXN0IDE2IGJ5dGVzLiBUaGUgcGFkZGluZyBvZiBhIHJlY2VpdmVkIEhlYXJ0YmVhdE1lc3NhZ2UgbWVzc2FnZVxuICogTVVTVCBiZSBpZ25vcmVkLlxuICpcbiAqIElmIHRoZSBwYXlsb2FkX2xlbmd0aCBvZiBhIHJlY2VpdmVkIEhlYXJ0YmVhdE1lc3NhZ2UgaXMgdG9vIGxhcmdlLFxuICogdGhlIHJlY2VpdmVkIEhlYXJ0YmVhdE1lc3NhZ2UgTVVTVCBiZSBkaXNjYXJkZWQgc2lsZW50bHkuXG4gKlxuICogQHBhcmFtIGMgdGhlIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0gdHlwZSB0aGUgdGxzLkhlYXJ0YmVhdE1lc3NhZ2VUeXBlLlxuICogQHBhcmFtIHBheWxvYWQgdGhlIGhlYXJ0YmVhdCBkYXRhIHRvIHNlbmQgYXMgdGhlIHBheWxvYWQuXG4gKiBAcGFyYW0gW3BheWxvYWRMZW5ndGhdIHRoZSBwYXlsb2FkIGxlbmd0aCB0byB1c2UsIGRlZmF1bHRzIHRvIHRoZVxuICogICAgICAgICAgYWN0dWFsIHBheWxvYWQgbGVuZ3RoLlxuICpcbiAqIEByZXR1cm4gdGhlIEhlYXJ0YmVhdFJlcXVlc3QgYnl0ZSBidWZmZXIuXG4gKi9cbnRscy5jcmVhdGVIZWFydGJlYXQgPSBmdW5jdGlvbih0eXBlLCBwYXlsb2FkLCBwYXlsb2FkTGVuZ3RoKSB7XG4gIGlmKHR5cGVvZiBwYXlsb2FkTGVuZ3RoID09PSAndW5kZWZpbmVkJykge1xuICAgIHBheWxvYWRMZW5ndGggPSBwYXlsb2FkLmxlbmd0aDtcbiAgfVxuICAvLyBidWlsZCByZWNvcmQgZnJhZ21lbnRcbiAgdmFyIHJ2YWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICBydmFsLnB1dEJ5dGUodHlwZSk7ICAgICAgICAgICAgICAgLy8gaGVhcnRiZWF0IG1lc3NhZ2UgdHlwZVxuICBydmFsLnB1dEludDE2KHBheWxvYWRMZW5ndGgpOyAgICAgLy8gcGF5bG9hZCBsZW5ndGhcbiAgcnZhbC5wdXRCeXRlcyhwYXlsb2FkKTsgICAgICAgICAgIC8vIHBheWxvYWRcbiAgLy8gcGFkZGluZ1xuICB2YXIgcGxhaW50ZXh0TGVuZ3RoID0gcnZhbC5sZW5ndGgoKTtcbiAgdmFyIHBhZGRpbmdMZW5ndGggPSBNYXRoLm1heCgxNiwgcGxhaW50ZXh0TGVuZ3RoIC0gcGF5bG9hZExlbmd0aCAtIDMpO1xuICBydmFsLnB1dEJ5dGVzKGZvcmdlLnJhbmRvbS5nZXRCeXRlcyhwYWRkaW5nTGVuZ3RoKSk7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBGcmFnbWVudHMsIGNvbXByZXNzZXMsIGVuY3J5cHRzLCBhbmQgcXVldWVzIGEgcmVjb3JkIGZvciBkZWxpdmVyeS5cbiAqXG4gKiBAcGFyYW0gYyB0aGUgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSByZWNvcmQgdGhlIHJlY29yZCB0byBxdWV1ZS5cbiAqL1xudGxzLnF1ZXVlID0gZnVuY3Rpb24oYywgcmVjb3JkKSB7XG4gIC8vIGVycm9yIGR1cmluZyByZWNvcmQgY3JlYXRpb25cbiAgaWYoIXJlY29yZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmKHJlY29yZC5mcmFnbWVudC5sZW5ndGgoKSA9PT0gMCkge1xuICAgIGlmKHJlY29yZC50eXBlID09PSB0bHMuQ29udGVudFR5cGUuaGFuZHNoYWtlIHx8XG4gICAgICByZWNvcmQudHlwZSA9PT0gdGxzLkNvbnRlbnRUeXBlLmFsZXJ0IHx8XG4gICAgICByZWNvcmQudHlwZSA9PT0gdGxzLkNvbnRlbnRUeXBlLmNoYW5nZV9jaXBoZXJfc3BlYykge1xuICAgICAgLy8gRW1wdHkgaGFuZHNoYWtlLCBhbGVydCBvZiBjaGFuZ2UgY2lwaGVyIHNwZWMgbWVzc2FnZXMgYXJlIG5vdCBhbGxvd2VkIHBlciB0aGUgVExTIHNwZWNpZmljYXRpb24gYW5kIHNob3VsZCBub3QgYmUgc2VudC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcmVjb3JkIGlzIGEgaGFuZHNoYWtlIHJlY29yZCwgdXBkYXRlIGhhbmRzaGFrZSBoYXNoZXNcbiAgaWYocmVjb3JkLnR5cGUgPT09IHRscy5Db250ZW50VHlwZS5oYW5kc2hha2UpIHtcbiAgICB2YXIgYnl0ZXMgPSByZWNvcmQuZnJhZ21lbnQuYnl0ZXMoKTtcbiAgICBjLnNlc3Npb24ubWQ1LnVwZGF0ZShieXRlcyk7XG4gICAgYy5zZXNzaW9uLnNoYTEudXBkYXRlKGJ5dGVzKTtcbiAgICBieXRlcyA9IG51bGw7XG4gIH1cblxuICAvLyBoYW5kbGUgcmVjb3JkIGZyYWdtZW50YXRpb25cbiAgdmFyIHJlY29yZHM7XG4gIGlmKHJlY29yZC5mcmFnbWVudC5sZW5ndGgoKSA8PSB0bHMuTWF4RnJhZ21lbnQpIHtcbiAgICByZWNvcmRzID0gW3JlY29yZF07XG4gIH0gZWxzZSB7XG4gICAgLy8gZnJhZ21lbnQgZGF0YSBhcyBsb25nIGFzIGl0IGlzIHRvbyBsb25nXG4gICAgcmVjb3JkcyA9IFtdO1xuICAgIHZhciBkYXRhID0gcmVjb3JkLmZyYWdtZW50LmJ5dGVzKCk7XG4gICAgd2hpbGUoZGF0YS5sZW5ndGggPiB0bHMuTWF4RnJhZ21lbnQpIHtcbiAgICAgIHJlY29yZHMucHVzaCh0bHMuY3JlYXRlUmVjb3JkKGMsIHtcbiAgICAgICAgdHlwZTogcmVjb3JkLnR5cGUsXG4gICAgICAgIGRhdGE6IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGRhdGEuc2xpY2UoMCwgdGxzLk1heEZyYWdtZW50KSlcbiAgICAgIH0pKTtcbiAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKHRscy5NYXhGcmFnbWVudCk7XG4gICAgfVxuICAgIC8vIGFkZCBsYXN0IHJlY29yZFxuICAgIGlmKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgcmVjb3Jkcy5wdXNoKHRscy5jcmVhdGVSZWNvcmQoYywge1xuICAgICAgICB0eXBlOiByZWNvcmQudHlwZSxcbiAgICAgICAgZGF0YTogZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoZGF0YSlcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cblxuICAvLyBjb21wcmVzcyBhbmQgZW5jcnlwdCBhbGwgZnJhZ21lbnRlZCByZWNvcmRzXG4gIGZvcih2YXIgaSA9IDA7IGkgPCByZWNvcmRzLmxlbmd0aCAmJiAhYy5mYWlsOyArK2kpIHtcbiAgICAvLyB1cGRhdGUgdGhlIHJlY29yZCB1c2luZyBjdXJyZW50IHdyaXRlIHN0YXRlXG4gICAgdmFyIHJlYyA9IHJlY29yZHNbaV07XG4gICAgdmFyIHMgPSBjLnN0YXRlLmN1cnJlbnQud3JpdGU7XG4gICAgaWYocy51cGRhdGUoYywgcmVjKSkge1xuICAgICAgLy8gc3RvcmUgcmVjb3JkXG4gICAgICBjLnJlY29yZHMucHVzaChyZWMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBGbHVzaGVzIGFsbCBxdWV1ZWQgcmVjb3JkcyB0byB0aGUgb3V0cHV0IGJ1ZmZlciBhbmQgY2FsbHMgdGhlXG4gKiB0bHNEYXRhUmVhZHkoKSBoYW5kbGVyIG9uIHRoZSBnaXZlbiBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSBjIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvbiBmYWlsdXJlLlxuICovXG50bHMuZmx1c2ggPSBmdW5jdGlvbihjKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBjLnJlY29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcmVjb3JkID0gYy5yZWNvcmRzW2ldO1xuXG4gICAgLy8gYWRkIHJlY29yZCBoZWFkZXIgYW5kIGZyYWdtZW50XG4gICAgYy50bHNEYXRhLnB1dEJ5dGUocmVjb3JkLnR5cGUpO1xuICAgIGMudGxzRGF0YS5wdXRCeXRlKHJlY29yZC52ZXJzaW9uLm1ham9yKTtcbiAgICBjLnRsc0RhdGEucHV0Qnl0ZShyZWNvcmQudmVyc2lvbi5taW5vcik7XG4gICAgYy50bHNEYXRhLnB1dEludDE2KHJlY29yZC5mcmFnbWVudC5sZW5ndGgoKSk7XG4gICAgYy50bHNEYXRhLnB1dEJ1ZmZlcihjLnJlY29yZHNbaV0uZnJhZ21lbnQpO1xuICB9XG4gIGMucmVjb3JkcyA9IFtdO1xuICByZXR1cm4gYy50bHNEYXRhUmVhZHkoYyk7XG59O1xuXG4vKipcbiAqIE1hcHMgYSBwa2kuY2VydGlmaWNhdGVFcnJvciB0byBhIHRscy5BbGVydC5EZXNjcmlwdGlvbi5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgdGhlIGVycm9yIHRvIG1hcC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhbGVydCBkZXNjcmlwdGlvbi5cbiAqL1xudmFyIF9jZXJ0RXJyb3JUb0FsZXJ0RGVzYyA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gIHN3aXRjaChlcnJvcikge1xuICBjYXNlIHRydWU6XG4gICAgcmV0dXJuIHRydWU7XG4gIGNhc2UgZm9yZ2UucGtpLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlOlxuICAgIHJldHVybiB0bHMuQWxlcnQuRGVzY3JpcHRpb24uYmFkX2NlcnRpZmljYXRlO1xuICBjYXNlIGZvcmdlLnBraS5jZXJ0aWZpY2F0ZUVycm9yLnVuc3VwcG9ydGVkX2NlcnRpZmljYXRlOlxuICAgIHJldHVybiB0bHMuQWxlcnQuRGVzY3JpcHRpb24udW5zdXBwb3J0ZWRfY2VydGlmaWNhdGU7XG4gIGNhc2UgZm9yZ2UucGtpLmNlcnRpZmljYXRlRXJyb3IuY2VydGlmaWNhdGVfcmV2b2tlZDpcbiAgICByZXR1cm4gdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmNlcnRpZmljYXRlX3Jldm9rZWQ7XG4gIGNhc2UgZm9yZ2UucGtpLmNlcnRpZmljYXRlRXJyb3IuY2VydGlmaWNhdGVfZXhwaXJlZDpcbiAgICByZXR1cm4gdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmNlcnRpZmljYXRlX2V4cGlyZWQ7XG4gIGNhc2UgZm9yZ2UucGtpLmNlcnRpZmljYXRlRXJyb3IuY2VydGlmaWNhdGVfdW5rbm93bjpcbiAgICByZXR1cm4gdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmNlcnRpZmljYXRlX3Vua25vd247XG4gIGNhc2UgZm9yZ2UucGtpLmNlcnRpZmljYXRlRXJyb3IudW5rbm93bl9jYTpcbiAgICByZXR1cm4gdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLnVua25vd25fY2E7XG4gIGRlZmF1bHQ6XG4gICAgcmV0dXJuIHRscy5BbGVydC5EZXNjcmlwdGlvbi5iYWRfY2VydGlmaWNhdGU7XG4gIH1cbn07XG5cbi8qKlxuICogTWFwcyBhIHRscy5BbGVydC5EZXNjcmlwdGlvbiB0byBhIHBraS5jZXJ0aWZpY2F0ZUVycm9yLlxuICpcbiAqIEBwYXJhbSBkZXNjIHRoZSBhbGVydCBkZXNjcmlwdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjZXJ0aWZpY2F0ZSBlcnJvci5cbiAqL1xudmFyIF9hbGVydERlc2NUb0NlcnRFcnJvciA9IGZ1bmN0aW9uKGRlc2MpIHtcbiAgc3dpdGNoKGRlc2MpIHtcbiAgY2FzZSB0cnVlOlxuICAgIHJldHVybiB0cnVlO1xuICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi5iYWRfY2VydGlmaWNhdGU6XG4gICAgcmV0dXJuIGZvcmdlLnBraS5jZXJ0aWZpY2F0ZUVycm9yLmJhZF9jZXJ0aWZpY2F0ZTtcbiAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24udW5zdXBwb3J0ZWRfY2VydGlmaWNhdGU6XG4gICAgcmV0dXJuIGZvcmdlLnBraS5jZXJ0aWZpY2F0ZUVycm9yLnVuc3VwcG9ydGVkX2NlcnRpZmljYXRlO1xuICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi5jZXJ0aWZpY2F0ZV9yZXZva2VkOlxuICAgIHJldHVybiBmb3JnZS5wa2kuY2VydGlmaWNhdGVFcnJvci5jZXJ0aWZpY2F0ZV9yZXZva2VkO1xuICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi5jZXJ0aWZpY2F0ZV9leHBpcmVkOlxuICAgIHJldHVybiBmb3JnZS5wa2kuY2VydGlmaWNhdGVFcnJvci5jZXJ0aWZpY2F0ZV9leHBpcmVkO1xuICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi5jZXJ0aWZpY2F0ZV91bmtub3duOlxuICAgIHJldHVybiBmb3JnZS5wa2kuY2VydGlmaWNhdGVFcnJvci5jZXJ0aWZpY2F0ZV91bmtub3duO1xuICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi51bmtub3duX2NhOlxuICAgIHJldHVybiBmb3JnZS5wa2kuY2VydGlmaWNhdGVFcnJvci51bmtub3duX2NhO1xuICBkZWZhdWx0OlxuICAgIHJldHVybiBmb3JnZS5wa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGU7XG4gIH1cbn07XG5cbi8qKlxuICogVmVyaWZpZXMgYSBjZXJ0aWZpY2F0ZSBjaGFpbiBhZ2FpbnN0IHRoZSBnaXZlbiBjb25uZWN0aW9uJ3NcbiAqIENlcnRpZmljYXRlIEF1dGhvcml0eSBzdG9yZS5cbiAqXG4gKiBAcGFyYW0gYyB0aGUgVExTIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0gY2hhaW4gdGhlIGNlcnRpZmljYXRlIGNoYWluIHRvIHZlcmlmeSwgd2l0aCB0aGUgcm9vdCBvciBoaWdoZXN0XG4gKiAgICAgICAgICBhdXRob3JpdHkgYXQgdGhlIGVuZC5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgc3VjY2Vzc2Z1bCwgZmFsc2UgaWYgbm90LlxuICovXG50bHMudmVyaWZ5Q2VydGlmaWNhdGVDaGFpbiA9IGZ1bmN0aW9uKGMsIGNoYWluKSB7XG4gIHRyeSB7XG4gICAgLy8gTWFrZSBhIGNvcHkgb2YgYy52ZXJpZnlPcHRpb25zIHNvIHRoYXQgd2UgY2FuIG1vZGlmeSBvcHRpb25zLnZlcmlmeVxuICAgIC8vIHdpdGhvdXQgbW9kaWZ5aW5nIGMudmVyaWZ5T3B0aW9ucy5cbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBjLnZlcmlmeU9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnNba2V5XSA9IGMudmVyaWZ5T3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIG9wdGlvbnMudmVyaWZ5ID0gZnVuY3Rpb24odmZkLCBkZXB0aCwgY2hhaW4pIHtcbiAgICAgIC8vIGNvbnZlcnQgcGtpLmNlcnRpZmljYXRlRXJyb3IgdG8gdGxzIGFsZXJ0IGRlc2NyaXB0aW9uXG4gICAgICB2YXIgZGVzYyA9IF9jZXJ0RXJyb3JUb0FsZXJ0RGVzYyh2ZmQpO1xuXG4gICAgICAvLyBjYWxsIGFwcGxpY2F0aW9uIGNhbGxiYWNrXG4gICAgICB2YXIgcmV0ID0gYy52ZXJpZnkoYywgdmZkLCBkZXB0aCwgY2hhaW4pO1xuICAgICAgaWYocmV0ICE9PSB0cnVlKSB7XG4gICAgICAgIGlmKHR5cGVvZiByZXQgPT09ICdvYmplY3QnICYmICFmb3JnZS51dGlsLmlzQXJyYXkocmV0KSkge1xuICAgICAgICAgIC8vIHRocm93IGN1c3RvbSBlcnJvclxuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVGhlIGFwcGxpY2F0aW9uIHJlamVjdGVkIHRoZSBjZXJ0aWZpY2F0ZS4nKTtcbiAgICAgICAgICBlcnJvci5zZW5kID0gdHJ1ZTtcbiAgICAgICAgICBlcnJvci5hbGVydCA9IHtcbiAgICAgICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwuZmF0YWwsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmJhZF9jZXJ0aWZpY2F0ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYocmV0Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSByZXQubWVzc2FnZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmV0LmFsZXJ0KSB7XG4gICAgICAgICAgICBlcnJvci5hbGVydC5kZXNjcmlwdGlvbiA9IHJldC5hbGVydDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb252ZXJ0IHRscyBhbGVydCBkZXNjcmlwdGlvbiB0byBwa2kuY2VydGlmaWNhdGVFcnJvclxuICAgICAgICBpZihyZXQgIT09IHZmZCkge1xuICAgICAgICAgIHJldCA9IF9hbGVydERlc2NUb0NlcnRFcnJvcihyZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIC8vIHZlcmlmeSBjaGFpblxuICAgIGZvcmdlLnBraS52ZXJpZnlDZXJ0aWZpY2F0ZUNoYWluKGMuY2FTdG9yZSwgY2hhaW4sIG9wdGlvbnMpO1xuICB9IGNhdGNoKGV4KSB7XG4gICAgLy8gYnVpbGQgdGxzIGVycm9yIGlmIG5vdCBhbHJlYWR5IGN1c3RvbWl6ZWRcbiAgICB2YXIgZXJyID0gZXg7XG4gICAgaWYodHlwZW9mIGVyciAhPT0gJ29iamVjdCcgfHwgZm9yZ2UudXRpbC5pc0FycmF5KGVycikpIHtcbiAgICAgIGVyciA9IHtcbiAgICAgICAgc2VuZDogdHJ1ZSxcbiAgICAgICAgYWxlcnQ6IHtcbiAgICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBfY2VydEVycm9yVG9BbGVydERlc2MoZXgpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmKCEoJ3NlbmQnIGluIGVycikpIHtcbiAgICAgIGVyci5zZW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYoISgnYWxlcnQnIGluIGVycikpIHtcbiAgICAgIGVyci5hbGVydCA9IHtcbiAgICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC5mYXRhbCxcbiAgICAgICAgZGVzY3JpcHRpb246IF9jZXJ0RXJyb3JUb0FsZXJ0RGVzYyhlcnIuZXJyb3IpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHNlbmQgZXJyb3JcbiAgICBjLmVycm9yKGMsIGVycik7XG4gIH1cblxuICByZXR1cm4gIWMuZmFpbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBUTFMgc2Vzc2lvbiBjYWNoZS5cbiAqXG4gKiBAcGFyYW0gY2FjaGUgb3B0aW9uYWwgbWFwIG9mIHNlc3Npb24gSUQgdG8gY2FjaGVkIHNlc3Npb24uXG4gKiBAcGFyYW0gY2FwYWNpdHkgdGhlIG1heGltdW0gc2l6ZSBmb3IgdGhlIGNhY2hlIChkZWZhdWx0OiAxMDApLlxuICpcbiAqIEByZXR1cm4gdGhlIG5ldyBUTFMgc2Vzc2lvbiBjYWNoZS5cbiAqL1xudGxzLmNyZWF0ZVNlc3Npb25DYWNoZSA9IGZ1bmN0aW9uKGNhY2hlLCBjYXBhY2l0eSkge1xuICB2YXIgcnZhbCA9IG51bGw7XG5cbiAgLy8gYXNzdW1lIGlucHV0IGlzIGFscmVhZHkgYSBzZXNzaW9uIGNhY2hlIG9iamVjdFxuICBpZihjYWNoZSAmJiBjYWNoZS5nZXRTZXNzaW9uICYmIGNhY2hlLnNldFNlc3Npb24gJiYgY2FjaGUub3JkZXIpIHtcbiAgICBydmFsID0gY2FjaGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gY3JlYXRlIGNhY2hlXG4gICAgcnZhbCA9IHt9O1xuICAgIHJ2YWwuY2FjaGUgPSBjYWNoZSB8fCB7fTtcbiAgICBydmFsLmNhcGFjaXR5ID0gTWF0aC5tYXgoY2FwYWNpdHkgfHwgMTAwLCAxKTtcbiAgICBydmFsLm9yZGVyID0gW107XG5cbiAgICAvLyBzdG9yZSBvcmRlciBmb3Igc2Vzc2lvbnMsIGRlbGV0ZSBzZXNzaW9uIG92ZXJmbG93XG4gICAgZm9yKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICAgIGlmKHJ2YWwub3JkZXIubGVuZ3RoIDw9IGNhcGFjaXR5KSB7XG4gICAgICAgIHJ2YWwub3JkZXIucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGNhY2hlW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZ2V0IGEgc2Vzc2lvbiBmcm9tIGEgc2Vzc2lvbiBJRCAob3IgZ2V0IGFueSBzZXNzaW9uKVxuICAgIHJ2YWwuZ2V0U2Vzc2lvbiA9IGZ1bmN0aW9uKHNlc3Npb25JZCkge1xuICAgICAgdmFyIHNlc3Npb24gPSBudWxsO1xuICAgICAgdmFyIGtleSA9IG51bGw7XG5cbiAgICAgIC8vIGlmIHNlc3Npb24gSUQgcHJvdmlkZWQsIHVzZSBpdFxuICAgICAgaWYoc2Vzc2lvbklkKSB7XG4gICAgICAgIGtleSA9IGZvcmdlLnV0aWwuYnl0ZXNUb0hleChzZXNzaW9uSWQpO1xuICAgICAgfSBlbHNlIGlmKHJ2YWwub3JkZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBnZXQgZmlyc3Qgc2Vzc2lvbiBmcm9tIGNhY2hlXG4gICAgICAgIGtleSA9IHJ2YWwub3JkZXJbMF07XG4gICAgICB9XG5cbiAgICAgIGlmKGtleSAhPT0gbnVsbCAmJiBrZXkgaW4gcnZhbC5jYWNoZSkge1xuICAgICAgICAvLyBnZXQgY2FjaGVkIHNlc3Npb24gYW5kIHJlbW92ZSBmcm9tIGNhY2hlXG4gICAgICAgIHNlc3Npb24gPSBydmFsLmNhY2hlW2tleV07XG4gICAgICAgIGRlbGV0ZSBydmFsLmNhY2hlW2tleV07XG4gICAgICAgIGZvcih2YXIgaSBpbiBydmFsLm9yZGVyKSB7XG4gICAgICAgICAgaWYocnZhbC5vcmRlcltpXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICBydmFsLm9yZGVyLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2Vzc2lvbjtcbiAgICB9O1xuXG4gICAgLy8gc2V0IGEgc2Vzc2lvbiBpbiB0aGUgY2FjaGVcbiAgICBydmFsLnNldFNlc3Npb24gPSBmdW5jdGlvbihzZXNzaW9uSWQsIHNlc3Npb24pIHtcbiAgICAgIC8vIHJlbW92ZSBzZXNzaW9uIGZyb20gY2FjaGUgaWYgYXQgY2FwYWNpdHlcbiAgICAgIGlmKHJ2YWwub3JkZXIubGVuZ3RoID09PSBydmFsLmNhcGFjaXR5KSB7XG4gICAgICAgIHZhciBrZXkgPSBydmFsLm9yZGVyLnNoaWZ0KCk7XG4gICAgICAgIGRlbGV0ZSBydmFsLmNhY2hlW2tleV07XG4gICAgICB9XG4gICAgICAvLyBhZGQgc2Vzc2lvbiB0byBjYWNoZVxuICAgICAgdmFyIGtleSA9IGZvcmdlLnV0aWwuYnl0ZXNUb0hleChzZXNzaW9uSWQpO1xuICAgICAgcnZhbC5vcmRlci5wdXNoKGtleSk7XG4gICAgICBydmFsLmNhY2hlW2tleV0gPSBzZXNzaW9uO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBUTFMgY29ubmVjdGlvbi5cbiAqXG4gKiBTZWUgcHVibGljIGNyZWF0ZUNvbm5lY3Rpb24oKSBkb2NzIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgZm9yIHRoaXMgY29ubmVjdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBuZXcgVExTIGNvbm5lY3Rpb24uXG4gKi9cbnRscy5jcmVhdGVDb25uZWN0aW9uID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgY2FTdG9yZSA9IG51bGw7XG4gIGlmKG9wdGlvbnMuY2FTdG9yZSkge1xuICAgIC8vIGlmIENBIHN0b3JlIGlzIGFuIGFycmF5LCBjb252ZXJ0IGl0IHRvIGEgQ0Egc3RvcmUgb2JqZWN0XG4gICAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KG9wdGlvbnMuY2FTdG9yZSkpIHtcbiAgICAgIGNhU3RvcmUgPSBmb3JnZS5wa2kuY3JlYXRlQ2FTdG9yZShvcHRpb25zLmNhU3RvcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYVN0b3JlID0gb3B0aW9ucy5jYVN0b3JlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBjcmVhdGUgZW1wdHkgQ0Egc3RvcmVcbiAgICBjYVN0b3JlID0gZm9yZ2UucGtpLmNyZWF0ZUNhU3RvcmUoKTtcbiAgfVxuXG4gIC8vIHNldHVwIGRlZmF1bHQgY2lwaGVyIHN1aXRlc1xuICB2YXIgY2lwaGVyU3VpdGVzID0gb3B0aW9ucy5jaXBoZXJTdWl0ZXMgfHwgbnVsbDtcbiAgaWYoY2lwaGVyU3VpdGVzID09PSBudWxsKSB7XG4gICAgY2lwaGVyU3VpdGVzID0gW107XG4gICAgZm9yKHZhciBrZXkgaW4gdGxzLkNpcGhlclN1aXRlcykge1xuICAgICAgY2lwaGVyU3VpdGVzLnB1c2godGxzLkNpcGhlclN1aXRlc1trZXldKTtcbiAgICB9XG4gIH1cblxuICAvLyBzZXQgZGVmYXVsdCBlbnRpdHlcbiAgdmFyIGVudGl0eSA9IChvcHRpb25zLnNlcnZlciB8fCBmYWxzZSkgP1xuICAgIHRscy5Db25uZWN0aW9uRW5kLnNlcnZlciA6IHRscy5Db25uZWN0aW9uRW5kLmNsaWVudDtcblxuICAvLyBjcmVhdGUgc2Vzc2lvbiBjYWNoZSBpZiByZXF1ZXN0ZWRcbiAgdmFyIHNlc3Npb25DYWNoZSA9IG9wdGlvbnMuc2Vzc2lvbkNhY2hlID9cbiAgICB0bHMuY3JlYXRlU2Vzc2lvbkNhY2hlKG9wdGlvbnMuc2Vzc2lvbkNhY2hlKSA6IG51bGw7XG5cbiAgLy8gY3JlYXRlIFRMUyBjb25uZWN0aW9uXG4gIHZhciBjID0ge1xuICAgIHZlcnNpb246IHttYWpvcjogdGxzLlZlcnNpb24ubWFqb3IsIG1pbm9yOiB0bHMuVmVyc2lvbi5taW5vcn0sXG4gICAgZW50aXR5OiBlbnRpdHksXG4gICAgc2Vzc2lvbklkOiBvcHRpb25zLnNlc3Npb25JZCxcbiAgICBjYVN0b3JlOiBjYVN0b3JlLFxuICAgIHNlc3Npb25DYWNoZTogc2Vzc2lvbkNhY2hlLFxuICAgIGNpcGhlclN1aXRlczogY2lwaGVyU3VpdGVzLFxuICAgIGNvbm5lY3RlZDogb3B0aW9ucy5jb25uZWN0ZWQsXG4gICAgdmlydHVhbEhvc3Q6IG9wdGlvbnMudmlydHVhbEhvc3QgfHwgbnVsbCxcbiAgICB2ZXJpZnlDbGllbnQ6IG9wdGlvbnMudmVyaWZ5Q2xpZW50IHx8IGZhbHNlLFxuICAgIHZlcmlmeTogb3B0aW9ucy52ZXJpZnkgfHwgZnVuY3Rpb24oY24sIHZmZCwgZHB0aCwgY3RzKSB7cmV0dXJuIHZmZDt9LFxuICAgIHZlcmlmeU9wdGlvbnM6IG9wdGlvbnMudmVyaWZ5T3B0aW9ucyB8fCB7fSxcbiAgICBnZXRDZXJ0aWZpY2F0ZTogb3B0aW9ucy5nZXRDZXJ0aWZpY2F0ZSB8fCBudWxsLFxuICAgIGdldFByaXZhdGVLZXk6IG9wdGlvbnMuZ2V0UHJpdmF0ZUtleSB8fCBudWxsLFxuICAgIGdldFNpZ25hdHVyZTogb3B0aW9ucy5nZXRTaWduYXR1cmUgfHwgbnVsbCxcbiAgICBpbnB1dDogZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKSxcbiAgICB0bHNEYXRhOiBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpLFxuICAgIGRhdGE6IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCksXG4gICAgdGxzRGF0YVJlYWR5OiBvcHRpb25zLnRsc0RhdGFSZWFkeSxcbiAgICBkYXRhUmVhZHk6IG9wdGlvbnMuZGF0YVJlYWR5LFxuICAgIGhlYXJ0YmVhdFJlY2VpdmVkOiBvcHRpb25zLmhlYXJ0YmVhdFJlY2VpdmVkLFxuICAgIGNsb3NlZDogb3B0aW9ucy5jbG9zZWQsXG4gICAgZXJyb3I6IGZ1bmN0aW9uKGMsIGV4KSB7XG4gICAgICAvLyBzZXQgb3JpZ2luIGlmIG5vdCBzZXRcbiAgICAgIGV4Lm9yaWdpbiA9IGV4Lm9yaWdpbiB8fFxuICAgICAgICAoKGMuZW50aXR5ID09PSB0bHMuQ29ubmVjdGlvbkVuZC5jbGllbnQpID8gJ2NsaWVudCcgOiAnc2VydmVyJyk7XG5cbiAgICAgIC8vIHNlbmQgVExTIGFsZXJ0XG4gICAgICBpZihleC5zZW5kKSB7XG4gICAgICAgIHRscy5xdWV1ZShjLCB0bHMuY3JlYXRlQWxlcnQoYywgZXguYWxlcnQpKTtcbiAgICAgICAgdGxzLmZsdXNoKGMpO1xuICAgICAgfVxuXG4gICAgICAvLyBlcnJvciBpcyBmYXRhbCBieSBkZWZhdWx0XG4gICAgICB2YXIgZmF0YWwgPSAoZXguZmF0YWwgIT09IGZhbHNlKTtcbiAgICAgIGlmKGZhdGFsKSB7XG4gICAgICAgIC8vIHNldCBmYWlsIGZsYWdcbiAgICAgICAgYy5mYWlsID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gY2FsbCBlcnJvciBoYW5kbGVyIGZpcnN0XG4gICAgICBvcHRpb25zLmVycm9yKGMsIGV4KTtcblxuICAgICAgaWYoZmF0YWwpIHtcbiAgICAgICAgLy8gZmF0YWwgZXJyb3IsIGNsb3NlIGNvbm5lY3Rpb24sIGRvIG5vdCBjbGVhciBmYWlsXG4gICAgICAgIGMuY2xvc2UoZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVmbGF0ZTogb3B0aW9ucy5kZWZsYXRlIHx8IG51bGwsXG4gICAgaW5mbGF0ZTogb3B0aW9ucy5pbmZsYXRlIHx8IG51bGxcbiAgfTtcblxuICAvKipcbiAgICogUmVzZXRzIGEgY2xvc2VkIFRMUyBjb25uZWN0aW9uIGZvciByZXVzZS4gQ2FsbGVkIGluIGMuY2xvc2UoKS5cbiAgICpcbiAgICogQHBhcmFtIGNsZWFyRmFpbCB0cnVlIHRvIGNsZWFyIHRoZSBmYWlsIGZsYWcgKGRlZmF1bHQ6IHRydWUpLlxuICAgKi9cbiAgYy5yZXNldCA9IGZ1bmN0aW9uKGNsZWFyRmFpbCkge1xuICAgIGMudmVyc2lvbiA9IHttYWpvcjogdGxzLlZlcnNpb24ubWFqb3IsIG1pbm9yOiB0bHMuVmVyc2lvbi5taW5vcn07XG4gICAgYy5yZWNvcmQgPSBudWxsO1xuICAgIGMuc2Vzc2lvbiA9IG51bGw7XG4gICAgYy5wZWVyQ2VydGlmaWNhdGUgPSBudWxsO1xuICAgIGMuc3RhdGUgPSB7XG4gICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgY3VycmVudDogbnVsbFxuICAgIH07XG4gICAgYy5leHBlY3QgPSAoYy5lbnRpdHkgPT09IHRscy5Db25uZWN0aW9uRW5kLmNsaWVudCkgPyBTSEUgOiBDSEU7XG4gICAgYy5mcmFnbWVudGVkID0gbnVsbDtcbiAgICBjLnJlY29yZHMgPSBbXTtcbiAgICBjLm9wZW4gPSBmYWxzZTtcbiAgICBjLmhhbmRzaGFrZXMgPSAwO1xuICAgIGMuaGFuZHNoYWtpbmcgPSBmYWxzZTtcbiAgICBjLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgYy5mYWlsID0gIShjbGVhckZhaWwgfHwgdHlwZW9mKGNsZWFyRmFpbCkgPT09ICd1bmRlZmluZWQnKTtcbiAgICBjLmlucHV0LmNsZWFyKCk7XG4gICAgYy50bHNEYXRhLmNsZWFyKCk7XG4gICAgYy5kYXRhLmNsZWFyKCk7XG4gICAgYy5zdGF0ZS5jdXJyZW50ID0gdGxzLmNyZWF0ZUNvbm5lY3Rpb25TdGF0ZShjKTtcbiAgfTtcblxuICAvLyBkbyBpbml0aWFsIHJlc2V0IG9mIGNvbm5lY3Rpb25cbiAgYy5yZXNldCgpO1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjdXJyZW50IFRMUyBlbmdpbmUgc3RhdGUgYmFzZWQgb24gdGhlIGdpdmVuIHJlY29yZC5cbiAgICpcbiAgICogQHBhcmFtIGMgdGhlIFRMUyBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0gcmVjb3JkIHRoZSBUTFMgcmVjb3JkIHRvIGFjdCBvbi5cbiAgICovXG4gIHZhciBfdXBkYXRlID0gZnVuY3Rpb24oYywgcmVjb3JkKSB7XG4gICAgLy8gZ2V0IHJlY29yZCBoYW5kbGVyIChhbGlnbiB0eXBlIGluIHRhYmxlIGJ5IHN1YnRyYWN0aW5nIGxvd2VzdClcbiAgICB2YXIgYWxpZ25lZCA9IHJlY29yZC50eXBlIC0gdGxzLkNvbnRlbnRUeXBlLmNoYW5nZV9jaXBoZXJfc3BlYztcbiAgICB2YXIgaGFuZGxlcnMgPSBjdFRhYmxlW2MuZW50aXR5XVtjLmV4cGVjdF07XG4gICAgaWYoYWxpZ25lZCBpbiBoYW5kbGVycykge1xuICAgICAgaGFuZGxlcnNbYWxpZ25lZF0oYywgcmVjb3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5leHBlY3RlZCByZWNvcmRcbiAgICAgIHRscy5oYW5kbGVVbmV4cGVjdGVkKGMsIHJlY29yZCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgcmVjb3JkIGhlYWRlciBhbmQgaW5pdGlhbGl6ZXMgdGhlIG5leHQgcmVjb3JkIG9uIHRoZSBnaXZlblxuICAgKiBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gYyB0aGUgVExTIGNvbm5lY3Rpb24gd2l0aCB0aGUgbmV4dCByZWNvcmQuXG4gICAqXG4gICAqIEByZXR1cm4gMCBpZiB0aGUgaW5wdXQgZGF0YSBjb3VsZCBiZSBwcm9jZXNzZWQsIG90aGVyd2lzZSB0aGVcbiAgICogICAgICAgICBudW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQgZm9yIGRhdGEgdG8gYmUgcHJvY2Vzc2VkLlxuICAgKi9cbiAgdmFyIF9yZWFkUmVjb3JkSGVhZGVyID0gZnVuY3Rpb24oYykge1xuICAgIHZhciBydmFsID0gMDtcblxuICAgIC8vIGdldCBpbnB1dCBidWZmZXIgYW5kIGl0cyBsZW5ndGhcbiAgICB2YXIgYiA9IGMuaW5wdXQ7XG4gICAgdmFyIGxlbiA9IGIubGVuZ3RoKCk7XG5cbiAgICAvLyBuZWVkIGF0IGxlYXN0IDUgYnl0ZXMgdG8gaW5pdGlhbGl6ZSBhIHJlY29yZFxuICAgIGlmKGxlbiA8IDUpIHtcbiAgICAgIHJ2YWwgPSA1IC0gbGVuO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbm91Z2ggYnl0ZXMgZm9yIGhlYWRlclxuICAgICAgLy8gaW5pdGlhbGl6ZSByZWNvcmRcbiAgICAgIGMucmVjb3JkID0ge1xuICAgICAgICB0eXBlOiBiLmdldEJ5dGUoKSxcbiAgICAgICAgdmVyc2lvbjoge1xuICAgICAgICAgIG1ham9yOiBiLmdldEJ5dGUoKSxcbiAgICAgICAgICBtaW5vcjogYi5nZXRCeXRlKClcbiAgICAgICAgfSxcbiAgICAgICAgbGVuZ3RoOiBiLmdldEludDE2KCksXG4gICAgICAgIGZyYWdtZW50OiBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpLFxuICAgICAgICByZWFkeTogZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIC8vIGNoZWNrIHJlY29yZCB2ZXJzaW9uXG4gICAgICB2YXIgY29tcGF0aWJsZVZlcnNpb24gPSAoYy5yZWNvcmQudmVyc2lvbi5tYWpvciA9PT0gYy52ZXJzaW9uLm1ham9yKTtcbiAgICAgIGlmKGNvbXBhdGlibGVWZXJzaW9uICYmIGMuc2Vzc2lvbiAmJiBjLnNlc3Npb24udmVyc2lvbikge1xuICAgICAgICAvLyBzZXNzaW9uIHZlcnNpb24gYWxyZWFkeSBzZXQsIHJlcXVpcmUgc2FtZSBtaW5vciB2ZXJzaW9uXG4gICAgICAgIGNvbXBhdGlibGVWZXJzaW9uID0gKGMucmVjb3JkLnZlcnNpb24ubWlub3IgPT09IGMudmVyc2lvbi5taW5vcik7XG4gICAgICB9XG4gICAgICBpZighY29tcGF0aWJsZVZlcnNpb24pIHtcbiAgICAgICAgYy5lcnJvcihjLCB7XG4gICAgICAgICAgbWVzc2FnZTogJ0luY29tcGF0aWJsZSBUTFMgdmVyc2lvbi4nLFxuICAgICAgICAgIHNlbmQ6IHRydWUsXG4gICAgICAgICAgYWxlcnQ6IHtcbiAgICAgICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwuZmF0YWwsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLnByb3RvY29sX3ZlcnNpb25cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgbmV4dCByZWNvcmQncyBjb250ZW50cyBhbmQgYXBwZW5kcyBpdHMgbWVzc2FnZSB0byBhbnlcbiAgICogcHJldmlvdXNseSBmcmFnbWVudGVkIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBjIHRoZSBUTFMgY29ubmVjdGlvbiB3aXRoIHRoZSBuZXh0IHJlY29yZC5cbiAgICpcbiAgICogQHJldHVybiAwIGlmIHRoZSBpbnB1dCBkYXRhIGNvdWxkIGJlIHByb2Nlc3NlZCwgb3RoZXJ3aXNlIHRoZVxuICAgKiAgICAgICAgIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCBmb3IgZGF0YSB0byBiZSBwcm9jZXNzZWQuXG4gICAqL1xuICB2YXIgX3JlYWRSZWNvcmQgPSBmdW5jdGlvbihjKSB7XG4gICAgdmFyIHJ2YWwgPSAwO1xuXG4gICAgLy8gZW5zdXJlIHRoZXJlIGlzIGVub3VnaCBpbnB1dCBkYXRhIHRvIGdldCB0aGUgZW50aXJlIHJlY29yZFxuICAgIHZhciBiID0gYy5pbnB1dDtcbiAgICB2YXIgbGVuID0gYi5sZW5ndGgoKTtcbiAgICBpZihsZW4gPCBjLnJlY29yZC5sZW5ndGgpIHtcbiAgICAgIC8vIG5vdCBlbm91Z2ggZGF0YSB5ZXQsIHJldHVybiBob3cgbXVjaCBpcyByZXF1aXJlZFxuICAgICAgcnZhbCA9IGMucmVjb3JkLmxlbmd0aCAtIGxlbjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlcmUgaXMgZW5vdWdoIGRhdGEgdG8gcGFyc2UgdGhlIHBlbmRpbmcgcmVjb3JkXG4gICAgICAvLyBmaWxsIHJlY29yZCBmcmFnbWVudCBhbmQgY29tcGFjdCBpbnB1dCBidWZmZXJcbiAgICAgIGMucmVjb3JkLmZyYWdtZW50LnB1dEJ5dGVzKGIuZ2V0Qnl0ZXMoYy5yZWNvcmQubGVuZ3RoKSk7XG4gICAgICBiLmNvbXBhY3QoKTtcblxuICAgICAgLy8gdXBkYXRlIHJlY29yZCB1c2luZyBjdXJyZW50IHJlYWQgc3RhdGVcbiAgICAgIHZhciBzID0gYy5zdGF0ZS5jdXJyZW50LnJlYWQ7XG4gICAgICBpZihzLnVwZGF0ZShjLCBjLnJlY29yZCkpIHtcbiAgICAgICAgLy8gc2VlIGlmIHRoZXJlIGlzIGEgcHJldmlvdXNseSBmcmFnbWVudGVkIG1lc3NhZ2UgdGhhdCB0aGVcbiAgICAgICAgLy8gbmV3IHJlY29yZCdzIG1lc3NhZ2UgZnJhZ21lbnQgc2hvdWxkIGJlIGFwcGVuZGVkIHRvXG4gICAgICAgIGlmKGMuZnJhZ21lbnRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIGlmIHRoZSByZWNvcmQgdHlwZSBtYXRjaGVzIGEgcHJldmlvdXNseSBmcmFnbWVudGVkXG4gICAgICAgICAgLy8gcmVjb3JkLCBhcHBlbmQgdGhlIHJlY29yZCBmcmFnbWVudCB0byBpdFxuICAgICAgICAgIGlmKGMuZnJhZ21lbnRlZC50eXBlID09PSBjLnJlY29yZC50eXBlKSB7XG4gICAgICAgICAgICAvLyBjb25jYXRlbmF0ZSByZWNvcmQgZnJhZ21lbnRzXG4gICAgICAgICAgICBjLmZyYWdtZW50ZWQuZnJhZ21lbnQucHV0QnVmZmVyKGMucmVjb3JkLmZyYWdtZW50KTtcbiAgICAgICAgICAgIGMucmVjb3JkID0gYy5mcmFnbWVudGVkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBlcnJvciwgaW52YWxpZCBmcmFnbWVudGVkIHJlY29yZFxuICAgICAgICAgICAgYy5lcnJvcihjLCB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGZyYWdtZW50ZWQgcmVjb3JkLicsXG4gICAgICAgICAgICAgIHNlbmQ6IHRydWUsXG4gICAgICAgICAgICAgIGFsZXJ0OiB7XG4gICAgICAgICAgICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC5mYXRhbCxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgICAgICAgIHRscy5BbGVydC5EZXNjcmlwdGlvbi51bmV4cGVjdGVkX21lc3NhZ2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjb3JkIGlzIG5vdyByZWFkeVxuICAgICAgICBjLnJlY29yZC5yZWFkeSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgaGFuZHNoYWtlIHVzaW5nIHRoZSBUTFMgSGFuZHNoYWtlIFByb3RvY29sLCBhcyBhIGNsaWVudC5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGlmIHRoZSBjb25uZWN0aW9uIGlzIGluIGNsaWVudCBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uIElEIHRvIHVzZSwgbnVsbCB0byBzdGFydCBhIG5ldyBvbmUuXG4gICAqL1xuICBjLmhhbmRzaGFrZSA9IGZ1bmN0aW9uKHNlc3Npb25JZCkge1xuICAgIC8vIGVycm9yIHRvIGNhbGwgdGhpcyBpbiBub24tY2xpZW50IG1vZGVcbiAgICBpZihjLmVudGl0eSAhPT0gdGxzLkNvbm5lY3Rpb25FbmQuY2xpZW50KSB7XG4gICAgICAvLyBub3QgZmF0YWwgZXJyb3JcbiAgICAgIGMuZXJyb3IoYywge1xuICAgICAgICBtZXNzYWdlOiAnQ2Fubm90IGluaXRpYXRlIGhhbmRzaGFrZSBhcyBhIHNlcnZlci4nLFxuICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZihjLmhhbmRzaGFraW5nKSB7XG4gICAgICAvLyBoYW5kc2hha2UgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgZmFpbCBidXQgbm90IGZhdGFsIGVycm9yXG4gICAgICBjLmVycm9yKGMsIHtcbiAgICAgICAgbWVzc2FnZTogJ0hhbmRzaGFrZSBhbHJlYWR5IGluIHByb2dyZXNzLicsXG4gICAgICAgIGZhdGFsOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNsZWFyIGZhaWwgZmxhZyBvbiByZXVzZVxuICAgICAgaWYoYy5mYWlsICYmICFjLm9wZW4gJiYgYy5oYW5kc2hha2VzID09PSAwKSB7XG4gICAgICAgIGMuZmFpbCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBub3cgaGFuZHNoYWtpbmdcbiAgICAgIGMuaGFuZHNoYWtpbmcgPSB0cnVlO1xuXG4gICAgICAvLyBkZWZhdWx0IHRvIGJsYW5rIChuZXcgc2Vzc2lvbilcbiAgICAgIHNlc3Npb25JZCA9IHNlc3Npb25JZCB8fCAnJztcblxuICAgICAgLy8gaWYgYSBzZXNzaW9uIElEIHdhcyBzcGVjaWZpZWQsIHRyeSB0byBmaW5kIGl0IGluIHRoZSBjYWNoZVxuICAgICAgdmFyIHNlc3Npb24gPSBudWxsO1xuICAgICAgaWYoc2Vzc2lvbklkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYoYy5zZXNzaW9uQ2FjaGUpIHtcbiAgICAgICAgICBzZXNzaW9uID0gYy5zZXNzaW9uQ2FjaGUuZ2V0U2Vzc2lvbihzZXNzaW9uSWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWF0Y2hpbmcgc2Vzc2lvbiBub3QgZm91bmQgaW4gY2FjaGUsIGNsZWFyIHNlc3Npb24gSURcbiAgICAgICAgaWYoc2Vzc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICAgIHNlc3Npb25JZCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5vIHNlc3Npb24gZ2l2ZW4sIGdyYWIgYSBzZXNzaW9uIGZyb20gdGhlIGNhY2hlLCBpZiBhdmFpbGFibGVcbiAgICAgIGlmKHNlc3Npb25JZC5sZW5ndGggPT09IDAgJiYgYy5zZXNzaW9uQ2FjaGUpIHtcbiAgICAgICAgc2Vzc2lvbiA9IGMuc2Vzc2lvbkNhY2hlLmdldFNlc3Npb24oKTtcbiAgICAgICAgaWYoc2Vzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIHNlc3Npb25JZCA9IHNlc3Npb24uaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHVwIHNlc3Npb25cbiAgICAgIGMuc2Vzc2lvbiA9IHtcbiAgICAgICAgaWQ6IHNlc3Npb25JZCxcbiAgICAgICAgdmVyc2lvbjogbnVsbCxcbiAgICAgICAgY2lwaGVyU3VpdGU6IG51bGwsXG4gICAgICAgIGNvbXByZXNzaW9uTWV0aG9kOiBudWxsLFxuICAgICAgICBzZXJ2ZXJDZXJ0aWZpY2F0ZTogbnVsbCxcbiAgICAgICAgY2VydGlmaWNhdGVSZXF1ZXN0OiBudWxsLFxuICAgICAgICBjbGllbnRDZXJ0aWZpY2F0ZTogbnVsbCxcbiAgICAgICAgc3A6IHt9LFxuICAgICAgICBtZDU6IGZvcmdlLm1kLm1kNS5jcmVhdGUoKSxcbiAgICAgICAgc2hhMTogZm9yZ2UubWQuc2hhMS5jcmVhdGUoKVxuICAgICAgfTtcblxuICAgICAgLy8gdXNlIGV4aXN0aW5nIHNlc3Npb24gaW5mb3JtYXRpb25cbiAgICAgIGlmKHNlc3Npb24pIHtcbiAgICAgICAgLy8gb25seSB1cGRhdGUgdmVyc2lvbiBvbiBjb25uZWN0aW9uLCBzZXNzaW9uIHZlcnNpb24gbm90IHlldCBzZXRcbiAgICAgICAgYy52ZXJzaW9uID0gc2Vzc2lvbi52ZXJzaW9uO1xuICAgICAgICBjLnNlc3Npb24uc3AgPSBzZXNzaW9uLnNwO1xuICAgICAgfVxuXG4gICAgICAvLyBnZW5lcmF0ZSBuZXcgY2xpZW50IHJhbmRvbVxuICAgICAgYy5zZXNzaW9uLnNwLmNsaWVudF9yYW5kb20gPSB0bHMuY3JlYXRlUmFuZG9tKCkuZ2V0Qnl0ZXMoKTtcblxuICAgICAgLy8gY29ubmVjdGlvbiBub3cgb3BlblxuICAgICAgYy5vcGVuID0gdHJ1ZTtcblxuICAgICAgLy8gc2VuZCBoZWxsb1xuICAgICAgdGxzLnF1ZXVlKGMsIHRscy5jcmVhdGVSZWNvcmQoYywge1xuICAgICAgICB0eXBlOiB0bHMuQ29udGVudFR5cGUuaGFuZHNoYWtlLFxuICAgICAgICBkYXRhOiB0bHMuY3JlYXRlQ2xpZW50SGVsbG8oYylcbiAgICAgIH0pKTtcbiAgICAgIHRscy5mbHVzaChjKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIFRMUyBwcm90b2NvbCBkYXRhIGhhcyBiZWVuIHJlY2VpdmVkIGZyb20gc29tZXdoZXJlIGFuZCBzaG91bGRcbiAgICogYmUgcHJvY2Vzc2VkIGJ5IHRoZSBUTFMgZW5naW5lLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSB0aGUgVExTIHByb3RvY29sIGRhdGEsIGFzIGEgc3RyaW5nLCB0byBwcm9jZXNzLlxuICAgKlxuICAgKiBAcmV0dXJuIDAgaWYgdGhlIGRhdGEgY291bGQgYmUgcHJvY2Vzc2VkLCBvdGhlcndpc2UgdGhlIG51bWJlciBvZiBieXRlc1xuICAgKiAgICAgICAgIHJlcXVpcmVkIGZvciBkYXRhIHRvIGJlIHByb2Nlc3NlZC5cbiAgICovXG4gIGMucHJvY2VzcyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgcnZhbCA9IDA7XG5cbiAgICAvLyBidWZmZXIgaW5wdXQgZGF0YVxuICAgIGlmKGRhdGEpIHtcbiAgICAgIGMuaW5wdXQucHV0Qnl0ZXMoZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gcHJvY2VzcyBuZXh0IHJlY29yZCBpZiBubyBmYWlsdXJlLCBwcm9jZXNzIHdpbGwgYmUgY2FsbGVkIGFmdGVyXG4gICAgLy8gZWFjaCByZWNvcmQgaXMgaGFuZGxlZCAoc2luY2UgaGFuZGxpbmcgY2FuIGJlIGFzeW5jaHJvbm91cylcbiAgICBpZighYy5mYWlsKSB7XG4gICAgICAvLyByZXNldCByZWNvcmQgaWYgcmVhZHkgYW5kIG5vdyBlbXB0eVxuICAgICAgaWYoYy5yZWNvcmQgIT09IG51bGwgJiZcbiAgICAgICAgYy5yZWNvcmQucmVhZHkgJiYgYy5yZWNvcmQuZnJhZ21lbnQuaXNFbXB0eSgpKSB7XG4gICAgICAgIGMucmVjb3JkID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gcGVuZGluZyByZWNvcmQsIHRyeSB0byByZWFkIHJlY29yZCBoZWFkZXJcbiAgICAgIGlmKGMucmVjb3JkID09PSBudWxsKSB7XG4gICAgICAgIHJ2YWwgPSBfcmVhZFJlY29yZEhlYWRlcihjKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVhZCB0aGUgbmV4dCByZWNvcmQgKGlmIHJlY29yZCBub3QgeWV0IHJlYWR5KVxuICAgICAgaWYoIWMuZmFpbCAmJiBjLnJlY29yZCAhPT0gbnVsbCAmJiAhYy5yZWNvcmQucmVhZHkpIHtcbiAgICAgICAgcnZhbCA9IF9yZWFkUmVjb3JkKGMpO1xuICAgICAgfVxuXG4gICAgICAvLyByZWNvcmQgcmVhZHkgdG8gYmUgaGFuZGxlZCwgdXBkYXRlIGVuZ2luZSBzdGF0ZVxuICAgICAgaWYoIWMuZmFpbCAmJiBjLnJlY29yZCAhPT0gbnVsbCAmJiBjLnJlY29yZC5yZWFkeSkge1xuICAgICAgICBfdXBkYXRlKGMsIGMucmVjb3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICAvKipcbiAgICogUmVxdWVzdHMgdGhhdCBhcHBsaWNhdGlvbiBkYXRhIGJlIHBhY2thZ2VkIGludG8gYSBUTFMgcmVjb3JkLiBUaGVcbiAgICogdGxzRGF0YVJlYWR5IGhhbmRsZXIgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgVExTIHJlY29yZChzKSBoYXZlIGJlZW5cbiAgICogcHJlcGFyZWQuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIHRoZSBhcHBsaWNhdGlvbiBkYXRhLCBhcyBhIHJhdyAnYmluYXJ5JyBlbmNvZGVkIHN0cmluZywgdG9cbiAgICogICAgICAgICAgYmUgc2VudDsgdG8gc2VuZCB1dGYtMTYvdXRmLTggc3RyaW5nIGRhdGEsIHVzZSB0aGUgcmV0dXJuIHZhbHVlXG4gICAqICAgICAgICAgIG9mIHV0aWwuZW5jb2RlVXRmOChzdHIpLlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZS5cbiAgICovXG4gIGMucHJlcGFyZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB0bHMucXVldWUoYywgdGxzLmNyZWF0ZVJlY29yZChjLCB7XG4gICAgICB0eXBlOiB0bHMuQ29udGVudFR5cGUuYXBwbGljYXRpb25fZGF0YSxcbiAgICAgIGRhdGE6IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGRhdGEpXG4gICAgfSkpO1xuICAgIHJldHVybiB0bHMuZmx1c2goYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcXVlc3RzIHRoYXQgYSBoZWFydGJlYXQgcmVxdWVzdCBiZSBwYWNrYWdlZCBpbnRvIGEgVExTIHJlY29yZCBmb3JcbiAgICogdHJhbnNtaXNzaW9uLiBUaGUgdGxzRGF0YVJlYWR5IGhhbmRsZXIgd2lsbCBiZSBjYWxsZWQgd2hlbiBUTFMgcmVjb3JkKHMpXG4gICAqIGhhdmUgYmVlbiBwcmVwYXJlZC5cbiAgICpcbiAgICogV2hlbiBhIGhlYXJ0YmVhdCByZXNwb25zZSBoYXMgYmVlbiByZWNlaXZlZCwgdGhlIGhlYXJ0YmVhdFJlY2VpdmVkXG4gICAqIGhhbmRsZXIgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgbWF0Y2hpbmcgcGF5bG9hZC4gVGhpcyBoYW5kbGVyIGNhblxuICAgKiBiZSB1c2VkIHRvIGNsZWFyIGEgcmV0cmFuc21pc3Npb24gdGltZXIsIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHBheWxvYWQgdGhlIGhlYXJ0YmVhdCBkYXRhIHRvIHNlbmQgYXMgdGhlIHBheWxvYWQgaW4gdGhlIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSBbcGF5bG9hZExlbmd0aF0gdGhlIHBheWxvYWQgbGVuZ3RoIHRvIHVzZSwgZGVmYXVsdHMgdG8gdGhlXG4gICAqICAgICAgICAgIGFjdHVhbCBwYXlsb2FkIGxlbmd0aC5cbiAgICpcbiAgICogQHJldHVybiB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmUuXG4gICAqL1xuICBjLnByZXBhcmVIZWFydGJlYXRSZXF1ZXN0ID0gZnVuY3Rpb24ocGF5bG9hZCwgcGF5bG9hZExlbmd0aCkge1xuICAgIGlmKHBheWxvYWQgaW5zdGFuY2VvZiBmb3JnZS51dGlsLkJ5dGVCdWZmZXIpIHtcbiAgICAgIHBheWxvYWQgPSBwYXlsb2FkLmJ5dGVzKCk7XG4gICAgfVxuICAgIGlmKHR5cGVvZiBwYXlsb2FkTGVuZ3RoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcGF5bG9hZExlbmd0aCA9IHBheWxvYWQubGVuZ3RoO1xuICAgIH1cbiAgICBjLmV4cGVjdGVkSGVhcnRiZWF0UGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgdGxzLnF1ZXVlKGMsIHRscy5jcmVhdGVSZWNvcmQoYywge1xuICAgICAgdHlwZTogdGxzLkNvbnRlbnRUeXBlLmhlYXJ0YmVhdCxcbiAgICAgIGRhdGE6IHRscy5jcmVhdGVIZWFydGJlYXQoXG4gICAgICAgIHRscy5IZWFydGJlYXRNZXNzYWdlVHlwZS5oZWFydGJlYXRfcmVxdWVzdCwgcGF5bG9hZCwgcGF5bG9hZExlbmd0aClcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRscy5mbHVzaChjKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uIChzZW5kcyBhIGNsb3NlX25vdGlmeSBhbGVydCkuXG4gICAqXG4gICAqIEBwYXJhbSBjbGVhckZhaWwgdHJ1ZSB0byBjbGVhciB0aGUgZmFpbCBmbGFnIChkZWZhdWx0OiB0cnVlKS5cbiAgICovXG4gIGMuY2xvc2UgPSBmdW5jdGlvbihjbGVhckZhaWwpIHtcbiAgICAvLyBzYXZlIHNlc3Npb24gaWYgY29ubmVjdGlvbiBkaWRuJ3QgZmFpbFxuICAgIGlmKCFjLmZhaWwgJiYgYy5zZXNzaW9uQ2FjaGUgJiYgYy5zZXNzaW9uKSB7XG4gICAgICAvLyBvbmx5IG5lZWQgdG8gcHJlc2VydmUgc2Vzc2lvbiBJRCwgdmVyc2lvbiwgYW5kIHNlY3VyaXR5IHBhcmFtc1xuICAgICAgdmFyIHNlc3Npb24gPSB7XG4gICAgICAgIGlkOiBjLnNlc3Npb24uaWQsXG4gICAgICAgIHZlcnNpb246IGMuc2Vzc2lvbi52ZXJzaW9uLFxuICAgICAgICBzcDogYy5zZXNzaW9uLnNwXG4gICAgICB9O1xuICAgICAgc2Vzc2lvbi5zcC5rZXlzID0gbnVsbDtcbiAgICAgIGMuc2Vzc2lvbkNhY2hlLnNldFNlc3Npb24oc2Vzc2lvbi5pZCwgc2Vzc2lvbik7XG4gICAgfVxuXG4gICAgaWYoYy5vcGVuKSB7XG4gICAgICAvLyBjb25uZWN0aW9uIG5vIGxvbmdlciBvcGVuLCBjbGVhciBpbnB1dFxuICAgICAgYy5vcGVuID0gZmFsc2U7XG4gICAgICBjLmlucHV0LmNsZWFyKCk7XG5cbiAgICAgIC8vIGlmIGNvbm5lY3RlZCBvciBoYW5kc2hha2luZywgc2VuZCBhbiBhbGVydFxuICAgICAgaWYoYy5pc0Nvbm5lY3RlZCB8fCBjLmhhbmRzaGFraW5nKSB7XG4gICAgICAgIGMuaXNDb25uZWN0ZWQgPSBjLmhhbmRzaGFraW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gc2VuZCBjbG9zZV9ub3RpZnkgYWxlcnRcbiAgICAgICAgdGxzLnF1ZXVlKGMsIHRscy5jcmVhdGVBbGVydChjLCB7XG4gICAgICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC53YXJuaW5nLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24uY2xvc2Vfbm90aWZ5XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGxzLmZsdXNoKGMpO1xuICAgICAgfVxuXG4gICAgICAvLyBjYWxsIGhhbmRsZXJcbiAgICAgIGMuY2xvc2VkKGMpO1xuICAgIH1cblxuICAgIC8vIHJlc2V0IFRMUyBjb25uZWN0aW9uLCBkbyBub3QgY2xlYXIgZmFpbCBmbGFnXG4gICAgYy5yZXNldChjbGVhckZhaWwpO1xuICB9O1xuXG4gIHJldHVybiBjO1xufTtcblxuLyogVExTIEFQSSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS50bHMgPSBmb3JnZS50bHMgfHwge307XG5cbi8vIGV4cG9zZSBub24tZnVuY3Rpb25zXG5mb3IodmFyIGtleSBpbiB0bHMpIHtcbiAgaWYodHlwZW9mIHRsc1trZXldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgZm9yZ2UudGxzW2tleV0gPSB0bHNba2V5XTtcbiAgfVxufVxuXG4vLyBleHBvc2UgcHJmX3RsczEgZm9yIHRlc3RpbmdcbmZvcmdlLnRscy5wcmZfdGxzMSA9IHByZl9UTFMxO1xuXG4vLyBleHBvc2Ugc2hhMSBobWFjIG1ldGhvZFxuZm9yZ2UudGxzLmhtYWNfc2hhMSA9IGhtYWNfc2hhMTtcblxuLy8gZXhwb3NlIHNlc3Npb24gY2FjaGUgY3JlYXRpb25cbmZvcmdlLnRscy5jcmVhdGVTZXNzaW9uQ2FjaGUgPSB0bHMuY3JlYXRlU2Vzc2lvbkNhY2hlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVExTIGNvbm5lY3Rpb24uIFRoaXMgZG9lcyBub3QgbWFrZSBhbnkgYXNzdW1wdGlvbnMgYWJvdXQgdGhlXG4gKiB0cmFuc3BvcnQgbGF5ZXIgdGhhdCBUTFMgaXMgd29ya2luZyBvbiB0b3Agb2YsIGllOiBpdCBkb2VzIG5vdCBhc3N1bWUgdGhlcmVcbiAqIGlzIGEgVENQL0lQIGNvbm5lY3Rpb24gb3IgZXN0YWJsaXNoIG9uZS4gQSBUTFMgY29ubmVjdGlvbiBpcyB0b3RhbGx5XG4gKiBhYnN0cmFjdGVkIGF3YXkgZnJvbSB0aGUgbGF5ZXIgaXMgcnVucyBvbiB0b3Agb2YsIGl0IG1lcmVseSBlc3RhYmxpc2hlcyBhXG4gKiBzZWN1cmUgY2hhbm5lbCBiZXR3ZWVuIGEgY2xpZW50XCIgYW5kIGEgXCJzZXJ2ZXJcIi5cbiAqXG4gKiBBIFRMUyBjb25uZWN0aW9uIGNvbnRhaW5zIDQgY29ubmVjdGlvbiBzdGF0ZXM6IHBlbmRpbmcgcmVhZCBhbmQgd3JpdGUsIGFuZFxuICogY3VycmVudCByZWFkIGFuZCB3cml0ZS5cbiAqXG4gKiBBdCBpbml0aWFsaXphdGlvbiwgdGhlIGN1cnJlbnQgcmVhZCBhbmQgd3JpdGUgc3RhdGVzIHdpbGwgYmUgbnVsbC4gT25seSBvbmNlXG4gKiB0aGUgc2VjdXJpdHkgcGFyYW1ldGVycyBoYXZlIGJlZW4gc2V0IGFuZCB0aGUga2V5cyBoYXZlIGJlZW4gZ2VuZXJhdGVkIGNhblxuICogdGhlIHBlbmRpbmcgc3RhdGVzIGJlIGNvbnZlcnRlZCBpbnRvIGN1cnJlbnQgc3RhdGVzLiBDdXJyZW50IHN0YXRlcyB3aWxsIGJlXG4gKiB1cGRhdGVkIGZvciBlYWNoIHJlY29yZCBwcm9jZXNzZWQuXG4gKlxuICogQSBjdXN0b20gY2VydGlmaWNhdGUgdmVyaWZ5IGNhbGxiYWNrIG1heSBiZSBwcm92aWRlZCB0byBjaGVjayBpbmZvcm1hdGlvblxuICogbGlrZSB0aGUgY29tbW9uIG5hbWUgb24gdGhlIHNlcnZlcidzIGNlcnRpZmljYXRlLiBJdCB3aWxsIGJlIGNhbGxlZCBmb3JcbiAqIGV2ZXJ5IGNlcnRpZmljYXRlIGluIHRoZSBjaGFpbi4gSXQgaGFzIHRoZSBmb2xsb3dpbmcgc2lnbmF0dXJlOlxuICpcbiAqIHZhcmlhYmxlIGZ1bmMoYywgY2VydHMsIGluZGV4LCBwcmVWZXJpZnkpXG4gKiBXaGVyZTpcbiAqIGMgICAgICAgICBUaGUgVExTIGNvbm5lY3Rpb25cbiAqIHZlcmlmaWVkICBTZXQgdG8gdHJ1ZSBpZiBjZXJ0aWZpY2F0ZSB3YXMgdmVyaWZpZWQsIG90aGVyd2lzZSB0aGUgYWxlcnRcbiAqICAgICAgICAgICB0bHMuQWxlcnQuRGVzY3JpcHRpb24gZm9yIHdoeSB0aGUgY2VydGlmaWNhdGUgZmFpbGVkLlxuICogZGVwdGggICAgIFRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBjaGFpbiwgd2hlcmUgMCBpcyB0aGUgc2VydmVyJ3MgY2VydC5cbiAqIGNlcnRzICAgICBUaGUgY2VydGlmaWNhdGUgY2hhaW4sICpOT1RFKiBpZiB0aGUgc2VydmVyIHdhcyBhbm9ueW1vdXMgdGhlblxuICogICAgICAgICAgIHRoZSBjaGFpbiB3aWxsIGJlIGVtcHR5LlxuICpcbiAqIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgb24gc3VjY2VzcyBhbmQgb24gZmFpbHVyZSBlaXRoZXIgdGhlIGFwcHJvcHJpYXRlXG4gKiB0bHMuQWxlcnQuRGVzY3JpcHRpb24gb3IgYW4gb2JqZWN0IHdpdGggJ2FsZXJ0JyBzZXQgdG8gdGhlIGFwcHJvcHJpYXRlXG4gKiB0bHMuQWxlcnQuRGVzY3JpcHRpb24gYW5kICdtZXNzYWdlJyBzZXQgdG8gYSBjdXN0b20gZXJyb3IgbWVzc2FnZS4gSWYgdHJ1ZVxuICogaXMgbm90IHJldHVybmVkIHRoZW4gdGhlIGNvbm5lY3Rpb24gd2lsbCBhYm9ydCB1c2luZywgaW4gb3JkZXIgb2ZcbiAqIGF2YWlsYWJpbGl0eSwgZmlyc3QgdGhlIHJldHVybmVkIGFsZXJ0IGRlc2NyaXB0aW9uLCBzZWNvbmQgdGhlIHByZVZlcmlmeVxuICogYWxlcnQgZGVzY3JpcHRpb24sIGFuZCBsYXN0bHkgdGhlIGRlZmF1bHQgJ2JhZF9jZXJ0aWZpY2F0ZScuXG4gKlxuICogVGhlcmUgYXJlIHRocmVlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgdXNlIG9mIGNsaWVudC1zaWRlXG4gKiBjZXJ0aWZpY2F0ZXMgd2hlcmUgZWFjaCB0YWtlcyB0aGUgVExTIGNvbm5lY3Rpb24gYXMgdGhlIGZpcnN0IHBhcmFtZXRlcjpcbiAqXG4gKiBnZXRDZXJ0aWZpY2F0ZShjb25uLCBoaW50KVxuICogICBUaGUgc2Vjb25kIHBhcmFtZXRlciBpcyBhIGhpbnQgYXMgdG8gd2hpY2ggY2VydGlmaWNhdGUgc2hvdWxkIGJlXG4gKiAgIHJldHVybmVkLiBJZiB0aGUgY29ubmVjdGlvbiBlbnRpdHkgaXMgYSBjbGllbnQsIHRoZW4gdGhlIGhpbnQgd2lsbCBiZVxuICogICB0aGUgQ2VydGlmaWNhdGVSZXF1ZXN0IG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyIHRoYXQgaXMgcGFydCBvZiB0aGVcbiAqICAgVExTIHByb3RvY29sLiBJZiB0aGUgY29ubmVjdGlvbiBlbnRpdHkgaXMgYSBzZXJ2ZXIsIHRoZW4gaXQgd2lsbCBiZVxuICogICB0aGUgc2VydmVybmFtZSBsaXN0IHByb3ZpZGVkIHZpYSBhbiBTTkkgZXh0ZW5zaW9uIHRoZSBDbGllbnRIZWxsbywgaWZcbiAqICAgb25lIHdhcyBwcm92aWRlZCAoZW1wdHkgYXJyYXkgaWYgbm90KS4gVGhlIGhpbnQgY2FuIGJlIGV4YW1pbmVkIHRvXG4gKiAgIGRldGVybWluZSB3aGljaCBjZXJ0aWZpY2F0ZSB0byB1c2UgKGFkdmFuY2VkKS4gTW9zdCBpbXBsZW1lbnRhdGlvbnNcbiAqICAgd2lsbCBqdXN0IHJldHVybiBhIGNlcnRpZmljYXRlLiBUaGUgcmV0dXJuIHZhbHVlIG11c3QgYmUgYVxuICogICBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlIG9yIGFuIGFycmF5IG9mIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGVzXG4gKiAgIHRoYXQgY29uc3RpdHV0ZSBhIGNlcnRpZmljYXRlIGNoYWluLCB3aXRoIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkvY2hhaW5cbiAqICAgYmVpbmcgdGhlIGNsaWVudCdzIGNlcnRpZmljYXRlLlxuICogZ2V0UHJpdmF0ZUtleShjb25uLCBjZXJ0aWZpY2F0ZSlcbiAqICAgVGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgYW4gZm9yZ2UucGtpIFguNTA5IGNlcnRpZmljYXRlIG9iamVjdCB0aGF0XG4gKiAgIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVxdWVzdGVkIHByaXZhdGUga2V5LiBUaGUgcmV0dXJuIHZhbHVlIG11c3RcbiAqICAgYmUgYSBQRU0tZm9ybWF0dGVkIHByaXZhdGUga2V5LlxuICogZ2V0U2lnbmF0dXJlKGNvbm4sIGJ5dGVzLCBjYWxsYmFjaylcbiAqICAgVGhpcyBjYWxsYmFjayBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIGdldFByaXZhdGVLZXkgaWYgdGhlIHByaXZhdGUga2V5XG4gKiAgIGlzIG5vdCBkaXJlY3RseSBhY2Nlc3NpYmxlIGluIGphdmFzY3JpcHQgb3Igc2hvdWxkIG5vdCBiZS4gRm9yXG4gKiAgIGluc3RhbmNlLCBhIHNlY3VyZSBleHRlcm5hbCB3ZWIgc2VydmljZSBjb3VsZCBwcm92aWRlIHRoZSBzaWduYXR1cmVcbiAqICAgaW4gZXhjaGFuZ2UgZm9yIGFwcHJvcHJpYXRlIGNyZWRlbnRpYWxzLiBUaGUgc2Vjb25kIHBhcmFtZXRlciBpcyBhXG4gKiAgIHN0cmluZyBvZiBieXRlcyB0byBiZSBzaWduZWQgdGhhdCBhcmUgcGFydCBvZiB0aGUgVExTIHByb3RvY29sLiBUaGVzZVxuICogICBieXRlcyBhcmUgdXNlZCB0byB2ZXJpZnkgdGhhdCB0aGUgcHJpdmF0ZSBrZXkgZm9yIHRoZSBwcmV2aW91c2x5XG4gKiAgIHByb3ZpZGVkIGNsaWVudC1zaWRlIGNlcnRpZmljYXRlIGlzIGFjY2Vzc2libGUgdG8gdGhlIGNsaWVudC4gVGhlXG4gKiAgIGNhbGxiYWNrIGlzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyAyIHBhcmFtZXRlcnMsIHRoZSBUTFMgY29ubmVjdGlvblxuICogICBhbmQgdGhlIFJTQSBlbmNyeXB0ZWQgKHNpZ25lZCkgYnl0ZXMgYXMgYSBzdHJpbmcuIFRoaXMgY2FsbGJhY2sgbXVzdFxuICogICBiZSBjYWxsZWQgb25jZSB0aGUgc2lnbmF0dXJlIGlzIHJlYWR5LlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIGZvciB0aGlzIGNvbm5lY3Rpb246XG4gKiAgIHNlcnZlcjogdHJ1ZSBpZiB0aGUgY29ubmVjdGlvbiBpcyBzZXJ2ZXItc2lkZSwgZmFsc2UgZm9yIGNsaWVudC5cbiAqICAgc2Vzc2lvbklkOiBhIHNlc3Npb24gSUQgdG8gcmV1c2UsIG51bGwgZm9yIGEgbmV3IGNvbm5lY3Rpb24uXG4gKiAgIGNhU3RvcmU6IGFuIGFycmF5IG9mIGNlcnRpZmljYXRlcyB0byB0cnVzdC5cbiAqICAgc2Vzc2lvbkNhY2hlOiBhIHNlc3Npb24gY2FjaGUgdG8gdXNlLlxuICogICBjaXBoZXJTdWl0ZXM6IGFuIG9wdGlvbmFsIGFycmF5IG9mIGNpcGhlciBzdWl0ZXMgdG8gdXNlLFxuICogICAgIHNlZSB0bHMuQ2lwaGVyU3VpdGVzLlxuICogICBjb25uZWN0ZWQ6IGZ1bmN0aW9uKGNvbm4pIGNhbGxlZCB3aGVuIHRoZSBmaXJzdCBoYW5kc2hha2UgY29tcGxldGVzLlxuICogICB2aXJ0dWFsSG9zdDogdGhlIHZpcnR1YWwgc2VydmVyIG5hbWUgdG8gdXNlIGluIGEgVExTIFNOSSBleHRlbnNpb24uXG4gKiAgIHZlcmlmeUNsaWVudDogdHJ1ZSB0byByZXF1aXJlIGEgY2xpZW50IGNlcnRpZmljYXRlIGluIHNlcnZlciBtb2RlLFxuICogICAgICdvcHRpb25hbCcgdG8gcmVxdWVzdCBvbmUsIGZhbHNlIG5vdCB0byAoZGVmYXVsdDogZmFsc2UpLlxuICogICB2ZXJpZnk6IGEgaGFuZGxlciB1c2VkIHRvIGN1c3RvbSB2ZXJpZnkgY2VydGlmaWNhdGVzIGluIHRoZSBjaGFpbi5cbiAqICAgdmVyaWZ5T3B0aW9uczogYW4gb2JqZWN0IHdpdGggb3B0aW9ucyBmb3IgdGhlIGNlcnRpZmljYXRlIGNoYWluIHZhbGlkYXRpb24uXG4gKiAgICAgU2VlIGRvY3VtZW50YXRpb24gb2YgcGtpLnZlcmlmeUNlcnRpZmljYXRlQ2hhaW4gZm9yIHBvc3NpYmxlIG9wdGlvbnMuXG4gKiAgICAgdmVyaWZ5T3B0aW9ucy52ZXJpZnkgaXMgaWdub3JlZC4gSWYgeW91IHdpc2ggdG8gc3BlY2lmeSBhIHZlcmlmeSBoYW5kbGVyXG4gKiAgICAgdXNlIHRoZSB2ZXJpZnkga2V5LlxuICogICBnZXRDZXJ0aWZpY2F0ZTogYW4gb3B0aW9uYWwgY2FsbGJhY2sgdXNlZCB0byBnZXQgYSBjZXJ0aWZpY2F0ZSBvclxuICogICAgIGEgY2hhaW4gb2YgY2VydGlmaWNhdGVzIChhcyBhbiBhcnJheSkuXG4gKiAgIGdldFByaXZhdGVLZXk6IGFuIG9wdGlvbmFsIGNhbGxiYWNrIHVzZWQgdG8gZ2V0IGEgcHJpdmF0ZSBrZXkuXG4gKiAgIGdldFNpZ25hdHVyZTogYW4gb3B0aW9uYWwgY2FsbGJhY2sgdXNlZCB0byBnZXQgYSBzaWduYXR1cmUuXG4gKiAgIHRsc0RhdGFSZWFkeTogZnVuY3Rpb24oY29ubikgY2FsbGVkIHdoZW4gVExTIHByb3RvY29sIGRhdGEgaGFzIGJlZW5cbiAqICAgICBwcmVwYXJlZCBhbmQgaXMgcmVhZHkgdG8gYmUgdXNlZCAodHlwaWNhbGx5IHNlbnQgb3ZlciBhIHNvY2tldFxuICogICAgIGNvbm5lY3Rpb24gdG8gaXRzIGRlc3RpbmF0aW9uKSwgcmVhZCBmcm9tIGNvbm4udGxzRGF0YSBidWZmZXIuXG4gKiAgIGRhdGFSZWFkeTogZnVuY3Rpb24oY29ubikgY2FsbGVkIHdoZW4gYXBwbGljYXRpb24gZGF0YSBoYXNcbiAqICAgICBiZWVuIHBhcnNlZCBmcm9tIGEgVExTIHJlY29yZCBhbmQgc2hvdWxkIGJlIGNvbnN1bWVkIGJ5IHRoZVxuICogICAgIGFwcGxpY2F0aW9uLCByZWFkIGZyb20gY29ubi5kYXRhIGJ1ZmZlci5cbiAqICAgY2xvc2VkOiBmdW5jdGlvbihjb25uKSBjYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBoYXMgYmVlbiBjbG9zZWQuXG4gKiAgIGVycm9yOiBmdW5jdGlvbihjb25uLCBlcnJvcikgY2FsbGVkIHdoZW4gdGhlcmUgd2FzIGFuIGVycm9yLlxuICogICBkZWZsYXRlOiBmdW5jdGlvbihpbkJ5dGVzKSBpZiBwcm92aWRlZCwgd2lsbCBkZWZsYXRlIFRMUyByZWNvcmRzIHVzaW5nXG4gKiAgICAgdGhlIGRlZmxhdGUgYWxnb3JpdGhtIGlmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgaXQuXG4gKiAgIGluZmxhdGU6IGZ1bmN0aW9uKGluQnl0ZXMpIGlmIHByb3ZpZGVkLCB3aWxsIGluZmxhdGUgVExTIHJlY29yZHMgdXNpbmdcbiAqICAgICB0aGUgZGVmbGF0ZSBhbGdvcml0aG0gaWYgdGhlIHNlcnZlciBzdXBwb3J0cyBpdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBuZXcgVExTIGNvbm5lY3Rpb24uXG4gKi9cbmZvcmdlLnRscy5jcmVhdGVDb25uZWN0aW9uID0gdGxzLmNyZWF0ZUNvbm5lY3Rpb247XG4iXSwibmFtZXMiOlsiZm9yZ2UiLCJyZXF1aXJlIiwicHJmX1RMUzEiLCJzZWNyZXQiLCJsYWJlbCIsInNlZWQiLCJsZW5ndGgiLCJydmFsIiwidXRpbCIsImNyZWF0ZUJ1ZmZlciIsImlkeCIsInNsZW4iLCJzMSIsInN1YnN0ciIsInMyIiwiYWkiLCJobWFjIiwiY3JlYXRlIiwibWQ1aXRyIiwiTWF0aCIsImNlaWwiLCJzaGExaXRyIiwic3RhcnQiLCJtZDVieXRlcyIsInB1dEJ5dGVzIiwiaSIsInVwZGF0ZSIsImdldEJ5dGVzIiwicHV0QnVmZmVyIiwiZGlnZXN0IiwiYnl0ZXMiLCJzaGExYnl0ZXMiLCJjbGVhciIsInhvckJ5dGVzIiwicHJmX3NoYTI1NiIsImhtYWNfc2hhMSIsImtleSIsInNlcU51bSIsInJlY29yZCIsImIiLCJwdXRJbnQzMiIsInB1dEJ5dGUiLCJ0eXBlIiwidmVyc2lvbiIsIm1ham9yIiwibWlub3IiLCJwdXRJbnQxNiIsImZyYWdtZW50IiwiZGVmbGF0ZSIsImMiLCJzIiwiZXgiLCJpbmZsYXRlIiwicmVhZFZlY3RvciIsImxlbkJ5dGVzIiwibGVuIiwiZ2V0Qnl0ZSIsImdldEludDE2IiwiZ2V0SW50MjQiLCJnZXRJbnQzMiIsIndyaXRlVmVjdG9yIiwidiIsInB1dEludCIsInRscyIsIlZlcnNpb25zIiwiVExTXzFfMCIsIlRMU18xXzEiLCJUTFNfMV8yIiwiU3VwcG9ydGVkVmVyc2lvbnMiLCJWZXJzaW9uIiwiTWF4RnJhZ21lbnQiLCJDb25uZWN0aW9uRW5kIiwic2VydmVyIiwiY2xpZW50IiwiUFJGQWxnb3JpdGhtIiwidGxzX3ByZl9zaGEyNTYiLCJCdWxrQ2lwaGVyQWxnb3JpdGhtIiwibm9uZSIsInJjNCIsImRlczMiLCJhZXMiLCJDaXBoZXJUeXBlIiwic3RyZWFtIiwiYmxvY2siLCJhZWFkIiwiTUFDQWxnb3JpdGhtIiwiaG1hY19tZDUiLCJobWFjX3NoYTI1NiIsImhtYWNfc2hhMzg0IiwiaG1hY19zaGE1MTIiLCJDb21wcmVzc2lvbk1ldGhvZCIsIkNvbnRlbnRUeXBlIiwiY2hhbmdlX2NpcGhlcl9zcGVjIiwiYWxlcnQiLCJoYW5kc2hha2UiLCJhcHBsaWNhdGlvbl9kYXRhIiwiaGVhcnRiZWF0IiwiSGFuZHNoYWtlVHlwZSIsImhlbGxvX3JlcXVlc3QiLCJjbGllbnRfaGVsbG8iLCJzZXJ2ZXJfaGVsbG8iLCJjZXJ0aWZpY2F0ZSIsInNlcnZlcl9rZXlfZXhjaGFuZ2UiLCJjZXJ0aWZpY2F0ZV9yZXF1ZXN0Iiwic2VydmVyX2hlbGxvX2RvbmUiLCJjZXJ0aWZpY2F0ZV92ZXJpZnkiLCJjbGllbnRfa2V5X2V4Y2hhbmdlIiwiZmluaXNoZWQiLCJBbGVydCIsIkxldmVsIiwid2FybmluZyIsImZhdGFsIiwiRGVzY3JpcHRpb24iLCJjbG9zZV9ub3RpZnkiLCJ1bmV4cGVjdGVkX21lc3NhZ2UiLCJiYWRfcmVjb3JkX21hYyIsImRlY3J5cHRpb25fZmFpbGVkIiwicmVjb3JkX292ZXJmbG93IiwiZGVjb21wcmVzc2lvbl9mYWlsdXJlIiwiaGFuZHNoYWtlX2ZhaWx1cmUiLCJiYWRfY2VydGlmaWNhdGUiLCJ1bnN1cHBvcnRlZF9jZXJ0aWZpY2F0ZSIsImNlcnRpZmljYXRlX3Jldm9rZWQiLCJjZXJ0aWZpY2F0ZV9leHBpcmVkIiwiY2VydGlmaWNhdGVfdW5rbm93biIsImlsbGVnYWxfcGFyYW1ldGVyIiwidW5rbm93bl9jYSIsImFjY2Vzc19kZW5pZWQiLCJkZWNvZGVfZXJyb3IiLCJkZWNyeXB0X2Vycm9yIiwiZXhwb3J0X3Jlc3RyaWN0aW9uIiwicHJvdG9jb2xfdmVyc2lvbiIsImluc3VmZmljaWVudF9zZWN1cml0eSIsImludGVybmFsX2Vycm9yIiwidXNlcl9jYW5jZWxlZCIsIm5vX3JlbmVnb3RpYXRpb24iLCJIZWFydGJlYXRNZXNzYWdlVHlwZSIsImhlYXJ0YmVhdF9yZXF1ZXN0IiwiaGVhcnRiZWF0X3Jlc3BvbnNlIiwiQ2lwaGVyU3VpdGVzIiwiZ2V0Q2lwaGVyU3VpdGUiLCJ0d29CeXRlcyIsImNzIiwiaWQiLCJjaGFyQ29kZUF0IiwiaGFuZGxlVW5leHBlY3RlZCIsImlnbm9yZSIsIm9wZW4iLCJlbnRpdHkiLCJlcnJvciIsIm1lc3NhZ2UiLCJzZW5kIiwibGV2ZWwiLCJkZXNjcmlwdGlvbiIsImhhbmRsZUhlbGxvUmVxdWVzdCIsImhhbmRzaGFraW5nIiwiaGFuZHNoYWtlcyIsInF1ZXVlIiwiY3JlYXRlQWxlcnQiLCJmbHVzaCIsInByb2Nlc3MiLCJwYXJzZUhlbGxvTWVzc2FnZSIsIm1zZyIsInJlbWFpbmluZyIsInJhbmRvbSIsInNlc3Npb25faWQiLCJleHRlbnNpb25zIiwiY2lwaGVyX3N1aXRlIiwiY29tcHJlc3Npb25fbWV0aG9kIiwiY2lwaGVyX3N1aXRlcyIsImNvbXByZXNzaW9uX21ldGhvZHMiLCJleHRzIiwicHVzaCIsImRhdGEiLCJleHQiLCJzbmwiLCJzblR5cGUiLCJzZXNzaW9uIiwic2VydmVyX25hbWUiLCJzZXJ2ZXJOYW1lTGlzdCIsImNpcGhlclN1aXRlIiwidG1wIiwiYnl0ZXNUb0hleCIsImNvbXByZXNzaW9uTWV0aG9kIiwiY3JlYXRlU2VjdXJpdHlQYXJhbWV0ZXJzIiwibXNnUmFuZG9tIiwiY1JhbmRvbSIsInNwIiwiY2xpZW50X3JhbmRvbSIsInNSYW5kb20iLCJjcmVhdGVSYW5kb20iLCJwcmZfYWxnb3JpdGhtIiwiYnVsa19jaXBoZXJfYWxnb3JpdGhtIiwiY2lwaGVyX3R5cGUiLCJlbmNfa2V5X2xlbmd0aCIsImJsb2NrX2xlbmd0aCIsImZpeGVkX2l2X2xlbmd0aCIsInJlY29yZF9pdl9sZW5ndGgiLCJtYWNfYWxnb3JpdGhtIiwibWFjX2xlbmd0aCIsIm1hY19rZXlfbGVuZ3RoIiwiY29tcHJlc3Npb25fYWxnb3JpdGhtIiwicHJlX21hc3Rlcl9zZWNyZXQiLCJtYXN0ZXJfc2VjcmV0Iiwic2VydmVyX3JhbmRvbSIsImhhbmRsZVNlcnZlckhlbGxvIiwiZmFpbCIsInNlc3Npb25JZCIsImV4cGVjdCIsIlNDQyIsInJlc3VtaW5nIiwiU0NFIiwiaGFuZGxlQ2xpZW50SGVsbG8iLCJzZXNzaW9uQ2FjaGUiLCJnZXRTZXNzaW9uIiwiY2xpZW50SGVsbG9WZXJzaW9uIiwiQ0NDIiwidmVyaWZ5Q2xpZW50IiwiQ0NFIiwiQ0tFIiwiY3JlYXRlUmVjb3JkIiwiY3JlYXRlU2VydmVySGVsbG8iLCJjcmVhdGVDaGFuZ2VDaXBoZXJTcGVjIiwic3RhdGUiLCJwZW5kaW5nIiwiY3JlYXRlQ29ubmVjdGlvblN0YXRlIiwiY3VycmVudCIsIndyaXRlIiwiY3JlYXRlRmluaXNoZWQiLCJjcmVhdGVDZXJ0aWZpY2F0ZSIsImNyZWF0ZVNlcnZlcktleUV4Y2hhbmdlIiwiY3JlYXRlQ2VydGlmaWNhdGVSZXF1ZXN0IiwiY3JlYXRlU2VydmVySGVsbG9Eb25lIiwiaGFuZGxlQ2VydGlmaWNhdGUiLCJjZXJ0aWZpY2F0ZV9saXN0IiwiY2VydCIsImFzbjEiLCJjZXJ0cyIsImZyb21EZXIiLCJwa2kiLCJjZXJ0aWZpY2F0ZUZyb21Bc24xIiwiY2F1c2UiLCJTS0UiLCJzZXJ2ZXJDZXJ0aWZpY2F0ZSIsImNsaWVudENlcnRpZmljYXRlIiwidmVyaWZ5Q2VydGlmaWNhdGVDaGFpbiIsImhhbmRsZVNlcnZlcktleUV4Y2hhbmdlIiwiU0NSIiwiaGFuZGxlQ2xpZW50S2V5RXhjaGFuZ2UiLCJlbmNfcHJlX21hc3Rlcl9zZWNyZXQiLCJwcml2YXRlS2V5IiwiZ2V0UHJpdmF0ZUtleSIsInByaXZhdGVLZXlGcm9tUGVtIiwiZGVjcnlwdCIsIkVycm9yIiwiQ0NWIiwiaGFuZGxlQ2VydGlmaWNhdGVSZXF1ZXN0IiwiY2VydGlmaWNhdGVfdHlwZXMiLCJjZXJ0aWZpY2F0ZV9hdXRob3JpdGllcyIsImNlcnRpZmljYXRlUmVxdWVzdCIsIlNIRCIsImhhbmRsZUNlcnRpZmljYXRlVmVyaWZ5IiwicmVhZCIsIm1zZ0J5dGVzIiwic2lnbmF0dXJlIiwidmVyaWZ5IiwibWQ1Iiwic2hhMSIsInB1YmxpY0tleSIsImhhbmRsZVNlcnZlckhlbGxvRG9uZSIsImRlcHRoIiwicmV0IiwiaXNBcnJheSIsImNyZWF0ZUNsaWVudEtleUV4Y2hhbmdlIiwiU0VSIiwiY2FsbGJhY2siLCJjcmVhdGVDZXJ0aWZpY2F0ZVZlcmlmeSIsImdldENsaWVudFNpZ25hdHVyZSIsImhhbmRsZUNoYW5nZUNpcGhlclNwZWMiLCJTRkkiLCJDRkkiLCJoYW5kbGVGaW5pc2hlZCIsInZkIiwidmRsIiwicHJmIiwiU0FEIiwiQ0FEIiwicGVlckNlcnRpZmljYXRlIiwiaXNDb25uZWN0ZWQiLCJjb25uZWN0ZWQiLCJoYW5kbGVBbGVydCIsImNsb3NlIiwib3JpZ2luIiwiaGFuZGxlSGFuZHNoYWtlIiwiZnJhZ21lbnRlZCIsImhzVGFibGUiLCJtZCIsImhhbmRsZUFwcGxpY2F0aW9uRGF0YSIsImRhdGFSZWFkeSIsImhhbmRsZUhlYXJ0YmVhdCIsInBheWxvYWQiLCJjcmVhdGVIZWFydGJlYXQiLCJleHBlY3RlZEhlYXJ0YmVhdFBheWxvYWQiLCJoZWFydGJlYXRSZWNlaXZlZCIsIlNIRSIsIkNIRSIsIkNFUiIsIl9fIiwiUjAiLCJSMSIsIlIyIiwiUjMiLCJSNCIsImN0VGFibGUiLCJIMCIsIkgxIiwiSDIiLCJIMyIsIkg0IiwiSDUiLCJINiIsIkg3IiwiSDgiLCJIOSIsImdlbmVyYXRlS2V5cyIsInRsczEwIiwia20iLCJjbGllbnRfd3JpdGVfTUFDX2tleSIsInNlcnZlcl93cml0ZV9NQUNfa2V5IiwiY2xpZW50X3dyaXRlX2tleSIsInNlcnZlcl93cml0ZV9rZXkiLCJjbGllbnRfd3JpdGVfSVYiLCJzZXJ2ZXJfd3JpdGVfSVYiLCJjcmVhdGVNb2RlIiwibW9kZSIsInNlcXVlbmNlTnVtYmVyIiwibWFjS2V5IiwibWFjTGVuZ3RoIiwibWFjRnVuY3Rpb24iLCJjaXBoZXJTdGF0ZSIsImNpcGhlckZ1bmN0aW9uIiwiY29tcHJlc3Npb25TdGF0ZSIsImNvbXByZXNzRnVuY3Rpb24iLCJ1cGRhdGVTZXF1ZW5jZU51bWJlciIsImluaXRTZWN1cml0eVBhcmFtZXRlcnMiLCJrZXlzIiwiaW5pdENvbm5lY3Rpb25TdGF0ZSIsImQiLCJEYXRlIiwidXRjIiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJvcHRpb25zIiwiY3JlYXRlQ2xpZW50SGVsbG8iLCJjaXBoZXJTdWl0ZXMiLCJjU3VpdGVzIiwiY29tcHJlc3Npb25NZXRob2RzIiwiY01ldGhvZHMiLCJ2aXJ0dWFsSG9zdCIsInNlcnZlck5hbWUiLCJzbkxpc3QiLCJleHRMZW5ndGgiLCJwdXRJbnQyNCIsImdldENlcnRpZmljYXRlIiwiaGludCIsImNlcnRMaXN0IiwicGVtIiwiZGVjb2RlIiwiaGVhZGVyVHlwZSIsInByb2NUeXBlIiwiZGVyIiwiYm9keSIsImNlcnRCdWZmZXIiLCJlbmNyeXB0IiwiZ2V0U2lnbmF0dXJlIiwic2lnbiIsImNlcnRUeXBlcyIsImNBcyIsImNhU3RvcmUiLCJkbiIsImRpc3Rpbmd1aXNoZWROYW1lVG9Bc24xIiwic3ViamVjdCIsImJ5dGVCdWZmZXIiLCJ0b0RlciIsInBheWxvYWRMZW5ndGgiLCJwbGFpbnRleHRMZW5ndGgiLCJwYWRkaW5nTGVuZ3RoIiwibWF4IiwicmVjb3JkcyIsInNsaWNlIiwicmVjIiwidGxzRGF0YSIsInRsc0RhdGFSZWFkeSIsIl9jZXJ0RXJyb3JUb0FsZXJ0RGVzYyIsImNlcnRpZmljYXRlRXJyb3IiLCJfYWxlcnREZXNjVG9DZXJ0RXJyb3IiLCJkZXNjIiwiY2hhaW4iLCJ2ZXJpZnlPcHRpb25zIiwidmZkIiwiZXJyIiwiY3JlYXRlU2Vzc2lvbkNhY2hlIiwiY2FjaGUiLCJjYXBhY2l0eSIsInNldFNlc3Npb24iLCJvcmRlciIsInNwbGljZSIsInNoaWZ0IiwiY3JlYXRlQ29ubmVjdGlvbiIsImNyZWF0ZUNhU3RvcmUiLCJjbiIsImRwdGgiLCJjdHMiLCJpbnB1dCIsImNsb3NlZCIsInJlc2V0IiwiY2xlYXJGYWlsIiwiX3VwZGF0ZSIsImFsaWduZWQiLCJoYW5kbGVycyIsIl9yZWFkUmVjb3JkSGVhZGVyIiwicmVhZHkiLCJjb21wYXRpYmxlVmVyc2lvbiIsIl9yZWFkUmVjb3JkIiwiY29tcGFjdCIsImlzRW1wdHkiLCJwcmVwYXJlIiwicHJlcGFyZUhlYXJ0YmVhdFJlcXVlc3QiLCJCeXRlQnVmZmVyIiwibW9kdWxlIiwiZXhwb3J0cyIsInByZl90bHMxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/tls.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/util.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/util.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Utility functions for web applications.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2018 Digital Bazaar, Inc.\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\nvar baseN = __webpack_require__(/*! ./baseN */ \"(rsc)/./node_modules/node-forge/lib/baseN.js\");\n/* Utilities API */ var util = module.exports = forge.util = forge.util || {};\n// define setImmediate and nextTick\n(function() {\n    // use native nextTick (unless we're in webpack)\n    // webpack (or better node-libs-browser polyfill) sets process.browser.\n    // this way we can detect webpack properly\n    if (typeof process !== \"undefined\" && process.nextTick && !false) {\n        util.nextTick = process.nextTick;\n        if (typeof setImmediate === \"function\") {\n            util.setImmediate = setImmediate;\n        } else {\n            // polyfill setImmediate with nextTick, older versions of node\n            // (those w/o setImmediate) won't totally starve IO\n            util.setImmediate = util.nextTick;\n        }\n        return;\n    }\n    // polyfill nextTick with native setImmediate\n    if (typeof setImmediate === \"function\") {\n        util.setImmediate = function() {\n            return setImmediate.apply(undefined, arguments);\n        };\n        util.nextTick = function(callback) {\n            return setImmediate(callback);\n        };\n        return;\n    }\n    /* Note: A polyfill upgrade pattern is used here to allow combining\n  polyfills. For example, MutationObserver is fast, but blocks UI updates,\n  so it needs to allow UI updates periodically, so it falls back on\n  postMessage or setTimeout. */ // polyfill with setTimeout\n    util.setImmediate = function(callback) {\n        setTimeout(callback, 0);\n    };\n    // upgrade polyfill to use postMessage\n    if (false) { var callbacks, msg; }\n    // upgrade polyfill to use MutationObserver\n    if (typeof MutationObserver !== \"undefined\") {\n        // polyfill with MutationObserver\n        var now = Date.now();\n        var attr = true;\n        var div = document.createElement(\"div\");\n        var callbacks = [];\n        new MutationObserver(function() {\n            var copy = callbacks.slice();\n            callbacks.length = 0;\n            copy.forEach(function(callback) {\n                callback();\n            });\n        }).observe(div, {\n            attributes: true\n        });\n        var oldSetImmediate = util.setImmediate;\n        util.setImmediate = function(callback) {\n            if (Date.now() - now > 15) {\n                now = Date.now();\n                oldSetImmediate(callback);\n            } else {\n                callbacks.push(callback);\n                // only trigger observer when it hasn't been triggered in\n                // the current turn of the event loop\n                if (callbacks.length === 1) {\n                    div.setAttribute(\"a\", attr = !attr);\n                }\n            }\n        };\n    }\n    util.nextTick = util.setImmediate;\n})();\n// check if running under Node.js\nutil.isNodejs = typeof process !== \"undefined\" && process.versions && process.versions.node;\n// 'self' will also work in Web Workers (instance of WorkerGlobalScope) while\n// it will point to `window` in the main thread.\n// To remain compatible with older browsers, we fall back to 'window' if 'self'\n// is not available.\nutil.globalScope = function() {\n    if (util.isNodejs) {\n        return global;\n    }\n    return typeof self === \"undefined\" ? window : self;\n}();\n// define isArray\nutil.isArray = Array.isArray || function(x) {\n    return Object.prototype.toString.call(x) === \"[object Array]\";\n};\n// define isArrayBuffer\nutil.isArrayBuffer = function(x) {\n    return typeof ArrayBuffer !== \"undefined\" && x instanceof ArrayBuffer;\n};\n// define isArrayBufferView\nutil.isArrayBufferView = function(x) {\n    return x && util.isArrayBuffer(x.buffer) && x.byteLength !== undefined;\n};\n/**\n * Ensure a bits param is 8, 16, 24, or 32. Used to validate input for\n * algorithms where bit manipulation, JavaScript limitations, and/or algorithm\n * design only allow for byte operations of a limited size.\n *\n * @param n number of bits.\n *\n * Throw Error if n invalid.\n */ function _checkBitsParam(n) {\n    if (!(n === 8 || n === 16 || n === 24 || n === 32)) {\n        throw new Error(\"Only 8, 16, 24, or 32 bits supported: \" + n);\n    }\n}\n// TODO: set ByteBuffer to best available backing\nutil.ByteBuffer = ByteStringBuffer;\n/** Buffer w/BinaryString backing */ /**\n * Constructor for a binary string backed byte buffer.\n *\n * @param [b] the bytes to wrap (either encoded as string, one byte per\n *          character, or as an ArrayBuffer or Typed Array).\n */ function ByteStringBuffer(b) {\n    // TODO: update to match DataBuffer API\n    // the data in this buffer\n    this.data = \"\";\n    // the pointer for reading from this buffer\n    this.read = 0;\n    if (typeof b === \"string\") {\n        this.data = b;\n    } else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) {\n        if (typeof Buffer !== \"undefined\" && b instanceof Buffer) {\n            this.data = b.toString(\"binary\");\n        } else {\n            // convert native buffer to forge buffer\n            // FIXME: support native buffers internally instead\n            var arr = new Uint8Array(b);\n            try {\n                this.data = String.fromCharCode.apply(null, arr);\n            } catch (e) {\n                for(var i = 0; i < arr.length; ++i){\n                    this.putByte(arr[i]);\n                }\n            }\n        }\n    } else if (b instanceof ByteStringBuffer || typeof b === \"object\" && typeof b.data === \"string\" && typeof b.read === \"number\") {\n        // copy existing buffer\n        this.data = b.data;\n        this.read = b.read;\n    }\n    // used for v8 optimization\n    this._constructedStringLength = 0;\n}\nutil.ByteStringBuffer = ByteStringBuffer;\n/* Note: This is an optimization for V8-based browsers. When V8 concatenates\n  a string, the strings are only joined logically using a \"cons string\" or\n  \"constructed/concatenated string\". These containers keep references to one\n  another and can result in very large memory usage. For example, if a 2MB\n  string is constructed by concatenating 4 bytes together at a time, the\n  memory usage will be ~44MB; so ~22x increase. The strings are only joined\n  together when an operation requiring their joining takes place, such as\n  substr(). This function is called when adding data to this buffer to ensure\n  these types of strings are periodically joined to reduce the memory\n  footprint. */ var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;\nutil.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {\n    this._constructedStringLength += x;\n    if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {\n        // this substr() should cause the constructed string to join\n        this.data.substr(0, 1);\n        this._constructedStringLength = 0;\n    }\n};\n/**\n * Gets the number of bytes in this buffer.\n *\n * @return the number of bytes in this buffer.\n */ util.ByteStringBuffer.prototype.length = function() {\n    return this.data.length - this.read;\n};\n/**\n * Gets whether or not this buffer is empty.\n *\n * @return true if this buffer is empty, false if not.\n */ util.ByteStringBuffer.prototype.isEmpty = function() {\n    return this.length() <= 0;\n};\n/**\n * Puts a byte in this buffer.\n *\n * @param b the byte to put.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putByte = function(b) {\n    return this.putBytes(String.fromCharCode(b));\n};\n/**\n * Puts a byte in this buffer N times.\n *\n * @param b the byte to put.\n * @param n the number of bytes of value b to put.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {\n    b = String.fromCharCode(b);\n    var d = this.data;\n    while(n > 0){\n        if (n & 1) {\n            d += b;\n        }\n        n >>>= 1;\n        if (n > 0) {\n            b += b;\n        }\n    }\n    this.data = d;\n    this._optimizeConstructedString(n);\n    return this;\n};\n/**\n * Puts bytes in this buffer.\n *\n * @param bytes the bytes (as a binary encoded string) to put.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putBytes = function(bytes) {\n    this.data += bytes;\n    this._optimizeConstructedString(bytes.length);\n    return this;\n};\n/**\n * Puts a UTF-16 encoded string into this buffer.\n *\n * @param str the string to put.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putString = function(str) {\n    return this.putBytes(util.encodeUtf8(str));\n};\n/**\n * Puts a 16-bit integer in this buffer in big-endian order.\n *\n * @param i the 16-bit integer.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putInt16 = function(i) {\n    return this.putBytes(String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));\n};\n/**\n * Puts a 24-bit integer in this buffer in big-endian order.\n *\n * @param i the 24-bit integer.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putInt24 = function(i) {\n    return this.putBytes(String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));\n};\n/**\n * Puts a 32-bit integer in this buffer in big-endian order.\n *\n * @param i the 32-bit integer.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putInt32 = function(i) {\n    return this.putBytes(String.fromCharCode(i >> 24 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));\n};\n/**\n * Puts a 16-bit integer in this buffer in little-endian order.\n *\n * @param i the 16-bit integer.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putInt16Le = function(i) {\n    return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF));\n};\n/**\n * Puts a 24-bit integer in this buffer in little-endian order.\n *\n * @param i the 24-bit integer.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putInt24Le = function(i) {\n    return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF));\n};\n/**\n * Puts a 32-bit integer in this buffer in little-endian order.\n *\n * @param i the 32-bit integer.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putInt32Le = function(i) {\n    return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 24 & 0xFF));\n};\n/**\n * Puts an n-bit integer in this buffer in big-endian order.\n *\n * @param i the n-bit integer.\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putInt = function(i, n) {\n    _checkBitsParam(n);\n    var bytes = \"\";\n    do {\n        n -= 8;\n        bytes += String.fromCharCode(i >> n & 0xFF);\n    }while (n > 0);\n    return this.putBytes(bytes);\n};\n/**\n * Puts a signed n-bit integer in this buffer in big-endian order. Two's\n * complement representation is used.\n *\n * @param i the n-bit integer.\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {\n    // putInt checks n\n    if (i < 0) {\n        i += 2 << n - 1;\n    }\n    return this.putInt(i, n);\n};\n/**\n * Puts the given buffer into this buffer.\n *\n * @param buffer the buffer to put into this one.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.putBuffer = function(buffer) {\n    return this.putBytes(buffer.getBytes());\n};\n/**\n * Gets a byte from this buffer and advances the read pointer by 1.\n *\n * @return the byte.\n */ util.ByteStringBuffer.prototype.getByte = function() {\n    return this.data.charCodeAt(this.read++);\n};\n/**\n * Gets a uint16 from this buffer in big-endian order and advances the read\n * pointer by 2.\n *\n * @return the uint16.\n */ util.ByteStringBuffer.prototype.getInt16 = function() {\n    var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);\n    this.read += 2;\n    return rval;\n};\n/**\n * Gets a uint24 from this buffer in big-endian order and advances the read\n * pointer by 3.\n *\n * @return the uint24.\n */ util.ByteStringBuffer.prototype.getInt24 = function() {\n    var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);\n    this.read += 3;\n    return rval;\n};\n/**\n * Gets a uint32 from this buffer in big-endian order and advances the read\n * pointer by 4.\n *\n * @return the word.\n */ util.ByteStringBuffer.prototype.getInt32 = function() {\n    var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);\n    this.read += 4;\n    return rval;\n};\n/**\n * Gets a uint16 from this buffer in little-endian order and advances the read\n * pointer by 2.\n *\n * @return the uint16.\n */ util.ByteStringBuffer.prototype.getInt16Le = function() {\n    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;\n    this.read += 2;\n    return rval;\n};\n/**\n * Gets a uint24 from this buffer in little-endian order and advances the read\n * pointer by 3.\n *\n * @return the uint24.\n */ util.ByteStringBuffer.prototype.getInt24Le = function() {\n    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;\n    this.read += 3;\n    return rval;\n};\n/**\n * Gets a uint32 from this buffer in little-endian order and advances the read\n * pointer by 4.\n *\n * @return the word.\n */ util.ByteStringBuffer.prototype.getInt32Le = function() {\n    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;\n    this.read += 4;\n    return rval;\n};\n/**\n * Gets an n-bit integer from this buffer in big-endian order and advances the\n * read pointer by ceil(n/8).\n *\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return the integer.\n */ util.ByteStringBuffer.prototype.getInt = function(n) {\n    _checkBitsParam(n);\n    var rval = 0;\n    do {\n        // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.\n        rval = (rval << 8) + this.data.charCodeAt(this.read++);\n        n -= 8;\n    }while (n > 0);\n    return rval;\n};\n/**\n * Gets a signed n-bit integer from this buffer in big-endian order, using\n * two's complement, and advances the read pointer by n/8.\n *\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return the integer.\n */ util.ByteStringBuffer.prototype.getSignedInt = function(n) {\n    // getInt checks n\n    var x = this.getInt(n);\n    var max = 2 << n - 2;\n    if (x >= max) {\n        x -= max << 1;\n    }\n    return x;\n};\n/**\n * Reads bytes out as a binary encoded string and clears them from the\n * buffer. Note that the resulting string is binary encoded (in node.js this\n * encoding is referred to as `binary`, it is *not* `utf8`).\n *\n * @param count the number of bytes to read, undefined or null for all.\n *\n * @return a binary encoded string of bytes.\n */ util.ByteStringBuffer.prototype.getBytes = function(count) {\n    var rval;\n    if (count) {\n        // read count bytes\n        count = Math.min(this.length(), count);\n        rval = this.data.slice(this.read, this.read + count);\n        this.read += count;\n    } else if (count === 0) {\n        rval = \"\";\n    } else {\n        // read all bytes, optimize to only copy when needed\n        rval = this.read === 0 ? this.data : this.data.slice(this.read);\n        this.clear();\n    }\n    return rval;\n};\n/**\n * Gets a binary encoded string of the bytes from this buffer without\n * modifying the read pointer.\n *\n * @param count the number of bytes to get, omit to get all.\n *\n * @return a string full of binary encoded characters.\n */ util.ByteStringBuffer.prototype.bytes = function(count) {\n    return typeof count === \"undefined\" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);\n};\n/**\n * Gets a byte at the given index without modifying the read pointer.\n *\n * @param i the byte index.\n *\n * @return the byte.\n */ util.ByteStringBuffer.prototype.at = function(i) {\n    return this.data.charCodeAt(this.read + i);\n};\n/**\n * Puts a byte at the given index without modifying the read pointer.\n *\n * @param i the byte index.\n * @param b the byte to put.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.setAt = function(i, b) {\n    this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);\n    return this;\n};\n/**\n * Gets the last byte without modifying the read pointer.\n *\n * @return the last byte.\n */ util.ByteStringBuffer.prototype.last = function() {\n    return this.data.charCodeAt(this.data.length - 1);\n};\n/**\n * Creates a copy of this buffer.\n *\n * @return the copy.\n */ util.ByteStringBuffer.prototype.copy = function() {\n    var c = util.createBuffer(this.data);\n    c.read = this.read;\n    return c;\n};\n/**\n * Compacts this buffer.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.compact = function() {\n    if (this.read > 0) {\n        this.data = this.data.slice(this.read);\n        this.read = 0;\n    }\n    return this;\n};\n/**\n * Clears this buffer.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.clear = function() {\n    this.data = \"\";\n    this.read = 0;\n    return this;\n};\n/**\n * Shortens this buffer by triming bytes off of the end of this buffer.\n *\n * @param count the number of bytes to trim off.\n *\n * @return this buffer.\n */ util.ByteStringBuffer.prototype.truncate = function(count) {\n    var len = Math.max(0, this.length() - count);\n    this.data = this.data.substr(this.read, len);\n    this.read = 0;\n    return this;\n};\n/**\n * Converts this buffer to a hexadecimal string.\n *\n * @return a hexadecimal string.\n */ util.ByteStringBuffer.prototype.toHex = function() {\n    var rval = \"\";\n    for(var i = this.read; i < this.data.length; ++i){\n        var b = this.data.charCodeAt(i);\n        if (b < 16) {\n            rval += \"0\";\n        }\n        rval += b.toString(16);\n    }\n    return rval;\n};\n/**\n * Converts this buffer to a UTF-16 string (standard JavaScript string).\n *\n * @return a UTF-16 string.\n */ util.ByteStringBuffer.prototype.toString = function() {\n    return util.decodeUtf8(this.bytes());\n};\n/** End Buffer w/BinaryString backing */ /** Buffer w/UInt8Array backing */ /**\n * FIXME: Experimental. Do not use yet.\n *\n * Constructor for an ArrayBuffer-backed byte buffer.\n *\n * The buffer may be constructed from a string, an ArrayBuffer, DataView, or a\n * TypedArray.\n *\n * If a string is given, its encoding should be provided as an option,\n * otherwise it will default to 'binary'. A 'binary' string is encoded such\n * that each character is one byte in length and size.\n *\n * If an ArrayBuffer, DataView, or TypedArray is given, it will be used\n * *directly* without any copying. Note that, if a write to the buffer requires\n * more space, the buffer will allocate a new backing ArrayBuffer to\n * accommodate. The starting read and write offsets for the buffer may be\n * given as options.\n *\n * @param [b] the initial bytes for this buffer.\n * @param options the options to use:\n *          [readOffset] the starting read offset to use (default: 0).\n *          [writeOffset] the starting write offset to use (default: the\n *            length of the first parameter).\n *          [growSize] the minimum amount, in bytes, to grow the buffer by to\n *            accommodate writes (default: 1024).\n *          [encoding] the encoding ('binary', 'utf8', 'utf16', 'hex') for the\n *            first parameter, if it is a string (default: 'binary').\n */ function DataBuffer(b, options) {\n    // default options\n    options = options || {};\n    // pointers for read from/write to buffer\n    this.read = options.readOffset || 0;\n    this.growSize = options.growSize || 1024;\n    var isArrayBuffer = util.isArrayBuffer(b);\n    var isArrayBufferView = util.isArrayBufferView(b);\n    if (isArrayBuffer || isArrayBufferView) {\n        // use ArrayBuffer directly\n        if (isArrayBuffer) {\n            this.data = new DataView(b);\n        } else {\n            // TODO: adjust read/write offset based on the type of view\n            // or specify that this must be done in the options ... that the\n            // offsets are byte-based\n            this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);\n        }\n        this.write = \"writeOffset\" in options ? options.writeOffset : this.data.byteLength;\n        return;\n    }\n    // initialize to empty array buffer and add any given bytes using putBytes\n    this.data = new DataView(new ArrayBuffer(0));\n    this.write = 0;\n    if (b !== null && b !== undefined) {\n        this.putBytes(b);\n    }\n    if (\"writeOffset\" in options) {\n        this.write = options.writeOffset;\n    }\n}\nutil.DataBuffer = DataBuffer;\n/**\n * Gets the number of bytes in this buffer.\n *\n * @return the number of bytes in this buffer.\n */ util.DataBuffer.prototype.length = function() {\n    return this.write - this.read;\n};\n/**\n * Gets whether or not this buffer is empty.\n *\n * @return true if this buffer is empty, false if not.\n */ util.DataBuffer.prototype.isEmpty = function() {\n    return this.length() <= 0;\n};\n/**\n * Ensures this buffer has enough empty space to accommodate the given number\n * of bytes. An optional parameter may be given that indicates a minimum\n * amount to grow the buffer if necessary. If the parameter is not given,\n * the buffer will be grown by some previously-specified default amount\n * or heuristic.\n *\n * @param amount the number of bytes to accommodate.\n * @param [growSize] the minimum amount, in bytes, to grow the buffer by if\n *          necessary.\n */ util.DataBuffer.prototype.accommodate = function(amount, growSize) {\n    if (this.length() >= amount) {\n        return this;\n    }\n    growSize = Math.max(growSize || this.growSize, amount);\n    // grow buffer\n    var src = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);\n    var dst = new Uint8Array(this.length() + growSize);\n    dst.set(src);\n    this.data = new DataView(dst.buffer);\n    return this;\n};\n/**\n * Puts a byte in this buffer.\n *\n * @param b the byte to put.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putByte = function(b) {\n    this.accommodate(1);\n    this.data.setUint8(this.write++, b);\n    return this;\n};\n/**\n * Puts a byte in this buffer N times.\n *\n * @param b the byte to put.\n * @param n the number of bytes of value b to put.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.fillWithByte = function(b, n) {\n    this.accommodate(n);\n    for(var i = 0; i < n; ++i){\n        this.data.setUint8(b);\n    }\n    return this;\n};\n/**\n * Puts bytes in this buffer. The bytes may be given as a string, an\n * ArrayBuffer, a DataView, or a TypedArray.\n *\n * @param bytes the bytes to put.\n * @param [encoding] the encoding for the first parameter ('binary', 'utf8',\n *          'utf16', 'hex'), if it is a string (default: 'binary').\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putBytes = function(bytes, encoding) {\n    if (util.isArrayBufferView(bytes)) {\n        var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n        var len = src.byteLength - src.byteOffset;\n        this.accommodate(len);\n        var dst = new Uint8Array(this.data.buffer, this.write);\n        dst.set(src);\n        this.write += len;\n        return this;\n    }\n    if (util.isArrayBuffer(bytes)) {\n        var src = new Uint8Array(bytes);\n        this.accommodate(src.byteLength);\n        var dst = new Uint8Array(this.data.buffer);\n        dst.set(src, this.write);\n        this.write += src.byteLength;\n        return this;\n    }\n    // bytes is a util.DataBuffer or equivalent\n    if (bytes instanceof util.DataBuffer || typeof bytes === \"object\" && typeof bytes.read === \"number\" && typeof bytes.write === \"number\" && util.isArrayBufferView(bytes.data)) {\n        var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());\n        this.accommodate(src.byteLength);\n        var dst = new Uint8Array(bytes.data.byteLength, this.write);\n        dst.set(src);\n        this.write += src.byteLength;\n        return this;\n    }\n    if (bytes instanceof util.ByteStringBuffer) {\n        // copy binary string and process as the same as a string parameter below\n        bytes = bytes.data;\n        encoding = \"binary\";\n    }\n    // string conversion\n    encoding = encoding || \"binary\";\n    if (typeof bytes === \"string\") {\n        var view;\n        // decode from string\n        if (encoding === \"hex\") {\n            this.accommodate(Math.ceil(bytes.length / 2));\n            view = new Uint8Array(this.data.buffer, this.write);\n            this.write += util.binary.hex.decode(bytes, view, this.write);\n            return this;\n        }\n        if (encoding === \"base64\") {\n            this.accommodate(Math.ceil(bytes.length / 4) * 3);\n            view = new Uint8Array(this.data.buffer, this.write);\n            this.write += util.binary.base64.decode(bytes, view, this.write);\n            return this;\n        }\n        // encode text as UTF-8 bytes\n        if (encoding === \"utf8\") {\n            // encode as UTF-8 then decode string as raw binary\n            bytes = util.encodeUtf8(bytes);\n            encoding = \"binary\";\n        }\n        // decode string as raw binary\n        if (encoding === \"binary\" || encoding === \"raw\") {\n            // one byte per character\n            this.accommodate(bytes.length);\n            view = new Uint8Array(this.data.buffer, this.write);\n            this.write += util.binary.raw.decode(view);\n            return this;\n        }\n        // encode text as UTF-16 bytes\n        if (encoding === \"utf16\") {\n            // two bytes per character\n            this.accommodate(bytes.length * 2);\n            view = new Uint16Array(this.data.buffer, this.write);\n            this.write += util.text.utf16.encode(view);\n            return this;\n        }\n        throw new Error(\"Invalid encoding: \" + encoding);\n    }\n    throw Error(\"Invalid parameter: \" + bytes);\n};\n/**\n * Puts the given buffer into this buffer.\n *\n * @param buffer the buffer to put into this one.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putBuffer = function(buffer) {\n    this.putBytes(buffer);\n    buffer.clear();\n    return this;\n};\n/**\n * Puts a string into this buffer.\n *\n * @param str the string to put.\n * @param [encoding] the encoding for the string (default: 'utf16').\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putString = function(str) {\n    return this.putBytes(str, \"utf16\");\n};\n/**\n * Puts a 16-bit integer in this buffer in big-endian order.\n *\n * @param i the 16-bit integer.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putInt16 = function(i) {\n    this.accommodate(2);\n    this.data.setInt16(this.write, i);\n    this.write += 2;\n    return this;\n};\n/**\n * Puts a 24-bit integer in this buffer in big-endian order.\n *\n * @param i the 24-bit integer.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putInt24 = function(i) {\n    this.accommodate(3);\n    this.data.setInt16(this.write, i >> 8 & 0xFFFF);\n    this.data.setInt8(this.write, i >> 16 & 0xFF);\n    this.write += 3;\n    return this;\n};\n/**\n * Puts a 32-bit integer in this buffer in big-endian order.\n *\n * @param i the 32-bit integer.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putInt32 = function(i) {\n    this.accommodate(4);\n    this.data.setInt32(this.write, i);\n    this.write += 4;\n    return this;\n};\n/**\n * Puts a 16-bit integer in this buffer in little-endian order.\n *\n * @param i the 16-bit integer.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putInt16Le = function(i) {\n    this.accommodate(2);\n    this.data.setInt16(this.write, i, true);\n    this.write += 2;\n    return this;\n};\n/**\n * Puts a 24-bit integer in this buffer in little-endian order.\n *\n * @param i the 24-bit integer.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putInt24Le = function(i) {\n    this.accommodate(3);\n    this.data.setInt8(this.write, i >> 16 & 0xFF);\n    this.data.setInt16(this.write, i >> 8 & 0xFFFF, true);\n    this.write += 3;\n    return this;\n};\n/**\n * Puts a 32-bit integer in this buffer in little-endian order.\n *\n * @param i the 32-bit integer.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putInt32Le = function(i) {\n    this.accommodate(4);\n    this.data.setInt32(this.write, i, true);\n    this.write += 4;\n    return this;\n};\n/**\n * Puts an n-bit integer in this buffer in big-endian order.\n *\n * @param i the n-bit integer.\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putInt = function(i, n) {\n    _checkBitsParam(n);\n    this.accommodate(n / 8);\n    do {\n        n -= 8;\n        this.data.setInt8(this.write++, i >> n & 0xFF);\n    }while (n > 0);\n    return this;\n};\n/**\n * Puts a signed n-bit integer in this buffer in big-endian order. Two's\n * complement representation is used.\n *\n * @param i the n-bit integer.\n * @param n the number of bits in the integer.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.putSignedInt = function(i, n) {\n    _checkBitsParam(n);\n    this.accommodate(n / 8);\n    if (i < 0) {\n        i += 2 << n - 1;\n    }\n    return this.putInt(i, n);\n};\n/**\n * Gets a byte from this buffer and advances the read pointer by 1.\n *\n * @return the byte.\n */ util.DataBuffer.prototype.getByte = function() {\n    return this.data.getInt8(this.read++);\n};\n/**\n * Gets a uint16 from this buffer in big-endian order and advances the read\n * pointer by 2.\n *\n * @return the uint16.\n */ util.DataBuffer.prototype.getInt16 = function() {\n    var rval = this.data.getInt16(this.read);\n    this.read += 2;\n    return rval;\n};\n/**\n * Gets a uint24 from this buffer in big-endian order and advances the read\n * pointer by 3.\n *\n * @return the uint24.\n */ util.DataBuffer.prototype.getInt24 = function() {\n    var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);\n    this.read += 3;\n    return rval;\n};\n/**\n * Gets a uint32 from this buffer in big-endian order and advances the read\n * pointer by 4.\n *\n * @return the word.\n */ util.DataBuffer.prototype.getInt32 = function() {\n    var rval = this.data.getInt32(this.read);\n    this.read += 4;\n    return rval;\n};\n/**\n * Gets a uint16 from this buffer in little-endian order and advances the read\n * pointer by 2.\n *\n * @return the uint16.\n */ util.DataBuffer.prototype.getInt16Le = function() {\n    var rval = this.data.getInt16(this.read, true);\n    this.read += 2;\n    return rval;\n};\n/**\n * Gets a uint24 from this buffer in little-endian order and advances the read\n * pointer by 3.\n *\n * @return the uint24.\n */ util.DataBuffer.prototype.getInt24Le = function() {\n    var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;\n    this.read += 3;\n    return rval;\n};\n/**\n * Gets a uint32 from this buffer in little-endian order and advances the read\n * pointer by 4.\n *\n * @return the word.\n */ util.DataBuffer.prototype.getInt32Le = function() {\n    var rval = this.data.getInt32(this.read, true);\n    this.read += 4;\n    return rval;\n};\n/**\n * Gets an n-bit integer from this buffer in big-endian order and advances the\n * read pointer by n/8.\n *\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return the integer.\n */ util.DataBuffer.prototype.getInt = function(n) {\n    _checkBitsParam(n);\n    var rval = 0;\n    do {\n        // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.\n        rval = (rval << 8) + this.data.getInt8(this.read++);\n        n -= 8;\n    }while (n > 0);\n    return rval;\n};\n/**\n * Gets a signed n-bit integer from this buffer in big-endian order, using\n * two's complement, and advances the read pointer by n/8.\n *\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return the integer.\n */ util.DataBuffer.prototype.getSignedInt = function(n) {\n    // getInt checks n\n    var x = this.getInt(n);\n    var max = 2 << n - 2;\n    if (x >= max) {\n        x -= max << 1;\n    }\n    return x;\n};\n/**\n * Reads bytes out as a binary encoded string and clears them from the\n * buffer.\n *\n * @param count the number of bytes to read, undefined or null for all.\n *\n * @return a binary encoded string of bytes.\n */ util.DataBuffer.prototype.getBytes = function(count) {\n    // TODO: deprecate this method, it is poorly named and\n    // this.toString('binary') replaces it\n    // add a toTypedArray()/toArrayBuffer() function\n    var rval;\n    if (count) {\n        // read count bytes\n        count = Math.min(this.length(), count);\n        rval = this.data.slice(this.read, this.read + count);\n        this.read += count;\n    } else if (count === 0) {\n        rval = \"\";\n    } else {\n        // read all bytes, optimize to only copy when needed\n        rval = this.read === 0 ? this.data : this.data.slice(this.read);\n        this.clear();\n    }\n    return rval;\n};\n/**\n * Gets a binary encoded string of the bytes from this buffer without\n * modifying the read pointer.\n *\n * @param count the number of bytes to get, omit to get all.\n *\n * @return a string full of binary encoded characters.\n */ util.DataBuffer.prototype.bytes = function(count) {\n    // TODO: deprecate this method, it is poorly named, add \"getString()\"\n    return typeof count === \"undefined\" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);\n};\n/**\n * Gets a byte at the given index without modifying the read pointer.\n *\n * @param i the byte index.\n *\n * @return the byte.\n */ util.DataBuffer.prototype.at = function(i) {\n    return this.data.getUint8(this.read + i);\n};\n/**\n * Puts a byte at the given index without modifying the read pointer.\n *\n * @param i the byte index.\n * @param b the byte to put.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.setAt = function(i, b) {\n    this.data.setUint8(i, b);\n    return this;\n};\n/**\n * Gets the last byte without modifying the read pointer.\n *\n * @return the last byte.\n */ util.DataBuffer.prototype.last = function() {\n    return this.data.getUint8(this.write - 1);\n};\n/**\n * Creates a copy of this buffer.\n *\n * @return the copy.\n */ util.DataBuffer.prototype.copy = function() {\n    return new util.DataBuffer(this);\n};\n/**\n * Compacts this buffer.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.compact = function() {\n    if (this.read > 0) {\n        var src = new Uint8Array(this.data.buffer, this.read);\n        var dst = new Uint8Array(src.byteLength);\n        dst.set(src);\n        this.data = new DataView(dst);\n        this.write -= this.read;\n        this.read = 0;\n    }\n    return this;\n};\n/**\n * Clears this buffer.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.clear = function() {\n    this.data = new DataView(new ArrayBuffer(0));\n    this.read = this.write = 0;\n    return this;\n};\n/**\n * Shortens this buffer by triming bytes off of the end of this buffer.\n *\n * @param count the number of bytes to trim off.\n *\n * @return this buffer.\n */ util.DataBuffer.prototype.truncate = function(count) {\n    this.write = Math.max(0, this.length() - count);\n    this.read = Math.min(this.read, this.write);\n    return this;\n};\n/**\n * Converts this buffer to a hexadecimal string.\n *\n * @return a hexadecimal string.\n */ util.DataBuffer.prototype.toHex = function() {\n    var rval = \"\";\n    for(var i = this.read; i < this.data.byteLength; ++i){\n        var b = this.data.getUint8(i);\n        if (b < 16) {\n            rval += \"0\";\n        }\n        rval += b.toString(16);\n    }\n    return rval;\n};\n/**\n * Converts this buffer to a string, using the given encoding. If no\n * encoding is given, 'utf8' (UTF-8) is used.\n *\n * @param [encoding] the encoding to use: 'binary', 'utf8', 'utf16', 'hex',\n *          'base64' (default: 'utf8').\n *\n * @return a string representation of the bytes in this buffer.\n */ util.DataBuffer.prototype.toString = function(encoding) {\n    var view = new Uint8Array(this.data, this.read, this.length());\n    encoding = encoding || \"utf8\";\n    // encode to string\n    if (encoding === \"binary\" || encoding === \"raw\") {\n        return util.binary.raw.encode(view);\n    }\n    if (encoding === \"hex\") {\n        return util.binary.hex.encode(view);\n    }\n    if (encoding === \"base64\") {\n        return util.binary.base64.encode(view);\n    }\n    // decode to text\n    if (encoding === \"utf8\") {\n        return util.text.utf8.decode(view);\n    }\n    if (encoding === \"utf16\") {\n        return util.text.utf16.decode(view);\n    }\n    throw new Error(\"Invalid encoding: \" + encoding);\n};\n/** End Buffer w/UInt8Array backing */ /**\n * Creates a buffer that stores bytes. A value may be given to populate the\n * buffer with data. This value can either be string of encoded bytes or a\n * regular string of characters. When passing a string of binary encoded\n * bytes, the encoding `raw` should be given. This is also the default. When\n * passing a string of characters, the encoding `utf8` should be given.\n *\n * @param [input] a string with encoded bytes to store in the buffer.\n * @param [encoding] (default: 'raw', other: 'utf8').\n */ util.createBuffer = function(input, encoding) {\n    // TODO: deprecate, use new ByteBuffer() instead\n    encoding = encoding || \"raw\";\n    if (input !== undefined && encoding === \"utf8\") {\n        input = util.encodeUtf8(input);\n    }\n    return new util.ByteBuffer(input);\n};\n/**\n * Fills a string with a particular value. If you want the string to be a byte\n * string, pass in String.fromCharCode(theByte).\n *\n * @param c the character to fill the string with, use String.fromCharCode\n *          to fill the string with a byte value.\n * @param n the number of characters of value c to fill with.\n *\n * @return the filled string.\n */ util.fillString = function(c, n) {\n    var s = \"\";\n    while(n > 0){\n        if (n & 1) {\n            s += c;\n        }\n        n >>>= 1;\n        if (n > 0) {\n            c += c;\n        }\n    }\n    return s;\n};\n/**\n * Performs a per byte XOR between two byte strings and returns the result as a\n * string of bytes.\n *\n * @param s1 first string of bytes.\n * @param s2 second string of bytes.\n * @param n the number of bytes to XOR.\n *\n * @return the XOR'd result.\n */ util.xorBytes = function(s1, s2, n) {\n    var s3 = \"\";\n    var b = \"\";\n    var t = \"\";\n    var i = 0;\n    var c = 0;\n    for(; n > 0; --n, ++i){\n        b = s1.charCodeAt(i) ^ s2.charCodeAt(i);\n        if (c >= 10) {\n            s3 += t;\n            t = \"\";\n            c = 0;\n        }\n        t += String.fromCharCode(b);\n        ++c;\n    }\n    s3 += t;\n    return s3;\n};\n/**\n * Converts a hex string into a 'binary' encoded string of bytes.\n *\n * @param hex the hexadecimal string to convert.\n *\n * @return the binary-encoded string of bytes.\n */ util.hexToBytes = function(hex) {\n    // TODO: deprecate: \"Deprecated. Use util.binary.hex.decode instead.\"\n    var rval = \"\";\n    var i = 0;\n    if (hex.length & 1 == 1) {\n        // odd number of characters, convert first character alone\n        i = 1;\n        rval += String.fromCharCode(parseInt(hex[0], 16));\n    }\n    // convert 2 characters (1 byte) at a time\n    for(; i < hex.length; i += 2){\n        rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));\n    }\n    return rval;\n};\n/**\n * Converts a 'binary' encoded string of bytes to hex.\n *\n * @param bytes the byte string to convert.\n *\n * @return the string of hexadecimal characters.\n */ util.bytesToHex = function(bytes) {\n    // TODO: deprecate: \"Deprecated. Use util.binary.hex.encode instead.\"\n    return util.createBuffer(bytes).toHex();\n};\n/**\n * Converts an 32-bit integer to 4-big-endian byte string.\n *\n * @param i the integer.\n *\n * @return the byte string.\n */ util.int32ToBytes = function(i) {\n    return String.fromCharCode(i >> 24 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF);\n};\n// base64 characters, reverse mapping\nvar _base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nvar _base64Idx = [\n    /*43 -43 = 0*/ /*'+',  1,  2,  3,'/' */ 62,\n    -1,\n    -1,\n    -1,\n    63,\n    /*'0','1','2','3','4','5','6','7','8','9' */ 52,\n    53,\n    54,\n    55,\n    56,\n    57,\n    58,\n    59,\n    60,\n    61,\n    /*15, 16, 17,'=', 19, 20, 21 */ -1,\n    -1,\n    -1,\n    64,\n    -1,\n    -1,\n    -1,\n    /*65 - 43 = 22*/ /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */ 0,\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    10,\n    11,\n    12,\n    /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */ 13,\n    14,\n    15,\n    16,\n    17,\n    18,\n    19,\n    20,\n    21,\n    22,\n    23,\n    24,\n    25,\n    /*91 - 43 = 48 */ /*48, 49, 50, 51, 52, 53 */ -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    /*97 - 43 = 54*/ /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */ 26,\n    27,\n    28,\n    29,\n    30,\n    31,\n    32,\n    33,\n    34,\n    35,\n    36,\n    37,\n    38,\n    /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */ 39,\n    40,\n    41,\n    42,\n    43,\n    44,\n    45,\n    46,\n    47,\n    48,\n    49,\n    50,\n    51\n];\n// base58 characters (Bitcoin alphabet)\nvar _base58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n/**\n * Base64 encodes a 'binary' encoded string of bytes.\n *\n * @param input the binary encoded string of bytes to base64-encode.\n * @param maxline the maximum number of encoded characters per line to use,\n *          defaults to none.\n *\n * @return the base64-encoded output.\n */ util.encode64 = function(input, maxline) {\n    // TODO: deprecate: \"Deprecated. Use util.binary.base64.encode instead.\"\n    var line = \"\";\n    var output = \"\";\n    var chr1, chr2, chr3;\n    var i = 0;\n    while(i < input.length){\n        chr1 = input.charCodeAt(i++);\n        chr2 = input.charCodeAt(i++);\n        chr3 = input.charCodeAt(i++);\n        // encode 4 character group\n        line += _base64.charAt(chr1 >> 2);\n        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);\n        if (isNaN(chr2)) {\n            line += \"==\";\n        } else {\n            line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);\n            line += isNaN(chr3) ? \"=\" : _base64.charAt(chr3 & 63);\n        }\n        if (maxline && line.length > maxline) {\n            output += line.substr(0, maxline) + \"\\r\\n\";\n            line = line.substr(maxline);\n        }\n    }\n    output += line;\n    return output;\n};\n/**\n * Base64 decodes a string into a 'binary' encoded string of bytes.\n *\n * @param input the base64-encoded input.\n *\n * @return the binary encoded string.\n */ util.decode64 = function(input) {\n    // TODO: deprecate: \"Deprecated. Use util.binary.base64.decode instead.\"\n    // remove all non-base64 characters\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n    var output = \"\";\n    var enc1, enc2, enc3, enc4;\n    var i = 0;\n    while(i < input.length){\n        enc1 = _base64Idx[input.charCodeAt(i++) - 43];\n        enc2 = _base64Idx[input.charCodeAt(i++) - 43];\n        enc3 = _base64Idx[input.charCodeAt(i++) - 43];\n        enc4 = _base64Idx[input.charCodeAt(i++) - 43];\n        output += String.fromCharCode(enc1 << 2 | enc2 >> 4);\n        if (enc3 !== 64) {\n            // decoded at least 2 bytes\n            output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);\n            if (enc4 !== 64) {\n                // decoded 3 bytes\n                output += String.fromCharCode((enc3 & 3) << 6 | enc4);\n            }\n        }\n    }\n    return output;\n};\n/**\n * Encodes the given string of characters (a standard JavaScript\n * string) as a binary encoded string where the bytes represent\n * a UTF-8 encoded string of characters. Non-ASCII characters will be\n * encoded as multiple bytes according to UTF-8.\n *\n * @param str a standard string of characters to encode.\n *\n * @return the binary encoded string.\n */ util.encodeUtf8 = function(str) {\n    return unescape(encodeURIComponent(str));\n};\n/**\n * Decodes a binary encoded string that contains bytes that\n * represent a UTF-8 encoded string of characters -- into a\n * string of characters (a standard JavaScript string).\n *\n * @param str the binary encoded string to decode.\n *\n * @return the resulting standard string of characters.\n */ util.decodeUtf8 = function(str) {\n    return decodeURIComponent(escape(str));\n};\n// binary encoding/decoding tools\n// FIXME: Experimental. Do not use yet.\nutil.binary = {\n    raw: {},\n    hex: {},\n    base64: {},\n    base58: {},\n    baseN: {\n        encode: baseN.encode,\n        decode: baseN.decode\n    }\n};\n/**\n * Encodes a Uint8Array as a binary-encoded string. This encoding uses\n * a value between 0 and 255 for each character.\n *\n * @param bytes the Uint8Array to encode.\n *\n * @return the binary-encoded string.\n */ util.binary.raw.encode = function(bytes) {\n    return String.fromCharCode.apply(null, bytes);\n};\n/**\n * Decodes a binary-encoded string to a Uint8Array. This encoding uses\n * a value between 0 and 255 for each character.\n *\n * @param str the binary-encoded string to decode.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */ util.binary.raw.decode = function(str, output, offset) {\n    var out = output;\n    if (!out) {\n        out = new Uint8Array(str.length);\n    }\n    offset = offset || 0;\n    var j = offset;\n    for(var i = 0; i < str.length; ++i){\n        out[j++] = str.charCodeAt(i);\n    }\n    return output ? j - offset : out;\n};\n/**\n * Encodes a 'binary' string, ArrayBuffer, DataView, TypedArray, or\n * ByteBuffer as a string of hexadecimal characters.\n *\n * @param bytes the bytes to convert.\n *\n * @return the string of hexadecimal characters.\n */ util.binary.hex.encode = util.bytesToHex;\n/**\n * Decodes a hex-encoded string to a Uint8Array.\n *\n * @param hex the hexadecimal string to convert.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */ util.binary.hex.decode = function(hex, output, offset) {\n    var out = output;\n    if (!out) {\n        out = new Uint8Array(Math.ceil(hex.length / 2));\n    }\n    offset = offset || 0;\n    var i = 0, j = offset;\n    if (hex.length & 1) {\n        // odd number of characters, convert first character alone\n        i = 1;\n        out[j++] = parseInt(hex[0], 16);\n    }\n    // convert 2 characters (1 byte) at a time\n    for(; i < hex.length; i += 2){\n        out[j++] = parseInt(hex.substr(i, 2), 16);\n    }\n    return output ? j - offset : out;\n};\n/**\n * Base64-encodes a Uint8Array.\n *\n * @param input the Uint8Array to encode.\n * @param maxline the maximum number of encoded characters per line to use,\n *          defaults to none.\n *\n * @return the base64-encoded output string.\n */ util.binary.base64.encode = function(input, maxline) {\n    var line = \"\";\n    var output = \"\";\n    var chr1, chr2, chr3;\n    var i = 0;\n    while(i < input.byteLength){\n        chr1 = input[i++];\n        chr2 = input[i++];\n        chr3 = input[i++];\n        // encode 4 character group\n        line += _base64.charAt(chr1 >> 2);\n        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);\n        if (isNaN(chr2)) {\n            line += \"==\";\n        } else {\n            line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);\n            line += isNaN(chr3) ? \"=\" : _base64.charAt(chr3 & 63);\n        }\n        if (maxline && line.length > maxline) {\n            output += line.substr(0, maxline) + \"\\r\\n\";\n            line = line.substr(maxline);\n        }\n    }\n    output += line;\n    return output;\n};\n/**\n * Decodes a base64-encoded string to a Uint8Array.\n *\n * @param input the base64-encoded input string.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */ util.binary.base64.decode = function(input, output, offset) {\n    var out = output;\n    if (!out) {\n        out = new Uint8Array(Math.ceil(input.length / 4) * 3);\n    }\n    // remove all non-base64 characters\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n    offset = offset || 0;\n    var enc1, enc2, enc3, enc4;\n    var i = 0, j = offset;\n    while(i < input.length){\n        enc1 = _base64Idx[input.charCodeAt(i++) - 43];\n        enc2 = _base64Idx[input.charCodeAt(i++) - 43];\n        enc3 = _base64Idx[input.charCodeAt(i++) - 43];\n        enc4 = _base64Idx[input.charCodeAt(i++) - 43];\n        out[j++] = enc1 << 2 | enc2 >> 4;\n        if (enc3 !== 64) {\n            // decoded at least 2 bytes\n            out[j++] = (enc2 & 15) << 4 | enc3 >> 2;\n            if (enc4 !== 64) {\n                // decoded 3 bytes\n                out[j++] = (enc3 & 3) << 6 | enc4;\n            }\n        }\n    }\n    // make sure result is the exact decoded length\n    return output ? j - offset : out.subarray(0, j);\n};\n// add support for base58 encoding/decoding with Bitcoin alphabet\nutil.binary.base58.encode = function(input, maxline) {\n    return util.binary.baseN.encode(input, _base58, maxline);\n};\nutil.binary.base58.decode = function(input, maxline) {\n    return util.binary.baseN.decode(input, _base58, maxline);\n};\n// text encoding/decoding tools\n// FIXME: Experimental. Do not use yet.\nutil.text = {\n    utf8: {},\n    utf16: {}\n};\n/**\n * Encodes the given string as UTF-8 in a Uint8Array.\n *\n * @param str the string to encode.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */ util.text.utf8.encode = function(str, output, offset) {\n    str = util.encodeUtf8(str);\n    var out = output;\n    if (!out) {\n        out = new Uint8Array(str.length);\n    }\n    offset = offset || 0;\n    var j = offset;\n    for(var i = 0; i < str.length; ++i){\n        out[j++] = str.charCodeAt(i);\n    }\n    return output ? j - offset : out;\n};\n/**\n * Decodes the UTF-8 contents from a Uint8Array.\n *\n * @param bytes the Uint8Array to decode.\n *\n * @return the resulting string.\n */ util.text.utf8.decode = function(bytes) {\n    return util.decodeUtf8(String.fromCharCode.apply(null, bytes));\n};\n/**\n * Encodes the given string as UTF-16 in a Uint8Array.\n *\n * @param str the string to encode.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */ util.text.utf16.encode = function(str, output, offset) {\n    var out = output;\n    if (!out) {\n        out = new Uint8Array(str.length * 2);\n    }\n    var view = new Uint16Array(out.buffer);\n    offset = offset || 0;\n    var j = offset;\n    var k = offset;\n    for(var i = 0; i < str.length; ++i){\n        view[k++] = str.charCodeAt(i);\n        j += 2;\n    }\n    return output ? j - offset : out;\n};\n/**\n * Decodes the UTF-16 contents from a Uint8Array.\n *\n * @param bytes the Uint8Array to decode.\n *\n * @return the resulting string.\n */ util.text.utf16.decode = function(bytes) {\n    return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));\n};\n/**\n * Deflates the given data using a flash interface.\n *\n * @param api the flash interface.\n * @param bytes the data.\n * @param raw true to return only raw deflate data, false to include zlib\n *          header and trailer.\n *\n * @return the deflated data as a string.\n */ util.deflate = function(api, bytes, raw) {\n    bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);\n    // strip zlib header and trailer if necessary\n    if (raw) {\n        // zlib header is 2 bytes (CMF,FLG) where FLG indicates that\n        // there is a 4-byte DICT (alder-32) block before the data if\n        // its 5th bit is set\n        var start = 2;\n        var flg = bytes.charCodeAt(1);\n        if (flg & 0x20) {\n            start = 6;\n        }\n        // zlib trailer is 4 bytes of adler-32\n        bytes = bytes.substring(start, bytes.length - 4);\n    }\n    return bytes;\n};\n/**\n * Inflates the given data using a flash interface.\n *\n * @param api the flash interface.\n * @param bytes the data.\n * @param raw true if the incoming data has no zlib header or trailer and is\n *          raw DEFLATE data.\n *\n * @return the inflated data as a string, null on error.\n */ util.inflate = function(api, bytes, raw) {\n    // TODO: add zlib header and trailer if necessary/possible\n    var rval = api.inflate(util.encode64(bytes)).rval;\n    return rval === null ? null : util.decode64(rval);\n};\n/**\n * Sets a storage object.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n * @param obj the storage object, null to remove.\n */ var _setStorageObject = function(api, id, obj) {\n    if (!api) {\n        throw new Error(\"WebStorage not available.\");\n    }\n    var rval;\n    if (obj === null) {\n        rval = api.removeItem(id);\n    } else {\n        // json-encode and base64-encode object\n        obj = util.encode64(JSON.stringify(obj));\n        rval = api.setItem(id, obj);\n    }\n    // handle potential flash error\n    if (typeof rval !== \"undefined\" && rval.rval !== true) {\n        var error = new Error(rval.error.message);\n        error.id = rval.error.id;\n        error.name = rval.error.name;\n        throw error;\n    }\n};\n/**\n * Gets a storage object.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n *\n * @return the storage object entry or null if none exists.\n */ var _getStorageObject = function(api, id) {\n    if (!api) {\n        throw new Error(\"WebStorage not available.\");\n    }\n    // get the existing entry\n    var rval = api.getItem(id);\n    /* Note: We check api.init because we can't do (api == localStorage)\n    on IE because of \"Class doesn't support Automation\" exception. Only\n    the flash api has an init method so this works too, but we need a\n    better solution in the future. */ // flash returns item wrapped in an object, handle special case\n    if (api.init) {\n        if (rval.rval === null) {\n            if (rval.error) {\n                var error = new Error(rval.error.message);\n                error.id = rval.error.id;\n                error.name = rval.error.name;\n                throw error;\n            }\n            // no error, but also no item\n            rval = null;\n        } else {\n            rval = rval.rval;\n        }\n    }\n    // handle decoding\n    if (rval !== null) {\n        // base64-decode and json-decode data\n        rval = JSON.parse(util.decode64(rval));\n    }\n    return rval;\n};\n/**\n * Stores an item in local storage.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n * @param key the key for the item.\n * @param data the data for the item (any javascript object/primitive).\n */ var _setItem = function(api, id, key, data) {\n    // get storage object\n    var obj = _getStorageObject(api, id);\n    if (obj === null) {\n        // create a new storage object\n        obj = {};\n    }\n    // update key\n    obj[key] = data;\n    // set storage object\n    _setStorageObject(api, id, obj);\n};\n/**\n * Gets an item from local storage.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n * @param key the key for the item.\n *\n * @return the item.\n */ var _getItem = function(api, id, key) {\n    // get storage object\n    var rval = _getStorageObject(api, id);\n    if (rval !== null) {\n        // return data at key\n        rval = key in rval ? rval[key] : null;\n    }\n    return rval;\n};\n/**\n * Removes an item from local storage.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n * @param key the key for the item.\n */ var _removeItem = function(api, id, key) {\n    // get storage object\n    var obj = _getStorageObject(api, id);\n    if (obj !== null && key in obj) {\n        // remove key\n        delete obj[key];\n        // see if entry has no keys remaining\n        var empty = true;\n        for(var prop in obj){\n            empty = false;\n            break;\n        }\n        if (empty) {\n            // remove entry entirely if no keys are left\n            obj = null;\n        }\n        // set storage object\n        _setStorageObject(api, id, obj);\n    }\n};\n/**\n * Clears the local disk storage identified by the given ID.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n */ var _clearItems = function(api, id) {\n    _setStorageObject(api, id, null);\n};\n/**\n * Calls a storage function.\n *\n * @param func the function to call.\n * @param args the arguments for the function.\n * @param location the location argument.\n *\n * @return the return value from the function.\n */ var _callStorageFunction = function(func, args, location) {\n    var rval = null;\n    // default storage types\n    if (typeof location === \"undefined\") {\n        location = [\n            \"web\",\n            \"flash\"\n        ];\n    }\n    // apply storage types in order of preference\n    var type;\n    var done = false;\n    var exception = null;\n    for(var idx in location){\n        type = location[idx];\n        try {\n            if (type === \"flash\" || type === \"both\") {\n                if (args[0] === null) {\n                    throw new Error(\"Flash local storage not available.\");\n                }\n                rval = func.apply(this, args);\n                done = type === \"flash\";\n            }\n            if (type === \"web\" || type === \"both\") {\n                args[0] = localStorage;\n                rval = func.apply(this, args);\n                done = true;\n            }\n        } catch (ex) {\n            exception = ex;\n        }\n        if (done) {\n            break;\n        }\n    }\n    if (!done) {\n        throw exception;\n    }\n    return rval;\n};\n/**\n * Stores an item on local disk.\n *\n * The available types of local storage include 'flash', 'web', and 'both'.\n *\n * The type 'flash' refers to flash local storage (SharedObject). In order\n * to use flash local storage, the 'api' parameter must be valid. The type\n * 'web' refers to WebStorage, if supported by the browser. The type 'both'\n * refers to storing using both 'flash' and 'web', not just one or the\n * other.\n *\n * The location array should list the storage types to use in order of\n * preference:\n *\n * ['flash']: flash only storage\n * ['web']: web only storage\n * ['both']: try to store in both\n * ['flash','web']: store in flash first, but if not available, 'web'\n * ['web','flash']: store in web first, but if not available, 'flash'\n *\n * The location array defaults to: ['web', 'flash']\n *\n * @param api the flash interface, null to use only WebStorage.\n * @param id the storage ID to use.\n * @param key the key for the item.\n * @param data the data for the item (any javascript object/primitive).\n * @param location an array with the preferred types of storage to use.\n */ util.setItem = function(api, id, key, data, location) {\n    _callStorageFunction(_setItem, arguments, location);\n};\n/**\n * Gets an item on local disk.\n *\n * Set setItem() for details on storage types.\n *\n * @param api the flash interface, null to use only WebStorage.\n * @param id the storage ID to use.\n * @param key the key for the item.\n * @param location an array with the preferred types of storage to use.\n *\n * @return the item.\n */ util.getItem = function(api, id, key, location) {\n    return _callStorageFunction(_getItem, arguments, location);\n};\n/**\n * Removes an item on local disk.\n *\n * Set setItem() for details on storage types.\n *\n * @param api the flash interface.\n * @param id the storage ID to use.\n * @param key the key for the item.\n * @param location an array with the preferred types of storage to use.\n */ util.removeItem = function(api, id, key, location) {\n    _callStorageFunction(_removeItem, arguments, location);\n};\n/**\n * Clears the local disk storage identified by the given ID.\n *\n * Set setItem() for details on storage types.\n *\n * @param api the flash interface if flash is available.\n * @param id the storage ID to use.\n * @param location an array with the preferred types of storage to use.\n */ util.clearItems = function(api, id, location) {\n    _callStorageFunction(_clearItems, arguments, location);\n};\n/**\n * Check if an object is empty.\n *\n * Taken from:\n * http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937\n *\n * @param object the object to check.\n */ util.isEmpty = function(obj) {\n    for(var prop in obj){\n        if (obj.hasOwnProperty(prop)) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Format with simple printf-style interpolation.\n *\n * %%: literal '%'\n * %s,%o: convert next argument into a string.\n *\n * @param format the string to format.\n * @param ... arguments to interpolate into the format string.\n */ util.format = function(format) {\n    var re = /%./g;\n    // current match\n    var match;\n    // current part\n    var part;\n    // current arg index\n    var argi = 0;\n    // collected parts to recombine later\n    var parts = [];\n    // last index found\n    var last = 0;\n    // loop while matches remain\n    while(match = re.exec(format)){\n        part = format.substring(last, re.lastIndex - 2);\n        // don't add empty strings (ie, parts between %s%s)\n        if (part.length > 0) {\n            parts.push(part);\n        }\n        last = re.lastIndex;\n        // switch on % code\n        var code = match[0][1];\n        switch(code){\n            case \"s\":\n            case \"o\":\n                // check if enough arguments were given\n                if (argi < arguments.length) {\n                    parts.push(arguments[argi++ + 1]);\n                } else {\n                    parts.push(\"<?>\");\n                }\n                break;\n            // FIXME: do proper formating for numbers, etc\n            //case 'f':\n            //case 'd':\n            case \"%\":\n                parts.push(\"%\");\n                break;\n            default:\n                parts.push(\"<%\" + code + \"?>\");\n        }\n    }\n    // add trailing part of format string\n    parts.push(format.substring(last));\n    return parts.join(\"\");\n};\n/**\n * Formats a number.\n *\n * http://snipplr.com/view/5945/javascript-numberformat--ported-from-php/\n */ util.formatNumber = function(number, decimals, dec_point, thousands_sep) {\n    // http://kevin.vanzonneveld.net\n    // +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n    // +     bugfix by: Michael White (http://crestidg.com)\n    // +     bugfix by: Benjamin Lupton\n    // +     bugfix by: Allan Jensen (http://www.winternet.no)\n    // +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\n    // *     example 1: number_format(1234.5678, 2, '.', '');\n    // *     returns 1: 1234.57\n    var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;\n    var d = dec_point === undefined ? \",\" : dec_point;\n    var t = thousands_sep === undefined ? \".\" : thousands_sep, s = n < 0 ? \"-\" : \"\";\n    var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + \"\";\n    var j = i.length > 3 ? i.length % 3 : 0;\n    return s + (j ? i.substr(0, j) + t : \"\") + i.substr(j).replace(/(\\d{3})(?=\\d)/g, \"$1\" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : \"\");\n};\n/**\n * Formats a byte size.\n *\n * http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/\n */ util.formatSize = function(size) {\n    if (size >= 1073741824) {\n        size = util.formatNumber(size / 1073741824, 2, \".\", \"\") + \" GiB\";\n    } else if (size >= 1048576) {\n        size = util.formatNumber(size / 1048576, 2, \".\", \"\") + \" MiB\";\n    } else if (size >= 1024) {\n        size = util.formatNumber(size / 1024, 0) + \" KiB\";\n    } else {\n        size = util.formatNumber(size, 0) + \" bytes\";\n    }\n    return size;\n};\n/**\n * Converts an IPv4 or IPv6 string representation into bytes (in network order).\n *\n * @param ip the IPv4 or IPv6 address to convert.\n *\n * @return the 4-byte IPv6 or 16-byte IPv6 address or null if the address can't\n *         be parsed.\n */ util.bytesFromIP = function(ip) {\n    if (ip.indexOf(\".\") !== -1) {\n        return util.bytesFromIPv4(ip);\n    }\n    if (ip.indexOf(\":\") !== -1) {\n        return util.bytesFromIPv6(ip);\n    }\n    return null;\n};\n/**\n * Converts an IPv4 string representation into bytes (in network order).\n *\n * @param ip the IPv4 address to convert.\n *\n * @return the 4-byte address or null if the address can't be parsed.\n */ util.bytesFromIPv4 = function(ip) {\n    ip = ip.split(\".\");\n    if (ip.length !== 4) {\n        return null;\n    }\n    var b = util.createBuffer();\n    for(var i = 0; i < ip.length; ++i){\n        var num = parseInt(ip[i], 10);\n        if (isNaN(num)) {\n            return null;\n        }\n        b.putByte(num);\n    }\n    return b.getBytes();\n};\n/**\n * Converts an IPv6 string representation into bytes (in network order).\n *\n * @param ip the IPv6 address to convert.\n *\n * @return the 16-byte address or null if the address can't be parsed.\n */ util.bytesFromIPv6 = function(ip) {\n    var blanks = 0;\n    ip = ip.split(\":\").filter(function(e) {\n        if (e.length === 0) ++blanks;\n        return true;\n    });\n    var zeros = (8 - ip.length + blanks) * 2;\n    var b = util.createBuffer();\n    for(var i = 0; i < 8; ++i){\n        if (!ip[i] || ip[i].length === 0) {\n            b.fillWithByte(0, zeros);\n            zeros = 0;\n            continue;\n        }\n        var bytes = util.hexToBytes(ip[i]);\n        if (bytes.length < 2) {\n            b.putByte(0);\n        }\n        b.putBytes(bytes);\n    }\n    return b.getBytes();\n};\n/**\n * Converts 4-bytes into an IPv4 string representation or 16-bytes into\n * an IPv6 string representation. The bytes must be in network order.\n *\n * @param bytes the bytes to convert.\n *\n * @return the IPv4 or IPv6 string representation if 4 or 16 bytes,\n *         respectively, are given, otherwise null.\n */ util.bytesToIP = function(bytes) {\n    if (bytes.length === 4) {\n        return util.bytesToIPv4(bytes);\n    }\n    if (bytes.length === 16) {\n        return util.bytesToIPv6(bytes);\n    }\n    return null;\n};\n/**\n * Converts 4-bytes into an IPv4 string representation. The bytes must be\n * in network order.\n *\n * @param bytes the bytes to convert.\n *\n * @return the IPv4 string representation or null for an invalid # of bytes.\n */ util.bytesToIPv4 = function(bytes) {\n    if (bytes.length !== 4) {\n        return null;\n    }\n    var ip = [];\n    for(var i = 0; i < bytes.length; ++i){\n        ip.push(bytes.charCodeAt(i));\n    }\n    return ip.join(\".\");\n};\n/**\n * Converts 16-bytes into an IPv16 string representation. The bytes must be\n * in network order.\n *\n * @param bytes the bytes to convert.\n *\n * @return the IPv16 string representation or null for an invalid # of bytes.\n */ util.bytesToIPv6 = function(bytes) {\n    if (bytes.length !== 16) {\n        return null;\n    }\n    var ip = [];\n    var zeroGroups = [];\n    var zeroMaxGroup = 0;\n    for(var i = 0; i < bytes.length; i += 2){\n        var hex = util.bytesToHex(bytes[i] + bytes[i + 1]);\n        // canonicalize zero representation\n        while(hex[0] === \"0\" && hex !== \"0\"){\n            hex = hex.substr(1);\n        }\n        if (hex === \"0\") {\n            var last = zeroGroups[zeroGroups.length - 1];\n            var idx = ip.length;\n            if (!last || idx !== last.end + 1) {\n                zeroGroups.push({\n                    start: idx,\n                    end: idx\n                });\n            } else {\n                last.end = idx;\n                if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {\n                    zeroMaxGroup = zeroGroups.length - 1;\n                }\n            }\n        }\n        ip.push(hex);\n    }\n    if (zeroGroups.length > 0) {\n        var group = zeroGroups[zeroMaxGroup];\n        // only shorten group of length > 0\n        if (group.end - group.start > 0) {\n            ip.splice(group.start, group.end - group.start + 1, \"\");\n            if (group.start === 0) {\n                ip.unshift(\"\");\n            }\n            if (group.end === 7) {\n                ip.push(\"\");\n            }\n        }\n    }\n    return ip.join(\":\");\n};\n/**\n * Estimates the number of processes that can be run concurrently. If\n * creating Web Workers, keep in mind that the main JavaScript process needs\n * its own core.\n *\n * @param options the options to use:\n *          update true to force an update (not use the cached value).\n * @param callback(err, max) called once the operation completes.\n */ util.estimateCores = function(options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    options = options || {};\n    if (\"cores\" in util && !options.update) {\n        return callback(null, util.cores);\n    }\n    if (typeof navigator !== \"undefined\" && \"hardwareConcurrency\" in navigator && navigator.hardwareConcurrency > 0) {\n        util.cores = navigator.hardwareConcurrency;\n        return callback(null, util.cores);\n    }\n    if (typeof Worker === \"undefined\") {\n        // workers not available\n        util.cores = 1;\n        return callback(null, util.cores);\n    }\n    if (typeof Blob === \"undefined\") {\n        // can't estimate, default to 2\n        util.cores = 2;\n        return callback(null, util.cores);\n    }\n    // create worker concurrency estimation code as blob\n    var blobUrl = URL.createObjectURL(new Blob([\n        \"(\",\n        (function() {\n            self.addEventListener(\"message\", function(e) {\n                // run worker for 4 ms\n                var st = Date.now();\n                var et = st + 4;\n                while(Date.now() < et);\n                self.postMessage({\n                    st: st,\n                    et: et\n                });\n            });\n        }).toString(),\n        \")()\"\n    ], {\n        type: \"application/javascript\"\n    }));\n    // take 5 samples using 16 workers\n    sample([], 5, 16);\n    function sample(max, samples, numWorkers) {\n        if (samples === 0) {\n            // get overlap average\n            var avg = Math.floor(max.reduce(function(avg, x) {\n                return avg + x;\n            }, 0) / max.length);\n            util.cores = Math.max(1, avg);\n            URL.revokeObjectURL(blobUrl);\n            return callback(null, util.cores);\n        }\n        map(numWorkers, function(err, results) {\n            max.push(reduce(numWorkers, results));\n            sample(max, samples - 1, numWorkers);\n        });\n    }\n    function map(numWorkers, callback) {\n        var workers = [];\n        var results = [];\n        for(var i = 0; i < numWorkers; ++i){\n            var worker = new Worker(blobUrl);\n            worker.addEventListener(\"message\", function(e) {\n                results.push(e.data);\n                if (results.length === numWorkers) {\n                    for(var i = 0; i < numWorkers; ++i){\n                        workers[i].terminate();\n                    }\n                    callback(null, results);\n                }\n            });\n            workers.push(worker);\n        }\n        for(var i = 0; i < numWorkers; ++i){\n            workers[i].postMessage(i);\n        }\n    }\n    function reduce(numWorkers, results) {\n        // find overlapping time windows\n        var overlaps = [];\n        for(var n = 0; n < numWorkers; ++n){\n            var r1 = results[n];\n            var overlap = overlaps[n] = [];\n            for(var i = 0; i < numWorkers; ++i){\n                if (n === i) {\n                    continue;\n                }\n                var r2 = results[i];\n                if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {\n                    overlap.push(i);\n                }\n            }\n        }\n        // get maximum overlaps ... don't include overlapping worker itself\n        // as the main JS process was also being scheduled during the work and\n        // would have to be subtracted from the estimate anyway\n        return overlaps.reduce(function(max, overlap) {\n            return Math.max(max, overlap.length);\n        }, 0);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0NBTUM7QUFDRCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQixJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUVwQixpQkFBaUIsR0FDakIsSUFBSUUsT0FBT0MsT0FBT0MsT0FBTyxHQUFHTCxNQUFNRyxJQUFJLEdBQUdILE1BQU1HLElBQUksSUFBSSxDQUFDO0FBRXhELG1DQUFtQztBQUNsQztJQUNDLGdEQUFnRDtJQUNoRCx1RUFBdUU7SUFDdkUsMENBQTBDO0lBQzFDLElBQUcsT0FBT0csWUFBWSxlQUFlQSxRQUFRQyxRQUFRLElBQUksQ0FBQ0QsS0FBZSxFQUFFO1FBQ3pFSCxLQUFLSSxRQUFRLEdBQUdELFFBQVFDLFFBQVE7UUFDaEMsSUFBRyxPQUFPRSxpQkFBaUIsWUFBWTtZQUNyQ04sS0FBS00sWUFBWSxHQUFHQTtRQUN0QixPQUFPO1lBQ0wsOERBQThEO1lBQzlELG1EQUFtRDtZQUNuRE4sS0FBS00sWUFBWSxHQUFHTixLQUFLSSxRQUFRO1FBQ25DO1FBQ0E7SUFDRjtJQUVBLDZDQUE2QztJQUM3QyxJQUFHLE9BQU9FLGlCQUFpQixZQUFZO1FBQ3JDTixLQUFLTSxZQUFZLEdBQUc7WUFBYSxPQUFPQSxhQUFhQyxLQUFLLENBQUNDLFdBQVdDO1FBQVk7UUFDbEZULEtBQUtJLFFBQVEsR0FBRyxTQUFTTSxRQUFRO1lBQy9CLE9BQU9KLGFBQWFJO1FBQ3RCO1FBQ0E7SUFDRjtJQUVBOzs7NkJBRzJCLEdBRTNCLDJCQUEyQjtJQUMzQlYsS0FBS00sWUFBWSxHQUFHLFNBQVNJLFFBQVE7UUFDbkNDLFdBQVdELFVBQVU7SUFDdkI7SUFFQSxzQ0FBc0M7SUFDdEMsSUFBRyxLQUM2QixFQUFZLHVCQXNCM0M7SUFFRCwyQ0FBMkM7SUFDM0MsSUFBRyxPQUFPaUIscUJBQXFCLGFBQWE7UUFDMUMsaUNBQWlDO1FBQ2pDLElBQUlDLE1BQU1D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UXRSLE1BQU07UUFDckMsR0FBRztJQUNMO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvdXRpbC5qcz8zNzQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdlYiBhcHBsaWNhdGlvbnMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxOCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG52YXIgYmFzZU4gPSByZXF1aXJlKCcuL2Jhc2VOJyk7XG5cbi8qIFV0aWxpdGllcyBBUEkgKi9cbnZhciB1dGlsID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS51dGlsID0gZm9yZ2UudXRpbCB8fCB7fTtcblxuLy8gZGVmaW5lIHNldEltbWVkaWF0ZSBhbmQgbmV4dFRpY2tcbihmdW5jdGlvbigpIHtcbiAgLy8gdXNlIG5hdGl2ZSBuZXh0VGljayAodW5sZXNzIHdlJ3JlIGluIHdlYnBhY2spXG4gIC8vIHdlYnBhY2sgKG9yIGJldHRlciBub2RlLWxpYnMtYnJvd3NlciBwb2x5ZmlsbCkgc2V0cyBwcm9jZXNzLmJyb3dzZXIuXG4gIC8vIHRoaXMgd2F5IHdlIGNhbiBkZXRlY3Qgd2VicGFjayBwcm9wZXJseVxuICBpZih0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5uZXh0VGljayAmJiAhcHJvY2Vzcy5icm93c2VyKSB7XG4gICAgdXRpbC5uZXh0VGljayA9IHByb2Nlc3MubmV4dFRpY2s7XG4gICAgaWYodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdXRpbC5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHBvbHlmaWxsIHNldEltbWVkaWF0ZSB3aXRoIG5leHRUaWNrLCBvbGRlciB2ZXJzaW9ucyBvZiBub2RlXG4gICAgICAvLyAodGhvc2Ugdy9vIHNldEltbWVkaWF0ZSkgd29uJ3QgdG90YWxseSBzdGFydmUgSU9cbiAgICAgIHV0aWwuc2V0SW1tZWRpYXRlID0gdXRpbC5uZXh0VGljaztcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gcG9seWZpbGwgbmV4dFRpY2sgd2l0aCBuYXRpdmUgc2V0SW1tZWRpYXRlXG4gIGlmKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2V0SW1tZWRpYXRlLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTsgfTtcbiAgICB1dGlsLm5leHRUaWNrID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuICAgIH07XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyogTm90ZTogQSBwb2x5ZmlsbCB1cGdyYWRlIHBhdHRlcm4gaXMgdXNlZCBoZXJlIHRvIGFsbG93IGNvbWJpbmluZ1xuICBwb2x5ZmlsbHMuIEZvciBleGFtcGxlLCBNdXRhdGlvbk9ic2VydmVyIGlzIGZhc3QsIGJ1dCBibG9ja3MgVUkgdXBkYXRlcyxcbiAgc28gaXQgbmVlZHMgdG8gYWxsb3cgVUkgdXBkYXRlcyBwZXJpb2RpY2FsbHksIHNvIGl0IGZhbGxzIGJhY2sgb25cbiAgcG9zdE1lc3NhZ2Ugb3Igc2V0VGltZW91dC4gKi9cblxuICAvLyBwb2x5ZmlsbCB3aXRoIHNldFRpbWVvdXRcbiAgdXRpbC5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuICB9O1xuXG4gIC8vIHVwZ3JhZGUgcG9seWZpbGwgdG8gdXNlIHBvc3RNZXNzYWdlXG4gIGlmKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5wb3N0TWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBtc2cgPSAnZm9yZ2Uuc2V0SW1tZWRpYXRlJztcbiAgICB2YXIgY2FsbGJhY2tzID0gW107XG4gICAgdXRpbC5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgLy8gb25seSBzZW5kIG1lc3NhZ2Ugd2hlbiBvbmUgaGFzbid0IGJlZW4gc2VudCBpblxuICAgICAgLy8gdGhlIGN1cnJlbnQgdHVybiBvZiB0aGUgZXZlbnQgbG9vcFxuICAgICAgaWYoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UobXNnLCAnKicpO1xuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xuICAgICAgaWYoZXZlbnQuc291cmNlID09PSB3aW5kb3cgJiYgZXZlbnQuZGF0YSA9PT0gbXNnKSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB2YXIgY29weSA9IGNhbGxiYWNrcy5zbGljZSgpO1xuICAgICAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICAgICAgY29weS5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlciwgdHJ1ZSk7XG4gIH1cblxuICAvLyB1cGdyYWRlIHBvbHlmaWxsIHRvIHVzZSBNdXRhdGlvbk9ic2VydmVyXG4gIGlmKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIHBvbHlmaWxsIHdpdGggTXV0YXRpb25PYnNlcnZlclxuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIHZhciBhdHRyID0gdHJ1ZTtcbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvcHkgPSBjYWxsYmFja3Muc2xpY2UoKTtcbiAgICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgY29weS5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9KS5vYnNlcnZlKGRpdiwge2F0dHJpYnV0ZXM6IHRydWV9KTtcbiAgICB2YXIgb2xkU2V0SW1tZWRpYXRlID0gdXRpbC5zZXRJbW1lZGlhdGU7XG4gICAgdXRpbC5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgaWYoRGF0ZS5ub3coKSAtIG5vdyA+IDE1KSB7XG4gICAgICAgIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIG9sZFNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIC8vIG9ubHkgdHJpZ2dlciBvYnNlcnZlciB3aGVuIGl0IGhhc24ndCBiZWVuIHRyaWdnZXJlZCBpblxuICAgICAgICAvLyB0aGUgY3VycmVudCB0dXJuIG9mIHRoZSBldmVudCBsb29wXG4gICAgICAgIGlmKGNhbGxiYWNrcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdhJywgYXR0ciA9ICFhdHRyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB1dGlsLm5leHRUaWNrID0gdXRpbC5zZXRJbW1lZGlhdGU7XG59KSgpO1xuXG4vLyBjaGVjayBpZiBydW5uaW5nIHVuZGVyIE5vZGUuanNcbnV0aWwuaXNOb2RlanMgPVxuICB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7XG5cblxuLy8gJ3NlbGYnIHdpbGwgYWxzbyB3b3JrIGluIFdlYiBXb3JrZXJzIChpbnN0YW5jZSBvZiBXb3JrZXJHbG9iYWxTY29wZSkgd2hpbGVcbi8vIGl0IHdpbGwgcG9pbnQgdG8gYHdpbmRvd2AgaW4gdGhlIG1haW4gdGhyZWFkLlxuLy8gVG8gcmVtYWluIGNvbXBhdGlibGUgd2l0aCBvbGRlciBicm93c2Vycywgd2UgZmFsbCBiYWNrIHRvICd3aW5kb3cnIGlmICdzZWxmJ1xuLy8gaXMgbm90IGF2YWlsYWJsZS5cbnV0aWwuZ2xvYmFsU2NvcGUgPSAoZnVuY3Rpb24oKSB7XG4gIGlmKHV0aWwuaXNOb2RlanMpIHtcbiAgICByZXR1cm4gZ2xvYmFsO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHNlbGY7XG59KSgpO1xuXG4vLyBkZWZpbmUgaXNBcnJheVxudXRpbC5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vLyBkZWZpbmUgaXNBcnJheUJ1ZmZlclxudXRpbC5pc0FycmF5QnVmZmVyID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59O1xuXG4vLyBkZWZpbmUgaXNBcnJheUJ1ZmZlclZpZXdcbnV0aWwuaXNBcnJheUJ1ZmZlclZpZXcgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4ICYmIHV0aWwuaXNBcnJheUJ1ZmZlcih4LmJ1ZmZlcikgJiYgeC5ieXRlTGVuZ3RoICE9PSB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEVuc3VyZSBhIGJpdHMgcGFyYW0gaXMgOCwgMTYsIDI0LCBvciAzMi4gVXNlZCB0byB2YWxpZGF0ZSBpbnB1dCBmb3JcbiAqIGFsZ29yaXRobXMgd2hlcmUgYml0IG1hbmlwdWxhdGlvbiwgSmF2YVNjcmlwdCBsaW1pdGF0aW9ucywgYW5kL29yIGFsZ29yaXRobVxuICogZGVzaWduIG9ubHkgYWxsb3cgZm9yIGJ5dGUgb3BlcmF0aW9ucyBvZiBhIGxpbWl0ZWQgc2l6ZS5cbiAqXG4gKiBAcGFyYW0gbiBudW1iZXIgb2YgYml0cy5cbiAqXG4gKiBUaHJvdyBFcnJvciBpZiBuIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIF9jaGVja0JpdHNQYXJhbShuKSB7XG4gIGlmKCEobiA9PT0gOCB8fCBuID09PSAxNiB8fCBuID09PSAyNCB8fCBuID09PSAzMikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgOCwgMTYsIDI0LCBvciAzMiBiaXRzIHN1cHBvcnRlZDogJyArIG4pO1xuICB9XG59XG5cbi8vIFRPRE86IHNldCBCeXRlQnVmZmVyIHRvIGJlc3QgYXZhaWxhYmxlIGJhY2tpbmdcbnV0aWwuQnl0ZUJ1ZmZlciA9IEJ5dGVTdHJpbmdCdWZmZXI7XG5cbi8qKiBCdWZmZXIgdy9CaW5hcnlTdHJpbmcgYmFja2luZyAqL1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIGZvciBhIGJpbmFyeSBzdHJpbmcgYmFja2VkIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBbYl0gdGhlIGJ5dGVzIHRvIHdyYXAgKGVpdGhlciBlbmNvZGVkIGFzIHN0cmluZywgb25lIGJ5dGUgcGVyXG4gKiAgICAgICAgICBjaGFyYWN0ZXIsIG9yIGFzIGFuIEFycmF5QnVmZmVyIG9yIFR5cGVkIEFycmF5KS5cbiAqL1xuZnVuY3Rpb24gQnl0ZVN0cmluZ0J1ZmZlcihiKSB7XG4gIC8vIFRPRE86IHVwZGF0ZSB0byBtYXRjaCBEYXRhQnVmZmVyIEFQSVxuXG4gIC8vIHRoZSBkYXRhIGluIHRoaXMgYnVmZmVyXG4gIHRoaXMuZGF0YSA9ICcnO1xuICAvLyB0aGUgcG9pbnRlciBmb3IgcmVhZGluZyBmcm9tIHRoaXMgYnVmZmVyXG4gIHRoaXMucmVhZCA9IDA7XG5cbiAgaWYodHlwZW9mIGIgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5kYXRhID0gYjtcbiAgfSBlbHNlIGlmKHV0aWwuaXNBcnJheUJ1ZmZlcihiKSB8fCB1dGlsLmlzQXJyYXlCdWZmZXJWaWV3KGIpKSB7XG4gICAgaWYodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgYiBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgdGhpcy5kYXRhID0gYi50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnZlcnQgbmF0aXZlIGJ1ZmZlciB0byBmb3JnZSBidWZmZXJcbiAgICAgIC8vIEZJWE1FOiBzdXBwb3J0IG5hdGl2ZSBidWZmZXJzIGludGVybmFsbHkgaW5zdGVhZFxuICAgICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5kYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnIpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB0aGlzLnB1dEJ5dGUoYXJyW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmKGIgaW5zdGFuY2VvZiBCeXRlU3RyaW5nQnVmZmVyIHx8XG4gICAgKHR5cGVvZiBiID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYi5kYXRhID09PSAnc3RyaW5nJyAmJlxuICAgIHR5cGVvZiBiLnJlYWQgPT09ICdudW1iZXInKSkge1xuICAgIC8vIGNvcHkgZXhpc3RpbmcgYnVmZmVyXG4gICAgdGhpcy5kYXRhID0gYi5kYXRhO1xuICAgIHRoaXMucmVhZCA9IGIucmVhZDtcbiAgfVxuXG4gIC8vIHVzZWQgZm9yIHY4IG9wdGltaXphdGlvblxuICB0aGlzLl9jb25zdHJ1Y3RlZFN0cmluZ0xlbmd0aCA9IDA7XG59XG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIgPSBCeXRlU3RyaW5nQnVmZmVyO1xuXG4vKiBOb3RlOiBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiBmb3IgVjgtYmFzZWQgYnJvd3NlcnMuIFdoZW4gVjggY29uY2F0ZW5hdGVzXG4gIGEgc3RyaW5nLCB0aGUgc3RyaW5ncyBhcmUgb25seSBqb2luZWQgbG9naWNhbGx5IHVzaW5nIGEgXCJjb25zIHN0cmluZ1wiIG9yXG4gIFwiY29uc3RydWN0ZWQvY29uY2F0ZW5hdGVkIHN0cmluZ1wiLiBUaGVzZSBjb250YWluZXJzIGtlZXAgcmVmZXJlbmNlcyB0byBvbmVcbiAgYW5vdGhlciBhbmQgY2FuIHJlc3VsdCBpbiB2ZXJ5IGxhcmdlIG1lbW9yeSB1c2FnZS4gRm9yIGV4YW1wbGUsIGlmIGEgMk1CXG4gIHN0cmluZyBpcyBjb25zdHJ1Y3RlZCBieSBjb25jYXRlbmF0aW5nIDQgYnl0ZXMgdG9nZXRoZXIgYXQgYSB0aW1lLCB0aGVcbiAgbWVtb3J5IHVzYWdlIHdpbGwgYmUgfjQ0TUI7IHNvIH4yMnggaW5jcmVhc2UuIFRoZSBzdHJpbmdzIGFyZSBvbmx5IGpvaW5lZFxuICB0b2dldGhlciB3aGVuIGFuIG9wZXJhdGlvbiByZXF1aXJpbmcgdGhlaXIgam9pbmluZyB0YWtlcyBwbGFjZSwgc3VjaCBhc1xuICBzdWJzdHIoKS4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBhZGRpbmcgZGF0YSB0byB0aGlzIGJ1ZmZlciB0byBlbnN1cmVcbiAgdGhlc2UgdHlwZXMgb2Ygc3RyaW5ncyBhcmUgcGVyaW9kaWNhbGx5IGpvaW5lZCB0byByZWR1Y2UgdGhlIG1lbW9yeVxuICBmb290cHJpbnQuICovXG52YXIgX01BWF9DT05TVFJVQ1RFRF9TVFJJTkdfTEVOR1RIID0gNDA5NjtcbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuX29wdGltaXplQ29uc3RydWN0ZWRTdHJpbmcgPSBmdW5jdGlvbih4KSB7XG4gIHRoaXMuX2NvbnN0cnVjdGVkU3RyaW5nTGVuZ3RoICs9IHg7XG4gIGlmKHRoaXMuX2NvbnN0cnVjdGVkU3RyaW5nTGVuZ3RoID4gX01BWF9DT05TVFJVQ1RFRF9TVFJJTkdfTEVOR1RIKSB7XG4gICAgLy8gdGhpcyBzdWJzdHIoKSBzaG91bGQgY2F1c2UgdGhlIGNvbnN0cnVjdGVkIHN0cmluZyB0byBqb2luXG4gICAgdGhpcy5kYXRhLnN1YnN0cigwLCAxKTtcbiAgICB0aGlzLl9jb25zdHJ1Y3RlZFN0cmluZ0xlbmd0aCA9IDA7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0cyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoaXMgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGggLSB0aGlzLnJlYWQ7XG59O1xuXG4vKipcbiAqIEdldHMgd2hldGhlciBvciBub3QgdGhpcyBidWZmZXIgaXMgZW1wdHkuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoaXMgYnVmZmVyIGlzIGVtcHR5LCBmYWxzZSBpZiBub3QuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5sZW5ndGgoKSA8PSAwO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBpbiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gYiB0aGUgYnl0ZSB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRCeXRlID0gZnVuY3Rpb24oYikge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhTdHJpbmcuZnJvbUNoYXJDb2RlKGIpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgaW4gdGhpcyBidWZmZXIgTiB0aW1lcy5cbiAqXG4gKiBAcGFyYW0gYiB0aGUgYnl0ZSB0byBwdXQuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIG9mIHZhbHVlIGIgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZmlsbFdpdGhCeXRlID0gZnVuY3Rpb24oYiwgbikge1xuICBiID0gU3RyaW5nLmZyb21DaGFyQ29kZShiKTtcbiAgdmFyIGQgPSB0aGlzLmRhdGE7XG4gIHdoaWxlKG4gPiAwKSB7XG4gICAgaWYobiAmIDEpIHtcbiAgICAgIGQgKz0gYjtcbiAgICB9XG4gICAgbiA+Pj49IDE7XG4gICAgaWYobiA+IDApIHtcbiAgICAgIGIgKz0gYjtcbiAgICB9XG4gIH1cbiAgdGhpcy5kYXRhID0gZDtcbiAgdGhpcy5fb3B0aW1pemVDb25zdHJ1Y3RlZFN0cmluZyhuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyAoYXMgYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcpIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEJ5dGVzID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgdGhpcy5kYXRhICs9IGJ5dGVzO1xuICB0aGlzLl9vcHRpbWl6ZUNvbnN0cnVjdGVkU3RyaW5nKGJ5dGVzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgVVRGLTE2IGVuY29kZWQgc3RyaW5nIGludG8gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dFN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyh1dGlsLmVuY29kZVV0Zjgoc3RyKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAxNi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDE2ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAyNC1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAyNC1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDI0ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMTYgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMzItYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMzItYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQzMiA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDI0ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAxNi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDE2TGUgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MjRMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDMyLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDMyLWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MzJMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMjQgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYW4gbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICB2YXIgYnl0ZXMgPSAnJztcbiAgZG8ge1xuICAgIG4gLT0gODtcbiAgICBieXRlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpID4+IG4pICYgMHhGRik7XG4gIH0gd2hpbGUobiA+IDApO1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhieXRlcyk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBzaWduZWQgbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLiBUd28nc1xuICogY29tcGxlbWVudCByZXByZXNlbnRhdGlvbiBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dFNpZ25lZEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgLy8gcHV0SW50IGNoZWNrcyBuXG4gIGlmKGkgPCAwKSB7XG4gICAgaSArPSAyIDw8IChuIC0gMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMucHV0SW50KGksIG4pO1xufTtcblxuLyoqXG4gKiBQdXRzIHRoZSBnaXZlbiBidWZmZXIgaW50byB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gYnVmZmVyIHRoZSBidWZmZXIgdG8gcHV0IGludG8gdGhpcyBvbmUuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRCdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoYnVmZmVyLmdldEJ5dGVzKCkpO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYnl0ZSBmcm9tIHRoaXMgYnVmZmVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZCBwb2ludGVyIGJ5IDEuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZS5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQrKyk7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MTYgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAyLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQxNi5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQxNiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpKTtcbiAgdGhpcy5yZWFkICs9IDI7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDI0IGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMy5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MjQuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSA8PCAxNiBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMikpO1xuICB0aGlzLnJlYWQgKz0gMztcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MzIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSA0LlxuICpcbiAqIEByZXR1cm4gdGhlIHdvcmQuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSA8PCAyNCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgMTYgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDIpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDMpKTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDE2IGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMi5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MTYuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTZMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSA8PCA4KTtcbiAgdGhpcy5yZWFkICs9IDI7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDI0IGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMy5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MjQuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjRMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSA8PCA4IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAyKSA8PCAxNik7XG4gIHRoaXMucmVhZCArPSAzO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQzMiBmcm9tIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDQuXG4gKlxuICogQHJldHVybiB0aGUgd29yZC5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQzMkxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCkgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDIpIDw8IDE2IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAzKSA8PCAyNCk7XG4gIHRoaXMucmVhZCArPSA0O1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBuLWJpdCBpbnRlZ2VyIGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlXG4gKiByZWFkIHBvaW50ZXIgYnkgY2VpbChuLzgpLlxuICpcbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGUgaW50ZWdlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQgPSBmdW5jdGlvbihuKSB7XG4gIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgdmFyIHJ2YWwgPSAwO1xuICBkbyB7XG4gICAgLy8gVE9ETzogVXNlIChydmFsICogMHgxMDApIGlmIGFkZGluZyBzdXBwb3J0IGZvciAzMyB0byA1MyBiaXRzLlxuICAgIHJ2YWwgPSAocnZhbCA8PCA4KSArIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCsrKTtcbiAgICBuIC09IDg7XG4gIH0gd2hpbGUobiA+IDApO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHNpZ25lZCBuLWJpdCBpbnRlZ2VyIGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciwgdXNpbmdcbiAqIHR3bydzIGNvbXBsZW1lbnQsIGFuZCBhZHZhbmNlcyB0aGUgcmVhZCBwb2ludGVyIGJ5IG4vOC5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhlIGludGVnZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0U2lnbmVkSW50ID0gZnVuY3Rpb24obikge1xuICAvLyBnZXRJbnQgY2hlY2tzIG5cbiAgdmFyIHggPSB0aGlzLmdldEludChuKTtcbiAgdmFyIG1heCA9IDIgPDwgKG4gLSAyKTtcbiAgaWYoeCA+PSBtYXgpIHtcbiAgICB4IC09IG1heCA8PCAxO1xuICB9XG4gIHJldHVybiB4O1xufTtcblxuLyoqXG4gKiBSZWFkcyBieXRlcyBvdXQgYXMgYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgYW5kIGNsZWFycyB0aGVtIGZyb20gdGhlXG4gKiBidWZmZXIuIE5vdGUgdGhhdCB0aGUgcmVzdWx0aW5nIHN0cmluZyBpcyBiaW5hcnkgZW5jb2RlZCAoaW4gbm9kZS5qcyB0aGlzXG4gKiBlbmNvZGluZyBpcyByZWZlcnJlZCB0byBhcyBgYmluYXJ5YCwgaXQgaXMgKm5vdCogYHV0ZjhgKS5cbiAqXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLCB1bmRlZmluZWQgb3IgbnVsbCBmb3IgYWxsLlxuICpcbiAqIEByZXR1cm4gYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZXMgPSBmdW5jdGlvbihjb3VudCkge1xuICB2YXIgcnZhbDtcbiAgaWYoY291bnQpIHtcbiAgICAvLyByZWFkIGNvdW50IGJ5dGVzXG4gICAgY291bnQgPSBNYXRoLm1pbih0aGlzLmxlbmd0aCgpLCBjb3VudCk7XG4gICAgcnZhbCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsIHRoaXMucmVhZCArIGNvdW50KTtcbiAgICB0aGlzLnJlYWQgKz0gY291bnQ7XG4gIH0gZWxzZSBpZihjb3VudCA9PT0gMCkge1xuICAgIHJ2YWwgPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIGFsbCBieXRlcywgb3B0aW1pemUgdG8gb25seSBjb3B5IHdoZW4gbmVlZGVkXG4gICAgcnZhbCA9ICh0aGlzLnJlYWQgPT09IDApID8gdGhpcy5kYXRhIDogdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCk7XG4gICAgdGhpcy5jbGVhcigpO1xuICB9XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYmluYXJ5IGVuY29kZWQgc3RyaW5nIG9mIHRoZSBieXRlcyBmcm9tIHRoaXMgYnVmZmVyIHdpdGhvdXRcbiAqIG1vZGlmeWluZyB0aGUgcmVhZCBwb2ludGVyLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGdldCwgb21pdCB0byBnZXQgYWxsLlxuICpcbiAqIEByZXR1cm4gYSBzdHJpbmcgZnVsbCBvZiBiaW5hcnkgZW5jb2RlZCBjaGFyYWN0ZXJzLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgcmV0dXJuICh0eXBlb2YoY291bnQpID09PSAndW5kZWZpbmVkJyA/XG4gICAgdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCkgOlxuICAgIHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsIHRoaXMucmVhZCArIGNvdW50KSk7XG59O1xuXG4vKipcbiAqIEdldHMgYSBieXRlIGF0IHRoZSBnaXZlbiBpbmRleCB3aXRob3V0IG1vZGlmeWluZyB0aGUgcmVhZCBwb2ludGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBieXRlIGluZGV4LlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyBpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIGJ5dGUgaW5kZXguXG4gKiBAcGFyYW0gYiB0aGUgYnl0ZSB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5zZXRBdCA9IGZ1bmN0aW9uKGksIGIpIHtcbiAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLnN1YnN0cigwLCB0aGlzLnJlYWQgKyBpKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShiKSArXG4gICAgdGhpcy5kYXRhLnN1YnN0cih0aGlzLnJlYWQgKyBpICsgMSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGJ5dGUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBsYXN0IGJ5dGUuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5kYXRhLmxlbmd0aCAtIDEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjb3B5LlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGMgPSB1dGlsLmNyZWF0ZUJ1ZmZlcih0aGlzLmRhdGEpO1xuICBjLnJlYWQgPSB0aGlzLnJlYWQ7XG4gIHJldHVybiBjO1xufTtcblxuLyoqXG4gKiBDb21wYWN0cyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5yZWFkID4gMCkge1xuICAgIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpO1xuICAgIHRoaXMucmVhZCA9IDA7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGF0YSA9ICcnO1xuICB0aGlzLnJlYWQgPSAwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2hvcnRlbnMgdGhpcyBidWZmZXIgYnkgdHJpbWluZyBieXRlcyBvZmYgb2YgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byB0cmltIG9mZi5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24oY291bnQpIHtcbiAgdmFyIGxlbiA9IE1hdGgubWF4KDAsIHRoaXMubGVuZ3RoKCkgLSBjb3VudCk7XG4gIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5zdWJzdHIodGhpcy5yZWFkLCBsZW4pO1xuICB0aGlzLnJlYWQgPSAwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQHJldHVybiBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9ICcnO1xuICBmb3IodmFyIGkgPSB0aGlzLnJlYWQ7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYiA9IHRoaXMuZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmKGIgPCAxNikge1xuICAgICAgcnZhbCArPSAnMCc7XG4gICAgfVxuICAgIHJ2YWwgKz0gYi50b1N0cmluZygxNik7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgYnVmZmVyIHRvIGEgVVRGLTE2IHN0cmluZyAoc3RhbmRhcmQgSmF2YVNjcmlwdCBzdHJpbmcpLlxuICpcbiAqIEByZXR1cm4gYSBVVEYtMTYgc3RyaW5nLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB1dGlsLmRlY29kZVV0ZjgodGhpcy5ieXRlcygpKTtcbn07XG5cbi8qKiBFbmQgQnVmZmVyIHcvQmluYXJ5U3RyaW5nIGJhY2tpbmcgKi9cblxuLyoqIEJ1ZmZlciB3L1VJbnQ4QXJyYXkgYmFja2luZyAqL1xuXG4vKipcbiAqIEZJWE1FOiBFeHBlcmltZW50YWwuIERvIG5vdCB1c2UgeWV0LlxuICpcbiAqIENvbnN0cnVjdG9yIGZvciBhbiBBcnJheUJ1ZmZlci1iYWNrZWQgYnl0ZSBidWZmZXIuXG4gKlxuICogVGhlIGJ1ZmZlciBtYXkgYmUgY29uc3RydWN0ZWQgZnJvbSBhIHN0cmluZywgYW4gQXJyYXlCdWZmZXIsIERhdGFWaWV3LCBvciBhXG4gKiBUeXBlZEFycmF5LlxuICpcbiAqIElmIGEgc3RyaW5nIGlzIGdpdmVuLCBpdHMgZW5jb2Rpbmcgc2hvdWxkIGJlIHByb3ZpZGVkIGFzIGFuIG9wdGlvbixcbiAqIG90aGVyd2lzZSBpdCB3aWxsIGRlZmF1bHQgdG8gJ2JpbmFyeScuIEEgJ2JpbmFyeScgc3RyaW5nIGlzIGVuY29kZWQgc3VjaFxuICogdGhhdCBlYWNoIGNoYXJhY3RlciBpcyBvbmUgYnl0ZSBpbiBsZW5ndGggYW5kIHNpemUuXG4gKlxuICogSWYgYW4gQXJyYXlCdWZmZXIsIERhdGFWaWV3LCBvciBUeXBlZEFycmF5IGlzIGdpdmVuLCBpdCB3aWxsIGJlIHVzZWRcbiAqICpkaXJlY3RseSogd2l0aG91dCBhbnkgY29weWluZy4gTm90ZSB0aGF0LCBpZiBhIHdyaXRlIHRvIHRoZSBidWZmZXIgcmVxdWlyZXNcbiAqIG1vcmUgc3BhY2UsIHRoZSBidWZmZXIgd2lsbCBhbGxvY2F0ZSBhIG5ldyBiYWNraW5nIEFycmF5QnVmZmVyIHRvXG4gKiBhY2NvbW1vZGF0ZS4gVGhlIHN0YXJ0aW5nIHJlYWQgYW5kIHdyaXRlIG9mZnNldHMgZm9yIHRoZSBidWZmZXIgbWF5IGJlXG4gKiBnaXZlbiBhcyBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBbYl0gdGhlIGluaXRpYWwgYnl0ZXMgZm9yIHRoaXMgYnVmZmVyLlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW3JlYWRPZmZzZXRdIHRoZSBzdGFydGluZyByZWFkIG9mZnNldCB0byB1c2UgKGRlZmF1bHQ6IDApLlxuICogICAgICAgICAgW3dyaXRlT2Zmc2V0XSB0aGUgc3RhcnRpbmcgd3JpdGUgb2Zmc2V0IHRvIHVzZSAoZGVmYXVsdDogdGhlXG4gKiAgICAgICAgICAgIGxlbmd0aCBvZiB0aGUgZmlyc3QgcGFyYW1ldGVyKS5cbiAqICAgICAgICAgIFtncm93U2l6ZV0gdGhlIG1pbmltdW0gYW1vdW50LCBpbiBieXRlcywgdG8gZ3JvdyB0aGUgYnVmZmVyIGJ5IHRvXG4gKiAgICAgICAgICAgIGFjY29tbW9kYXRlIHdyaXRlcyAoZGVmYXVsdDogMTAyNCkuXG4gKiAgICAgICAgICBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyAoJ2JpbmFyeScsICd1dGY4JywgJ3V0ZjE2JywgJ2hleCcpIGZvciB0aGVcbiAqICAgICAgICAgICAgZmlyc3QgcGFyYW1ldGVyLCBpZiBpdCBpcyBhIHN0cmluZyAoZGVmYXVsdDogJ2JpbmFyeScpLlxuICovXG5mdW5jdGlvbiBEYXRhQnVmZmVyKGIsIG9wdGlvbnMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHBvaW50ZXJzIGZvciByZWFkIGZyb20vd3JpdGUgdG8gYnVmZmVyXG4gIHRoaXMucmVhZCA9IG9wdGlvbnMucmVhZE9mZnNldCB8fCAwO1xuICB0aGlzLmdyb3dTaXplID0gb3B0aW9ucy5ncm93U2l6ZSB8fCAxMDI0O1xuXG4gIHZhciBpc0FycmF5QnVmZmVyID0gdXRpbC5pc0FycmF5QnVmZmVyKGIpO1xuICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPSB1dGlsLmlzQXJyYXlCdWZmZXJWaWV3KGIpO1xuICBpZihpc0FycmF5QnVmZmVyIHx8IGlzQXJyYXlCdWZmZXJWaWV3KSB7XG4gICAgLy8gdXNlIEFycmF5QnVmZmVyIGRpcmVjdGx5XG4gICAgaWYoaXNBcnJheUJ1ZmZlcikge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBhZGp1c3QgcmVhZC93cml0ZSBvZmZzZXQgYmFzZWQgb24gdGhlIHR5cGUgb2Ygdmlld1xuICAgICAgLy8gb3Igc3BlY2lmeSB0aGF0IHRoaXMgbXVzdCBiZSBkb25lIGluIHRoZSBvcHRpb25zIC4uLiB0aGF0IHRoZVxuICAgICAgLy8gb2Zmc2V0cyBhcmUgYnl0ZS1iYXNlZFxuICAgICAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIHRoaXMud3JpdGUgPSAoJ3dyaXRlT2Zmc2V0JyBpbiBvcHRpb25zID9cbiAgICAgIG9wdGlvbnMud3JpdGVPZmZzZXQgOiB0aGlzLmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSB0byBlbXB0eSBhcnJheSBidWZmZXIgYW5kIGFkZCBhbnkgZ2l2ZW4gYnl0ZXMgdXNpbmcgcHV0Qnl0ZXNcbiAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gIHRoaXMud3JpdGUgPSAwO1xuXG4gIGlmKGIgIT09IG51bGwgJiYgYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5wdXRCeXRlcyhiKTtcbiAgfVxuXG4gIGlmKCd3cml0ZU9mZnNldCcgaW4gb3B0aW9ucykge1xuICAgIHRoaXMud3JpdGUgPSBvcHRpb25zLndyaXRlT2Zmc2V0O1xuICB9XG59XG51dGlsLkRhdGFCdWZmZXIgPSBEYXRhQnVmZmVyO1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLndyaXRlIC0gdGhpcy5yZWFkO1xufTtcblxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoaXMgYnVmZmVyIGlzIGVtcHR5LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGJ1ZmZlciBpcyBlbXB0eSwgZmFsc2UgaWYgbm90LlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgPD0gMDtcbn07XG5cbi8qKlxuICogRW5zdXJlcyB0aGlzIGJ1ZmZlciBoYXMgZW5vdWdoIGVtcHR5IHNwYWNlIHRvIGFjY29tbW9kYXRlIHRoZSBnaXZlbiBudW1iZXJcbiAqIG9mIGJ5dGVzLiBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgbWF5IGJlIGdpdmVuIHRoYXQgaW5kaWNhdGVzIGEgbWluaW11bVxuICogYW1vdW50IHRvIGdyb3cgdGhlIGJ1ZmZlciBpZiBuZWNlc3NhcnkuIElmIHRoZSBwYXJhbWV0ZXIgaXMgbm90IGdpdmVuLFxuICogdGhlIGJ1ZmZlciB3aWxsIGJlIGdyb3duIGJ5IHNvbWUgcHJldmlvdXNseS1zcGVjaWZpZWQgZGVmYXVsdCBhbW91bnRcbiAqIG9yIGhldXJpc3RpYy5cbiAqXG4gKiBAcGFyYW0gYW1vdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gYWNjb21tb2RhdGUuXG4gKiBAcGFyYW0gW2dyb3dTaXplXSB0aGUgbWluaW11bSBhbW91bnQsIGluIGJ5dGVzLCB0byBncm93IHRoZSBidWZmZXIgYnkgaWZcbiAqICAgICAgICAgIG5lY2Vzc2FyeS5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5hY2NvbW1vZGF0ZSA9IGZ1bmN0aW9uKGFtb3VudCwgZ3Jvd1NpemUpIHtcbiAgaWYodGhpcy5sZW5ndGgoKSA+PSBhbW91bnQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBncm93U2l6ZSA9IE1hdGgubWF4KGdyb3dTaXplIHx8IHRoaXMuZ3Jvd1NpemUsIGFtb3VudCk7XG5cbiAgLy8gZ3JvdyBidWZmZXJcbiAgdmFyIHNyYyA9IG5ldyBVaW50OEFycmF5KFxuICAgIHRoaXMuZGF0YS5idWZmZXIsIHRoaXMuZGF0YS5ieXRlT2Zmc2V0LCB0aGlzLmRhdGEuYnl0ZUxlbmd0aCk7XG4gIHZhciBkc3QgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCgpICsgZ3Jvd1NpemUpO1xuICBkc3Quc2V0KHNyYyk7XG4gIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhkc3QuYnVmZmVyKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgaW4gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgxKTtcbiAgdGhpcy5kYXRhLnNldFVpbnQ4KHRoaXMud3JpdGUrKywgYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBpbiB0aGlzIGJ1ZmZlciBOIHRpbWVzLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgb2YgdmFsdWUgYiB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5maWxsV2l0aEJ5dGUgPSBmdW5jdGlvbihiLCBuKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUobik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICB0aGlzLmRhdGEuc2V0VWludDgoYik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYnl0ZXMgaW4gdGhpcyBidWZmZXIuIFRoZSBieXRlcyBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcsIGFuXG4gKiBBcnJheUJ1ZmZlciwgYSBEYXRhVmlldywgb3IgYSBUeXBlZEFycmF5LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgdG8gcHV0LlxuICogQHBhcmFtIFtlbmNvZGluZ10gdGhlIGVuY29kaW5nIGZvciB0aGUgZmlyc3QgcGFyYW1ldGVyICgnYmluYXJ5JywgJ3V0ZjgnLFxuICogICAgICAgICAgJ3V0ZjE2JywgJ2hleCcpLCBpZiBpdCBpcyBhIHN0cmluZyAoZGVmYXVsdDogJ2JpbmFyeScpLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZXMgPSBmdW5jdGlvbihieXRlcywgZW5jb2RpbmcpIHtcbiAgaWYodXRpbC5pc0FycmF5QnVmZmVyVmlldyhieXRlcykpIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICB2YXIgbGVuID0gc3JjLmJ5dGVMZW5ndGggLSBzcmMuYnl0ZU9mZnNldDtcbiAgICB0aGlzLmFjY29tbW9kYXRlKGxlbik7XG4gICAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgIGRzdC5zZXQoc3JjKTtcbiAgICB0aGlzLndyaXRlICs9IGxlbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmKHV0aWwuaXNBcnJheUJ1ZmZlcihieXRlcykpIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgIHRoaXMuYWNjb21tb2RhdGUoc3JjLmJ5dGVMZW5ndGgpO1xuICAgIHZhciBkc3QgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyKTtcbiAgICBkc3Quc2V0KHNyYywgdGhpcy53cml0ZSk7XG4gICAgdGhpcy53cml0ZSArPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGJ5dGVzIGlzIGEgdXRpbC5EYXRhQnVmZmVyIG9yIGVxdWl2YWxlbnRcbiAgaWYoYnl0ZXMgaW5zdGFuY2VvZiB1dGlsLkRhdGFCdWZmZXIgfHxcbiAgICAodHlwZW9mIGJ5dGVzID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBieXRlcy5yZWFkID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYnl0ZXMud3JpdGUgPT09ICdudW1iZXInICYmXG4gICAgdXRpbC5pc0FycmF5QnVmZmVyVmlldyhieXRlcy5kYXRhKSkpIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMuZGF0YS5ieXRlTGVuZ3RoLCBieXRlcy5yZWFkLCBieXRlcy5sZW5ndGgoKSk7XG4gICAgdGhpcy5hY2NvbW1vZGF0ZShzcmMuYnl0ZUxlbmd0aCk7XG4gICAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmRhdGEuYnl0ZUxlbmd0aCwgdGhpcy53cml0ZSk7XG4gICAgZHN0LnNldChzcmMpO1xuICAgIHRoaXMud3JpdGUgKz0gc3JjLmJ5dGVMZW5ndGg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZihieXRlcyBpbnN0YW5jZW9mIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlcikge1xuICAgIC8vIGNvcHkgYmluYXJ5IHN0cmluZyBhbmQgcHJvY2VzcyBhcyB0aGUgc2FtZSBhcyBhIHN0cmluZyBwYXJhbWV0ZXIgYmVsb3dcbiAgICBieXRlcyA9IGJ5dGVzLmRhdGE7XG4gICAgZW5jb2RpbmcgPSAnYmluYXJ5JztcbiAgfVxuXG4gIC8vIHN0cmluZyBjb252ZXJzaW9uXG4gIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgJ2JpbmFyeSc7XG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgdmlldztcblxuICAgIC8vIGRlY29kZSBmcm9tIHN0cmluZ1xuICAgIGlmKGVuY29kaW5nID09PSAnaGV4Jykge1xuICAgICAgdGhpcy5hY2NvbW1vZGF0ZShNYXRoLmNlaWwoYnl0ZXMubGVuZ3RoIC8gMikpO1xuICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgICAgdGhpcy53cml0ZSArPSB1dGlsLmJpbmFyeS5oZXguZGVjb2RlKGJ5dGVzLCB2aWV3LCB0aGlzLndyaXRlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZihlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgIHRoaXMuYWNjb21tb2RhdGUoTWF0aC5jZWlsKGJ5dGVzLmxlbmd0aCAvIDQpICogMyk7XG4gICAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy53cml0ZSk7XG4gICAgICB0aGlzLndyaXRlICs9IHV0aWwuYmluYXJ5LmJhc2U2NC5kZWNvZGUoYnl0ZXMsIHZpZXcsIHRoaXMud3JpdGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIHRleHQgYXMgVVRGLTggYnl0ZXNcbiAgICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICAvLyBlbmNvZGUgYXMgVVRGLTggdGhlbiBkZWNvZGUgc3RyaW5nIGFzIHJhdyBiaW5hcnlcbiAgICAgIGJ5dGVzID0gdXRpbC5lbmNvZGVVdGY4KGJ5dGVzKTtcbiAgICAgIGVuY29kaW5nID0gJ2JpbmFyeSc7XG4gICAgfVxuXG4gICAgLy8gZGVjb2RlIHN0cmluZyBhcyByYXcgYmluYXJ5XG4gICAgaWYoZW5jb2RpbmcgPT09ICdiaW5hcnknIHx8IGVuY29kaW5nID09PSAncmF3Jykge1xuICAgICAgLy8gb25lIGJ5dGUgcGVyIGNoYXJhY3RlclxuICAgICAgdGhpcy5hY2NvbW1vZGF0ZShieXRlcy5sZW5ndGgpO1xuICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgICAgdGhpcy53cml0ZSArPSB1dGlsLmJpbmFyeS5yYXcuZGVjb2RlKHZpZXcpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIHRleHQgYXMgVVRGLTE2IGJ5dGVzXG4gICAgaWYoZW5jb2RpbmcgPT09ICd1dGYxNicpIHtcbiAgICAgIC8vIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyXG4gICAgICB0aGlzLmFjY29tbW9kYXRlKGJ5dGVzLmxlbmd0aCAqIDIpO1xuICAgICAgdmlldyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLndyaXRlKTtcbiAgICAgIHRoaXMud3JpdGUgKz0gdXRpbC50ZXh0LnV0ZjE2LmVuY29kZSh2aWV3KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxuXG4gIHRocm93IEVycm9yKCdJbnZhbGlkIHBhcmFtZXRlcjogJyArIGJ5dGVzKTtcbn07XG5cbi8qKlxuICogUHV0cyB0aGUgZ2l2ZW4gYnVmZmVyIGludG8gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGJ1ZmZlciB0aGUgYnVmZmVyIHRvIHB1dCBpbnRvIHRoaXMgb25lLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0QnVmZmVyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHRoaXMucHV0Qnl0ZXMoYnVmZmVyKTtcbiAgYnVmZmVyLmNsZWFyKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgc3RyaW5nIGludG8gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIHB1dC5cbiAqIEBwYXJhbSBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyBmb3IgdGhlIHN0cmluZyAoZGVmYXVsdDogJ3V0ZjE2JykuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoc3RyLCAndXRmMTYnKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDE2LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDE2LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MTYgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMik7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpKTtcbiAgdGhpcy53cml0ZSArPSAyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MjQgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMyk7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpID4+IDggJiAweEZGRkYpO1xuICB0aGlzLmRhdGEuc2V0SW50OCh0aGlzLndyaXRlLCBpID4+IDE2ICYgMHhGRik7XG4gIHRoaXMud3JpdGUgKz0gMztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAzMi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAzMi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDMyID0gZnVuY3Rpb24oaSkge1xuICB0aGlzLmFjY29tbW9kYXRlKDQpO1xuICB0aGlzLmRhdGEuc2V0SW50MzIodGhpcy53cml0ZSwgaSk7XG4gIHRoaXMud3JpdGUgKz0gNDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAxNi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDE2TGUgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMik7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpLCB0cnVlKTtcbiAgdGhpcy53cml0ZSArPSAyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MjRMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgzKTtcbiAgdGhpcy5kYXRhLnNldEludDgodGhpcy53cml0ZSwgaSA+PiAxNiAmIDB4RkYpO1xuICB0aGlzLmRhdGEuc2V0SW50MTYodGhpcy53cml0ZSwgaSA+PiA4ICYgMHhGRkZGLCB0cnVlKTtcbiAgdGhpcy53cml0ZSArPSAzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDMyLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDMyLWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MzJMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSg0KTtcbiAgdGhpcy5kYXRhLnNldEludDMyKHRoaXMud3JpdGUsIGksIHRydWUpO1xuICB0aGlzLndyaXRlICs9IDQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGFuIG4tYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgbi1iaXQgaW50ZWdlci5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQgPSBmdW5jdGlvbihpLCBuKSB7XG4gIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgdGhpcy5hY2NvbW1vZGF0ZShuIC8gOCk7XG4gIGRvIHtcbiAgICBuIC09IDg7XG4gICAgdGhpcy5kYXRhLnNldEludDgodGhpcy53cml0ZSsrLCAoaSA+PiBuKSAmIDB4RkYpO1xuICB9IHdoaWxlKG4gPiAwKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBzaWduZWQgbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLiBUd28nc1xuICogY29tcGxlbWVudCByZXByZXNlbnRhdGlvbiBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0U2lnbmVkSW50ID0gZnVuY3Rpb24oaSwgbikge1xuICBfY2hlY2tCaXRzUGFyYW0obik7XG4gIHRoaXMuYWNjb21tb2RhdGUobiAvIDgpO1xuICBpZihpIDwgMCkge1xuICAgIGkgKz0gMiA8PCAobiAtIDEpO1xuICB9XG4gIHJldHVybiB0aGlzLnB1dEludChpLCBuKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIGJ5dGUgZnJvbSB0aGlzIGJ1ZmZlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWQgcG9pbnRlciBieSAxLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkKyspO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDE2IGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMi5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MTYuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5yZWFkKTtcbiAgdGhpcy5yZWFkICs9IDI7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDI0IGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMy5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MjQuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmdldEludDE2KHRoaXMucmVhZCkgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkICsgMikpO1xuICB0aGlzLnJlYWQgKz0gMztcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MzIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSA0LlxuICpcbiAqIEByZXR1cm4gdGhlIHdvcmQuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50MzIodGhpcy5yZWFkKTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDE2IGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMi5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MTYuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTZMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLnJlYWQsIHRydWUpO1xuICB0aGlzLnJlYWQgKz0gMjtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MjQgZnJvbSB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAzLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQyNC5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQyNExlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5nZXRJbnQ4KHRoaXMucmVhZCkgXlxuICAgIHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLnJlYWQgKyAxLCB0cnVlKSA8PCA4KTtcbiAgdGhpcy5yZWFkICs9IDM7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDMyIGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgNC5cbiAqXG4gKiBAcmV0dXJuIHRoZSB3b3JkLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDMyTGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50MzIodGhpcy5yZWFkLCB0cnVlKTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIG4tYml0IGludGVnZXIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGVcbiAqIHJlYWQgcG9pbnRlciBieSBuLzguXG4gKlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbnRlZ2VyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludCA9IGZ1bmN0aW9uKG4pIHtcbiAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICB2YXIgcnZhbCA9IDA7XG4gIGRvIHtcbiAgICAvLyBUT0RPOiBVc2UgKHJ2YWwgKiAweDEwMCkgaWYgYWRkaW5nIHN1cHBvcnQgZm9yIDMzIHRvIDUzIGJpdHMuXG4gICAgcnZhbCA9IChydmFsIDw8IDgpICsgdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkKyspO1xuICAgIG4gLT0gODtcbiAgfSB3aGlsZShuID4gMCk7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgc2lnbmVkIG4tYml0IGludGVnZXIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLCB1c2luZ1xuICogdHdvJ3MgY29tcGxlbWVudCwgYW5kIGFkdmFuY2VzIHRoZSByZWFkIHBvaW50ZXIgYnkgbi84LlxuICpcbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGUgaW50ZWdlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRTaWduZWRJbnQgPSBmdW5jdGlvbihuKSB7XG4gIC8vIGdldEludCBjaGVja3MgblxuICB2YXIgeCA9IHRoaXMuZ2V0SW50KG4pO1xuICB2YXIgbWF4ID0gMiA8PCAobiAtIDIpO1xuICBpZih4ID49IG1heCkge1xuICAgIHggLT0gbWF4IDw8IDE7XG4gIH1cbiAgcmV0dXJuIHg7XG59O1xuXG4vKipcbiAqIFJlYWRzIGJ5dGVzIG91dCBhcyBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBhbmQgY2xlYXJzIHRoZW0gZnJvbSB0aGVcbiAqIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLCB1bmRlZmluZWQgb3IgbnVsbCBmb3IgYWxsLlxuICpcbiAqIEByZXR1cm4gYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZXMgPSBmdW5jdGlvbihjb3VudCkge1xuICAvLyBUT0RPOiBkZXByZWNhdGUgdGhpcyBtZXRob2QsIGl0IGlzIHBvb3JseSBuYW1lZCBhbmRcbiAgLy8gdGhpcy50b1N0cmluZygnYmluYXJ5JykgcmVwbGFjZXMgaXRcbiAgLy8gYWRkIGEgdG9UeXBlZEFycmF5KCkvdG9BcnJheUJ1ZmZlcigpIGZ1bmN0aW9uXG4gIHZhciBydmFsO1xuICBpZihjb3VudCkge1xuICAgIC8vIHJlYWQgY291bnQgYnl0ZXNcbiAgICBjb3VudCA9IE1hdGgubWluKHRoaXMubGVuZ3RoKCksIGNvdW50KTtcbiAgICBydmFsID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCwgdGhpcy5yZWFkICsgY291bnQpO1xuICAgIHRoaXMucmVhZCArPSBjb3VudDtcbiAgfSBlbHNlIGlmKGNvdW50ID09PSAwKSB7XG4gICAgcnZhbCA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgYWxsIGJ5dGVzLCBvcHRpbWl6ZSB0byBvbmx5IGNvcHkgd2hlbiBuZWVkZWRcbiAgICBydmFsID0gKHRoaXMucmVhZCA9PT0gMCkgPyB0aGlzLmRhdGEgOiB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgb2YgdGhlIGJ5dGVzIGZyb20gdGhpcyBidWZmZXIgd2l0aG91dFxuICogbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2V0LCBvbWl0IHRvIGdldCBhbGwuXG4gKlxuICogQHJldHVybiBhIHN0cmluZyBmdWxsIG9mIGJpbmFyeSBlbmNvZGVkIGNoYXJhY3RlcnMuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbihjb3VudCkge1xuICAvLyBUT0RPOiBkZXByZWNhdGUgdGhpcyBtZXRob2QsIGl0IGlzIHBvb3JseSBuYW1lZCwgYWRkIFwiZ2V0U3RyaW5nKClcIlxuICByZXR1cm4gKHR5cGVvZihjb3VudCkgPT09ICd1bmRlZmluZWQnID9cbiAgICB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKSA6XG4gICAgdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCwgdGhpcy5yZWFkICsgY291bnQpKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIGJ5dGUgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIGJ5dGUgaW5kZXguXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZS5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5nZXRVaW50OCh0aGlzLnJlYWQgKyBpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIGJ5dGUgaW5kZXguXG4gKiBAcGFyYW0gYiB0aGUgYnl0ZSB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5zZXRBdCA9IGZ1bmN0aW9uKGksIGIpIHtcbiAgdGhpcy5kYXRhLnNldFVpbnQ4KGksIGIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgbGFzdCBieXRlIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHJldHVybiB0aGUgbGFzdCBieXRlLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5nZXRVaW50OCh0aGlzLndyaXRlIC0gMSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGNvcHkuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IHV0aWwuRGF0YUJ1ZmZlcih0aGlzKTtcbn07XG5cbi8qKlxuICogQ29tcGFjdHMgdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oKSB7XG4gIGlmKHRoaXMucmVhZCA+IDApIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy5yZWFkKTtcbiAgICB2YXIgZHN0ID0gbmV3IFVpbnQ4QXJyYXkoc3JjLmJ5dGVMZW5ndGgpO1xuICAgIGRzdC5zZXQoc3JjKTtcbiAgICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcoZHN0KTtcbiAgICB0aGlzLndyaXRlIC09IHRoaXMucmVhZDtcbiAgICB0aGlzLnJlYWQgPSAwO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgdGhpcy5yZWFkID0gdGhpcy53cml0ZSA9IDA7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTaG9ydGVucyB0aGlzIGJ1ZmZlciBieSB0cmltaW5nIGJ5dGVzIG9mZiBvZiB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHRyaW0gb2ZmLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihjb3VudCkge1xuICB0aGlzLndyaXRlID0gTWF0aC5tYXgoMCwgdGhpcy5sZW5ndGgoKSAtIGNvdW50KTtcbiAgdGhpcy5yZWFkID0gTWF0aC5taW4odGhpcy5yZWFkLCB0aGlzLndyaXRlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgYnVmZmVyIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAnJztcbiAgZm9yKHZhciBpID0gdGhpcy5yZWFkOyBpIDwgdGhpcy5kYXRhLmJ5dGVMZW5ndGg7ICsraSkge1xuICAgIHZhciBiID0gdGhpcy5kYXRhLmdldFVpbnQ4KGkpO1xuICAgIGlmKGIgPCAxNikge1xuICAgICAgcnZhbCArPSAnMCc7XG4gICAgfVxuICAgIHJ2YWwgKz0gYi50b1N0cmluZygxNik7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgYnVmZmVyIHRvIGEgc3RyaW5nLCB1c2luZyB0aGUgZ2l2ZW4gZW5jb2RpbmcuIElmIG5vXG4gKiBlbmNvZGluZyBpcyBnaXZlbiwgJ3V0ZjgnIChVVEYtOCkgaXMgdXNlZC5cbiAqXG4gKiBAcGFyYW0gW2VuY29kaW5nXSB0aGUgZW5jb2RpbmcgdG8gdXNlOiAnYmluYXJ5JywgJ3V0ZjgnLCAndXRmMTYnLCAnaGV4JyxcbiAqICAgICAgICAgICdiYXNlNjQnIChkZWZhdWx0OiAndXRmOCcpLlxuICpcbiAqIEByZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEsIHRoaXMucmVhZCwgdGhpcy5sZW5ndGgoKSk7XG4gIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIGVuY29kZSB0byBzdHJpbmdcbiAgaWYoZW5jb2RpbmcgPT09ICdiaW5hcnknIHx8IGVuY29kaW5nID09PSAncmF3Jykge1xuICAgIHJldHVybiB1dGlsLmJpbmFyeS5yYXcuZW5jb2RlKHZpZXcpO1xuICB9XG4gIGlmKGVuY29kaW5nID09PSAnaGV4Jykge1xuICAgIHJldHVybiB1dGlsLmJpbmFyeS5oZXguZW5jb2RlKHZpZXcpO1xuICB9XG4gIGlmKGVuY29kaW5nID09PSAnYmFzZTY0Jykge1xuICAgIHJldHVybiB1dGlsLmJpbmFyeS5iYXNlNjQuZW5jb2RlKHZpZXcpO1xuICB9XG5cbiAgLy8gZGVjb2RlIHRvIHRleHRcbiAgaWYoZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgIHJldHVybiB1dGlsLnRleHQudXRmOC5kZWNvZGUodmlldyk7XG4gIH1cbiAgaWYoZW5jb2RpbmcgPT09ICd1dGYxNicpIHtcbiAgICByZXR1cm4gdXRpbC50ZXh0LnV0ZjE2LmRlY29kZSh2aWV3KTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbn07XG5cbi8qKiBFbmQgQnVmZmVyIHcvVUludDhBcnJheSBiYWNraW5nICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIGJ1ZmZlciB0aGF0IHN0b3JlcyBieXRlcy4gQSB2YWx1ZSBtYXkgYmUgZ2l2ZW4gdG8gcG9wdWxhdGUgdGhlXG4gKiBidWZmZXIgd2l0aCBkYXRhLiBUaGlzIHZhbHVlIGNhbiBlaXRoZXIgYmUgc3RyaW5nIG9mIGVuY29kZWQgYnl0ZXMgb3IgYVxuICogcmVndWxhciBzdHJpbmcgb2YgY2hhcmFjdGVycy4gV2hlbiBwYXNzaW5nIGEgc3RyaW5nIG9mIGJpbmFyeSBlbmNvZGVkXG4gKiBieXRlcywgdGhlIGVuY29kaW5nIGByYXdgIHNob3VsZCBiZSBnaXZlbi4gVGhpcyBpcyBhbHNvIHRoZSBkZWZhdWx0LiBXaGVuXG4gKiBwYXNzaW5nIGEgc3RyaW5nIG9mIGNoYXJhY3RlcnMsIHRoZSBlbmNvZGluZyBgdXRmOGAgc2hvdWxkIGJlIGdpdmVuLlxuICpcbiAqIEBwYXJhbSBbaW5wdXRdIGEgc3RyaW5nIHdpdGggZW5jb2RlZCBieXRlcyB0byBzdG9yZSBpbiB0aGUgYnVmZmVyLlxuICogQHBhcmFtIFtlbmNvZGluZ10gKGRlZmF1bHQ6ICdyYXcnLCBvdGhlcjogJ3V0ZjgnKS5cbiAqL1xudXRpbC5jcmVhdGVCdWZmZXIgPSBmdW5jdGlvbihpbnB1dCwgZW5jb2RpbmcpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlLCB1c2UgbmV3IEJ5dGVCdWZmZXIoKSBpbnN0ZWFkXG4gIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgJ3Jhdyc7XG4gIGlmKGlucHV0ICE9PSB1bmRlZmluZWQgJiYgZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgIGlucHV0ID0gdXRpbC5lbmNvZGVVdGY4KGlucHV0KTtcbiAgfVxuICByZXR1cm4gbmV3IHV0aWwuQnl0ZUJ1ZmZlcihpbnB1dCk7XG59O1xuXG4vKipcbiAqIEZpbGxzIGEgc3RyaW5nIHdpdGggYSBwYXJ0aWN1bGFyIHZhbHVlLiBJZiB5b3Ugd2FudCB0aGUgc3RyaW5nIHRvIGJlIGEgYnl0ZVxuICogc3RyaW5nLCBwYXNzIGluIFN0cmluZy5mcm9tQ2hhckNvZGUodGhlQnl0ZSkuXG4gKlxuICogQHBhcmFtIGMgdGhlIGNoYXJhY3RlciB0byBmaWxsIHRoZSBzdHJpbmcgd2l0aCwgdXNlIFN0cmluZy5mcm9tQ2hhckNvZGVcbiAqICAgICAgICAgIHRvIGZpbGwgdGhlIHN0cmluZyB3aXRoIGEgYnl0ZSB2YWx1ZS5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBvZiB2YWx1ZSBjIHRvIGZpbGwgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBmaWxsZWQgc3RyaW5nLlxuICovXG51dGlsLmZpbGxTdHJpbmcgPSBmdW5jdGlvbihjLCBuKSB7XG4gIHZhciBzID0gJyc7XG4gIHdoaWxlKG4gPiAwKSB7XG4gICAgaWYobiAmIDEpIHtcbiAgICAgIHMgKz0gYztcbiAgICB9XG4gICAgbiA+Pj49IDE7XG4gICAgaWYobiA+IDApIHtcbiAgICAgIGMgKz0gYztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHM7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgcGVyIGJ5dGUgWE9SIGJldHdlZW4gdHdvIGJ5dGUgc3RyaW5ncyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGFcbiAqIHN0cmluZyBvZiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gczEgZmlyc3Qgc3RyaW5nIG9mIGJ5dGVzLlxuICogQHBhcmFtIHMyIHNlY29uZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIFhPUi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBYT1InZCByZXN1bHQuXG4gKi9cbnV0aWwueG9yQnl0ZXMgPSBmdW5jdGlvbihzMSwgczIsIG4pIHtcbiAgdmFyIHMzID0gJyc7XG4gIHZhciBiID0gJyc7XG4gIHZhciB0ID0gJyc7XG4gIHZhciBpID0gMDtcbiAgdmFyIGMgPSAwO1xuICBmb3IoOyBuID4gMDsgLS1uLCArK2kpIHtcbiAgICBiID0gczEuY2hhckNvZGVBdChpKSBeIHMyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYoYyA+PSAxMCkge1xuICAgICAgczMgKz0gdDtcbiAgICAgIHQgPSAnJztcbiAgICAgIGMgPSAwO1xuICAgIH1cbiAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYik7XG4gICAgKytjO1xuICB9XG4gIHMzICs9IHQ7XG4gIHJldHVybiBzMztcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBoZXggc3RyaW5nIGludG8gYSAnYmluYXJ5JyBlbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gaGV4IHRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKi9cbnV0aWwuaGV4VG9CeXRlcyA9IGZ1bmN0aW9uKGhleCkge1xuICAvLyBUT0RPOiBkZXByZWNhdGU6IFwiRGVwcmVjYXRlZC4gVXNlIHV0aWwuYmluYXJ5LmhleC5kZWNvZGUgaW5zdGVhZC5cIlxuICB2YXIgcnZhbCA9ICcnO1xuICB2YXIgaSA9IDA7XG4gIGlmKGhleC5sZW5ndGggJiAxID09IDEpIHtcbiAgICAvLyBvZGQgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIGNvbnZlcnQgZmlyc3QgY2hhcmFjdGVyIGFsb25lXG4gICAgaSA9IDE7XG4gICAgcnZhbCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleFswXSwgMTYpKTtcbiAgfVxuICAvLyBjb252ZXJ0IDIgY2hhcmFjdGVycyAoMSBieXRlKSBhdCBhIHRpbWVcbiAgZm9yKDsgaSA8IGhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJ2YWwgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNikpO1xuICB9XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhICdiaW5hcnknIGVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIHRvIGhleC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgc3RyaW5nIG9mIGhleGFkZWNpbWFsIGNoYXJhY3RlcnMuXG4gKi9cbnV0aWwuYnl0ZXNUb0hleCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZTogXCJEZXByZWNhdGVkLiBVc2UgdXRpbC5iaW5hcnkuaGV4LmVuY29kZSBpbnN0ZWFkLlwiXG4gIHJldHVybiB1dGlsLmNyZWF0ZUJ1ZmZlcihieXRlcykudG9IZXgoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gMzItYml0IGludGVnZXIgdG8gNC1iaWctZW5kaWFuIGJ5dGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUgc3RyaW5nLlxuICovXG51dGlsLmludDMyVG9CeXRlcyA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIChcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMjQgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDE2ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpKTtcbn07XG5cbi8vIGJhc2U2NCBjaGFyYWN0ZXJzLCByZXZlcnNlIG1hcHBpbmdcbnZhciBfYmFzZTY0ID1cbiAgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcbnZhciBfYmFzZTY0SWR4ID0gW1xuLyo0MyAtNDMgPSAwKi9cbi8qJysnLCAgMSwgIDIsICAzLCcvJyAqL1xuICAgNjIsIC0xLCAtMSwgLTEsIDYzLFxuXG4vKicwJywnMScsJzInLCczJywnNCcsJzUnLCc2JywnNycsJzgnLCc5JyAqL1xuICAgNTIsIDUzLCA1NCwgNTUsIDU2LCA1NywgNTgsIDU5LCA2MCwgNjEsXG5cbi8qMTUsIDE2LCAxNywnPScsIDE5LCAyMCwgMjEgKi9cbiAgLTEsIC0xLCAtMSwgNjQsIC0xLCAtMSwgLTEsXG5cbi8qNjUgLSA0MyA9IDIyKi9cbi8qJ0EnLCdCJywnQycsJ0QnLCdFJywnRicsJ0cnLCdIJywnSScsJ0onLCdLJywnTCcsJ00nLCAqL1xuICAgMCwgIDEsICAyLCAgMywgIDQsICA1LCAgNiwgIDcsICA4LCAgOSwgMTAsIDExLCAxMixcblxuLyonTicsJ08nLCdQJywnUScsJ1InLCdTJywnVCcsJ1UnLCdWJywnVycsJ1gnLCdZJywnWicgKi9cbiAgIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAyMCwgMjEsIDIyLCAyMywgMjQsIDI1LFxuXG4vKjkxIC0gNDMgPSA0OCAqL1xuLyo0OCwgNDksIDUwLCA1MSwgNTIsIDUzICovXG4gIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG5cbi8qOTcgLSA0MyA9IDU0Ki9cbi8qJ2EnLCdiJywnYycsJ2QnLCdlJywnZicsJ2cnLCdoJywnaScsJ2onLCdrJywnbCcsJ20nICovXG4gICAyNiwgMjcsIDI4LCAyOSwgMzAsIDMxLCAzMiwgMzMsIDM0LCAzNSwgMzYsIDM3LCAzOCxcblxuLyonbicsJ28nLCdwJywncScsJ3InLCdzJywndCcsJ3UnLCd2JywndycsJ3gnLCd5JywneicgKi9cbiAgIDM5LCA0MCwgNDEsIDQyLCA0MywgNDQsIDQ1LCA0NiwgNDcsIDQ4LCA0OSwgNTAsIDUxXG5dO1xuXG4vLyBiYXNlNTggY2hhcmFjdGVycyAoQml0Y29pbiBhbHBoYWJldClcbnZhciBfYmFzZTU4ID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonO1xuXG4vKipcbiAqIEJhc2U2NCBlbmNvZGVzIGEgJ2JpbmFyeScgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgdG8gYmFzZTY0LWVuY29kZS5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIG51bWJlciBvZiBlbmNvZGVkIGNoYXJhY3RlcnMgcGVyIGxpbmUgdG8gdXNlLFxuICogICAgICAgICAgZGVmYXVsdHMgdG8gbm9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiYXNlNjQtZW5jb2RlZCBvdXRwdXQuXG4gKi9cbnV0aWwuZW5jb2RlNjQgPSBmdW5jdGlvbihpbnB1dCwgbWF4bGluZSkge1xuICAvLyBUT0RPOiBkZXByZWNhdGU6IFwiRGVwcmVjYXRlZC4gVXNlIHV0aWwuYmluYXJ5LmJhc2U2NC5lbmNvZGUgaW5zdGVhZC5cIlxuICB2YXIgbGluZSA9ICcnO1xuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBjaHIxLCBjaHIyLCBjaHIzO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlKGkgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICBjaHIxID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuICAgIGNocjIgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgY2hyMyA9IGlucHV0LmNoYXJDb2RlQXQoaSsrKTtcblxuICAgIC8vIGVuY29kZSA0IGNoYXJhY3RlciBncm91cFxuICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoY2hyMSA+PiAyKTtcbiAgICBsaW5lICs9IF9iYXNlNjQuY2hhckF0KCgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNCkpO1xuICAgIGlmKGlzTmFOKGNocjIpKSB7XG4gICAgICBsaW5lICs9ICc9PSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoKChjaHIyICYgMTUpIDw8IDIpIHwgKGNocjMgPj4gNikpO1xuICAgICAgbGluZSArPSBpc05hTihjaHIzKSA/ICc9JyA6IF9iYXNlNjQuY2hhckF0KGNocjMgJiA2Myk7XG4gICAgfVxuXG4gICAgaWYobWF4bGluZSAmJiBsaW5lLmxlbmd0aCA+IG1heGxpbmUpIHtcbiAgICAgIG91dHB1dCArPSBsaW5lLnN1YnN0cigwLCBtYXhsaW5lKSArICdcXHJcXG4nO1xuICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKG1heGxpbmUpO1xuICAgIH1cbiAgfVxuICBvdXRwdXQgKz0gbGluZTtcbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogQmFzZTY0IGRlY29kZXMgYSBzdHJpbmcgaW50byBhICdiaW5hcnknIGVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgYmFzZTY0LWVuY29kZWQgaW5wdXQuXG4gKlxuICogQHJldHVybiB0aGUgYmluYXJ5IGVuY29kZWQgc3RyaW5nLlxuICovXG51dGlsLmRlY29kZTY0ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlOiBcIkRlcHJlY2F0ZWQuIFVzZSB1dGlsLmJpbmFyeS5iYXNlNjQuZGVjb2RlIGluc3RlYWQuXCJcblxuICAvLyByZW1vdmUgYWxsIG5vbi1iYXNlNjQgY2hhcmFjdGVyc1xuICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCAnJyk7XG5cbiAgdmFyIG91dHB1dCA9ICcnO1xuICB2YXIgZW5jMSwgZW5jMiwgZW5jMywgZW5jNDtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlKGkgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICBlbmMxID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jMiA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzMgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmM0ID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG5cbiAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoZW5jMSA8PCAyKSB8IChlbmMyID4+IDQpKTtcbiAgICBpZihlbmMzICE9PSA2NCkge1xuICAgICAgLy8gZGVjb2RlZCBhdCBsZWFzdCAyIGJ5dGVzXG4gICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKSk7XG4gICAgICBpZihlbmM0ICE9PSA2NCkge1xuICAgICAgICAvLyBkZWNvZGVkIDMgYnl0ZXNcbiAgICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChlbmMzICYgMykgPDwgNikgfCBlbmM0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiBzdHJpbmcgb2YgY2hhcmFjdGVycyAoYSBzdGFuZGFyZCBKYXZhU2NyaXB0XG4gKiBzdHJpbmcpIGFzIGEgYmluYXJ5IGVuY29kZWQgc3RyaW5nIHdoZXJlIHRoZSBieXRlcyByZXByZXNlbnRcbiAqIGEgVVRGLTggZW5jb2RlZCBzdHJpbmcgb2YgY2hhcmFjdGVycy4gTm9uLUFTQ0lJIGNoYXJhY3RlcnMgd2lsbCBiZVxuICogZW5jb2RlZCBhcyBtdWx0aXBsZSBieXRlcyBhY2NvcmRpbmcgdG8gVVRGLTguXG4gKlxuICogQHBhcmFtIHN0ciBhIHN0YW5kYXJkIHN0cmluZyBvZiBjaGFyYWN0ZXJzIHRvIGVuY29kZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbnV0aWwuZW5jb2RlVXRmOCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgYmluYXJ5IGVuY29kZWQgc3RyaW5nIHRoYXQgY29udGFpbnMgYnl0ZXMgdGhhdFxuICogcmVwcmVzZW50IGEgVVRGLTggZW5jb2RlZCBzdHJpbmcgb2YgY2hhcmFjdGVycyAtLSBpbnRvIGFcbiAqIHN0cmluZyBvZiBjaGFyYWN0ZXJzIChhIHN0YW5kYXJkIEphdmFTY3JpcHQgc3RyaW5nKS5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgdG8gZGVjb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIHJlc3VsdGluZyBzdGFuZGFyZCBzdHJpbmcgb2YgY2hhcmFjdGVycy5cbiAqL1xudXRpbC5kZWNvZGVVdGY4ID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHN0cikpO1xufTtcblxuLy8gYmluYXJ5IGVuY29kaW5nL2RlY29kaW5nIHRvb2xzXG4vLyBGSVhNRTogRXhwZXJpbWVudGFsLiBEbyBub3QgdXNlIHlldC5cbnV0aWwuYmluYXJ5ID0ge1xuICByYXc6IHt9LFxuICBoZXg6IHt9LFxuICBiYXNlNjQ6IHt9LFxuICBiYXNlNTg6IHt9LFxuICBiYXNlTiA6IHtcbiAgICBlbmNvZGU6IGJhc2VOLmVuY29kZSxcbiAgICBkZWNvZGU6IGJhc2VOLmRlY29kZVxuICB9XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSBVaW50OEFycmF5IGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nLiBUaGlzIGVuY29kaW5nIHVzZXNcbiAqIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTUgZm9yIGVhY2ggY2hhcmFjdGVyLlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgVWludDhBcnJheSB0byBlbmNvZGUuXG4gKlxuICogQHJldHVybiB0aGUgYmluYXJ5LWVuY29kZWQgc3RyaW5nLlxuICovXG51dGlsLmJpbmFyeS5yYXcuZW5jb2RlID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnl0ZXMpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIHRvIGEgVWludDhBcnJheS4gVGhpcyBlbmNvZGluZyB1c2VzXG4gKiBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1IGZvciBlYWNoIGNoYXJhY3Rlci5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgdG8gZGVjb2RlLlxuICogQHBhcmFtIFtvdXRwdXRdIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkgdG8gd3JpdGUgdGhlIG91dHB1dCB0bzsgaWYgaXRcbiAqICAgICAgICAgIGlzIHRvbyBzbWFsbCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICogQHBhcmFtIFtvZmZzZXRdIHRoZSBzdGFydCBvZmZzZXQgZm9yIHdyaXRpbmcgdG8gdGhlIG91dHB1dCAoZGVmYXVsdDogMCkuXG4gKlxuICogQHJldHVybiB0aGUgVWludDhBcnJheSBvciB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gaWYgb3V0cHV0IHdhcyBnaXZlbi5cbiAqL1xudXRpbC5iaW5hcnkucmF3LmRlY29kZSA9IGZ1bmN0aW9uKHN0ciwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgdmFyIG91dCA9IG91dHB1dDtcbiAgaWYoIW91dCkge1xuICAgIG91dCA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGgpO1xuICB9XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgaiA9IG9mZnNldDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIG91dFtqKytdID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dCA/IChqIC0gb2Zmc2V0KSA6IG91dDtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhICdiaW5hcnknIHN0cmluZywgQXJyYXlCdWZmZXIsIERhdGFWaWV3LCBUeXBlZEFycmF5LCBvclxuICogQnl0ZUJ1ZmZlciBhcyBhIHN0cmluZyBvZiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXJzLlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdHJpbmcgb2YgaGV4YWRlY2ltYWwgY2hhcmFjdGVycy5cbiAqL1xudXRpbC5iaW5hcnkuaGV4LmVuY29kZSA9IHV0aWwuYnl0ZXNUb0hleDtcblxuLyoqXG4gKiBEZWNvZGVzIGEgaGV4LWVuY29kZWQgc3RyaW5nIHRvIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gaGV4IHRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydC5cbiAqIEBwYXJhbSBbb3V0cHV0XSBhbiBvcHRpb25hbCBVaW50OEFycmF5IHRvIHdyaXRlIHRoZSBvdXRwdXQgdG87IGlmIGl0XG4gKiAgICAgICAgICBpcyB0b28gc21hbGwsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqIEBwYXJhbSBbb2Zmc2V0XSB0aGUgc3RhcnQgb2Zmc2V0IGZvciB3cml0aW5nIHRvIHRoZSBvdXRwdXQgKGRlZmF1bHQ6IDApLlxuICpcbiAqIEByZXR1cm4gdGhlIFVpbnQ4QXJyYXkgb3IgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIGlmIG91dHB1dCB3YXMgZ2l2ZW4uXG4gKi9cbnV0aWwuYmluYXJ5LmhleC5kZWNvZGUgPSBmdW5jdGlvbihoZXgsIG91dHB1dCwgb2Zmc2V0KSB7XG4gIHZhciBvdXQgPSBvdXRwdXQ7XG4gIGlmKCFvdXQpIHtcbiAgICBvdXQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwoaGV4Lmxlbmd0aCAvIDIpKTtcbiAgfVxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGkgPSAwLCBqID0gb2Zmc2V0O1xuICBpZihoZXgubGVuZ3RoICYgMSkge1xuICAgIC8vIG9kZCBudW1iZXIgb2YgY2hhcmFjdGVycywgY29udmVydCBmaXJzdCBjaGFyYWN0ZXIgYWxvbmVcbiAgICBpID0gMTtcbiAgICBvdXRbaisrXSA9IHBhcnNlSW50KGhleFswXSwgMTYpO1xuICB9XG4gIC8vIGNvbnZlcnQgMiBjaGFyYWN0ZXJzICgxIGJ5dGUpIGF0IGEgdGltZVxuICBmb3IoOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgb3V0W2orK10gPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNik7XG4gIH1cbiAgcmV0dXJuIG91dHB1dCA/IChqIC0gb2Zmc2V0KSA6IG91dDtcbn07XG5cbi8qKlxuICogQmFzZTY0LWVuY29kZXMgYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgVWludDhBcnJheSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBudW1iZXIgb2YgZW5jb2RlZCBjaGFyYWN0ZXJzIHBlciBsaW5lIHRvIHVzZSxcbiAqICAgICAgICAgIGRlZmF1bHRzIHRvIG5vbmUuXG4gKlxuICogQHJldHVybiB0aGUgYmFzZTY0LWVuY29kZWQgb3V0cHV0IHN0cmluZy5cbiAqL1xudXRpbC5iaW5hcnkuYmFzZTY0LmVuY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBtYXhsaW5lKSB7XG4gIHZhciBsaW5lID0gJyc7XG4gIHZhciBvdXRwdXQgPSAnJztcbiAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUoaSA8IGlucHV0LmJ5dGVMZW5ndGgpIHtcbiAgICBjaHIxID0gaW5wdXRbaSsrXTtcbiAgICBjaHIyID0gaW5wdXRbaSsrXTtcbiAgICBjaHIzID0gaW5wdXRbaSsrXTtcblxuICAgIC8vIGVuY29kZSA0IGNoYXJhY3RlciBncm91cFxuICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoY2hyMSA+PiAyKTtcbiAgICBsaW5lICs9IF9iYXNlNjQuY2hhckF0KCgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNCkpO1xuICAgIGlmKGlzTmFOKGNocjIpKSB7XG4gICAgICBsaW5lICs9ICc9PSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoKChjaHIyICYgMTUpIDw8IDIpIHwgKGNocjMgPj4gNikpO1xuICAgICAgbGluZSArPSBpc05hTihjaHIzKSA/ICc9JyA6IF9iYXNlNjQuY2hhckF0KGNocjMgJiA2Myk7XG4gICAgfVxuXG4gICAgaWYobWF4bGluZSAmJiBsaW5lLmxlbmd0aCA+IG1heGxpbmUpIHtcbiAgICAgIG91dHB1dCArPSBsaW5lLnN1YnN0cigwLCBtYXhsaW5lKSArICdcXHJcXG4nO1xuICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKG1heGxpbmUpO1xuICAgIH1cbiAgfVxuICBvdXRwdXQgKz0gbGluZTtcbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZyB0byBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBiYXNlNjQtZW5jb2RlZCBpbnB1dCBzdHJpbmcuXG4gKiBAcGFyYW0gW291dHB1dF0gYW4gb3B0aW9uYWwgVWludDhBcnJheSB0byB3cml0ZSB0aGUgb3V0cHV0IHRvOyBpZiBpdFxuICogICAgICAgICAgaXMgdG9vIHNtYWxsLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAcGFyYW0gW29mZnNldF0gdGhlIHN0YXJ0IG9mZnNldCBmb3Igd3JpdGluZyB0byB0aGUgb3V0cHV0IChkZWZhdWx0OiAwKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5IG9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpZiBvdXRwdXQgd2FzIGdpdmVuLlxuICovXG51dGlsLmJpbmFyeS5iYXNlNjQuZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgb2Zmc2V0KSB7XG4gIHZhciBvdXQgPSBvdXRwdXQ7XG4gIGlmKCFvdXQpIHtcbiAgICBvdXQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwoaW5wdXQubGVuZ3RoIC8gNCkgKiAzKTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBhbGwgbm9uLWJhc2U2NCBjaGFyYWN0ZXJzXG4gIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9cXD1dL2csICcnKTtcblxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gIHZhciBpID0gMCwgaiA9IG9mZnNldDtcblxuICB3aGlsZShpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgZW5jMSA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzIgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmMzID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jNCA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuXG4gICAgb3V0W2orK10gPSAoZW5jMSA8PCAyKSB8IChlbmMyID4+IDQpO1xuICAgIGlmKGVuYzMgIT09IDY0KSB7XG4gICAgICAvLyBkZWNvZGVkIGF0IGxlYXN0IDIgYnl0ZXNcbiAgICAgIG91dFtqKytdID0gKChlbmMyICYgMTUpIDw8IDQpIHwgKGVuYzMgPj4gMik7XG4gICAgICBpZihlbmM0ICE9PSA2NCkge1xuICAgICAgICAvLyBkZWNvZGVkIDMgYnl0ZXNcbiAgICAgICAgb3V0W2orK10gPSAoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHJlc3VsdCBpcyB0aGUgZXhhY3QgZGVjb2RlZCBsZW5ndGhcbiAgcmV0dXJuIG91dHB1dCA/IChqIC0gb2Zmc2V0KSA6IG91dC5zdWJhcnJheSgwLCBqKTtcbn07XG5cbi8vIGFkZCBzdXBwb3J0IGZvciBiYXNlNTggZW5jb2RpbmcvZGVjb2Rpbmcgd2l0aCBCaXRjb2luIGFscGhhYmV0XG51dGlsLmJpbmFyeS5iYXNlNTguZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQsIG1heGxpbmUpIHtcbiAgcmV0dXJuIHV0aWwuYmluYXJ5LmJhc2VOLmVuY29kZShpbnB1dCwgX2Jhc2U1OCwgbWF4bGluZSk7XG59O1xudXRpbC5iaW5hcnkuYmFzZTU4LmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBtYXhsaW5lKSB7XG4gIHJldHVybiB1dGlsLmJpbmFyeS5iYXNlTi5kZWNvZGUoaW5wdXQsIF9iYXNlNTgsIG1heGxpbmUpO1xufTtcblxuLy8gdGV4dCBlbmNvZGluZy9kZWNvZGluZyB0b29sc1xuLy8gRklYTUU6IEV4cGVyaW1lbnRhbC4gRG8gbm90IHVzZSB5ZXQuXG51dGlsLnRleHQgPSB7XG4gIHV0Zjg6IHt9LFxuICB1dGYxNjoge31cbn07XG5cbi8qKlxuICogRW5jb2RlcyB0aGUgZ2l2ZW4gc3RyaW5nIGFzIFVURi04IGluIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gZW5jb2RlLlxuICogQHBhcmFtIFtvdXRwdXRdIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkgdG8gd3JpdGUgdGhlIG91dHB1dCB0bzsgaWYgaXRcbiAqICAgICAgICAgIGlzIHRvbyBzbWFsbCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICogQHBhcmFtIFtvZmZzZXRdIHRoZSBzdGFydCBvZmZzZXQgZm9yIHdyaXRpbmcgdG8gdGhlIG91dHB1dCAoZGVmYXVsdDogMCkuXG4gKlxuICogQHJldHVybiB0aGUgVWludDhBcnJheSBvciB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gaWYgb3V0cHV0IHdhcyBnaXZlbi5cbiAqL1xudXRpbC50ZXh0LnV0ZjguZW5jb2RlID0gZnVuY3Rpb24oc3RyLCBvdXRwdXQsIG9mZnNldCkge1xuICBzdHIgPSB1dGlsLmVuY29kZVV0Zjgoc3RyKTtcbiAgdmFyIG91dCA9IG91dHB1dDtcbiAgaWYoIW91dCkge1xuICAgIG91dCA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGgpO1xuICB9XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgaiA9IG9mZnNldDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIG91dFtqKytdID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dCA/IChqIC0gb2Zmc2V0KSA6IG91dDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyB0aGUgVVRGLTggY29udGVudHMgZnJvbSBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBVaW50OEFycmF5IHRvIGRlY29kZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXN1bHRpbmcgc3RyaW5nLlxuICovXG51dGlsLnRleHQudXRmOC5kZWNvZGUgPSBmdW5jdGlvbihieXRlcykge1xuICByZXR1cm4gdXRpbC5kZWNvZGVVdGY4KFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnl0ZXMpKTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyB0aGUgZ2l2ZW4gc3RyaW5nIGFzIFVURi0xNiBpbiBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBbb3V0cHV0XSBhbiBvcHRpb25hbCBVaW50OEFycmF5IHRvIHdyaXRlIHRoZSBvdXRwdXQgdG87IGlmIGl0XG4gKiAgICAgICAgICBpcyB0b28gc21hbGwsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqIEBwYXJhbSBbb2Zmc2V0XSB0aGUgc3RhcnQgb2Zmc2V0IGZvciB3cml0aW5nIHRvIHRoZSBvdXRwdXQgKGRlZmF1bHQ6IDApLlxuICpcbiAqIEByZXR1cm4gdGhlIFVpbnQ4QXJyYXkgb3IgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIGlmIG91dHB1dCB3YXMgZ2l2ZW4uXG4gKi9cbnV0aWwudGV4dC51dGYxNi5lbmNvZGUgPSBmdW5jdGlvbihzdHIsIG91dHB1dCwgb2Zmc2V0KSB7XG4gIHZhciBvdXQgPSBvdXRwdXQ7XG4gIGlmKCFvdXQpIHtcbiAgICBvdXQgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoICogMik7XG4gIH1cbiAgdmFyIHZpZXcgPSBuZXcgVWludDE2QXJyYXkob3V0LmJ1ZmZlcik7XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgaiA9IG9mZnNldDtcbiAgdmFyIGsgPSBvZmZzZXQ7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICB2aWV3W2srK10gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBqICs9IDI7XG4gIH1cbiAgcmV0dXJuIG91dHB1dCA/IChqIC0gb2Zmc2V0KSA6IG91dDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyB0aGUgVVRGLTE2IGNvbnRlbnRzIGZyb20gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgVWludDhBcnJheSB0byBkZWNvZGUuXG4gKlxuICogQHJldHVybiB0aGUgcmVzdWx0aW5nIHN0cmluZy5cbiAqL1xudXRpbC50ZXh0LnV0ZjE2LmRlY29kZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheShieXRlcy5idWZmZXIpKTtcbn07XG5cbi8qKlxuICogRGVmbGF0ZXMgdGhlIGdpdmVuIGRhdGEgdXNpbmcgYSBmbGFzaCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgZmxhc2ggaW50ZXJmYWNlLlxuICogQHBhcmFtIGJ5dGVzIHRoZSBkYXRhLlxuICogQHBhcmFtIHJhdyB0cnVlIHRvIHJldHVybiBvbmx5IHJhdyBkZWZsYXRlIGRhdGEsIGZhbHNlIHRvIGluY2x1ZGUgemxpYlxuICogICAgICAgICAgaGVhZGVyIGFuZCB0cmFpbGVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlZmxhdGVkIGRhdGEgYXMgYSBzdHJpbmcuXG4gKi9cbnV0aWwuZGVmbGF0ZSA9IGZ1bmN0aW9uKGFwaSwgYnl0ZXMsIHJhdykge1xuICBieXRlcyA9IHV0aWwuZGVjb2RlNjQoYXBpLmRlZmxhdGUodXRpbC5lbmNvZGU2NChieXRlcykpLnJ2YWwpO1xuXG4gIC8vIHN0cmlwIHpsaWIgaGVhZGVyIGFuZCB0cmFpbGVyIGlmIG5lY2Vzc2FyeVxuICBpZihyYXcpIHtcbiAgICAvLyB6bGliIGhlYWRlciBpcyAyIGJ5dGVzIChDTUYsRkxHKSB3aGVyZSBGTEcgaW5kaWNhdGVzIHRoYXRcbiAgICAvLyB0aGVyZSBpcyBhIDQtYnl0ZSBESUNUIChhbGRlci0zMikgYmxvY2sgYmVmb3JlIHRoZSBkYXRhIGlmXG4gICAgLy8gaXRzIDV0aCBiaXQgaXMgc2V0XG4gICAgdmFyIHN0YXJ0ID0gMjtcbiAgICB2YXIgZmxnID0gYnl0ZXMuY2hhckNvZGVBdCgxKTtcbiAgICBpZihmbGcgJiAweDIwKSB7XG4gICAgICBzdGFydCA9IDY7XG4gICAgfVxuICAgIC8vIHpsaWIgdHJhaWxlciBpcyA0IGJ5dGVzIG9mIGFkbGVyLTMyXG4gICAgYnl0ZXMgPSBieXRlcy5zdWJzdHJpbmcoc3RhcnQsIGJ5dGVzLmxlbmd0aCAtIDQpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufTtcblxuLyoqXG4gKiBJbmZsYXRlcyB0aGUgZ2l2ZW4gZGF0YSB1c2luZyBhIGZsYXNoIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGRhdGEuXG4gKiBAcGFyYW0gcmF3IHRydWUgaWYgdGhlIGluY29taW5nIGRhdGEgaGFzIG5vIHpsaWIgaGVhZGVyIG9yIHRyYWlsZXIgYW5kIGlzXG4gKiAgICAgICAgICByYXcgREVGTEFURSBkYXRhLlxuICpcbiAqIEByZXR1cm4gdGhlIGluZmxhdGVkIGRhdGEgYXMgYSBzdHJpbmcsIG51bGwgb24gZXJyb3IuXG4gKi9cbnV0aWwuaW5mbGF0ZSA9IGZ1bmN0aW9uKGFwaSwgYnl0ZXMsIHJhdykge1xuICAvLyBUT0RPOiBhZGQgemxpYiBoZWFkZXIgYW5kIHRyYWlsZXIgaWYgbmVjZXNzYXJ5L3Bvc3NpYmxlXG4gIHZhciBydmFsID0gYXBpLmluZmxhdGUodXRpbC5lbmNvZGU2NChieXRlcykpLnJ2YWw7XG4gIHJldHVybiAocnZhbCA9PT0gbnVsbCkgPyBudWxsIDogdXRpbC5kZWNvZGU2NChydmFsKTtcbn07XG5cbi8qKlxuICogU2V0cyBhIHN0b3JhZ2Ugb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBvYmogdGhlIHN0b3JhZ2Ugb2JqZWN0LCBudWxsIHRvIHJlbW92ZS5cbiAqL1xudmFyIF9zZXRTdG9yYWdlT2JqZWN0ID0gZnVuY3Rpb24oYXBpLCBpZCwgb2JqKSB7XG4gIGlmKCFhcGkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlN0b3JhZ2Ugbm90IGF2YWlsYWJsZS4nKTtcbiAgfVxuXG4gIHZhciBydmFsO1xuICBpZihvYmogPT09IG51bGwpIHtcbiAgICBydmFsID0gYXBpLnJlbW92ZUl0ZW0oaWQpO1xuICB9IGVsc2Uge1xuICAgIC8vIGpzb24tZW5jb2RlIGFuZCBiYXNlNjQtZW5jb2RlIG9iamVjdFxuICAgIG9iaiA9IHV0aWwuZW5jb2RlNjQoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gICAgcnZhbCA9IGFwaS5zZXRJdGVtKGlkLCBvYmopO1xuICB9XG5cbiAgLy8gaGFuZGxlIHBvdGVudGlhbCBmbGFzaCBlcnJvclxuICBpZih0eXBlb2YocnZhbCkgIT09ICd1bmRlZmluZWQnICYmIHJ2YWwucnZhbCAhPT0gdHJ1ZSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihydmFsLmVycm9yLm1lc3NhZ2UpO1xuICAgIGVycm9yLmlkID0gcnZhbC5lcnJvci5pZDtcbiAgICBlcnJvci5uYW1lID0gcnZhbC5lcnJvci5uYW1lO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vKipcbiAqIEdldHMgYSBzdG9yYWdlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgc3RvcmFnZSBvYmplY3QgZW50cnkgb3IgbnVsbCBpZiBub25lIGV4aXN0cy5cbiAqL1xudmFyIF9nZXRTdG9yYWdlT2JqZWN0ID0gZnVuY3Rpb24oYXBpLCBpZCkge1xuICBpZighYXBpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTdG9yYWdlIG5vdCBhdmFpbGFibGUuJyk7XG4gIH1cblxuICAvLyBnZXQgdGhlIGV4aXN0aW5nIGVudHJ5XG4gIHZhciBydmFsID0gYXBpLmdldEl0ZW0oaWQpO1xuXG4gIC8qIE5vdGU6IFdlIGNoZWNrIGFwaS5pbml0IGJlY2F1c2Ugd2UgY2FuJ3QgZG8gKGFwaSA9PSBsb2NhbFN0b3JhZ2UpXG4gICAgb24gSUUgYmVjYXVzZSBvZiBcIkNsYXNzIGRvZXNuJ3Qgc3VwcG9ydCBBdXRvbWF0aW9uXCIgZXhjZXB0aW9uLiBPbmx5XG4gICAgdGhlIGZsYXNoIGFwaSBoYXMgYW4gaW5pdCBtZXRob2Qgc28gdGhpcyB3b3JrcyB0b28sIGJ1dCB3ZSBuZWVkIGFcbiAgICBiZXR0ZXIgc29sdXRpb24gaW4gdGhlIGZ1dHVyZS4gKi9cblxuICAvLyBmbGFzaCByZXR1cm5zIGl0ZW0gd3JhcHBlZCBpbiBhbiBvYmplY3QsIGhhbmRsZSBzcGVjaWFsIGNhc2VcbiAgaWYoYXBpLmluaXQpIHtcbiAgICBpZihydmFsLnJ2YWwgPT09IG51bGwpIHtcbiAgICAgIGlmKHJ2YWwuZXJyb3IpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKHJ2YWwuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIGVycm9yLmlkID0gcnZhbC5lcnJvci5pZDtcbiAgICAgICAgZXJyb3IubmFtZSA9IHJ2YWwuZXJyb3IubmFtZTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICAvLyBubyBlcnJvciwgYnV0IGFsc28gbm8gaXRlbVxuICAgICAgcnZhbCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ2YWwgPSBydmFsLnJ2YWw7XG4gICAgfVxuICB9XG5cbiAgLy8gaGFuZGxlIGRlY29kaW5nXG4gIGlmKHJ2YWwgIT09IG51bGwpIHtcbiAgICAvLyBiYXNlNjQtZGVjb2RlIGFuZCBqc29uLWRlY29kZSBkYXRhXG4gICAgcnZhbCA9IEpTT04ucGFyc2UodXRpbC5kZWNvZGU2NChydmFsKSk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogU3RvcmVzIGFuIGl0ZW0gaW4gbG9jYWwgc3RvcmFnZS5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICogQHBhcmFtIGRhdGEgdGhlIGRhdGEgZm9yIHRoZSBpdGVtIChhbnkgamF2YXNjcmlwdCBvYmplY3QvcHJpbWl0aXZlKS5cbiAqL1xudmFyIF9zZXRJdGVtID0gZnVuY3Rpb24oYXBpLCBpZCwga2V5LCBkYXRhKSB7XG4gIC8vIGdldCBzdG9yYWdlIG9iamVjdFxuICB2YXIgb2JqID0gX2dldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCk7XG4gIGlmKG9iaiA9PT0gbnVsbCkge1xuICAgIC8vIGNyZWF0ZSBhIG5ldyBzdG9yYWdlIG9iamVjdFxuICAgIG9iaiA9IHt9O1xuICB9XG4gIC8vIHVwZGF0ZSBrZXlcbiAgb2JqW2tleV0gPSBkYXRhO1xuXG4gIC8vIHNldCBzdG9yYWdlIG9iamVjdFxuICBfc2V0U3RvcmFnZU9iamVjdChhcGksIGlkLCBvYmopO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIGl0ZW0gZnJvbSBsb2NhbCBzdG9yYWdlLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKlxuICogQHJldHVybiB0aGUgaXRlbS5cbiAqL1xudmFyIF9nZXRJdGVtID0gZnVuY3Rpb24oYXBpLCBpZCwga2V5KSB7XG4gIC8vIGdldCBzdG9yYWdlIG9iamVjdFxuICB2YXIgcnZhbCA9IF9nZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQpO1xuICBpZihydmFsICE9PSBudWxsKSB7XG4gICAgLy8gcmV0dXJuIGRhdGEgYXQga2V5XG4gICAgcnZhbCA9IChrZXkgaW4gcnZhbCkgPyBydmFsW2tleV0gOiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIGxvY2FsIHN0b3JhZ2UuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqL1xudmFyIF9yZW1vdmVJdGVtID0gZnVuY3Rpb24oYXBpLCBpZCwga2V5KSB7XG4gIC8vIGdldCBzdG9yYWdlIG9iamVjdFxuICB2YXIgb2JqID0gX2dldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCk7XG4gIGlmKG9iaiAhPT0gbnVsbCAmJiBrZXkgaW4gb2JqKSB7XG4gICAgLy8gcmVtb3ZlIGtleVxuICAgIGRlbGV0ZSBvYmpba2V5XTtcblxuICAgIC8vIHNlZSBpZiBlbnRyeSBoYXMgbm8ga2V5cyByZW1haW5pbmdcbiAgICB2YXIgZW1wdHkgPSB0cnVlO1xuICAgIGZvcih2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYoZW1wdHkpIHtcbiAgICAgIC8vIHJlbW92ZSBlbnRyeSBlbnRpcmVseSBpZiBubyBrZXlzIGFyZSBsZWZ0XG4gICAgICBvYmogPSBudWxsO1xuICAgIH1cblxuICAgIC8vIHNldCBzdG9yYWdlIG9iamVjdFxuICAgIF9zZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQsIG9iaik7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBsb2NhbCBkaXNrIHN0b3JhZ2UgaWRlbnRpZmllZCBieSB0aGUgZ2l2ZW4gSUQuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICovXG52YXIgX2NsZWFySXRlbXMgPSBmdW5jdGlvbihhcGksIGlkKSB7XG4gIF9zZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQsIG51bGwpO1xufTtcblxuLyoqXG4gKiBDYWxscyBhIHN0b3JhZ2UgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIGZ1bmMgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gKiBAcGFyYW0gYXJncyB0aGUgYXJndW1lbnRzIGZvciB0aGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0gbG9jYXRpb24gdGhlIGxvY2F0aW9uIGFyZ3VtZW50LlxuICpcbiAqIEByZXR1cm4gdGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBmdW5jdGlvbi5cbiAqL1xudmFyIF9jYWxsU3RvcmFnZUZ1bmN0aW9uID0gZnVuY3Rpb24oZnVuYywgYXJncywgbG9jYXRpb24pIHtcbiAgdmFyIHJ2YWwgPSBudWxsO1xuXG4gIC8vIGRlZmF1bHQgc3RvcmFnZSB0eXBlc1xuICBpZih0eXBlb2YobG9jYXRpb24pID09PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2F0aW9uID0gWyd3ZWInLCAnZmxhc2gnXTtcbiAgfVxuXG4gIC8vIGFwcGx5IHN0b3JhZ2UgdHlwZXMgaW4gb3JkZXIgb2YgcHJlZmVyZW5jZVxuICB2YXIgdHlwZTtcbiAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgdmFyIGV4Y2VwdGlvbiA9IG51bGw7XG4gIGZvcih2YXIgaWR4IGluIGxvY2F0aW9uKSB7XG4gICAgdHlwZSA9IGxvY2F0aW9uW2lkeF07XG4gICAgdHJ5IHtcbiAgICAgIGlmKHR5cGUgPT09ICdmbGFzaCcgfHwgdHlwZSA9PT0gJ2JvdGgnKSB7XG4gICAgICAgIGlmKGFyZ3NbMF0gPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZsYXNoIGxvY2FsIHN0b3JhZ2Ugbm90IGF2YWlsYWJsZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBydmFsID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgZG9uZSA9ICh0eXBlID09PSAnZmxhc2gnKTtcbiAgICAgIH1cbiAgICAgIGlmKHR5cGUgPT09ICd3ZWInIHx8IHR5cGUgPT09ICdib3RoJykge1xuICAgICAgICBhcmdzWzBdID0gbG9jYWxTdG9yYWdlO1xuICAgICAgICBydmFsID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaChleCkge1xuICAgICAgZXhjZXB0aW9uID0gZXg7XG4gICAgfVxuICAgIGlmKGRvbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmKCFkb25lKSB7XG4gICAgdGhyb3cgZXhjZXB0aW9uO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIFN0b3JlcyBhbiBpdGVtIG9uIGxvY2FsIGRpc2suXG4gKlxuICogVGhlIGF2YWlsYWJsZSB0eXBlcyBvZiBsb2NhbCBzdG9yYWdlIGluY2x1ZGUgJ2ZsYXNoJywgJ3dlYicsIGFuZCAnYm90aCcuXG4gKlxuICogVGhlIHR5cGUgJ2ZsYXNoJyByZWZlcnMgdG8gZmxhc2ggbG9jYWwgc3RvcmFnZSAoU2hhcmVkT2JqZWN0KS4gSW4gb3JkZXJcbiAqIHRvIHVzZSBmbGFzaCBsb2NhbCBzdG9yYWdlLCB0aGUgJ2FwaScgcGFyYW1ldGVyIG11c3QgYmUgdmFsaWQuIFRoZSB0eXBlXG4gKiAnd2ViJyByZWZlcnMgdG8gV2ViU3RvcmFnZSwgaWYgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLiBUaGUgdHlwZSAnYm90aCdcbiAqIHJlZmVycyB0byBzdG9yaW5nIHVzaW5nIGJvdGggJ2ZsYXNoJyBhbmQgJ3dlYicsIG5vdCBqdXN0IG9uZSBvciB0aGVcbiAqIG90aGVyLlxuICpcbiAqIFRoZSBsb2NhdGlvbiBhcnJheSBzaG91bGQgbGlzdCB0aGUgc3RvcmFnZSB0eXBlcyB0byB1c2UgaW4gb3JkZXIgb2ZcbiAqIHByZWZlcmVuY2U6XG4gKlxuICogWydmbGFzaCddOiBmbGFzaCBvbmx5IHN0b3JhZ2VcbiAqIFsnd2ViJ106IHdlYiBvbmx5IHN0b3JhZ2VcbiAqIFsnYm90aCddOiB0cnkgdG8gc3RvcmUgaW4gYm90aFxuICogWydmbGFzaCcsJ3dlYiddOiBzdG9yZSBpbiBmbGFzaCBmaXJzdCwgYnV0IGlmIG5vdCBhdmFpbGFibGUsICd3ZWInXG4gKiBbJ3dlYicsJ2ZsYXNoJ106IHN0b3JlIGluIHdlYiBmaXJzdCwgYnV0IGlmIG5vdCBhdmFpbGFibGUsICdmbGFzaCdcbiAqXG4gKiBUaGUgbG9jYXRpb24gYXJyYXkgZGVmYXVsdHMgdG86IFsnd2ViJywgJ2ZsYXNoJ11cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UsIG51bGwgdG8gdXNlIG9ubHkgV2ViU3RvcmFnZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICogQHBhcmFtIGRhdGEgdGhlIGRhdGEgZm9yIHRoZSBpdGVtIChhbnkgamF2YXNjcmlwdCBvYmplY3QvcHJpbWl0aXZlKS5cbiAqIEBwYXJhbSBsb2NhdGlvbiBhbiBhcnJheSB3aXRoIHRoZSBwcmVmZXJyZWQgdHlwZXMgb2Ygc3RvcmFnZSB0byB1c2UuXG4gKi9cbnV0aWwuc2V0SXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSwgZGF0YSwgbG9jYXRpb24pIHtcbiAgX2NhbGxTdG9yYWdlRnVuY3Rpb24oX3NldEl0ZW0sIGFyZ3VtZW50cywgbG9jYXRpb24pO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIGl0ZW0gb24gbG9jYWwgZGlzay5cbiAqXG4gKiBTZXQgc2V0SXRlbSgpIGZvciBkZXRhaWxzIG9uIHN0b3JhZ2UgdHlwZXMuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgZmxhc2ggaW50ZXJmYWNlLCBudWxsIHRvIHVzZSBvbmx5IFdlYlN0b3JhZ2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqIEBwYXJhbSBsb2NhdGlvbiBhbiBhcnJheSB3aXRoIHRoZSBwcmVmZXJyZWQgdHlwZXMgb2Ygc3RvcmFnZSB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgaXRlbS5cbiAqL1xudXRpbC5nZXRJdGVtID0gZnVuY3Rpb24oYXBpLCBpZCwga2V5LCBsb2NhdGlvbikge1xuICByZXR1cm4gX2NhbGxTdG9yYWdlRnVuY3Rpb24oX2dldEl0ZW0sIGFyZ3VtZW50cywgbG9jYXRpb24pO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIGl0ZW0gb24gbG9jYWwgZGlzay5cbiAqXG4gKiBTZXQgc2V0SXRlbSgpIGZvciBkZXRhaWxzIG9uIHN0b3JhZ2UgdHlwZXMuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgZmxhc2ggaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKiBAcGFyYW0gbG9jYXRpb24gYW4gYXJyYXkgd2l0aCB0aGUgcHJlZmVycmVkIHR5cGVzIG9mIHN0b3JhZ2UgdG8gdXNlLlxuICovXG51dGlsLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXksIGxvY2F0aW9uKSB7XG4gIF9jYWxsU3RvcmFnZUZ1bmN0aW9uKF9yZW1vdmVJdGVtLCBhcmd1bWVudHMsIGxvY2F0aW9uKTtcbn07XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBsb2NhbCBkaXNrIHN0b3JhZ2UgaWRlbnRpZmllZCBieSB0aGUgZ2l2ZW4gSUQuXG4gKlxuICogU2V0IHNldEl0ZW0oKSBmb3IgZGV0YWlscyBvbiBzdG9yYWdlIHR5cGVzLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZSBpZiBmbGFzaCBpcyBhdmFpbGFibGUuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGxvY2F0aW9uIGFuIGFycmF5IHdpdGggdGhlIHByZWZlcnJlZCB0eXBlcyBvZiBzdG9yYWdlIHRvIHVzZS5cbiAqL1xudXRpbC5jbGVhckl0ZW1zID0gZnVuY3Rpb24oYXBpLCBpZCwgbG9jYXRpb24pIHtcbiAgX2NhbGxTdG9yYWdlRnVuY3Rpb24oX2NsZWFySXRlbXMsIGFyZ3VtZW50cywgbG9jYXRpb24pO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgZW1wdHkuXG4gKlxuICogVGFrZW4gZnJvbTpcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjc5OTE1L2hvdy1kby1pLXRlc3QtZm9yLWFuLWVtcHR5LWphdmFzY3JpcHQtb2JqZWN0LWZyb20tanNvbi82Nzk5MzcjNjc5OTM3XG4gKlxuICogQHBhcmFtIG9iamVjdCB0aGUgb2JqZWN0IHRvIGNoZWNrLlxuICovXG51dGlsLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgZm9yKHZhciBwcm9wIGluIG9iaikge1xuICAgIGlmKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogRm9ybWF0IHdpdGggc2ltcGxlIHByaW50Zi1zdHlsZSBpbnRlcnBvbGF0aW9uLlxuICpcbiAqICUlOiBsaXRlcmFsICclJ1xuICogJXMsJW86IGNvbnZlcnQgbmV4dCBhcmd1bWVudCBpbnRvIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBmb3JtYXQgdGhlIHN0cmluZyB0byBmb3JtYXQuXG4gKiBAcGFyYW0gLi4uIGFyZ3VtZW50cyB0byBpbnRlcnBvbGF0ZSBpbnRvIHRoZSBmb3JtYXQgc3RyaW5nLlxuICovXG51dGlsLmZvcm1hdCA9IGZ1bmN0aW9uKGZvcm1hdCkge1xuICB2YXIgcmUgPSAvJS4vZztcbiAgLy8gY3VycmVudCBtYXRjaFxuICB2YXIgbWF0Y2g7XG4gIC8vIGN1cnJlbnQgcGFydFxuICB2YXIgcGFydDtcbiAgLy8gY3VycmVudCBhcmcgaW5kZXhcbiAgdmFyIGFyZ2kgPSAwO1xuICAvLyBjb2xsZWN0ZWQgcGFydHMgdG8gcmVjb21iaW5lIGxhdGVyXG4gIHZhciBwYXJ0cyA9IFtdO1xuICAvLyBsYXN0IGluZGV4IGZvdW5kXG4gIHZhciBsYXN0ID0gMDtcbiAgLy8gbG9vcCB3aGlsZSBtYXRjaGVzIHJlbWFpblxuICB3aGlsZSgobWF0Y2ggPSByZS5leGVjKGZvcm1hdCkpKSB7XG4gICAgcGFydCA9IGZvcm1hdC5zdWJzdHJpbmcobGFzdCwgcmUubGFzdEluZGV4IC0gMik7XG4gICAgLy8gZG9uJ3QgYWRkIGVtcHR5IHN0cmluZ3MgKGllLCBwYXJ0cyBiZXR3ZWVuICVzJXMpXG4gICAgaWYocGFydC5sZW5ndGggPiAwKSB7XG4gICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgIH1cbiAgICBsYXN0ID0gcmUubGFzdEluZGV4O1xuICAgIC8vIHN3aXRjaCBvbiAlIGNvZGVcbiAgICB2YXIgY29kZSA9IG1hdGNoWzBdWzFdO1xuICAgIHN3aXRjaChjb2RlKSB7XG4gICAgY2FzZSAncyc6XG4gICAgY2FzZSAnbyc6XG4gICAgICAvLyBjaGVjayBpZiBlbm91Z2ggYXJndW1lbnRzIHdlcmUgZ2l2ZW5cbiAgICAgIGlmKGFyZ2kgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYXJndW1lbnRzW2FyZ2krKyArIDFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnB1c2goJzw/PicpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgLy8gRklYTUU6IGRvIHByb3BlciBmb3JtYXRpbmcgZm9yIG51bWJlcnMsIGV0Y1xuICAgIC8vY2FzZSAnZic6XG4gICAgLy9jYXNlICdkJzpcbiAgICBjYXNlICclJzpcbiAgICAgIHBhcnRzLnB1c2goJyUnKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwYXJ0cy5wdXNoKCc8JScgKyBjb2RlICsgJz8+Jyk7XG4gICAgfVxuICB9XG4gIC8vIGFkZCB0cmFpbGluZyBwYXJ0IG9mIGZvcm1hdCBzdHJpbmdcbiAgcGFydHMucHVzaChmb3JtYXQuc3Vic3RyaW5nKGxhc3QpKTtcbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIGEgbnVtYmVyLlxuICpcbiAqIGh0dHA6Ly9zbmlwcGxyLmNvbS92aWV3LzU5NDUvamF2YXNjcmlwdC1udW1iZXJmb3JtYXQtLXBvcnRlZC1mcm9tLXBocC9cbiAqL1xudXRpbC5mb3JtYXROdW1iZXIgPSBmdW5jdGlvbihudW1iZXIsIGRlY2ltYWxzLCBkZWNfcG9pbnQsIHRob3VzYW5kc19zZXApIHtcbiAgLy8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcbiAgLy8gKyAgIG9yaWdpbmFsIGJ5OiBKb25hcyBSYW9uaSBTb2FyZXMgU2lsdmEgKGh0dHA6Ly93d3cuanNmcm9taGVsbC5jb20pXG4gIC8vICsgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gIC8vICsgICAgIGJ1Z2ZpeCBieTogTWljaGFlbCBXaGl0ZSAoaHR0cDovL2NyZXN0aWRnLmNvbSlcbiAgLy8gKyAgICAgYnVnZml4IGJ5OiBCZW5qYW1pbiBMdXB0b25cbiAgLy8gKyAgICAgYnVnZml4IGJ5OiBBbGxhbiBKZW5zZW4gKGh0dHA6Ly93d3cud2ludGVybmV0Lm5vKVxuICAvLyArICAgIHJldmlzZWQgYnk6IEpvbmFzIFJhb25pIFNvYXJlcyBTaWx2YSAoaHR0cDovL3d3dy5qc2Zyb21oZWxsLmNvbSlcbiAgLy8gKiAgICAgZXhhbXBsZSAxOiBudW1iZXJfZm9ybWF0KDEyMzQuNTY3OCwgMiwgJy4nLCAnJyk7XG4gIC8vICogICAgIHJldHVybnMgMTogMTIzNC41N1xuXG4gIHZhciBuID0gbnVtYmVyLCBjID0gaXNOYU4oZGVjaW1hbHMgPSBNYXRoLmFicyhkZWNpbWFscykpID8gMiA6IGRlY2ltYWxzO1xuICB2YXIgZCA9IGRlY19wb2ludCA9PT0gdW5kZWZpbmVkID8gJywnIDogZGVjX3BvaW50O1xuICB2YXIgdCA9IHRob3VzYW5kc19zZXAgPT09IHVuZGVmaW5lZCA/XG4gICAnLicgOiB0aG91c2FuZHNfc2VwLCBzID0gbiA8IDAgPyAnLScgOiAnJztcbiAgdmFyIGkgPSBwYXJzZUludCgobiA9IE1hdGguYWJzKCtuIHx8IDApLnRvRml4ZWQoYykpLCAxMCkgKyAnJztcbiAgdmFyIGogPSAoaS5sZW5ndGggPiAzKSA/IGkubGVuZ3RoICUgMyA6IDA7XG4gIHJldHVybiBzICsgKGogPyBpLnN1YnN0cigwLCBqKSArIHQgOiAnJykgK1xuICAgIGkuc3Vic3RyKGopLnJlcGxhY2UoLyhcXGR7M30pKD89XFxkKS9nLCAnJDEnICsgdCkgK1xuICAgIChjID8gZCArIE1hdGguYWJzKG4gLSBpKS50b0ZpeGVkKGMpLnNsaWNlKDIpIDogJycpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIGEgYnl0ZSBzaXplLlxuICpcbiAqIGh0dHA6Ly9zbmlwcGxyLmNvbS92aWV3LzU5NDkvZm9ybWF0LWh1bWFuaXplLWZpbGUtYnl0ZS1zaXplLXByZXNlbnRhdGlvbi1pbi1qYXZhc2NyaXB0L1xuICovXG51dGlsLmZvcm1hdFNpemUgPSBmdW5jdGlvbihzaXplKSB7XG4gIGlmKHNpemUgPj0gMTA3Mzc0MTgyNCkge1xuICAgIHNpemUgPSB1dGlsLmZvcm1hdE51bWJlcihzaXplIC8gMTA3Mzc0MTgyNCwgMiwgJy4nLCAnJykgKyAnIEdpQic7XG4gIH0gZWxzZSBpZihzaXplID49IDEwNDg1NzYpIHtcbiAgICBzaXplID0gdXRpbC5mb3JtYXROdW1iZXIoc2l6ZSAvIDEwNDg1NzYsIDIsICcuJywgJycpICsgJyBNaUInO1xuICB9IGVsc2UgaWYoc2l6ZSA+PSAxMDI0KSB7XG4gICAgc2l6ZSA9IHV0aWwuZm9ybWF0TnVtYmVyKHNpemUgLyAxMDI0LCAwKSArICcgS2lCJztcbiAgfSBlbHNlIHtcbiAgICBzaXplID0gdXRpbC5mb3JtYXROdW1iZXIoc2l6ZSwgMCkgKyAnIGJ5dGVzJztcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gSVB2NCBvciBJUHY2IHN0cmluZyByZXByZXNlbnRhdGlvbiBpbnRvIGJ5dGVzIChpbiBuZXR3b3JrIG9yZGVyKS5cbiAqXG4gKiBAcGFyYW0gaXAgdGhlIElQdjQgb3IgSVB2NiBhZGRyZXNzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgNC1ieXRlIElQdjYgb3IgMTYtYnl0ZSBJUHY2IGFkZHJlc3Mgb3IgbnVsbCBpZiB0aGUgYWRkcmVzcyBjYW4ndFxuICogICAgICAgICBiZSBwYXJzZWQuXG4gKi9cbnV0aWwuYnl0ZXNGcm9tSVAgPSBmdW5jdGlvbihpcCkge1xuICBpZihpcC5pbmRleE9mKCcuJykgIT09IC0xKSB7XG4gICAgcmV0dXJuIHV0aWwuYnl0ZXNGcm9tSVB2NChpcCk7XG4gIH1cbiAgaWYoaXAuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgIHJldHVybiB1dGlsLmJ5dGVzRnJvbUlQdjYoaXApO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBJUHY0IHN0cmluZyByZXByZXNlbnRhdGlvbiBpbnRvIGJ5dGVzIChpbiBuZXR3b3JrIG9yZGVyKS5cbiAqXG4gKiBAcGFyYW0gaXAgdGhlIElQdjQgYWRkcmVzcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIDQtYnl0ZSBhZGRyZXNzIG9yIG51bGwgaWYgdGhlIGFkZHJlc3MgY2FuJ3QgYmUgcGFyc2VkLlxuICovXG51dGlsLmJ5dGVzRnJvbUlQdjQgPSBmdW5jdGlvbihpcCkge1xuICBpcCA9IGlwLnNwbGl0KCcuJyk7XG4gIGlmKGlwLmxlbmd0aCAhPT0gNCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBiID0gdXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlwLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIG51bSA9IHBhcnNlSW50KGlwW2ldLCAxMCk7XG4gICAgaWYoaXNOYU4obnVtKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGIucHV0Qnl0ZShudW0pO1xuICB9XG4gIHJldHVybiBiLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIElQdjYgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGludG8gYnl0ZXMgKGluIG5ldHdvcmsgb3JkZXIpLlxuICpcbiAqIEBwYXJhbSBpcCB0aGUgSVB2NiBhZGRyZXNzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgMTYtYnl0ZSBhZGRyZXNzIG9yIG51bGwgaWYgdGhlIGFkZHJlc3MgY2FuJ3QgYmUgcGFyc2VkLlxuICovXG51dGlsLmJ5dGVzRnJvbUlQdjYgPSBmdW5jdGlvbihpcCkge1xuICB2YXIgYmxhbmtzID0gMDtcbiAgaXAgPSBpcC5zcGxpdCgnOicpLmZpbHRlcihmdW5jdGlvbihlKSB7XG4gICAgaWYoZS5sZW5ndGggPT09IDApICsrYmxhbmtzO1xuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbiAgdmFyIHplcm9zID0gKDggLSBpcC5sZW5ndGggKyBibGFua3MpICogMjtcbiAgdmFyIGIgPSB1dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgODsgKytpKSB7XG4gICAgaWYoIWlwW2ldIHx8IGlwW2ldLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYi5maWxsV2l0aEJ5dGUoMCwgemVyb3MpO1xuICAgICAgemVyb3MgPSAwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBieXRlcyA9IHV0aWwuaGV4VG9CeXRlcyhpcFtpXSk7XG4gICAgaWYoYnl0ZXMubGVuZ3RoIDwgMikge1xuICAgICAgYi5wdXRCeXRlKDApO1xuICAgIH1cbiAgICBiLnB1dEJ5dGVzKGJ5dGVzKTtcbiAgfVxuICByZXR1cm4gYi5nZXRCeXRlcygpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyA0LWJ5dGVzIGludG8gYW4gSVB2NCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb3IgMTYtYnl0ZXMgaW50b1xuICogYW4gSVB2NiBzdHJpbmcgcmVwcmVzZW50YXRpb24uIFRoZSBieXRlcyBtdXN0IGJlIGluIG5ldHdvcmsgb3JkZXIuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIElQdjQgb3IgSVB2NiBzdHJpbmcgcmVwcmVzZW50YXRpb24gaWYgNCBvciAxNiBieXRlcyxcbiAqICAgICAgICAgcmVzcGVjdGl2ZWx5LCBhcmUgZ2l2ZW4sIG90aGVyd2lzZSBudWxsLlxuICovXG51dGlsLmJ5dGVzVG9JUCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIGlmKGJ5dGVzLmxlbmd0aCA9PT0gNCkge1xuICAgIHJldHVybiB1dGlsLmJ5dGVzVG9JUHY0KGJ5dGVzKTtcbiAgfVxuICBpZihieXRlcy5sZW5ndGggPT09IDE2KSB7XG4gICAgcmV0dXJuIHV0aWwuYnl0ZXNUb0lQdjYoYnl0ZXMpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyA0LWJ5dGVzIGludG8gYW4gSVB2NCBzdHJpbmcgcmVwcmVzZW50YXRpb24uIFRoZSBieXRlcyBtdXN0IGJlXG4gKiBpbiBuZXR3b3JrIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBJUHY0IHN0cmluZyByZXByZXNlbnRhdGlvbiBvciBudWxsIGZvciBhbiBpbnZhbGlkICMgb2YgYnl0ZXMuXG4gKi9cbnV0aWwuYnl0ZXNUb0lQdjQgPSBmdW5jdGlvbihieXRlcykge1xuICBpZihieXRlcy5sZW5ndGggIT09IDQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgaXAgPSBbXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgaXAucHVzaChieXRlcy5jaGFyQ29kZUF0KGkpKTtcbiAgfVxuICByZXR1cm4gaXAuam9pbignLicpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyAxNi1ieXRlcyBpbnRvIGFuIElQdjE2IHN0cmluZyByZXByZXNlbnRhdGlvbi4gVGhlIGJ5dGVzIG11c3QgYmVcbiAqIGluIG5ldHdvcmsgb3JkZXIuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIElQdjE2IHN0cmluZyByZXByZXNlbnRhdGlvbiBvciBudWxsIGZvciBhbiBpbnZhbGlkICMgb2YgYnl0ZXMuXG4gKi9cbnV0aWwuYnl0ZXNUb0lQdjYgPSBmdW5jdGlvbihieXRlcykge1xuICBpZihieXRlcy5sZW5ndGggIT09IDE2KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGlwID0gW107XG4gIHZhciB6ZXJvR3JvdXBzID0gW107XG4gIHZhciB6ZXJvTWF4R3JvdXAgPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgaGV4ID0gdXRpbC5ieXRlc1RvSGV4KGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdKTtcbiAgICAvLyBjYW5vbmljYWxpemUgemVybyByZXByZXNlbnRhdGlvblxuICAgIHdoaWxlKGhleFswXSA9PT0gJzAnICYmIGhleCAhPT0gJzAnKSB7XG4gICAgICBoZXggPSBoZXguc3Vic3RyKDEpO1xuICAgIH1cbiAgICBpZihoZXggPT09ICcwJykge1xuICAgICAgdmFyIGxhc3QgPSB6ZXJvR3JvdXBzW3plcm9Hcm91cHMubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgaWR4ID0gaXAubGVuZ3RoO1xuICAgICAgaWYoIWxhc3QgfHwgaWR4ICE9PSBsYXN0LmVuZCArIDEpIHtcbiAgICAgICAgemVyb0dyb3Vwcy5wdXNoKHtzdGFydDogaWR4LCBlbmQ6IGlkeH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdC5lbmQgPSBpZHg7XG4gICAgICAgIGlmKChsYXN0LmVuZCAtIGxhc3Quc3RhcnQpID5cbiAgICAgICAgICAoemVyb0dyb3Vwc1t6ZXJvTWF4R3JvdXBdLmVuZCAtIHplcm9Hcm91cHNbemVyb01heEdyb3VwXS5zdGFydCkpIHtcbiAgICAgICAgICB6ZXJvTWF4R3JvdXAgPSB6ZXJvR3JvdXBzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaXAucHVzaChoZXgpO1xuICB9XG4gIGlmKHplcm9Hcm91cHMubGVuZ3RoID4gMCkge1xuICAgIHZhciBncm91cCA9IHplcm9Hcm91cHNbemVyb01heEdyb3VwXTtcbiAgICAvLyBvbmx5IHNob3J0ZW4gZ3JvdXAgb2YgbGVuZ3RoID4gMFxuICAgIGlmKGdyb3VwLmVuZCAtIGdyb3VwLnN0YXJ0ID4gMCkge1xuICAgICAgaXAuc3BsaWNlKGdyb3VwLnN0YXJ0LCBncm91cC5lbmQgLSBncm91cC5zdGFydCArIDEsICcnKTtcbiAgICAgIGlmKGdyb3VwLnN0YXJ0ID09PSAwKSB7XG4gICAgICAgIGlwLnVuc2hpZnQoJycpO1xuICAgICAgfVxuICAgICAgaWYoZ3JvdXAuZW5kID09PSA3KSB7XG4gICAgICAgIGlwLnB1c2goJycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaXAuam9pbignOicpO1xufTtcblxuLyoqXG4gKiBFc3RpbWF0ZXMgdGhlIG51bWJlciBvZiBwcm9jZXNzZXMgdGhhdCBjYW4gYmUgcnVuIGNvbmN1cnJlbnRseS4gSWZcbiAqIGNyZWF0aW5nIFdlYiBXb3JrZXJzLCBrZWVwIGluIG1pbmQgdGhhdCB0aGUgbWFpbiBKYXZhU2NyaXB0IHByb2Nlc3MgbmVlZHNcbiAqIGl0cyBvd24gY29yZS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICB1cGRhdGUgdHJ1ZSB0byBmb3JjZSBhbiB1cGRhdGUgKG5vdCB1c2UgdGhlIGNhY2hlZCB2YWx1ZSkuXG4gKiBAcGFyYW0gY2FsbGJhY2soZXJyLCBtYXgpIGNhbGxlZCBvbmNlIHRoZSBvcGVyYXRpb24gY29tcGxldGVzLlxuICovXG51dGlsLmVzdGltYXRlQ29yZXMgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmKCdjb3JlcycgaW4gdXRpbCAmJiAhb3B0aW9ucy51cGRhdGUpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdXRpbC5jb3Jlcyk7XG4gIH1cbiAgaWYodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAnaGFyZHdhcmVDb25jdXJyZW5jeScgaW4gbmF2aWdhdG9yICYmXG4gICAgbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgPiAwKSB7XG4gICAgdXRpbC5jb3JlcyA9IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgfVxuICBpZih0eXBlb2YgV29ya2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIHdvcmtlcnMgbm90IGF2YWlsYWJsZVxuICAgIHV0aWwuY29yZXMgPSAxO1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgfVxuICBpZih0eXBlb2YgQmxvYiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBjYW4ndCBlc3RpbWF0ZSwgZGVmYXVsdCB0byAyXG4gICAgdXRpbC5jb3JlcyA9IDI7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICB9XG5cbiAgLy8gY3JlYXRlIHdvcmtlciBjb25jdXJyZW5jeSBlc3RpbWF0aW9uIGNvZGUgYXMgYmxvYlxuICB2YXIgYmxvYlVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoWycoJyxcbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gcnVuIHdvcmtlciBmb3IgNCBtc1xuICAgICAgICB2YXIgc3QgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgZXQgPSBzdCArIDQ7XG4gICAgICAgIHdoaWxlKERhdGUubm93KCkgPCBldCk7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe3N0OiBzdCwgZXQ6IGV0fSk7XG4gICAgICB9KTtcbiAgICB9LnRvU3RyaW5nKCksXG4gICcpKCknXSwge3R5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J30pKTtcblxuICAvLyB0YWtlIDUgc2FtcGxlcyB1c2luZyAxNiB3b3JrZXJzXG4gIHNhbXBsZShbXSwgNSwgMTYpO1xuXG4gIGZ1bmN0aW9uIHNhbXBsZShtYXgsIHNhbXBsZXMsIG51bVdvcmtlcnMpIHtcbiAgICBpZihzYW1wbGVzID09PSAwKSB7XG4gICAgICAvLyBnZXQgb3ZlcmxhcCBhdmVyYWdlXG4gICAgICB2YXIgYXZnID0gTWF0aC5mbG9vcihtYXgucmVkdWNlKGZ1bmN0aW9uKGF2ZywgeCkge1xuICAgICAgICByZXR1cm4gYXZnICsgeDtcbiAgICAgIH0sIDApIC8gbWF4Lmxlbmd0aCk7XG4gICAgICB1dGlsLmNvcmVzID0gTWF0aC5tYXgoMSwgYXZnKTtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVybCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdXRpbC5jb3Jlcyk7XG4gICAgfVxuICAgIG1hcChudW1Xb3JrZXJzLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICAgIG1heC5wdXNoKHJlZHVjZShudW1Xb3JrZXJzLCByZXN1bHRzKSk7XG4gICAgICBzYW1wbGUobWF4LCBzYW1wbGVzIC0gMSwgbnVtV29ya2Vycyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXAobnVtV29ya2VycywgY2FsbGJhY2spIHtcbiAgICB2YXIgd29ya2VycyA9IFtdO1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIoYmxvYlVybCk7XG4gICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGUuZGF0YSk7XG4gICAgICAgIGlmKHJlc3VsdHMubGVuZ3RoID09PSBudW1Xb3JrZXJzKSB7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgICAgICAgd29ya2Vyc1tpXS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgd29ya2Vycy5wdXNoKHdvcmtlcik7XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyArK2kpIHtcbiAgICAgIHdvcmtlcnNbaV0ucG9zdE1lc3NhZ2UoaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVkdWNlKG51bVdvcmtlcnMsIHJlc3VsdHMpIHtcbiAgICAvLyBmaW5kIG92ZXJsYXBwaW5nIHRpbWUgd2luZG93c1xuICAgIHZhciBvdmVybGFwcyA9IFtdO1xuICAgIGZvcih2YXIgbiA9IDA7IG4gPCBudW1Xb3JrZXJzOyArK24pIHtcbiAgICAgIHZhciByMSA9IHJlc3VsdHNbbl07XG4gICAgICB2YXIgb3ZlcmxhcCA9IG92ZXJsYXBzW25dID0gW107XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICAgIGlmKG4gPT09IGkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcjIgPSByZXN1bHRzW2ldO1xuICAgICAgICBpZigocjEuc3QgPiByMi5zdCAmJiByMS5zdCA8IHIyLmV0KSB8fFxuICAgICAgICAgIChyMi5zdCA+IHIxLnN0ICYmIHIyLnN0IDwgcjEuZXQpKSB7XG4gICAgICAgICAgb3ZlcmxhcC5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGdldCBtYXhpbXVtIG92ZXJsYXBzIC4uLiBkb24ndCBpbmNsdWRlIG92ZXJsYXBwaW5nIHdvcmtlciBpdHNlbGZcbiAgICAvLyBhcyB0aGUgbWFpbiBKUyBwcm9jZXNzIHdhcyBhbHNvIGJlaW5nIHNjaGVkdWxlZCBkdXJpbmcgdGhlIHdvcmsgYW5kXG4gICAgLy8gd291bGQgaGF2ZSB0byBiZSBzdWJ0cmFjdGVkIGZyb20gdGhlIGVzdGltYXRlIGFueXdheVxuICAgIHJldHVybiBvdmVybGFwcy5yZWR1Y2UoZnVuY3Rpb24obWF4LCBvdmVybGFwKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgobWF4LCBvdmVybGFwLmxlbmd0aCk7XG4gICAgfSwgMCk7XG4gIH1cbn07XG4iXSwibmFtZXMiOlsiZm9yZ2UiLCJyZXF1aXJlIiwiYmFzZU4iLCJ1dGlsIiwibW9kdWxlIiwiZXhwb3J0cyIsInByb2Nlc3MiLCJuZXh0VGljayIsImJyb3dzZXIiLCJzZXRJbW1lZGlhdGUiLCJhcHBseSIsInVuZGVmaW5lZCIsImFyZ3VtZW50cyIsImNhbGxiYWNrIiwic2V0VGltZW91dCIsIndpbmRvdyIsInBvc3RNZXNzYWdlIiwibXNnIiwiY2FsbGJhY2tzIiwicHVzaCIsImxlbmd0aCIsImhhbmRsZXIiLCJldmVudCIsInNvdXJjZSIsImRhdGEiLCJzdG9wUHJvcGFnYXRpb24iLCJjb3B5Iiwic2xpY2UiLCJmb3JFYWNoIiwiYWRkRXZlbnRMaXN0ZW5lciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJub3ciLCJEYXRlIiwiYXR0ciIsImRpdiIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm9ic2VydmUiLCJhdHRyaWJ1dGVzIiwib2xkU2V0SW1tZWRpYXRlIiwic2V0QXR0cmlidXRlIiwiaXNOb2RlanMiLCJ2ZXJzaW9ucyIsIm5vZGUiLCJnbG9iYWxTY29wZSIsImdsb2JhbCIsInNlbGYiLCJpc0FycmF5IiwiQXJyYXkiLCJ4IiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiaXNBcnJheUJ1ZmZlciIsIkFycmF5QnVmZmVyIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJidWZmZXIiLCJieXRlTGVuZ3RoIiwiX2NoZWNrQml0c1BhcmFtIiwibiIsIkVycm9yIiwiQnl0ZUJ1ZmZlciIsIkJ5dGVTdHJpbmdCdWZmZXIiLCJiIiwicmVhZCIsIkJ1ZmZlciIsImFyciIsIlVpbnQ4QXJyYXkiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJlIiwiaSIsInB1dEJ5dGUiLCJfY29uc3RydWN0ZWRTdHJpbmdMZW5ndGgiLCJfTUFYX0NPTlNUUlVDVEVEX1NUUklOR19MRU5HVEgiLCJfb3B0aW1pemVDb25zdHJ1Y3RlZFN0cmluZyIsInN1YnN0ciIsImlzRW1wdHkiLCJwdXRCeXRlcyIsImZpbGxXaXRoQnl0ZSIsImQiLCJieXRlcyIsInB1dFN0cmluZyIsInN0ciIsImVuY29kZVV0ZjgiLCJwdXRJbnQxNiIsInB1dEludDI0IiwicHV0SW50MzIiLCJwdXRJbnQxNkxlIiwicHV0SW50MjRMZSIsInB1dEludDMyTGUiLCJwdXRJbnQiLCJwdXRTaWduZWRJbnQiLCJwdXRCdWZmZXIiLCJnZXRCeXRlcyIsImdldEJ5dGUiLCJjaGFyQ29kZUF0IiwiZ2V0SW50MTYiLCJydmFsIiwiZ2V0SW50MjQiLCJnZXRJbnQzMiIsImdldEludDE2TGUiLCJnZXRJbnQyNExlIiwiZ2V0SW50MzJMZSIsImdldEludCIsImdldFNpZ25lZEludCIsIm1heCIsImNvdW50IiwiTWF0aCIsIm1pbiIsImNsZWFyIiwiYXQiLCJzZXRBdCIsImxhc3QiLCJjIiwiY3JlYXRlQnVmZmVyIiwiY29tcGFjdCIsInRydW5jYXRlIiwibGVuIiwidG9IZXgiLCJkZWNvZGVVdGY4IiwiRGF0YUJ1ZmZlciIsIm9wdGlvbnMiLCJyZWFkT2Zmc2V0IiwiZ3Jvd1NpemUiLCJEYXRhVmlldyIsImJ5dGVPZmZzZXQiLCJ3cml0ZSIsIndyaXRlT2Zmc2V0IiwiYWNjb21tb2RhdGUiLCJhbW91bnQiLCJzcmMiLCJkc3QiLCJzZXQiLCJzZXRVaW50OCIsImVuY29kaW5nIiwidmlldyIsImNlaWwiLCJiaW5hcnkiLCJoZXgiLCJkZWNvZGUiLCJiYXNlNjQiLCJyYXciLCJVaW50MTZBcnJheSIsInRleHQiLCJ1dGYxNiIsImVuY29kZSIsInNldEludDE2Iiwic2V0SW50OCIsInNldEludDMyIiwiZ2V0SW50OCIsImdldFVpbnQ4IiwidXRmOCIsImlucHV0IiwiZmlsbFN0cmluZyIsInMiLCJ4b3JCeXRlcyIsInMxIiwiczIiLCJzMyIsInQiLCJoZXhUb0J5dGVzIiwicGFyc2VJbnQiLCJieXRlc1RvSGV4IiwiaW50MzJUb0J5dGVzIiwiX2Jhc2U2NCIsIl9iYXNlNjRJZHgiLCJfYmFzZTU4IiwiZW5jb2RlNjQiLCJtYXhsaW5lIiwibGluZSIsIm91dHB1dCIsImNocjEiLCJjaHIyIiwiY2hyMyIsImNoYXJBdCIsImlzTmFOIiwiZGVjb2RlNjQiLCJyZXBsYWNlIiwiZW5jMSIsImVuYzIiLCJlbmMzIiwiZW5jNCIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZXNjYXBlIiwiYmFzZTU4Iiwib2Zmc2V0Iiwib3V0IiwiaiIsInN1YmFycmF5IiwiayIsImRlZmxhdGUiLCJhcGkiLCJzdGFydCIsImZsZyIsInN1YnN0cmluZyIsImluZmxhdGUiLCJfc2V0U3RvcmFnZU9iamVjdCIsImlkIiwib2JqIiwicmVtb3ZlSXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzZXRJdGVtIiwiZXJyb3IiLCJtZXNzYWdlIiwibmFtZSIsIl9nZXRTdG9yYWdlT2JqZWN0IiwiZ2V0SXRlbSIsImluaXQiLCJwYXJzZSIsIl9zZXRJdGVtIiwia2V5IiwiX2dldEl0ZW0iLCJfcmVtb3ZlSXRlbSIsImVtcHR5IiwicHJvcCIsIl9jbGVhckl0ZW1zIiwiX2NhbGxTdG9yYWdlRnVuY3Rpb24iLCJmdW5jIiwiYXJncyIsImxvY2F0aW9uIiwidHlwZSIsImRvbmUiLCJleGNlcHRpb24iLCJpZHgiLCJsb2NhbFN0b3JhZ2UiLCJleCIsImNsZWFySXRlbXMiLCJoYXNPd25Qcm9wZXJ0eSIsImZvcm1hdCIsInJlIiwibWF0Y2giLCJwYXJ0IiwiYXJnaSIsInBhcnRzIiwiZXhlYyIsImxhc3RJbmRleCIsImNvZGUiLCJqb2luIiwiZm9ybWF0TnVtYmVyIiwibnVtYmVyIiwiZGVjaW1hbHMiLCJkZWNfcG9pbnQiLCJ0aG91c2FuZHNfc2VwIiwiYWJzIiwidG9GaXhlZCIsImZvcm1hdFNpemUiLCJzaXplIiwiYnl0ZXNGcm9tSVAiLCJpcCIsImluZGV4T2YiLCJieXRlc0Zyb21JUHY0IiwiYnl0ZXNGcm9tSVB2NiIsInNwbGl0IiwibnVtIiwiYmxhbmtzIiwiZmlsdGVyIiwiemVyb3MiLCJieXRlc1RvSVAiLCJieXRlc1RvSVB2NCIsImJ5dGVzVG9JUHY2IiwiemVyb0dyb3VwcyIsInplcm9NYXhHcm91cCIsImVuZCIsImdyb3VwIiwic3BsaWNlIiwidW5zaGlmdCIsImVzdGltYXRlQ29yZXMiLCJ1cGRhdGUiLCJjb3JlcyIsIm5hdmlnYXRvciIsImhhcmR3YXJlQ29uY3VycmVuY3kiLCJXb3JrZXIiLCJCbG9iIiwiYmxvYlVybCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsInN0IiwiZXQiLCJzYW1wbGUiLCJzYW1wbGVzIiwibnVtV29ya2VycyIsImF2ZyIsImZsb29yIiwicmVkdWNlIiwicmV2b2tlT2JqZWN0VVJMIiwibWFwIiwiZXJyIiwicmVzdWx0cyIsIndvcmtlcnMiLCJ3b3JrZXIiLCJ0ZXJtaW5hdGUiLCJvdmVybGFwcyIsInIxIiwib3ZlcmxhcCIsInIyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-forge/lib/x509.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/x509.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Javascript implementation of X.509 and related components (such as\n * Certification Signing Requests) of a Public Key Infrastructure.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n *\n * The ASN.1 representation of an X.509v3 certificate is as follows\n * (see RFC 2459):\n *\n * Certificate ::= SEQUENCE {\n *   tbsCertificate       TBSCertificate,\n *   signatureAlgorithm   AlgorithmIdentifier,\n *   signatureValue       BIT STRING\n * }\n *\n * TBSCertificate ::= SEQUENCE {\n *   version         [0]  EXPLICIT Version DEFAULT v1,\n *   serialNumber         CertificateSerialNumber,\n *   signature            AlgorithmIdentifier,\n *   issuer               Name,\n *   validity             Validity,\n *   subject              Name,\n *   subjectPublicKeyInfo SubjectPublicKeyInfo,\n *   issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,\n *                        -- If present, version shall be v2 or v3\n *   subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,\n *                        -- If present, version shall be v2 or v3\n *   extensions      [3]  EXPLICIT Extensions OPTIONAL\n *                        -- If present, version shall be v3\n * }\n *\n * Version ::= INTEGER  { v1(0), v2(1), v3(2) }\n *\n * CertificateSerialNumber ::= INTEGER\n *\n * Name ::= CHOICE {\n *   // only one possible choice for now\n *   RDNSequence\n * }\n *\n * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName\n *\n * RelativeDistinguishedName ::= SET OF AttributeTypeAndValue\n *\n * AttributeTypeAndValue ::= SEQUENCE {\n *   type     AttributeType,\n *   value    AttributeValue\n * }\n * AttributeType ::= OBJECT IDENTIFIER\n * AttributeValue ::= ANY DEFINED BY AttributeType\n *\n * Validity ::= SEQUENCE {\n *   notBefore      Time,\n *   notAfter       Time\n * }\n *\n * Time ::= CHOICE {\n *   utcTime        UTCTime,\n *   generalTime    GeneralizedTime\n * }\n *\n * UniqueIdentifier ::= BIT STRING\n *\n * SubjectPublicKeyInfo ::= SEQUENCE {\n *   algorithm            AlgorithmIdentifier,\n *   subjectPublicKey     BIT STRING\n * }\n *\n * Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension\n *\n * Extension ::= SEQUENCE {\n *   extnID      OBJECT IDENTIFIER,\n *   critical    BOOLEAN DEFAULT FALSE,\n *   extnValue   OCTET STRING\n * }\n *\n * The only key algorithm currently supported for PKI is RSA.\n *\n * RSASSA-PSS signatures are described in RFC 3447 and RFC 4055.\n *\n * PKCS#10 v1.7 describes certificate signing requests:\n *\n * CertificationRequestInfo:\n *\n * CertificationRequestInfo ::= SEQUENCE {\n *   version       INTEGER { v1(0) } (v1,...),\n *   subject       Name,\n *   subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},\n *   attributes    [0] Attributes{{ CRIAttributes }}\n * }\n *\n * Attributes { ATTRIBUTE:IOSet } ::= SET OF Attribute{{ IOSet }}\n *\n * CRIAttributes  ATTRIBUTE  ::= {\n *   ... -- add any locally defined attributes here -- }\n *\n * Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {\n *   type   ATTRIBUTE.&id({IOSet}),\n *   values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})\n * }\n *\n * CertificationRequest ::= SEQUENCE {\n *   certificationRequestInfo CertificationRequestInfo,\n *   signatureAlgorithm AlgorithmIdentifier{{ SignatureAlgorithms }},\n *   signature          BIT STRING\n * }\n */ \nvar forge = __webpack_require__(/*! ./forge */ \"(rsc)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! ./aes */ \"(rsc)/./node_modules/node-forge/lib/aes.js\");\n__webpack_require__(/*! ./asn1 */ \"(rsc)/./node_modules/node-forge/lib/asn1.js\");\n__webpack_require__(/*! ./des */ \"(rsc)/./node_modules/node-forge/lib/des.js\");\n__webpack_require__(/*! ./md */ \"(rsc)/./node_modules/node-forge/lib/md.js\");\n__webpack_require__(/*! ./mgf */ \"(rsc)/./node_modules/node-forge/lib/mgf.js\");\n__webpack_require__(/*! ./oids */ \"(rsc)/./node_modules/node-forge/lib/oids.js\");\n__webpack_require__(/*! ./pem */ \"(rsc)/./node_modules/node-forge/lib/pem.js\");\n__webpack_require__(/*! ./pss */ \"(rsc)/./node_modules/node-forge/lib/pss.js\");\n__webpack_require__(/*! ./rsa */ \"(rsc)/./node_modules/node-forge/lib/rsa.js\");\n__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/node-forge/lib/util.js\");\n// shortcut for asn.1 API\nvar asn1 = forge.asn1;\n/* Public Key Infrastructure (PKI) implementation. */ var pki = module.exports = forge.pki = forge.pki || {};\nvar oids = pki.oids;\n// short name OID mappings\nvar _shortNames = {};\n_shortNames[\"CN\"] = oids[\"commonName\"];\n_shortNames[\"commonName\"] = \"CN\";\n_shortNames[\"C\"] = oids[\"countryName\"];\n_shortNames[\"countryName\"] = \"C\";\n_shortNames[\"L\"] = oids[\"localityName\"];\n_shortNames[\"localityName\"] = \"L\";\n_shortNames[\"ST\"] = oids[\"stateOrProvinceName\"];\n_shortNames[\"stateOrProvinceName\"] = \"ST\";\n_shortNames[\"O\"] = oids[\"organizationName\"];\n_shortNames[\"organizationName\"] = \"O\";\n_shortNames[\"OU\"] = oids[\"organizationalUnitName\"];\n_shortNames[\"organizationalUnitName\"] = \"OU\";\n_shortNames[\"E\"] = oids[\"emailAddress\"];\n_shortNames[\"emailAddress\"] = \"E\";\n// validator for an SubjectPublicKeyInfo structure\n// Note: Currently only works with an RSA public key\nvar publicKeyValidator = forge.pki.rsa.publicKeyValidator;\n// validator for an X.509v3 certificate\nvar x509CertificateValidator = {\n    name: \"Certificate\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"Certificate.TBSCertificate\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            captureAsn1: \"tbsCertificate\",\n            value: [\n                {\n                    name: \"Certificate.TBSCertificate.version\",\n                    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n                    type: 0,\n                    constructed: true,\n                    optional: true,\n                    value: [\n                        {\n                            name: \"Certificate.TBSCertificate.version.integer\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.INTEGER,\n                            constructed: false,\n                            capture: \"certVersion\"\n                        }\n                    ]\n                },\n                {\n                    name: \"Certificate.TBSCertificate.serialNumber\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.INTEGER,\n                    constructed: false,\n                    capture: \"certSerialNumber\"\n                },\n                {\n                    name: \"Certificate.TBSCertificate.signature\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.SEQUENCE,\n                    constructed: true,\n                    value: [\n                        {\n                            name: \"Certificate.TBSCertificate.signature.algorithm\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.OID,\n                            constructed: false,\n                            capture: \"certinfoSignatureOid\"\n                        },\n                        {\n                            name: \"Certificate.TBSCertificate.signature.parameters\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            optional: true,\n                            captureAsn1: \"certinfoSignatureParams\"\n                        }\n                    ]\n                },\n                {\n                    name: \"Certificate.TBSCertificate.issuer\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.SEQUENCE,\n                    constructed: true,\n                    captureAsn1: \"certIssuer\"\n                },\n                {\n                    name: \"Certificate.TBSCertificate.validity\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.SEQUENCE,\n                    constructed: true,\n                    // Note: UTC and generalized times may both appear so the capture\n                    // names are based on their detected order, the names used below\n                    // are only for the common case, which validity time really means\n                    // \"notBefore\" and which means \"notAfter\" will be determined by order\n                    value: [\n                        {\n                            // notBefore (Time) (UTC time case)\n                            name: \"Certificate.TBSCertificate.validity.notBefore (utc)\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.UTCTIME,\n                            constructed: false,\n                            optional: true,\n                            capture: \"certValidity1UTCTime\"\n                        },\n                        {\n                            // notBefore (Time) (generalized time case)\n                            name: \"Certificate.TBSCertificate.validity.notBefore (generalized)\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.GENERALIZEDTIME,\n                            constructed: false,\n                            optional: true,\n                            capture: \"certValidity2GeneralizedTime\"\n                        },\n                        {\n                            // notAfter (Time) (only UTC time is supported)\n                            name: \"Certificate.TBSCertificate.validity.notAfter (utc)\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.UTCTIME,\n                            constructed: false,\n                            optional: true,\n                            capture: \"certValidity3UTCTime\"\n                        },\n                        {\n                            // notAfter (Time) (only UTC time is supported)\n                            name: \"Certificate.TBSCertificate.validity.notAfter (generalized)\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.GENERALIZEDTIME,\n                            constructed: false,\n                            optional: true,\n                            capture: \"certValidity4GeneralizedTime\"\n                        }\n                    ]\n                },\n                {\n                    // Name (subject) (RDNSequence)\n                    name: \"Certificate.TBSCertificate.subject\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.SEQUENCE,\n                    constructed: true,\n                    captureAsn1: \"certSubject\"\n                },\n                // SubjectPublicKeyInfo\n                publicKeyValidator,\n                {\n                    // issuerUniqueID (optional)\n                    name: \"Certificate.TBSCertificate.issuerUniqueID\",\n                    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n                    type: 1,\n                    constructed: true,\n                    optional: true,\n                    value: [\n                        {\n                            name: \"Certificate.TBSCertificate.issuerUniqueID.id\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.BITSTRING,\n                            constructed: false,\n                            // TODO: support arbitrary bit length ids\n                            captureBitStringValue: \"certIssuerUniqueId\"\n                        }\n                    ]\n                },\n                {\n                    // subjectUniqueID (optional)\n                    name: \"Certificate.TBSCertificate.subjectUniqueID\",\n                    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n                    type: 2,\n                    constructed: true,\n                    optional: true,\n                    value: [\n                        {\n                            name: \"Certificate.TBSCertificate.subjectUniqueID.id\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.BITSTRING,\n                            constructed: false,\n                            // TODO: support arbitrary bit length ids\n                            captureBitStringValue: \"certSubjectUniqueId\"\n                        }\n                    ]\n                },\n                {\n                    // Extensions (optional)\n                    name: \"Certificate.TBSCertificate.extensions\",\n                    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n                    type: 3,\n                    constructed: true,\n                    captureAsn1: \"certExtensions\",\n                    optional: true\n                }\n            ]\n        },\n        {\n            // AlgorithmIdentifier (signature algorithm)\n            name: \"Certificate.signatureAlgorithm\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    // algorithm\n                    name: \"Certificate.signatureAlgorithm.algorithm\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OID,\n                    constructed: false,\n                    capture: \"certSignatureOid\"\n                },\n                {\n                    name: \"Certificate.TBSCertificate.signature.parameters\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    optional: true,\n                    captureAsn1: \"certSignatureParams\"\n                }\n            ]\n        },\n        {\n            // SignatureValue\n            name: \"Certificate.signatureValue\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.BITSTRING,\n            constructed: false,\n            captureBitStringValue: \"certSignature\"\n        }\n    ]\n};\nvar rsassaPssParameterValidator = {\n    name: \"rsapss\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n        {\n            name: \"rsapss.hashAlgorithm\",\n            tagClass: asn1.Class.CONTEXT_SPECIFIC,\n            type: 0,\n            constructed: true,\n            value: [\n                {\n                    name: \"rsapss.hashAlgorithm.AlgorithmIdentifier\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Class.SEQUENCE,\n                    constructed: true,\n                    optional: true,\n                    value: [\n                        {\n                            name: \"rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.OID,\n                            constructed: false,\n                            capture: \"hashOid\"\n                        }\n                    ]\n                }\n            ]\n        },\n        {\n            name: \"rsapss.maskGenAlgorithm\",\n            tagClass: asn1.Class.CONTEXT_SPECIFIC,\n            type: 1,\n            constructed: true,\n            value: [\n                {\n                    name: \"rsapss.maskGenAlgorithm.AlgorithmIdentifier\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Class.SEQUENCE,\n                    constructed: true,\n                    optional: true,\n                    value: [\n                        {\n                            name: \"rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.OID,\n                            constructed: false,\n                            capture: \"maskGenOid\"\n                        },\n                        {\n                            name: \"rsapss.maskGenAlgorithm.AlgorithmIdentifier.params\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.SEQUENCE,\n                            constructed: true,\n                            value: [\n                                {\n                                    name: \"rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm\",\n                                    tagClass: asn1.Class.UNIVERSAL,\n                                    type: asn1.Type.OID,\n                                    constructed: false,\n                                    capture: \"maskGenHashOid\"\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ]\n        },\n        {\n            name: \"rsapss.saltLength\",\n            tagClass: asn1.Class.CONTEXT_SPECIFIC,\n            type: 2,\n            optional: true,\n            value: [\n                {\n                    name: \"rsapss.saltLength.saltLength\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Class.INTEGER,\n                    constructed: false,\n                    capture: \"saltLength\"\n                }\n            ]\n        },\n        {\n            name: \"rsapss.trailerField\",\n            tagClass: asn1.Class.CONTEXT_SPECIFIC,\n            type: 3,\n            optional: true,\n            value: [\n                {\n                    name: \"rsapss.trailer.trailer\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Class.INTEGER,\n                    constructed: false,\n                    capture: \"trailer\"\n                }\n            ]\n        }\n    ]\n};\n// validator for a CertificationRequestInfo structure\nvar certificationRequestInfoValidator = {\n    name: \"CertificationRequestInfo\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    captureAsn1: \"certificationRequestInfo\",\n    value: [\n        {\n            name: \"CertificationRequestInfo.integer\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"certificationRequestInfoVersion\"\n        },\n        {\n            // Name (subject) (RDNSequence)\n            name: \"CertificationRequestInfo.subject\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            captureAsn1: \"certificationRequestInfoSubject\"\n        },\n        // SubjectPublicKeyInfo\n        publicKeyValidator,\n        {\n            name: \"CertificationRequestInfo.attributes\",\n            tagClass: asn1.Class.CONTEXT_SPECIFIC,\n            type: 0,\n            constructed: true,\n            optional: true,\n            capture: \"certificationRequestInfoAttributes\",\n            value: [\n                {\n                    name: \"CertificationRequestInfo.attributes\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.SEQUENCE,\n                    constructed: true,\n                    value: [\n                        {\n                            name: \"CertificationRequestInfo.attributes.type\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.OID,\n                            constructed: false\n                        },\n                        {\n                            name: \"CertificationRequestInfo.attributes.value\",\n                            tagClass: asn1.Class.UNIVERSAL,\n                            type: asn1.Type.SET,\n                            constructed: true\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n};\n// validator for a CertificationRequest structure\nvar certificationRequestValidator = {\n    name: \"CertificationRequest\",\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    captureAsn1: \"csr\",\n    value: [\n        certificationRequestInfoValidator,\n        {\n            // AlgorithmIdentifier (signature algorithm)\n            name: \"CertificationRequest.signatureAlgorithm\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [\n                {\n                    // algorithm\n                    name: \"CertificationRequest.signatureAlgorithm.algorithm\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    type: asn1.Type.OID,\n                    constructed: false,\n                    capture: \"csrSignatureOid\"\n                },\n                {\n                    name: \"CertificationRequest.signatureAlgorithm.parameters\",\n                    tagClass: asn1.Class.UNIVERSAL,\n                    optional: true,\n                    captureAsn1: \"csrSignatureParams\"\n                }\n            ]\n        },\n        {\n            // signature\n            name: \"CertificationRequest.signature\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.BITSTRING,\n            constructed: false,\n            captureBitStringValue: \"csrSignature\"\n        }\n    ]\n};\n/**\n * Converts an RDNSequence of ASN.1 DER-encoded RelativeDistinguishedName\n * sets into an array with objects that have type and value properties.\n *\n * @param rdn the RDNSequence to convert.\n * @param md a message digest to append type and value to if provided.\n */ pki.RDNAttributesAsArray = function(rdn, md) {\n    var rval = [];\n    // each value in 'rdn' in is a SET of RelativeDistinguishedName\n    var set, attr, obj;\n    for(var si = 0; si < rdn.value.length; ++si){\n        // get the RelativeDistinguishedName set\n        set = rdn.value[si];\n        // each value in the SET is an AttributeTypeAndValue sequence\n        // containing first a type (an OID) and second a value (defined by\n        // the OID)\n        for(var i = 0; i < set.value.length; ++i){\n            obj = {};\n            attr = set.value[i];\n            obj.type = asn1.derToOid(attr.value[0].value);\n            obj.value = attr.value[1].value;\n            obj.valueTagClass = attr.value[1].type;\n            // if the OID is known, get its name and short name\n            if (obj.type in oids) {\n                obj.name = oids[obj.type];\n                if (obj.name in _shortNames) {\n                    obj.shortName = _shortNames[obj.name];\n                }\n            }\n            if (md) {\n                md.update(obj.type);\n                md.update(obj.value);\n            }\n            rval.push(obj);\n        }\n    }\n    return rval;\n};\n/**\n * Converts ASN.1 CRIAttributes into an array with objects that have type and\n * value properties.\n *\n * @param attributes the CRIAttributes to convert.\n */ pki.CRIAttributesAsArray = function(attributes) {\n    var rval = [];\n    // each value in 'attributes' in is a SEQUENCE with an OID and a SET\n    for(var si = 0; si < attributes.length; ++si){\n        // get the attribute sequence\n        var seq = attributes[si];\n        // each value in the SEQUENCE containing first a type (an OID) and\n        // second a set of values (defined by the OID)\n        var type = asn1.derToOid(seq.value[0].value);\n        var values = seq.value[1].value;\n        for(var vi = 0; vi < values.length; ++vi){\n            var obj = {};\n            obj.type = type;\n            obj.value = values[vi].value;\n            obj.valueTagClass = values[vi].type;\n            // if the OID is known, get its name and short name\n            if (obj.type in oids) {\n                obj.name = oids[obj.type];\n                if (obj.name in _shortNames) {\n                    obj.shortName = _shortNames[obj.name];\n                }\n            }\n            // parse extensions\n            if (obj.type === oids.extensionRequest) {\n                obj.extensions = [];\n                for(var ei = 0; ei < obj.value.length; ++ei){\n                    obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));\n                }\n            }\n            rval.push(obj);\n        }\n    }\n    return rval;\n};\n/**\n * Gets an issuer or subject attribute from its name, type, or short name.\n *\n * @param obj the issuer or subject object.\n * @param options a short name string or an object with:\n *          shortName the short name for the attribute.\n *          name the name for the attribute.\n *          type the type for the attribute.\n *\n * @return the attribute.\n */ function _getAttribute(obj, options) {\n    if (typeof options === \"string\") {\n        options = {\n            shortName: options\n        };\n    }\n    var rval = null;\n    var attr;\n    for(var i = 0; rval === null && i < obj.attributes.length; ++i){\n        attr = obj.attributes[i];\n        if (options.type && options.type === attr.type) {\n            rval = attr;\n        } else if (options.name && options.name === attr.name) {\n            rval = attr;\n        } else if (options.shortName && options.shortName === attr.shortName) {\n            rval = attr;\n        }\n    }\n    return rval;\n}\n/**\n * Converts signature parameters from ASN.1 structure.\n *\n * Currently only RSASSA-PSS supported.  The PKCS#1 v1.5 signature scheme had\n * no parameters.\n *\n * RSASSA-PSS-params  ::=  SEQUENCE  {\n *   hashAlgorithm      [0] HashAlgorithm DEFAULT\n *                             sha1Identifier,\n *   maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT\n *                             mgf1SHA1Identifier,\n *   saltLength         [2] INTEGER DEFAULT 20,\n *   trailerField       [3] INTEGER DEFAULT 1\n * }\n *\n * HashAlgorithm  ::=  AlgorithmIdentifier\n *\n * MaskGenAlgorithm  ::=  AlgorithmIdentifier\n *\n * AlgorithmIdentifer ::= SEQUENCE {\n *   algorithm OBJECT IDENTIFIER,\n *   parameters ANY DEFINED BY algorithm OPTIONAL\n * }\n *\n * @param oid The OID specifying the signature algorithm\n * @param obj The ASN.1 structure holding the parameters\n * @param fillDefaults Whether to use return default values where omitted\n * @return signature parameter object\n */ var _readSignatureParameters = function(oid, obj, fillDefaults) {\n    var params = {};\n    if (oid !== oids[\"RSASSA-PSS\"]) {\n        return params;\n    }\n    if (fillDefaults) {\n        params = {\n            hash: {\n                algorithmOid: oids[\"sha1\"]\n            },\n            mgf: {\n                algorithmOid: oids[\"mgf1\"],\n                hash: {\n                    algorithmOid: oids[\"sha1\"]\n                }\n            },\n            saltLength: 20\n        };\n    }\n    var capture = {};\n    var errors = [];\n    if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {\n        var error = new Error(\"Cannot read RSASSA-PSS parameter block.\");\n        error.errors = errors;\n        throw error;\n    }\n    if (capture.hashOid !== undefined) {\n        params.hash = params.hash || {};\n        params.hash.algorithmOid = asn1.derToOid(capture.hashOid);\n    }\n    if (capture.maskGenOid !== undefined) {\n        params.mgf = params.mgf || {};\n        params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);\n        params.mgf.hash = params.mgf.hash || {};\n        params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);\n    }\n    if (capture.saltLength !== undefined) {\n        params.saltLength = capture.saltLength.charCodeAt(0);\n    }\n    return params;\n};\n/**\n * Create signature digest for OID.\n *\n * @param options\n *   signatureOid: the OID specifying the signature algorithm.\n *   type: a human readable type for error messages\n * @return a created md instance. throws if unknown oid.\n */ var _createSignatureDigest = function(options) {\n    switch(oids[options.signatureOid]){\n        case \"sha1WithRSAEncryption\":\n        // deprecated alias\n        case \"sha1WithRSASignature\":\n            return forge.md.sha1.create();\n        case \"md5WithRSAEncryption\":\n            return forge.md.md5.create();\n        case \"sha256WithRSAEncryption\":\n            return forge.md.sha256.create();\n        case \"sha384WithRSAEncryption\":\n            return forge.md.sha384.create();\n        case \"sha512WithRSAEncryption\":\n            return forge.md.sha512.create();\n        case \"RSASSA-PSS\":\n            return forge.md.sha256.create();\n        default:\n            var error = new Error(\"Could not compute \" + options.type + \" digest. \" + \"Unknown signature OID.\");\n            error.signatureOid = options.signatureOid;\n            throw error;\n    }\n};\n/**\n * Verify signature on certificate or CSR.\n *\n * @param options:\n *   certificate the certificate or CSR to verify.\n *   md the signature digest.\n *   signature the signature\n * @return a created md instance. throws if unknown oid.\n */ var _verifySignature = function(options) {\n    var cert = options.certificate;\n    var scheme;\n    switch(cert.signatureOid){\n        case oids.sha1WithRSAEncryption:\n        // deprecated alias\n        case oids.sha1WithRSASignature:\n            break;\n        case oids[\"RSASSA-PSS\"]:\n            var hash, mgf;\n            /* initialize mgf */ hash = oids[cert.signatureParameters.mgf.hash.algorithmOid];\n            if (hash === undefined || forge.md[hash] === undefined) {\n                var error = new Error(\"Unsupported MGF hash function.\");\n                error.oid = cert.signatureParameters.mgf.hash.algorithmOid;\n                error.name = hash;\n                throw error;\n            }\n            mgf = oids[cert.signatureParameters.mgf.algorithmOid];\n            if (mgf === undefined || forge.mgf[mgf] === undefined) {\n                var error = new Error(\"Unsupported MGF function.\");\n                error.oid = cert.signatureParameters.mgf.algorithmOid;\n                error.name = mgf;\n                throw error;\n            }\n            mgf = forge.mgf[mgf].create(forge.md[hash].create());\n            /* initialize hash function */ hash = oids[cert.signatureParameters.hash.algorithmOid];\n            if (hash === undefined || forge.md[hash] === undefined) {\n                var error = new Error(\"Unsupported RSASSA-PSS hash function.\");\n                error.oid = cert.signatureParameters.hash.algorithmOid;\n                error.name = hash;\n                throw error;\n            }\n            scheme = forge.pss.create(forge.md[hash].create(), mgf, cert.signatureParameters.saltLength);\n            break;\n    }\n    // verify signature on cert using public key\n    return cert.publicKey.verify(options.md.digest().getBytes(), options.signature, scheme);\n};\n/**\n * Converts an X.509 certificate from PEM format.\n *\n * Note: If the certificate is to be verified then compute hash should\n * be set to true. This will scan the TBSCertificate part of the ASN.1\n * object while it is converted so it doesn't need to be converted back\n * to ASN.1-DER-encoding later.\n *\n * @param pem the PEM-formatted certificate.\n * @param computeHash true to compute the hash for verification.\n * @param strict true to be strict when checking ASN.1 value lengths, false to\n *          allow truncated values (default: true).\n *\n * @return the certificate.\n */ pki.certificateFromPem = function(pem, computeHash, strict) {\n    var msg = forge.pem.decode(pem)[0];\n    if (msg.type !== \"CERTIFICATE\" && msg.type !== \"X509 CERTIFICATE\" && msg.type !== \"TRUSTED CERTIFICATE\") {\n        var error = new Error(\"Could not convert certificate from PEM; PEM header type \" + 'is not \"CERTIFICATE\", \"X509 CERTIFICATE\", or \"TRUSTED CERTIFICATE\".');\n        error.headerType = msg.type;\n        throw error;\n    }\n    if (msg.procType && msg.procType.type === \"ENCRYPTED\") {\n        throw new Error(\"Could not convert certificate from PEM; PEM is encrypted.\");\n    }\n    // convert DER to ASN.1 object\n    var obj = asn1.fromDer(msg.body, strict);\n    return pki.certificateFromAsn1(obj, computeHash);\n};\n/**\n * Converts an X.509 certificate to PEM format.\n *\n * @param cert the certificate.\n * @param maxline the maximum characters per line, defaults to 64.\n *\n * @return the PEM-formatted certificate.\n */ pki.certificateToPem = function(cert, maxline) {\n    // convert to ASN.1, then DER, then PEM-encode\n    var msg = {\n        type: \"CERTIFICATE\",\n        body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()\n    };\n    return forge.pem.encode(msg, {\n        maxline: maxline\n    });\n};\n/**\n * Converts an RSA public key from PEM format.\n *\n * @param pem the PEM-formatted public key.\n *\n * @return the public key.\n */ pki.publicKeyFromPem = function(pem) {\n    var msg = forge.pem.decode(pem)[0];\n    if (msg.type !== \"PUBLIC KEY\" && msg.type !== \"RSA PUBLIC KEY\") {\n        var error = new Error(\"Could not convert public key from PEM; PEM header \" + 'type is not \"PUBLIC KEY\" or \"RSA PUBLIC KEY\".');\n        error.headerType = msg.type;\n        throw error;\n    }\n    if (msg.procType && msg.procType.type === \"ENCRYPTED\") {\n        throw new Error(\"Could not convert public key from PEM; PEM is encrypted.\");\n    }\n    // convert DER to ASN.1 object\n    var obj = asn1.fromDer(msg.body);\n    return pki.publicKeyFromAsn1(obj);\n};\n/**\n * Converts an RSA public key to PEM format (using a SubjectPublicKeyInfo).\n *\n * @param key the public key.\n * @param maxline the maximum characters per line, defaults to 64.\n *\n * @return the PEM-formatted public key.\n */ pki.publicKeyToPem = function(key, maxline) {\n    // convert to ASN.1, then DER, then PEM-encode\n    var msg = {\n        type: \"PUBLIC KEY\",\n        body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()\n    };\n    return forge.pem.encode(msg, {\n        maxline: maxline\n    });\n};\n/**\n * Converts an RSA public key to PEM format (using an RSAPublicKey).\n *\n * @param key the public key.\n * @param maxline the maximum characters per line, defaults to 64.\n *\n * @return the PEM-formatted public key.\n */ pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {\n    // convert to ASN.1, then DER, then PEM-encode\n    var msg = {\n        type: \"RSA PUBLIC KEY\",\n        body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()\n    };\n    return forge.pem.encode(msg, {\n        maxline: maxline\n    });\n};\n/**\n * Gets a fingerprint for the given public key.\n *\n * @param options the options to use.\n *          [md] the message digest object to use (defaults to forge.md.sha1).\n *          [type] the type of fingerprint, such as 'RSAPublicKey',\n *            'SubjectPublicKeyInfo' (defaults to 'RSAPublicKey').\n *          [encoding] an alternative output encoding, such as 'hex'\n *            (defaults to none, outputs a byte buffer).\n *          [delimiter] the delimiter to use between bytes for 'hex' encoded\n *            output, eg: ':' (defaults to none).\n *\n * @return the fingerprint as a byte buffer or other encoding based on options.\n */ pki.getPublicKeyFingerprint = function(key, options) {\n    options = options || {};\n    var md = options.md || forge.md.sha1.create();\n    var type = options.type || \"RSAPublicKey\";\n    var bytes;\n    switch(type){\n        case \"RSAPublicKey\":\n            bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();\n            break;\n        case \"SubjectPublicKeyInfo\":\n            bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();\n            break;\n        default:\n            throw new Error('Unknown fingerprint type \"' + options.type + '\".');\n    }\n    // hash public key bytes\n    md.start();\n    md.update(bytes);\n    var digest = md.digest();\n    if (options.encoding === \"hex\") {\n        var hex = digest.toHex();\n        if (options.delimiter) {\n            return hex.match(/.{2}/g).join(options.delimiter);\n        }\n        return hex;\n    } else if (options.encoding === \"binary\") {\n        return digest.getBytes();\n    } else if (options.encoding) {\n        throw new Error('Unknown encoding \"' + options.encoding + '\".');\n    }\n    return digest;\n};\n/**\n * Converts a PKCS#10 certification request (CSR) from PEM format.\n *\n * Note: If the certification request is to be verified then compute hash\n * should be set to true. This will scan the CertificationRequestInfo part of\n * the ASN.1 object while it is converted so it doesn't need to be converted\n * back to ASN.1-DER-encoding later.\n *\n * @param pem the PEM-formatted certificate.\n * @param computeHash true to compute the hash for verification.\n * @param strict true to be strict when checking ASN.1 value lengths, false to\n *          allow truncated values (default: true).\n *\n * @return the certification request (CSR).\n */ pki.certificationRequestFromPem = function(pem, computeHash, strict) {\n    var msg = forge.pem.decode(pem)[0];\n    if (msg.type !== \"CERTIFICATE REQUEST\") {\n        var error = new Error(\"Could not convert certification request from PEM; \" + 'PEM header type is not \"CERTIFICATE REQUEST\".');\n        error.headerType = msg.type;\n        throw error;\n    }\n    if (msg.procType && msg.procType.type === \"ENCRYPTED\") {\n        throw new Error(\"Could not convert certification request from PEM; \" + \"PEM is encrypted.\");\n    }\n    // convert DER to ASN.1 object\n    var obj = asn1.fromDer(msg.body, strict);\n    return pki.certificationRequestFromAsn1(obj, computeHash);\n};\n/**\n * Converts a PKCS#10 certification request (CSR) to PEM format.\n *\n * @param csr the certification request.\n * @param maxline the maximum characters per line, defaults to 64.\n *\n * @return the PEM-formatted certification request.\n */ pki.certificationRequestToPem = function(csr, maxline) {\n    // convert to ASN.1, then DER, then PEM-encode\n    var msg = {\n        type: \"CERTIFICATE REQUEST\",\n        body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()\n    };\n    return forge.pem.encode(msg, {\n        maxline: maxline\n    });\n};\n/**\n * Creates an empty X.509v3 RSA certificate.\n *\n * @return the certificate.\n */ pki.createCertificate = function() {\n    var cert = {};\n    cert.version = 0x02;\n    cert.serialNumber = \"00\";\n    cert.signatureOid = null;\n    cert.signature = null;\n    cert.siginfo = {};\n    cert.siginfo.algorithmOid = null;\n    cert.validity = {};\n    cert.validity.notBefore = new Date();\n    cert.validity.notAfter = new Date();\n    cert.issuer = {};\n    cert.issuer.getField = function(sn) {\n        return _getAttribute(cert.issuer, sn);\n    };\n    cert.issuer.addField = function(attr) {\n        _fillMissingFields([\n            attr\n        ]);\n        cert.issuer.attributes.push(attr);\n    };\n    cert.issuer.attributes = [];\n    cert.issuer.hash = null;\n    cert.subject = {};\n    cert.subject.getField = function(sn) {\n        return _getAttribute(cert.subject, sn);\n    };\n    cert.subject.addField = function(attr) {\n        _fillMissingFields([\n            attr\n        ]);\n        cert.subject.attributes.push(attr);\n    };\n    cert.subject.attributes = [];\n    cert.subject.hash = null;\n    cert.extensions = [];\n    cert.publicKey = null;\n    cert.md = null;\n    /**\n   * Sets the subject of this certificate.\n   *\n   * @param attrs the array of subject attributes to use.\n   * @param uniqueId an optional a unique ID to use.\n   */ cert.setSubject = function(attrs, uniqueId) {\n        // set new attributes, clear hash\n        _fillMissingFields(attrs);\n        cert.subject.attributes = attrs;\n        delete cert.subject.uniqueId;\n        if (uniqueId) {\n            // TODO: support arbitrary bit length ids\n            cert.subject.uniqueId = uniqueId;\n        }\n        cert.subject.hash = null;\n    };\n    /**\n   * Sets the issuer of this certificate.\n   *\n   * @param attrs the array of issuer attributes to use.\n   * @param uniqueId an optional a unique ID to use.\n   */ cert.setIssuer = function(attrs, uniqueId) {\n        // set new attributes, clear hash\n        _fillMissingFields(attrs);\n        cert.issuer.attributes = attrs;\n        delete cert.issuer.uniqueId;\n        if (uniqueId) {\n            // TODO: support arbitrary bit length ids\n            cert.issuer.uniqueId = uniqueId;\n        }\n        cert.issuer.hash = null;\n    };\n    /**\n   * Sets the extensions of this certificate.\n   *\n   * @param exts the array of extensions to use.\n   */ cert.setExtensions = function(exts) {\n        for(var i = 0; i < exts.length; ++i){\n            _fillMissingExtensionFields(exts[i], {\n                cert: cert\n            });\n        }\n        // set new extensions\n        cert.extensions = exts;\n    };\n    /**\n   * Gets an extension by its name or id.\n   *\n   * @param options the name to use or an object with:\n   *          name the name to use.\n   *          id the id to use.\n   *\n   * @return the extension or null if not found.\n   */ cert.getExtension = function(options) {\n        if (typeof options === \"string\") {\n            options = {\n                name: options\n            };\n        }\n        var rval = null;\n        var ext;\n        for(var i = 0; rval === null && i < cert.extensions.length; ++i){\n            ext = cert.extensions[i];\n            if (options.id && ext.id === options.id) {\n                rval = ext;\n            } else if (options.name && ext.name === options.name) {\n                rval = ext;\n            }\n        }\n        return rval;\n    };\n    /**\n   * Signs this certificate using the given private key.\n   *\n   * @param key the private key to sign with.\n   * @param md the message digest object to use (defaults to forge.md.sha1).\n   */ cert.sign = function(key, md) {\n        // TODO: get signature OID from private key\n        cert.md = md || forge.md.sha1.create();\n        var algorithmOid = oids[cert.md.algorithm + \"WithRSAEncryption\"];\n        if (!algorithmOid) {\n            var error = new Error(\"Could not compute certificate digest. \" + \"Unknown message digest algorithm OID.\");\n            error.algorithm = cert.md.algorithm;\n            throw error;\n        }\n        cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;\n        // get TBSCertificate, convert to DER\n        cert.tbsCertificate = pki.getTBSCertificate(cert);\n        var bytes = asn1.toDer(cert.tbsCertificate);\n        // digest and sign\n        cert.md.update(bytes.getBytes());\n        cert.signature = key.sign(cert.md);\n    };\n    /**\n   * Attempts verify the signature on the passed certificate using this\n   * certificate's public key.\n   *\n   * @param child the certificate to verify.\n   *\n   * @return true if verified, false if not.\n   */ cert.verify = function(child) {\n        var rval = false;\n        if (!cert.issued(child)) {\n            var issuer = child.issuer;\n            var subject = cert.subject;\n            var error = new Error(\"The parent certificate did not issue the given child \" + \"certificate; the child certificate's issuer does not match the \" + \"parent's subject.\");\n            error.expectedIssuer = subject.attributes;\n            error.actualIssuer = issuer.attributes;\n            throw error;\n        }\n        var md = child.md;\n        if (md === null) {\n            // create digest for OID signature types\n            md = _createSignatureDigest({\n                signatureOid: child.signatureOid,\n                type: \"certificate\"\n            });\n            // produce DER formatted TBSCertificate and digest it\n            var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);\n            var bytes = asn1.toDer(tbsCertificate);\n            md.update(bytes.getBytes());\n        }\n        if (md !== null) {\n            rval = _verifySignature({\n                certificate: cert,\n                md: md,\n                signature: child.signature\n            });\n        }\n        return rval;\n    };\n    /**\n   * Returns true if this certificate's issuer matches the passed\n   * certificate's subject. Note that no signature check is performed.\n   *\n   * @param parent the certificate to check.\n   *\n   * @return true if this certificate's issuer matches the passed certificate's\n   *         subject.\n   */ cert.isIssuer = function(parent) {\n        var rval = false;\n        var i = cert.issuer;\n        var s = parent.subject;\n        // compare hashes if present\n        if (i.hash && s.hash) {\n            rval = i.hash === s.hash;\n        } else if (i.attributes.length === s.attributes.length) {\n            // all attributes are the same so issuer matches subject\n            rval = true;\n            var iattr, sattr;\n            for(var n = 0; rval && n < i.attributes.length; ++n){\n                iattr = i.attributes[n];\n                sattr = s.attributes[n];\n                if (iattr.type !== sattr.type || iattr.value !== sattr.value) {\n                    // attribute mismatch\n                    rval = false;\n                }\n            }\n        }\n        return rval;\n    };\n    /**\n   * Returns true if this certificate's subject matches the issuer of the\n   * given certificate). Note that not signature check is performed.\n   *\n   * @param child the certificate to check.\n   *\n   * @return true if this certificate's subject matches the passed\n   *         certificate's issuer.\n   */ cert.issued = function(child) {\n        return child.isIssuer(cert);\n    };\n    /**\n   * Generates the subjectKeyIdentifier for this certificate as byte buffer.\n   *\n   * @return the subjectKeyIdentifier for this certificate as byte buffer.\n   */ cert.generateSubjectKeyIdentifier = function() {\n        /* See: 4.2.1.2 section of the the RFC3280, keyIdentifier is either:\n\n      (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the\n        value of the BIT STRING subjectPublicKey (excluding the tag,\n        length, and number of unused bits).\n\n      (2) The keyIdentifier is composed of a four bit type field with\n        the value 0100 followed by the least significant 60 bits of the\n        SHA-1 hash of the value of the BIT STRING subjectPublicKey\n        (excluding the tag, length, and number of unused bit string bits).\n    */ // skipping the tag, length, and number of unused bits is the same\n        // as just using the RSAPublicKey (for RSA keys, which are the\n        // only ones supported)\n        return pki.getPublicKeyFingerprint(cert.publicKey, {\n            type: \"RSAPublicKey\"\n        });\n    };\n    /**\n   * Verifies the subjectKeyIdentifier extension value for this certificate\n   * against its public key. If no extension is found, false will be\n   * returned.\n   *\n   * @return true if verified, false if not.\n   */ cert.verifySubjectKeyIdentifier = function() {\n        var oid = oids[\"subjectKeyIdentifier\"];\n        for(var i = 0; i < cert.extensions.length; ++i){\n            var ext = cert.extensions[i];\n            if (ext.id === oid) {\n                var ski = cert.generateSubjectKeyIdentifier().getBytes();\n                return forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski;\n            }\n        }\n        return false;\n    };\n    return cert;\n};\n/**\n * Converts an X.509v3 RSA certificate from an ASN.1 object.\n *\n * Note: If the certificate is to be verified then compute hash should\n * be set to true. There is currently no implementation for converting\n * a certificate back to ASN.1 so the TBSCertificate part of the ASN.1\n * object needs to be scanned before the cert object is created.\n *\n * @param obj the asn1 representation of an X.509v3 RSA certificate.\n * @param computeHash true to compute the hash for verification.\n *\n * @return the certificate.\n */ pki.certificateFromAsn1 = function(obj, computeHash) {\n    // validate certificate and capture data\n    var capture = {};\n    var errors = [];\n    if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {\n        var error = new Error(\"Cannot read X.509 certificate. \" + \"ASN.1 object is not an X509v3 Certificate.\");\n        error.errors = errors;\n        throw error;\n    }\n    // get oid\n    var oid = asn1.derToOid(capture.publicKeyOid);\n    if (oid !== pki.oids.rsaEncryption) {\n        throw new Error(\"Cannot read public key. OID is not RSA.\");\n    }\n    // create certificate\n    var cert = pki.createCertificate();\n    cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;\n    var serial = forge.util.createBuffer(capture.certSerialNumber);\n    cert.serialNumber = serial.toHex();\n    cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);\n    cert.signatureParameters = _readSignatureParameters(cert.signatureOid, capture.certSignatureParams, true);\n    cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);\n    cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid, capture.certinfoSignatureParams, false);\n    cert.signature = capture.certSignature;\n    var validity = [];\n    if (capture.certValidity1UTCTime !== undefined) {\n        validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));\n    }\n    if (capture.certValidity2GeneralizedTime !== undefined) {\n        validity.push(asn1.generalizedTimeToDate(capture.certValidity2GeneralizedTime));\n    }\n    if (capture.certValidity3UTCTime !== undefined) {\n        validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));\n    }\n    if (capture.certValidity4GeneralizedTime !== undefined) {\n        validity.push(asn1.generalizedTimeToDate(capture.certValidity4GeneralizedTime));\n    }\n    if (validity.length > 2) {\n        throw new Error(\"Cannot read notBefore/notAfter validity times; more \" + \"than two times were provided in the certificate.\");\n    }\n    if (validity.length < 2) {\n        throw new Error(\"Cannot read notBefore/notAfter validity times; they \" + \"were not provided as either UTCTime or GeneralizedTime.\");\n    }\n    cert.validity.notBefore = validity[0];\n    cert.validity.notAfter = validity[1];\n    // keep TBSCertificate to preserve signature when exporting\n    cert.tbsCertificate = capture.tbsCertificate;\n    if (computeHash) {\n        // create digest for OID signature type\n        cert.md = _createSignatureDigest({\n            signatureOid: cert.signatureOid,\n            type: \"certificate\"\n        });\n        // produce DER formatted TBSCertificate and digest it\n        var bytes = asn1.toDer(cert.tbsCertificate);\n        cert.md.update(bytes.getBytes());\n    }\n    // handle issuer, build issuer message digest\n    var imd = forge.md.sha1.create();\n    var ibytes = asn1.toDer(capture.certIssuer);\n    imd.update(ibytes.getBytes());\n    cert.issuer.getField = function(sn) {\n        return _getAttribute(cert.issuer, sn);\n    };\n    cert.issuer.addField = function(attr) {\n        _fillMissingFields([\n            attr\n        ]);\n        cert.issuer.attributes.push(attr);\n    };\n    cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer);\n    if (capture.certIssuerUniqueId) {\n        cert.issuer.uniqueId = capture.certIssuerUniqueId;\n    }\n    cert.issuer.hash = imd.digest().toHex();\n    // handle subject, build subject message digest\n    var smd = forge.md.sha1.create();\n    var sbytes = asn1.toDer(capture.certSubject);\n    smd.update(sbytes.getBytes());\n    cert.subject.getField = function(sn) {\n        return _getAttribute(cert.subject, sn);\n    };\n    cert.subject.addField = function(attr) {\n        _fillMissingFields([\n            attr\n        ]);\n        cert.subject.attributes.push(attr);\n    };\n    cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject);\n    if (capture.certSubjectUniqueId) {\n        cert.subject.uniqueId = capture.certSubjectUniqueId;\n    }\n    cert.subject.hash = smd.digest().toHex();\n    // handle extensions\n    if (capture.certExtensions) {\n        cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);\n    } else {\n        cert.extensions = [];\n    }\n    // convert RSA public key from ASN.1\n    cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);\n    return cert;\n};\n/**\n * Converts an ASN.1 extensions object (with extension sequences as its\n * values) into an array of extension objects with types and values.\n *\n * Supported extensions:\n *\n * id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }\n * KeyUsage ::= BIT STRING {\n *   digitalSignature        (0),\n *   nonRepudiation          (1),\n *   keyEncipherment         (2),\n *   dataEncipherment        (3),\n *   keyAgreement            (4),\n *   keyCertSign             (5),\n *   cRLSign                 (6),\n *   encipherOnly            (7),\n *   decipherOnly            (8)\n * }\n *\n * id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }\n * BasicConstraints ::= SEQUENCE {\n *   cA                      BOOLEAN DEFAULT FALSE,\n *   pathLenConstraint       INTEGER (0..MAX) OPTIONAL\n * }\n *\n * subjectAltName EXTENSION ::= {\n *   SYNTAX GeneralNames\n *   IDENTIFIED BY id-ce-subjectAltName\n * }\n *\n * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName\n *\n * GeneralName ::= CHOICE {\n *   otherName      [0] INSTANCE OF OTHER-NAME,\n *   rfc822Name     [1] IA5String,\n *   dNSName        [2] IA5String,\n *   x400Address    [3] ORAddress,\n *   directoryName  [4] Name,\n *   ediPartyName   [5] EDIPartyName,\n *   uniformResourceIdentifier [6] IA5String,\n *   IPAddress      [7] OCTET STRING,\n *   registeredID   [8] OBJECT IDENTIFIER\n * }\n *\n * OTHER-NAME ::= TYPE-IDENTIFIER\n *\n * EDIPartyName ::= SEQUENCE {\n *   nameAssigner [0] DirectoryString {ub-name} OPTIONAL,\n *   partyName    [1] DirectoryString {ub-name}\n * }\n *\n * @param exts the extensions ASN.1 with extension sequences to parse.\n *\n * @return the array.\n */ pki.certificateExtensionsFromAsn1 = function(exts) {\n    var rval = [];\n    for(var i = 0; i < exts.value.length; ++i){\n        // get extension sequence\n        var extseq = exts.value[i];\n        for(var ei = 0; ei < extseq.value.length; ++ei){\n            rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));\n        }\n    }\n    return rval;\n};\n/**\n * Parses a single certificate extension from ASN.1.\n *\n * @param ext the extension in ASN.1 format.\n *\n * @return the parsed extension as an object.\n */ pki.certificateExtensionFromAsn1 = function(ext) {\n    // an extension has:\n    // [0] extnID      OBJECT IDENTIFIER\n    // [1] critical    BOOLEAN DEFAULT FALSE\n    // [2] extnValue   OCTET STRING\n    var e = {};\n    e.id = asn1.derToOid(ext.value[0].value);\n    e.critical = false;\n    if (ext.value[1].type === asn1.Type.BOOLEAN) {\n        e.critical = ext.value[1].value.charCodeAt(0) !== 0x00;\n        e.value = ext.value[2].value;\n    } else {\n        e.value = ext.value[1].value;\n    }\n    // if the oid is known, get its name\n    if (e.id in oids) {\n        e.name = oids[e.id];\n        // handle key usage\n        if (e.name === \"keyUsage\") {\n            // get value as BIT STRING\n            var ev = asn1.fromDer(e.value);\n            var b2 = 0x00;\n            var b3 = 0x00;\n            if (ev.value.length > 1) {\n                // skip first byte, just indicates unused bits which\n                // will be padded with 0s anyway\n                // get bytes with flag bits\n                b2 = ev.value.charCodeAt(1);\n                b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;\n            }\n            // set flags\n            e.digitalSignature = (b2 & 0x80) === 0x80;\n            e.nonRepudiation = (b2 & 0x40) === 0x40;\n            e.keyEncipherment = (b2 & 0x20) === 0x20;\n            e.dataEncipherment = (b2 & 0x10) === 0x10;\n            e.keyAgreement = (b2 & 0x08) === 0x08;\n            e.keyCertSign = (b2 & 0x04) === 0x04;\n            e.cRLSign = (b2 & 0x02) === 0x02;\n            e.encipherOnly = (b2 & 0x01) === 0x01;\n            e.decipherOnly = (b3 & 0x80) === 0x80;\n        } else if (e.name === \"basicConstraints\") {\n            // handle basic constraints\n            // get value as SEQUENCE\n            var ev = asn1.fromDer(e.value);\n            // get cA BOOLEAN flag (defaults to false)\n            if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {\n                e.cA = ev.value[0].value.charCodeAt(0) !== 0x00;\n            } else {\n                e.cA = false;\n            }\n            // get path length constraint\n            var value = null;\n            if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {\n                value = ev.value[0].value;\n            } else if (ev.value.length > 1) {\n                value = ev.value[1].value;\n            }\n            if (value !== null) {\n                e.pathLenConstraint = asn1.derToInteger(value);\n            }\n        } else if (e.name === \"extKeyUsage\") {\n            // handle extKeyUsage\n            // value is a SEQUENCE of OIDs\n            var ev = asn1.fromDer(e.value);\n            for(var vi = 0; vi < ev.value.length; ++vi){\n                var oid = asn1.derToOid(ev.value[vi].value);\n                if (oid in oids) {\n                    e[oids[oid]] = true;\n                } else {\n                    e[oid] = true;\n                }\n            }\n        } else if (e.name === \"nsCertType\") {\n            // handle nsCertType\n            // get value as BIT STRING\n            var ev = asn1.fromDer(e.value);\n            var b2 = 0x00;\n            if (ev.value.length > 1) {\n                // skip first byte, just indicates unused bits which\n                // will be padded with 0s anyway\n                // get bytes with flag bits\n                b2 = ev.value.charCodeAt(1);\n            }\n            // set flags\n            e.client = (b2 & 0x80) === 0x80;\n            e.server = (b2 & 0x40) === 0x40;\n            e.email = (b2 & 0x20) === 0x20;\n            e.objsign = (b2 & 0x10) === 0x10;\n            e.reserved = (b2 & 0x08) === 0x08;\n            e.sslCA = (b2 & 0x04) === 0x04;\n            e.emailCA = (b2 & 0x02) === 0x02;\n            e.objCA = (b2 & 0x01) === 0x01;\n        } else if (e.name === \"subjectAltName\" || e.name === \"issuerAltName\") {\n            // handle subjectAltName/issuerAltName\n            e.altNames = [];\n            // ev is a SYNTAX SEQUENCE\n            var gn;\n            var ev = asn1.fromDer(e.value);\n            for(var n = 0; n < ev.value.length; ++n){\n                // get GeneralName\n                gn = ev.value[n];\n                var altName = {\n                    type: gn.type,\n                    value: gn.value\n                };\n                e.altNames.push(altName);\n                // Note: Support for types 1,2,6,7,8\n                switch(gn.type){\n                    // rfc822Name\n                    case 1:\n                    // dNSName\n                    case 2:\n                    // uniformResourceIdentifier (URI)\n                    case 6:\n                        break;\n                    // IPAddress\n                    case 7:\n                        // convert to IPv4/IPv6 string representation\n                        altName.ip = forge.util.bytesToIP(gn.value);\n                        break;\n                    // registeredID\n                    case 8:\n                        altName.oid = asn1.derToOid(gn.value);\n                        break;\n                    default:\n                }\n            }\n        } else if (e.name === \"subjectKeyIdentifier\") {\n            // value is an OCTETSTRING w/the hash of the key-type specific\n            // public key structure (eg: RSAPublicKey)\n            var ev = asn1.fromDer(e.value);\n            e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);\n        }\n    }\n    return e;\n};\n/**\n * Converts a PKCS#10 certification request (CSR) from an ASN.1 object.\n *\n * Note: If the certification request is to be verified then compute hash\n * should be set to true. There is currently no implementation for converting\n * a certificate back to ASN.1 so the CertificationRequestInfo part of the\n * ASN.1 object needs to be scanned before the csr object is created.\n *\n * @param obj the asn1 representation of a PKCS#10 certification request (CSR).\n * @param computeHash true to compute the hash for verification.\n *\n * @return the certification request (CSR).\n */ pki.certificationRequestFromAsn1 = function(obj, computeHash) {\n    // validate certification request and capture data\n    var capture = {};\n    var errors = [];\n    if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {\n        var error = new Error(\"Cannot read PKCS#10 certificate request. \" + \"ASN.1 object is not a PKCS#10 CertificationRequest.\");\n        error.errors = errors;\n        throw error;\n    }\n    // get oid\n    var oid = asn1.derToOid(capture.publicKeyOid);\n    if (oid !== pki.oids.rsaEncryption) {\n        throw new Error(\"Cannot read public key. OID is not RSA.\");\n    }\n    // create certification request\n    var csr = pki.createCertificationRequest();\n    csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;\n    csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);\n    csr.signatureParameters = _readSignatureParameters(csr.signatureOid, capture.csrSignatureParams, true);\n    csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);\n    csr.siginfo.parameters = _readSignatureParameters(csr.siginfo.algorithmOid, capture.csrSignatureParams, false);\n    csr.signature = capture.csrSignature;\n    // keep CertificationRequestInfo to preserve signature when exporting\n    csr.certificationRequestInfo = capture.certificationRequestInfo;\n    if (computeHash) {\n        // create digest for OID signature type\n        csr.md = _createSignatureDigest({\n            signatureOid: csr.signatureOid,\n            type: \"certification request\"\n        });\n        // produce DER formatted CertificationRequestInfo and digest it\n        var bytes = asn1.toDer(csr.certificationRequestInfo);\n        csr.md.update(bytes.getBytes());\n    }\n    // handle subject, build subject message digest\n    var smd = forge.md.sha1.create();\n    csr.subject.getField = function(sn) {\n        return _getAttribute(csr.subject, sn);\n    };\n    csr.subject.addField = function(attr) {\n        _fillMissingFields([\n            attr\n        ]);\n        csr.subject.attributes.push(attr);\n    };\n    csr.subject.attributes = pki.RDNAttributesAsArray(capture.certificationRequestInfoSubject, smd);\n    csr.subject.hash = smd.digest().toHex();\n    // convert RSA public key from ASN.1\n    csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);\n    // convert attributes from ASN.1\n    csr.getAttribute = function(sn) {\n        return _getAttribute(csr, sn);\n    };\n    csr.addAttribute = function(attr) {\n        _fillMissingFields([\n            attr\n        ]);\n        csr.attributes.push(attr);\n    };\n    csr.attributes = pki.CRIAttributesAsArray(capture.certificationRequestInfoAttributes || []);\n    return csr;\n};\n/**\n * Creates an empty certification request (a CSR or certificate signing\n * request). Once created, its public key and attributes can be set and then\n * it can be signed.\n *\n * @return the empty certification request.\n */ pki.createCertificationRequest = function() {\n    var csr = {};\n    csr.version = 0x00;\n    csr.signatureOid = null;\n    csr.signature = null;\n    csr.siginfo = {};\n    csr.siginfo.algorithmOid = null;\n    csr.subject = {};\n    csr.subject.getField = function(sn) {\n        return _getAttribute(csr.subject, sn);\n    };\n    csr.subject.addField = function(attr) {\n        _fillMissingFields([\n            attr\n        ]);\n        csr.subject.attributes.push(attr);\n    };\n    csr.subject.attributes = [];\n    csr.subject.hash = null;\n    csr.publicKey = null;\n    csr.attributes = [];\n    csr.getAttribute = function(sn) {\n        return _getAttribute(csr, sn);\n    };\n    csr.addAttribute = function(attr) {\n        _fillMissingFields([\n            attr\n        ]);\n        csr.attributes.push(attr);\n    };\n    csr.md = null;\n    /**\n   * Sets the subject of this certification request.\n   *\n   * @param attrs the array of subject attributes to use.\n   */ csr.setSubject = function(attrs) {\n        // set new attributes\n        _fillMissingFields(attrs);\n        csr.subject.attributes = attrs;\n        csr.subject.hash = null;\n    };\n    /**\n   * Sets the attributes of this certification request.\n   *\n   * @param attrs the array of attributes to use.\n   */ csr.setAttributes = function(attrs) {\n        // set new attributes\n        _fillMissingFields(attrs);\n        csr.attributes = attrs;\n    };\n    /**\n   * Signs this certification request using the given private key.\n   *\n   * @param key the private key to sign with.\n   * @param md the message digest object to use (defaults to forge.md.sha1).\n   */ csr.sign = function(key, md) {\n        // TODO: get signature OID from private key\n        csr.md = md || forge.md.sha1.create();\n        var algorithmOid = oids[csr.md.algorithm + \"WithRSAEncryption\"];\n        if (!algorithmOid) {\n            var error = new Error(\"Could not compute certification request digest. \" + \"Unknown message digest algorithm OID.\");\n            error.algorithm = csr.md.algorithm;\n            throw error;\n        }\n        csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;\n        // get CertificationRequestInfo, convert to DER\n        csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);\n        var bytes = asn1.toDer(csr.certificationRequestInfo);\n        // digest and sign\n        csr.md.update(bytes.getBytes());\n        csr.signature = key.sign(csr.md);\n    };\n    /**\n   * Attempts verify the signature on the passed certification request using\n   * its public key.\n   *\n   * A CSR that has been exported to a file in PEM format can be verified using\n   * OpenSSL using this command:\n   *\n   * openssl req -in <the-csr-pem-file> -verify -noout -text\n   *\n   * @return true if verified, false if not.\n   */ csr.verify = function() {\n        var rval = false;\n        var md = csr.md;\n        if (md === null) {\n            md = _createSignatureDigest({\n                signatureOid: csr.signatureOid,\n                type: \"certification request\"\n            });\n            // produce DER formatted CertificationRequestInfo and digest it\n            var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);\n            var bytes = asn1.toDer(cri);\n            md.update(bytes.getBytes());\n        }\n        if (md !== null) {\n            rval = _verifySignature({\n                certificate: csr,\n                md: md,\n                signature: csr.signature\n            });\n        }\n        return rval;\n    };\n    return csr;\n};\n/**\n * Converts an X.509 subject or issuer to an ASN.1 RDNSequence.\n *\n * @param obj the subject or issuer (distinguished name).\n *\n * @return the ASN.1 RDNSequence.\n */ function _dnToAsn1(obj) {\n    // create an empty RDNSequence\n    var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n    // iterate over attributes\n    var attr, set;\n    var attrs = obj.attributes;\n    for(var i = 0; i < attrs.length; ++i){\n        attr = attrs[i];\n        var value = attr.value;\n        // reuse tag class for attribute value if available\n        var valueTagClass = asn1.Type.PRINTABLESTRING;\n        if (\"valueTagClass\" in attr) {\n            valueTagClass = attr.valueTagClass;\n            if (valueTagClass === asn1.Type.UTF8) {\n                value = forge.util.encodeUtf8(value);\n            }\n        // FIXME: handle more encodings\n        }\n        // create a RelativeDistinguishedName set\n        // each value in the set is an AttributeTypeAndValue first\n        // containing the type (an OID) and second the value\n        set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                // AttributeType\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),\n                // AttributeValue\n                asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)\n            ])\n        ]);\n        rval.value.push(set);\n    }\n    return rval;\n}\n/**\n * Gets all printable attributes (typically of an issuer or subject) in a\n * simplified JSON format for display.\n *\n * @param attrs the attributes.\n *\n * @return the JSON for display.\n */ function _getAttributesAsJson(attrs) {\n    var rval = {};\n    for(var i = 0; i < attrs.length; ++i){\n        var attr = attrs[i];\n        if (attr.shortName && (attr.valueTagClass === asn1.Type.UTF8 || attr.valueTagClass === asn1.Type.PRINTABLESTRING || attr.valueTagClass === asn1.Type.IA5STRING)) {\n            var value = attr.value;\n            if (attr.valueTagClass === asn1.Type.UTF8) {\n                value = forge.util.encodeUtf8(attr.value);\n            }\n            if (!(attr.shortName in rval)) {\n                rval[attr.shortName] = value;\n            } else if (forge.util.isArray(rval[attr.shortName])) {\n                rval[attr.shortName].push(value);\n            } else {\n                rval[attr.shortName] = [\n                    rval[attr.shortName],\n                    value\n                ];\n            }\n        }\n    }\n    return rval;\n}\n/**\n * Fills in missing fields in attributes.\n *\n * @param attrs the attributes to fill missing fields in.\n */ function _fillMissingFields(attrs) {\n    var attr;\n    for(var i = 0; i < attrs.length; ++i){\n        attr = attrs[i];\n        // populate missing name\n        if (typeof attr.name === \"undefined\") {\n            if (attr.type && attr.type in pki.oids) {\n                attr.name = pki.oids[attr.type];\n            } else if (attr.shortName && attr.shortName in _shortNames) {\n                attr.name = pki.oids[_shortNames[attr.shortName]];\n            }\n        }\n        // populate missing type (OID)\n        if (typeof attr.type === \"undefined\") {\n            if (attr.name && attr.name in pki.oids) {\n                attr.type = pki.oids[attr.name];\n            } else {\n                var error = new Error(\"Attribute type not specified.\");\n                error.attribute = attr;\n                throw error;\n            }\n        }\n        // populate missing shortname\n        if (typeof attr.shortName === \"undefined\") {\n            if (attr.name && attr.name in _shortNames) {\n                attr.shortName = _shortNames[attr.name];\n            }\n        }\n        // convert extensions to value\n        if (attr.type === oids.extensionRequest) {\n            attr.valueConstructed = true;\n            attr.valueTagClass = asn1.Type.SEQUENCE;\n            if (!attr.value && attr.extensions) {\n                attr.value = [];\n                for(var ei = 0; ei < attr.extensions.length; ++ei){\n                    attr.value.push(pki.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei])));\n                }\n            }\n        }\n        if (typeof attr.value === \"undefined\") {\n            var error = new Error(\"Attribute value not specified.\");\n            error.attribute = attr;\n            throw error;\n        }\n    }\n}\n/**\n * Fills in missing fields in certificate extensions.\n *\n * @param e the extension.\n * @param [options] the options to use.\n *          [cert] the certificate the extensions are for.\n *\n * @return the extension.\n */ function _fillMissingExtensionFields(e, options) {\n    options = options || {};\n    // populate missing name\n    if (typeof e.name === \"undefined\") {\n        if (e.id && e.id in pki.oids) {\n            e.name = pki.oids[e.id];\n        }\n    }\n    // populate missing id\n    if (typeof e.id === \"undefined\") {\n        if (e.name && e.name in pki.oids) {\n            e.id = pki.oids[e.name];\n        } else {\n            var error = new Error(\"Extension ID not specified.\");\n            error.extension = e;\n            throw error;\n        }\n    }\n    if (typeof e.value !== \"undefined\") {\n        return e;\n    }\n    // handle missing value:\n    // value is a BIT STRING\n    if (e.name === \"keyUsage\") {\n        // build flags\n        var unused = 0;\n        var b2 = 0x00;\n        var b3 = 0x00;\n        if (e.digitalSignature) {\n            b2 |= 0x80;\n            unused = 7;\n        }\n        if (e.nonRepudiation) {\n            b2 |= 0x40;\n            unused = 6;\n        }\n        if (e.keyEncipherment) {\n            b2 |= 0x20;\n            unused = 5;\n        }\n        if (e.dataEncipherment) {\n            b2 |= 0x10;\n            unused = 4;\n        }\n        if (e.keyAgreement) {\n            b2 |= 0x08;\n            unused = 3;\n        }\n        if (e.keyCertSign) {\n            b2 |= 0x04;\n            unused = 2;\n        }\n        if (e.cRLSign) {\n            b2 |= 0x02;\n            unused = 1;\n        }\n        if (e.encipherOnly) {\n            b2 |= 0x01;\n            unused = 0;\n        }\n        if (e.decipherOnly) {\n            b3 |= 0x80;\n            unused = 7;\n        }\n        // create bit string\n        var value = String.fromCharCode(unused);\n        if (b3 !== 0) {\n            value += String.fromCharCode(b2) + String.fromCharCode(b3);\n        } else if (b2 !== 0) {\n            value += String.fromCharCode(b2);\n        }\n        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);\n    } else if (e.name === \"basicConstraints\") {\n        // basicConstraints is a SEQUENCE\n        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n        // cA BOOLEAN flag defaults to false\n        if (e.cA) {\n            e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(0xFF)));\n        }\n        if (\"pathLenConstraint\" in e) {\n            e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(e.pathLenConstraint).getBytes()));\n        }\n    } else if (e.name === \"extKeyUsage\") {\n        // extKeyUsage is a SEQUENCE of OIDs\n        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n        var seq = e.value.value;\n        for(var key in e){\n            if (e[key] !== true) {\n                continue;\n            }\n            // key is name in OID map\n            if (key in oids) {\n                seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids[key]).getBytes()));\n            } else if (key.indexOf(\".\") !== -1) {\n                // assume key is an OID\n                seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(key).getBytes()));\n            }\n        }\n    } else if (e.name === \"nsCertType\") {\n        // nsCertType is a BIT STRING\n        // build flags\n        var unused = 0;\n        var b2 = 0x00;\n        if (e.client) {\n            b2 |= 0x80;\n            unused = 7;\n        }\n        if (e.server) {\n            b2 |= 0x40;\n            unused = 6;\n        }\n        if (e.email) {\n            b2 |= 0x20;\n            unused = 5;\n        }\n        if (e.objsign) {\n            b2 |= 0x10;\n            unused = 4;\n        }\n        if (e.reserved) {\n            b2 |= 0x08;\n            unused = 3;\n        }\n        if (e.sslCA) {\n            b2 |= 0x04;\n            unused = 2;\n        }\n        if (e.emailCA) {\n            b2 |= 0x02;\n            unused = 1;\n        }\n        if (e.objCA) {\n            b2 |= 0x01;\n            unused = 0;\n        }\n        // create bit string\n        var value = String.fromCharCode(unused);\n        if (b2 !== 0) {\n            value += String.fromCharCode(b2);\n        }\n        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);\n    } else if (e.name === \"subjectAltName\" || e.name === \"issuerAltName\") {\n        // SYNTAX SEQUENCE\n        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n        var altName;\n        for(var n = 0; n < e.altNames.length; ++n){\n            altName = e.altNames[n];\n            var value = altName.value;\n            // handle IP\n            if (altName.type === 7 && altName.ip) {\n                value = forge.util.bytesFromIP(altName.ip);\n                if (value === null) {\n                    var error = new Error('Extension \"ip\" value is not a valid IPv4 or IPv6 address.');\n                    error.extension = e;\n                    throw error;\n                }\n            } else if (altName.type === 8) {\n                // handle OID\n                if (altName.oid) {\n                    value = asn1.oidToDer(asn1.oidToDer(altName.oid));\n                } else {\n                    // deprecated ... convert value to OID\n                    value = asn1.oidToDer(value);\n                }\n            }\n            e.value.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));\n        }\n    } else if (e.name === \"nsComment\" && options.cert) {\n        // sanity check value is ASCII (req'd) and not too big\n        if (!/^[\\x00-\\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {\n            throw new Error('Invalid \"nsComment\" content.');\n        }\n        // IA5STRING opaque comment\n        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.IA5STRING, false, e.comment);\n    } else if (e.name === \"subjectKeyIdentifier\" && options.cert) {\n        var ski = options.cert.generateSubjectKeyIdentifier();\n        e.subjectKeyIdentifier = ski.toHex();\n        // OCTETSTRING w/digest\n        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ski.getBytes());\n    } else if (e.name === \"authorityKeyIdentifier\" && options.cert) {\n        // SYNTAX SEQUENCE\n        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n        var seq = e.value.value;\n        if (e.keyIdentifier) {\n            var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;\n            seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier));\n        }\n        if (e.authorityCertIssuer) {\n            var authorityCertIssuer = [\n                asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [\n                    _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)\n                ])\n            ];\n            seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer));\n        }\n        if (e.serialNumber) {\n            var serialNumber = forge.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);\n            seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber));\n        }\n    } else if (e.name === \"cRLDistributionPoints\") {\n        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n        var seq = e.value.value;\n        // Create sub SEQUENCE of DistributionPointName\n        var subSeq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n        // Create fullName CHOICE\n        var fullNameGeneralNames = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);\n        var altName;\n        for(var n = 0; n < e.altNames.length; ++n){\n            altName = e.altNames[n];\n            var value = altName.value;\n            // handle IP\n            if (altName.type === 7 && altName.ip) {\n                value = forge.util.bytesFromIP(altName.ip);\n                if (value === null) {\n                    var error = new Error('Extension \"ip\" value is not a valid IPv4 or IPv6 address.');\n                    error.extension = e;\n                    throw error;\n                }\n            } else if (altName.type === 8) {\n                // handle OID\n                if (altName.oid) {\n                    value = asn1.oidToDer(asn1.oidToDer(altName.oid));\n                } else {\n                    // deprecated ... convert value to OID\n                    value = asn1.oidToDer(value);\n                }\n            }\n            fullNameGeneralNames.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));\n        }\n        // Add to the parent SEQUENCE\n        subSeq.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n            fullNameGeneralNames\n        ]));\n        seq.push(subSeq);\n    }\n    // ensure value has been defined by now\n    if (typeof e.value === \"undefined\") {\n        var error = new Error(\"Extension value not specified.\");\n        error.extension = e;\n        throw error;\n    }\n    return e;\n}\n/**\n * Convert signature parameters object to ASN.1\n *\n * @param {String} oid Signature algorithm OID\n * @param params The signature parametrs object\n * @return ASN.1 object representing signature parameters\n */ function _signatureParametersToAsn1(oid, params) {\n    switch(oid){\n        case oids[\"RSASSA-PSS\"]:\n            var parts = [];\n            if (params.hash.algorithmOid !== undefined) {\n                parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.hash.algorithmOid).getBytes()),\n                        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n                    ])\n                ]));\n            }\n            if (params.mgf.algorithmOid !== undefined) {\n                parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [\n                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.algorithmOid).getBytes()),\n                        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()),\n                            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n                        ])\n                    ])\n                ]));\n            }\n            if (params.saltLength !== undefined) {\n                parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [\n                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(params.saltLength).getBytes())\n                ]));\n            }\n            return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);\n        default:\n            return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\");\n    }\n}\n/**\n * Converts a certification request's attributes to an ASN.1 set of\n * CRIAttributes.\n *\n * @param csr certification request.\n *\n * @return the ASN.1 set of CRIAttributes.\n */ function _CRIAttributesToAsn1(csr) {\n    // create an empty context-specific container\n    var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);\n    // no attributes, return empty container\n    if (csr.attributes.length === 0) {\n        return rval;\n    }\n    // each attribute has a sequence with a type and a set of values\n    var attrs = csr.attributes;\n    for(var i = 0; i < attrs.length; ++i){\n        var attr = attrs[i];\n        var value = attr.value;\n        // reuse tag class for attribute value if available\n        var valueTagClass = asn1.Type.UTF8;\n        if (\"valueTagClass\" in attr) {\n            valueTagClass = attr.valueTagClass;\n        }\n        if (valueTagClass === asn1.Type.UTF8) {\n            value = forge.util.encodeUtf8(value);\n        }\n        var valueConstructed = false;\n        if (\"valueConstructed\" in attr) {\n            valueConstructed = attr.valueConstructed;\n        }\n        // FIXME: handle more encodings\n        // create a RelativeDistinguishedName set\n        // each value in the set is an AttributeTypeAndValue first\n        // containing the type (an OID) and second the value\n        var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // AttributeType\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\n                // AttributeValue\n                asn1.create(asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)\n            ])\n        ]);\n        rval.value.push(seq);\n    }\n    return rval;\n}\nvar jan_1_1950 = new Date(\"1950-01-01T00:00:00Z\");\nvar jan_1_2050 = new Date(\"2050-01-01T00:00:00Z\");\n/**\n * Converts a Date object to ASN.1\n * Handles the different format before and after 1st January 2050\n *\n * @param date date object.\n *\n * @return the ASN.1 object representing the date.\n */ function _dateToAsn1(date) {\n    if (date >= jan_1_1950 && date < jan_1_2050) {\n        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));\n    } else {\n        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));\n    }\n}\n/**\n * Gets the ASN.1 TBSCertificate part of an X.509v3 certificate.\n *\n * @param cert the certificate.\n *\n * @return the asn1 TBSCertificate.\n */ pki.getTBSCertificate = function(cert) {\n    // TBSCertificate\n    var notBefore = _dateToAsn1(cert.validity.notBefore);\n    var notAfter = _dateToAsn1(cert.validity.notAfter);\n    var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // version\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n            // integer\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(cert.version).getBytes())\n        ]),\n        // serialNumber\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(cert.serialNumber)),\n        // signature\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // algorithm\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()),\n            // parameters\n            _signatureParametersToAsn1(cert.siginfo.algorithmOid, cert.siginfo.parameters)\n        ]),\n        // issuer\n        _dnToAsn1(cert.issuer),\n        // validity\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            notBefore,\n            notAfter\n        ]),\n        // subject\n        _dnToAsn1(cert.subject),\n        // SubjectPublicKeyInfo\n        pki.publicKeyToAsn1(cert.publicKey)\n    ]);\n    if (cert.issuer.uniqueId) {\n        // issuerUniqueID (optional)\n        tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, // TODO: support arbitrary bit length ids\n            String.fromCharCode(0x00) + cert.issuer.uniqueId)\n        ]));\n    }\n    if (cert.subject.uniqueId) {\n        // subjectUniqueID (optional)\n        tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, // TODO: support arbitrary bit length ids\n            String.fromCharCode(0x00) + cert.subject.uniqueId)\n        ]));\n    }\n    if (cert.extensions.length > 0) {\n        // extensions (optional)\n        tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));\n    }\n    return tbs;\n};\n/**\n * Gets the ASN.1 CertificationRequestInfo part of a\n * PKCS#10 CertificationRequest.\n *\n * @param csr the certification request.\n *\n * @return the asn1 CertificationRequestInfo.\n */ pki.getCertificationRequestInfo = function(csr) {\n    // CertificationRequestInfo\n    var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // version\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(csr.version).getBytes()),\n        // subject\n        _dnToAsn1(csr.subject),\n        // SubjectPublicKeyInfo\n        pki.publicKeyToAsn1(csr.publicKey),\n        // attributes\n        _CRIAttributesToAsn1(csr)\n    ]);\n    return cri;\n};\n/**\n * Converts a DistinguishedName (subject or issuer) to an ASN.1 object.\n *\n * @param dn the DistinguishedName.\n *\n * @return the asn1 representation of a DistinguishedName.\n */ pki.distinguishedNameToAsn1 = function(dn) {\n    return _dnToAsn1(dn);\n};\n/**\n * Converts an X.509v3 RSA certificate to an ASN.1 object.\n *\n * @param cert the certificate.\n *\n * @return the asn1 representation of an X.509v3 RSA certificate.\n */ pki.certificateToAsn1 = function(cert) {\n    // prefer cached TBSCertificate over generating one\n    var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);\n    // Certificate\n    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // TBSCertificate\n        tbsCertificate,\n        // AlgorithmIdentifier (signature algorithm)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // algorithm\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.signatureOid).getBytes()),\n            // parameters\n            _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)\n        ]),\n        // SignatureValue\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0x00) + cert.signature)\n    ]);\n};\n/**\n * Converts X.509v3 certificate extensions to ASN.1.\n *\n * @param exts the extensions to convert.\n *\n * @return the extensions in ASN.1 format.\n */ pki.certificateExtensionsToAsn1 = function(exts) {\n    // create top-level extension container\n    var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);\n    // create extension sequence (stores a sequence for each extension)\n    var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n    rval.value.push(seq);\n    for(var i = 0; i < exts.length; ++i){\n        seq.value.push(pki.certificateExtensionToAsn1(exts[i]));\n    }\n    return rval;\n};\n/**\n * Converts a single certificate extension to ASN.1.\n *\n * @param ext the extension to convert.\n *\n * @return the extension in ASN.1 format.\n */ pki.certificateExtensionToAsn1 = function(ext) {\n    // create a sequence for each extension\n    var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n    // extnID (OID)\n    extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ext.id).getBytes()));\n    // critical defaults to false\n    if (ext.critical) {\n        // critical BOOLEAN DEFAULT FALSE\n        extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(0xFF)));\n    }\n    var value = ext.value;\n    if (typeof ext.value !== \"string\") {\n        // value is asn.1\n        value = asn1.toDer(value).getBytes();\n    }\n    // extnValue (OCTET STRING)\n    extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value));\n    return extseq;\n};\n/**\n * Converts a PKCS#10 certification request to an ASN.1 object.\n *\n * @param csr the certification request.\n *\n * @return the asn1 representation of a certification request.\n */ pki.certificationRequestToAsn1 = function(csr) {\n    // prefer cached CertificationRequestInfo over generating one\n    var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);\n    // Certificate\n    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // CertificationRequestInfo\n        cri,\n        // AlgorithmIdentifier (signature algorithm)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // algorithm\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(csr.signatureOid).getBytes()),\n            // parameters\n            _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)\n        ]),\n        // signature\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0x00) + csr.signature)\n    ]);\n};\n/**\n * Creates a CA store.\n *\n * @param certs an optional array of certificate objects or PEM-formatted\n *          certificate strings to add to the CA store.\n *\n * @return the CA store.\n */ pki.createCaStore = function(certs) {\n    // create CA store\n    var caStore = {\n        // stored certificates\n        certs: {}\n    };\n    /**\n   * Gets the certificate that issued the passed certificate or its\n   * 'parent'.\n   *\n   * @param cert the certificate to get the parent for.\n   *\n   * @return the parent certificate or null if none was found.\n   */ caStore.getIssuer = function(cert) {\n        var rval = getBySubject(cert.issuer);\n        // see if there are multiple matches\n        /*if(forge.util.isArray(rval)) {\n      // TODO: resolve multiple matches by checking\n      // authorityKey/subjectKey/issuerUniqueID/other identifiers, etc.\n      // FIXME: or alternatively do authority key mapping\n      // if possible (X.509v1 certs can't work?)\n      throw new Error('Resolving multiple issuer matches not implemented yet.');\n    }*/ return rval;\n    };\n    /**\n   * Adds a trusted certificate to the store.\n   *\n   * @param cert the certificate to add as a trusted certificate (either a\n   *          pki.certificate object or a PEM-formatted certificate).\n   */ caStore.addCertificate = function(cert) {\n        // convert from pem if necessary\n        if (typeof cert === \"string\") {\n            cert = forge.pki.certificateFromPem(cert);\n        }\n        ensureSubjectHasHash(cert.subject);\n        if (!caStore.hasCertificate(cert)) {\n            if (cert.subject.hash in caStore.certs) {\n                // subject hash already exists, append to array\n                var tmp = caStore.certs[cert.subject.hash];\n                if (!forge.util.isArray(tmp)) {\n                    tmp = [\n                        tmp\n                    ];\n                }\n                tmp.push(cert);\n                caStore.certs[cert.subject.hash] = tmp;\n            } else {\n                caStore.certs[cert.subject.hash] = cert;\n            }\n        }\n    };\n    /**\n   * Checks to see if the given certificate is in the store.\n   *\n   * @param cert the certificate to check (either a pki.certificate or a\n   *          PEM-formatted certificate).\n   *\n   * @return true if the certificate is in the store, false if not.\n   */ caStore.hasCertificate = function(cert) {\n        // convert from pem if necessary\n        if (typeof cert === \"string\") {\n            cert = forge.pki.certificateFromPem(cert);\n        }\n        var match = getBySubject(cert.subject);\n        if (!match) {\n            return false;\n        }\n        if (!forge.util.isArray(match)) {\n            match = [\n                match\n            ];\n        }\n        // compare DER-encoding of certificates\n        var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();\n        for(var i = 0; i < match.length; ++i){\n            var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();\n            if (der1 === der2) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n   * Lists all of the certificates kept in the store.\n   *\n   * @return an array of all of the pki.certificate objects in the store.\n   */ caStore.listAllCertificates = function() {\n        var certList = [];\n        for(var hash in caStore.certs){\n            if (caStore.certs.hasOwnProperty(hash)) {\n                var value = caStore.certs[hash];\n                if (!forge.util.isArray(value)) {\n                    certList.push(value);\n                } else {\n                    for(var i = 0; i < value.length; ++i){\n                        certList.push(value[i]);\n                    }\n                }\n            }\n        }\n        return certList;\n    };\n    /**\n   * Removes a certificate from the store.\n   *\n   * @param cert the certificate to remove (either a pki.certificate or a\n   *          PEM-formatted certificate).\n   *\n   * @return the certificate that was removed or null if the certificate\n   *           wasn't in store.\n   */ caStore.removeCertificate = function(cert) {\n        var result;\n        // convert from pem if necessary\n        if (typeof cert === \"string\") {\n            cert = forge.pki.certificateFromPem(cert);\n        }\n        ensureSubjectHasHash(cert.subject);\n        if (!caStore.hasCertificate(cert)) {\n            return null;\n        }\n        var match = getBySubject(cert.subject);\n        if (!forge.util.isArray(match)) {\n            result = caStore.certs[cert.subject.hash];\n            delete caStore.certs[cert.subject.hash];\n            return result;\n        }\n        // compare DER-encoding of certificates\n        var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();\n        for(var i = 0; i < match.length; ++i){\n            var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();\n            if (der1 === der2) {\n                result = match[i];\n                match.splice(i, 1);\n            }\n        }\n        if (match.length === 0) {\n            delete caStore.certs[cert.subject.hash];\n        }\n        return result;\n    };\n    function getBySubject(subject) {\n        ensureSubjectHasHash(subject);\n        return caStore.certs[subject.hash] || null;\n    }\n    function ensureSubjectHasHash(subject) {\n        // produce subject hash if it doesn't exist\n        if (!subject.hash) {\n            var md = forge.md.sha1.create();\n            subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);\n            subject.hash = md.digest().toHex();\n        }\n    }\n    // auto-add passed in certs\n    if (certs) {\n        // parse PEM-formatted certificates as necessary\n        for(var i = 0; i < certs.length; ++i){\n            var cert = certs[i];\n            caStore.addCertificate(cert);\n        }\n    }\n    return caStore;\n};\n/**\n * Certificate verification errors, based on TLS.\n */ pki.certificateError = {\n    bad_certificate: \"forge.pki.BadCertificate\",\n    unsupported_certificate: \"forge.pki.UnsupportedCertificate\",\n    certificate_revoked: \"forge.pki.CertificateRevoked\",\n    certificate_expired: \"forge.pki.CertificateExpired\",\n    certificate_unknown: \"forge.pki.CertificateUnknown\",\n    unknown_ca: \"forge.pki.UnknownCertificateAuthority\"\n};\n/**\n * Verifies a certificate chain against the given Certificate Authority store\n * with an optional custom verify callback.\n *\n * @param caStore a certificate store to verify against.\n * @param chain the certificate chain to verify, with the root or highest\n *          authority at the end (an array of certificates).\n * @param options a callback to be called for every certificate in the chain or\n *                  an object with:\n *                  verify a callback to be called for every certificate in the\n *                    chain\n *                  validityCheckDate the date against which the certificate\n *                    validity period should be checked. Pass null to not check\n *                    the validity period. By default, the current date is used.\n *\n * The verify callback has the following signature:\n *\n * verified - Set to true if certificate was verified, otherwise the\n *   pki.certificateError for why the certificate failed.\n * depth - The current index in the chain, where 0 is the end point's cert.\n * certs - The certificate chain, *NOTE* an empty chain indicates an anonymous\n *   end point.\n *\n * The function returns true on success and on failure either the appropriate\n * pki.certificateError or an object with 'error' set to the appropriate\n * pki.certificateError and 'message' set to a custom error message.\n *\n * @return true if successful, error thrown if not.\n */ pki.verifyCertificateChain = function(caStore, chain, options) {\n    /* From: RFC3280 - Internet X.509 Public Key Infrastructure Certificate\n    Section 6: Certification Path Validation\n    See inline parentheticals related to this particular implementation.\n\n    The primary goal of path validation is to verify the binding between\n    a subject distinguished name or a subject alternative name and subject\n    public key, as represented in the end entity certificate, based on the\n    public key of the trust anchor. This requires obtaining a sequence of\n    certificates that support that binding. That sequence should be provided\n    in the passed 'chain'. The trust anchor should be in the given CA\n    store. The 'end entity' certificate is the certificate provided by the\n    end point (typically a server) and is the first in the chain.\n\n    To meet this goal, the path validation process verifies, among other\n    things, that a prospective certification path (a sequence of n\n    certificates or a 'chain') satisfies the following conditions:\n\n    (a) for all x in {1, ..., n-1}, the subject of certificate x is\n          the issuer of certificate x+1;\n\n    (b) certificate 1 is issued by the trust anchor;\n\n    (c) certificate n is the certificate to be validated; and\n\n    (d) for all x in {1, ..., n}, the certificate was valid at the\n          time in question.\n\n    Note that here 'n' is index 0 in the chain and 1 is the last certificate\n    in the chain and it must be signed by a certificate in the connection's\n    CA store.\n\n    The path validation process also determines the set of certificate\n    policies that are valid for this path, based on the certificate policies\n    extension, policy mapping extension, policy constraints extension, and\n    inhibit any-policy extension.\n\n    Note: Policy mapping extension not supported (Not Required).\n\n    Note: If the certificate has an unsupported critical extension, then it\n    must be rejected.\n\n    Note: A certificate is self-issued if the DNs that appear in the subject\n    and issuer fields are identical and are not empty.\n\n    The path validation algorithm assumes the following seven inputs are\n    provided to the path processing logic. What this specific implementation\n    will use is provided parenthetically:\n\n    (a) a prospective certification path of length n (the 'chain')\n    (b) the current date/time: ('now').\n    (c) user-initial-policy-set: A set of certificate policy identifiers\n          naming the policies that are acceptable to the certificate user.\n          The user-initial-policy-set contains the special value any-policy\n          if the user is not concerned about certificate policy\n          (Not implemented. Any policy is accepted).\n    (d) trust anchor information, describing a CA that serves as a trust\n          anchor for the certification path. The trust anchor information\n          includes:\n\n      (1)  the trusted issuer name,\n      (2)  the trusted public key algorithm,\n      (3)  the trusted public key, and\n      (4)  optionally, the trusted public key parameters associated\n             with the public key.\n\n      (Trust anchors are provided via certificates in the CA store).\n\n      The trust anchor information may be provided to the path processing\n      procedure in the form of a self-signed certificate. The trusted anchor\n      information is trusted because it was delivered to the path processing\n      procedure by some trustworthy out-of-band procedure. If the trusted\n      public key algorithm requires parameters, then the parameters are\n      provided along with the trusted public key (No parameters used in this\n      implementation).\n\n    (e) initial-policy-mapping-inhibit, which indicates if policy mapping is\n          allowed in the certification path.\n          (Not implemented, no policy checking)\n\n    (f) initial-explicit-policy, which indicates if the path must be valid\n          for at least one of the certificate policies in the user-initial-\n          policy-set.\n          (Not implemented, no policy checking)\n\n    (g) initial-any-policy-inhibit, which indicates whether the\n          anyPolicy OID should be processed if it is included in a\n          certificate.\n          (Not implemented, so any policy is valid provided that it is\n          not marked as critical) */ /* Basic Path Processing:\n\n    For each certificate in the 'chain', the following is checked:\n\n    1. The certificate validity period includes the current time.\n    2. The certificate was signed by its parent (where the parent is either\n       the next in the chain or from the CA store). Allow processing to\n       continue to the next step if no parent is found but the certificate is\n       in the CA store.\n    3. TODO: The certificate has not been revoked.\n    4. The certificate issuer name matches the parent's subject name.\n    5. TODO: If the certificate is self-issued and not the final certificate\n       in the chain, skip this step, otherwise verify that the subject name\n       is within one of the permitted subtrees of X.500 distinguished names\n       and that each of the alternative names in the subjectAltName extension\n       (critical or non-critical) is within one of the permitted subtrees for\n       that name type.\n    6. TODO: If the certificate is self-issued and not the final certificate\n       in the chain, skip this step, otherwise verify that the subject name\n       is not within one of the excluded subtrees for X.500 distinguished\n       names and none of the subjectAltName extension names are excluded for\n       that name type.\n    7. The other steps in the algorithm for basic path processing involve\n       handling the policy extension which is not presently supported in this\n       implementation. Instead, if a critical policy extension is found, the\n       certificate is rejected as not supported.\n    8. If the certificate is not the first or if its the only certificate in\n       the chain (having no parent from the CA store or is self-signed) and it\n       has a critical key usage extension, verify that the keyCertSign bit is\n       set. If the key usage extension exists, verify that the basic\n       constraints extension exists. If the basic constraints extension exists,\n       verify that the cA flag is set. If pathLenConstraint is set, ensure that\n       the number of certificates that precede in the chain (come earlier\n       in the chain as implemented below), excluding the very first in the\n       chain (typically the end-entity one), isn't greater than the\n       pathLenConstraint. This constraint limits the number of intermediate\n       CAs that may appear below a CA before only end-entity certificates\n       may be issued. */ // if a verify callback is passed as the third parameter, package it within\n    // the options object. This is to support a legacy function signature that\n    // expected the verify callback as the third parameter.\n    if (typeof options === \"function\") {\n        options = {\n            verify: options\n        };\n    }\n    options = options || {};\n    // copy cert chain references to another array to protect against changes\n    // in verify callback\n    chain = chain.slice(0);\n    var certs = chain.slice(0);\n    var validityCheckDate = options.validityCheckDate;\n    // if no validityCheckDate is specified, default to the current date. Make\n    // sure to maintain the value null because it indicates that the validity\n    // period should not be checked.\n    if (typeof validityCheckDate === \"undefined\") {\n        validityCheckDate = new Date();\n    }\n    // verify each cert in the chain using its parent, where the parent\n    // is either the next in the chain or from the CA store\n    var first = true;\n    var error = null;\n    var depth = 0;\n    do {\n        var cert = chain.shift();\n        var parent = null;\n        var selfSigned = false;\n        if (validityCheckDate) {\n            // 1. check valid time\n            if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {\n                error = {\n                    message: \"Certificate is not valid yet or has expired.\",\n                    error: pki.certificateError.certificate_expired,\n                    notBefore: cert.validity.notBefore,\n                    notAfter: cert.validity.notAfter,\n                    // TODO: we might want to reconsider renaming 'now' to\n                    // 'validityCheckDate' should this API be changed in the future.\n                    now: validityCheckDate\n                };\n            }\n        }\n        // 2. verify with parent from chain or CA store\n        if (error === null) {\n            parent = chain[0] || caStore.getIssuer(cert);\n            if (parent === null) {\n                // check for self-signed cert\n                if (cert.isIssuer(cert)) {\n                    selfSigned = true;\n                    parent = cert;\n                }\n            }\n            if (parent) {\n                // FIXME: current CA store implementation might have multiple\n                // certificates where the issuer can't be determined from the\n                // certificate (happens rarely with, eg: old certificates) so normalize\n                // by always putting parents into an array\n                // TODO: there's may be an extreme degenerate case currently uncovered\n                // where an old intermediate certificate seems to have a matching parent\n                // but none of the parents actually verify ... but the intermediate\n                // is in the CA and it should pass this check; needs investigation\n                var parents = parent;\n                if (!forge.util.isArray(parents)) {\n                    parents = [\n                        parents\n                    ];\n                }\n                // try to verify with each possible parent (typically only one)\n                var verified = false;\n                while(!verified && parents.length > 0){\n                    parent = parents.shift();\n                    try {\n                        verified = parent.verify(cert);\n                    } catch (ex) {\n                    // failure to verify, don't care why, try next one\n                    }\n                }\n                if (!verified) {\n                    error = {\n                        message: \"Certificate signature is invalid.\",\n                        error: pki.certificateError.bad_certificate\n                    };\n                }\n            }\n            if (error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {\n                // no parent issuer and certificate itself is not trusted\n                error = {\n                    message: \"Certificate is not trusted.\",\n                    error: pki.certificateError.unknown_ca\n                };\n            }\n        }\n        // TODO: 3. check revoked\n        // 4. check for matching issuer/subject\n        if (error === null && parent && !cert.isIssuer(parent)) {\n            // parent is not issuer\n            error = {\n                message: \"Certificate issuer is invalid.\",\n                error: pki.certificateError.bad_certificate\n            };\n        }\n        // 5. TODO: check names with permitted names tree\n        // 6. TODO: check names against excluded names tree\n        // 7. check for unsupported critical extensions\n        if (error === null) {\n            // supported extensions\n            var se = {\n                keyUsage: true,\n                basicConstraints: true\n            };\n            for(var i = 0; error === null && i < cert.extensions.length; ++i){\n                var ext = cert.extensions[i];\n                if (ext.critical && !(ext.name in se)) {\n                    error = {\n                        message: \"Certificate has an unsupported critical extension.\",\n                        error: pki.certificateError.unsupported_certificate\n                    };\n                }\n            }\n        }\n        // 8. check for CA if cert is not first or is the only certificate\n        // remaining in chain with no parent or is self-signed\n        if (error === null && (!first || chain.length === 0 && (!parent || selfSigned))) {\n            // first check keyUsage extension and then basic constraints\n            var bcExt = cert.getExtension(\"basicConstraints\");\n            var keyUsageExt = cert.getExtension(\"keyUsage\");\n            if (keyUsageExt !== null) {\n                // keyCertSign must be true and there must be a basic\n                // constraints extension\n                if (!keyUsageExt.keyCertSign || bcExt === null) {\n                    // bad certificate\n                    error = {\n                        message: \"Certificate keyUsage or basicConstraints conflict \" + \"or indicate that the certificate is not a CA. \" + \"If the certificate is the only one in the chain or \" + \"isn't the first then the certificate must be a \" + \"valid CA.\",\n                        error: pki.certificateError.bad_certificate\n                    };\n                }\n            }\n            // basic constraints cA flag must be set\n            if (error === null && bcExt !== null && !bcExt.cA) {\n                // bad certificate\n                error = {\n                    message: \"Certificate basicConstraints indicates the certificate \" + \"is not a CA.\",\n                    error: pki.certificateError.bad_certificate\n                };\n            }\n            // if error is not null and keyUsage is available, then we know it\n            // has keyCertSign and there is a basic constraints extension too,\n            // which means we can check pathLenConstraint (if it exists)\n            if (error === null && keyUsageExt !== null && \"pathLenConstraint\" in bcExt) {\n                // pathLen is the maximum # of intermediate CA certs that can be\n                // found between the current certificate and the end-entity (depth 0)\n                // certificate; this number does not include the end-entity (depth 0,\n                // last in the chain) even if it happens to be a CA certificate itself\n                var pathLen = depth - 1;\n                if (pathLen > bcExt.pathLenConstraint) {\n                    // pathLenConstraint violated, bad certificate\n                    error = {\n                        message: \"Certificate basicConstraints pathLenConstraint violated.\",\n                        error: pki.certificateError.bad_certificate\n                    };\n                }\n            }\n        }\n        // call application callback\n        var vfd = error === null ? true : error.error;\n        var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;\n        if (ret === true) {\n            // clear any set error\n            error = null;\n        } else {\n            // if passed basic tests, set default message and alert\n            if (vfd === true) {\n                error = {\n                    message: \"The application rejected the certificate.\",\n                    error: pki.certificateError.bad_certificate\n                };\n            }\n            // check for custom error info\n            if (ret || ret === 0) {\n                // set custom message and error\n                if (typeof ret === \"object\" && !forge.util.isArray(ret)) {\n                    if (ret.message) {\n                        error.message = ret.message;\n                    }\n                    if (ret.error) {\n                        error.error = ret.error;\n                    }\n                } else if (typeof ret === \"string\") {\n                    // set custom error\n                    error.error = ret;\n                }\n            }\n            // throw error\n            throw error;\n        }\n        // no longer first cert in chain\n        first = false;\n        ++depth;\n    }while (chain.length > 0);\n    return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIveDUwOS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNEdDO0FBQ0QsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVIseUJBQXlCO0FBQ3pCLElBQUlDLE9BQU9GLE1BQU1FLElBQUk7QUFFckIsbURBQW1ELEdBQ25ELElBQUlDLE1BQU1DLE9BQU9DLE9BQU8sR0FBR0wsTUFBTUcsR0FBRyxHQUFHSCxNQUFNRyxHQUFHLElBQUksQ0FBQztBQUNyRCxJQUFJRyxPQUFPSCxJQUFJRyxJQUFJO0FBRW5CLDBCQUEwQjtBQUMxQixJQUFJQyxjQUFjLENBQUM7QUFDbkJBLFdBQVcsQ0FBQyxLQUFLLEdBQUdELElBQUksQ0FBQyxhQUFhO0FBQ3RDQyxXQUFXLENBQUMsYUFBYSxHQUFHO0FBQzVCQSxXQUFXLENBQUMsSUFBSSxHQUFHRCxJQUFJLENBQUMsY0FBYztBQUN0Q0MsV0FBVyxDQUFDLGNBQWMsR0FBRztBQUM3QkEsV0FBVyxDQUFDLElBQUksR0FBR0QsSUFBSSxDQUFDLGVBQWU7QUFDdkNDLFdBQVcsQ0FBQyxlQUFlLEdBQUc7QUFDOUJBLFdBQVcsQ0FBQyxLQUFLLEdBQUdELElBQUksQ0FBQyxzQkFBc0I7QUFDL0NDLFdBQVcsQ0FBQyxzQkFBc0IsR0FBRztBQUNyQ0EsV0FBVyxDQUFDLElB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QU07b0JBQ3RELElBQUdBLElBQUlaLE9BQU8sRUFBRTt3QkFDZC9QLE1BQU0rUCxPQUFPLEdBQUdZLElBQUlaLE9BQU87b0JBQzdCO29CQUNBLElBQUdZLElBQUkzUSxLQUFLLEVBQUU7d0JBQ1pBLE1BQU1BLEtBQUssR0FBRzJRLElBQUkzUSxLQUFLO29CQUN6QjtnQkFDRixPQUFPLElBQUcsT0FBTzJRLFFBQVEsVUFBVTtvQkFDakMsbUJBQW1CO29CQUNuQjNRLE1BQU1BLEtBQUssR0FBRzJRO2dCQUNoQjtZQUNGO1lBRUEsY0FBYztZQUNkLE1BQU0zUTtRQUNSO1FBRUEsZ0NBQWdDO1FBQ2hDMlAsUUFBUTtRQUNSLEVBQUVDO0lBQ0osUUFBUUosTUFBTXBSLE1BQU0sR0FBRyxHQUFHO0lBRTFCLE9BQU87QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi94NTA5LmpzPzBkZDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIFguNTA5IGFuZCByZWxhdGVkIGNvbXBvbmVudHMgKHN1Y2ggYXNcbiAqIENlcnRpZmljYXRpb24gU2lnbmluZyBSZXF1ZXN0cykgb2YgYSBQdWJsaWMgS2V5IEluZnJhc3RydWN0dXJlLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqXG4gKiBUaGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgYW4gWC41MDl2MyBjZXJ0aWZpY2F0ZSBpcyBhcyBmb2xsb3dzXG4gKiAoc2VlIFJGQyAyNDU5KTpcbiAqXG4gKiBDZXJ0aWZpY2F0ZSA6Oj0gU0VRVUVOQ0Uge1xuICogICB0YnNDZXJ0aWZpY2F0ZSAgICAgICBUQlNDZXJ0aWZpY2F0ZSxcbiAqICAgc2lnbmF0dXJlQWxnb3JpdGhtICAgQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgc2lnbmF0dXJlVmFsdWUgICAgICAgQklUIFNUUklOR1xuICogfVxuICpcbiAqIFRCU0NlcnRpZmljYXRlIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gICAgICAgICBbMF0gIEVYUExJQ0lUIFZlcnNpb24gREVGQVVMVCB2MSxcbiAqICAgc2VyaWFsTnVtYmVyICAgICAgICAgQ2VydGlmaWNhdGVTZXJpYWxOdW1iZXIsXG4gKiAgIHNpZ25hdHVyZSAgICAgICAgICAgIEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGlzc3VlciAgICAgICAgICAgICAgIE5hbWUsXG4gKiAgIHZhbGlkaXR5ICAgICAgICAgICAgIFZhbGlkaXR5LFxuICogICBzdWJqZWN0ICAgICAgICAgICAgICBOYW1lLFxuICogICBzdWJqZWN0UHVibGljS2V5SW5mbyBTdWJqZWN0UHVibGljS2V5SW5mbyxcbiAqICAgaXNzdWVyVW5pcXVlSUQgIFsxXSAgSU1QTElDSVQgVW5pcXVlSWRlbnRpZmllciBPUFRJT05BTCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgLS0gSWYgcHJlc2VudCwgdmVyc2lvbiBzaGFsbCBiZSB2MiBvciB2M1xuICogICBzdWJqZWN0VW5pcXVlSUQgWzJdICBJTVBMSUNJVCBVbmlxdWVJZGVudGlmaWVyIE9QVElPTkFMLFxuICogICAgICAgICAgICAgICAgICAgICAgICAtLSBJZiBwcmVzZW50LCB2ZXJzaW9uIHNoYWxsIGJlIHYyIG9yIHYzXG4gKiAgIGV4dGVuc2lvbnMgICAgICBbM10gIEVYUExJQ0lUIEV4dGVuc2lvbnMgT1BUSU9OQUxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgLS0gSWYgcHJlc2VudCwgdmVyc2lvbiBzaGFsbCBiZSB2M1xuICogfVxuICpcbiAqIFZlcnNpb24gOjo9IElOVEVHRVIgIHsgdjEoMCksIHYyKDEpLCB2MygyKSB9XG4gKlxuICogQ2VydGlmaWNhdGVTZXJpYWxOdW1iZXIgOjo9IElOVEVHRVJcbiAqXG4gKiBOYW1lIDo6PSBDSE9JQ0Uge1xuICogICAvLyBvbmx5IG9uZSBwb3NzaWJsZSBjaG9pY2UgZm9yIG5vd1xuICogICBSRE5TZXF1ZW5jZVxuICogfVxuICpcbiAqIFJETlNlcXVlbmNlIDo6PSBTRVFVRU5DRSBPRiBSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lXG4gKlxuICogUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZSA6Oj0gU0VUIE9GIEF0dHJpYnV0ZVR5cGVBbmRWYWx1ZVxuICpcbiAqIEF0dHJpYnV0ZVR5cGVBbmRWYWx1ZSA6Oj0gU0VRVUVOQ0Uge1xuICogICB0eXBlICAgICBBdHRyaWJ1dGVUeXBlLFxuICogICB2YWx1ZSAgICBBdHRyaWJ1dGVWYWx1ZVxuICogfVxuICogQXR0cmlidXRlVHlwZSA6Oj0gT0JKRUNUIElERU5USUZJRVJcbiAqIEF0dHJpYnV0ZVZhbHVlIDo6PSBBTlkgREVGSU5FRCBCWSBBdHRyaWJ1dGVUeXBlXG4gKlxuICogVmFsaWRpdHkgOjo9IFNFUVVFTkNFIHtcbiAqICAgbm90QmVmb3JlICAgICAgVGltZSxcbiAqICAgbm90QWZ0ZXIgICAgICAgVGltZVxuICogfVxuICpcbiAqIFRpbWUgOjo9IENIT0lDRSB7XG4gKiAgIHV0Y1RpbWUgICAgICAgIFVUQ1RpbWUsXG4gKiAgIGdlbmVyYWxUaW1lICAgIEdlbmVyYWxpemVkVGltZVxuICogfVxuICpcbiAqIFVuaXF1ZUlkZW50aWZpZXIgOjo9IEJJVCBTVFJJTkdcbiAqXG4gKiBTdWJqZWN0UHVibGljS2V5SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBhbGdvcml0aG0gICAgICAgICAgICBBbGdvcml0aG1JZGVudGlmaWVyLFxuICogICBzdWJqZWN0UHVibGljS2V5ICAgICBCSVQgU1RSSU5HXG4gKiB9XG4gKlxuICogRXh0ZW5zaW9ucyA6Oj0gU0VRVUVOQ0UgU0laRSAoMS4uTUFYKSBPRiBFeHRlbnNpb25cbiAqXG4gKiBFeHRlbnNpb24gOjo9IFNFUVVFTkNFIHtcbiAqICAgZXh0bklEICAgICAgT0JKRUNUIElERU5USUZJRVIsXG4gKiAgIGNyaXRpY2FsICAgIEJPT0xFQU4gREVGQVVMVCBGQUxTRSxcbiAqICAgZXh0blZhbHVlICAgT0NURVQgU1RSSU5HXG4gKiB9XG4gKlxuICogVGhlIG9ubHkga2V5IGFsZ29yaXRobSBjdXJyZW50bHkgc3VwcG9ydGVkIGZvciBQS0kgaXMgUlNBLlxuICpcbiAqIFJTQVNTQS1QU1Mgc2lnbmF0dXJlcyBhcmUgZGVzY3JpYmVkIGluIFJGQyAzNDQ3IGFuZCBSRkMgNDA1NS5cbiAqXG4gKiBQS0NTIzEwIHYxLjcgZGVzY3JpYmVzIGNlcnRpZmljYXRlIHNpZ25pbmcgcmVxdWVzdHM6XG4gKlxuICogQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvOlxuICpcbiAqIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgIElOVEVHRVIgeyB2MSgwKSB9ICh2MSwuLi4pLFxuICogICBzdWJqZWN0ICAgICAgIE5hbWUsXG4gKiAgIHN1YmplY3RQS0luZm8gU3ViamVjdFB1YmxpY0tleUluZm97eyBQS0luZm9BbGdvcml0aG1zIH19LFxuICogICBhdHRyaWJ1dGVzICAgIFswXSBBdHRyaWJ1dGVze3sgQ1JJQXR0cmlidXRlcyB9fVxuICogfVxuICpcbiAqIEF0dHJpYnV0ZXMgeyBBVFRSSUJVVEU6SU9TZXQgfSA6Oj0gU0VUIE9GIEF0dHJpYnV0ZXt7IElPU2V0IH19XG4gKlxuICogQ1JJQXR0cmlidXRlcyAgQVRUUklCVVRFICA6Oj0ge1xuICogICAuLi4gLS0gYWRkIGFueSBsb2NhbGx5IGRlZmluZWQgYXR0cmlidXRlcyBoZXJlIC0tIH1cbiAqXG4gKiBBdHRyaWJ1dGUgeyBBVFRSSUJVVEU6SU9TZXQgfSA6Oj0gU0VRVUVOQ0Uge1xuICogICB0eXBlICAgQVRUUklCVVRFLiZpZCh7SU9TZXR9KSxcbiAqICAgdmFsdWVzIFNFVCBTSVpFKDEuLk1BWCkgT0YgQVRUUklCVVRFLiZUeXBlKHtJT1NldH17QHR5cGV9KVxuICogfVxuICpcbiAqIENlcnRpZmljYXRpb25SZXF1ZXN0IDo6PSBTRVFVRU5DRSB7XG4gKiAgIGNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8sXG4gKiAgIHNpZ25hdHVyZUFsZ29yaXRobSBBbGdvcml0aG1JZGVudGlmaWVye3sgU2lnbmF0dXJlQWxnb3JpdGhtcyB9fSxcbiAqICAgc2lnbmF0dXJlICAgICAgICAgIEJJVCBTVFJJTkdcbiAqIH1cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9hZXMnKTtcbnJlcXVpcmUoJy4vYXNuMScpO1xucmVxdWlyZSgnLi9kZXMnKTtcbnJlcXVpcmUoJy4vbWQnKTtcbnJlcXVpcmUoJy4vbWdmJyk7XG5yZXF1aXJlKCcuL29pZHMnKTtcbnJlcXVpcmUoJy4vcGVtJyk7XG5yZXF1aXJlKCcuL3BzcycpO1xucmVxdWlyZSgnLi9yc2EnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBzaG9ydGN1dCBmb3IgYXNuLjEgQVBJXG52YXIgYXNuMSA9IGZvcmdlLmFzbjE7XG5cbi8qIFB1YmxpYyBLZXkgSW5mcmFzdHJ1Y3R1cmUgKFBLSSkgaW1wbGVtZW50YXRpb24uICovXG52YXIgcGtpID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wa2kgPSBmb3JnZS5wa2kgfHwge307XG52YXIgb2lkcyA9IHBraS5vaWRzO1xuXG4vLyBzaG9ydCBuYW1lIE9JRCBtYXBwaW5nc1xudmFyIF9zaG9ydE5hbWVzID0ge307XG5fc2hvcnROYW1lc1snQ04nXSA9IG9pZHNbJ2NvbW1vbk5hbWUnXTtcbl9zaG9ydE5hbWVzWydjb21tb25OYW1lJ10gPSAnQ04nO1xuX3Nob3J0TmFtZXNbJ0MnXSA9IG9pZHNbJ2NvdW50cnlOYW1lJ107XG5fc2hvcnROYW1lc1snY291bnRyeU5hbWUnXSA9ICdDJztcbl9zaG9ydE5hbWVzWydMJ10gPSBvaWRzWydsb2NhbGl0eU5hbWUnXTtcbl9zaG9ydE5hbWVzWydsb2NhbGl0eU5hbWUnXSA9ICdMJztcbl9zaG9ydE5hbWVzWydTVCddID0gb2lkc1snc3RhdGVPclByb3ZpbmNlTmFtZSddO1xuX3Nob3J0TmFtZXNbJ3N0YXRlT3JQcm92aW5jZU5hbWUnXSA9ICdTVCc7XG5fc2hvcnROYW1lc1snTyddID0gb2lkc1snb3JnYW5pemF0aW9uTmFtZSddO1xuX3Nob3J0TmFtZXNbJ29yZ2FuaXphdGlvbk5hbWUnXSA9ICdPJztcbl9zaG9ydE5hbWVzWydPVSddID0gb2lkc1snb3JnYW5pemF0aW9uYWxVbml0TmFtZSddO1xuX3Nob3J0TmFtZXNbJ29yZ2FuaXphdGlvbmFsVW5pdE5hbWUnXSA9ICdPVSc7XG5fc2hvcnROYW1lc1snRSddID0gb2lkc1snZW1haWxBZGRyZXNzJ107XG5fc2hvcnROYW1lc1snZW1haWxBZGRyZXNzJ10gPSAnRSc7XG5cbi8vIHZhbGlkYXRvciBmb3IgYW4gU3ViamVjdFB1YmxpY0tleUluZm8gc3RydWN0dXJlXG4vLyBOb3RlOiBDdXJyZW50bHkgb25seSB3b3JrcyB3aXRoIGFuIFJTQSBwdWJsaWMga2V5XG52YXIgcHVibGljS2V5VmFsaWRhdG9yID0gZm9yZ2UucGtpLnJzYS5wdWJsaWNLZXlWYWxpZGF0b3I7XG5cbi8vIHZhbGlkYXRvciBmb3IgYW4gWC41MDl2MyBjZXJ0aWZpY2F0ZVxudmFyIHg1MDlDZXJ0aWZpY2F0ZVZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0NlcnRpZmljYXRlJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICd0YnNDZXJ0aWZpY2F0ZScsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmVyc2lvbicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgICAgdHlwZTogMCxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZlcnNpb24uaW50ZWdlcicsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ2NlcnRWZXJzaW9uJ1xuICAgICAgfV1cbiAgICB9LCB7XG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc2VyaWFsTnVtYmVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2NlcnRTZXJpYWxOdW1iZXInXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc2lnbmF0dXJlLmFsZ29yaXRobScsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiAnY2VydGluZm9TaWduYXR1cmVPaWQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zaWduYXR1cmUucGFyYW1ldGVycycsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIGNhcHR1cmVBc24xOiAnY2VydGluZm9TaWduYXR1cmVQYXJhbXMnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5pc3N1ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ2NlcnRJc3N1ZXInXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZhbGlkaXR5JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgLy8gTm90ZTogVVRDIGFuZCBnZW5lcmFsaXplZCB0aW1lcyBtYXkgYm90aCBhcHBlYXIgc28gdGhlIGNhcHR1cmVcbiAgICAgIC8vIG5hbWVzIGFyZSBiYXNlZCBvbiB0aGVpciBkZXRlY3RlZCBvcmRlciwgdGhlIG5hbWVzIHVzZWQgYmVsb3dcbiAgICAgIC8vIGFyZSBvbmx5IGZvciB0aGUgY29tbW9uIGNhc2UsIHdoaWNoIHZhbGlkaXR5IHRpbWUgcmVhbGx5IG1lYW5zXG4gICAgICAvLyBcIm5vdEJlZm9yZVwiIGFuZCB3aGljaCBtZWFucyBcIm5vdEFmdGVyXCIgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IG9yZGVyXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgLy8gbm90QmVmb3JlIChUaW1lKSAoVVRDIHRpbWUgY2FzZSlcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZhbGlkaXR5Lm5vdEJlZm9yZSAodXRjKScsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLlVUQ1RJTUUsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIGNhcHR1cmU6ICdjZXJ0VmFsaWRpdHkxVVRDVGltZSdcbiAgICAgIH0sIHtcbiAgICAgICAgLy8gbm90QmVmb3JlIChUaW1lKSAoZ2VuZXJhbGl6ZWQgdGltZSBjYXNlKVxuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHkubm90QmVmb3JlIChnZW5lcmFsaXplZCknLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5HRU5FUkFMSVpFRFRJTUUsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIGNhcHR1cmU6ICdjZXJ0VmFsaWRpdHkyR2VuZXJhbGl6ZWRUaW1lJ1xuICAgICAgfSwge1xuICAgICAgICAvLyBub3RBZnRlciAoVGltZSkgKG9ubHkgVVRDIHRpbWUgaXMgc3VwcG9ydGVkKVxuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHkubm90QWZ0ZXIgKHV0YyknLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5VVENUSU1FLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlOiAnY2VydFZhbGlkaXR5M1VUQ1RpbWUnXG4gICAgICB9LCB7XG4gICAgICAgIC8vIG5vdEFmdGVyIChUaW1lKSAob25seSBVVEMgdGltZSBpcyBzdXBwb3J0ZWQpXG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eS5ub3RBZnRlciAoZ2VuZXJhbGl6ZWQpJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuR0VORVJBTElaRURUSU1FLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlOiAnY2VydFZhbGlkaXR5NEdlbmVyYWxpemVkVGltZSdcbiAgICAgIH1dXG4gICAgfSwge1xuICAgICAgLy8gTmFtZSAoc3ViamVjdCkgKFJETlNlcXVlbmNlKVxuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnN1YmplY3QnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ2NlcnRTdWJqZWN0J1xuICAgIH0sXG4gICAgLy8gU3ViamVjdFB1YmxpY0tleUluZm9cbiAgICBwdWJsaWNLZXlWYWxpZGF0b3IsXG4gICAge1xuICAgICAgLy8gaXNzdWVyVW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLmlzc3VlclVuaXF1ZUlEJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICB0eXBlOiAxLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuaXNzdWVyVW5pcXVlSUQuaWQnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5CSVRTVFJJTkcsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBhcmJpdHJhcnkgYml0IGxlbmd0aCBpZHNcbiAgICAgICAgY2FwdHVyZUJpdFN0cmluZ1ZhbHVlOiAnY2VydElzc3VlclVuaXF1ZUlkJ1xuICAgICAgfV1cbiAgICB9LCB7XG4gICAgICAvLyBzdWJqZWN0VW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnN1YmplY3RVbmlxdWVJRCcsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgICAgdHlwZTogMixcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnN1YmplY3RVbmlxdWVJRC5pZCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICBjYXB0dXJlQml0U3RyaW5nVmFsdWU6ICdjZXJ0U3ViamVjdFVuaXF1ZUlkJ1xuICAgICAgfV1cbiAgICB9LCB7XG4gICAgICAvLyBFeHRlbnNpb25zIChvcHRpb25hbClcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5leHRlbnNpb25zJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICB0eXBlOiAzLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ2NlcnRFeHRlbnNpb25zJyxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfV1cbiAgfSwge1xuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgbmFtZTogJ0NlcnRpZmljYXRlLnNpZ25hdHVyZUFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIC8vIGFsZ29yaXRobVxuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLnNpZ25hdHVyZUFsZ29yaXRobS5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdjZXJ0U2lnbmF0dXJlT2lkJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zaWduYXR1cmUucGFyYW1ldGVycycsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnY2VydFNpZ25hdHVyZVBhcmFtcydcbiAgICB9XVxuICB9LCB7XG4gICAgLy8gU2lnbmF0dXJlVmFsdWVcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGUuc2lnbmF0dXJlVmFsdWUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuQklUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlQml0U3RyaW5nVmFsdWU6ICdjZXJ0U2lnbmF0dXJlJ1xuICB9XVxufTtcblxudmFyIHJzYXNzYVBzc1BhcmFtZXRlclZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ3JzYXBzcycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ3JzYXBzcy5oYXNoQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDAsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAncnNhcHNzLmhhc2hBbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLkNsYXNzLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAncnNhcHNzLmhhc2hBbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG0nLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ2hhc2hPaWQnXG4gICAgICAgIC8qIHBhcmFtZXRlciBibG9jayBvbWl0dGVkLCBmb3IgU0hBMSBOVUxMIGFueWhvdy4gKi9cbiAgICAgIH1dXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdyc2Fwc3MubWFza0dlbkFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAxLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ3JzYXBzcy5tYXNrR2VuQWxnb3JpdGhtLkFsZ29yaXRobUlkZW50aWZpZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5DbGFzcy5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ3JzYXBzcy5tYXNrR2VuQWxnb3JpdGhtLkFsZ29yaXRobUlkZW50aWZpZXIuYWxnb3JpdGhtJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6ICdtYXNrR2VuT2lkJ1xuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAncnNhcHNzLm1hc2tHZW5BbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllci5wYXJhbXMnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgIG5hbWU6ICdyc2Fwc3MubWFza0dlbkFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyLnBhcmFtcy5hbGdvcml0aG0nLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBjYXB0dXJlOiAnbWFza0dlbkhhc2hPaWQnXG4gICAgICAgICAgLyogcGFyYW1ldGVyIGJsb2NrIG9taXR0ZWQsIGZvciBTSEExIE5VTEwgYW55aG93LiAqL1xuICAgICAgICB9XVxuICAgICAgfV1cbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ3JzYXBzcy5zYWx0TGVuZ3RoJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDIsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAncnNhcHNzLnNhbHRMZW5ndGguc2FsdExlbmd0aCcsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLkNsYXNzLklOVEVHRVIsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnc2FsdExlbmd0aCdcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ3JzYXBzcy50cmFpbGVyRmllbGQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMyxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdyc2Fwc3MudHJhaWxlci50cmFpbGVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuQ2xhc3MuSU5URUdFUixcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICd0cmFpbGVyJ1xuICAgIH1dXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGEgQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHN0cnVjdHVyZVxudmFyIGNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgY2FwdHVyZUFzbjE6ICdjZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8nLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmludGVnZXInLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2NlcnRpZmljYXRpb25SZXF1ZXN0SW5mb1ZlcnNpb24nXG4gIH0sIHtcbiAgICAvLyBOYW1lIChzdWJqZWN0KSAoUkROU2VxdWVuY2UpXG4gICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5zdWJqZWN0JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvU3ViamVjdCdcbiAgfSxcbiAgLy8gU3ViamVjdFB1YmxpY0tleUluZm9cbiAgcHVibGljS2V5VmFsaWRhdG9yLFxuICB7XG4gICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5hdHRyaWJ1dGVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDAsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgY2FwdHVyZTogJ2NlcnRpZmljYXRpb25SZXF1ZXN0SW5mb0F0dHJpYnV0ZXMnLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5hdHRyaWJ1dGVzJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8uYXR0cmlidXRlcy50eXBlJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5hdHRyaWJ1dGVzLnZhbHVlJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuU0VULFxuICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZVxuICAgICAgfV1cbiAgICB9XVxuICB9XVxufTtcblxuLy8gdmFsaWRhdG9yIGZvciBhIENlcnRpZmljYXRpb25SZXF1ZXN0IHN0cnVjdHVyZVxudmFyIGNlcnRpZmljYXRpb25SZXF1ZXN0VmFsaWRhdG9yID0ge1xuICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3QnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIGNhcHR1cmVBc24xOiAnY3NyJyxcbiAgdmFsdWU6IFtcbiAgICBjZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9WYWxpZGF0b3IsIHtcbiAgICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3Quc2lnbmF0dXJlQWxnb3JpdGhtJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIC8vIGFsZ29yaXRobVxuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3Quc2lnbmF0dXJlQWxnb3JpdGhtLmFsZ29yaXRobScsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiAnY3NyU2lnbmF0dXJlT2lkJ1xuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3Quc2lnbmF0dXJlQWxnb3JpdGhtLnBhcmFtZXRlcnMnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlQXNuMTogJ2NzclNpZ25hdHVyZVBhcmFtcydcbiAgICAgIH1dXG4gICAgfSwge1xuICAgICAgLy8gc2lnbmF0dXJlXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3Quc2lnbmF0dXJlJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5CSVRTVFJJTkcsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlQml0U3RyaW5nVmFsdWU6ICdjc3JTaWduYXR1cmUnXG4gICAgfVxuICBdXG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJETlNlcXVlbmNlIG9mIEFTTi4xIERFUi1lbmNvZGVkIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWVcbiAqIHNldHMgaW50byBhbiBhcnJheSB3aXRoIG9iamVjdHMgdGhhdCBoYXZlIHR5cGUgYW5kIHZhbHVlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHJkbiB0aGUgUkROU2VxdWVuY2UgdG8gY29udmVydC5cbiAqIEBwYXJhbSBtZCBhIG1lc3NhZ2UgZGlnZXN0IHRvIGFwcGVuZCB0eXBlIGFuZCB2YWx1ZSB0byBpZiBwcm92aWRlZC5cbiAqL1xucGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5ID0gZnVuY3Rpb24ocmRuLCBtZCkge1xuICB2YXIgcnZhbCA9IFtdO1xuXG4gIC8vIGVhY2ggdmFsdWUgaW4gJ3JkbicgaW4gaXMgYSBTRVQgb2YgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZVxuICB2YXIgc2V0LCBhdHRyLCBvYmo7XG4gIGZvcih2YXIgc2kgPSAwOyBzaSA8IHJkbi52YWx1ZS5sZW5ndGg7ICsrc2kpIHtcbiAgICAvLyBnZXQgdGhlIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWUgc2V0XG4gICAgc2V0ID0gcmRuLnZhbHVlW3NpXTtcblxuICAgIC8vIGVhY2ggdmFsdWUgaW4gdGhlIFNFVCBpcyBhbiBBdHRyaWJ1dGVUeXBlQW5kVmFsdWUgc2VxdWVuY2VcbiAgICAvLyBjb250YWluaW5nIGZpcnN0IGEgdHlwZSAoYW4gT0lEKSBhbmQgc2Vjb25kIGEgdmFsdWUgKGRlZmluZWQgYnlcbiAgICAvLyB0aGUgT0lEKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZXQudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIG9iaiA9IHt9O1xuICAgICAgYXR0ciA9IHNldC52YWx1ZVtpXTtcbiAgICAgIG9iai50eXBlID0gYXNuMS5kZXJUb09pZChhdHRyLnZhbHVlWzBdLnZhbHVlKTtcbiAgICAgIG9iai52YWx1ZSA9IGF0dHIudmFsdWVbMV0udmFsdWU7XG4gICAgICBvYmoudmFsdWVUYWdDbGFzcyA9IGF0dHIudmFsdWVbMV0udHlwZTtcbiAgICAgIC8vIGlmIHRoZSBPSUQgaXMga25vd24sIGdldCBpdHMgbmFtZSBhbmQgc2hvcnQgbmFtZVxuICAgICAgaWYob2JqLnR5cGUgaW4gb2lkcykge1xuICAgICAgICBvYmoubmFtZSA9IG9pZHNbb2JqLnR5cGVdO1xuICAgICAgICBpZihvYmoubmFtZSBpbiBfc2hvcnROYW1lcykge1xuICAgICAgICAgIG9iai5zaG9ydE5hbWUgPSBfc2hvcnROYW1lc1tvYmoubmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKG1kKSB7XG4gICAgICAgIG1kLnVwZGF0ZShvYmoudHlwZSk7XG4gICAgICAgIG1kLnVwZGF0ZShvYmoudmFsdWUpO1xuICAgICAgfVxuICAgICAgcnZhbC5wdXNoKG9iaik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIEFTTi4xIENSSUF0dHJpYnV0ZXMgaW50byBhbiBhcnJheSB3aXRoIG9iamVjdHMgdGhhdCBoYXZlIHR5cGUgYW5kXG4gKiB2YWx1ZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSBhdHRyaWJ1dGVzIHRoZSBDUklBdHRyaWJ1dGVzIHRvIGNvbnZlcnQuXG4gKi9cbnBraS5DUklBdHRyaWJ1dGVzQXNBcnJheSA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgdmFyIHJ2YWwgPSBbXTtcblxuICAvLyBlYWNoIHZhbHVlIGluICdhdHRyaWJ1dGVzJyBpbiBpcyBhIFNFUVVFTkNFIHdpdGggYW4gT0lEIGFuZCBhIFNFVFxuICBmb3IodmFyIHNpID0gMDsgc2kgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgKytzaSkge1xuICAgIC8vIGdldCB0aGUgYXR0cmlidXRlIHNlcXVlbmNlXG4gICAgdmFyIHNlcSA9IGF0dHJpYnV0ZXNbc2ldO1xuXG4gICAgLy8gZWFjaCB2YWx1ZSBpbiB0aGUgU0VRVUVOQ0UgY29udGFpbmluZyBmaXJzdCBhIHR5cGUgKGFuIE9JRCkgYW5kXG4gICAgLy8gc2Vjb25kIGEgc2V0IG9mIHZhbHVlcyAoZGVmaW5lZCBieSB0aGUgT0lEKVxuICAgIHZhciB0eXBlID0gYXNuMS5kZXJUb09pZChzZXEudmFsdWVbMF0udmFsdWUpO1xuICAgIHZhciB2YWx1ZXMgPSBzZXEudmFsdWVbMV0udmFsdWU7XG4gICAgZm9yKHZhciB2aSA9IDA7IHZpIDwgdmFsdWVzLmxlbmd0aDsgKyt2aSkge1xuICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgb2JqLnR5cGUgPSB0eXBlO1xuICAgICAgb2JqLnZhbHVlID0gdmFsdWVzW3ZpXS52YWx1ZTtcbiAgICAgIG9iai52YWx1ZVRhZ0NsYXNzID0gdmFsdWVzW3ZpXS50eXBlO1xuICAgICAgLy8gaWYgdGhlIE9JRCBpcyBrbm93biwgZ2V0IGl0cyBuYW1lIGFuZCBzaG9ydCBuYW1lXG4gICAgICBpZihvYmoudHlwZSBpbiBvaWRzKSB7XG4gICAgICAgIG9iai5uYW1lID0gb2lkc1tvYmoudHlwZV07XG4gICAgICAgIGlmKG9iai5uYW1lIGluIF9zaG9ydE5hbWVzKSB7XG4gICAgICAgICAgb2JqLnNob3J0TmFtZSA9IF9zaG9ydE5hbWVzW29iai5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gcGFyc2UgZXh0ZW5zaW9uc1xuICAgICAgaWYob2JqLnR5cGUgPT09IG9pZHMuZXh0ZW5zaW9uUmVxdWVzdCkge1xuICAgICAgICBvYmouZXh0ZW5zaW9ucyA9IFtdO1xuICAgICAgICBmb3IodmFyIGVpID0gMDsgZWkgPCBvYmoudmFsdWUubGVuZ3RoOyArK2VpKSB7XG4gICAgICAgICAgb2JqLmV4dGVuc2lvbnMucHVzaChwa2kuY2VydGlmaWNhdGVFeHRlbnNpb25Gcm9tQXNuMShvYmoudmFsdWVbZWldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJ2YWwucHVzaChvYmopO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIGlzc3VlciBvciBzdWJqZWN0IGF0dHJpYnV0ZSBmcm9tIGl0cyBuYW1lLCB0eXBlLCBvciBzaG9ydCBuYW1lLlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIGlzc3VlciBvciBzdWJqZWN0IG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zIGEgc2hvcnQgbmFtZSBzdHJpbmcgb3IgYW4gb2JqZWN0IHdpdGg6XG4gKiAgICAgICAgICBzaG9ydE5hbWUgdGhlIHNob3J0IG5hbWUgZm9yIHRoZSBhdHRyaWJ1dGUuXG4gKiAgICAgICAgICBuYW1lIHRoZSBuYW1lIGZvciB0aGUgYXR0cmlidXRlLlxuICogICAgICAgICAgdHlwZSB0aGUgdHlwZSBmb3IgdGhlIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhdHRyaWJ1dGUuXG4gKi9cbmZ1bmN0aW9uIF9nZXRBdHRyaWJ1dGUob2JqLCBvcHRpb25zKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7c2hvcnROYW1lOiBvcHRpb25zfTtcbiAgfVxuXG4gIHZhciBydmFsID0gbnVsbDtcbiAgdmFyIGF0dHI7XG4gIGZvcih2YXIgaSA9IDA7IHJ2YWwgPT09IG51bGwgJiYgaSA8IG9iai5hdHRyaWJ1dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgYXR0ciA9IG9iai5hdHRyaWJ1dGVzW2ldO1xuICAgIGlmKG9wdGlvbnMudHlwZSAmJiBvcHRpb25zLnR5cGUgPT09IGF0dHIudHlwZSkge1xuICAgICAgcnZhbCA9IGF0dHI7XG4gICAgfSBlbHNlIGlmKG9wdGlvbnMubmFtZSAmJiBvcHRpb25zLm5hbWUgPT09IGF0dHIubmFtZSkge1xuICAgICAgcnZhbCA9IGF0dHI7XG4gICAgfSBlbHNlIGlmKG9wdGlvbnMuc2hvcnROYW1lICYmIG9wdGlvbnMuc2hvcnROYW1lID09PSBhdHRyLnNob3J0TmFtZSkge1xuICAgICAgcnZhbCA9IGF0dHI7XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHNpZ25hdHVyZSBwYXJhbWV0ZXJzIGZyb20gQVNOLjEgc3RydWN0dXJlLlxuICpcbiAqIEN1cnJlbnRseSBvbmx5IFJTQVNTQS1QU1Mgc3VwcG9ydGVkLiAgVGhlIFBLQ1MjMSB2MS41IHNpZ25hdHVyZSBzY2hlbWUgaGFkXG4gKiBubyBwYXJhbWV0ZXJzLlxuICpcbiAqIFJTQVNTQS1QU1MtcGFyYW1zICA6Oj0gIFNFUVVFTkNFICB7XG4gKiAgIGhhc2hBbGdvcml0aG0gICAgICBbMF0gSGFzaEFsZ29yaXRobSBERUZBVUxUXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhMUlkZW50aWZpZXIsXG4gKiAgIG1hc2tHZW5BbGdvcml0aG0gICBbMV0gTWFza0dlbkFsZ29yaXRobSBERUZBVUxUXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWdmMVNIQTFJZGVudGlmaWVyLFxuICogICBzYWx0TGVuZ3RoICAgICAgICAgWzJdIElOVEVHRVIgREVGQVVMVCAyMCxcbiAqICAgdHJhaWxlckZpZWxkICAgICAgIFszXSBJTlRFR0VSIERFRkFVTFQgMVxuICogfVxuICpcbiAqIEhhc2hBbGdvcml0aG0gIDo6PSAgQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIE1hc2tHZW5BbGdvcml0aG0gIDo6PSAgQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIEFsZ29yaXRobUlkZW50aWZlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgIHBhcmFtZXRlcnMgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMXG4gKiB9XG4gKlxuICogQHBhcmFtIG9pZCBUaGUgT0lEIHNwZWNpZnlpbmcgdGhlIHNpZ25hdHVyZSBhbGdvcml0aG1cbiAqIEBwYXJhbSBvYmogVGhlIEFTTi4xIHN0cnVjdHVyZSBob2xkaW5nIHRoZSBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gZmlsbERlZmF1bHRzIFdoZXRoZXIgdG8gdXNlIHJldHVybiBkZWZhdWx0IHZhbHVlcyB3aGVyZSBvbWl0dGVkXG4gKiBAcmV0dXJuIHNpZ25hdHVyZSBwYXJhbWV0ZXIgb2JqZWN0XG4gKi9cbnZhciBfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMgPSBmdW5jdGlvbihvaWQsIG9iaiwgZmlsbERlZmF1bHRzKSB7XG4gIHZhciBwYXJhbXMgPSB7fTtcblxuICBpZihvaWQgIT09IG9pZHNbJ1JTQVNTQS1QU1MnXSkge1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICBpZihmaWxsRGVmYXVsdHMpIHtcbiAgICBwYXJhbXMgPSB7XG4gICAgICBoYXNoOiB7XG4gICAgICAgIGFsZ29yaXRobU9pZDogb2lkc1snc2hhMSddXG4gICAgICB9LFxuICAgICAgbWdmOiB7XG4gICAgICAgIGFsZ29yaXRobU9pZDogb2lkc1snbWdmMSddLFxuICAgICAgICBoYXNoOiB7XG4gICAgICAgICAgYWxnb3JpdGhtT2lkOiBvaWRzWydzaGExJ11cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNhbHRMZW5ndGg6IDIwXG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCByc2Fzc2FQc3NQYXJhbWV0ZXJWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIFJTQVNTQS1QU1MgcGFyYW1ldGVyIGJsb2NrLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGlmKGNhcHR1cmUuaGFzaE9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zLmhhc2ggPSBwYXJhbXMuaGFzaCB8fCB7fTtcbiAgICBwYXJhbXMuaGFzaC5hbGdvcml0aG1PaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuaGFzaE9pZCk7XG4gIH1cblxuICBpZihjYXB0dXJlLm1hc2tHZW5PaWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHBhcmFtcy5tZ2YgPSBwYXJhbXMubWdmIHx8IHt9O1xuICAgIHBhcmFtcy5tZ2YuYWxnb3JpdGhtT2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLm1hc2tHZW5PaWQpO1xuICAgIHBhcmFtcy5tZ2YuaGFzaCA9IHBhcmFtcy5tZ2YuaGFzaCB8fCB7fTtcbiAgICBwYXJhbXMubWdmLmhhc2guYWxnb3JpdGhtT2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLm1hc2tHZW5IYXNoT2lkKTtcbiAgfVxuXG4gIGlmKGNhcHR1cmUuc2FsdExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zLnNhbHRMZW5ndGggPSBjYXB0dXJlLnNhbHRMZW5ndGguY2hhckNvZGVBdCgwKTtcbiAgfVxuXG4gIHJldHVybiBwYXJhbXM7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBzaWduYXR1cmUgZGlnZXN0IGZvciBPSUQuXG4gKlxuICogQHBhcmFtIG9wdGlvbnNcbiAqICAgc2lnbmF0dXJlT2lkOiB0aGUgT0lEIHNwZWNpZnlpbmcgdGhlIHNpZ25hdHVyZSBhbGdvcml0aG0uXG4gKiAgIHR5cGU6IGEgaHVtYW4gcmVhZGFibGUgdHlwZSBmb3IgZXJyb3IgbWVzc2FnZXNcbiAqIEByZXR1cm4gYSBjcmVhdGVkIG1kIGluc3RhbmNlLiB0aHJvd3MgaWYgdW5rbm93biBvaWQuXG4gKi9cbnZhciBfY3JlYXRlU2lnbmF0dXJlRGlnZXN0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBzd2l0Y2gob2lkc1tvcHRpb25zLnNpZ25hdHVyZU9pZF0pIHtcbiAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgIC8vIGRlcHJlY2F0ZWQgYWxpYXNcbiAgICBjYXNlICdzaGExV2l0aFJTQVNpZ25hdHVyZSc6XG4gICAgICByZXR1cm4gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICBjYXNlICdtZDVXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICByZXR1cm4gZm9yZ2UubWQubWQ1LmNyZWF0ZSgpO1xuICAgIGNhc2UgJ3NoYTI1NldpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgIHJldHVybiBmb3JnZS5tZC5zaGEyNTYuY3JlYXRlKCk7XG4gICAgY2FzZSAnc2hhMzg0V2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgcmV0dXJuIGZvcmdlLm1kLnNoYTM4NC5jcmVhdGUoKTtcbiAgICBjYXNlICdzaGE1MTJXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICByZXR1cm4gZm9yZ2UubWQuc2hhNTEyLmNyZWF0ZSgpO1xuICAgIGNhc2UgJ1JTQVNTQS1QU1MnOlxuICAgICAgcmV0dXJuIGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnQ291bGQgbm90IGNvbXB1dGUgJyArIG9wdGlvbnMudHlwZSArICcgZGlnZXN0LiAnICtcbiAgICAgICAgJ1Vua25vd24gc2lnbmF0dXJlIE9JRC4nKTtcbiAgICAgIGVycm9yLnNpZ25hdHVyZU9pZCA9IG9wdGlvbnMuc2lnbmF0dXJlT2lkO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogVmVyaWZ5IHNpZ25hdHVyZSBvbiBjZXJ0aWZpY2F0ZSBvciBDU1IuXG4gKlxuICogQHBhcmFtIG9wdGlvbnM6XG4gKiAgIGNlcnRpZmljYXRlIHRoZSBjZXJ0aWZpY2F0ZSBvciBDU1IgdG8gdmVyaWZ5LlxuICogICBtZCB0aGUgc2lnbmF0dXJlIGRpZ2VzdC5cbiAqICAgc2lnbmF0dXJlIHRoZSBzaWduYXR1cmVcbiAqIEByZXR1cm4gYSBjcmVhdGVkIG1kIGluc3RhbmNlLiB0aHJvd3MgaWYgdW5rbm93biBvaWQuXG4gKi9cbnZhciBfdmVyaWZ5U2lnbmF0dXJlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgY2VydCA9IG9wdGlvbnMuY2VydGlmaWNhdGU7XG4gIHZhciBzY2hlbWU7XG5cbiAgc3dpdGNoKGNlcnQuc2lnbmF0dXJlT2lkKSB7XG4gICAgY2FzZSBvaWRzLnNoYTFXaXRoUlNBRW5jcnlwdGlvbjpcbiAgICAvLyBkZXByZWNhdGVkIGFsaWFzXG4gICAgY2FzZSBvaWRzLnNoYTFXaXRoUlNBU2lnbmF0dXJlOlxuICAgICAgLyogdXNlIFBLQ1MjMSB2MS41IHBhZGRpbmcgc2NoZW1lICovXG4gICAgICBicmVhaztcbiAgICBjYXNlIG9pZHNbJ1JTQVNTQS1QU1MnXTpcbiAgICAgIHZhciBoYXNoLCBtZ2Y7XG5cbiAgICAgIC8qIGluaXRpYWxpemUgbWdmICovXG4gICAgICBoYXNoID0gb2lkc1tjZXJ0LnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmhhc2guYWxnb3JpdGhtT2lkXTtcbiAgICAgIGlmKGhhc2ggPT09IHVuZGVmaW5lZCB8fCBmb3JnZS5tZFtoYXNoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgTUdGIGhhc2ggZnVuY3Rpb24uJyk7XG4gICAgICAgIGVycm9yLm9pZCA9IGNlcnQuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWQ7XG4gICAgICAgIGVycm9yLm5hbWUgPSBoYXNoO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgbWdmID0gb2lkc1tjZXJ0LnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmFsZ29yaXRobU9pZF07XG4gICAgICBpZihtZ2YgPT09IHVuZGVmaW5lZCB8fCBmb3JnZS5tZ2ZbbWdmXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgTUdGIGZ1bmN0aW9uLicpO1xuICAgICAgICBlcnJvci5vaWQgPSBjZXJ0LnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmFsZ29yaXRobU9pZDtcbiAgICAgICAgZXJyb3IubmFtZSA9IG1nZjtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIG1nZiA9IGZvcmdlLm1nZlttZ2ZdLmNyZWF0ZShmb3JnZS5tZFtoYXNoXS5jcmVhdGUoKSk7XG5cbiAgICAgIC8qIGluaXRpYWxpemUgaGFzaCBmdW5jdGlvbiAqL1xuICAgICAgaGFzaCA9IG9pZHNbY2VydC5zaWduYXR1cmVQYXJhbWV0ZXJzLmhhc2guYWxnb3JpdGhtT2lkXTtcbiAgICAgIGlmKGhhc2ggPT09IHVuZGVmaW5lZCB8fCBmb3JnZS5tZFtoYXNoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUlNBU1NBLVBTUyBoYXNoIGZ1bmN0aW9uLicpO1xuICAgICAgICBlcnJvci5vaWQgPSBjZXJ0LnNpZ25hdHVyZVBhcmFtZXRlcnMuaGFzaC5hbGdvcml0aG1PaWQ7XG4gICAgICAgIGVycm9yLm5hbWUgPSBoYXNoO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgc2NoZW1lID0gZm9yZ2UucHNzLmNyZWF0ZShcbiAgICAgICAgZm9yZ2UubWRbaGFzaF0uY3JlYXRlKCksIG1nZiwgY2VydC5zaWduYXR1cmVQYXJhbWV0ZXJzLnNhbHRMZW5ndGhcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIHZlcmlmeSBzaWduYXR1cmUgb24gY2VydCB1c2luZyBwdWJsaWMga2V5XG4gIHJldHVybiBjZXJ0LnB1YmxpY0tleS52ZXJpZnkoXG4gICAgb3B0aW9ucy5tZC5kaWdlc3QoKS5nZXRCeXRlcygpLCBvcHRpb25zLnNpZ25hdHVyZSwgc2NoZW1lXG4gICk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFguNTA5IGNlcnRpZmljYXRlIGZyb20gUEVNIGZvcm1hdC5cbiAqXG4gKiBOb3RlOiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgdG8gYmUgdmVyaWZpZWQgdGhlbiBjb21wdXRlIGhhc2ggc2hvdWxkXG4gKiBiZSBzZXQgdG8gdHJ1ZS4gVGhpcyB3aWxsIHNjYW4gdGhlIFRCU0NlcnRpZmljYXRlIHBhcnQgb2YgdGhlIEFTTi4xXG4gKiBvYmplY3Qgd2hpbGUgaXQgaXMgY29udmVydGVkIHNvIGl0IGRvZXNuJ3QgbmVlZCB0byBiZSBjb252ZXJ0ZWQgYmFja1xuICogdG8gQVNOLjEtREVSLWVuY29kaW5nIGxhdGVyLlxuICpcbiAqIEBwYXJhbSBwZW0gdGhlIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUuXG4gKiBAcGFyYW0gY29tcHV0ZUhhc2ggdHJ1ZSB0byBjb21wdXRlIHRoZSBoYXNoIGZvciB2ZXJpZmljYXRpb24uXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gYmUgc3RyaWN0IHdoZW4gY2hlY2tpbmcgQVNOLjEgdmFsdWUgbGVuZ3RocywgZmFsc2UgdG9cbiAqICAgICAgICAgIGFsbG93IHRydW5jYXRlZCB2YWx1ZXMgKGRlZmF1bHQ6IHRydWUpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNlcnRpZmljYXRlLlxuICovXG5wa2kuY2VydGlmaWNhdGVGcm9tUGVtID0gZnVuY3Rpb24ocGVtLCBjb21wdXRlSGFzaCwgc3RyaWN0KSB7XG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdDRVJUSUZJQ0FURScgJiZcbiAgICBtc2cudHlwZSAhPT0gJ1g1MDkgQ0VSVElGSUNBVEUnICYmXG4gICAgbXNnLnR5cGUgIT09ICdUUlVTVEVEIENFUlRJRklDQVRFJykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICdDb3VsZCBub3QgY29udmVydCBjZXJ0aWZpY2F0ZSBmcm9tIFBFTTsgUEVNIGhlYWRlciB0eXBlICcgK1xuICAgICAgJ2lzIG5vdCBcIkNFUlRJRklDQVRFXCIsIFwiWDUwOSBDRVJUSUZJQ0FURVwiLCBvciBcIlRSVVNURUQgQ0VSVElGSUNBVEVcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdDb3VsZCBub3QgY29udmVydCBjZXJ0aWZpY2F0ZSBmcm9tIFBFTTsgUEVNIGlzIGVuY3J5cHRlZC4nKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgREVSIHRvIEFTTi4xIG9iamVjdFxuICB2YXIgb2JqID0gYXNuMS5mcm9tRGVyKG1zZy5ib2R5LCBzdHJpY3QpO1xuXG4gIHJldHVybiBwa2kuY2VydGlmaWNhdGVGcm9tQXNuMShvYmosIGNvbXB1dGVIYXNoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gWC41MDkgY2VydGlmaWNhdGUgdG8gUEVNIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUuXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lLCBkZWZhdWx0cyB0byA2NC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlLlxuICovXG5wa2kuY2VydGlmaWNhdGVUb1BlbSA9IGZ1bmN0aW9uKGNlcnQsIG1heGxpbmUpIHtcbiAgLy8gY29udmVydCB0byBBU04uMSwgdGhlbiBERVIsIHRoZW4gUEVNLWVuY29kZVxuICB2YXIgbXNnID0ge1xuICAgIHR5cGU6ICdDRVJUSUZJQ0FURScsXG4gICAgYm9keTogYXNuMS50b0Rlcihwa2kuY2VydGlmaWNhdGVUb0FzbjEoY2VydCkpLmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnLCB7bWF4bGluZTogbWF4bGluZX0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBSU0EgcHVibGljIGtleSBmcm9tIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHBlbSB0aGUgUEVNLWZvcm1hdHRlZCBwdWJsaWMga2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIHB1YmxpYyBrZXkuXG4gKi9cbnBraS5wdWJsaWNLZXlGcm9tUGVtID0gZnVuY3Rpb24ocGVtKSB7XG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdQVUJMSUMgS0VZJyAmJiBtc2cudHlwZSAhPT0gJ1JTQSBQVUJMSUMgS0VZJykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgcHVibGljIGtleSBmcm9tIFBFTTsgUEVNIGhlYWRlciAnICtcbiAgICAgICd0eXBlIGlzIG5vdCBcIlBVQkxJQyBLRVlcIiBvciBcIlJTQSBQVUJMSUMgS0VZXCIuJyk7XG4gICAgZXJyb3IuaGVhZGVyVHlwZSA9IG1zZy50eXBlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIGlmKG1zZy5wcm9jVHlwZSAmJiBtc2cucHJvY1R5cGUudHlwZSA9PT0gJ0VOQ1JZUFRFRCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IHB1YmxpYyBrZXkgZnJvbSBQRU07IFBFTSBpcyBlbmNyeXB0ZWQuJyk7XG4gIH1cblxuICAvLyBjb252ZXJ0IERFUiB0byBBU04uMSBvYmplY3RcbiAgdmFyIG9iaiA9IGFzbjEuZnJvbURlcihtc2cuYm9keSk7XG5cbiAgcmV0dXJuIHBraS5wdWJsaWNLZXlGcm9tQXNuMShvYmopO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBSU0EgcHVibGljIGtleSB0byBQRU0gZm9ybWF0ICh1c2luZyBhIFN1YmplY3RQdWJsaWNLZXlJbmZvKS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBwdWJsaWMga2V5LlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSwgZGVmYXVsdHMgdG8gNjQuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBwdWJsaWMga2V5LlxuICovXG5wa2kucHVibGljS2V5VG9QZW0gPSBmdW5jdGlvbihrZXksIG1heGxpbmUpIHtcbiAgLy8gY29udmVydCB0byBBU04uMSwgdGhlbiBERVIsIHRoZW4gUEVNLWVuY29kZVxuICB2YXIgbXNnID0ge1xuICAgIHR5cGU6ICdQVUJMSUMgS0VZJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKHBraS5wdWJsaWNLZXlUb0FzbjEoa2V5KSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJTQSBwdWJsaWMga2V5IHRvIFBFTSBmb3JtYXQgKHVzaW5nIGFuIFJTQVB1YmxpY0tleSkuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgcHVibGljIGtleS5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIGNoYXJhY3RlcnMgcGVyIGxpbmUsIGRlZmF1bHRzIHRvIDY0LlxuICpcbiAqIEByZXR1cm4gdGhlIFBFTS1mb3JtYXR0ZWQgcHVibGljIGtleS5cbiAqL1xucGtpLnB1YmxpY0tleVRvUlNBUHVibGljS2V5UGVtID0gZnVuY3Rpb24oa2V5LCBtYXhsaW5lKSB7XG4gIC8vIGNvbnZlcnQgdG8gQVNOLjEsIHRoZW4gREVSLCB0aGVuIFBFTS1lbmNvZGVcbiAgdmFyIG1zZyA9IHtcbiAgICB0eXBlOiAnUlNBIFBVQkxJQyBLRVknLFxuICAgIGJvZHk6IGFzbjEudG9EZXIocGtpLnB1YmxpY0tleVRvUlNBUHVibGljS2V5KGtleSkpLmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnLCB7bWF4bGluZTogbWF4bGluZX0pO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgZmluZ2VycHJpbnQgZm9yIHRoZSBnaXZlbiBwdWJsaWMga2V5LlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZS5cbiAqICAgICAgICAgIFttZF0gdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UgKGRlZmF1bHRzIHRvIGZvcmdlLm1kLnNoYTEpLlxuICogICAgICAgICAgW3R5cGVdIHRoZSB0eXBlIG9mIGZpbmdlcnByaW50LCBzdWNoIGFzICdSU0FQdWJsaWNLZXknLFxuICogICAgICAgICAgICAnU3ViamVjdFB1YmxpY0tleUluZm8nIChkZWZhdWx0cyB0byAnUlNBUHVibGljS2V5JykuXG4gKiAgICAgICAgICBbZW5jb2RpbmddIGFuIGFsdGVybmF0aXZlIG91dHB1dCBlbmNvZGluZywgc3VjaCBhcyAnaGV4J1xuICogICAgICAgICAgICAoZGVmYXVsdHMgdG8gbm9uZSwgb3V0cHV0cyBhIGJ5dGUgYnVmZmVyKS5cbiAqICAgICAgICAgIFtkZWxpbWl0ZXJdIHRoZSBkZWxpbWl0ZXIgdG8gdXNlIGJldHdlZW4gYnl0ZXMgZm9yICdoZXgnIGVuY29kZWRcbiAqICAgICAgICAgICAgb3V0cHV0LCBlZzogJzonIChkZWZhdWx0cyB0byBub25lKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBmaW5nZXJwcmludCBhcyBhIGJ5dGUgYnVmZmVyIG9yIG90aGVyIGVuY29kaW5nIGJhc2VkIG9uIG9wdGlvbnMuXG4gKi9cbnBraS5nZXRQdWJsaWNLZXlGaW5nZXJwcmludCA9IGZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIG1kID0gb3B0aW9ucy5tZCB8fCBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICB2YXIgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCAnUlNBUHVibGljS2V5JztcblxuICB2YXIgYnl0ZXM7XG4gIHN3aXRjaCh0eXBlKSB7XG4gICAgY2FzZSAnUlNBUHVibGljS2V5JzpcbiAgICAgIGJ5dGVzID0gYXNuMS50b0Rlcihwa2kucHVibGljS2V5VG9SU0FQdWJsaWNLZXkoa2V5KSkuZ2V0Qnl0ZXMoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1N1YmplY3RQdWJsaWNLZXlJbmZvJzpcbiAgICAgIGJ5dGVzID0gYXNuMS50b0Rlcihwa2kucHVibGljS2V5VG9Bc24xKGtleSkpLmdldEJ5dGVzKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGZpbmdlcnByaW50IHR5cGUgXCInICsgb3B0aW9ucy50eXBlICsgJ1wiLicpO1xuICB9XG5cbiAgLy8gaGFzaCBwdWJsaWMga2V5IGJ5dGVzXG4gIG1kLnN0YXJ0KCk7XG4gIG1kLnVwZGF0ZShieXRlcyk7XG4gIHZhciBkaWdlc3QgPSBtZC5kaWdlc3QoKTtcbiAgaWYob3B0aW9ucy5lbmNvZGluZyA9PT0gJ2hleCcpIHtcbiAgICB2YXIgaGV4ID0gZGlnZXN0LnRvSGV4KCk7XG4gICAgaWYob3B0aW9ucy5kZWxpbWl0ZXIpIHtcbiAgICAgIHJldHVybiBoZXgubWF0Y2goLy57Mn0vZykuam9pbihvcHRpb25zLmRlbGltaXRlcik7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG4gIH0gZWxzZSBpZihvcHRpb25zLmVuY29kaW5nID09PSAnYmluYXJ5Jykge1xuICAgIHJldHVybiBkaWdlc3QuZ2V0Qnl0ZXMoKTtcbiAgfSBlbHNlIGlmKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcgXCInICsgb3B0aW9ucy5lbmNvZGluZyArICdcIi4nKTtcbiAgfVxuICByZXR1cm4gZGlnZXN0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFBLQ1MjMTAgY2VydGlmaWNhdGlvbiByZXF1ZXN0IChDU1IpIGZyb20gUEVNIGZvcm1hdC5cbiAqXG4gKiBOb3RlOiBJZiB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGlzIHRvIGJlIHZlcmlmaWVkIHRoZW4gY29tcHV0ZSBoYXNoXG4gKiBzaG91bGQgYmUgc2V0IHRvIHRydWUuIFRoaXMgd2lsbCBzY2FuIHRoZSBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gcGFydCBvZlxuICogdGhlIEFTTi4xIG9iamVjdCB3aGlsZSBpdCBpcyBjb252ZXJ0ZWQgc28gaXQgZG9lc24ndCBuZWVkIHRvIGJlIGNvbnZlcnRlZFxuICogYmFjayB0byBBU04uMS1ERVItZW5jb2RpbmcgbGF0ZXIuXG4gKlxuICogQHBhcmFtIHBlbSB0aGUgUEVNLWZvcm1hdHRlZCBjZXJ0aWZpY2F0ZS5cbiAqIEBwYXJhbSBjb21wdXRlSGFzaCB0cnVlIHRvIGNvbXB1dGUgdGhlIGhhc2ggZm9yIHZlcmlmaWNhdGlvbi5cbiAqIEBwYXJhbSBzdHJpY3QgdHJ1ZSB0byBiZSBzdHJpY3Qgd2hlbiBjaGVja2luZyBBU04uMSB2YWx1ZSBsZW5ndGhzLCBmYWxzZSB0b1xuICogICAgICAgICAgYWxsb3cgdHJ1bmNhdGVkIHZhbHVlcyAoZGVmYXVsdDogdHJ1ZSkuXG4gKlxuICogQHJldHVybiB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IChDU1IpLlxuICovXG5wa2kuY2VydGlmaWNhdGlvblJlcXVlc3RGcm9tUGVtID0gZnVuY3Rpb24ocGVtLCBjb21wdXRlSGFzaCwgc3RyaWN0KSB7XG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdDRVJUSUZJQ0FURSBSRVFVRVNUJykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGZyb20gUEVNOyAnICtcbiAgICAgICdQRU0gaGVhZGVyIHR5cGUgaXMgbm90IFwiQ0VSVElGSUNBVEUgUkVRVUVTVFwiLicpO1xuICAgIGVycm9yLmhlYWRlclR5cGUgPSBtc2cudHlwZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgZnJvbSBQRU07ICcgK1xuICAgICAgJ1BFTSBpcyBlbmNyeXB0ZWQuJyk7XG4gIH1cblxuICAvLyBjb252ZXJ0IERFUiB0byBBU04uMSBvYmplY3RcbiAgdmFyIG9iaiA9IGFzbjEuZnJvbURlcihtc2cuYm9keSwgc3RyaWN0KTtcblxuICByZXR1cm4gcGtpLmNlcnRpZmljYXRpb25SZXF1ZXN0RnJvbUFzbjEob2JqLCBjb21wdXRlSGFzaCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUEtDUyMxMCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKENTUikgdG8gUEVNIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gY3NyIHRoZSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lLCBkZWZhdWx0cyB0byA2NC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRpb24gcmVxdWVzdC5cbiAqL1xucGtpLmNlcnRpZmljYXRpb25SZXF1ZXN0VG9QZW0gPSBmdW5jdGlvbihjc3IsIG1heGxpbmUpIHtcbiAgLy8gY29udmVydCB0byBBU04uMSwgdGhlbiBERVIsIHRoZW4gUEVNLWVuY29kZVxuICB2YXIgbXNnID0ge1xuICAgIHR5cGU6ICdDRVJUSUZJQ0FURSBSRVFVRVNUJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKHBraS5jZXJ0aWZpY2F0aW9uUmVxdWVzdFRvQXNuMShjc3IpKS5nZXRCeXRlcygpXG4gIH07XG4gIHJldHVybiBmb3JnZS5wZW0uZW5jb2RlKG1zZywge21heGxpbmU6IG1heGxpbmV9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbXB0eSBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmNyZWF0ZUNlcnRpZmljYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjZXJ0ID0ge307XG4gIGNlcnQudmVyc2lvbiA9IDB4MDI7XG4gIGNlcnQuc2VyaWFsTnVtYmVyID0gJzAwJztcbiAgY2VydC5zaWduYXR1cmVPaWQgPSBudWxsO1xuICBjZXJ0LnNpZ25hdHVyZSA9IG51bGw7XG4gIGNlcnQuc2lnaW5mbyA9IHt9O1xuICBjZXJ0LnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gbnVsbDtcbiAgY2VydC52YWxpZGl0eSA9IHt9O1xuICBjZXJ0LnZhbGlkaXR5Lm5vdEJlZm9yZSA9IG5ldyBEYXRlKCk7XG4gIGNlcnQudmFsaWRpdHkubm90QWZ0ZXIgPSBuZXcgRGF0ZSgpO1xuXG4gIGNlcnQuaXNzdWVyID0ge307XG4gIGNlcnQuaXNzdWVyLmdldEZpZWxkID0gZnVuY3Rpb24oc24pIHtcbiAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjZXJ0Lmlzc3Vlciwgc24pO1xuICB9O1xuICBjZXJ0Lmlzc3Vlci5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNlcnQuaXNzdWVyLmF0dHJpYnV0ZXMgPSBbXTtcbiAgY2VydC5pc3N1ZXIuaGFzaCA9IG51bGw7XG5cbiAgY2VydC5zdWJqZWN0ID0ge307XG4gIGNlcnQuc3ViamVjdC5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY2VydC5zdWJqZWN0LCBzbik7XG4gIH07XG4gIGNlcnQuc3ViamVjdC5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjZXJ0LnN1YmplY3QuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjZXJ0LnN1YmplY3QuYXR0cmlidXRlcyA9IFtdO1xuICBjZXJ0LnN1YmplY3QuaGFzaCA9IG51bGw7XG5cbiAgY2VydC5leHRlbnNpb25zID0gW107XG4gIGNlcnQucHVibGljS2V5ID0gbnVsbDtcbiAgY2VydC5tZCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN1YmplY3Qgb2YgdGhpcyBjZXJ0aWZpY2F0ZS5cbiAgICpcbiAgICogQHBhcmFtIGF0dHJzIHRoZSBhcnJheSBvZiBzdWJqZWN0IGF0dHJpYnV0ZXMgdG8gdXNlLlxuICAgKiBAcGFyYW0gdW5pcXVlSWQgYW4gb3B0aW9uYWwgYSB1bmlxdWUgSUQgdG8gdXNlLlxuICAgKi9cbiAgY2VydC5zZXRTdWJqZWN0ID0gZnVuY3Rpb24oYXR0cnMsIHVuaXF1ZUlkKSB7XG4gICAgLy8gc2V0IG5ldyBhdHRyaWJ1dGVzLCBjbGVhciBoYXNoXG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKGF0dHJzKTtcbiAgICBjZXJ0LnN1YmplY3QuYXR0cmlidXRlcyA9IGF0dHJzO1xuICAgIGRlbGV0ZSBjZXJ0LnN1YmplY3QudW5pcXVlSWQ7XG4gICAgaWYodW5pcXVlSWQpIHtcbiAgICAgIC8vIFRPRE86IHN1cHBvcnQgYXJiaXRyYXJ5IGJpdCBsZW5ndGggaWRzXG4gICAgICBjZXJ0LnN1YmplY3QudW5pcXVlSWQgPSB1bmlxdWVJZDtcbiAgICB9XG4gICAgY2VydC5zdWJqZWN0Lmhhc2ggPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpc3N1ZXIgb2YgdGhpcyBjZXJ0aWZpY2F0ZS5cbiAgICpcbiAgICogQHBhcmFtIGF0dHJzIHRoZSBhcnJheSBvZiBpc3N1ZXIgYXR0cmlidXRlcyB0byB1c2UuXG4gICAqIEBwYXJhbSB1bmlxdWVJZCBhbiBvcHRpb25hbCBhIHVuaXF1ZSBJRCB0byB1c2UuXG4gICAqL1xuICBjZXJ0LnNldElzc3VlciA9IGZ1bmN0aW9uKGF0dHJzLCB1bmlxdWVJZCkge1xuICAgIC8vIHNldCBuZXcgYXR0cmlidXRlcywgY2xlYXIgaGFzaFxuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhhdHRycyk7XG4gICAgY2VydC5pc3N1ZXIuYXR0cmlidXRlcyA9IGF0dHJzO1xuICAgIGRlbGV0ZSBjZXJ0Lmlzc3Vlci51bmlxdWVJZDtcbiAgICBpZih1bmlxdWVJZCkge1xuICAgICAgLy8gVE9ETzogc3VwcG9ydCBhcmJpdHJhcnkgYml0IGxlbmd0aCBpZHNcbiAgICAgIGNlcnQuaXNzdWVyLnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG4gICAgfVxuICAgIGNlcnQuaXNzdWVyLmhhc2ggPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBleHRlbnNpb25zIG9mIHRoaXMgY2VydGlmaWNhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBleHRzIHRoZSBhcnJheSBvZiBleHRlbnNpb25zIHRvIHVzZS5cbiAgICovXG4gIGNlcnQuc2V0RXh0ZW5zaW9ucyA9IGZ1bmN0aW9uKGV4dHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZXh0cy5sZW5ndGg7ICsraSkge1xuICAgICAgX2ZpbGxNaXNzaW5nRXh0ZW5zaW9uRmllbGRzKGV4dHNbaV0sIHtjZXJ0OiBjZXJ0fSk7XG4gICAgfVxuICAgIC8vIHNldCBuZXcgZXh0ZW5zaW9uc1xuICAgIGNlcnQuZXh0ZW5zaW9ucyA9IGV4dHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gZXh0ZW5zaW9uIGJ5IGl0cyBuYW1lIG9yIGlkLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgbmFtZSB0byB1c2Ugb3IgYW4gb2JqZWN0IHdpdGg6XG4gICAqICAgICAgICAgIG5hbWUgdGhlIG5hbWUgdG8gdXNlLlxuICAgKiAgICAgICAgICBpZCB0aGUgaWQgdG8gdXNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBleHRlbnNpb24gb3IgbnVsbCBpZiBub3QgZm91bmQuXG4gICAqL1xuICBjZXJ0LmdldEV4dGVuc2lvbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdGlvbnMgPSB7bmFtZTogb3B0aW9uc307XG4gICAgfVxuXG4gICAgdmFyIHJ2YWwgPSBudWxsO1xuICAgIHZhciBleHQ7XG4gICAgZm9yKHZhciBpID0gMDsgcnZhbCA9PT0gbnVsbCAmJiBpIDwgY2VydC5leHRlbnNpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICBleHQgPSBjZXJ0LmV4dGVuc2lvbnNbaV07XG4gICAgICBpZihvcHRpb25zLmlkICYmIGV4dC5pZCA9PT0gb3B0aW9ucy5pZCkge1xuICAgICAgICBydmFsID0gZXh0O1xuICAgICAgfSBlbHNlIGlmKG9wdGlvbnMubmFtZSAmJiBleHQubmFtZSA9PT0gb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIHJ2YWwgPSBleHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaWducyB0aGlzIGNlcnRpZmljYXRlIHVzaW5nIHRoZSBnaXZlbiBwcml2YXRlIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkgdG8gc2lnbiB3aXRoLlxuICAgKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UgKGRlZmF1bHRzIHRvIGZvcmdlLm1kLnNoYTEpLlxuICAgKi9cbiAgY2VydC5zaWduID0gZnVuY3Rpb24oa2V5LCBtZCkge1xuICAgIC8vIFRPRE86IGdldCBzaWduYXR1cmUgT0lEIGZyb20gcHJpdmF0ZSBrZXlcbiAgICBjZXJ0Lm1kID0gbWQgfHwgZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICB2YXIgYWxnb3JpdGhtT2lkID0gb2lkc1tjZXJ0Lm1kLmFsZ29yaXRobSArICdXaXRoUlNBRW5jcnlwdGlvbiddO1xuICAgIGlmKCFhbGdvcml0aG1PaWQpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbXB1dGUgY2VydGlmaWNhdGUgZGlnZXN0LiAnICtcbiAgICAgICAgJ1Vua25vd24gbWVzc2FnZSBkaWdlc3QgYWxnb3JpdGhtIE9JRC4nKTtcbiAgICAgIGVycm9yLmFsZ29yaXRobSA9IGNlcnQubWQuYWxnb3JpdGhtO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNlcnQuc2lnbmF0dXJlT2lkID0gY2VydC5zaWdpbmZvLmFsZ29yaXRobU9pZCA9IGFsZ29yaXRobU9pZDtcblxuICAgIC8vIGdldCBUQlNDZXJ0aWZpY2F0ZSwgY29udmVydCB0byBERVJcbiAgICBjZXJ0LnRic0NlcnRpZmljYXRlID0gcGtpLmdldFRCU0NlcnRpZmljYXRlKGNlcnQpO1xuICAgIHZhciBieXRlcyA9IGFzbjEudG9EZXIoY2VydC50YnNDZXJ0aWZpY2F0ZSk7XG5cbiAgICAvLyBkaWdlc3QgYW5kIHNpZ25cbiAgICBjZXJ0Lm1kLnVwZGF0ZShieXRlcy5nZXRCeXRlcygpKTtcbiAgICBjZXJ0LnNpZ25hdHVyZSA9IGtleS5zaWduKGNlcnQubWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB2ZXJpZnkgdGhlIHNpZ25hdHVyZSBvbiB0aGUgcGFzc2VkIGNlcnRpZmljYXRlIHVzaW5nIHRoaXNcbiAgICogY2VydGlmaWNhdGUncyBwdWJsaWMga2V5LlxuICAgKlxuICAgKiBAcGFyYW0gY2hpbGQgdGhlIGNlcnRpZmljYXRlIHRvIHZlcmlmeS5cbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHZlcmlmaWVkLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICBjZXJ0LnZlcmlmeSA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgdmFyIHJ2YWwgPSBmYWxzZTtcblxuICAgIGlmKCFjZXJ0Lmlzc3VlZChjaGlsZCkpIHtcbiAgICAgIHZhciBpc3N1ZXIgPSBjaGlsZC5pc3N1ZXI7XG4gICAgICB2YXIgc3ViamVjdCA9IGNlcnQuc3ViamVjdDtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSBwYXJlbnQgY2VydGlmaWNhdGUgZGlkIG5vdCBpc3N1ZSB0aGUgZ2l2ZW4gY2hpbGQgJyArXG4gICAgICAgICdjZXJ0aWZpY2F0ZTsgdGhlIGNoaWxkIGNlcnRpZmljYXRlXFwncyBpc3N1ZXIgZG9lcyBub3QgbWF0Y2ggdGhlICcgK1xuICAgICAgICAncGFyZW50XFwncyBzdWJqZWN0LicpO1xuICAgICAgZXJyb3IuZXhwZWN0ZWRJc3N1ZXIgPSBzdWJqZWN0LmF0dHJpYnV0ZXM7XG4gICAgICBlcnJvci5hY3R1YWxJc3N1ZXIgPSBpc3N1ZXIuYXR0cmlidXRlcztcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHZhciBtZCA9IGNoaWxkLm1kO1xuICAgIGlmKG1kID09PSBudWxsKSB7XG4gICAgICAvLyBjcmVhdGUgZGlnZXN0IGZvciBPSUQgc2lnbmF0dXJlIHR5cGVzXG4gICAgICBtZCA9IF9jcmVhdGVTaWduYXR1cmVEaWdlc3Qoe1xuICAgICAgICBzaWduYXR1cmVPaWQ6IGNoaWxkLnNpZ25hdHVyZU9pZCxcbiAgICAgICAgdHlwZTogJ2NlcnRpZmljYXRlJ1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHByb2R1Y2UgREVSIGZvcm1hdHRlZCBUQlNDZXJ0aWZpY2F0ZSBhbmQgZGlnZXN0IGl0XG4gICAgICB2YXIgdGJzQ2VydGlmaWNhdGUgPSBjaGlsZC50YnNDZXJ0aWZpY2F0ZSB8fCBwa2kuZ2V0VEJTQ2VydGlmaWNhdGUoY2hpbGQpO1xuICAgICAgdmFyIGJ5dGVzID0gYXNuMS50b0Rlcih0YnNDZXJ0aWZpY2F0ZSk7XG4gICAgICBtZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gICAgfVxuXG4gICAgaWYobWQgIT09IG51bGwpIHtcbiAgICAgIHJ2YWwgPSBfdmVyaWZ5U2lnbmF0dXJlKHtcbiAgICAgICAgY2VydGlmaWNhdGU6IGNlcnQsIG1kOiBtZCwgc2lnbmF0dXJlOiBjaGlsZC5zaWduYXR1cmVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjZXJ0aWZpY2F0ZSdzIGlzc3VlciBtYXRjaGVzIHRoZSBwYXNzZWRcbiAgICogY2VydGlmaWNhdGUncyBzdWJqZWN0LiBOb3RlIHRoYXQgbm8gc2lnbmF0dXJlIGNoZWNrIGlzIHBlcmZvcm1lZC5cbiAgICpcbiAgICogQHBhcmFtIHBhcmVudCB0aGUgY2VydGlmaWNhdGUgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGNlcnRpZmljYXRlJ3MgaXNzdWVyIG1hdGNoZXMgdGhlIHBhc3NlZCBjZXJ0aWZpY2F0ZSdzXG4gICAqICAgICAgICAgc3ViamVjdC5cbiAgICovXG4gIGNlcnQuaXNJc3N1ZXIgPSBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICB2YXIgcnZhbCA9IGZhbHNlO1xuXG4gICAgdmFyIGkgPSBjZXJ0Lmlzc3VlcjtcbiAgICB2YXIgcyA9IHBhcmVudC5zdWJqZWN0O1xuXG4gICAgLy8gY29tcGFyZSBoYXNoZXMgaWYgcHJlc2VudFxuICAgIGlmKGkuaGFzaCAmJiBzLmhhc2gpIHtcbiAgICAgIHJ2YWwgPSAoaS5oYXNoID09PSBzLmhhc2gpO1xuICAgIH0gZWxzZSBpZihpLmF0dHJpYnV0ZXMubGVuZ3RoID09PSBzLmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAvLyBhbGwgYXR0cmlidXRlcyBhcmUgdGhlIHNhbWUgc28gaXNzdWVyIG1hdGNoZXMgc3ViamVjdFxuICAgICAgcnZhbCA9IHRydWU7XG4gICAgICB2YXIgaWF0dHIsIHNhdHRyO1xuICAgICAgZm9yKHZhciBuID0gMDsgcnZhbCAmJiBuIDwgaS5hdHRyaWJ1dGVzLmxlbmd0aDsgKytuKSB7XG4gICAgICAgIGlhdHRyID0gaS5hdHRyaWJ1dGVzW25dO1xuICAgICAgICBzYXR0ciA9IHMuYXR0cmlidXRlc1tuXTtcbiAgICAgICAgaWYoaWF0dHIudHlwZSAhPT0gc2F0dHIudHlwZSB8fCBpYXR0ci52YWx1ZSAhPT0gc2F0dHIudmFsdWUpIHtcbiAgICAgICAgICAvLyBhdHRyaWJ1dGUgbWlzbWF0Y2hcbiAgICAgICAgICBydmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY2VydGlmaWNhdGUncyBzdWJqZWN0IG1hdGNoZXMgdGhlIGlzc3VlciBvZiB0aGVcbiAgICogZ2l2ZW4gY2VydGlmaWNhdGUpLiBOb3RlIHRoYXQgbm90IHNpZ25hdHVyZSBjaGVjayBpcyBwZXJmb3JtZWQuXG4gICAqXG4gICAqIEBwYXJhbSBjaGlsZCB0aGUgY2VydGlmaWNhdGUgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGNlcnRpZmljYXRlJ3Mgc3ViamVjdCBtYXRjaGVzIHRoZSBwYXNzZWRcbiAgICogICAgICAgICBjZXJ0aWZpY2F0ZSdzIGlzc3Vlci5cbiAgICovXG4gIGNlcnQuaXNzdWVkID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQuaXNJc3N1ZXIoY2VydCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgc3ViamVjdEtleUlkZW50aWZpZXIgZm9yIHRoaXMgY2VydGlmaWNhdGUgYXMgYnl0ZSBidWZmZXIuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHN1YmplY3RLZXlJZGVudGlmaWVyIGZvciB0aGlzIGNlcnRpZmljYXRlIGFzIGJ5dGUgYnVmZmVyLlxuICAgKi9cbiAgY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XG4gICAgLyogU2VlOiA0LjIuMS4yIHNlY3Rpb24gb2YgdGhlIHRoZSBSRkMzMjgwLCBrZXlJZGVudGlmaWVyIGlzIGVpdGhlcjpcblxuICAgICAgKDEpIFRoZSBrZXlJZGVudGlmaWVyIGlzIGNvbXBvc2VkIG9mIHRoZSAxNjAtYml0IFNIQS0xIGhhc2ggb2YgdGhlXG4gICAgICAgIHZhbHVlIG9mIHRoZSBCSVQgU1RSSU5HIHN1YmplY3RQdWJsaWNLZXkgKGV4Y2x1ZGluZyB0aGUgdGFnLFxuICAgICAgICBsZW5ndGgsIGFuZCBudW1iZXIgb2YgdW51c2VkIGJpdHMpLlxuXG4gICAgICAoMikgVGhlIGtleUlkZW50aWZpZXIgaXMgY29tcG9zZWQgb2YgYSBmb3VyIGJpdCB0eXBlIGZpZWxkIHdpdGhcbiAgICAgICAgdGhlIHZhbHVlIDAxMDAgZm9sbG93ZWQgYnkgdGhlIGxlYXN0IHNpZ25pZmljYW50IDYwIGJpdHMgb2YgdGhlXG4gICAgICAgIFNIQS0xIGhhc2ggb2YgdGhlIHZhbHVlIG9mIHRoZSBCSVQgU1RSSU5HIHN1YmplY3RQdWJsaWNLZXlcbiAgICAgICAgKGV4Y2x1ZGluZyB0aGUgdGFnLCBsZW5ndGgsIGFuZCBudW1iZXIgb2YgdW51c2VkIGJpdCBzdHJpbmcgYml0cykuXG4gICAgKi9cblxuICAgIC8vIHNraXBwaW5nIHRoZSB0YWcsIGxlbmd0aCwgYW5kIG51bWJlciBvZiB1bnVzZWQgYml0cyBpcyB0aGUgc2FtZVxuICAgIC8vIGFzIGp1c3QgdXNpbmcgdGhlIFJTQVB1YmxpY0tleSAoZm9yIFJTQSBrZXlzLCB3aGljaCBhcmUgdGhlXG4gICAgLy8gb25seSBvbmVzIHN1cHBvcnRlZClcbiAgICByZXR1cm4gcGtpLmdldFB1YmxpY0tleUZpbmdlcnByaW50KGNlcnQucHVibGljS2V5LCB7dHlwZTogJ1JTQVB1YmxpY0tleSd9KTtcbiAgfTtcblxuICAvKipcbiAgICogVmVyaWZpZXMgdGhlIHN1YmplY3RLZXlJZGVudGlmaWVyIGV4dGVuc2lvbiB2YWx1ZSBmb3IgdGhpcyBjZXJ0aWZpY2F0ZVxuICAgKiBhZ2FpbnN0IGl0cyBwdWJsaWMga2V5LiBJZiBubyBleHRlbnNpb24gaXMgZm91bmQsIGZhbHNlIHdpbGwgYmVcbiAgICogcmV0dXJuZWQuXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB2ZXJpZmllZCwgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAgY2VydC52ZXJpZnlTdWJqZWN0S2V5SWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvaWQgPSBvaWRzWydzdWJqZWN0S2V5SWRlbnRpZmllciddO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBleHQgPSBjZXJ0LmV4dGVuc2lvbnNbaV07XG4gICAgICBpZihleHQuaWQgPT09IG9pZCkge1xuICAgICAgICB2YXIgc2tpID0gY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyKCkuZ2V0Qnl0ZXMoKTtcbiAgICAgICAgcmV0dXJuIChmb3JnZS51dGlsLmhleFRvQnl0ZXMoZXh0LnN1YmplY3RLZXlJZGVudGlmaWVyKSA9PT0gc2tpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHJldHVybiBjZXJ0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZSBmcm9tIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBOb3RlOiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgdG8gYmUgdmVyaWZpZWQgdGhlbiBjb21wdXRlIGhhc2ggc2hvdWxkXG4gKiBiZSBzZXQgdG8gdHJ1ZS4gVGhlcmUgaXMgY3VycmVudGx5IG5vIGltcGxlbWVudGF0aW9uIGZvciBjb252ZXJ0aW5nXG4gKiBhIGNlcnRpZmljYXRlIGJhY2sgdG8gQVNOLjEgc28gdGhlIFRCU0NlcnRpZmljYXRlIHBhcnQgb2YgdGhlIEFTTi4xXG4gKiBvYmplY3QgbmVlZHMgdG8gYmUgc2Nhbm5lZCBiZWZvcmUgdGhlIGNlcnQgb2JqZWN0IGlzIGNyZWF0ZWQuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhbiBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZS5cbiAqIEBwYXJhbSBjb21wdXRlSGFzaCB0cnVlIHRvIGNvbXB1dGUgdGhlIGhhc2ggZm9yIHZlcmlmaWNhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmNlcnRpZmljYXRlRnJvbUFzbjEgPSBmdW5jdGlvbihvYmosIGNvbXB1dGVIYXNoKSB7XG4gIC8vIHZhbGlkYXRlIGNlcnRpZmljYXRlIGFuZCBjYXB0dXJlIGRhdGFcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIHg1MDlDZXJ0aWZpY2F0ZVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgWC41MDkgY2VydGlmaWNhdGUuICcgK1xuICAgICAgJ0FTTi4xIG9iamVjdCBpcyBub3QgYW4gWDUwOXYzIENlcnRpZmljYXRlLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGdldCBvaWRcbiAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5wdWJsaWNLZXlPaWQpO1xuICBpZihvaWQgIT09IHBraS5vaWRzLnJzYUVuY3J5cHRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHB1YmxpYyBrZXkuIE9JRCBpcyBub3QgUlNBLicpO1xuICB9XG5cbiAgLy8gY3JlYXRlIGNlcnRpZmljYXRlXG4gIHZhciBjZXJ0ID0gcGtpLmNyZWF0ZUNlcnRpZmljYXRlKCk7XG4gIGNlcnQudmVyc2lvbiA9IGNhcHR1cmUuY2VydFZlcnNpb24gP1xuICAgIGNhcHR1cmUuY2VydFZlcnNpb24uY2hhckNvZGVBdCgwKSA6IDA7XG4gIHZhciBzZXJpYWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLmNlcnRTZXJpYWxOdW1iZXIpO1xuICBjZXJ0LnNlcmlhbE51bWJlciA9IHNlcmlhbC50b0hleCgpO1xuICBjZXJ0LnNpZ25hdHVyZU9pZCA9IGZvcmdlLmFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jZXJ0U2lnbmF0dXJlT2lkKTtcbiAgY2VydC5zaWduYXR1cmVQYXJhbWV0ZXJzID0gX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzKFxuICAgIGNlcnQuc2lnbmF0dXJlT2lkLCBjYXB0dXJlLmNlcnRTaWduYXR1cmVQYXJhbXMsIHRydWUpO1xuICBjZXJ0LnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmNlcnRpbmZvU2lnbmF0dXJlT2lkKTtcbiAgY2VydC5zaWdpbmZvLnBhcmFtZXRlcnMgPSBfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMoY2VydC5zaWdpbmZvLmFsZ29yaXRobU9pZCxcbiAgICBjYXB0dXJlLmNlcnRpbmZvU2lnbmF0dXJlUGFyYW1zLCBmYWxzZSk7XG4gIGNlcnQuc2lnbmF0dXJlID0gY2FwdHVyZS5jZXJ0U2lnbmF0dXJlO1xuXG4gIHZhciB2YWxpZGl0eSA9IFtdO1xuICBpZihjYXB0dXJlLmNlcnRWYWxpZGl0eTFVVENUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWxpZGl0eS5wdXNoKGFzbjEudXRjVGltZVRvRGF0ZShjYXB0dXJlLmNlcnRWYWxpZGl0eTFVVENUaW1lKSk7XG4gIH1cbiAgaWYoY2FwdHVyZS5jZXJ0VmFsaWRpdHkyR2VuZXJhbGl6ZWRUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWxpZGl0eS5wdXNoKGFzbjEuZ2VuZXJhbGl6ZWRUaW1lVG9EYXRlKFxuICAgICAgY2FwdHVyZS5jZXJ0VmFsaWRpdHkyR2VuZXJhbGl6ZWRUaW1lKSk7XG4gIH1cbiAgaWYoY2FwdHVyZS5jZXJ0VmFsaWRpdHkzVVRDVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRpdHkucHVzaChhc24xLnV0Y1RpbWVUb0RhdGUoY2FwdHVyZS5jZXJ0VmFsaWRpdHkzVVRDVGltZSkpO1xuICB9XG4gIGlmKGNhcHR1cmUuY2VydFZhbGlkaXR5NEdlbmVyYWxpemVkVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRpdHkucHVzaChhc24xLmdlbmVyYWxpemVkVGltZVRvRGF0ZShcbiAgICAgIGNhcHR1cmUuY2VydFZhbGlkaXR5NEdlbmVyYWxpemVkVGltZSkpO1xuICB9XG4gIGlmKHZhbGlkaXR5Lmxlbmd0aCA+IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIG5vdEJlZm9yZS9ub3RBZnRlciB2YWxpZGl0eSB0aW1lczsgbW9yZSAnICtcbiAgICAgICd0aGFuIHR3byB0aW1lcyB3ZXJlIHByb3ZpZGVkIGluIHRoZSBjZXJ0aWZpY2F0ZS4nKTtcbiAgfVxuICBpZih2YWxpZGl0eS5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBub3RCZWZvcmUvbm90QWZ0ZXIgdmFsaWRpdHkgdGltZXM7IHRoZXkgJyArXG4gICAgICAnd2VyZSBub3QgcHJvdmlkZWQgYXMgZWl0aGVyIFVUQ1RpbWUgb3IgR2VuZXJhbGl6ZWRUaW1lLicpO1xuICB9XG4gIGNlcnQudmFsaWRpdHkubm90QmVmb3JlID0gdmFsaWRpdHlbMF07XG4gIGNlcnQudmFsaWRpdHkubm90QWZ0ZXIgPSB2YWxpZGl0eVsxXTtcblxuICAvLyBrZWVwIFRCU0NlcnRpZmljYXRlIHRvIHByZXNlcnZlIHNpZ25hdHVyZSB3aGVuIGV4cG9ydGluZ1xuICBjZXJ0LnRic0NlcnRpZmljYXRlID0gY2FwdHVyZS50YnNDZXJ0aWZpY2F0ZTtcblxuICBpZihjb21wdXRlSGFzaCkge1xuICAgIC8vIGNyZWF0ZSBkaWdlc3QgZm9yIE9JRCBzaWduYXR1cmUgdHlwZVxuICAgIGNlcnQubWQgPSBfY3JlYXRlU2lnbmF0dXJlRGlnZXN0KHtcbiAgICAgIHNpZ25hdHVyZU9pZDogY2VydC5zaWduYXR1cmVPaWQsXG4gICAgICB0eXBlOiAnY2VydGlmaWNhdGUnXG4gICAgfSk7XG5cbiAgICAvLyBwcm9kdWNlIERFUiBmb3JtYXR0ZWQgVEJTQ2VydGlmaWNhdGUgYW5kIGRpZ2VzdCBpdFxuICAgIHZhciBieXRlcyA9IGFzbjEudG9EZXIoY2VydC50YnNDZXJ0aWZpY2F0ZSk7XG4gICAgY2VydC5tZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gIH1cblxuICAvLyBoYW5kbGUgaXNzdWVyLCBidWlsZCBpc3N1ZXIgbWVzc2FnZSBkaWdlc3RcbiAgdmFyIGltZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIHZhciBpYnl0ZXMgPSBhc24xLnRvRGVyKGNhcHR1cmUuY2VydElzc3Vlcik7XG4gIGltZC51cGRhdGUoaWJ5dGVzLmdldEJ5dGVzKCkpO1xuICBjZXJ0Lmlzc3Vlci5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY2VydC5pc3N1ZXIsIHNuKTtcbiAgfTtcbiAgY2VydC5pc3N1ZXIuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY2VydC5pc3N1ZXIuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzID0gcGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5KGNhcHR1cmUuY2VydElzc3Vlcik7XG4gIGlmKGNhcHR1cmUuY2VydElzc3VlclVuaXF1ZUlkKSB7XG4gICAgY2VydC5pc3N1ZXIudW5pcXVlSWQgPSBjYXB0dXJlLmNlcnRJc3N1ZXJVbmlxdWVJZDtcbiAgfVxuICBjZXJ0Lmlzc3Vlci5oYXNoID0gaW1kLmRpZ2VzdCgpLnRvSGV4KCk7XG5cbiAgLy8gaGFuZGxlIHN1YmplY3QsIGJ1aWxkIHN1YmplY3QgbWVzc2FnZSBkaWdlc3RcbiAgdmFyIHNtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIHZhciBzYnl0ZXMgPSBhc24xLnRvRGVyKGNhcHR1cmUuY2VydFN1YmplY3QpO1xuICBzbWQudXBkYXRlKHNieXRlcy5nZXRCeXRlcygpKTtcbiAgY2VydC5zdWJqZWN0LmdldEZpZWxkID0gZnVuY3Rpb24oc24pIHtcbiAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjZXJ0LnN1YmplY3QsIHNuKTtcbiAgfTtcbiAgY2VydC5zdWJqZWN0LmFkZEZpZWxkID0gZnVuY3Rpb24oYXR0cikge1xuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhbYXR0cl0pO1xuICAgIGNlcnQuc3ViamVjdC5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNlcnQuc3ViamVjdC5hdHRyaWJ1dGVzID0gcGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5KGNhcHR1cmUuY2VydFN1YmplY3QpO1xuICBpZihjYXB0dXJlLmNlcnRTdWJqZWN0VW5pcXVlSWQpIHtcbiAgICBjZXJ0LnN1YmplY3QudW5pcXVlSWQgPSBjYXB0dXJlLmNlcnRTdWJqZWN0VW5pcXVlSWQ7XG4gIH1cbiAgY2VydC5zdWJqZWN0Lmhhc2ggPSBzbWQuZGlnZXN0KCkudG9IZXgoKTtcblxuICAvLyBoYW5kbGUgZXh0ZW5zaW9uc1xuICBpZihjYXB0dXJlLmNlcnRFeHRlbnNpb25zKSB7XG4gICAgY2VydC5leHRlbnNpb25zID0gcGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uc0Zyb21Bc24xKGNhcHR1cmUuY2VydEV4dGVuc2lvbnMpO1xuICB9IGVsc2Uge1xuICAgIGNlcnQuZXh0ZW5zaW9ucyA9IFtdO1xuICB9XG5cbiAgLy8gY29udmVydCBSU0EgcHVibGljIGtleSBmcm9tIEFTTi4xXG4gIGNlcnQucHVibGljS2V5ID0gcGtpLnB1YmxpY0tleUZyb21Bc24xKGNhcHR1cmUuc3ViamVjdFB1YmxpY0tleUluZm8pO1xuXG4gIHJldHVybiBjZXJ0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBBU04uMSBleHRlbnNpb25zIG9iamVjdCAod2l0aCBleHRlbnNpb24gc2VxdWVuY2VzIGFzIGl0c1xuICogdmFsdWVzKSBpbnRvIGFuIGFycmF5IG9mIGV4dGVuc2lvbiBvYmplY3RzIHdpdGggdHlwZXMgYW5kIHZhbHVlcy5cbiAqXG4gKiBTdXBwb3J0ZWQgZXh0ZW5zaW9uczpcbiAqXG4gKiBpZC1jZS1rZXlVc2FnZSBPQkpFQ1QgSURFTlRJRklFUiA6Oj0gIHsgaWQtY2UgMTUgfVxuICogS2V5VXNhZ2UgOjo9IEJJVCBTVFJJTkcge1xuICogICBkaWdpdGFsU2lnbmF0dXJlICAgICAgICAoMCksXG4gKiAgIG5vblJlcHVkaWF0aW9uICAgICAgICAgICgxKSxcbiAqICAga2V5RW5jaXBoZXJtZW50ICAgICAgICAgKDIpLFxuICogICBkYXRhRW5jaXBoZXJtZW50ICAgICAgICAoMyksXG4gKiAgIGtleUFncmVlbWVudCAgICAgICAgICAgICg0KSxcbiAqICAga2V5Q2VydFNpZ24gICAgICAgICAgICAgKDUpLFxuICogICBjUkxTaWduICAgICAgICAgICAgICAgICAoNiksXG4gKiAgIGVuY2lwaGVyT25seSAgICAgICAgICAgICg3KSxcbiAqICAgZGVjaXBoZXJPbmx5ICAgICAgICAgICAgKDgpXG4gKiB9XG4gKlxuICogaWQtY2UtYmFzaWNDb25zdHJhaW50cyBPQkpFQ1QgSURFTlRJRklFUiA6Oj0gIHsgaWQtY2UgMTkgfVxuICogQmFzaWNDb25zdHJhaW50cyA6Oj0gU0VRVUVOQ0Uge1xuICogICBjQSAgICAgICAgICAgICAgICAgICAgICBCT09MRUFOIERFRkFVTFQgRkFMU0UsXG4gKiAgIHBhdGhMZW5Db25zdHJhaW50ICAgICAgIElOVEVHRVIgKDAuLk1BWCkgT1BUSU9OQUxcbiAqIH1cbiAqXG4gKiBzdWJqZWN0QWx0TmFtZSBFWFRFTlNJT04gOjo9IHtcbiAqICAgU1lOVEFYIEdlbmVyYWxOYW1lc1xuICogICBJREVOVElGSUVEIEJZIGlkLWNlLXN1YmplY3RBbHROYW1lXG4gKiB9XG4gKlxuICogR2VuZXJhbE5hbWVzIDo6PSBTRVFVRU5DRSBTSVpFICgxLi5NQVgpIE9GIEdlbmVyYWxOYW1lXG4gKlxuICogR2VuZXJhbE5hbWUgOjo9IENIT0lDRSB7XG4gKiAgIG90aGVyTmFtZSAgICAgIFswXSBJTlNUQU5DRSBPRiBPVEhFUi1OQU1FLFxuICogICByZmM4MjJOYW1lICAgICBbMV0gSUE1U3RyaW5nLFxuICogICBkTlNOYW1lICAgICAgICBbMl0gSUE1U3RyaW5nLFxuICogICB4NDAwQWRkcmVzcyAgICBbM10gT1JBZGRyZXNzLFxuICogICBkaXJlY3RvcnlOYW1lICBbNF0gTmFtZSxcbiAqICAgZWRpUGFydHlOYW1lICAgWzVdIEVESVBhcnR5TmFtZSxcbiAqICAgdW5pZm9ybVJlc291cmNlSWRlbnRpZmllciBbNl0gSUE1U3RyaW5nLFxuICogICBJUEFkZHJlc3MgICAgICBbN10gT0NURVQgU1RSSU5HLFxuICogICByZWdpc3RlcmVkSUQgICBbOF0gT0JKRUNUIElERU5USUZJRVJcbiAqIH1cbiAqXG4gKiBPVEhFUi1OQU1FIDo6PSBUWVBFLUlERU5USUZJRVJcbiAqXG4gKiBFRElQYXJ0eU5hbWUgOjo9IFNFUVVFTkNFIHtcbiAqICAgbmFtZUFzc2lnbmVyIFswXSBEaXJlY3RvcnlTdHJpbmcge3ViLW5hbWV9IE9QVElPTkFMLFxuICogICBwYXJ0eU5hbWUgICAgWzFdIERpcmVjdG9yeVN0cmluZyB7dWItbmFtZX1cbiAqIH1cbiAqXG4gKiBAcGFyYW0gZXh0cyB0aGUgZXh0ZW5zaW9ucyBBU04uMSB3aXRoIGV4dGVuc2lvbiBzZXF1ZW5jZXMgdG8gcGFyc2UuXG4gKlxuICogQHJldHVybiB0aGUgYXJyYXkuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNGcm9tQXNuMSA9IGZ1bmN0aW9uKGV4dHMpIHtcbiAgdmFyIHJ2YWwgPSBbXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGV4dHMudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBnZXQgZXh0ZW5zaW9uIHNlcXVlbmNlXG4gICAgdmFyIGV4dHNlcSA9IGV4dHMudmFsdWVbaV07XG4gICAgZm9yKHZhciBlaSA9IDA7IGVpIDwgZXh0c2VxLnZhbHVlLmxlbmd0aDsgKytlaSkge1xuICAgICAgcnZhbC5wdXNoKHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbkZyb21Bc24xKGV4dHNlcS52YWx1ZVtlaV0pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgc2luZ2xlIGNlcnRpZmljYXRlIGV4dGVuc2lvbiBmcm9tIEFTTi4xLlxuICpcbiAqIEBwYXJhbSBleHQgdGhlIGV4dGVuc2lvbiBpbiBBU04uMSBmb3JtYXQuXG4gKlxuICogQHJldHVybiB0aGUgcGFyc2VkIGV4dGVuc2lvbiBhcyBhbiBvYmplY3QuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbkZyb21Bc24xID0gZnVuY3Rpb24oZXh0KSB7XG4gIC8vIGFuIGV4dGVuc2lvbiBoYXM6XG4gIC8vIFswXSBleHRuSUQgICAgICBPQkpFQ1QgSURFTlRJRklFUlxuICAvLyBbMV0gY3JpdGljYWwgICAgQk9PTEVBTiBERUZBVUxUIEZBTFNFXG4gIC8vIFsyXSBleHRuVmFsdWUgICBPQ1RFVCBTVFJJTkdcbiAgdmFyIGUgPSB7fTtcbiAgZS5pZCA9IGFzbjEuZGVyVG9PaWQoZXh0LnZhbHVlWzBdLnZhbHVlKTtcbiAgZS5jcml0aWNhbCA9IGZhbHNlO1xuICBpZihleHQudmFsdWVbMV0udHlwZSA9PT0gYXNuMS5UeXBlLkJPT0xFQU4pIHtcbiAgICBlLmNyaXRpY2FsID0gKGV4dC52YWx1ZVsxXS52YWx1ZS5jaGFyQ29kZUF0KDApICE9PSAweDAwKTtcbiAgICBlLnZhbHVlID0gZXh0LnZhbHVlWzJdLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGUudmFsdWUgPSBleHQudmFsdWVbMV0udmFsdWU7XG4gIH1cbiAgLy8gaWYgdGhlIG9pZCBpcyBrbm93biwgZ2V0IGl0cyBuYW1lXG4gIGlmKGUuaWQgaW4gb2lkcykge1xuICAgIGUubmFtZSA9IG9pZHNbZS5pZF07XG5cbiAgICAvLyBoYW5kbGUga2V5IHVzYWdlXG4gICAgaWYoZS5uYW1lID09PSAna2V5VXNhZ2UnKSB7XG4gICAgICAvLyBnZXQgdmFsdWUgYXMgQklUIFNUUklOR1xuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgdmFyIGIyID0gMHgwMDtcbiAgICAgIHZhciBiMyA9IDB4MDA7XG4gICAgICBpZihldi52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIHNraXAgZmlyc3QgYnl0ZSwganVzdCBpbmRpY2F0ZXMgdW51c2VkIGJpdHMgd2hpY2hcbiAgICAgICAgLy8gd2lsbCBiZSBwYWRkZWQgd2l0aCAwcyBhbnl3YXlcbiAgICAgICAgLy8gZ2V0IGJ5dGVzIHdpdGggZmxhZyBiaXRzXG4gICAgICAgIGIyID0gZXYudmFsdWUuY2hhckNvZGVBdCgxKTtcbiAgICAgICAgYjMgPSBldi52YWx1ZS5sZW5ndGggPiAyID8gZXYudmFsdWUuY2hhckNvZGVBdCgyKSA6IDA7XG4gICAgICB9XG4gICAgICAvLyBzZXQgZmxhZ3NcbiAgICAgIGUuZGlnaXRhbFNpZ25hdHVyZSA9IChiMiAmIDB4ODApID09PSAweDgwO1xuICAgICAgZS5ub25SZXB1ZGlhdGlvbiA9IChiMiAmIDB4NDApID09PSAweDQwO1xuICAgICAgZS5rZXlFbmNpcGhlcm1lbnQgPSAoYjIgJiAweDIwKSA9PT0gMHgyMDtcbiAgICAgIGUuZGF0YUVuY2lwaGVybWVudCA9IChiMiAmIDB4MTApID09PSAweDEwO1xuICAgICAgZS5rZXlBZ3JlZW1lbnQgPSAoYjIgJiAweDA4KSA9PT0gMHgwODtcbiAgICAgIGUua2V5Q2VydFNpZ24gPSAoYjIgJiAweDA0KSA9PT0gMHgwNDtcbiAgICAgIGUuY1JMU2lnbiA9IChiMiAmIDB4MDIpID09PSAweDAyO1xuICAgICAgZS5lbmNpcGhlck9ubHkgPSAoYjIgJiAweDAxKSA9PT0gMHgwMTtcbiAgICAgIGUuZGVjaXBoZXJPbmx5ID0gKGIzICYgMHg4MCkgPT09IDB4ODA7XG4gICAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ2Jhc2ljQ29uc3RyYWludHMnKSB7XG4gICAgICAvLyBoYW5kbGUgYmFzaWMgY29uc3RyYWludHNcbiAgICAgIC8vIGdldCB2YWx1ZSBhcyBTRVFVRU5DRVxuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgLy8gZ2V0IGNBIEJPT0xFQU4gZmxhZyAoZGVmYXVsdHMgdG8gZmFsc2UpXG4gICAgICBpZihldi52YWx1ZS5sZW5ndGggPiAwICYmIGV2LnZhbHVlWzBdLnR5cGUgPT09IGFzbjEuVHlwZS5CT09MRUFOKSB7XG4gICAgICAgIGUuY0EgPSAoZXYudmFsdWVbMF0udmFsdWUuY2hhckNvZGVBdCgwKSAhPT0gMHgwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlLmNBID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBnZXQgcGF0aCBsZW5ndGggY29uc3RyYWludFxuICAgICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICAgIGlmKGV2LnZhbHVlLmxlbmd0aCA+IDAgJiYgZXYudmFsdWVbMF0udHlwZSA9PT0gYXNuMS5UeXBlLklOVEVHRVIpIHtcbiAgICAgICAgdmFsdWUgPSBldi52YWx1ZVswXS52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZihldi52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhbHVlID0gZXYudmFsdWVbMV0udmFsdWU7XG4gICAgICB9XG4gICAgICBpZih2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBlLnBhdGhMZW5Db25zdHJhaW50ID0gYXNuMS5kZXJUb0ludGVnZXIodmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihlLm5hbWUgPT09ICdleHRLZXlVc2FnZScpIHtcbiAgICAgIC8vIGhhbmRsZSBleHRLZXlVc2FnZVxuICAgICAgLy8gdmFsdWUgaXMgYSBTRVFVRU5DRSBvZiBPSURzXG4gICAgICB2YXIgZXYgPSBhc24xLmZyb21EZXIoZS52YWx1ZSk7XG4gICAgICBmb3IodmFyIHZpID0gMDsgdmkgPCBldi52YWx1ZS5sZW5ndGg7ICsrdmkpIHtcbiAgICAgICAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoZXYudmFsdWVbdmldLnZhbHVlKTtcbiAgICAgICAgaWYob2lkIGluIG9pZHMpIHtcbiAgICAgICAgICBlW29pZHNbb2lkXV0gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVbb2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoZS5uYW1lID09PSAnbnNDZXJ0VHlwZScpIHtcbiAgICAgIC8vIGhhbmRsZSBuc0NlcnRUeXBlXG4gICAgICAvLyBnZXQgdmFsdWUgYXMgQklUIFNUUklOR1xuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgdmFyIGIyID0gMHgwMDtcbiAgICAgIGlmKGV2LnZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gc2tpcCBmaXJzdCBieXRlLCBqdXN0IGluZGljYXRlcyB1bnVzZWQgYml0cyB3aGljaFxuICAgICAgICAvLyB3aWxsIGJlIHBhZGRlZCB3aXRoIDBzIGFueXdheVxuICAgICAgICAvLyBnZXQgYnl0ZXMgd2l0aCBmbGFnIGJpdHNcbiAgICAgICAgYjIgPSBldi52YWx1ZS5jaGFyQ29kZUF0KDEpO1xuICAgICAgfVxuICAgICAgLy8gc2V0IGZsYWdzXG4gICAgICBlLmNsaWVudCA9IChiMiAmIDB4ODApID09PSAweDgwO1xuICAgICAgZS5zZXJ2ZXIgPSAoYjIgJiAweDQwKSA9PT0gMHg0MDtcbiAgICAgIGUuZW1haWwgPSAoYjIgJiAweDIwKSA9PT0gMHgyMDtcbiAgICAgIGUub2Jqc2lnbiA9IChiMiAmIDB4MTApID09PSAweDEwO1xuICAgICAgZS5yZXNlcnZlZCA9IChiMiAmIDB4MDgpID09PSAweDA4O1xuICAgICAgZS5zc2xDQSA9IChiMiAmIDB4MDQpID09PSAweDA0O1xuICAgICAgZS5lbWFpbENBID0gKGIyICYgMHgwMikgPT09IDB4MDI7XG4gICAgICBlLm9iakNBID0gKGIyICYgMHgwMSkgPT09IDB4MDE7XG4gICAgfSBlbHNlIGlmKFxuICAgICAgZS5uYW1lID09PSAnc3ViamVjdEFsdE5hbWUnIHx8XG4gICAgICBlLm5hbWUgPT09ICdpc3N1ZXJBbHROYW1lJykge1xuICAgICAgLy8gaGFuZGxlIHN1YmplY3RBbHROYW1lL2lzc3VlckFsdE5hbWVcbiAgICAgIGUuYWx0TmFtZXMgPSBbXTtcblxuICAgICAgLy8gZXYgaXMgYSBTWU5UQVggU0VRVUVOQ0VcbiAgICAgIHZhciBnbjtcbiAgICAgIHZhciBldiA9IGFzbjEuZnJvbURlcihlLnZhbHVlKTtcbiAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCBldi52YWx1ZS5sZW5ndGg7ICsrbikge1xuICAgICAgICAvLyBnZXQgR2VuZXJhbE5hbWVcbiAgICAgICAgZ24gPSBldi52YWx1ZVtuXTtcblxuICAgICAgICB2YXIgYWx0TmFtZSA9IHtcbiAgICAgICAgICB0eXBlOiBnbi50eXBlLFxuICAgICAgICAgIHZhbHVlOiBnbi52YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBlLmFsdE5hbWVzLnB1c2goYWx0TmFtZSk7XG5cbiAgICAgICAgLy8gTm90ZTogU3VwcG9ydCBmb3IgdHlwZXMgMSwyLDYsNyw4XG4gICAgICAgIHN3aXRjaChnbi50eXBlKSB7XG4gICAgICAgICAgLy8gcmZjODIyTmFtZVxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAvLyBkTlNOYW1lXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIC8vIHVuaWZvcm1SZXNvdXJjZUlkZW50aWZpZXIgKFVSSSlcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBJUEFkZHJlc3NcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRvIElQdjQvSVB2NiBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICAgICAgICAgIGFsdE5hbWUuaXAgPSBmb3JnZS51dGlsLmJ5dGVzVG9JUChnbi52YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyByZWdpc3RlcmVkSURcbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBhbHROYW1lLm9pZCA9IGFzbjEuZGVyVG9PaWQoZ24udmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIHVuc3VwcG9ydGVkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoZS5uYW1lID09PSAnc3ViamVjdEtleUlkZW50aWZpZXInKSB7XG4gICAgICAvLyB2YWx1ZSBpcyBhbiBPQ1RFVFNUUklORyB3L3RoZSBoYXNoIG9mIHRoZSBrZXktdHlwZSBzcGVjaWZpY1xuICAgICAgLy8gcHVibGljIGtleSBzdHJ1Y3R1cmUgKGVnOiBSU0FQdWJsaWNLZXkpXG4gICAgICB2YXIgZXYgPSBhc24xLmZyb21EZXIoZS52YWx1ZSk7XG4gICAgICBlLnN1YmplY3RLZXlJZGVudGlmaWVyID0gZm9yZ2UudXRpbC5ieXRlc1RvSGV4KGV2LnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUEtDUyMxMCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKENTUikgZnJvbSBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogTm90ZTogSWYgdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdCBpcyB0byBiZSB2ZXJpZmllZCB0aGVuIGNvbXB1dGUgaGFzaFxuICogc2hvdWxkIGJlIHNldCB0byB0cnVlLiBUaGVyZSBpcyBjdXJyZW50bHkgbm8gaW1wbGVtZW50YXRpb24gZm9yIGNvbnZlcnRpbmdcbiAqIGEgY2VydGlmaWNhdGUgYmFjayB0byBBU04uMSBzbyB0aGUgQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHBhcnQgb2YgdGhlXG4gKiBBU04uMSBvYmplY3QgbmVlZHMgdG8gYmUgc2Nhbm5lZCBiZWZvcmUgdGhlIGNzciBvYmplY3QgaXMgY3JlYXRlZC5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBhc24xIHJlcHJlc2VudGF0aW9uIG9mIGEgUEtDUyMxMCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKENTUikuXG4gKiBAcGFyYW0gY29tcHV0ZUhhc2ggdHJ1ZSB0byBjb21wdXRlIHRoZSBoYXNoIGZvciB2ZXJpZmljYXRpb24uXG4gKlxuICogQHJldHVybiB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IChDU1IpLlxuICovXG5wa2kuY2VydGlmaWNhdGlvblJlcXVlc3RGcm9tQXNuMSA9IGZ1bmN0aW9uKG9iaiwgY29tcHV0ZUhhc2gpIHtcbiAgLy8gdmFsaWRhdGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGFuZCBjYXB0dXJlIGRhdGFcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIGNlcnRpZmljYXRpb25SZXF1ZXN0VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTIzEwIGNlcnRpZmljYXRlIHJlcXVlc3QuICcgK1xuICAgICAgJ0FTTi4xIG9iamVjdCBpcyBub3QgYSBQS0NTIzEwIENlcnRpZmljYXRpb25SZXF1ZXN0LicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGdldCBvaWRcbiAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5wdWJsaWNLZXlPaWQpO1xuICBpZihvaWQgIT09IHBraS5vaWRzLnJzYUVuY3J5cHRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHB1YmxpYyBrZXkuIE9JRCBpcyBub3QgUlNBLicpO1xuICB9XG5cbiAgLy8gY3JlYXRlIGNlcnRpZmljYXRpb24gcmVxdWVzdFxuICB2YXIgY3NyID0gcGtpLmNyZWF0ZUNlcnRpZmljYXRpb25SZXF1ZXN0KCk7XG4gIGNzci52ZXJzaW9uID0gY2FwdHVyZS5jc3JWZXJzaW9uID8gY2FwdHVyZS5jc3JWZXJzaW9uLmNoYXJDb2RlQXQoMCkgOiAwO1xuICBjc3Iuc2lnbmF0dXJlT2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmNzclNpZ25hdHVyZU9pZCk7XG4gIGNzci5zaWduYXR1cmVQYXJhbWV0ZXJzID0gX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzKFxuICAgIGNzci5zaWduYXR1cmVPaWQsIGNhcHR1cmUuY3NyU2lnbmF0dXJlUGFyYW1zLCB0cnVlKTtcbiAgY3NyLnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmNzclNpZ25hdHVyZU9pZCk7XG4gIGNzci5zaWdpbmZvLnBhcmFtZXRlcnMgPSBfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMoXG4gICAgY3NyLnNpZ2luZm8uYWxnb3JpdGhtT2lkLCBjYXB0dXJlLmNzclNpZ25hdHVyZVBhcmFtcywgZmFsc2UpO1xuICBjc3Iuc2lnbmF0dXJlID0gY2FwdHVyZS5jc3JTaWduYXR1cmU7XG5cbiAgLy8ga2VlcCBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gdG8gcHJlc2VydmUgc2lnbmF0dXJlIHdoZW4gZXhwb3J0aW5nXG4gIGNzci5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gPSBjYXB0dXJlLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbztcblxuICBpZihjb21wdXRlSGFzaCkge1xuICAgIC8vIGNyZWF0ZSBkaWdlc3QgZm9yIE9JRCBzaWduYXR1cmUgdHlwZVxuICAgIGNzci5tZCA9IF9jcmVhdGVTaWduYXR1cmVEaWdlc3Qoe1xuICAgICAgc2lnbmF0dXJlT2lkOiBjc3Iuc2lnbmF0dXJlT2lkLFxuICAgICAgdHlwZTogJ2NlcnRpZmljYXRpb24gcmVxdWVzdCdcbiAgICB9KTtcblxuICAgIC8vIHByb2R1Y2UgREVSIGZvcm1hdHRlZCBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gYW5kIGRpZ2VzdCBpdFxuICAgIHZhciBieXRlcyA9IGFzbjEudG9EZXIoY3NyLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyk7XG4gICAgY3NyLm1kLnVwZGF0ZShieXRlcy5nZXRCeXRlcygpKTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBzdWJqZWN0LCBidWlsZCBzdWJqZWN0IG1lc3NhZ2UgZGlnZXN0XG4gIHZhciBzbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICBjc3Iuc3ViamVjdC5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY3NyLnN1YmplY3QsIHNuKTtcbiAgfTtcbiAgY3NyLnN1YmplY3QuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY3NyLnN1YmplY3QuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzID0gcGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5KFxuICAgIGNhcHR1cmUuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvU3ViamVjdCwgc21kKTtcbiAgY3NyLnN1YmplY3QuaGFzaCA9IHNtZC5kaWdlc3QoKS50b0hleCgpO1xuXG4gIC8vIGNvbnZlcnQgUlNBIHB1YmxpYyBrZXkgZnJvbSBBU04uMVxuICBjc3IucHVibGljS2V5ID0gcGtpLnB1YmxpY0tleUZyb21Bc24xKGNhcHR1cmUuc3ViamVjdFB1YmxpY0tleUluZm8pO1xuXG4gIC8vIGNvbnZlcnQgYXR0cmlidXRlcyBmcm9tIEFTTi4xXG4gIGNzci5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihzbikge1xuICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNzciwgc24pO1xuICB9O1xuICBjc3IuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24oYXR0cikge1xuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhbYXR0cl0pO1xuICAgIGNzci5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNzci5hdHRyaWJ1dGVzID0gcGtpLkNSSUF0dHJpYnV0ZXNBc0FycmF5KFxuICAgIGNhcHR1cmUuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvQXR0cmlidXRlcyB8fCBbXSk7XG5cbiAgcmV0dXJuIGNzcjtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbXB0eSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKGEgQ1NSIG9yIGNlcnRpZmljYXRlIHNpZ25pbmdcbiAqIHJlcXVlc3QpLiBPbmNlIGNyZWF0ZWQsIGl0cyBwdWJsaWMga2V5IGFuZCBhdHRyaWJ1dGVzIGNhbiBiZSBzZXQgYW5kIHRoZW5cbiAqIGl0IGNhbiBiZSBzaWduZWQuXG4gKlxuICogQHJldHVybiB0aGUgZW1wdHkgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICovXG5wa2kuY3JlYXRlQ2VydGlmaWNhdGlvblJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNzciA9IHt9O1xuICBjc3IudmVyc2lvbiA9IDB4MDA7XG4gIGNzci5zaWduYXR1cmVPaWQgPSBudWxsO1xuICBjc3Iuc2lnbmF0dXJlID0gbnVsbDtcbiAgY3NyLnNpZ2luZm8gPSB7fTtcbiAgY3NyLnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gbnVsbDtcblxuICBjc3Iuc3ViamVjdCA9IHt9O1xuICBjc3Iuc3ViamVjdC5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY3NyLnN1YmplY3QsIHNuKTtcbiAgfTtcbiAgY3NyLnN1YmplY3QuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY3NyLnN1YmplY3QuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzID0gW107XG4gIGNzci5zdWJqZWN0Lmhhc2ggPSBudWxsO1xuXG4gIGNzci5wdWJsaWNLZXkgPSBudWxsO1xuICBjc3IuYXR0cmlidXRlcyA9IFtdO1xuICBjc3IuZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24oc24pIHtcbiAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjc3IsIHNuKTtcbiAgfTtcbiAgY3NyLmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjc3IuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjc3IubWQgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdWJqZWN0IG9mIHRoaXMgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgdGhlIGFycmF5IG9mIHN1YmplY3QgYXR0cmlidXRlcyB0byB1c2UuXG4gICAqL1xuICBjc3Iuc2V0U3ViamVjdCA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgLy8gc2V0IG5ldyBhdHRyaWJ1dGVzXG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKGF0dHJzKTtcbiAgICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzID0gYXR0cnM7XG4gICAgY3NyLnN1YmplY3QuaGFzaCA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyB0aGUgYXJyYXkgb2YgYXR0cmlidXRlcyB0byB1c2UuXG4gICAqL1xuICBjc3Iuc2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgLy8gc2V0IG5ldyBhdHRyaWJ1dGVzXG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKGF0dHJzKTtcbiAgICBjc3IuYXR0cmlidXRlcyA9IGF0dHJzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaWducyB0aGlzIGNlcnRpZmljYXRpb24gcmVxdWVzdCB1c2luZyB0aGUgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgdGhlIHByaXZhdGUga2V5IHRvIHNpZ24gd2l0aC5cbiAgICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIChkZWZhdWx0cyB0byBmb3JnZS5tZC5zaGExKS5cbiAgICovXG4gIGNzci5zaWduID0gZnVuY3Rpb24oa2V5LCBtZCkge1xuICAgIC8vIFRPRE86IGdldCBzaWduYXR1cmUgT0lEIGZyb20gcHJpdmF0ZSBrZXlcbiAgICBjc3IubWQgPSBtZCB8fCBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgIHZhciBhbGdvcml0aG1PaWQgPSBvaWRzW2Nzci5tZC5hbGdvcml0aG0gKyAnV2l0aFJTQUVuY3J5cHRpb24nXTtcbiAgICBpZighYWxnb3JpdGhtT2lkKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb21wdXRlIGNlcnRpZmljYXRpb24gcmVxdWVzdCBkaWdlc3QuICcgK1xuICAgICAgICAnVW5rbm93biBtZXNzYWdlIGRpZ2VzdCBhbGdvcml0aG0gT0lELicpO1xuICAgICAgZXJyb3IuYWxnb3JpdGhtID0gY3NyLm1kLmFsZ29yaXRobTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjc3Iuc2lnbmF0dXJlT2lkID0gY3NyLnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gYWxnb3JpdGhtT2lkO1xuXG4gICAgLy8gZ2V0IENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbywgY29udmVydCB0byBERVJcbiAgICBjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvID0gcGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyhjc3IpO1xuICAgIHZhciBieXRlcyA9IGFzbjEudG9EZXIoY3NyLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyk7XG5cbiAgICAvLyBkaWdlc3QgYW5kIHNpZ25cbiAgICBjc3IubWQudXBkYXRlKGJ5dGVzLmdldEJ5dGVzKCkpO1xuICAgIGNzci5zaWduYXR1cmUgPSBrZXkuc2lnbihjc3IubWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB2ZXJpZnkgdGhlIHNpZ25hdHVyZSBvbiB0aGUgcGFzc2VkIGNlcnRpZmljYXRpb24gcmVxdWVzdCB1c2luZ1xuICAgKiBpdHMgcHVibGljIGtleS5cbiAgICpcbiAgICogQSBDU1IgdGhhdCBoYXMgYmVlbiBleHBvcnRlZCB0byBhIGZpbGUgaW4gUEVNIGZvcm1hdCBjYW4gYmUgdmVyaWZpZWQgdXNpbmdcbiAgICogT3BlblNTTCB1c2luZyB0aGlzIGNvbW1hbmQ6XG4gICAqXG4gICAqIG9wZW5zc2wgcmVxIC1pbiA8dGhlLWNzci1wZW0tZmlsZT4gLXZlcmlmeSAtbm9vdXQgLXRleHRcbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHZlcmlmaWVkLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICBjc3IudmVyaWZ5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJ2YWwgPSBmYWxzZTtcblxuICAgIHZhciBtZCA9IGNzci5tZDtcbiAgICBpZihtZCA9PT0gbnVsbCkge1xuICAgICAgbWQgPSBfY3JlYXRlU2lnbmF0dXJlRGlnZXN0KHtcbiAgICAgICAgc2lnbmF0dXJlT2lkOiBjc3Iuc2lnbmF0dXJlT2lkLFxuICAgICAgICB0eXBlOiAnY2VydGlmaWNhdGlvbiByZXF1ZXN0J1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHByb2R1Y2UgREVSIGZvcm1hdHRlZCBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gYW5kIGRpZ2VzdCBpdFxuICAgICAgdmFyIGNyaSA9IGNzci5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gfHxcbiAgICAgICAgcGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyhjc3IpO1xuICAgICAgdmFyIGJ5dGVzID0gYXNuMS50b0RlcihjcmkpO1xuICAgICAgbWQudXBkYXRlKGJ5dGVzLmdldEJ5dGVzKCkpO1xuICAgIH1cblxuICAgIGlmKG1kICE9PSBudWxsKSB7XG4gICAgICBydmFsID0gX3ZlcmlmeVNpZ25hdHVyZSh7XG4gICAgICAgIGNlcnRpZmljYXRlOiBjc3IsIG1kOiBtZCwgc2lnbmF0dXJlOiBjc3Iuc2lnbmF0dXJlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICByZXR1cm4gY3NyO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBYLjUwOSBzdWJqZWN0IG9yIGlzc3VlciB0byBhbiBBU04uMSBSRE5TZXF1ZW5jZS5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBzdWJqZWN0IG9yIGlzc3VlciAoZGlzdGluZ3Vpc2hlZCBuYW1lKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBSRE5TZXF1ZW5jZS5cbiAqL1xuZnVuY3Rpb24gX2RuVG9Bc24xKG9iaikge1xuICAvLyBjcmVhdGUgYW4gZW1wdHkgUkROU2VxdWVuY2VcbiAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG5cbiAgLy8gaXRlcmF0ZSBvdmVyIGF0dHJpYnV0ZXNcbiAgdmFyIGF0dHIsIHNldDtcbiAgdmFyIGF0dHJzID0gb2JqLmF0dHJpYnV0ZXM7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7ICsraSkge1xuICAgIGF0dHIgPSBhdHRyc1tpXTtcbiAgICB2YXIgdmFsdWUgPSBhdHRyLnZhbHVlO1xuXG4gICAgLy8gcmV1c2UgdGFnIGNsYXNzIGZvciBhdHRyaWJ1dGUgdmFsdWUgaWYgYXZhaWxhYmxlXG4gICAgdmFyIHZhbHVlVGFnQ2xhc3MgPSBhc24xLlR5cGUuUFJJTlRBQkxFU1RSSU5HO1xuICAgIGlmKCd2YWx1ZVRhZ0NsYXNzJyBpbiBhdHRyKSB7XG4gICAgICB2YWx1ZVRhZ0NsYXNzID0gYXR0ci52YWx1ZVRhZ0NsYXNzO1xuXG4gICAgICBpZih2YWx1ZVRhZ0NsYXNzID09PSBhc24xLlR5cGUuVVRGOCkge1xuICAgICAgICB2YWx1ZSA9IGZvcmdlLnV0aWwuZW5jb2RlVXRmOCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBGSVhNRTogaGFuZGxlIG1vcmUgZW5jb2RpbmdzXG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGEgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZSBzZXRcbiAgICAvLyBlYWNoIHZhbHVlIGluIHRoZSBzZXQgaXMgYW4gQXR0cmlidXRlVHlwZUFuZFZhbHVlIGZpcnN0XG4gICAgLy8gY29udGFpbmluZyB0aGUgdHlwZSAoYW4gT0lEKSBhbmQgc2Vjb25kIHRoZSB2YWx1ZVxuICAgIHNldCA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIEF0dHJpYnV0ZVR5cGVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgIGFzbjEub2lkVG9EZXIoYXR0ci50eXBlKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gQXR0cmlidXRlVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIHZhbHVlVGFnQ2xhc3MsIGZhbHNlLCB2YWx1ZSlcbiAgICAgIF0pXG4gICAgXSk7XG4gICAgcnZhbC52YWx1ZS5wdXNoKHNldCk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn1cblxuLyoqXG4gKiBHZXRzIGFsbCBwcmludGFibGUgYXR0cmlidXRlcyAodHlwaWNhbGx5IG9mIGFuIGlzc3VlciBvciBzdWJqZWN0KSBpbiBhXG4gKiBzaW1wbGlmaWVkIEpTT04gZm9ybWF0IGZvciBkaXNwbGF5LlxuICpcbiAqIEBwYXJhbSBhdHRycyB0aGUgYXR0cmlidXRlcy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBKU09OIGZvciBkaXNwbGF5LlxuICovXG5mdW5jdGlvbiBfZ2V0QXR0cmlidXRlc0FzSnNvbihhdHRycykge1xuICB2YXIgcnZhbCA9IHt9O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmKGF0dHIuc2hvcnROYW1lICYmIChcbiAgICAgIGF0dHIudmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLlVURjggfHxcbiAgICAgIGF0dHIudmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLlBSSU5UQUJMRVNUUklORyB8fFxuICAgICAgYXR0ci52YWx1ZVRhZ0NsYXNzID09PSBhc24xLlR5cGUuSUE1U1RSSU5HKSkge1xuICAgICAgdmFyIHZhbHVlID0gYXR0ci52YWx1ZTtcbiAgICAgIGlmKGF0dHIudmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLlVURjgpIHtcbiAgICAgICAgdmFsdWUgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgoYXR0ci52YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZighKGF0dHIuc2hvcnROYW1lIGluIHJ2YWwpKSB7XG4gICAgICAgIHJ2YWxbYXR0ci5zaG9ydE5hbWVdID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYoZm9yZ2UudXRpbC5pc0FycmF5KHJ2YWxbYXR0ci5zaG9ydE5hbWVdKSkge1xuICAgICAgICBydmFsW2F0dHIuc2hvcnROYW1lXS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWxbYXR0ci5zaG9ydE5hbWVdID0gW3J2YWxbYXR0ci5zaG9ydE5hbWVdLCB2YWx1ZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIEZpbGxzIGluIG1pc3NpbmcgZmllbGRzIGluIGF0dHJpYnV0ZXMuXG4gKlxuICogQHBhcmFtIGF0dHJzIHRoZSBhdHRyaWJ1dGVzIHRvIGZpbGwgbWlzc2luZyBmaWVsZHMgaW4uXG4gKi9cbmZ1bmN0aW9uIF9maWxsTWlzc2luZ0ZpZWxkcyhhdHRycykge1xuICB2YXIgYXR0cjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgKytpKSB7XG4gICAgYXR0ciA9IGF0dHJzW2ldO1xuXG4gICAgLy8gcG9wdWxhdGUgbWlzc2luZyBuYW1lXG4gICAgaWYodHlwZW9mIGF0dHIubmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmKGF0dHIudHlwZSAmJiBhdHRyLnR5cGUgaW4gcGtpLm9pZHMpIHtcbiAgICAgICAgYXR0ci5uYW1lID0gcGtpLm9pZHNbYXR0ci50eXBlXTtcbiAgICAgIH0gZWxzZSBpZihhdHRyLnNob3J0TmFtZSAmJiBhdHRyLnNob3J0TmFtZSBpbiBfc2hvcnROYW1lcykge1xuICAgICAgICBhdHRyLm5hbWUgPSBwa2kub2lkc1tfc2hvcnROYW1lc1thdHRyLnNob3J0TmFtZV1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBvcHVsYXRlIG1pc3NpbmcgdHlwZSAoT0lEKVxuICAgIGlmKHR5cGVvZiBhdHRyLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZihhdHRyLm5hbWUgJiYgYXR0ci5uYW1lIGluIHBraS5vaWRzKSB7XG4gICAgICAgIGF0dHIudHlwZSA9IHBraS5vaWRzW2F0dHIubmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSB0eXBlIG5vdCBzcGVjaWZpZWQuJyk7XG4gICAgICAgIGVycm9yLmF0dHJpYnV0ZSA9IGF0dHI7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBvcHVsYXRlIG1pc3Npbmcgc2hvcnRuYW1lXG4gICAgaWYodHlwZW9mIGF0dHIuc2hvcnROYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYoYXR0ci5uYW1lICYmIGF0dHIubmFtZSBpbiBfc2hvcnROYW1lcykge1xuICAgICAgICBhdHRyLnNob3J0TmFtZSA9IF9zaG9ydE5hbWVzW2F0dHIubmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBleHRlbnNpb25zIHRvIHZhbHVlXG4gICAgaWYoYXR0ci50eXBlID09PSBvaWRzLmV4dGVuc2lvblJlcXVlc3QpIHtcbiAgICAgIGF0dHIudmFsdWVDb25zdHJ1Y3RlZCA9IHRydWU7XG4gICAgICBhdHRyLnZhbHVlVGFnQ2xhc3MgPSBhc24xLlR5cGUuU0VRVUVOQ0U7XG4gICAgICBpZighYXR0ci52YWx1ZSAmJiBhdHRyLmV4dGVuc2lvbnMpIHtcbiAgICAgICAgYXR0ci52YWx1ZSA9IFtdO1xuICAgICAgICBmb3IodmFyIGVpID0gMDsgZWkgPCBhdHRyLmV4dGVuc2lvbnMubGVuZ3RoOyArK2VpKSB7XG4gICAgICAgICAgYXR0ci52YWx1ZS5wdXNoKHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvblRvQXNuMShcbiAgICAgICAgICAgIF9maWxsTWlzc2luZ0V4dGVuc2lvbkZpZWxkcyhhdHRyLmV4dGVuc2lvbnNbZWldKSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYodHlwZW9mIGF0dHIudmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSB2YWx1ZSBub3Qgc3BlY2lmaWVkLicpO1xuICAgICAgZXJyb3IuYXR0cmlidXRlID0gYXR0cjtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEZpbGxzIGluIG1pc3NpbmcgZmllbGRzIGluIGNlcnRpZmljYXRlIGV4dGVuc2lvbnMuXG4gKlxuICogQHBhcmFtIGUgdGhlIGV4dGVuc2lvbi5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAgW2NlcnRdIHRoZSBjZXJ0aWZpY2F0ZSB0aGUgZXh0ZW5zaW9ucyBhcmUgZm9yLlxuICpcbiAqIEByZXR1cm4gdGhlIGV4dGVuc2lvbi5cbiAqL1xuZnVuY3Rpb24gX2ZpbGxNaXNzaW5nRXh0ZW5zaW9uRmllbGRzKGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gcG9wdWxhdGUgbWlzc2luZyBuYW1lXG4gIGlmKHR5cGVvZiBlLm5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYoZS5pZCAmJiBlLmlkIGluIHBraS5vaWRzKSB7XG4gICAgICBlLm5hbWUgPSBwa2kub2lkc1tlLmlkXTtcbiAgICB9XG4gIH1cblxuICAvLyBwb3B1bGF0ZSBtaXNzaW5nIGlkXG4gIGlmKHR5cGVvZiBlLmlkID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmKGUubmFtZSAmJiBlLm5hbWUgaW4gcGtpLm9pZHMpIHtcbiAgICAgIGUuaWQgPSBwa2kub2lkc1tlLm5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0V4dGVuc2lvbiBJRCBub3Qgc3BlY2lmaWVkLicpO1xuICAgICAgZXJyb3IuZXh0ZW5zaW9uID0gZTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGlmKHR5cGVvZiBlLnZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBlO1xuICB9XG5cbiAgLy8gaGFuZGxlIG1pc3NpbmcgdmFsdWU6XG5cbiAgLy8gdmFsdWUgaXMgYSBCSVQgU1RSSU5HXG4gIGlmKGUubmFtZSA9PT0gJ2tleVVzYWdlJykge1xuICAgIC8vIGJ1aWxkIGZsYWdzXG4gICAgdmFyIHVudXNlZCA9IDA7XG4gICAgdmFyIGIyID0gMHgwMDtcbiAgICB2YXIgYjMgPSAweDAwO1xuICAgIGlmKGUuZGlnaXRhbFNpZ25hdHVyZSkge1xuICAgICAgYjIgfD0gMHg4MDtcbiAgICAgIHVudXNlZCA9IDc7XG4gICAgfVxuICAgIGlmKGUubm9uUmVwdWRpYXRpb24pIHtcbiAgICAgIGIyIHw9IDB4NDA7XG4gICAgICB1bnVzZWQgPSA2O1xuICAgIH1cbiAgICBpZihlLmtleUVuY2lwaGVybWVudCkge1xuICAgICAgYjIgfD0gMHgyMDtcbiAgICAgIHVudXNlZCA9IDU7XG4gICAgfVxuICAgIGlmKGUuZGF0YUVuY2lwaGVybWVudCkge1xuICAgICAgYjIgfD0gMHgxMDtcbiAgICAgIHVudXNlZCA9IDQ7XG4gICAgfVxuICAgIGlmKGUua2V5QWdyZWVtZW50KSB7XG4gICAgICBiMiB8PSAweDA4O1xuICAgICAgdW51c2VkID0gMztcbiAgICB9XG4gICAgaWYoZS5rZXlDZXJ0U2lnbikge1xuICAgICAgYjIgfD0gMHgwNDtcbiAgICAgIHVudXNlZCA9IDI7XG4gICAgfVxuICAgIGlmKGUuY1JMU2lnbikge1xuICAgICAgYjIgfD0gMHgwMjtcbiAgICAgIHVudXNlZCA9IDE7XG4gICAgfVxuICAgIGlmKGUuZW5jaXBoZXJPbmx5KSB7XG4gICAgICBiMiB8PSAweDAxO1xuICAgICAgdW51c2VkID0gMDtcbiAgICB9XG4gICAgaWYoZS5kZWNpcGhlck9ubHkpIHtcbiAgICAgIGIzIHw9IDB4ODA7XG4gICAgICB1bnVzZWQgPSA3O1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBiaXQgc3RyaW5nXG4gICAgdmFyIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bnVzZWQpO1xuICAgIGlmKGIzICE9PSAwKSB7XG4gICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIyKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYjMpO1xuICAgIH0gZWxzZSBpZihiMiAhPT0gMCkge1xuICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiMik7XG4gICAgfVxuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYoZS5uYW1lID09PSAnYmFzaWNDb25zdHJhaW50cycpIHtcbiAgICAvLyBiYXNpY0NvbnN0cmFpbnRzIGlzIGEgU0VRVUVOQ0VcbiAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gICAgLy8gY0EgQk9PTEVBTiBmbGFnIGRlZmF1bHRzIHRvIGZhbHNlXG4gICAgaWYoZS5jQSkge1xuICAgICAgZS52YWx1ZS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKFxuICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJPT0xFQU4sIGZhbHNlLFxuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkYpKSk7XG4gICAgfVxuICAgIGlmKCdwYXRoTGVuQ29uc3RyYWludCcgaW4gZSkge1xuICAgICAgZS52YWx1ZS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKFxuICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICBhc24xLmludGVnZXJUb0RlcihlLnBhdGhMZW5Db25zdHJhaW50KS5nZXRCeXRlcygpKSk7XG4gICAgfVxuICB9IGVsc2UgaWYoZS5uYW1lID09PSAnZXh0S2V5VXNhZ2UnKSB7XG4gICAgLy8gZXh0S2V5VXNhZ2UgaXMgYSBTRVFVRU5DRSBvZiBPSURzXG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuICAgIHZhciBzZXEgPSBlLnZhbHVlLnZhbHVlO1xuICAgIGZvcih2YXIga2V5IGluIGUpIHtcbiAgICAgIGlmKGVba2V5XSAhPT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIGtleSBpcyBuYW1lIGluIE9JRCBtYXBcbiAgICAgIGlmKGtleSBpbiBvaWRzKSB7XG4gICAgICAgIHNlcS5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELFxuICAgICAgICAgIGZhbHNlLCBhc24xLm9pZFRvRGVyKG9pZHNba2V5XSkuZ2V0Qnl0ZXMoKSkpO1xuICAgICAgfSBlbHNlIGlmKGtleS5pbmRleE9mKCcuJykgIT09IC0xKSB7XG4gICAgICAgIC8vIGFzc3VtZSBrZXkgaXMgYW4gT0lEXG4gICAgICAgIHNlcS5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELFxuICAgICAgICAgIGZhbHNlLCBhc24xLm9pZFRvRGVyKGtleSkuZ2V0Qnl0ZXMoKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ25zQ2VydFR5cGUnKSB7XG4gICAgLy8gbnNDZXJ0VHlwZSBpcyBhIEJJVCBTVFJJTkdcbiAgICAvLyBidWlsZCBmbGFnc1xuICAgIHZhciB1bnVzZWQgPSAwO1xuICAgIHZhciBiMiA9IDB4MDA7XG5cbiAgICBpZihlLmNsaWVudCkge1xuICAgICAgYjIgfD0gMHg4MDtcbiAgICAgIHVudXNlZCA9IDc7XG4gICAgfVxuICAgIGlmKGUuc2VydmVyKSB7XG4gICAgICBiMiB8PSAweDQwO1xuICAgICAgdW51c2VkID0gNjtcbiAgICB9XG4gICAgaWYoZS5lbWFpbCkge1xuICAgICAgYjIgfD0gMHgyMDtcbiAgICAgIHVudXNlZCA9IDU7XG4gICAgfVxuICAgIGlmKGUub2Jqc2lnbikge1xuICAgICAgYjIgfD0gMHgxMDtcbiAgICAgIHVudXNlZCA9IDQ7XG4gICAgfVxuICAgIGlmKGUucmVzZXJ2ZWQpIHtcbiAgICAgIGIyIHw9IDB4MDg7XG4gICAgICB1bnVzZWQgPSAzO1xuICAgIH1cbiAgICBpZihlLnNzbENBKSB7XG4gICAgICBiMiB8PSAweDA0O1xuICAgICAgdW51c2VkID0gMjtcbiAgICB9XG4gICAgaWYoZS5lbWFpbENBKSB7XG4gICAgICBiMiB8PSAweDAyO1xuICAgICAgdW51c2VkID0gMTtcbiAgICB9XG4gICAgaWYoZS5vYmpDQSkge1xuICAgICAgYjIgfD0gMHgwMTtcbiAgICAgIHVudXNlZCA9IDA7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGJpdCBzdHJpbmdcbiAgICB2YXIgdmFsdWUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVudXNlZCk7XG4gICAgaWYoYjIgIT09IDApIHtcbiAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYjIpO1xuICAgIH1cbiAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJJVFNUUklORywgZmFsc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ3N1YmplY3RBbHROYW1lJyB8fCBlLm5hbWUgPT09ICdpc3N1ZXJBbHROYW1lJykge1xuICAgIC8vIFNZTlRBWCBTRVFVRU5DRVxuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG5cbiAgICB2YXIgYWx0TmFtZTtcbiAgICBmb3IodmFyIG4gPSAwOyBuIDwgZS5hbHROYW1lcy5sZW5ndGg7ICsrbikge1xuICAgICAgYWx0TmFtZSA9IGUuYWx0TmFtZXNbbl07XG4gICAgICB2YXIgdmFsdWUgPSBhbHROYW1lLnZhbHVlO1xuICAgICAgLy8gaGFuZGxlIElQXG4gICAgICBpZihhbHROYW1lLnR5cGUgPT09IDcgJiYgYWx0TmFtZS5pcCkge1xuICAgICAgICB2YWx1ZSA9IGZvcmdlLnV0aWwuYnl0ZXNGcm9tSVAoYWx0TmFtZS5pcCk7XG4gICAgICAgIGlmKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0V4dGVuc2lvbiBcImlwXCIgdmFsdWUgaXMgbm90IGEgdmFsaWQgSVB2NCBvciBJUHY2IGFkZHJlc3MuJyk7XG4gICAgICAgICAgZXJyb3IuZXh0ZW5zaW9uID0gZTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKGFsdE5hbWUudHlwZSA9PT0gOCkge1xuICAgICAgICAvLyBoYW5kbGUgT0lEXG4gICAgICAgIGlmKGFsdE5hbWUub2lkKSB7XG4gICAgICAgICAgdmFsdWUgPSBhc24xLm9pZFRvRGVyKGFzbjEub2lkVG9EZXIoYWx0TmFtZS5vaWQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZXByZWNhdGVkIC4uLiBjb252ZXJ0IHZhbHVlIHRvIE9JRFxuICAgICAgICAgIHZhbHVlID0gYXNuMS5vaWRUb0Rlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGUudmFsdWUudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCBhbHROYW1lLnR5cGUsIGZhbHNlLFxuICAgICAgICB2YWx1ZSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ25zQ29tbWVudCcgJiYgb3B0aW9ucy5jZXJ0KSB7XG4gICAgLy8gc2FuaXR5IGNoZWNrIHZhbHVlIGlzIEFTQ0lJIChyZXEnZCkgYW5kIG5vdCB0b28gYmlnXG4gICAgaWYoISgvXltcXHgwMC1cXHg3Rl0qJC8udGVzdChlLmNvbW1lbnQpKSB8fFxuICAgICAgKGUuY29tbWVudC5sZW5ndGggPCAxKSB8fCAoZS5jb21tZW50Lmxlbmd0aCA+IDEyOCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBcIm5zQ29tbWVudFwiIGNvbnRlbnQuJyk7XG4gICAgfVxuICAgIC8vIElBNVNUUklORyBvcGFxdWUgY29tbWVudFxuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSUE1U1RSSU5HLCBmYWxzZSwgZS5jb21tZW50KTtcbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ3N1YmplY3RLZXlJZGVudGlmaWVyJyAmJiBvcHRpb25zLmNlcnQpIHtcbiAgICB2YXIgc2tpID0gb3B0aW9ucy5jZXJ0LmdlbmVyYXRlU3ViamVjdEtleUlkZW50aWZpZXIoKTtcbiAgICBlLnN1YmplY3RLZXlJZGVudGlmaWVyID0gc2tpLnRvSGV4KCk7XG4gICAgLy8gT0NURVRTVFJJTkcgdy9kaWdlc3RcbiAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgc2tpLmdldEJ5dGVzKCkpO1xuICB9IGVsc2UgaWYoZS5uYW1lID09PSAnYXV0aG9yaXR5S2V5SWRlbnRpZmllcicgJiYgb3B0aW9ucy5jZXJ0KSB7XG4gICAgLy8gU1lOVEFYIFNFUVVFTkNFXG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcbiAgICB2YXIgc2VxID0gZS52YWx1ZS52YWx1ZTtcblxuICAgIGlmKGUua2V5SWRlbnRpZmllcikge1xuICAgICAgdmFyIGtleUlkZW50aWZpZXIgPSAoZS5rZXlJZGVudGlmaWVyID09PSB0cnVlID9cbiAgICAgICAgb3B0aW9ucy5jZXJ0LmdlbmVyYXRlU3ViamVjdEtleUlkZW50aWZpZXIoKS5nZXRCeXRlcygpIDpcbiAgICAgICAgZS5rZXlJZGVudGlmaWVyKTtcbiAgICAgIHNlcS5wdXNoKFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIGZhbHNlLCBrZXlJZGVudGlmaWVyKSk7XG4gICAgfVxuXG4gICAgaWYoZS5hdXRob3JpdHlDZXJ0SXNzdWVyKSB7XG4gICAgICB2YXIgYXV0aG9yaXR5Q2VydElzc3VlciA9IFtcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCA0LCB0cnVlLCBbXG4gICAgICAgICAgX2RuVG9Bc24xKGUuYXV0aG9yaXR5Q2VydElzc3VlciA9PT0gdHJ1ZSA/XG4gICAgICAgICAgICBvcHRpb25zLmNlcnQuaXNzdWVyIDogZS5hdXRob3JpdHlDZXJ0SXNzdWVyKVxuICAgICAgICBdKVxuICAgICAgXTtcbiAgICAgIHNlcS5wdXNoKFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDEsIHRydWUsIGF1dGhvcml0eUNlcnRJc3N1ZXIpKTtcbiAgICB9XG5cbiAgICBpZihlLnNlcmlhbE51bWJlcikge1xuICAgICAgdmFyIHNlcmlhbE51bWJlciA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhlLnNlcmlhbE51bWJlciA9PT0gdHJ1ZSA/XG4gICAgICAgIG9wdGlvbnMuY2VydC5zZXJpYWxOdW1iZXIgOiBlLnNlcmlhbE51bWJlcik7XG4gICAgICBzZXEucHVzaChcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAyLCBmYWxzZSwgc2VyaWFsTnVtYmVyKSk7XG4gICAgfVxuICB9IGVsc2UgaWYoZS5uYW1lID09PSAnY1JMRGlzdHJpYnV0aW9uUG9pbnRzJykge1xuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gICAgdmFyIHNlcSA9IGUudmFsdWUudmFsdWU7XG5cbiAgICAvLyBDcmVhdGUgc3ViIFNFUVVFTkNFIG9mIERpc3RyaWJ1dGlvblBvaW50TmFtZVxuICAgIHZhciBzdWJTZXEgPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcblxuICAgIC8vIENyZWF0ZSBmdWxsTmFtZSBDSE9JQ0VcbiAgICB2YXIgZnVsbE5hbWVHZW5lcmFsTmFtZXMgPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW10pO1xuICAgIHZhciBhbHROYW1lO1xuICAgIGZvcih2YXIgbiA9IDA7IG4gPCBlLmFsdE5hbWVzLmxlbmd0aDsgKytuKSB7XG4gICAgICBhbHROYW1lID0gZS5hbHROYW1lc1tuXTtcbiAgICAgIHZhciB2YWx1ZSA9IGFsdE5hbWUudmFsdWU7XG4gICAgICAvLyBoYW5kbGUgSVBcbiAgICAgIGlmKGFsdE5hbWUudHlwZSA9PT0gNyAmJiBhbHROYW1lLmlwKSB7XG4gICAgICAgIHZhbHVlID0gZm9yZ2UudXRpbC5ieXRlc0Zyb21JUChhbHROYW1lLmlwKTtcbiAgICAgICAgaWYodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnRXh0ZW5zaW9uIFwiaXBcIiB2YWx1ZSBpcyBub3QgYSB2YWxpZCBJUHY0IG9yIElQdjYgYWRkcmVzcy4nKTtcbiAgICAgICAgICBlcnJvci5leHRlbnNpb24gPSBlO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoYWx0TmFtZS50eXBlID09PSA4KSB7XG4gICAgICAgIC8vIGhhbmRsZSBPSURcbiAgICAgICAgaWYoYWx0TmFtZS5vaWQpIHtcbiAgICAgICAgICB2YWx1ZSA9IGFzbjEub2lkVG9EZXIoYXNuMS5vaWRUb0RlcihhbHROYW1lLm9pZCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRlcHJlY2F0ZWQgLi4uIGNvbnZlcnQgdmFsdWUgdG8gT0lEXG4gICAgICAgICAgdmFsdWUgPSBhc24xLm9pZFRvRGVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVsbE5hbWVHZW5lcmFsTmFtZXMudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCBhbHROYW1lLnR5cGUsIGZhbHNlLFxuICAgICAgICB2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8vIEFkZCB0byB0aGUgcGFyZW50IFNFUVVFTkNFXG4gICAgc3ViU2VxLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtmdWxsTmFtZUdlbmVyYWxOYW1lc10pKTtcbiAgICBzZXEucHVzaChzdWJTZXEpO1xuICB9XG5cbiAgLy8gZW5zdXJlIHZhbHVlIGhhcyBiZWVuIGRlZmluZWQgYnkgbm93XG4gIGlmKHR5cGVvZiBlLnZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignRXh0ZW5zaW9uIHZhbHVlIG5vdCBzcGVjaWZpZWQuJyk7XG4gICAgZXJyb3IuZXh0ZW5zaW9uID0gZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHJldHVybiBlO1xufVxuXG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgb2JqZWN0IHRvIEFTTi4xXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9pZCBTaWduYXR1cmUgYWxnb3JpdGhtIE9JRFxuICogQHBhcmFtIHBhcmFtcyBUaGUgc2lnbmF0dXJlIHBhcmFtZXRycyBvYmplY3RcbiAqIEByZXR1cm4gQVNOLjEgb2JqZWN0IHJlcHJlc2VudGluZyBzaWduYXR1cmUgcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiBfc2lnbmF0dXJlUGFyYW1ldGVyc1RvQXNuMShvaWQsIHBhcmFtcykge1xuICBzd2l0Y2gob2lkKSB7XG4gICAgY2FzZSBvaWRzWydSU0FTU0EtUFNTJ106XG4gICAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgICAgaWYocGFyYW1zLmhhc2guYWxnb3JpdGhtT2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFydHMucHVzaChhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtcbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgICAgIGFzbjEub2lkVG9EZXIocGFyYW1zLmhhc2guYWxnb3JpdGhtT2lkKS5nZXRCeXRlcygpKSxcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgICAgICAgIF0pXG4gICAgICAgIF0pKTtcbiAgICAgIH1cblxuICAgICAgaWYocGFyYW1zLm1nZi5hbGdvcml0aG1PaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJ0cy5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMSwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgICAgYXNuMS5vaWRUb0RlcihwYXJhbXMubWdmLmFsZ29yaXRobU9pZCkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKHBhcmFtcy5tZ2YuaGFzaC5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSlcbiAgICAgICAgXSkpO1xuICAgICAgfVxuXG4gICAgICBpZihwYXJhbXMuc2FsdExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAyLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEuaW50ZWdlclRvRGVyKHBhcmFtcy5zYWx0TGVuZ3RoKS5nZXRCeXRlcygpKVxuICAgICAgICBdKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBwYXJ0cyk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgY2VydGlmaWNhdGlvbiByZXF1ZXN0J3MgYXR0cmlidXRlcyB0byBhbiBBU04uMSBzZXQgb2ZcbiAqIENSSUF0dHJpYnV0ZXMuXG4gKlxuICogQHBhcmFtIGNzciBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKlxuICogQHJldHVybiB0aGUgQVNOLjEgc2V0IG9mIENSSUF0dHJpYnV0ZXMuXG4gKi9cbmZ1bmN0aW9uIF9DUklBdHRyaWJ1dGVzVG9Bc24xKGNzcikge1xuICAvLyBjcmVhdGUgYW4gZW1wdHkgY29udGV4dC1zcGVjaWZpYyBjb250YWluZXJcbiAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtdKTtcblxuICAvLyBubyBhdHRyaWJ1dGVzLCByZXR1cm4gZW1wdHkgY29udGFpbmVyXG4gIGlmKGNzci5hdHRyaWJ1dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBydmFsO1xuICB9XG5cbiAgLy8gZWFjaCBhdHRyaWJ1dGUgaGFzIGEgc2VxdWVuY2Ugd2l0aCBhIHR5cGUgYW5kIGEgc2V0IG9mIHZhbHVlc1xuICB2YXIgYXR0cnMgPSBjc3IuYXR0cmlidXRlcztcbiAgZm9yKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICB2YXIgdmFsdWUgPSBhdHRyLnZhbHVlO1xuXG4gICAgLy8gcmV1c2UgdGFnIGNsYXNzIGZvciBhdHRyaWJ1dGUgdmFsdWUgaWYgYXZhaWxhYmxlXG4gICAgdmFyIHZhbHVlVGFnQ2xhc3MgPSBhc24xLlR5cGUuVVRGODtcbiAgICBpZigndmFsdWVUYWdDbGFzcycgaW4gYXR0cikge1xuICAgICAgdmFsdWVUYWdDbGFzcyA9IGF0dHIudmFsdWVUYWdDbGFzcztcbiAgICB9XG4gICAgaWYodmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLlVURjgpIHtcbiAgICAgIHZhbHVlID0gZm9yZ2UudXRpbC5lbmNvZGVVdGY4KHZhbHVlKTtcbiAgICB9XG4gICAgdmFyIHZhbHVlQ29uc3RydWN0ZWQgPSBmYWxzZTtcbiAgICBpZigndmFsdWVDb25zdHJ1Y3RlZCcgaW4gYXR0cikge1xuICAgICAgdmFsdWVDb25zdHJ1Y3RlZCA9IGF0dHIudmFsdWVDb25zdHJ1Y3RlZDtcbiAgICB9XG4gICAgLy8gRklYTUU6IGhhbmRsZSBtb3JlIGVuY29kaW5nc1xuXG4gICAgLy8gY3JlYXRlIGEgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZSBzZXRcbiAgICAvLyBlYWNoIHZhbHVlIGluIHRoZSBzZXQgaXMgYW4gQXR0cmlidXRlVHlwZUFuZFZhbHVlIGZpcnN0XG4gICAgLy8gY29udGFpbmluZyB0aGUgdHlwZSAoYW4gT0lEKSBhbmQgc2Vjb25kIHRoZSB2YWx1ZVxuICAgIHZhciBzZXEgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAvLyBBdHRyaWJ1dGVUeXBlXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoYXR0ci50eXBlKS5nZXRCeXRlcygpKSxcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICAgIC8vIEF0dHJpYnV0ZVZhbHVlXG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCB2YWx1ZVRhZ0NsYXNzLCB2YWx1ZUNvbnN0cnVjdGVkLCB2YWx1ZSlcbiAgICAgIF0pXG4gICAgXSk7XG4gICAgcnZhbC52YWx1ZS5wdXNoKHNlcSk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn1cblxudmFyIGphbl8xXzE5NTAgPSBuZXcgRGF0ZSgnMTk1MC0wMS0wMVQwMDowMDowMFonKTtcbnZhciBqYW5fMV8yMDUwID0gbmV3IERhdGUoJzIwNTAtMDEtMDFUMDA6MDA6MDBaJyk7XG5cbi8qKlxuICogQ29udmVydHMgYSBEYXRlIG9iamVjdCB0byBBU04uMVxuICogSGFuZGxlcyB0aGUgZGlmZmVyZW50IGZvcm1hdCBiZWZvcmUgYW5kIGFmdGVyIDFzdCBKYW51YXJ5IDIwNTBcbiAqXG4gKiBAcGFyYW0gZGF0ZSBkYXRlIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkYXRlLlxuICovXG5mdW5jdGlvbiBfZGF0ZVRvQXNuMShkYXRlKSB7XG4gIGlmKGRhdGUgPj0gamFuXzFfMTk1MCAmJiBkYXRlIDwgamFuXzFfMjA1MCkge1xuICAgIHJldHVybiBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuVVRDVElNRSwgZmFsc2UsXG4gICAgICBhc24xLmRhdGVUb1V0Y1RpbWUoZGF0ZSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuR0VORVJBTElaRURUSU1FLCBmYWxzZSxcbiAgICAgIGFzbjEuZGF0ZVRvR2VuZXJhbGl6ZWRUaW1lKGRhdGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIEFTTi4xIFRCU0NlcnRpZmljYXRlIHBhcnQgb2YgYW4gWC41MDl2MyBjZXJ0aWZpY2F0ZS5cbiAqXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSBUQlNDZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmdldFRCU0NlcnRpZmljYXRlID0gZnVuY3Rpb24oY2VydCkge1xuICAvLyBUQlNDZXJ0aWZpY2F0ZVxuICB2YXIgbm90QmVmb3JlID0gX2RhdGVUb0FzbjEoY2VydC52YWxpZGl0eS5ub3RCZWZvcmUpO1xuICB2YXIgbm90QWZ0ZXIgPSBfZGF0ZVRvQXNuMShjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyKTtcbiAgdmFyIHRicyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAvLyBpbnRlZ2VyXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICBhc24xLmludGVnZXJUb0RlcihjZXJ0LnZlcnNpb24pLmdldEJ5dGVzKCkpXG4gICAgXSksXG4gICAgLy8gc2VyaWFsTnVtYmVyXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhjZXJ0LnNlcmlhbE51bWJlcikpLFxuICAgIC8vIHNpZ25hdHVyZVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIC8vIGFsZ29yaXRobVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gcGFyYW1ldGVyc1xuICAgICAgX3NpZ25hdHVyZVBhcmFtZXRlcnNUb0FzbjEoXG4gICAgICAgIGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQsIGNlcnQuc2lnaW5mby5wYXJhbWV0ZXJzKVxuICAgIF0pLFxuICAgIC8vIGlzc3VlclxuICAgIF9kblRvQXNuMShjZXJ0Lmlzc3VlciksXG4gICAgLy8gdmFsaWRpdHlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICBub3RCZWZvcmUsXG4gICAgICBub3RBZnRlclxuICAgIF0pLFxuICAgIC8vIHN1YmplY3RcbiAgICBfZG5Ub0FzbjEoY2VydC5zdWJqZWN0KSxcbiAgICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICAgIHBraS5wdWJsaWNLZXlUb0FzbjEoY2VydC5wdWJsaWNLZXkpXG4gIF0pO1xuXG4gIGlmKGNlcnQuaXNzdWVyLnVuaXF1ZUlkKSB7XG4gICAgLy8gaXNzdWVyVW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAxLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgK1xuICAgICAgICAgIGNlcnQuaXNzdWVyLnVuaXF1ZUlkXG4gICAgICAgIClcbiAgICAgIF0pXG4gICAgKTtcbiAgfVxuICBpZihjZXJ0LnN1YmplY3QudW5pcXVlSWQpIHtcbiAgICAvLyBzdWJqZWN0VW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAyLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgK1xuICAgICAgICAgIGNlcnQuc3ViamVjdC51bmlxdWVJZFxuICAgICAgICApXG4gICAgICBdKVxuICAgICk7XG4gIH1cblxuICBpZihjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoID4gMCkge1xuICAgIC8vIGV4dGVuc2lvbnMgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNUb0FzbjEoY2VydC5leHRlbnNpb25zKSk7XG4gIH1cblxuICByZXR1cm4gdGJzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBBU04uMSBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gcGFydCBvZiBhXG4gKiBQS0NTIzEwIENlcnRpZmljYXRpb25SZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSBjc3IgdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhc24xIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5cbiAqL1xucGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyA9IGZ1bmN0aW9uKGNzcikge1xuICAvLyBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9cbiAgdmFyIGNyaSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGFzbjEuaW50ZWdlclRvRGVyKGNzci52ZXJzaW9uKS5nZXRCeXRlcygpKSxcbiAgICAvLyBzdWJqZWN0XG4gICAgX2RuVG9Bc24xKGNzci5zdWJqZWN0KSxcbiAgICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICAgIHBraS5wdWJsaWNLZXlUb0FzbjEoY3NyLnB1YmxpY0tleSksXG4gICAgLy8gYXR0cmlidXRlc1xuICAgIF9DUklBdHRyaWJ1dGVzVG9Bc24xKGNzcilcbiAgXSk7XG5cbiAgcmV0dXJuIGNyaTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBEaXN0aW5ndWlzaGVkTmFtZSAoc3ViamVjdCBvciBpc3N1ZXIpIHRvIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gZG4gdGhlIERpc3Rpbmd1aXNoZWROYW1lLlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBEaXN0aW5ndWlzaGVkTmFtZS5cbiAqL1xucGtpLmRpc3Rpbmd1aXNoZWROYW1lVG9Bc24xID0gZnVuY3Rpb24oZG4pIHtcbiAgcmV0dXJuIF9kblRvQXNuMShkbik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFguNTA5djMgUlNBIGNlcnRpZmljYXRlIHRvIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhbiBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmNlcnRpZmljYXRlVG9Bc24xID0gZnVuY3Rpb24oY2VydCkge1xuICAvLyBwcmVmZXIgY2FjaGVkIFRCU0NlcnRpZmljYXRlIG92ZXIgZ2VuZXJhdGluZyBvbmVcbiAgdmFyIHRic0NlcnRpZmljYXRlID0gY2VydC50YnNDZXJ0aWZpY2F0ZSB8fCBwa2kuZ2V0VEJTQ2VydGlmaWNhdGUoY2VydCk7XG5cbiAgLy8gQ2VydGlmaWNhdGVcbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBUQlNDZXJ0aWZpY2F0ZVxuICAgIHRic0NlcnRpZmljYXRlLFxuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoY2VydC5zaWduYXR1cmVPaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gcGFyYW1ldGVyc1xuICAgICAgX3NpZ25hdHVyZVBhcmFtZXRlcnNUb0FzbjEoY2VydC5zaWduYXR1cmVPaWQsIGNlcnQuc2lnbmF0dXJlUGFyYW1ldGVycylcbiAgICBdKSxcbiAgICAvLyBTaWduYXR1cmVWYWx1ZVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgKyBjZXJ0LnNpZ25hdHVyZSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIFguNTA5djMgY2VydGlmaWNhdGUgZXh0ZW5zaW9ucyB0byBBU04uMS5cbiAqXG4gKiBAcGFyYW0gZXh0cyB0aGUgZXh0ZW5zaW9ucyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGV4dGVuc2lvbnMgaW4gQVNOLjEgZm9ybWF0LlxuICovXG5wa2kuY2VydGlmaWNhdGVFeHRlbnNpb25zVG9Bc24xID0gZnVuY3Rpb24oZXh0cykge1xuICAvLyBjcmVhdGUgdG9wLWxldmVsIGV4dGVuc2lvbiBjb250YWluZXJcbiAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDMsIHRydWUsIFtdKTtcblxuICAvLyBjcmVhdGUgZXh0ZW5zaW9uIHNlcXVlbmNlIChzdG9yZXMgYSBzZXF1ZW5jZSBmb3IgZWFjaCBleHRlbnNpb24pXG4gIHZhciBzZXEgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gIHJ2YWwudmFsdWUucHVzaChzZXEpO1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBleHRzLmxlbmd0aDsgKytpKSB7XG4gICAgc2VxLnZhbHVlLnB1c2gocGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uVG9Bc24xKGV4dHNbaV0pKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNpbmdsZSBjZXJ0aWZpY2F0ZSBleHRlbnNpb24gdG8gQVNOLjEuXG4gKlxuICogQHBhcmFtIGV4dCB0aGUgZXh0ZW5zaW9uIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgZXh0ZW5zaW9uIGluIEFTTi4xIGZvcm1hdC5cbiAqL1xucGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uVG9Bc24xID0gZnVuY3Rpb24oZXh0KSB7XG4gIC8vIGNyZWF0ZSBhIHNlcXVlbmNlIGZvciBlYWNoIGV4dGVuc2lvblxuICB2YXIgZXh0c2VxID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuXG4gIC8vIGV4dG5JRCAoT0lEKVxuICBleHRzZXEudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgYXNuMS5vaWRUb0RlcihleHQuaWQpLmdldEJ5dGVzKCkpKTtcblxuICAvLyBjcml0aWNhbCBkZWZhdWx0cyB0byBmYWxzZVxuICBpZihleHQuY3JpdGljYWwpIHtcbiAgICAvLyBjcml0aWNhbCBCT09MRUFOIERFRkFVTFQgRkFMU0VcbiAgICBleHRzZXEudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQk9PTEVBTiwgZmFsc2UsXG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkYpKSk7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBleHQudmFsdWU7XG4gIGlmKHR5cGVvZiBleHQudmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gdmFsdWUgaXMgYXNuLjFcbiAgICB2YWx1ZSA9IGFzbjEudG9EZXIodmFsdWUpLmdldEJ5dGVzKCk7XG4gIH1cblxuICAvLyBleHRuVmFsdWUgKE9DVEVUIFNUUklORylcbiAgZXh0c2VxLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHZhbHVlKSk7XG5cbiAgcmV0dXJuIGV4dHNlcTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQS0NTIzEwIGNlcnRpZmljYXRpb24gcmVxdWVzdCB0byBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGNzciB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKi9cbnBraS5jZXJ0aWZpY2F0aW9uUmVxdWVzdFRvQXNuMSA9IGZ1bmN0aW9uKGNzcikge1xuICAvLyBwcmVmZXIgY2FjaGVkIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBvdmVyIGdlbmVyYXRpbmcgb25lXG4gIHZhciBjcmkgPSBjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHx8XG4gICAgcGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyhjc3IpO1xuXG4gIC8vIENlcnRpZmljYXRlXG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvXG4gICAgY3JpLFxuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoY3NyLnNpZ25hdHVyZU9pZCkuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBwYXJhbWV0ZXJzXG4gICAgICBfc2lnbmF0dXJlUGFyYW1ldGVyc1RvQXNuMShjc3Iuc2lnbmF0dXJlT2lkLCBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycylcbiAgICBdKSxcbiAgICAvLyBzaWduYXR1cmVcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJJVFNUUklORywgZmFsc2UsXG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MDApICsgY3NyLnNpZ25hdHVyZSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBDQSBzdG9yZS5cbiAqXG4gKiBAcGFyYW0gY2VydHMgYW4gb3B0aW9uYWwgYXJyYXkgb2YgY2VydGlmaWNhdGUgb2JqZWN0cyBvciBQRU0tZm9ybWF0dGVkXG4gKiAgICAgICAgICBjZXJ0aWZpY2F0ZSBzdHJpbmdzIHRvIGFkZCB0byB0aGUgQ0Egc3RvcmUuXG4gKlxuICogQHJldHVybiB0aGUgQ0Egc3RvcmUuXG4gKi9cbnBraS5jcmVhdGVDYVN0b3JlID0gZnVuY3Rpb24oY2VydHMpIHtcbiAgLy8gY3JlYXRlIENBIHN0b3JlXG4gIHZhciBjYVN0b3JlID0ge1xuICAgIC8vIHN0b3JlZCBjZXJ0aWZpY2F0ZXNcbiAgICBjZXJ0czoge31cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgY2VydGlmaWNhdGUgdGhhdCBpc3N1ZWQgdGhlIHBhc3NlZCBjZXJ0aWZpY2F0ZSBvciBpdHNcbiAgICogJ3BhcmVudCcuXG4gICAqXG4gICAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZSB0byBnZXQgdGhlIHBhcmVudCBmb3IuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHBhcmVudCBjZXJ0aWZpY2F0ZSBvciBudWxsIGlmIG5vbmUgd2FzIGZvdW5kLlxuICAgKi9cbiAgY2FTdG9yZS5nZXRJc3N1ZXIgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgdmFyIHJ2YWwgPSBnZXRCeVN1YmplY3QoY2VydC5pc3N1ZXIpO1xuXG4gICAgLy8gc2VlIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBtYXRjaGVzXG4gICAgLyppZihmb3JnZS51dGlsLmlzQXJyYXkocnZhbCkpIHtcbiAgICAgIC8vIFRPRE86IHJlc29sdmUgbXVsdGlwbGUgbWF0Y2hlcyBieSBjaGVja2luZ1xuICAgICAgLy8gYXV0aG9yaXR5S2V5L3N1YmplY3RLZXkvaXNzdWVyVW5pcXVlSUQvb3RoZXIgaWRlbnRpZmllcnMsIGV0Yy5cbiAgICAgIC8vIEZJWE1FOiBvciBhbHRlcm5hdGl2ZWx5IGRvIGF1dGhvcml0eSBrZXkgbWFwcGluZ1xuICAgICAgLy8gaWYgcG9zc2libGUgKFguNTA5djEgY2VydHMgY2FuJ3Qgd29yaz8pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc29sdmluZyBtdWx0aXBsZSBpc3N1ZXIgbWF0Y2hlcyBub3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICAgIH0qL1xuXG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB0cnVzdGVkIGNlcnRpZmljYXRlIHRvIHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIHRvIGFkZCBhcyBhIHRydXN0ZWQgY2VydGlmaWNhdGUgKGVpdGhlciBhXG4gICAqICAgICAgICAgIHBraS5jZXJ0aWZpY2F0ZSBvYmplY3Qgb3IgYSBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlKS5cbiAgICovXG4gIGNhU3RvcmUuYWRkQ2VydGlmaWNhdGUgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgLy8gY29udmVydCBmcm9tIHBlbSBpZiBuZWNlc3NhcnlcbiAgICBpZih0eXBlb2YgY2VydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNlcnQgPSBmb3JnZS5wa2kuY2VydGlmaWNhdGVGcm9tUGVtKGNlcnQpO1xuICAgIH1cblxuICAgIGVuc3VyZVN1YmplY3RIYXNIYXNoKGNlcnQuc3ViamVjdCk7XG5cbiAgICBpZighY2FTdG9yZS5oYXNDZXJ0aWZpY2F0ZShjZXJ0KSkgeyAvLyBhdm9pZCBkdXBsaWNhdGUgY2VydGlmaWNhdGVzIGluIHN0b3JlXG4gICAgICBpZihjZXJ0LnN1YmplY3QuaGFzaCBpbiBjYVN0b3JlLmNlcnRzKSB7XG4gICAgICAgIC8vIHN1YmplY3QgaGFzaCBhbHJlYWR5IGV4aXN0cywgYXBwZW5kIHRvIGFycmF5XG4gICAgICAgIHZhciB0bXAgPSBjYVN0b3JlLmNlcnRzW2NlcnQuc3ViamVjdC5oYXNoXTtcbiAgICAgICAgaWYoIWZvcmdlLnV0aWwuaXNBcnJheSh0bXApKSB7XG4gICAgICAgICAgdG1wID0gW3RtcF07XG4gICAgICAgIH1cbiAgICAgICAgdG1wLnB1c2goY2VydCk7XG4gICAgICAgIGNhU3RvcmUuY2VydHNbY2VydC5zdWJqZWN0Lmhhc2hdID0gdG1wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FTdG9yZS5jZXJ0c1tjZXJ0LnN1YmplY3QuaGFzaF0gPSBjZXJ0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgZ2l2ZW4gY2VydGlmaWNhdGUgaXMgaW4gdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUgdG8gY2hlY2sgKGVpdGhlciBhIHBraS5jZXJ0aWZpY2F0ZSBvciBhXG4gICAqICAgICAgICAgIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUpLlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIGNlcnRpZmljYXRlIGlzIGluIHRoZSBzdG9yZSwgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAgY2FTdG9yZS5oYXNDZXJ0aWZpY2F0ZSA9IGZ1bmN0aW9uKGNlcnQpIHtcbiAgICAvLyBjb252ZXJ0IGZyb20gcGVtIGlmIG5lY2Vzc2FyeVxuICAgIGlmKHR5cGVvZiBjZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgY2VydCA9IGZvcmdlLnBraS5jZXJ0aWZpY2F0ZUZyb21QZW0oY2VydCk7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gZ2V0QnlTdWJqZWN0KGNlcnQuc3ViamVjdCk7XG4gICAgaWYoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkobWF0Y2gpKSB7XG4gICAgICBtYXRjaCA9IFttYXRjaF07XG4gICAgfVxuICAgIC8vIGNvbXBhcmUgREVSLWVuY29kaW5nIG9mIGNlcnRpZmljYXRlc1xuICAgIHZhciBkZXIxID0gYXNuMS50b0Rlcihwa2kuY2VydGlmaWNhdGVUb0FzbjEoY2VydCkpLmdldEJ5dGVzKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1hdGNoLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZGVyMiA9IGFzbjEudG9EZXIocGtpLmNlcnRpZmljYXRlVG9Bc24xKG1hdGNoW2ldKSkuZ2V0Qnl0ZXMoKTtcbiAgICAgIGlmKGRlcjEgPT09IGRlcjIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogTGlzdHMgYWxsIG9mIHRoZSBjZXJ0aWZpY2F0ZXMga2VwdCBpbiB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm4gYW4gYXJyYXkgb2YgYWxsIG9mIHRoZSBwa2kuY2VydGlmaWNhdGUgb2JqZWN0cyBpbiB0aGUgc3RvcmUuXG4gICAqL1xuICBjYVN0b3JlLmxpc3RBbGxDZXJ0aWZpY2F0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2VydExpc3QgPSBbXTtcblxuICAgIGZvcih2YXIgaGFzaCBpbiBjYVN0b3JlLmNlcnRzKSB7XG4gICAgICBpZihjYVN0b3JlLmNlcnRzLmhhc093blByb3BlcnR5KGhhc2gpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGNhU3RvcmUuY2VydHNbaGFzaF07XG4gICAgICAgIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgY2VydExpc3QucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjZXJ0TGlzdC5wdXNoKHZhbHVlW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2VydExpc3Q7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjZXJ0aWZpY2F0ZSBmcm9tIHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIHRvIHJlbW92ZSAoZWl0aGVyIGEgcGtpLmNlcnRpZmljYXRlIG9yIGFcbiAgICogICAgICAgICAgUEVNLWZvcm1hdHRlZCBjZXJ0aWZpY2F0ZSkuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIGNlcnRpZmljYXRlIHRoYXQgd2FzIHJlbW92ZWQgb3IgbnVsbCBpZiB0aGUgY2VydGlmaWNhdGVcbiAgICogICAgICAgICAgIHdhc24ndCBpbiBzdG9yZS5cbiAgICovXG4gIGNhU3RvcmUucmVtb3ZlQ2VydGlmaWNhdGUgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIC8vIGNvbnZlcnQgZnJvbSBwZW0gaWYgbmVjZXNzYXJ5XG4gICAgaWYodHlwZW9mIGNlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjZXJ0ID0gZm9yZ2UucGtpLmNlcnRpZmljYXRlRnJvbVBlbShjZXJ0KTtcbiAgICB9XG4gICAgZW5zdXJlU3ViamVjdEhhc0hhc2goY2VydC5zdWJqZWN0KTtcbiAgICBpZighY2FTdG9yZS5oYXNDZXJ0aWZpY2F0ZShjZXJ0KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gZ2V0QnlTdWJqZWN0KGNlcnQuc3ViamVjdCk7XG5cbiAgICBpZighZm9yZ2UudXRpbC5pc0FycmF5KG1hdGNoKSkge1xuICAgICAgcmVzdWx0ID0gY2FTdG9yZS5jZXJ0c1tjZXJ0LnN1YmplY3QuaGFzaF07XG4gICAgICBkZWxldGUgY2FTdG9yZS5jZXJ0c1tjZXJ0LnN1YmplY3QuaGFzaF07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgREVSLWVuY29kaW5nIG9mIGNlcnRpZmljYXRlc1xuICAgIHZhciBkZXIxID0gYXNuMS50b0Rlcihwa2kuY2VydGlmaWNhdGVUb0FzbjEoY2VydCkpLmdldEJ5dGVzKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1hdGNoLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZGVyMiA9IGFzbjEudG9EZXIocGtpLmNlcnRpZmljYXRlVG9Bc24xKG1hdGNoW2ldKSkuZ2V0Qnl0ZXMoKTtcbiAgICAgIGlmKGRlcjEgPT09IGRlcjIpIHtcbiAgICAgICAgcmVzdWx0ID0gbWF0Y2hbaV07XG4gICAgICAgIG1hdGNoLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYobWF0Y2gubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgY2FTdG9yZS5jZXJ0c1tjZXJ0LnN1YmplY3QuaGFzaF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRCeVN1YmplY3Qoc3ViamVjdCkge1xuICAgIGVuc3VyZVN1YmplY3RIYXNIYXNoKHN1YmplY3QpO1xuICAgIHJldHVybiBjYVN0b3JlLmNlcnRzW3N1YmplY3QuaGFzaF0gfHwgbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuc3VyZVN1YmplY3RIYXNIYXNoKHN1YmplY3QpIHtcbiAgICAvLyBwcm9kdWNlIHN1YmplY3QgaGFzaCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgaWYoIXN1YmplY3QuaGFzaCkge1xuICAgICAgdmFyIG1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICAgIHN1YmplY3QuYXR0cmlidXRlcyA9IHBraS5SRE5BdHRyaWJ1dGVzQXNBcnJheShfZG5Ub0FzbjEoc3ViamVjdCksIG1kKTtcbiAgICAgIHN1YmplY3QuaGFzaCA9IG1kLmRpZ2VzdCgpLnRvSGV4KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gYXV0by1hZGQgcGFzc2VkIGluIGNlcnRzXG4gIGlmKGNlcnRzKSB7XG4gICAgLy8gcGFyc2UgUEVNLWZvcm1hdHRlZCBjZXJ0aWZpY2F0ZXMgYXMgbmVjZXNzYXJ5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNlcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgY2VydCA9IGNlcnRzW2ldO1xuICAgICAgY2FTdG9yZS5hZGRDZXJ0aWZpY2F0ZShjZXJ0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FTdG9yZTtcbn07XG5cbi8qKlxuICogQ2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uIGVycm9ycywgYmFzZWQgb24gVExTLlxuICovXG5wa2kuY2VydGlmaWNhdGVFcnJvciA9IHtcbiAgYmFkX2NlcnRpZmljYXRlOiAnZm9yZ2UucGtpLkJhZENlcnRpZmljYXRlJyxcbiAgdW5zdXBwb3J0ZWRfY2VydGlmaWNhdGU6ICdmb3JnZS5wa2kuVW5zdXBwb3J0ZWRDZXJ0aWZpY2F0ZScsXG4gIGNlcnRpZmljYXRlX3Jldm9rZWQ6ICdmb3JnZS5wa2kuQ2VydGlmaWNhdGVSZXZva2VkJyxcbiAgY2VydGlmaWNhdGVfZXhwaXJlZDogJ2ZvcmdlLnBraS5DZXJ0aWZpY2F0ZUV4cGlyZWQnLFxuICBjZXJ0aWZpY2F0ZV91bmtub3duOiAnZm9yZ2UucGtpLkNlcnRpZmljYXRlVW5rbm93bicsXG4gIHVua25vd25fY2E6ICdmb3JnZS5wa2kuVW5rbm93bkNlcnRpZmljYXRlQXV0aG9yaXR5J1xufTtcblxuLyoqXG4gKiBWZXJpZmllcyBhIGNlcnRpZmljYXRlIGNoYWluIGFnYWluc3QgdGhlIGdpdmVuIENlcnRpZmljYXRlIEF1dGhvcml0eSBzdG9yZVxuICogd2l0aCBhbiBvcHRpb25hbCBjdXN0b20gdmVyaWZ5IGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSBjYVN0b3JlIGEgY2VydGlmaWNhdGUgc3RvcmUgdG8gdmVyaWZ5IGFnYWluc3QuXG4gKiBAcGFyYW0gY2hhaW4gdGhlIGNlcnRpZmljYXRlIGNoYWluIHRvIHZlcmlmeSwgd2l0aCB0aGUgcm9vdCBvciBoaWdoZXN0XG4gKiAgICAgICAgICBhdXRob3JpdHkgYXQgdGhlIGVuZCAoYW4gYXJyYXkgb2YgY2VydGlmaWNhdGVzKS5cbiAqIEBwYXJhbSBvcHRpb25zIGEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGZvciBldmVyeSBjZXJ0aWZpY2F0ZSBpbiB0aGUgY2hhaW4gb3JcbiAqICAgICAgICAgICAgICAgICAgYW4gb2JqZWN0IHdpdGg6XG4gKiAgICAgICAgICAgICAgICAgIHZlcmlmeSBhIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBmb3IgZXZlcnkgY2VydGlmaWNhdGUgaW4gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgY2hhaW5cbiAqICAgICAgICAgICAgICAgICAgdmFsaWRpdHlDaGVja0RhdGUgdGhlIGRhdGUgYWdhaW5zdCB3aGljaCB0aGUgY2VydGlmaWNhdGVcbiAqICAgICAgICAgICAgICAgICAgICB2YWxpZGl0eSBwZXJpb2Qgc2hvdWxkIGJlIGNoZWNrZWQuIFBhc3MgbnVsbCB0byBub3QgY2hlY2tcbiAqICAgICAgICAgICAgICAgICAgICB0aGUgdmFsaWRpdHkgcGVyaW9kLiBCeSBkZWZhdWx0LCB0aGUgY3VycmVudCBkYXRlIGlzIHVzZWQuXG4gKlxuICogVGhlIHZlcmlmeSBjYWxsYmFjayBoYXMgdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gKlxuICogdmVyaWZpZWQgLSBTZXQgdG8gdHJ1ZSBpZiBjZXJ0aWZpY2F0ZSB3YXMgdmVyaWZpZWQsIG90aGVyd2lzZSB0aGVcbiAqICAgcGtpLmNlcnRpZmljYXRlRXJyb3IgZm9yIHdoeSB0aGUgY2VydGlmaWNhdGUgZmFpbGVkLlxuICogZGVwdGggLSBUaGUgY3VycmVudCBpbmRleCBpbiB0aGUgY2hhaW4sIHdoZXJlIDAgaXMgdGhlIGVuZCBwb2ludCdzIGNlcnQuXG4gKiBjZXJ0cyAtIFRoZSBjZXJ0aWZpY2F0ZSBjaGFpbiwgKk5PVEUqIGFuIGVtcHR5IGNoYWluIGluZGljYXRlcyBhbiBhbm9ueW1vdXNcbiAqICAgZW5kIHBvaW50LlxuICpcbiAqIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgb24gc3VjY2VzcyBhbmQgb24gZmFpbHVyZSBlaXRoZXIgdGhlIGFwcHJvcHJpYXRlXG4gKiBwa2kuY2VydGlmaWNhdGVFcnJvciBvciBhbiBvYmplY3Qgd2l0aCAnZXJyb3InIHNldCB0byB0aGUgYXBwcm9wcmlhdGVcbiAqIHBraS5jZXJ0aWZpY2F0ZUVycm9yIGFuZCAnbWVzc2FnZScgc2V0IHRvIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2UuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIHRocm93biBpZiBub3QuXG4gKi9cbnBraS52ZXJpZnlDZXJ0aWZpY2F0ZUNoYWluID0gZnVuY3Rpb24oY2FTdG9yZSwgY2hhaW4sIG9wdGlvbnMpIHtcbiAgLyogRnJvbTogUkZDMzI4MCAtIEludGVybmV0IFguNTA5IFB1YmxpYyBLZXkgSW5mcmFzdHJ1Y3R1cmUgQ2VydGlmaWNhdGVcbiAgICBTZWN0aW9uIDY6IENlcnRpZmljYXRpb24gUGF0aCBWYWxpZGF0aW9uXG4gICAgU2VlIGlubGluZSBwYXJlbnRoZXRpY2FscyByZWxhdGVkIHRvIHRoaXMgcGFydGljdWxhciBpbXBsZW1lbnRhdGlvbi5cblxuICAgIFRoZSBwcmltYXJ5IGdvYWwgb2YgcGF0aCB2YWxpZGF0aW9uIGlzIHRvIHZlcmlmeSB0aGUgYmluZGluZyBiZXR3ZWVuXG4gICAgYSBzdWJqZWN0IGRpc3Rpbmd1aXNoZWQgbmFtZSBvciBhIHN1YmplY3QgYWx0ZXJuYXRpdmUgbmFtZSBhbmQgc3ViamVjdFxuICAgIHB1YmxpYyBrZXksIGFzIHJlcHJlc2VudGVkIGluIHRoZSBlbmQgZW50aXR5IGNlcnRpZmljYXRlLCBiYXNlZCBvbiB0aGVcbiAgICBwdWJsaWMga2V5IG9mIHRoZSB0cnVzdCBhbmNob3IuIFRoaXMgcmVxdWlyZXMgb2J0YWluaW5nIGEgc2VxdWVuY2Ugb2ZcbiAgICBjZXJ0aWZpY2F0ZXMgdGhhdCBzdXBwb3J0IHRoYXQgYmluZGluZy4gVGhhdCBzZXF1ZW5jZSBzaG91bGQgYmUgcHJvdmlkZWRcbiAgICBpbiB0aGUgcGFzc2VkICdjaGFpbicuIFRoZSB0cnVzdCBhbmNob3Igc2hvdWxkIGJlIGluIHRoZSBnaXZlbiBDQVxuICAgIHN0b3JlLiBUaGUgJ2VuZCBlbnRpdHknIGNlcnRpZmljYXRlIGlzIHRoZSBjZXJ0aWZpY2F0ZSBwcm92aWRlZCBieSB0aGVcbiAgICBlbmQgcG9pbnQgKHR5cGljYWxseSBhIHNlcnZlcikgYW5kIGlzIHRoZSBmaXJzdCBpbiB0aGUgY2hhaW4uXG5cbiAgICBUbyBtZWV0IHRoaXMgZ29hbCwgdGhlIHBhdGggdmFsaWRhdGlvbiBwcm9jZXNzIHZlcmlmaWVzLCBhbW9uZyBvdGhlclxuICAgIHRoaW5ncywgdGhhdCBhIHByb3NwZWN0aXZlIGNlcnRpZmljYXRpb24gcGF0aCAoYSBzZXF1ZW5jZSBvZiBuXG4gICAgY2VydGlmaWNhdGVzIG9yIGEgJ2NoYWluJykgc2F0aXNmaWVzIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgIChhKSBmb3IgYWxsIHggaW4gezEsIC4uLiwgbi0xfSwgdGhlIHN1YmplY3Qgb2YgY2VydGlmaWNhdGUgeCBpc1xuICAgICAgICAgIHRoZSBpc3N1ZXIgb2YgY2VydGlmaWNhdGUgeCsxO1xuXG4gICAgKGIpIGNlcnRpZmljYXRlIDEgaXMgaXNzdWVkIGJ5IHRoZSB0cnVzdCBhbmNob3I7XG5cbiAgICAoYykgY2VydGlmaWNhdGUgbiBpcyB0aGUgY2VydGlmaWNhdGUgdG8gYmUgdmFsaWRhdGVkOyBhbmRcblxuICAgIChkKSBmb3IgYWxsIHggaW4gezEsIC4uLiwgbn0sIHRoZSBjZXJ0aWZpY2F0ZSB3YXMgdmFsaWQgYXQgdGhlXG4gICAgICAgICAgdGltZSBpbiBxdWVzdGlvbi5cblxuICAgIE5vdGUgdGhhdCBoZXJlICduJyBpcyBpbmRleCAwIGluIHRoZSBjaGFpbiBhbmQgMSBpcyB0aGUgbGFzdCBjZXJ0aWZpY2F0ZVxuICAgIGluIHRoZSBjaGFpbiBhbmQgaXQgbXVzdCBiZSBzaWduZWQgYnkgYSBjZXJ0aWZpY2F0ZSBpbiB0aGUgY29ubmVjdGlvbidzXG4gICAgQ0Egc3RvcmUuXG5cbiAgICBUaGUgcGF0aCB2YWxpZGF0aW9uIHByb2Nlc3MgYWxzbyBkZXRlcm1pbmVzIHRoZSBzZXQgb2YgY2VydGlmaWNhdGVcbiAgICBwb2xpY2llcyB0aGF0IGFyZSB2YWxpZCBmb3IgdGhpcyBwYXRoLCBiYXNlZCBvbiB0aGUgY2VydGlmaWNhdGUgcG9saWNpZXNcbiAgICBleHRlbnNpb24sIHBvbGljeSBtYXBwaW5nIGV4dGVuc2lvbiwgcG9saWN5IGNvbnN0cmFpbnRzIGV4dGVuc2lvbiwgYW5kXG4gICAgaW5oaWJpdCBhbnktcG9saWN5IGV4dGVuc2lvbi5cblxuICAgIE5vdGU6IFBvbGljeSBtYXBwaW5nIGV4dGVuc2lvbiBub3Qgc3VwcG9ydGVkIChOb3QgUmVxdWlyZWQpLlxuXG4gICAgTm90ZTogSWYgdGhlIGNlcnRpZmljYXRlIGhhcyBhbiB1bnN1cHBvcnRlZCBjcml0aWNhbCBleHRlbnNpb24sIHRoZW4gaXRcbiAgICBtdXN0IGJlIHJlamVjdGVkLlxuXG4gICAgTm90ZTogQSBjZXJ0aWZpY2F0ZSBpcyBzZWxmLWlzc3VlZCBpZiB0aGUgRE5zIHRoYXQgYXBwZWFyIGluIHRoZSBzdWJqZWN0XG4gICAgYW5kIGlzc3VlciBmaWVsZHMgYXJlIGlkZW50aWNhbCBhbmQgYXJlIG5vdCBlbXB0eS5cblxuICAgIFRoZSBwYXRoIHZhbGlkYXRpb24gYWxnb3JpdGhtIGFzc3VtZXMgdGhlIGZvbGxvd2luZyBzZXZlbiBpbnB1dHMgYXJlXG4gICAgcHJvdmlkZWQgdG8gdGhlIHBhdGggcHJvY2Vzc2luZyBsb2dpYy4gV2hhdCB0aGlzIHNwZWNpZmljIGltcGxlbWVudGF0aW9uXG4gICAgd2lsbCB1c2UgaXMgcHJvdmlkZWQgcGFyZW50aGV0aWNhbGx5OlxuXG4gICAgKGEpIGEgcHJvc3BlY3RpdmUgY2VydGlmaWNhdGlvbiBwYXRoIG9mIGxlbmd0aCBuICh0aGUgJ2NoYWluJylcbiAgICAoYikgdGhlIGN1cnJlbnQgZGF0ZS90aW1lOiAoJ25vdycpLlxuICAgIChjKSB1c2VyLWluaXRpYWwtcG9saWN5LXNldDogQSBzZXQgb2YgY2VydGlmaWNhdGUgcG9saWN5IGlkZW50aWZpZXJzXG4gICAgICAgICAgbmFtaW5nIHRoZSBwb2xpY2llcyB0aGF0IGFyZSBhY2NlcHRhYmxlIHRvIHRoZSBjZXJ0aWZpY2F0ZSB1c2VyLlxuICAgICAgICAgIFRoZSB1c2VyLWluaXRpYWwtcG9saWN5LXNldCBjb250YWlucyB0aGUgc3BlY2lhbCB2YWx1ZSBhbnktcG9saWN5XG4gICAgICAgICAgaWYgdGhlIHVzZXIgaXMgbm90IGNvbmNlcm5lZCBhYm91dCBjZXJ0aWZpY2F0ZSBwb2xpY3lcbiAgICAgICAgICAoTm90IGltcGxlbWVudGVkLiBBbnkgcG9saWN5IGlzIGFjY2VwdGVkKS5cbiAgICAoZCkgdHJ1c3QgYW5jaG9yIGluZm9ybWF0aW9uLCBkZXNjcmliaW5nIGEgQ0EgdGhhdCBzZXJ2ZXMgYXMgYSB0cnVzdFxuICAgICAgICAgIGFuY2hvciBmb3IgdGhlIGNlcnRpZmljYXRpb24gcGF0aC4gVGhlIHRydXN0IGFuY2hvciBpbmZvcm1hdGlvblxuICAgICAgICAgIGluY2x1ZGVzOlxuXG4gICAgICAoMSkgIHRoZSB0cnVzdGVkIGlzc3VlciBuYW1lLFxuICAgICAgKDIpICB0aGUgdHJ1c3RlZCBwdWJsaWMga2V5IGFsZ29yaXRobSxcbiAgICAgICgzKSAgdGhlIHRydXN0ZWQgcHVibGljIGtleSwgYW5kXG4gICAgICAoNCkgIG9wdGlvbmFsbHksIHRoZSB0cnVzdGVkIHB1YmxpYyBrZXkgcGFyYW1ldGVycyBhc3NvY2lhdGVkXG4gICAgICAgICAgICAgd2l0aCB0aGUgcHVibGljIGtleS5cblxuICAgICAgKFRydXN0IGFuY2hvcnMgYXJlIHByb3ZpZGVkIHZpYSBjZXJ0aWZpY2F0ZXMgaW4gdGhlIENBIHN0b3JlKS5cblxuICAgICAgVGhlIHRydXN0IGFuY2hvciBpbmZvcm1hdGlvbiBtYXkgYmUgcHJvdmlkZWQgdG8gdGhlIHBhdGggcHJvY2Vzc2luZ1xuICAgICAgcHJvY2VkdXJlIGluIHRoZSBmb3JtIG9mIGEgc2VsZi1zaWduZWQgY2VydGlmaWNhdGUuIFRoZSB0cnVzdGVkIGFuY2hvclxuICAgICAgaW5mb3JtYXRpb24gaXMgdHJ1c3RlZCBiZWNhdXNlIGl0IHdhcyBkZWxpdmVyZWQgdG8gdGhlIHBhdGggcHJvY2Vzc2luZ1xuICAgICAgcHJvY2VkdXJlIGJ5IHNvbWUgdHJ1c3R3b3J0aHkgb3V0LW9mLWJhbmQgcHJvY2VkdXJlLiBJZiB0aGUgdHJ1c3RlZFxuICAgICAgcHVibGljIGtleSBhbGdvcml0aG0gcmVxdWlyZXMgcGFyYW1ldGVycywgdGhlbiB0aGUgcGFyYW1ldGVycyBhcmVcbiAgICAgIHByb3ZpZGVkIGFsb25nIHdpdGggdGhlIHRydXN0ZWQgcHVibGljIGtleSAoTm8gcGFyYW1ldGVycyB1c2VkIGluIHRoaXNcbiAgICAgIGltcGxlbWVudGF0aW9uKS5cblxuICAgIChlKSBpbml0aWFsLXBvbGljeS1tYXBwaW5nLWluaGliaXQsIHdoaWNoIGluZGljYXRlcyBpZiBwb2xpY3kgbWFwcGluZyBpc1xuICAgICAgICAgIGFsbG93ZWQgaW4gdGhlIGNlcnRpZmljYXRpb24gcGF0aC5cbiAgICAgICAgICAoTm90IGltcGxlbWVudGVkLCBubyBwb2xpY3kgY2hlY2tpbmcpXG5cbiAgICAoZikgaW5pdGlhbC1leHBsaWNpdC1wb2xpY3ksIHdoaWNoIGluZGljYXRlcyBpZiB0aGUgcGF0aCBtdXN0IGJlIHZhbGlkXG4gICAgICAgICAgZm9yIGF0IGxlYXN0IG9uZSBvZiB0aGUgY2VydGlmaWNhdGUgcG9saWNpZXMgaW4gdGhlIHVzZXItaW5pdGlhbC1cbiAgICAgICAgICBwb2xpY3ktc2V0LlxuICAgICAgICAgIChOb3QgaW1wbGVtZW50ZWQsIG5vIHBvbGljeSBjaGVja2luZylcblxuICAgIChnKSBpbml0aWFsLWFueS1wb2xpY3ktaW5oaWJpdCwgd2hpY2ggaW5kaWNhdGVzIHdoZXRoZXIgdGhlXG4gICAgICAgICAgYW55UG9saWN5IE9JRCBzaG91bGQgYmUgcHJvY2Vzc2VkIGlmIGl0IGlzIGluY2x1ZGVkIGluIGFcbiAgICAgICAgICBjZXJ0aWZpY2F0ZS5cbiAgICAgICAgICAoTm90IGltcGxlbWVudGVkLCBzbyBhbnkgcG9saWN5IGlzIHZhbGlkIHByb3ZpZGVkIHRoYXQgaXQgaXNcbiAgICAgICAgICBub3QgbWFya2VkIGFzIGNyaXRpY2FsKSAqL1xuXG4gIC8qIEJhc2ljIFBhdGggUHJvY2Vzc2luZzpcblxuICAgIEZvciBlYWNoIGNlcnRpZmljYXRlIGluIHRoZSAnY2hhaW4nLCB0aGUgZm9sbG93aW5nIGlzIGNoZWNrZWQ6XG5cbiAgICAxLiBUaGUgY2VydGlmaWNhdGUgdmFsaWRpdHkgcGVyaW9kIGluY2x1ZGVzIHRoZSBjdXJyZW50IHRpbWUuXG4gICAgMi4gVGhlIGNlcnRpZmljYXRlIHdhcyBzaWduZWQgYnkgaXRzIHBhcmVudCAod2hlcmUgdGhlIHBhcmVudCBpcyBlaXRoZXJcbiAgICAgICB0aGUgbmV4dCBpbiB0aGUgY2hhaW4gb3IgZnJvbSB0aGUgQ0Egc3RvcmUpLiBBbGxvdyBwcm9jZXNzaW5nIHRvXG4gICAgICAgY29udGludWUgdG8gdGhlIG5leHQgc3RlcCBpZiBubyBwYXJlbnQgaXMgZm91bmQgYnV0IHRoZSBjZXJ0aWZpY2F0ZSBpc1xuICAgICAgIGluIHRoZSBDQSBzdG9yZS5cbiAgICAzLiBUT0RPOiBUaGUgY2VydGlmaWNhdGUgaGFzIG5vdCBiZWVuIHJldm9rZWQuXG4gICAgNC4gVGhlIGNlcnRpZmljYXRlIGlzc3VlciBuYW1lIG1hdGNoZXMgdGhlIHBhcmVudCdzIHN1YmplY3QgbmFtZS5cbiAgICA1LiBUT0RPOiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgc2VsZi1pc3N1ZWQgYW5kIG5vdCB0aGUgZmluYWwgY2VydGlmaWNhdGVcbiAgICAgICBpbiB0aGUgY2hhaW4sIHNraXAgdGhpcyBzdGVwLCBvdGhlcndpc2UgdmVyaWZ5IHRoYXQgdGhlIHN1YmplY3QgbmFtZVxuICAgICAgIGlzIHdpdGhpbiBvbmUgb2YgdGhlIHBlcm1pdHRlZCBzdWJ0cmVlcyBvZiBYLjUwMCBkaXN0aW5ndWlzaGVkIG5hbWVzXG4gICAgICAgYW5kIHRoYXQgZWFjaCBvZiB0aGUgYWx0ZXJuYXRpdmUgbmFtZXMgaW4gdGhlIHN1YmplY3RBbHROYW1lIGV4dGVuc2lvblxuICAgICAgIChjcml0aWNhbCBvciBub24tY3JpdGljYWwpIGlzIHdpdGhpbiBvbmUgb2YgdGhlIHBlcm1pdHRlZCBzdWJ0cmVlcyBmb3JcbiAgICAgICB0aGF0IG5hbWUgdHlwZS5cbiAgICA2LiBUT0RPOiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgc2VsZi1pc3N1ZWQgYW5kIG5vdCB0aGUgZmluYWwgY2VydGlmaWNhdGVcbiAgICAgICBpbiB0aGUgY2hhaW4sIHNraXAgdGhpcyBzdGVwLCBvdGhlcndpc2UgdmVyaWZ5IHRoYXQgdGhlIHN1YmplY3QgbmFtZVxuICAgICAgIGlzIG5vdCB3aXRoaW4gb25lIG9mIHRoZSBleGNsdWRlZCBzdWJ0cmVlcyBmb3IgWC41MDAgZGlzdGluZ3Vpc2hlZFxuICAgICAgIG5hbWVzIGFuZCBub25lIG9mIHRoZSBzdWJqZWN0QWx0TmFtZSBleHRlbnNpb24gbmFtZXMgYXJlIGV4Y2x1ZGVkIGZvclxuICAgICAgIHRoYXQgbmFtZSB0eXBlLlxuICAgIDcuIFRoZSBvdGhlciBzdGVwcyBpbiB0aGUgYWxnb3JpdGhtIGZvciBiYXNpYyBwYXRoIHByb2Nlc3NpbmcgaW52b2x2ZVxuICAgICAgIGhhbmRsaW5nIHRoZSBwb2xpY3kgZXh0ZW5zaW9uIHdoaWNoIGlzIG5vdCBwcmVzZW50bHkgc3VwcG9ydGVkIGluIHRoaXNcbiAgICAgICBpbXBsZW1lbnRhdGlvbi4gSW5zdGVhZCwgaWYgYSBjcml0aWNhbCBwb2xpY3kgZXh0ZW5zaW9uIGlzIGZvdW5kLCB0aGVcbiAgICAgICBjZXJ0aWZpY2F0ZSBpcyByZWplY3RlZCBhcyBub3Qgc3VwcG9ydGVkLlxuICAgIDguIElmIHRoZSBjZXJ0aWZpY2F0ZSBpcyBub3QgdGhlIGZpcnN0IG9yIGlmIGl0cyB0aGUgb25seSBjZXJ0aWZpY2F0ZSBpblxuICAgICAgIHRoZSBjaGFpbiAoaGF2aW5nIG5vIHBhcmVudCBmcm9tIHRoZSBDQSBzdG9yZSBvciBpcyBzZWxmLXNpZ25lZCkgYW5kIGl0XG4gICAgICAgaGFzIGEgY3JpdGljYWwga2V5IHVzYWdlIGV4dGVuc2lvbiwgdmVyaWZ5IHRoYXQgdGhlIGtleUNlcnRTaWduIGJpdCBpc1xuICAgICAgIHNldC4gSWYgdGhlIGtleSB1c2FnZSBleHRlbnNpb24gZXhpc3RzLCB2ZXJpZnkgdGhhdCB0aGUgYmFzaWNcbiAgICAgICBjb25zdHJhaW50cyBleHRlbnNpb24gZXhpc3RzLiBJZiB0aGUgYmFzaWMgY29uc3RyYWludHMgZXh0ZW5zaW9uIGV4aXN0cyxcbiAgICAgICB2ZXJpZnkgdGhhdCB0aGUgY0EgZmxhZyBpcyBzZXQuIElmIHBhdGhMZW5Db25zdHJhaW50IGlzIHNldCwgZW5zdXJlIHRoYXRcbiAgICAgICB0aGUgbnVtYmVyIG9mIGNlcnRpZmljYXRlcyB0aGF0IHByZWNlZGUgaW4gdGhlIGNoYWluIChjb21lIGVhcmxpZXJcbiAgICAgICBpbiB0aGUgY2hhaW4gYXMgaW1wbGVtZW50ZWQgYmVsb3cpLCBleGNsdWRpbmcgdGhlIHZlcnkgZmlyc3QgaW4gdGhlXG4gICAgICAgY2hhaW4gKHR5cGljYWxseSB0aGUgZW5kLWVudGl0eSBvbmUpLCBpc24ndCBncmVhdGVyIHRoYW4gdGhlXG4gICAgICAgcGF0aExlbkNvbnN0cmFpbnQuIFRoaXMgY29uc3RyYWludCBsaW1pdHMgdGhlIG51bWJlciBvZiBpbnRlcm1lZGlhdGVcbiAgICAgICBDQXMgdGhhdCBtYXkgYXBwZWFyIGJlbG93IGEgQ0EgYmVmb3JlIG9ubHkgZW5kLWVudGl0eSBjZXJ0aWZpY2F0ZXNcbiAgICAgICBtYXkgYmUgaXNzdWVkLiAqL1xuXG4gIC8vIGlmIGEgdmVyaWZ5IGNhbGxiYWNrIGlzIHBhc3NlZCBhcyB0aGUgdGhpcmQgcGFyYW1ldGVyLCBwYWNrYWdlIGl0IHdpdGhpblxuICAvLyB0aGUgb3B0aW9ucyBvYmplY3QuIFRoaXMgaXMgdG8gc3VwcG9ydCBhIGxlZ2FjeSBmdW5jdGlvbiBzaWduYXR1cmUgdGhhdFxuICAvLyBleHBlY3RlZCB0aGUgdmVyaWZ5IGNhbGxiYWNrIGFzIHRoZSB0aGlyZCBwYXJhbWV0ZXIuXG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucyA9IHt2ZXJpZnk6IG9wdGlvbnN9O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIGNvcHkgY2VydCBjaGFpbiByZWZlcmVuY2VzIHRvIGFub3RoZXIgYXJyYXkgdG8gcHJvdGVjdCBhZ2FpbnN0IGNoYW5nZXNcbiAgLy8gaW4gdmVyaWZ5IGNhbGxiYWNrXG4gIGNoYWluID0gY2hhaW4uc2xpY2UoMCk7XG4gIHZhciBjZXJ0cyA9IGNoYWluLnNsaWNlKDApO1xuXG4gIHZhciB2YWxpZGl0eUNoZWNrRGF0ZSA9IG9wdGlvbnMudmFsaWRpdHlDaGVja0RhdGU7XG4gIC8vIGlmIG5vIHZhbGlkaXR5Q2hlY2tEYXRlIGlzIHNwZWNpZmllZCwgZGVmYXVsdCB0byB0aGUgY3VycmVudCBkYXRlLiBNYWtlXG4gIC8vIHN1cmUgdG8gbWFpbnRhaW4gdGhlIHZhbHVlIG51bGwgYmVjYXVzZSBpdCBpbmRpY2F0ZXMgdGhhdCB0aGUgdmFsaWRpdHlcbiAgLy8gcGVyaW9kIHNob3VsZCBub3QgYmUgY2hlY2tlZC5cbiAgaWYodHlwZW9mIHZhbGlkaXR5Q2hlY2tEYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhbGlkaXR5Q2hlY2tEYXRlID0gbmV3IERhdGUoKTtcbiAgfVxuXG4gIC8vIHZlcmlmeSBlYWNoIGNlcnQgaW4gdGhlIGNoYWluIHVzaW5nIGl0cyBwYXJlbnQsIHdoZXJlIHRoZSBwYXJlbnRcbiAgLy8gaXMgZWl0aGVyIHRoZSBuZXh0IGluIHRoZSBjaGFpbiBvciBmcm9tIHRoZSBDQSBzdG9yZVxuICB2YXIgZmlyc3QgPSB0cnVlO1xuICB2YXIgZXJyb3IgPSBudWxsO1xuICB2YXIgZGVwdGggPSAwO1xuICBkbyB7XG4gICAgdmFyIGNlcnQgPSBjaGFpbi5zaGlmdCgpO1xuICAgIHZhciBwYXJlbnQgPSBudWxsO1xuICAgIHZhciBzZWxmU2lnbmVkID0gZmFsc2U7XG5cbiAgICBpZih2YWxpZGl0eUNoZWNrRGF0ZSkge1xuICAgICAgLy8gMS4gY2hlY2sgdmFsaWQgdGltZVxuICAgICAgaWYodmFsaWRpdHlDaGVja0RhdGUgPCBjZXJ0LnZhbGlkaXR5Lm5vdEJlZm9yZSB8fFxuICAgICAgICAgdmFsaWRpdHlDaGVja0RhdGUgPiBjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyKSB7XG4gICAgICAgIGVycm9yID0ge1xuICAgICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBpcyBub3QgdmFsaWQgeWV0IG9yIGhhcyBleHBpcmVkLicsXG4gICAgICAgICAgZXJyb3I6IHBraS5jZXJ0aWZpY2F0ZUVycm9yLmNlcnRpZmljYXRlX2V4cGlyZWQsXG4gICAgICAgICAgbm90QmVmb3JlOiBjZXJ0LnZhbGlkaXR5Lm5vdEJlZm9yZSxcbiAgICAgICAgICBub3RBZnRlcjogY2VydC52YWxpZGl0eS5ub3RBZnRlcixcbiAgICAgICAgICAvLyBUT0RPOiB3ZSBtaWdodCB3YW50IHRvIHJlY29uc2lkZXIgcmVuYW1pbmcgJ25vdycgdG9cbiAgICAgICAgICAvLyAndmFsaWRpdHlDaGVja0RhdGUnIHNob3VsZCB0aGlzIEFQSSBiZSBjaGFuZ2VkIGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgbm93OiB2YWxpZGl0eUNoZWNrRGF0ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDIuIHZlcmlmeSB3aXRoIHBhcmVudCBmcm9tIGNoYWluIG9yIENBIHN0b3JlXG4gICAgaWYoZXJyb3IgPT09IG51bGwpIHtcbiAgICAgIHBhcmVudCA9IGNoYWluWzBdIHx8IGNhU3RvcmUuZ2V0SXNzdWVyKGNlcnQpO1xuICAgICAgaWYocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBzZWxmLXNpZ25lZCBjZXJ0XG4gICAgICAgIGlmKGNlcnQuaXNJc3N1ZXIoY2VydCkpIHtcbiAgICAgICAgICBzZWxmU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICBwYXJlbnQgPSBjZXJ0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKHBhcmVudCkge1xuICAgICAgICAvLyBGSVhNRTogY3VycmVudCBDQSBzdG9yZSBpbXBsZW1lbnRhdGlvbiBtaWdodCBoYXZlIG11bHRpcGxlXG4gICAgICAgIC8vIGNlcnRpZmljYXRlcyB3aGVyZSB0aGUgaXNzdWVyIGNhbid0IGJlIGRldGVybWluZWQgZnJvbSB0aGVcbiAgICAgICAgLy8gY2VydGlmaWNhdGUgKGhhcHBlbnMgcmFyZWx5IHdpdGgsIGVnOiBvbGQgY2VydGlmaWNhdGVzKSBzbyBub3JtYWxpemVcbiAgICAgICAgLy8gYnkgYWx3YXlzIHB1dHRpbmcgcGFyZW50cyBpbnRvIGFuIGFycmF5XG4gICAgICAgIC8vIFRPRE86IHRoZXJlJ3MgbWF5IGJlIGFuIGV4dHJlbWUgZGVnZW5lcmF0ZSBjYXNlIGN1cnJlbnRseSB1bmNvdmVyZWRcbiAgICAgICAgLy8gd2hlcmUgYW4gb2xkIGludGVybWVkaWF0ZSBjZXJ0aWZpY2F0ZSBzZWVtcyB0byBoYXZlIGEgbWF0Y2hpbmcgcGFyZW50XG4gICAgICAgIC8vIGJ1dCBub25lIG9mIHRoZSBwYXJlbnRzIGFjdHVhbGx5IHZlcmlmeSAuLi4gYnV0IHRoZSBpbnRlcm1lZGlhdGVcbiAgICAgICAgLy8gaXMgaW4gdGhlIENBIGFuZCBpdCBzaG91bGQgcGFzcyB0aGlzIGNoZWNrOyBuZWVkcyBpbnZlc3RpZ2F0aW9uXG4gICAgICAgIHZhciBwYXJlbnRzID0gcGFyZW50O1xuICAgICAgICBpZighZm9yZ2UudXRpbC5pc0FycmF5KHBhcmVudHMpKSB7XG4gICAgICAgICAgcGFyZW50cyA9IFtwYXJlbnRzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSB0byB2ZXJpZnkgd2l0aCBlYWNoIHBvc3NpYmxlIHBhcmVudCAodHlwaWNhbGx5IG9ubHkgb25lKVxuICAgICAgICB2YXIgdmVyaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUoIXZlcmlmaWVkICYmIHBhcmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBhcmVudCA9IHBhcmVudHMuc2hpZnQoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmVyaWZpZWQgPSBwYXJlbnQudmVyaWZ5KGNlcnQpO1xuICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgIC8vIGZhaWx1cmUgdG8gdmVyaWZ5LCBkb24ndCBjYXJlIHdoeSwgdHJ5IG5leHQgb25lXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXZlcmlmaWVkKSB7XG4gICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOiAnQ2VydGlmaWNhdGUgc2lnbmF0dXJlIGlzIGludmFsaWQuJyxcbiAgICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKGVycm9yID09PSBudWxsICYmICghcGFyZW50IHx8IHNlbGZTaWduZWQpICYmXG4gICAgICAgICFjYVN0b3JlLmhhc0NlcnRpZmljYXRlKGNlcnQpKSB7XG4gICAgICAgIC8vIG5vIHBhcmVudCBpc3N1ZXIgYW5kIGNlcnRpZmljYXRlIGl0c2VsZiBpcyBub3QgdHJ1c3RlZFxuICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICBtZXNzYWdlOiAnQ2VydGlmaWNhdGUgaXMgbm90IHRydXN0ZWQuJyxcbiAgICAgICAgICBlcnJvcjogcGtpLmNlcnRpZmljYXRlRXJyb3IudW5rbm93bl9jYVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IDMuIGNoZWNrIHJldm9rZWRcblxuICAgIC8vIDQuIGNoZWNrIGZvciBtYXRjaGluZyBpc3N1ZXIvc3ViamVjdFxuICAgIGlmKGVycm9yID09PSBudWxsICYmIHBhcmVudCAmJiAhY2VydC5pc0lzc3VlcihwYXJlbnQpKSB7XG4gICAgICAvLyBwYXJlbnQgaXMgbm90IGlzc3VlclxuICAgICAgZXJyb3IgPSB7XG4gICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBpc3N1ZXIgaXMgaW52YWxpZC4nLFxuICAgICAgICBlcnJvcjogcGtpLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIDUuIFRPRE86IGNoZWNrIG5hbWVzIHdpdGggcGVybWl0dGVkIG5hbWVzIHRyZWVcblxuICAgIC8vIDYuIFRPRE86IGNoZWNrIG5hbWVzIGFnYWluc3QgZXhjbHVkZWQgbmFtZXMgdHJlZVxuXG4gICAgLy8gNy4gY2hlY2sgZm9yIHVuc3VwcG9ydGVkIGNyaXRpY2FsIGV4dGVuc2lvbnNcbiAgICBpZihlcnJvciA9PT0gbnVsbCkge1xuICAgICAgLy8gc3VwcG9ydGVkIGV4dGVuc2lvbnNcbiAgICAgIHZhciBzZSA9IHtcbiAgICAgICAga2V5VXNhZ2U6IHRydWUsXG4gICAgICAgIGJhc2ljQ29uc3RyYWludHM6IHRydWVcbiAgICAgIH07XG4gICAgICBmb3IodmFyIGkgPSAwOyBlcnJvciA9PT0gbnVsbCAmJiBpIDwgY2VydC5leHRlbnNpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBleHQgPSBjZXJ0LmV4dGVuc2lvbnNbaV07XG4gICAgICAgIGlmKGV4dC5jcml0aWNhbCAmJiAhKGV4dC5uYW1lIGluIHNlKSkge1xuICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgJ0NlcnRpZmljYXRlIGhhcyBhbiB1bnN1cHBvcnRlZCBjcml0aWNhbCBleHRlbnNpb24uJyxcbiAgICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci51bnN1cHBvcnRlZF9jZXJ0aWZpY2F0ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA4LiBjaGVjayBmb3IgQ0EgaWYgY2VydCBpcyBub3QgZmlyc3Qgb3IgaXMgdGhlIG9ubHkgY2VydGlmaWNhdGVcbiAgICAvLyByZW1haW5pbmcgaW4gY2hhaW4gd2l0aCBubyBwYXJlbnQgb3IgaXMgc2VsZi1zaWduZWRcbiAgICBpZihlcnJvciA9PT0gbnVsbCAmJlxuICAgICAgKCFmaXJzdCB8fCAoY2hhaW4ubGVuZ3RoID09PSAwICYmICghcGFyZW50IHx8IHNlbGZTaWduZWQpKSkpIHtcbiAgICAgIC8vIGZpcnN0IGNoZWNrIGtleVVzYWdlIGV4dGVuc2lvbiBhbmQgdGhlbiBiYXNpYyBjb25zdHJhaW50c1xuICAgICAgdmFyIGJjRXh0ID0gY2VydC5nZXRFeHRlbnNpb24oJ2Jhc2ljQ29uc3RyYWludHMnKTtcbiAgICAgIHZhciBrZXlVc2FnZUV4dCA9IGNlcnQuZ2V0RXh0ZW5zaW9uKCdrZXlVc2FnZScpO1xuICAgICAgaWYoa2V5VXNhZ2VFeHQgIT09IG51bGwpIHtcbiAgICAgICAgLy8ga2V5Q2VydFNpZ24gbXVzdCBiZSB0cnVlIGFuZCB0aGVyZSBtdXN0IGJlIGEgYmFzaWNcbiAgICAgICAgLy8gY29uc3RyYWludHMgZXh0ZW5zaW9uXG4gICAgICAgIGlmKCFrZXlVc2FnZUV4dC5rZXlDZXJ0U2lnbiB8fCBiY0V4dCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIGJhZCBjZXJ0aWZpY2F0ZVxuICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgJ0NlcnRpZmljYXRlIGtleVVzYWdlIG9yIGJhc2ljQ29uc3RyYWludHMgY29uZmxpY3QgJyArXG4gICAgICAgICAgICAgICdvciBpbmRpY2F0ZSB0aGF0IHRoZSBjZXJ0aWZpY2F0ZSBpcyBub3QgYSBDQS4gJyArXG4gICAgICAgICAgICAgICdJZiB0aGUgY2VydGlmaWNhdGUgaXMgdGhlIG9ubHkgb25lIGluIHRoZSBjaGFpbiBvciAnICtcbiAgICAgICAgICAgICAgJ2lzblxcJ3QgdGhlIGZpcnN0IHRoZW4gdGhlIGNlcnRpZmljYXRlIG11c3QgYmUgYSAnICtcbiAgICAgICAgICAgICAgJ3ZhbGlkIENBLicsXG4gICAgICAgICAgICBlcnJvcjogcGtpLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gYmFzaWMgY29uc3RyYWludHMgY0EgZmxhZyBtdXN0IGJlIHNldFxuICAgICAgaWYoZXJyb3IgPT09IG51bGwgJiYgYmNFeHQgIT09IG51bGwgJiYgIWJjRXh0LmNBKSB7XG4gICAgICAgIC8vIGJhZCBjZXJ0aWZpY2F0ZVxuICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgJ0NlcnRpZmljYXRlIGJhc2ljQ29uc3RyYWludHMgaW5kaWNhdGVzIHRoZSBjZXJ0aWZpY2F0ZSAnICtcbiAgICAgICAgICAgICdpcyBub3QgYSBDQS4nLFxuICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIGVycm9yIGlzIG5vdCBudWxsIGFuZCBrZXlVc2FnZSBpcyBhdmFpbGFibGUsIHRoZW4gd2Uga25vdyBpdFxuICAgICAgLy8gaGFzIGtleUNlcnRTaWduIGFuZCB0aGVyZSBpcyBhIGJhc2ljIGNvbnN0cmFpbnRzIGV4dGVuc2lvbiB0b28sXG4gICAgICAvLyB3aGljaCBtZWFucyB3ZSBjYW4gY2hlY2sgcGF0aExlbkNvbnN0cmFpbnQgKGlmIGl0IGV4aXN0cylcbiAgICAgIGlmKGVycm9yID09PSBudWxsICYmIGtleVVzYWdlRXh0ICE9PSBudWxsICYmXG4gICAgICAgICdwYXRoTGVuQ29uc3RyYWludCcgaW4gYmNFeHQpIHtcbiAgICAgICAgLy8gcGF0aExlbiBpcyB0aGUgbWF4aW11bSAjIG9mIGludGVybWVkaWF0ZSBDQSBjZXJ0cyB0aGF0IGNhbiBiZVxuICAgICAgICAvLyBmb3VuZCBiZXR3ZWVuIHRoZSBjdXJyZW50IGNlcnRpZmljYXRlIGFuZCB0aGUgZW5kLWVudGl0eSAoZGVwdGggMClcbiAgICAgICAgLy8gY2VydGlmaWNhdGU7IHRoaXMgbnVtYmVyIGRvZXMgbm90IGluY2x1ZGUgdGhlIGVuZC1lbnRpdHkgKGRlcHRoIDAsXG4gICAgICAgIC8vIGxhc3QgaW4gdGhlIGNoYWluKSBldmVuIGlmIGl0IGhhcHBlbnMgdG8gYmUgYSBDQSBjZXJ0aWZpY2F0ZSBpdHNlbGZcbiAgICAgICAgdmFyIHBhdGhMZW4gPSBkZXB0aCAtIDE7XG4gICAgICAgIGlmKHBhdGhMZW4gPiBiY0V4dC5wYXRoTGVuQ29uc3RyYWludCkge1xuICAgICAgICAgIC8vIHBhdGhMZW5Db25zdHJhaW50IHZpb2xhdGVkLCBiYWQgY2VydGlmaWNhdGVcbiAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICdDZXJ0aWZpY2F0ZSBiYXNpY0NvbnN0cmFpbnRzIHBhdGhMZW5Db25zdHJhaW50IHZpb2xhdGVkLicsXG4gICAgICAgICAgICBlcnJvcjogcGtpLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGwgYXBwbGljYXRpb24gY2FsbGJhY2tcbiAgICB2YXIgdmZkID0gKGVycm9yID09PSBudWxsKSA/IHRydWUgOiBlcnJvci5lcnJvcjtcbiAgICB2YXIgcmV0ID0gb3B0aW9ucy52ZXJpZnkgPyBvcHRpb25zLnZlcmlmeSh2ZmQsIGRlcHRoLCBjZXJ0cykgOiB2ZmQ7XG4gICAgaWYocmV0ID09PSB0cnVlKSB7XG4gICAgICAvLyBjbGVhciBhbnkgc2V0IGVycm9yXG4gICAgICBlcnJvciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHBhc3NlZCBiYXNpYyB0ZXN0cywgc2V0IGRlZmF1bHQgbWVzc2FnZSBhbmQgYWxlcnRcbiAgICAgIGlmKHZmZCA9PT0gdHJ1ZSkge1xuICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICBtZXNzYWdlOiAnVGhlIGFwcGxpY2F0aW9uIHJlamVjdGVkIHRoZSBjZXJ0aWZpY2F0ZS4nLFxuICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgZm9yIGN1c3RvbSBlcnJvciBpbmZvXG4gICAgICBpZihyZXQgfHwgcmV0ID09PSAwKSB7XG4gICAgICAgIC8vIHNldCBjdXN0b20gbWVzc2FnZSBhbmQgZXJyb3JcbiAgICAgICAgaWYodHlwZW9mIHJldCA9PT0gJ29iamVjdCcgJiYgIWZvcmdlLnV0aWwuaXNBcnJheShyZXQpKSB7XG4gICAgICAgICAgaWYocmV0Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSByZXQubWVzc2FnZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmV0LmVycm9yKSB7XG4gICAgICAgICAgICBlcnJvci5lcnJvciA9IHJldC5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZih0eXBlb2YgcmV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIHNldCBjdXN0b20gZXJyb3JcbiAgICAgICAgICBlcnJvci5lcnJvciA9IHJldDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0aHJvdyBlcnJvclxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gbm8gbG9uZ2VyIGZpcnN0IGNlcnQgaW4gY2hhaW5cbiAgICBmaXJzdCA9IGZhbHNlO1xuICAgICsrZGVwdGg7XG4gIH0gd2hpbGUoY2hhaW4ubGVuZ3RoID4gMCk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIl0sIm5hbWVzIjpbImZvcmdlIiwicmVxdWlyZSIsImFzbjEiLCJwa2kiLCJtb2R1bGUiLCJleHBvcnRzIiwib2lkcyIsIl9zaG9ydE5hbWVzIiwicHVibGljS2V5VmFsaWRhdG9yIiwicnNhIiwieDUwOUNlcnRpZmljYXRlVmFsaWRhdG9yIiwibmFtZSIsInRhZ0NsYXNzIiwiQ2xhc3MiLCJVTklWRVJTQUwiLCJ0eXBlIiwiVHlwZSIsIlNFUVVFTkNFIiwiY29uc3RydWN0ZWQiLCJ2YWx1ZSIsImNhcHR1cmVBc24xIiwiQ09OVEVYVF9TUEVDSUZJQyIsIm9wdGlvbmFsIiwiSU5URUdFUiIsImNhcHR1cmUiLCJPSUQiLCJVVENUSU1FIiwiR0VORVJBTElaRURUSU1FIiwiQklUU1RSSU5HIiwiY2FwdHVyZUJpdFN0cmluZ1ZhbHVlIiwicnNhc3NhUHNzUGFyYW1ldGVyVmFsaWRhdG9yIiwiY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvVmFsaWRhdG9yIiwiU0VUIiwiY2VydGlmaWNhdGlvblJlcXVlc3RWYWxpZGF0b3IiLCJSRE5BdHRyaWJ1dGVzQXNBcnJheSIsInJkbiIsIm1kIiwicnZhbCIsInNldCIsImF0dHIiLCJvYmoiLCJzaSIsImxlbmd0aCIsImkiLCJkZXJUb09pZCIsInZhbHVlVGFnQ2xhc3MiLCJzaG9ydE5hbWUiLCJ1cGRhdGUiLCJwdXNoIiwiQ1JJQXR0cmlidXRlc0FzQXJyYXkiLCJhdHRyaWJ1dGVzIiwic2VxIiwidmFsdWVzIiwidmkiLCJleHRlbnNpb25SZXF1ZXN0IiwiZXh0ZW5zaW9ucyIsImVpIiwiY2VydGlmaWNhdGVFeHRlbnNpb25Gcm9tQXNuMSIsIl9nZXRBdHRyaWJ1dGUiLCJvcHRpb25zIiwiX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzIiwib2lkIiwiZmlsbERlZmF1bHRzIiwicGFyYW1zIiwiaGFzaCIsImFsZ29yaXRobU9pZCIsIm1nZiIsInNhbHRMZW5ndGgiLCJlcnJvcnMiLCJ2YWxpZGF0ZSIsImVycm9yIiwiRXJyb3IiLCJoYXNoT2lkIiwidW5kZWZpbmVkIiwibWFza0dlbk9pZCIsIm1hc2tHZW5IYXNoT2lkIiwiY2hhckNvZGVBdCIsIl9jcmVhdGVTaWduYXR1cmVEaWdlc3QiLCJzaWduYXR1cmVPaWQiLCJzaGExIiwiY3JlYXRlIiwibWQ1Iiwic2hhMjU2Iiwic2hhMzg0Iiwic2hhNTEyIiwiX3ZlcmlmeVNpZ25hdHVyZSIsImNlcnQiLCJjZXJ0aWZpY2F0ZSIsInNjaGVtZSIsInNoYTFXaXRoUlNBRW5jcnlwdGlvbiIsInNoYTFXaXRoUlNBU2lnbmF0dXJlIiwic2lnbmF0dXJlUGFyYW1ldGVycyIsInBzcyIsInB1YmxpY0tleSIsInZlcmlmeSIsImRpZ2VzdCIsImdldEJ5dGVzIiwic2lnbmF0dXJlIiwiY2VydGlmaWNhdGVGcm9tUGVtIiwicGVtIiwiY29tcHV0ZUhhc2giLCJzdHJpY3QiLCJtc2ciLCJkZWNvZGUiLCJoZWFkZXJUeXBlIiwicHJvY1R5cGUiLCJmcm9tRGVyIiwiYm9keSIsImNlcnRpZmljYXRlRnJvbUFzbjEiLCJjZXJ0aWZpY2F0ZVRvUGVtIiwibWF4bGluZSIsInRvRGVyIiwiY2VydGlmaWNhdGVUb0FzbjEiLCJlbmNvZGUiLCJwdWJsaWNLZXlGcm9tUGVtIiwicHVibGljS2V5RnJvbUFzbjEiLCJwdWJsaWNLZXlUb1BlbSIsImtleSIsInB1YmxpY0tleVRvQXNuMSIsInB1YmxpY0tleVRvUlNBUHVibGljS2V5UGVtIiwicHVibGljS2V5VG9SU0FQdWJsaWNLZXkiLCJnZXRQdWJsaWNLZXlGaW5nZXJwcmludCIsImJ5dGVzIiwic3RhcnQiLCJlbmNvZGluZyIsImhleCIsInRvSGV4IiwiZGVsaW1pdGVyIiwibWF0Y2giLCJqb2luIiwiY2VydGlmaWNhdGlvblJlcXVlc3RGcm9tUGVtIiwiY2VydGlmaWNhdGlvblJlcXVlc3RGcm9tQXNuMSIsImNlcnRpZmljYXRpb25SZXF1ZXN0VG9QZW0iLCJjc3IiLCJjZXJ0aWZpY2F0aW9uUmVxdWVzdFRvQXNuMSIsImNyZWF0ZUNlcnRpZmljYXRlIiwidmVyc2lvbiIsInNlcmlhbE51bWJlciIsInNpZ2luZm8iLCJ2YWxpZGl0eSIsIm5vdEJlZm9yZSIsIkRhdGUiLCJub3RBZnRlciIsImlzc3VlciIsImdldEZpZWxkIiwic24iLCJhZGRGaWVsZCIsIl9maWxsTWlzc2luZ0ZpZWxkcyIsInN1YmplY3QiLCJzZXRTdWJqZWN0IiwiYXR0cnMiLCJ1bmlxdWVJZCIsInNldElzc3VlciIsInNldEV4dGVuc2lvbnMiLCJleHRzIiwiX2ZpbGxNaXNzaW5nRXh0ZW5zaW9uRmllbGRzIiwiZ2V0RXh0ZW5zaW9uIiwiZXh0IiwiaWQiLCJzaWduIiwiYWxnb3JpdGhtIiwidGJzQ2VydGlmaWNhdGUiLCJnZXRUQlNDZXJ0aWZpY2F0ZSIsImNoaWxkIiwiaXNzdWVkIiwiZXhwZWN0ZWRJc3N1ZXIiLCJhY3R1YWxJc3N1ZXIiLCJpc0lzc3VlciIsInBhcmVudCIsInMiLCJpYXR0ciIsInNhdHRyIiwibiIsImdlbmVyYXRlU3ViamVjdEtleUlkZW50aWZpZXIiLCJ2ZXJpZnlTdWJqZWN0S2V5SWRlbnRpZmllciIsInNraSIsInV0aWwiLCJoZXhUb0J5dGVzIiwic3ViamVjdEtleUlkZW50aWZpZXIiLCJwdWJsaWNLZXlPaWQiLCJyc2FFbmNyeXB0aW9uIiwiY2VydFZlcnNpb24iLCJzZXJpYWwiLCJjcmVhdGVCdWZmZXIiLCJjZXJ0U2VyaWFsTnVtYmVyIiwiY2VydFNpZ25hdHVyZU9pZCIsImNlcnRTaWduYXR1cmVQYXJhbXMiLCJjZXJ0aW5mb1NpZ25hdHVyZU9pZCIsInBhcmFtZXRlcnMiLCJjZXJ0aW5mb1NpZ25hdHVyZVBhcmFtcyIsImNlcnRTaWduYXR1cmUiLCJjZXJ0VmFsaWRpdHkxVVRDVGltZSIsInV0Y1RpbWVUb0RhdGUiLCJjZXJ0VmFsaWRpdHkyR2VuZXJhbGl6ZWRUaW1lIiwiZ2VuZXJhbGl6ZWRUaW1lVG9EYXRlIiwiY2VydFZhbGlkaXR5M1VUQ1RpbWUiLCJjZXJ0VmFsaWRpdHk0R2VuZXJhbGl6ZWRUaW1lIiwiaW1kIiwiaWJ5dGVzIiwiY2VydElzc3VlciIsImNlcnRJc3N1ZXJVbmlxdWVJZCIsInNtZCIsInNieXRlcyIsImNlcnRTdWJqZWN0IiwiY2VydFN1YmplY3RVbmlxdWVJZCIsImNlcnRFeHRlbnNpb25zIiwiY2VydGlmaWNhdGVFeHRlbnNpb25zRnJvbUFzbjEiLCJzdWJqZWN0UHVibGljS2V5SW5mbyIsImV4dHNlcSIsImUiLCJjcml0aWNhbCIsIkJPT0xFQU4iLCJldiIsImIyIiwiYjMiLCJkaWdpdGFsU2lnbmF0dXJlIiwibm9uUmVwdWRpYXRpb24iLCJrZXlFbmNpcGhlcm1lbnQiLCJkYXRhRW5jaXBoZXJtZW50Iiwia2V5QWdyZWVtZW50Iiwia2V5Q2VydFNpZ24iLCJjUkxTaWduIiwiZW5jaXBoZXJPbmx5IiwiZGVjaXBoZXJPbmx5IiwiY0EiLCJwYXRoTGVuQ29uc3RyYWludCIsImRlclRvSW50ZWdlciIsImNsaWVudCIsInNlcnZlciIsImVtYWlsIiwib2Jqc2lnbiIsInJlc2VydmVkIiwic3NsQ0EiLCJlbWFpbENBIiwib2JqQ0EiLCJhbHROYW1lcyIsImduIiwiYWx0TmFtZSIsImlwIiwiYnl0ZXNUb0lQIiwiYnl0ZXNUb0hleCIsImNyZWF0ZUNlcnRpZmljYXRpb25SZXF1ZXN0IiwiY3NyVmVyc2lvbiIsImNzclNpZ25hdHVyZU9pZCIsImNzclNpZ25hdHVyZVBhcmFtcyIsImNzclNpZ25hdHVyZSIsImNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyIsImNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb1N1YmplY3QiLCJnZXRBdHRyaWJ1dGUiLCJhZGRBdHRyaWJ1dGUiLCJjZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9BdHRyaWJ1dGVzIiwic2V0QXR0cmlidXRlcyIsImdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyIsImNyaSIsIl9kblRvQXNuMSIsIlBSSU5UQUJMRVNUUklORyIsIlVURjgiLCJlbmNvZGVVdGY4Iiwib2lkVG9EZXIiLCJfZ2V0QXR0cmlidXRlc0FzSnNvbiIsIklBNVNUUklORyIsImlzQXJyYXkiLCJhdHRyaWJ1dGUiLCJ2YWx1ZUNvbnN0cnVjdGVkIiwiY2VydGlmaWNhdGVFeHRlbnNpb25Ub0FzbjEiLCJleHRlbnNpb24iLCJ1bnVzZWQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJpbnRlZ2VyVG9EZXIiLCJpbmRleE9mIiwiYnl0ZXNGcm9tSVAiLCJ0ZXN0IiwiY29tbWVudCIsIk9DVEVUU1RSSU5HIiwia2V5SWRlbnRpZmllciIsImF1dGhvcml0eUNlcnRJc3N1ZXIiLCJzdWJTZXEiLCJmdWxsTmFtZUdlbmVyYWxOYW1lcyIsIl9zaWduYXR1cmVQYXJhbWV0ZXJzVG9Bc24xIiwicGFydHMiLCJOVUxMIiwiX0NSSUF0dHJpYnV0ZXNUb0FzbjEiLCJqYW5fMV8xOTUwIiwiamFuXzFfMjA1MCIsIl9kYXRlVG9Bc24xIiwiZGF0ZSIsImRhdGVUb1V0Y1RpbWUiLCJkYXRlVG9HZW5lcmFsaXplZFRpbWUiLCJ0YnMiLCJjZXJ0aWZpY2F0ZUV4dGVuc2lvbnNUb0FzbjEiLCJkaXN0aW5ndWlzaGVkTmFtZVRvQXNuMSIsImRuIiwiY3JlYXRlQ2FTdG9yZSIsImNlcnRzIiwiY2FTdG9yZSIsImdldElzc3VlciIsImdldEJ5U3ViamVjdCIsImFkZENlcnRpZmljYXRlIiwiZW5zdXJlU3ViamVjdEhhc0hhc2giLCJoYXNDZXJ0aWZpY2F0ZSIsInRtcCIsImRlcjEiLCJkZXIyIiwibGlzdEFsbENlcnRpZmljYXRlcyIsImNlcnRMaXN0IiwiaGFzT3duUHJvcGVydHkiLCJyZW1vdmVDZXJ0aWZpY2F0ZSIsInJlc3VsdCIsInNwbGljZSIsImNlcnRpZmljYXRlRXJyb3IiLCJiYWRfY2VydGlmaWNhdGUiLCJ1bnN1cHBvcnRlZF9jZXJ0aWZpY2F0ZSIsImNlcnRpZmljYXRlX3Jldm9rZWQiLCJjZXJ0aWZpY2F0ZV9leHBpcmVkIiwiY2VydGlmaWNhdGVfdW5rbm93biIsInVua25vd25fY2EiLCJ2ZXJpZnlDZXJ0aWZpY2F0ZUNoYWluIiwiY2hhaW4iLCJzbGljZSIsInZhbGlkaXR5Q2hlY2tEYXRlIiwiZmlyc3QiLCJkZXB0aCIsInNoaWZ0Iiwic2VsZlNpZ25lZCIsIm1lc3NhZ2UiLCJub3ciLCJwYXJlbnRzIiwidmVyaWZpZWQiLCJleCIsInNlIiwia2V5VXNhZ2UiLCJiYXNpY0NvbnN0cmFpbnRzIiwiYmNFeHQiLCJrZXlVc2FnZUV4dCIsInBhdGhMZW4iLCJ2ZmQiLCJyZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-forge/lib/x509.js\n");

/***/ })

};
;