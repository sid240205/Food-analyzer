"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/google-auth-library";
exports.ids = ["vendor-chunks/google-auth-library"];
exports.modules = {

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js":
/*!***********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/authclient.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2012 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AuthClient = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst transporters_1 = __webpack_require__(/*! ../transporters */ \"(rsc)/./node_modules/google-auth-library/build/src/transporters.js\");\nclass AuthClient extends events_1.EventEmitter {\n    constructor(){\n        super(...arguments);\n        this.transporter = new transporters_1.DefaultTransporter();\n        this.credentials = {};\n        this.eagerRefreshThresholdMillis = 5 * 60 * 1000;\n        this.forceRefreshOnFailure = false;\n    }\n    /**\n     * Sets the auth credentials.\n     */ setCredentials(credentials) {\n        this.credentials = credentials;\n    }\n    /**\n     * Append additional headers, e.g., x-goog-user-project, shared across the\n     * classes inheriting AuthClient. This method should be used by any method\n     * that overrides getRequestMetadataAsync(), which is a shared helper for\n     * setting request information in both gRPC and HTTP API calls.\n     *\n     * @param headers object to append additional headers to.\n     */ addSharedMetadataHeaders(headers) {\n        // quota_project_id, stored in application_default_credentials.json, is set in\n        // the x-goog-user-project header, to indicate an alternate account for\n        // billing and quota:\n        if (!headers[\"x-goog-user-project\"] && // don't override a value the user sets.\n        this.quotaProjectId) {\n            headers[\"x-goog-user-project\"] = this.quotaProjectId;\n        }\n        return headers;\n    }\n}\nexports.AuthClient = AuthClient; //# sourceMappingURL=authclient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9hdXRoY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0JBQWtCLEdBQUcsS0FBSztBQUMxQixNQUFNRyxXQUFXQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNQyxpQkFBaUJELG1CQUFPQSxDQUFDLDJGQUFpQjtBQUNoRCxNQUFNRixtQkFBbUJDLFNBQVNHLFlBQVk7SUFDMUNDLGFBQWM7UUFDVixLQUFLLElBQUlDO1FBQ1QsSUFBSSxDQUFDQyxXQUFXLEdBQUcsSUFBSUosZUFBZUssa0JBQWtCO1FBQ3hELElBQUksQ0FBQ0MsV0FBVyxHQUFHLENBQUM7UUFDcEIsSUFBSSxDQUFDQywyQkFBMkIsR0FBRyxJQUFJLEtBQUs7UUFDNUMsSUFBSSxDQUFDQyxxQkFBcUIsR0FBRztJQUNqQztJQUNBOztLQUVDLEdBQ0RDLGVBQWVILFdBQVcsRUFBRTtRQUN4QixJQUFJLENBQUNBLFdBQVcsR0FBR0E7SUFDdkI7SUFDQTs7Ozs7OztLQU9DLEdBQ0RJLHlCQUF5QkMsT0FBTyxFQUFFO1FBQzlCLDhFQUE4RTtRQUM5RSx1RUFBdUU7UUFDdkUscUJBQXFCO1FBQ3JCLElBQUksQ0FBQ0EsT0FBTyxDQUFDLHNCQUFzQixJQUFJLHdDQUF3QztRQUMzRSxJQUFJLENBQUNDLGNBQWMsRUFBRTtZQUNyQkQsT0FBTyxDQUFDLHNCQUFzQixHQUFHLElBQUksQ0FBQ0MsY0FBYztRQUN4RDtRQUNBLE9BQU9EO0lBQ1g7QUFDSjtBQUNBaEIsa0JBQWtCLEdBQUdFLFlBQ3JCLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2F1dGhjbGllbnQuanM/M2NlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDEyIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BdXRoQ2xpZW50ID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgdHJhbnNwb3J0ZXJzXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNwb3J0ZXJzXCIpO1xuY2xhc3MgQXV0aENsaWVudCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ZXIgPSBuZXcgdHJhbnNwb3J0ZXJzXzEuRGVmYXVsdFRyYW5zcG9ydGVyKCk7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSB7fTtcbiAgICAgICAgdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgPSA1ICogNjAgKiAxMDAwO1xuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhdXRoIGNyZWRlbnRpYWxzLlxuICAgICAqL1xuICAgIHNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwZW5kIGFkZGl0aW9uYWwgaGVhZGVycywgZS5nLiwgeC1nb29nLXVzZXItcHJvamVjdCwgc2hhcmVkIGFjcm9zcyB0aGVcbiAgICAgKiBjbGFzc2VzIGluaGVyaXRpbmcgQXV0aENsaWVudC4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgYnkgYW55IG1ldGhvZFxuICAgICAqIHRoYXQgb3ZlcnJpZGVzIGdldFJlcXVlc3RNZXRhZGF0YUFzeW5jKCksIHdoaWNoIGlzIGEgc2hhcmVkIGhlbHBlciBmb3JcbiAgICAgKiBzZXR0aW5nIHJlcXVlc3QgaW5mb3JtYXRpb24gaW4gYm90aCBnUlBDIGFuZCBIVFRQIEFQSSBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBoZWFkZXJzIG9iamVjdCB0byBhcHBlbmQgYWRkaXRpb25hbCBoZWFkZXJzIHRvLlxuICAgICAqL1xuICAgIGFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIC8vIHF1b3RhX3Byb2plY3RfaWQsIHN0b3JlZCBpbiBhcHBsaWNhdGlvbl9kZWZhdWx0X2NyZWRlbnRpYWxzLmpzb24sIGlzIHNldCBpblxuICAgICAgICAvLyB0aGUgeC1nb29nLXVzZXItcHJvamVjdCBoZWFkZXIsIHRvIGluZGljYXRlIGFuIGFsdGVybmF0ZSBhY2NvdW50IGZvclxuICAgICAgICAvLyBiaWxsaW5nIGFuZCBxdW90YTpcbiAgICAgICAgaWYgKCFoZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J10gJiYgLy8gZG9uJ3Qgb3ZlcnJpZGUgYSB2YWx1ZSB0aGUgdXNlciBzZXRzLlxuICAgICAgICAgICAgdGhpcy5xdW90YVByb2plY3RJZCkge1xuICAgICAgICAgICAgaGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddID0gdGhpcy5xdW90YVByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG59XG5leHBvcnRzLkF1dGhDbGllbnQgPSBBdXRoQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aGNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBdXRoQ2xpZW50IiwiZXZlbnRzXzEiLCJyZXF1aXJlIiwidHJhbnNwb3J0ZXJzXzEiLCJFdmVudEVtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsImFyZ3VtZW50cyIsInRyYW5zcG9ydGVyIiwiRGVmYXVsdFRyYW5zcG9ydGVyIiwiY3JlZGVudGlhbHMiLCJlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMiLCJmb3JjZVJlZnJlc2hPbkZhaWx1cmUiLCJzZXRDcmVkZW50aWFscyIsImFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyIsImhlYWRlcnMiLCJxdW90YVByb2plY3RJZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/awsclient.js":
/*!**********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/awsclient.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AwsClient = void 0;\nconst awsrequestsigner_1 = __webpack_require__(/*! ./awsrequestsigner */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/awsrequestsigner.js\");\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\n/**\n * AWS external account client. This is used for AWS workloads, where\n * AWS STS GetCallerIdentity serialized signed requests are exchanged for\n * GCP access token.\n */ class AwsClient extends baseexternalclient_1.BaseExternalAccountClient {\n    /**\n     * Instantiates an AwsClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * An error is thrown if the credential is not a valid AWS credential.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     */ constructor(options, additionalOptions){\n        super(options, additionalOptions);\n        this.environmentId = options.credential_source.environment_id;\n        // This is only required if the AWS region is not available in the\n        // AWS_REGION or AWS_DEFAULT_REGION environment variables.\n        this.regionUrl = options.credential_source.region_url;\n        // This is only required if AWS security credentials are not available in\n        // environment variables.\n        this.securityCredentialsUrl = options.credential_source.url;\n        this.regionalCredVerificationUrl = options.credential_source.regional_cred_verification_url;\n        this.imdsV2SessionTokenUrl = options.credential_source.imdsv2_session_token_url;\n        this.awsRequestSigner = null;\n        this.region = \"\";\n        // Data validators.\n        this.validateEnvironmentId();\n    }\n    validateEnvironmentId() {\n        var _a;\n        const match = (_a = this.environmentId) === null || _a === void 0 ? void 0 : _a.match(/^(aws)(\\d+)$/);\n        if (!match || !this.regionalCredVerificationUrl) {\n            throw new Error('No valid AWS \"credential_source\" provided');\n        } else if (parseInt(match[2], 10) !== 1) {\n            throw new Error(`aws version \"${match[2]}\" is not supported in the current build.`);\n        }\n    }\n    /**\n     * Triggered when an external subject token is needed to be exchanged for a\n     * GCP access token via GCP STS endpoint.\n     * This uses the `options.credential_source` object to figure out how\n     * to retrieve the token using the current environment. In this case,\n     * this uses a serialized AWS signed request to the STS GetCallerIdentity\n     * endpoint.\n     * The logic is summarized as:\n     * 1. If imdsv2_session_token_url is provided in the credential source, then\n     *    fetch the aws session token and include it in the headers of the\n     *    metadata requests. This is a requirement for IDMSv2 but optional\n     *    for IDMSv1.\n     * 2. Retrieve AWS region from availability-zone.\n     * 3a. Check AWS credentials in environment variables. If not found, get\n     *     from security-credentials endpoint.\n     * 3b. Get AWS credentials from security-credentials endpoint. In order\n     *     to retrieve this, the AWS role needs to be determined by calling\n     *     security-credentials endpoint without any argument. Then the\n     *     credentials can be retrieved via: security-credentials/role_name\n     * 4. Generate the signed request to AWS STS GetCallerIdentity action.\n     * 5. Inject x-goog-cloud-target-resource into header and serialize the\n     *    signed request. This will be the subject-token to pass to GCP STS.\n     * @return A promise that resolves with the external subject token.\n     */ async retrieveSubjectToken() {\n        // Initialize AWS request signer if not already initialized.\n        if (!this.awsRequestSigner) {\n            const metadataHeaders = {};\n            // Only retrieve the IMDSv2 session token if both the security credentials and region are\n            // not retrievable through the environment.\n            // The credential config contains all the URLs by default but clients may be running this\n            // where the metadata server is not available and returning the credentials through the environment.\n            // Removing this check may break them.\n            if (this.shouldUseMetadataServer() && this.imdsV2SessionTokenUrl) {\n                metadataHeaders[\"x-aws-ec2-metadata-token\"] = await this.getImdsV2SessionToken();\n            }\n            this.region = await this.getAwsRegion(metadataHeaders);\n            this.awsRequestSigner = new awsrequestsigner_1.AwsRequestSigner(async ()=>{\n                // Check environment variables for permanent credentials first.\n                // https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html\n                if (this.securityCredentialsFromEnv) {\n                    return this.securityCredentialsFromEnv;\n                }\n                // Since the role on a VM can change, we don't need to cache it.\n                const roleName = await this.getAwsRoleName(metadataHeaders);\n                // Temporary credentials typically last for several hours.\n                // Expiration is returned in response.\n                // Consider future optimization of this logic to cache AWS tokens\n                // until their natural expiration.\n                const awsCreds = await this.getAwsSecurityCredentials(roleName, metadataHeaders);\n                return {\n                    accessKeyId: awsCreds.AccessKeyId,\n                    secretAccessKey: awsCreds.SecretAccessKey,\n                    token: awsCreds.Token\n                };\n            }, this.region);\n        }\n        // Generate signed request to AWS STS GetCallerIdentity API.\n        // Use the required regional endpoint. Otherwise, the request will fail.\n        const options = await this.awsRequestSigner.getRequestOptions({\n            url: this.regionalCredVerificationUrl.replace(\"{region}\", this.region),\n            method: \"POST\"\n        });\n        // The GCP STS endpoint expects the headers to be formatted as:\n        // [\n        //   {key: 'x-amz-date', value: '...'},\n        //   {key: 'Authorization', value: '...'},\n        //   ...\n        // ]\n        // And then serialized as:\n        // encodeURIComponent(JSON.stringify({\n        //   url: '...',\n        //   method: 'POST',\n        //   headers: [{key: 'x-amz-date', value: '...'}, ...]\n        // }))\n        const reformattedHeader = [];\n        const extendedHeaders = Object.assign({\n            // The full, canonical resource name of the workload identity pool\n            // provider, with or without the HTTPS prefix.\n            // Including this header as part of the signature is recommended to\n            // ensure data integrity.\n            \"x-goog-cloud-target-resource\": this.audience\n        }, options.headers);\n        // Reformat header to GCP STS expected format.\n        for(const key in extendedHeaders){\n            reformattedHeader.push({\n                key,\n                value: extendedHeaders[key]\n            });\n        }\n        // Serialize the reformatted signed request.\n        return encodeURIComponent(JSON.stringify({\n            url: options.url,\n            method: options.method,\n            headers: reformattedHeader\n        }));\n    }\n    /**\n     * @return A promise that resolves with the IMDSv2 Session Token.\n     */ async getImdsV2SessionToken() {\n        const opts = {\n            url: this.imdsV2SessionTokenUrl,\n            method: \"PUT\",\n            responseType: \"text\",\n            headers: {\n                \"x-aws-ec2-metadata-token-ttl-seconds\": \"300\"\n            }\n        };\n        const response = await this.transporter.request(opts);\n        return response.data;\n    }\n    /**\n     * @param headers The headers to be used in the metadata request.\n     * @return A promise that resolves with the current AWS region.\n     */ async getAwsRegion(headers) {\n        // Priority order for region determination:\n        // AWS_REGION > AWS_DEFAULT_REGION > metadata server.\n        if (this.regionFromEnv) {\n            return this.regionFromEnv;\n        }\n        if (!this.regionUrl) {\n            throw new Error(\"Unable to determine AWS region due to missing \" + '\"options.credential_source.region_url\"');\n        }\n        const opts = {\n            url: this.regionUrl,\n            method: \"GET\",\n            responseType: \"text\",\n            headers: headers\n        };\n        const response = await this.transporter.request(opts);\n        // Remove last character. For example, if us-east-2b is returned,\n        // the region would be us-east-2.\n        return response.data.substr(0, response.data.length - 1);\n    }\n    /**\n     * @param headers The headers to be used in the metadata request.\n     * @return A promise that resolves with the assigned role to the current\n     *   AWS VM. This is needed for calling the security-credentials endpoint.\n     */ async getAwsRoleName(headers) {\n        if (!this.securityCredentialsUrl) {\n            throw new Error(\"Unable to determine AWS role name due to missing \" + '\"options.credential_source.url\"');\n        }\n        const opts = {\n            url: this.securityCredentialsUrl,\n            method: \"GET\",\n            responseType: \"text\",\n            headers: headers\n        };\n        const response = await this.transporter.request(opts);\n        return response.data;\n    }\n    /**\n     * Retrieves the temporary AWS credentials by calling the security-credentials\n     * endpoint as specified in the `credential_source` object.\n     * @param roleName The role attached to the current VM.\n     * @param headers The headers to be used in the metadata request.\n     * @return A promise that resolves with the temporary AWS credentials\n     *   needed for creating the GetCallerIdentity signed request.\n     */ async getAwsSecurityCredentials(roleName, headers) {\n        const response = await this.transporter.request({\n            url: `${this.securityCredentialsUrl}/${roleName}`,\n            responseType: \"json\",\n            headers: headers\n        });\n        return response.data;\n    }\n    shouldUseMetadataServer() {\n        // The metadata server must be used when either the AWS region or AWS security\n        // credentials cannot be retrieved through their defined environment variables.\n        return !this.regionFromEnv || !this.securityCredentialsFromEnv;\n    }\n    get regionFromEnv() {\n        // The AWS region can be provided through AWS_REGION or AWS_DEFAULT_REGION.\n        // Only one is required.\n        return process.env[\"AWS_REGION\"] || process.env[\"AWS_DEFAULT_REGION\"] || null;\n    }\n    get securityCredentialsFromEnv() {\n        // Both AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY are required.\n        if (process.env[\"AWS_ACCESS_KEY_ID\"] && process.env[\"AWS_SECRET_ACCESS_KEY\"]) {\n            return {\n                accessKeyId: process.env[\"AWS_ACCESS_KEY_ID\"],\n                secretAccessKey: process.env[\"AWS_SECRET_ACCESS_KEY\"],\n                token: process.env[\"AWS_SESSION_TOKEN\"]\n            };\n        }\n        return null;\n    }\n}\nexports.AwsClient = AwsClient;\nAwsClient.AWS_EC2_METADATA_IPV4_ADDRESS = \"169.254.169.254\";\nAwsClient.AWS_EC2_METADATA_IPV6_ADDRESS = \"fd00:ec2::254\"; //# sourceMappingURL=awsclient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9hd3NjbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLE1BQU1HLHFCQUFxQkMsbUJBQU9BLENBQUMsdUdBQW9CO0FBQ3ZELE1BQU1DLHVCQUF1QkQsbUJBQU9BLENBQUMsMkdBQXNCO0FBQzNEOzs7O0NBSUMsR0FDRCxNQUFNRixrQkFBa0JHLHFCQUFxQkMseUJBQXlCO0lBQ2xFOzs7Ozs7Ozs7S0FTQyxHQUNEQyxZQUFZQyxPQUFPLEVBQUVDLGlCQUFpQixDQUFFO1FBQ3BDLEtBQUssQ0FBQ0QsU0FBU0M7UUFDZixJQUFJLENBQUNDLGFBQWEsR0FBR0YsUUFBUUcsaUJBQWlCLENBQUNDLGNBQWM7UUFDN0Qsa0VBQWtFO1FBQ2xFLDBEQUEwRDtRQUMxRCxJQUFJLENBQUNDLFNBQVMsR0FBR0wsUUFBUUcsaUJBQWlCLENBQUNHLFVBQVU7UUFDckQseUVBQXlFO1FBQ3pFLHlCQUF5QjtRQUN6QixJQUFJLENBQUNDLHNCQUFzQixHQUFHUCxRQUFRRyxpQkFBaUIsQ0FBQ0ssR0FBRztRQUMzRCxJQUFJLENBQUNDLDJCQUEyQixHQUM1QlQsUUFBUUcsaUJBQWlCLENBQUNPLDhCQUE4QjtRQUM1RCxJQUFJLENBQUNDLHFCQUFxQixHQUN0QlgsUUFBUUcsaUJBQWlCLENBQUNTLHdCQUF3QjtRQUN0RCxJQUFJLENBQUNDLGdCQUFnQixHQUFHO1FBQ3hCLElBQUksQ0FB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QUNBcEUsaUJBQWlCLEdBQUdFO0FBQ3BCQSxVQUFVbUUsNkJBQTZCLEdBQUc7QUFDMUNuRSxVQUFVb0UsNkJBQTZCLEdBQUcsaUJBQzFDLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2F3c2NsaWVudC5qcz80OGIxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkF3c0NsaWVudCA9IHZvaWQgMDtcbmNvbnN0IGF3c3JlcXVlc3RzaWduZXJfMSA9IHJlcXVpcmUoXCIuL2F3c3JlcXVlc3RzaWduZXJcIik7XG5jb25zdCBiYXNlZXh0ZXJuYWxjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2Jhc2VleHRlcm5hbGNsaWVudFwiKTtcbi8qKlxuICogQVdTIGV4dGVybmFsIGFjY291bnQgY2xpZW50LiBUaGlzIGlzIHVzZWQgZm9yIEFXUyB3b3JrbG9hZHMsIHdoZXJlXG4gKiBBV1MgU1RTIEdldENhbGxlcklkZW50aXR5IHNlcmlhbGl6ZWQgc2lnbmVkIHJlcXVlc3RzIGFyZSBleGNoYW5nZWQgZm9yXG4gKiBHQ1AgYWNjZXNzIHRva2VuLlxuICovXG5jbGFzcyBBd3NDbGllbnQgZXh0ZW5kcyBiYXNlZXh0ZXJuYWxjbGllbnRfMS5CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYW4gQXdzQ2xpZW50IGluc3RhbmNlIHVzaW5nIHRoZSBwcm92aWRlZCBKU09OXG4gICAgICogb2JqZWN0IGxvYWRlZCBmcm9tIGFuIGV4dGVybmFsIGFjY291bnQgY3JlZGVudGlhbHMgZmlsZS5cbiAgICAgKiBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIGNyZWRlbnRpYWwgaXMgbm90IGEgdmFsaWQgQVdTIGNyZWRlbnRpYWwuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGV4dGVybmFsIGFjY291bnQgb3B0aW9ucyBvYmplY3QgdHlwaWNhbGx5IGxvYWRlZFxuICAgICAqICAgZnJvbSB0aGUgZXh0ZXJuYWwgYWNjb3VudCBKU09OIGNyZWRlbnRpYWwgZmlsZS5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbE9wdGlvbnMgT3B0aW9uYWwgYWRkaXRpb25hbCBiZWhhdmlvciBjdXN0b21pemF0aW9uXG4gICAgICogICBvcHRpb25zLiBUaGVzZSBjdXJyZW50bHkgY3VzdG9taXplIGV4cGlyYXRpb24gdGhyZXNob2xkIHRpbWUgYW5kXG4gICAgICogICB3aGV0aGVyIHRvIHJldHJ5IG9uIDQwMS80MDMgQVBJIHJlcXVlc3QgZXJyb3JzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKTtcbiAgICAgICAgdGhpcy5lbnZpcm9ubWVudElkID0gb3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS5lbnZpcm9ubWVudF9pZDtcbiAgICAgICAgLy8gVGhpcyBpcyBvbmx5IHJlcXVpcmVkIGlmIHRoZSBBV1MgcmVnaW9uIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlXG4gICAgICAgIC8vIEFXU19SRUdJT04gb3IgQVdTX0RFRkFVTFRfUkVHSU9OIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAgICAgICAgdGhpcy5yZWdpb25VcmwgPSBvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLnJlZ2lvbl91cmw7XG4gICAgICAgIC8vIFRoaXMgaXMgb25seSByZXF1aXJlZCBpZiBBV1Mgc2VjdXJpdHkgY3JlZGVudGlhbHMgYXJlIG5vdCBhdmFpbGFibGUgaW5cbiAgICAgICAgLy8gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgICAgICB0aGlzLnNlY3VyaXR5Q3JlZGVudGlhbHNVcmwgPSBvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLnVybDtcbiAgICAgICAgdGhpcy5yZWdpb25hbENyZWRWZXJpZmljYXRpb25VcmwgPVxuICAgICAgICAgICAgb3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS5yZWdpb25hbF9jcmVkX3ZlcmlmaWNhdGlvbl91cmw7XG4gICAgICAgIHRoaXMuaW1kc1YyU2Vzc2lvblRva2VuVXJsID1cbiAgICAgICAgICAgIG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UuaW1kc3YyX3Nlc3Npb25fdG9rZW5fdXJsO1xuICAgICAgICB0aGlzLmF3c1JlcXVlc3RTaWduZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnJlZ2lvbiA9ICcnO1xuICAgICAgICAvLyBEYXRhIHZhbGlkYXRvcnMuXG4gICAgICAgIHRoaXMudmFsaWRhdGVFbnZpcm9ubWVudElkKCk7XG4gICAgfVxuICAgIHZhbGlkYXRlRW52aXJvbm1lbnRJZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtYXRjaCA9IChfYSA9IHRoaXMuZW52aXJvbm1lbnRJZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hdGNoKC9eKGF3cykoXFxkKykkLyk7XG4gICAgICAgIGlmICghbWF0Y2ggfHwgIXRoaXMucmVnaW9uYWxDcmVkVmVyaWZpY2F0aW9uVXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIEFXUyBcImNyZWRlbnRpYWxfc291cmNlXCIgcHJvdmlkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJzZUludChtYXRjaFsyXSwgMTApICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGF3cyB2ZXJzaW9uIFwiJHttYXRjaFsyXX1cIiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGJ1aWxkLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFuIGV4dGVybmFsIHN1YmplY3QgdG9rZW4gaXMgbmVlZGVkIHRvIGJlIGV4Y2hhbmdlZCBmb3IgYVxuICAgICAqIEdDUCBhY2Nlc3MgdG9rZW4gdmlhIEdDUCBTVFMgZW5kcG9pbnQuXG4gICAgICogVGhpcyB1c2VzIHRoZSBgb3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZWAgb2JqZWN0IHRvIGZpZ3VyZSBvdXQgaG93XG4gICAgICogdG8gcmV0cmlldmUgdGhlIHRva2VuIHVzaW5nIHRoZSBjdXJyZW50IGVudmlyb25tZW50LiBJbiB0aGlzIGNhc2UsXG4gICAgICogdGhpcyB1c2VzIGEgc2VyaWFsaXplZCBBV1Mgc2lnbmVkIHJlcXVlc3QgdG8gdGhlIFNUUyBHZXRDYWxsZXJJZGVudGl0eVxuICAgICAqIGVuZHBvaW50LlxuICAgICAqIFRoZSBsb2dpYyBpcyBzdW1tYXJpemVkIGFzOlxuICAgICAqIDEuIElmIGltZHN2Ml9zZXNzaW9uX3Rva2VuX3VybCBpcyBwcm92aWRlZCBpbiB0aGUgY3JlZGVudGlhbCBzb3VyY2UsIHRoZW5cbiAgICAgKiAgICBmZXRjaCB0aGUgYXdzIHNlc3Npb24gdG9rZW4gYW5kIGluY2x1ZGUgaXQgaW4gdGhlIGhlYWRlcnMgb2YgdGhlXG4gICAgICogICAgbWV0YWRhdGEgcmVxdWVzdHMuIFRoaXMgaXMgYSByZXF1aXJlbWVudCBmb3IgSURNU3YyIGJ1dCBvcHRpb25hbFxuICAgICAqICAgIGZvciBJRE1TdjEuXG4gICAgICogMi4gUmV0cmlldmUgQVdTIHJlZ2lvbiBmcm9tIGF2YWlsYWJpbGl0eS16b25lLlxuICAgICAqIDNhLiBDaGVjayBBV1MgY3JlZGVudGlhbHMgaW4gZW52aXJvbm1lbnQgdmFyaWFibGVzLiBJZiBub3QgZm91bmQsIGdldFxuICAgICAqICAgICBmcm9tIHNlY3VyaXR5LWNyZWRlbnRpYWxzIGVuZHBvaW50LlxuICAgICAqIDNiLiBHZXQgQVdTIGNyZWRlbnRpYWxzIGZyb20gc2VjdXJpdHktY3JlZGVudGlhbHMgZW5kcG9pbnQuIEluIG9yZGVyXG4gICAgICogICAgIHRvIHJldHJpZXZlIHRoaXMsIHRoZSBBV1Mgcm9sZSBuZWVkcyB0byBiZSBkZXRlcm1pbmVkIGJ5IGNhbGxpbmdcbiAgICAgKiAgICAgc2VjdXJpdHktY3JlZGVudGlhbHMgZW5kcG9pbnQgd2l0aG91dCBhbnkgYXJndW1lbnQuIFRoZW4gdGhlXG4gICAgICogICAgIGNyZWRlbnRpYWxzIGNhbiBiZSByZXRyaWV2ZWQgdmlhOiBzZWN1cml0eS1jcmVkZW50aWFscy9yb2xlX25hbWVcbiAgICAgKiA0LiBHZW5lcmF0ZSB0aGUgc2lnbmVkIHJlcXVlc3QgdG8gQVdTIFNUUyBHZXRDYWxsZXJJZGVudGl0eSBhY3Rpb24uXG4gICAgICogNS4gSW5qZWN0IHgtZ29vZy1jbG91ZC10YXJnZXQtcmVzb3VyY2UgaW50byBoZWFkZXIgYW5kIHNlcmlhbGl6ZSB0aGVcbiAgICAgKiAgICBzaWduZWQgcmVxdWVzdC4gVGhpcyB3aWxsIGJlIHRoZSBzdWJqZWN0LXRva2VuIHRvIHBhc3MgdG8gR0NQIFNUUy5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGV4dGVybmFsIHN1YmplY3QgdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgcmV0cmlldmVTdWJqZWN0VG9rZW4oKSB7XG4gICAgICAgIC8vIEluaXRpYWxpemUgQVdTIHJlcXVlc3Qgc2lnbmVyIGlmIG5vdCBhbHJlYWR5IGluaXRpYWxpemVkLlxuICAgICAgICBpZiAoIXRoaXMuYXdzUmVxdWVzdFNpZ25lcikge1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFIZWFkZXJzID0ge307XG4gICAgICAgICAgICAvLyBPbmx5IHJldHJpZXZlIHRoZSBJTURTdjIgc2Vzc2lvbiB0b2tlbiBpZiBib3RoIHRoZSBzZWN1cml0eSBjcmVkZW50aWFscyBhbmQgcmVnaW9uIGFyZVxuICAgICAgICAgICAgLy8gbm90IHJldHJpZXZhYmxlIHRocm91Z2ggdGhlIGVudmlyb25tZW50LlxuICAgICAgICAgICAgLy8gVGhlIGNyZWRlbnRpYWwgY29uZmlnIGNvbnRhaW5zIGFsbCB0aGUgVVJMcyBieSBkZWZhdWx0IGJ1dCBjbGllbnRzIG1heSBiZSBydW5uaW5nIHRoaXNcbiAgICAgICAgICAgIC8vIHdoZXJlIHRoZSBtZXRhZGF0YSBzZXJ2ZXIgaXMgbm90IGF2YWlsYWJsZSBhbmQgcmV0dXJuaW5nIHRoZSBjcmVkZW50aWFscyB0aHJvdWdoIHRoZSBlbnZpcm9ubWVudC5cbiAgICAgICAgICAgIC8vIFJlbW92aW5nIHRoaXMgY2hlY2sgbWF5IGJyZWFrIHRoZW0uXG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGRVc2VNZXRhZGF0YVNlcnZlcigpICYmIHRoaXMuaW1kc1YyU2Vzc2lvblRva2VuVXJsKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGFIZWFkZXJzWyd4LWF3cy1lYzItbWV0YWRhdGEtdG9rZW4nXSA9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0SW1kc1YyU2Vzc2lvblRva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlZ2lvbiA9IGF3YWl0IHRoaXMuZ2V0QXdzUmVnaW9uKG1ldGFkYXRhSGVhZGVycyk7XG4gICAgICAgICAgICB0aGlzLmF3c1JlcXVlc3RTaWduZXIgPSBuZXcgYXdzcmVxdWVzdHNpZ25lcl8xLkF3c1JlcXVlc3RTaWduZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGVudmlyb25tZW50IHZhcmlhYmxlcyBmb3IgcGVybWFuZW50IGNyZWRlbnRpYWxzIGZpcnN0LlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9nZW5lcmFsL2xhdGVzdC9nci9hd3Mtc2VjLWNyZWQtdHlwZXMuaHRtbFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlY3VyaXR5Q3JlZGVudGlhbHNGcm9tRW52KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlY3VyaXR5Q3JlZGVudGlhbHNGcm9tRW52O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgcm9sZSBvbiBhIFZNIGNhbiBjaGFuZ2UsIHdlIGRvbid0IG5lZWQgdG8gY2FjaGUgaXQuXG4gICAgICAgICAgICAgICAgY29uc3Qgcm9sZU5hbWUgPSBhd2FpdCB0aGlzLmdldEF3c1JvbGVOYW1lKG1ldGFkYXRhSGVhZGVycyk7XG4gICAgICAgICAgICAgICAgLy8gVGVtcG9yYXJ5IGNyZWRlbnRpYWxzIHR5cGljYWxseSBsYXN0IGZvciBzZXZlcmFsIGhvdXJzLlxuICAgICAgICAgICAgICAgIC8vIEV4cGlyYXRpb24gaXMgcmV0dXJuZWQgaW4gcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgZnV0dXJlIG9wdGltaXphdGlvbiBvZiB0aGlzIGxvZ2ljIHRvIGNhY2hlIEFXUyB0b2tlbnNcbiAgICAgICAgICAgICAgICAvLyB1bnRpbCB0aGVpciBuYXR1cmFsIGV4cGlyYXRpb24uXG4gICAgICAgICAgICAgICAgY29uc3QgYXdzQ3JlZHMgPSBhd2FpdCB0aGlzLmdldEF3c1NlY3VyaXR5Q3JlZGVudGlhbHMocm9sZU5hbWUsIG1ldGFkYXRhSGVhZGVycyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzS2V5SWQ6IGF3c0NyZWRzLkFjY2Vzc0tleUlkLFxuICAgICAgICAgICAgICAgICAgICBzZWNyZXRBY2Nlc3NLZXk6IGF3c0NyZWRzLlNlY3JldEFjY2Vzc0tleSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IGF3c0NyZWRzLlRva2VuLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LCB0aGlzLnJlZ2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2VuZXJhdGUgc2lnbmVkIHJlcXVlc3QgdG8gQVdTIFNUUyBHZXRDYWxsZXJJZGVudGl0eSBBUEkuXG4gICAgICAgIC8vIFVzZSB0aGUgcmVxdWlyZWQgcmVnaW9uYWwgZW5kcG9pbnQuIE90aGVyd2lzZSwgdGhlIHJlcXVlc3Qgd2lsbCBmYWlsLlxuICAgICAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgdGhpcy5hd3NSZXF1ZXN0U2lnbmVyLmdldFJlcXVlc3RPcHRpb25zKHtcbiAgICAgICAgICAgIHVybDogdGhpcy5yZWdpb25hbENyZWRWZXJpZmljYXRpb25VcmwucmVwbGFjZSgne3JlZ2lvbn0nLCB0aGlzLnJlZ2lvbiksXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoZSBHQ1AgU1RTIGVuZHBvaW50IGV4cGVjdHMgdGhlIGhlYWRlcnMgdG8gYmUgZm9ybWF0dGVkIGFzOlxuICAgICAgICAvLyBbXG4gICAgICAgIC8vICAge2tleTogJ3gtYW16LWRhdGUnLCB2YWx1ZTogJy4uLid9LFxuICAgICAgICAvLyAgIHtrZXk6ICdBdXRob3JpemF0aW9uJywgdmFsdWU6ICcuLi4nfSxcbiAgICAgICAgLy8gICAuLi5cbiAgICAgICAgLy8gXVxuICAgICAgICAvLyBBbmQgdGhlbiBzZXJpYWxpemVkIGFzOlxuICAgICAgICAvLyBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAvLyAgIHVybDogJy4uLicsXG4gICAgICAgIC8vICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIC8vICAgaGVhZGVyczogW3trZXk6ICd4LWFtei1kYXRlJywgdmFsdWU6ICcuLi4nfSwgLi4uXVxuICAgICAgICAvLyB9KSlcbiAgICAgICAgY29uc3QgcmVmb3JtYXR0ZWRIZWFkZXIgPSBbXTtcbiAgICAgICAgY29uc3QgZXh0ZW5kZWRIZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAvLyBUaGUgZnVsbCwgY2Fub25pY2FsIHJlc291cmNlIG5hbWUgb2YgdGhlIHdvcmtsb2FkIGlkZW50aXR5IHBvb2xcbiAgICAgICAgICAgIC8vIHByb3ZpZGVyLCB3aXRoIG9yIHdpdGhvdXQgdGhlIEhUVFBTIHByZWZpeC5cbiAgICAgICAgICAgIC8vIEluY2x1ZGluZyB0aGlzIGhlYWRlciBhcyBwYXJ0IG9mIHRoZSBzaWduYXR1cmUgaXMgcmVjb21tZW5kZWQgdG9cbiAgICAgICAgICAgIC8vIGVuc3VyZSBkYXRhIGludGVncml0eS5cbiAgICAgICAgICAgICd4LWdvb2ctY2xvdWQtdGFyZ2V0LXJlc291cmNlJzogdGhpcy5hdWRpZW5jZSxcbiAgICAgICAgfSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgLy8gUmVmb3JtYXQgaGVhZGVyIHRvIEdDUCBTVFMgZXhwZWN0ZWQgZm9ybWF0LlxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBleHRlbmRlZEhlYWRlcnMpIHtcbiAgICAgICAgICAgIHJlZm9ybWF0dGVkSGVhZGVyLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXh0ZW5kZWRIZWFkZXJzW2tleV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXJpYWxpemUgdGhlIHJlZm9ybWF0dGVkIHNpZ25lZCByZXF1ZXN0LlxuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHVybDogb3B0aW9ucy51cmwsXG4gICAgICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVyczogcmVmb3JtYXR0ZWRIZWFkZXIsXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBJTURTdjIgU2Vzc2lvbiBUb2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRJbWRzVjJTZXNzaW9uVG9rZW4oKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICB1cmw6IHRoaXMuaW1kc1YyU2Vzc2lvblRva2VuVXJsLFxuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgaGVhZGVyczogeyAneC1hd3MtZWMyLW1ldGFkYXRhLXRva2VuLXR0bC1zZWNvbmRzJzogJzMwMCcgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qob3B0cyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaGVhZGVycyBUaGUgaGVhZGVycyB0byBiZSB1c2VkIGluIHRoZSBtZXRhZGF0YSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgY3VycmVudCBBV1MgcmVnaW9uLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEF3c1JlZ2lvbihoZWFkZXJzKSB7XG4gICAgICAgIC8vIFByaW9yaXR5IG9yZGVyIGZvciByZWdpb24gZGV0ZXJtaW5hdGlvbjpcbiAgICAgICAgLy8gQVdTX1JFR0lPTiA+IEFXU19ERUZBVUxUX1JFR0lPTiA+IG1ldGFkYXRhIHNlcnZlci5cbiAgICAgICAgaWYgKHRoaXMucmVnaW9uRnJvbUVudikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnaW9uRnJvbUVudjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucmVnaW9uVXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZXRlcm1pbmUgQVdTIHJlZ2lvbiBkdWUgdG8gbWlzc2luZyAnICtcbiAgICAgICAgICAgICAgICAnXCJvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLnJlZ2lvbl91cmxcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICB1cmw6IHRoaXMucmVnaW9uVXJsLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qob3B0cyk7XG4gICAgICAgIC8vIFJlbW92ZSBsYXN0IGNoYXJhY3Rlci4gRm9yIGV4YW1wbGUsIGlmIHVzLWVhc3QtMmIgaXMgcmV0dXJuZWQsXG4gICAgICAgIC8vIHRoZSByZWdpb24gd291bGQgYmUgdXMtZWFzdC0yLlxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5zdWJzdHIoMCwgcmVzcG9uc2UuZGF0YS5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGhlYWRlcnMgVGhlIGhlYWRlcnMgdG8gYmUgdXNlZCBpbiB0aGUgbWV0YWRhdGEgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGFzc2lnbmVkIHJvbGUgdG8gdGhlIGN1cnJlbnRcbiAgICAgKiAgIEFXUyBWTS4gVGhpcyBpcyBuZWVkZWQgZm9yIGNhbGxpbmcgdGhlIHNlY3VyaXR5LWNyZWRlbnRpYWxzIGVuZHBvaW50LlxuICAgICAqL1xuICAgIGFzeW5jIGdldEF3c1JvbGVOYW1lKGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlY3VyaXR5Q3JlZGVudGlhbHNVcmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGRldGVybWluZSBBV1Mgcm9sZSBuYW1lIGR1ZSB0byBtaXNzaW5nICcgK1xuICAgICAgICAgICAgICAgICdcIm9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UudXJsXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgdXJsOiB0aGlzLnNlY3VyaXR5Q3JlZGVudGlhbHNVcmwsXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdGVtcG9yYXJ5IEFXUyBjcmVkZW50aWFscyBieSBjYWxsaW5nIHRoZSBzZWN1cml0eS1jcmVkZW50aWFsc1xuICAgICAqIGVuZHBvaW50IGFzIHNwZWNpZmllZCBpbiB0aGUgYGNyZWRlbnRpYWxfc291cmNlYCBvYmplY3QuXG4gICAgICogQHBhcmFtIHJvbGVOYW1lIFRoZSByb2xlIGF0dGFjaGVkIHRvIHRoZSBjdXJyZW50IFZNLlxuICAgICAqIEBwYXJhbSBoZWFkZXJzIFRoZSBoZWFkZXJzIHRvIGJlIHVzZWQgaW4gdGhlIG1ldGFkYXRhIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSB0ZW1wb3JhcnkgQVdTIGNyZWRlbnRpYWxzXG4gICAgICogICBuZWVkZWQgZm9yIGNyZWF0aW5nIHRoZSBHZXRDYWxsZXJJZGVudGl0eSBzaWduZWQgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBd3NTZWN1cml0eUNyZWRlbnRpYWxzKHJvbGVOYW1lLCBoZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgIHVybDogYCR7dGhpcy5zZWN1cml0eUNyZWRlbnRpYWxzVXJsfS8ke3JvbGVOYW1lfWAsXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgc2hvdWxkVXNlTWV0YWRhdGFTZXJ2ZXIoKSB7XG4gICAgICAgIC8vIFRoZSBtZXRhZGF0YSBzZXJ2ZXIgbXVzdCBiZSB1c2VkIHdoZW4gZWl0aGVyIHRoZSBBV1MgcmVnaW9uIG9yIEFXUyBzZWN1cml0eVxuICAgICAgICAvLyBjcmVkZW50aWFscyBjYW5ub3QgYmUgcmV0cmlldmVkIHRocm91Z2ggdGhlaXIgZGVmaW5lZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gICAgICAgIHJldHVybiAhdGhpcy5yZWdpb25Gcm9tRW52IHx8ICF0aGlzLnNlY3VyaXR5Q3JlZGVudGlhbHNGcm9tRW52O1xuICAgIH1cbiAgICBnZXQgcmVnaW9uRnJvbUVudigpIHtcbiAgICAgICAgLy8gVGhlIEFXUyByZWdpb24gY2FuIGJlIHByb3ZpZGVkIHRocm91Z2ggQVdTX1JFR0lPTiBvciBBV1NfREVGQVVMVF9SRUdJT04uXG4gICAgICAgIC8vIE9ubHkgb25lIGlzIHJlcXVpcmVkLlxuICAgICAgICByZXR1cm4gKHByb2Nlc3MuZW52WydBV1NfUkVHSU9OJ10gfHwgcHJvY2Vzcy5lbnZbJ0FXU19ERUZBVUxUX1JFR0lPTiddIHx8IG51bGwpO1xuICAgIH1cbiAgICBnZXQgc2VjdXJpdHlDcmVkZW50aWFsc0Zyb21FbnYoKSB7XG4gICAgICAgIC8vIEJvdGggQVdTX0FDQ0VTU19LRVlfSUQgYW5kIEFXU19TRUNSRVRfQUNDRVNTX0tFWSBhcmUgcmVxdWlyZWQuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudlsnQVdTX0FDQ0VTU19LRVlfSUQnXSAmJlxuICAgICAgICAgICAgcHJvY2Vzcy5lbnZbJ0FXU19TRUNSRVRfQUNDRVNTX0tFWSddKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFjY2Vzc0tleUlkOiBwcm9jZXNzLmVudlsnQVdTX0FDQ0VTU19LRVlfSUQnXSxcbiAgICAgICAgICAgICAgICBzZWNyZXRBY2Nlc3NLZXk6IHByb2Nlc3MuZW52WydBV1NfU0VDUkVUX0FDQ0VTU19LRVknXSxcbiAgICAgICAgICAgICAgICB0b2tlbjogcHJvY2Vzcy5lbnZbJ0FXU19TRVNTSU9OX1RPS0VOJ10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuQXdzQ2xpZW50ID0gQXdzQ2xpZW50O1xuQXdzQ2xpZW50LkFXU19FQzJfTUVUQURBVEFfSVBWNF9BRERSRVNTID0gJzE2OS4yNTQuMTY5LjI1NCc7XG5Bd3NDbGllbnQuQVdTX0VDMl9NRVRBREFUQV9JUFY2X0FERFJFU1MgPSAnZmQwMDplYzI6OjI1NCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hd3NjbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQXdzQ2xpZW50IiwiYXdzcmVxdWVzdHNpZ25lcl8xIiwicmVxdWlyZSIsImJhc2VleHRlcm5hbGNsaWVudF8xIiwiQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImFkZGl0aW9uYWxPcHRpb25zIiwiZW52aXJvbm1lbnRJZCIsImNyZWRlbnRpYWxfc291cmNlIiwiZW52aXJvbm1lbnRfaWQiLCJyZWdpb25VcmwiLCJyZWdpb25fdXJsIiwic2VjdXJpdHlDcmVkZW50aWFsc1VybCIsInVybCIsInJlZ2lvbmFsQ3JlZFZlcmlmaWNhdGlvblVybCIsInJlZ2lvbmFsX2NyZWRfdmVyaWZpY2F0aW9uX3VybCIsImltZHNWMlNlc3Npb25Ub2tlblVybCIsImltZHN2Ml9zZXNzaW9uX3Rva2VuX3VybCIsImF3c1JlcXVlc3RTaWduZXIiLCJyZWdpb24iLCJ2YWxpZGF0ZUVudmlyb25tZW50SWQiLCJfYSIsIm1hdGNoIiwiRXJyb3IiLCJwYXJzZUludCIsInJldHJpZXZlU3ViamVjdFRva2VuIiwibWV0YWRhdGFIZWFkZXJzIiwic2hvdWxkVXNlTWV0YWRhdGFTZXJ2ZXIiLCJnZXRJbWRzVjJTZXNzaW9uVG9rZW4iLCJnZXRBd3NSZWdpb24iLCJBd3NSZXF1ZXN0U2lnbmVyIiwic2VjdXJpdHlDcmVkZW50aWFsc0Zyb21FbnYiLCJyb2xlTmFtZSIsImdldEF3c1JvbGVOYW1lIiwiYXdzQ3JlZHMiLCJnZXRBd3NTZWN1cml0eUNyZWRlbnRpYWxzIiwiYWNjZXNzS2V5SWQiLCJBY2Nlc3NLZXlJZCIsInNlY3JldEFjY2Vzc0tleSIsIlNlY3JldEFjY2Vzc0tleSIsInRva2VuIiwiVG9rZW4iLCJnZXRSZXF1ZXN0T3B0aW9ucyIsInJlcGxhY2UiLCJtZXRob2QiLCJyZWZvcm1hdHRlZEhlYWRlciIsImV4dGVuZGVkSGVhZGVycyIsImFzc2lnbiIsImF1ZGllbmNlIiwiaGVhZGVycyIsImtleSIsInB1c2giLCJlbmNvZGVVUklDb21wb25lbnQiLCJKU09OIiwic3RyaW5naWZ5Iiwib3B0cyIsInJlc3BvbnNlVHlwZSIsInJlc3BvbnNlIiwidHJhbnNwb3J0ZXIiLCJyZXF1ZXN0IiwiZGF0YSIsInJlZ2lvbkZyb21FbnYiLCJzdWJzdHIiLCJsZW5ndGgiLCJwcm9jZXNzIiwiZW52IiwiQVdTX0VDMl9NRVRBREFUQV9JUFY0X0FERFJFU1MiLCJBV1NfRUMyX01FVEFEQVRBX0lQVjZfQUREUkVTUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/awsclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/awsrequestsigner.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/awsrequestsigner.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AwsRequestSigner = void 0;\nconst crypto_1 = __webpack_require__(/*! ../crypto/crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js\");\n/** AWS Signature Version 4 signing algorithm identifier.  */ const AWS_ALGORITHM = \"AWS4-HMAC-SHA256\";\n/**\n * The termination string for the AWS credential scope value as defined in\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n */ const AWS_REQUEST_TYPE = \"aws4_request\";\n/**\n * Implements an AWS API request signer based on the AWS Signature Version 4\n * signing process.\n * https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html\n */ class AwsRequestSigner {\n    /**\n     * Instantiates an AWS API request signer used to send authenticated signed\n     * requests to AWS APIs based on the AWS Signature Version 4 signing process.\n     * This also provides a mechanism to generate the signed request without\n     * sending it.\n     * @param getCredentials A mechanism to retrieve AWS security credentials\n     *   when needed.\n     * @param region The AWS region to use.\n     */ constructor(getCredentials, region){\n        this.getCredentials = getCredentials;\n        this.region = region;\n        this.crypto = (0, crypto_1.createCrypto)();\n    }\n    /**\n     * Generates the signed request for the provided HTTP request for calling\n     * an AWS API. This follows the steps described at:\n     * https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html\n     * @param amzOptions The AWS request options that need to be signed.\n     * @return A promise that resolves with the GaxiosOptions containing the\n     *   signed HTTP request parameters.\n     */ async getRequestOptions(amzOptions) {\n        if (!amzOptions.url) {\n            throw new Error('\"url\" is required in \"amzOptions\"');\n        }\n        // Stringify JSON requests. This will be set in the request body of the\n        // generated signed request.\n        const requestPayloadData = typeof amzOptions.data === \"object\" ? JSON.stringify(amzOptions.data) : amzOptions.data;\n        const url = amzOptions.url;\n        const method = amzOptions.method || \"GET\";\n        const requestPayload = amzOptions.body || requestPayloadData;\n        const additionalAmzHeaders = amzOptions.headers;\n        const awsSecurityCredentials = await this.getCredentials();\n        const uri = new URL(url);\n        const headerMap = await generateAuthenticationHeaderMap({\n            crypto: this.crypto,\n            host: uri.host,\n            canonicalUri: uri.pathname,\n            canonicalQuerystring: uri.search.substr(1),\n            method,\n            region: this.region,\n            securityCredentials: awsSecurityCredentials,\n            requestPayload,\n            additionalAmzHeaders\n        });\n        // Append additional optional headers, eg. X-Amz-Target, Content-Type, etc.\n        const headers = Object.assign(// Add x-amz-date if available.\n        headerMap.amzDate ? {\n            \"x-amz-date\": headerMap.amzDate\n        } : {}, {\n            Authorization: headerMap.authorizationHeader,\n            host: uri.host\n        }, additionalAmzHeaders || {});\n        if (awsSecurityCredentials.token) {\n            Object.assign(headers, {\n                \"x-amz-security-token\": awsSecurityCredentials.token\n            });\n        }\n        const awsSignedReq = {\n            url,\n            method: method,\n            headers\n        };\n        if (typeof requestPayload !== \"undefined\") {\n            awsSignedReq.body = requestPayload;\n        }\n        return awsSignedReq;\n    }\n}\nexports.AwsRequestSigner = AwsRequestSigner;\n/**\n * Creates the HMAC-SHA256 hash of the provided message using the\n * provided key.\n *\n * @param crypto The crypto instance used to facilitate cryptographic\n *   operations.\n * @param key The HMAC-SHA256 key to use.\n * @param msg The message to hash.\n * @return The computed hash bytes.\n */ async function sign(crypto, key, msg) {\n    return await crypto.signWithHmacSha256(key, msg);\n}\n/**\n * Calculates the signing key used to calculate the signature for\n * AWS Signature Version 4 based on:\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n *\n * @param crypto The crypto instance used to facilitate cryptographic\n *   operations.\n * @param key The AWS secret access key.\n * @param dateStamp The '%Y%m%d' date format.\n * @param region The AWS region.\n * @param serviceName The AWS service name, eg. sts.\n * @return The signing key bytes.\n */ async function getSigningKey(crypto, key, dateStamp, region, serviceName) {\n    const kDate = await sign(crypto, `AWS4${key}`, dateStamp);\n    const kRegion = await sign(crypto, kDate, region);\n    const kService = await sign(crypto, kRegion, serviceName);\n    const kSigning = await sign(crypto, kService, \"aws4_request\");\n    return kSigning;\n}\n/**\n * Generates the authentication header map needed for generating the AWS\n * Signature Version 4 signed request.\n *\n * @param option The options needed to compute the authentication header map.\n * @return The AWS authentication header map which constitutes of the following\n *   components: amz-date, authorization header and canonical query string.\n */ async function generateAuthenticationHeaderMap(options) {\n    const additionalAmzHeaders = options.additionalAmzHeaders || {};\n    const requestPayload = options.requestPayload || \"\";\n    // iam.amazonaws.com host => iam service.\n    // sts.us-east-2.amazonaws.com => sts service.\n    const serviceName = options.host.split(\".\")[0];\n    const now = new Date();\n    // Format: '%Y%m%dT%H%M%SZ'.\n    const amzDate = now.toISOString().replace(/[-:]/g, \"\").replace(/\\.[0-9]+/, \"\");\n    // Format: '%Y%m%d'.\n    const dateStamp = now.toISOString().replace(/[-]/g, \"\").replace(/T.*/, \"\");\n    // Change all additional headers to be lower case.\n    const reformattedAdditionalAmzHeaders = {};\n    Object.keys(additionalAmzHeaders).forEach((key)=>{\n        reformattedAdditionalAmzHeaders[key.toLowerCase()] = additionalAmzHeaders[key];\n    });\n    // Add AWS token if available.\n    if (options.securityCredentials.token) {\n        reformattedAdditionalAmzHeaders[\"x-amz-security-token\"] = options.securityCredentials.token;\n    }\n    // Header keys need to be sorted alphabetically.\n    const amzHeaders = Object.assign({\n        host: options.host\n    }, // Previously the date was not fixed with x-amz- and could be provided manually.\n    // https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-header-value-trim.req\n    reformattedAdditionalAmzHeaders.date ? {} : {\n        \"x-amz-date\": amzDate\n    }, reformattedAdditionalAmzHeaders);\n    let canonicalHeaders = \"\";\n    const signedHeadersList = Object.keys(amzHeaders).sort();\n    signedHeadersList.forEach((key)=>{\n        canonicalHeaders += `${key}:${amzHeaders[key]}\\n`;\n    });\n    const signedHeaders = signedHeadersList.join(\";\");\n    const payloadHash = await options.crypto.sha256DigestHex(requestPayload);\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\n    const canonicalRequest = `${options.method}\\n` + `${options.canonicalUri}\\n` + `${options.canonicalQuerystring}\\n` + `${canonicalHeaders}\\n` + `${signedHeaders}\\n` + `${payloadHash}`;\n    const credentialScope = `${dateStamp}/${options.region}/${serviceName}/${AWS_REQUEST_TYPE}`;\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n    const stringToSign = `${AWS_ALGORITHM}\\n` + `${amzDate}\\n` + `${credentialScope}\\n` + await options.crypto.sha256DigestHex(canonicalRequest);\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n    const signingKey = await getSigningKey(options.crypto, options.securityCredentials.secretAccessKey, dateStamp, options.region, serviceName);\n    const signature = await sign(options.crypto, signingKey, stringToSign);\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n    const authorizationHeader = `${AWS_ALGORITHM} Credential=${options.securityCredentials.accessKeyId}/` + `${credentialScope}, SignedHeaders=${signedHeaders}, ` + `Signature=${(0, crypto_1.fromArrayBufferToHex)(signature)}`;\n    return {\n        // Do not return x-amz-date if date is available.\n        amzDate: reformattedAdditionalAmzHeaders.date ? undefined : amzDate,\n        authorizationHeader,\n        canonicalQuerystring: options.canonicalQuerystring\n    };\n} //# sourceMappingURL=awsrequestsigner.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9hd3NyZXF1ZXN0c2lnbmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsd0JBQXdCLEdBQUcsS0FBSztBQUNoQyxNQUFNRyxXQUFXQyxtQkFBT0EsQ0FBQyw2RkFBa0I7QUFDM0MsMkRBQTJELEdBQzNELE1BQU1DLGdCQUFnQjtBQUN0Qjs7O0NBR0MsR0FDRCxNQUFNQyxtQkFBbUI7QUFDekI7Ozs7Q0FJQyxHQUNELE1BQU1KO0lBQ0Y7Ozs7Ozs7O0tBUUMsR0FDREssWUFBWUMsY0FBYyxFQUFFQyxNQUFNLENBQUU7UUFDaEMsSUFBSSxDQUFDRCxjQUFjLEdBQUdBO1FBQ3RCLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsTUFBTSxHQUFHLENBQUMsR0FBR1AsU0FBU1EsWUFBWTtJQUMzQztJQUNBOzs7Ozs7O0tBT0MsR0FDRCxNQUFNQyxrQkFBa0JDLFVBQVUsRUFBRTtRQUNoQyxJQUFJLENBQUNBLFdBQVdDLEdBQUcsRUFBRTtZQUNqQixNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSx1RUFBdUU7UUFDdkUsNEJBQTRCO1FBQzVCLE1BQU1DLHFCQUFxQixPQUFPSCxXQUFXSSxJQUFJLEtBQUssV0FDaERDLEtBQUtDLFNBQVMsQ0FBQ04sV0FBV0ksSUFBSSxJQUM5QkosV0FBV0ksSUFBSTtRQUNyQixNQUFNSCxNQUFNRCxXQUFXQyxHQUFHO1FBQzFCLE1BQU1NLFNBQVNQLFdBQVdP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d0MsWUFBWSxDQUFDLEVBQUUzQyxpQkFBaUIsQ0FBQztJQUMzRixpRkFBaUY7SUFDakYsTUFBTXFFLGVBQWUsQ0FBQyxFQUFFdEUsY0FBYyxFQUFFLENBQUMsR0FDckMsQ0FBQyxFQUFFaUMsUUFBUSxFQUFFLENBQUMsR0FDZCxDQUFDLEVBQUVvQyxnQkFBZ0IsRUFBRSxDQUFDLEdBQ3JCLE1BQU1wQixRQUFRNUMsTUFBTSxDQUFDOEQsZUFBZSxDQUFDQztJQUMxQywrRUFBK0U7SUFDL0UsTUFBTUcsYUFBYSxNQUFNN0IsY0FBY08sUUFBUTVDLE1BQU0sRUFBRTRDLFFBQVFsQixtQkFBbUIsQ0FBQ3lDLGVBQWUsRUFBRTdCLFdBQVdNLFFBQVE3QyxNQUFNLEVBQUV3QztJQUMvSCxNQUFNNkIsWUFBWSxNQUFNbkMsS0FBS1csUUFBUTVDLE1BQU0sRUFBRWtFLFlBQVlEO0lBQ3pELG9GQUFvRjtJQUNwRixNQUFNbkMsc0JBQXNCLENBQUMsRUFBRW5DLGNBQWMsWUFBWSxFQUFFaUQsUUFBUWxCLG1CQUFtQixDQUFDMkMsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUNqRyxDQUFDLEVBQUVMLGdCQUFnQixnQkFBZ0IsRUFBRUwsY0FBYyxFQUFFLENBQUMsR0FDdEQsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxHQUFHbEUsU0FBUzZFLG9CQUFvQixFQUFFRixXQUFXLENBQUM7SUFDaEUsT0FBTztRQUNILGlEQUFpRDtRQUNqRHhDLFNBQVNzQixnQ0FBZ0NLLElBQUksR0FBR2dCLFlBQVkzQztRQUM1REU7UUFDQVAsc0JBQXNCcUIsUUFBUXJCLG9CQUFvQjtJQUN0RDtBQUNKLEVBQ0EsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvYXdzcmVxdWVzdHNpZ25lci5qcz85NWRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkF3c1JlcXVlc3RTaWduZXIgPSB2b2lkIDA7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vY3J5cHRvXCIpO1xuLyoqIEFXUyBTaWduYXR1cmUgVmVyc2lvbiA0IHNpZ25pbmcgYWxnb3JpdGhtIGlkZW50aWZpZXIuICAqL1xuY29uc3QgQVdTX0FMR09SSVRITSA9ICdBV1M0LUhNQUMtU0hBMjU2Jztcbi8qKlxuICogVGhlIHRlcm1pbmF0aW9uIHN0cmluZyBmb3IgdGhlIEFXUyBjcmVkZW50aWFsIHNjb3BlIHZhbHVlIGFzIGRlZmluZWQgaW5cbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9nZW5lcmFsL2xhdGVzdC9nci9zaWd2NC1jcmVhdGUtc3RyaW5nLXRvLXNpZ24uaHRtbFxuICovXG5jb25zdCBBV1NfUkVRVUVTVF9UWVBFID0gJ2F3czRfcmVxdWVzdCc7XG4vKipcbiAqIEltcGxlbWVudHMgYW4gQVdTIEFQSSByZXF1ZXN0IHNpZ25lciBiYXNlZCBvbiB0aGUgQVdTIFNpZ25hdHVyZSBWZXJzaW9uIDRcbiAqIHNpZ25pbmcgcHJvY2Vzcy5cbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9nZW5lcmFsL2xhdGVzdC9nci9zaWduYXR1cmUtdmVyc2lvbi00Lmh0bWxcbiAqL1xuY2xhc3MgQXdzUmVxdWVzdFNpZ25lciB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGFuIEFXUyBBUEkgcmVxdWVzdCBzaWduZXIgdXNlZCB0byBzZW5kIGF1dGhlbnRpY2F0ZWQgc2lnbmVkXG4gICAgICogcmVxdWVzdHMgdG8gQVdTIEFQSXMgYmFzZWQgb24gdGhlIEFXUyBTaWduYXR1cmUgVmVyc2lvbiA0IHNpZ25pbmcgcHJvY2Vzcy5cbiAgICAgKiBUaGlzIGFsc28gcHJvdmlkZXMgYSBtZWNoYW5pc20gdG8gZ2VuZXJhdGUgdGhlIHNpZ25lZCByZXF1ZXN0IHdpdGhvdXRcbiAgICAgKiBzZW5kaW5nIGl0LlxuICAgICAqIEBwYXJhbSBnZXRDcmVkZW50aWFscyBBIG1lY2hhbmlzbSB0byByZXRyaWV2ZSBBV1Mgc2VjdXJpdHkgY3JlZGVudGlhbHNcbiAgICAgKiAgIHdoZW4gbmVlZGVkLlxuICAgICAqIEBwYXJhbSByZWdpb24gVGhlIEFXUyByZWdpb24gdG8gdXNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdldENyZWRlbnRpYWxzLCByZWdpb24pIHtcbiAgICAgICAgdGhpcy5nZXRDcmVkZW50aWFscyA9IGdldENyZWRlbnRpYWxzO1xuICAgICAgICB0aGlzLnJlZ2lvbiA9IHJlZ2lvbjtcbiAgICAgICAgdGhpcy5jcnlwdG8gPSAoMCwgY3J5cHRvXzEuY3JlYXRlQ3J5cHRvKSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIHNpZ25lZCByZXF1ZXN0IGZvciB0aGUgcHJvdmlkZWQgSFRUUCByZXF1ZXN0IGZvciBjYWxsaW5nXG4gICAgICogYW4gQVdTIEFQSS4gVGhpcyBmb2xsb3dzIHRoZSBzdGVwcyBkZXNjcmliZWQgYXQ6XG4gICAgICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3NpZ3Y0X3NpZ25pbmcuaHRtbFxuICAgICAqIEBwYXJhbSBhbXpPcHRpb25zIFRoZSBBV1MgcmVxdWVzdCBvcHRpb25zIHRoYXQgbmVlZCB0byBiZSBzaWduZWQuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBHYXhpb3NPcHRpb25zIGNvbnRhaW5pbmcgdGhlXG4gICAgICogICBzaWduZWQgSFRUUCByZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UmVxdWVzdE9wdGlvbnMoYW16T3B0aW9ucykge1xuICAgICAgICBpZiAoIWFtek9wdGlvbnMudXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widXJsXCIgaXMgcmVxdWlyZWQgaW4gXCJhbXpPcHRpb25zXCInKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJpbmdpZnkgSlNPTiByZXF1ZXN0cy4gVGhpcyB3aWxsIGJlIHNldCBpbiB0aGUgcmVxdWVzdCBib2R5IG9mIHRoZVxuICAgICAgICAvLyBnZW5lcmF0ZWQgc2lnbmVkIHJlcXVlc3QuXG4gICAgICAgIGNvbnN0IHJlcXVlc3RQYXlsb2FkRGF0YSA9IHR5cGVvZiBhbXpPcHRpb25zLmRhdGEgPT09ICdvYmplY3QnXG4gICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KGFtek9wdGlvbnMuZGF0YSlcbiAgICAgICAgICAgIDogYW16T3B0aW9ucy5kYXRhO1xuICAgICAgICBjb25zdCB1cmwgPSBhbXpPcHRpb25zLnVybDtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gYW16T3B0aW9ucy5tZXRob2QgfHwgJ0dFVCc7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RQYXlsb2FkID0gYW16T3B0aW9ucy5ib2R5IHx8IHJlcXVlc3RQYXlsb2FkRGF0YTtcbiAgICAgICAgY29uc3QgYWRkaXRpb25hbEFtekhlYWRlcnMgPSBhbXpPcHRpb25zLmhlYWRlcnM7XG4gICAgICAgIGNvbnN0IGF3c1NlY3VyaXR5Q3JlZGVudGlhbHMgPSBhd2FpdCB0aGlzLmdldENyZWRlbnRpYWxzKCk7XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodXJsKTtcbiAgICAgICAgY29uc3QgaGVhZGVyTWFwID0gYXdhaXQgZ2VuZXJhdGVBdXRoZW50aWNhdGlvbkhlYWRlck1hcCh7XG4gICAgICAgICAgICBjcnlwdG86IHRoaXMuY3J5cHRvLFxuICAgICAgICAgICAgaG9zdDogdXJpLmhvc3QsXG4gICAgICAgICAgICBjYW5vbmljYWxVcmk6IHVyaS5wYXRobmFtZSxcbiAgICAgICAgICAgIGNhbm9uaWNhbFF1ZXJ5c3RyaW5nOiB1cmkuc2VhcmNoLnN1YnN0cigxKSxcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHJlZ2lvbjogdGhpcy5yZWdpb24sXG4gICAgICAgICAgICBzZWN1cml0eUNyZWRlbnRpYWxzOiBhd3NTZWN1cml0eUNyZWRlbnRpYWxzLFxuICAgICAgICAgICAgcmVxdWVzdFBheWxvYWQsXG4gICAgICAgICAgICBhZGRpdGlvbmFsQW16SGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFwcGVuZCBhZGRpdGlvbmFsIG9wdGlvbmFsIGhlYWRlcnMsIGVnLiBYLUFtei1UYXJnZXQsIENvbnRlbnQtVHlwZSwgZXRjLlxuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgLy8gQWRkIHgtYW16LWRhdGUgaWYgYXZhaWxhYmxlLlxuICAgICAgICBoZWFkZXJNYXAuYW16RGF0ZSA/IHsgJ3gtYW16LWRhdGUnOiBoZWFkZXJNYXAuYW16RGF0ZSB9IDoge30sIHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGhlYWRlck1hcC5hdXRob3JpemF0aW9uSGVhZGVyLFxuICAgICAgICAgICAgaG9zdDogdXJpLmhvc3QsXG4gICAgICAgIH0sIGFkZGl0aW9uYWxBbXpIZWFkZXJzIHx8IHt9KTtcbiAgICAgICAgaWYgKGF3c1NlY3VyaXR5Q3JlZGVudGlhbHMudG9rZW4pIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaGVhZGVycywge1xuICAgICAgICAgICAgICAgICd4LWFtei1zZWN1cml0eS10b2tlbic6IGF3c1NlY3VyaXR5Q3JlZGVudGlhbHMudG9rZW4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhd3NTaWduZWRSZXEgPSB7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdFBheWxvYWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBhd3NTaWduZWRSZXEuYm9keSA9IHJlcXVlc3RQYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd3NTaWduZWRSZXE7XG4gICAgfVxufVxuZXhwb3J0cy5Bd3NSZXF1ZXN0U2lnbmVyID0gQXdzUmVxdWVzdFNpZ25lcjtcbi8qKlxuICogQ3JlYXRlcyB0aGUgSE1BQy1TSEEyNTYgaGFzaCBvZiB0aGUgcHJvdmlkZWQgbWVzc2FnZSB1c2luZyB0aGVcbiAqIHByb3ZpZGVkIGtleS5cbiAqXG4gKiBAcGFyYW0gY3J5cHRvIFRoZSBjcnlwdG8gaW5zdGFuY2UgdXNlZCB0byBmYWNpbGl0YXRlIGNyeXB0b2dyYXBoaWNcbiAqICAgb3BlcmF0aW9ucy5cbiAqIEBwYXJhbSBrZXkgVGhlIEhNQUMtU0hBMjU2IGtleSB0byB1c2UuXG4gKiBAcGFyYW0gbXNnIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gKiBAcmV0dXJuIFRoZSBjb21wdXRlZCBoYXNoIGJ5dGVzLlxuICovXG5hc3luYyBmdW5jdGlvbiBzaWduKGNyeXB0bywga2V5LCBtc2cpIHtcbiAgICByZXR1cm4gYXdhaXQgY3J5cHRvLnNpZ25XaXRoSG1hY1NoYTI1NihrZXksIG1zZyk7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNpZ25pbmcga2V5IHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBzaWduYXR1cmUgZm9yXG4gKiBBV1MgU2lnbmF0dXJlIFZlcnNpb24gNCBiYXNlZCBvbjpcbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9nZW5lcmFsL2xhdGVzdC9nci9zaWd2NC1jYWxjdWxhdGUtc2lnbmF0dXJlLmh0bWxcbiAqXG4gKiBAcGFyYW0gY3J5cHRvIFRoZSBjcnlwdG8gaW5zdGFuY2UgdXNlZCB0byBmYWNpbGl0YXRlIGNyeXB0b2dyYXBoaWNcbiAqICAgb3BlcmF0aW9ucy5cbiAqIEBwYXJhbSBrZXkgVGhlIEFXUyBzZWNyZXQgYWNjZXNzIGtleS5cbiAqIEBwYXJhbSBkYXRlU3RhbXAgVGhlICclWSVtJWQnIGRhdGUgZm9ybWF0LlxuICogQHBhcmFtIHJlZ2lvbiBUaGUgQVdTIHJlZ2lvbi5cbiAqIEBwYXJhbSBzZXJ2aWNlTmFtZSBUaGUgQVdTIHNlcnZpY2UgbmFtZSwgZWcuIHN0cy5cbiAqIEByZXR1cm4gVGhlIHNpZ25pbmcga2V5IGJ5dGVzLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRTaWduaW5nS2V5KGNyeXB0bywga2V5LCBkYXRlU3RhbXAsIHJlZ2lvbiwgc2VydmljZU5hbWUpIHtcbiAgICBjb25zdCBrRGF0ZSA9IGF3YWl0IHNpZ24oY3J5cHRvLCBgQVdTNCR7a2V5fWAsIGRhdGVTdGFtcCk7XG4gICAgY29uc3Qga1JlZ2lvbiA9IGF3YWl0IHNpZ24oY3J5cHRvLCBrRGF0ZSwgcmVnaW9uKTtcbiAgICBjb25zdCBrU2VydmljZSA9IGF3YWl0IHNpZ24oY3J5cHRvLCBrUmVnaW9uLCBzZXJ2aWNlTmFtZSk7XG4gICAgY29uc3Qga1NpZ25pbmcgPSBhd2FpdCBzaWduKGNyeXB0bywga1NlcnZpY2UsICdhd3M0X3JlcXVlc3QnKTtcbiAgICByZXR1cm4ga1NpZ25pbmc7XG59XG4vKipcbiAqIEdlbmVyYXRlcyB0aGUgYXV0aGVudGljYXRpb24gaGVhZGVyIG1hcCBuZWVkZWQgZm9yIGdlbmVyYXRpbmcgdGhlIEFXU1xuICogU2lnbmF0dXJlIFZlcnNpb24gNCBzaWduZWQgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9uIFRoZSBvcHRpb25zIG5lZWRlZCB0byBjb21wdXRlIHRoZSBhdXRoZW50aWNhdGlvbiBoZWFkZXIgbWFwLlxuICogQHJldHVybiBUaGUgQVdTIGF1dGhlbnRpY2F0aW9uIGhlYWRlciBtYXAgd2hpY2ggY29uc3RpdHV0ZXMgb2YgdGhlIGZvbGxvd2luZ1xuICogICBjb21wb25lbnRzOiBhbXotZGF0ZSwgYXV0aG9yaXphdGlvbiBoZWFkZXIgYW5kIGNhbm9uaWNhbCBxdWVyeSBzdHJpbmcuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlQXV0aGVudGljYXRpb25IZWFkZXJNYXAob3B0aW9ucykge1xuICAgIGNvbnN0IGFkZGl0aW9uYWxBbXpIZWFkZXJzID0gb3B0aW9ucy5hZGRpdGlvbmFsQW16SGVhZGVycyB8fCB7fTtcbiAgICBjb25zdCByZXF1ZXN0UGF5bG9hZCA9IG9wdGlvbnMucmVxdWVzdFBheWxvYWQgfHwgJyc7XG4gICAgLy8gaWFtLmFtYXpvbmF3cy5jb20gaG9zdCA9PiBpYW0gc2VydmljZS5cbiAgICAvLyBzdHMudXMtZWFzdC0yLmFtYXpvbmF3cy5jb20gPT4gc3RzIHNlcnZpY2UuXG4gICAgY29uc3Qgc2VydmljZU5hbWUgPSBvcHRpb25zLmhvc3Quc3BsaXQoJy4nKVswXTtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIC8vIEZvcm1hdDogJyVZJW0lZFQlSCVNJVNaJy5cbiAgICBjb25zdCBhbXpEYXRlID0gbm93XG4gICAgICAgIC50b0lTT1N0cmluZygpXG4gICAgICAgIC5yZXBsYWNlKC9bLTpdL2csICcnKVxuICAgICAgICAucmVwbGFjZSgvXFwuWzAtOV0rLywgJycpO1xuICAgIC8vIEZvcm1hdDogJyVZJW0lZCcuXG4gICAgY29uc3QgZGF0ZVN0YW1wID0gbm93LnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvWy1dL2csICcnKS5yZXBsYWNlKC9ULiovLCAnJyk7XG4gICAgLy8gQ2hhbmdlIGFsbCBhZGRpdGlvbmFsIGhlYWRlcnMgdG8gYmUgbG93ZXIgY2FzZS5cbiAgICBjb25zdCByZWZvcm1hdHRlZEFkZGl0aW9uYWxBbXpIZWFkZXJzID0ge307XG4gICAgT2JqZWN0LmtleXMoYWRkaXRpb25hbEFtekhlYWRlcnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgcmVmb3JtYXR0ZWRBZGRpdGlvbmFsQW16SGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPVxuICAgICAgICAgICAgYWRkaXRpb25hbEFtekhlYWRlcnNba2V5XTtcbiAgICB9KTtcbiAgICAvLyBBZGQgQVdTIHRva2VuIGlmIGF2YWlsYWJsZS5cbiAgICBpZiAob3B0aW9ucy5zZWN1cml0eUNyZWRlbnRpYWxzLnRva2VuKSB7XG4gICAgICAgIHJlZm9ybWF0dGVkQWRkaXRpb25hbEFtekhlYWRlcnNbJ3gtYW16LXNlY3VyaXR5LXRva2VuJ10gPVxuICAgICAgICAgICAgb3B0aW9ucy5zZWN1cml0eUNyZWRlbnRpYWxzLnRva2VuO1xuICAgIH1cbiAgICAvLyBIZWFkZXIga2V5cyBuZWVkIHRvIGJlIHNvcnRlZCBhbHBoYWJldGljYWxseS5cbiAgICBjb25zdCBhbXpIZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGhvc3Q6IG9wdGlvbnMuaG9zdCxcbiAgICB9LCBcbiAgICAvLyBQcmV2aW91c2x5IHRoZSBkYXRlIHdhcyBub3QgZml4ZWQgd2l0aCB4LWFtei0gYW5kIGNvdWxkIGJlIHByb3ZpZGVkIG1hbnVhbGx5LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ib3RvL2JvdG9jb3JlL2Jsb2IvODc5Zjg0NDBhNGU5YWNlNWQzY2YxNDVjZThiM2Q1ZTVmZmI4OTJlZi90ZXN0cy91bml0L2F1dGgvYXdzNF90ZXN0c3VpdGUvZ2V0LWhlYWRlci12YWx1ZS10cmltLnJlcVxuICAgIHJlZm9ybWF0dGVkQWRkaXRpb25hbEFtekhlYWRlcnMuZGF0ZSA/IHt9IDogeyAneC1hbXotZGF0ZSc6IGFtekRhdGUgfSwgcmVmb3JtYXR0ZWRBZGRpdGlvbmFsQW16SGVhZGVycyk7XG4gICAgbGV0IGNhbm9uaWNhbEhlYWRlcnMgPSAnJztcbiAgICBjb25zdCBzaWduZWRIZWFkZXJzTGlzdCA9IE9iamVjdC5rZXlzKGFtekhlYWRlcnMpLnNvcnQoKTtcbiAgICBzaWduZWRIZWFkZXJzTGlzdC5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGNhbm9uaWNhbEhlYWRlcnMgKz0gYCR7a2V5fToke2FtekhlYWRlcnNba2V5XX1cXG5gO1xuICAgIH0pO1xuICAgIGNvbnN0IHNpZ25lZEhlYWRlcnMgPSBzaWduZWRIZWFkZXJzTGlzdC5qb2luKCc7Jyk7XG4gICAgY29uc3QgcGF5bG9hZEhhc2ggPSBhd2FpdCBvcHRpb25zLmNyeXB0by5zaGEyNTZEaWdlc3RIZXgocmVxdWVzdFBheWxvYWQpO1xuICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9nZW5lcmFsL2xhdGVzdC9nci9zaWd2NC1jcmVhdGUtY2Fub25pY2FsLXJlcXVlc3QuaHRtbFxuICAgIGNvbnN0IGNhbm9uaWNhbFJlcXVlc3QgPSBgJHtvcHRpb25zLm1ldGhvZH1cXG5gICtcbiAgICAgICAgYCR7b3B0aW9ucy5jYW5vbmljYWxVcml9XFxuYCArXG4gICAgICAgIGAke29wdGlvbnMuY2Fub25pY2FsUXVlcnlzdHJpbmd9XFxuYCArXG4gICAgICAgIGAke2Nhbm9uaWNhbEhlYWRlcnN9XFxuYCArXG4gICAgICAgIGAke3NpZ25lZEhlYWRlcnN9XFxuYCArXG4gICAgICAgIGAke3BheWxvYWRIYXNofWA7XG4gICAgY29uc3QgY3JlZGVudGlhbFNjb3BlID0gYCR7ZGF0ZVN0YW1wfS8ke29wdGlvbnMucmVnaW9ufS8ke3NlcnZpY2VOYW1lfS8ke0FXU19SRVFVRVNUX1RZUEV9YDtcbiAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vZ2VuZXJhbC9sYXRlc3QvZ3Ivc2lndjQtY3JlYXRlLXN0cmluZy10by1zaWduLmh0bWxcbiAgICBjb25zdCBzdHJpbmdUb1NpZ24gPSBgJHtBV1NfQUxHT1JJVEhNfVxcbmAgK1xuICAgICAgICBgJHthbXpEYXRlfVxcbmAgK1xuICAgICAgICBgJHtjcmVkZW50aWFsU2NvcGV9XFxuYCArXG4gICAgICAgIChhd2FpdCBvcHRpb25zLmNyeXB0by5zaGEyNTZEaWdlc3RIZXgoY2Fub25pY2FsUmVxdWVzdCkpO1xuICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9nZW5lcmFsL2xhdGVzdC9nci9zaWd2NC1jYWxjdWxhdGUtc2lnbmF0dXJlLmh0bWxcbiAgICBjb25zdCBzaWduaW5nS2V5ID0gYXdhaXQgZ2V0U2lnbmluZ0tleShvcHRpb25zLmNyeXB0bywgb3B0aW9ucy5zZWN1cml0eUNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSwgZGF0ZVN0YW1wLCBvcHRpb25zLnJlZ2lvbiwgc2VydmljZU5hbWUpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ24ob3B0aW9ucy5jcnlwdG8sIHNpZ25pbmdLZXksIHN0cmluZ1RvU2lnbik7XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3NpZ3Y0LWFkZC1zaWduYXR1cmUtdG8tcmVxdWVzdC5odG1sXG4gICAgY29uc3QgYXV0aG9yaXphdGlvbkhlYWRlciA9IGAke0FXU19BTEdPUklUSE19IENyZWRlbnRpYWw9JHtvcHRpb25zLnNlY3VyaXR5Q3JlZGVudGlhbHMuYWNjZXNzS2V5SWR9L2AgK1xuICAgICAgICBgJHtjcmVkZW50aWFsU2NvcGV9LCBTaWduZWRIZWFkZXJzPSR7c2lnbmVkSGVhZGVyc30sIGAgK1xuICAgICAgICBgU2lnbmF0dXJlPSR7KDAsIGNyeXB0b18xLmZyb21BcnJheUJ1ZmZlclRvSGV4KShzaWduYXR1cmUpfWA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gRG8gbm90IHJldHVybiB4LWFtei1kYXRlIGlmIGRhdGUgaXMgYXZhaWxhYmxlLlxuICAgICAgICBhbXpEYXRlOiByZWZvcm1hdHRlZEFkZGl0aW9uYWxBbXpIZWFkZXJzLmRhdGUgPyB1bmRlZmluZWQgOiBhbXpEYXRlLFxuICAgICAgICBhdXRob3JpemF0aW9uSGVhZGVyLFxuICAgICAgICBjYW5vbmljYWxRdWVyeXN0cmluZzogb3B0aW9ucy5jYW5vbmljYWxRdWVyeXN0cmluZyxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXdzcmVxdWVzdHNpZ25lci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBd3NSZXF1ZXN0U2lnbmVyIiwiY3J5cHRvXzEiLCJyZXF1aXJlIiwiQVdTX0FMR09SSVRITSIsIkFXU19SRVFVRVNUX1RZUEUiLCJjb25zdHJ1Y3RvciIsImdldENyZWRlbnRpYWxzIiwicmVnaW9uIiwiY3J5cHRvIiwiY3JlYXRlQ3J5cHRvIiwiZ2V0UmVxdWVzdE9wdGlvbnMiLCJhbXpPcHRpb25zIiwidXJsIiwiRXJyb3IiLCJyZXF1ZXN0UGF5bG9hZERhdGEiLCJkYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1ldGhvZCIsInJlcXVlc3RQYXlsb2FkIiwiYm9keSIsImFkZGl0aW9uYWxBbXpIZWFkZXJzIiwiaGVhZGVycyIsImF3c1NlY3VyaXR5Q3JlZGVudGlhbHMiLCJ1cmkiLCJVUkwiLCJoZWFkZXJNYXAiLCJnZW5lcmF0ZUF1dGhlbnRpY2F0aW9uSGVhZGVyTWFwIiwiaG9zdCIsImNhbm9uaWNhbFVyaSIsInBhdGhuYW1lIiwiY2Fub25pY2FsUXVlcnlzdHJpbmciLCJzZWFyY2giLCJzdWJzdHIiLCJzZWN1cml0eUNyZWRlbnRpYWxzIiwiYXNzaWduIiwiYW16RGF0ZSIsIkF1dGhvcml6YXRpb24iLCJhdXRob3JpemF0aW9uSGVhZGVyIiwidG9rZW4iLCJhd3NTaWduZWRSZXEiLCJzaWduIiwia2V5IiwibXNnIiwic2lnbldpdGhIbWFjU2hhMjU2IiwiZ2V0U2lnbmluZ0tleSIsImRhdGVTdGFtcCIsInNlcnZpY2VOYW1lIiwia0RhdGUiLCJrUmVnaW9uIiwia1NlcnZpY2UiLCJrU2lnbmluZyIsIm9wdGlvbnMiLCJzcGxpdCIsIm5vdyIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInJlcGxhY2UiLCJyZWZvcm1hdHRlZEFkZGl0aW9uYWxBbXpIZWFkZXJzIiwia2V5cyIsImZvckVhY2giLCJ0b0xvd2VyQ2FzZSIsImFtekhlYWRlcnMiLCJkYXRlIiwiY2Fub25pY2FsSGVhZGVycyIsInNpZ25lZEhlYWRlcnNMaXN0Iiwic29ydCIsInNpZ25lZEhlYWRlcnMiLCJqb2luIiwicGF5bG9hZEhhc2giLCJzaGEyNTZEaWdlc3RIZXgiLCJjYW5vbmljYWxSZXF1ZXN0IiwiY3JlZGVudGlhbFNjb3BlIiwic3RyaW5nVG9TaWduIiwic2lnbmluZ0tleSIsInNlY3JldEFjY2Vzc0tleSIsInNpZ25hdHVyZSIsImFjY2Vzc0tleUlkIiwiZnJvbUFycmF5QnVmZmVyVG9IZXgiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/awsrequestsigner.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/baseexternalclient.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BaseExternalAccountClient = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst sts = __webpack_require__(/*! ./stscredentials */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/stscredentials.js\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */ const STS_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:token-exchange\";\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */ const STS_REQUEST_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\";\n/** The default OAuth scope to request when none is provided. */ const DEFAULT_OAUTH_SCOPE = \"https://www.googleapis.com/auth/cloud-platform\";\n/** Default impersonated token lifespan in seconds.*/ const DEFAULT_TOKEN_LIFESPAN = 3600;\n/**\n * Offset to take into account network delays and server clock skews.\n */ exports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * The credentials JSON file type for external account clients.\n * There are 3 types of JSON configs:\n * 1. authorized_user => Google end user credential\n * 2. service_account => Google service account credential\n * 3. external_Account => non-GCP service (eg. AWS, Azure, K8s)\n */ exports.EXTERNAL_ACCOUNT_TYPE = \"external_account\";\n/** Cloud resource manager URL used to retrieve project information. */ exports.CLOUD_RESOURCE_MANAGER = \"https://cloudresourcemanager.googleapis.com/v1/projects/\";\n/** The workforce audience pattern. */ const WORKFORCE_AUDIENCE_PATTERN = \"//iam.googleapis.com/locations/[^/]+/workforcePools/[^/]+/providers/.+\";\n/**\n * Base external account client. This is used to instantiate AuthClients for\n * exchanging external account credentials for GCP access token and authorizing\n * requests to GCP APIs.\n * The base class implements common logic for exchanging various type of\n * external credentials for GCP access token. The logic of determining and\n * retrieving the external credential based on the environment and\n * credential_source will be left for the subclasses.\n */ class BaseExternalAccountClient extends authclient_1.AuthClient {\n    /**\n     * Instantiate a BaseExternalAccountClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     */ constructor(options, additionalOptions){\n        var _a, _b;\n        super();\n        if (options.type !== exports.EXTERNAL_ACCOUNT_TYPE) {\n            throw new Error(`Expected \"${exports.EXTERNAL_ACCOUNT_TYPE}\" type but ` + `received \"${options.type}\"`);\n        }\n        this.clientAuth = options.client_id ? {\n            confidentialClientType: \"basic\",\n            clientId: options.client_id,\n            clientSecret: options.client_secret\n        } : undefined;\n        this.stsCredential = new sts.StsCredentials(options.token_url, this.clientAuth);\n        // Default OAuth scope. This could be overridden via public property.\n        this.scopes = [\n            DEFAULT_OAUTH_SCOPE\n        ];\n        this.cachedAccessToken = null;\n        this.audience = options.audience;\n        this.subjectTokenType = options.subject_token_type;\n        this.quotaProjectId = options.quota_project_id;\n        this.workforcePoolUserProject = options.workforce_pool_user_project;\n        const workforceAudiencePattern = new RegExp(WORKFORCE_AUDIENCE_PATTERN);\n        if (this.workforcePoolUserProject && !this.audience.match(workforceAudiencePattern)) {\n            throw new Error(\"workforcePoolUserProject should not be set for non-workforce pool \" + \"credentials.\");\n        }\n        this.serviceAccountImpersonationUrl = options.service_account_impersonation_url;\n        this.serviceAccountImpersonationLifetime = (_b = (_a = options.service_account_impersonation) === null || _a === void 0 ? void 0 : _a.token_lifetime_seconds) !== null && _b !== void 0 ? _b : DEFAULT_TOKEN_LIFESPAN;\n        // As threshold could be zero,\n        // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n        // zero value.\n        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== \"number\") {\n            this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\n        } else {\n            this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;\n        }\n        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n        this.projectId = null;\n        this.projectNumber = this.getProjectNumber(this.audience);\n        this.universeDomain = options.universe_domain;\n    }\n    /** The service account email to be impersonated, if available. */ getServiceAccountEmail() {\n        var _a;\n        if (this.serviceAccountImpersonationUrl) {\n            // Parse email from URL. The formal looks as follows:\n            // https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/name@project-id.iam.gserviceaccount.com:generateAccessToken\n            const re = /serviceAccounts\\/(?<email>[^:]+):generateAccessToken$/;\n            const result = re.exec(this.serviceAccountImpersonationUrl);\n            return ((_a = result === null || result === void 0 ? void 0 : result.groups) === null || _a === void 0 ? void 0 : _a.email) || null;\n        }\n        return null;\n    }\n    /**\n     * Provides a mechanism to inject GCP access tokens directly.\n     * When the provided credential expires, a new credential, using the\n     * external account options, is retrieved.\n     * @param credentials The Credentials object to set on the current client.\n     */ setCredentials(credentials) {\n        super.setCredentials(credentials);\n        this.cachedAccessToken = credentials;\n    }\n    /**\n     * @return A promise that resolves with the current GCP access token\n     *   response. If the current credential is expired, a new one is retrieved.\n     */ async getAccessToken() {\n        // If cached access token is unavailable or expired, force refresh.\n        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return GCP access token in GetAccessTokenResponse format.\n        return {\n            token: this.cachedAccessToken.access_token,\n            res: this.cachedAccessToken.res\n        };\n    }\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     */ async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then((r)=>callback(null, r), (e)=>{\n                return callback(e, e.response);\n            });\n        } else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * @return A promise that resolves with the project ID corresponding to the\n     *   current workload identity pool or current workforce pool if\n     *   determinable. For workforce pool credential, it returns the project ID\n     *   corresponding to the workforcePoolUserProject.\n     *   This is introduced to match the current pattern of using the Auth\n     *   library:\n     *   const projectId = await auth.getProjectId();\n     *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;\n     *   const res = await client.request({ url });\n     *   The resource may not have permission\n     *   (resourcemanager.projects.get) to call this API or the required\n     *   scopes may not be selected:\n     *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes\n     */ async getProjectId() {\n        const projectNumber = this.projectNumber || this.workforcePoolUserProject;\n        if (this.projectId) {\n            // Return previously determined project ID.\n            return this.projectId;\n        } else if (projectNumber) {\n            // Preferable not to use request() to avoid retrial policies.\n            const headers = await this.getRequestHeaders();\n            const response = await this.transporter.request({\n                headers,\n                url: `${exports.CLOUD_RESOURCE_MANAGER}${projectNumber}`,\n                responseType: \"json\"\n            });\n            this.projectId = response.data.projectId;\n            return this.projectId;\n        }\n        return null;\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param retry Whether the current attempt is a retry after a failed attempt.\n     * @return A promise that resolves with the successful response.\n     */ async requestAsync(opts, retry = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders[\"x-goog-user-project\"]) {\n                opts.headers[\"x-goog-user-project\"] = requestHeaders[\"x-goog-user-project\"];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        } catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * External credentials are exchanged for GCP access tokens via the token\n     * exchange endpoint and other settings provided in the client options\n     * object.\n     * If the service_account_impersonation_url is provided, an additional\n     * step to exchange the external account GCP access token for a service\n     * account impersonated token is performed.\n     * @return A promise that resolves with the fresh GCP access tokens.\n     */ async refreshAccessTokenAsync() {\n        // Retrieve the external credential.\n        const subjectToken = await this.retrieveSubjectToken();\n        // Construct the STS credentials options.\n        const stsCredentialsOptions = {\n            grantType: STS_GRANT_TYPE,\n            audience: this.audience,\n            requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n            subjectToken,\n            subjectTokenType: this.subjectTokenType,\n            // generateAccessToken requires the provided access token to have\n            // scopes:\n            // https://www.googleapis.com/auth/iam or\n            // https://www.googleapis.com/auth/cloud-platform\n            // The new service account access token scopes will match the user\n            // provided ones.\n            scope: this.serviceAccountImpersonationUrl ? [\n                DEFAULT_OAUTH_SCOPE\n            ] : this.getScopesArray()\n        };\n        // Exchange the external credentials for a GCP access token.\n        // Client auth is prioritized over passing the workforcePoolUserProject\n        // parameter for STS token exchange.\n        const additionalOptions = !this.clientAuth && this.workforcePoolUserProject ? {\n            userProject: this.workforcePoolUserProject\n        } : undefined;\n        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, additionalOptions);\n        if (this.serviceAccountImpersonationUrl) {\n            this.cachedAccessToken = await this.getImpersonatedAccessToken(stsResponse.access_token);\n        } else if (stsResponse.expires_in) {\n            // Save response in cached access token.\n            this.cachedAccessToken = {\n                access_token: stsResponse.access_token,\n                expiry_date: new Date().getTime() + stsResponse.expires_in * 1000,\n                res: stsResponse.res\n            };\n        } else {\n            // Save response in cached access token.\n            this.cachedAccessToken = {\n                access_token: stsResponse.access_token,\n                res: stsResponse.res\n            };\n        }\n        // Save credentials.\n        this.credentials = {};\n        Object.assign(this.credentials, this.cachedAccessToken);\n        delete this.credentials.res;\n        // Trigger tokens event to notify external listeners.\n        this.emit(\"tokens\", {\n            refresh_token: null,\n            expiry_date: this.cachedAccessToken.expiry_date,\n            access_token: this.cachedAccessToken.access_token,\n            token_type: \"Bearer\",\n            id_token: null\n        });\n        // Return the cached access token.\n        return this.cachedAccessToken;\n    }\n    /**\n     * Returns the workload identity pool project number if it is determinable\n     * from the audience resource name.\n     * @param audience The STS audience used to determine the project number.\n     * @return The project number associated with the workload identity pool, if\n     *   this can be determined from the STS audience field. Otherwise, null is\n     *   returned.\n     */ getProjectNumber(audience) {\n        // STS audience pattern:\n        // //iam.googleapis.com/projects/$PROJECT_NUMBER/locations/...\n        const match = audience.match(/\\/projects\\/([^/]+)/);\n        if (!match) {\n            return null;\n        }\n        return match[1];\n    }\n    /**\n     * Exchanges an external account GCP access token for a service\n     * account impersonated access token using iamcredentials\n     * GenerateAccessToken API.\n     * @param token The access token to exchange for a service account access\n     *   token.\n     * @return A promise that resolves with the service account impersonated\n     *   credentials response.\n     */ async getImpersonatedAccessToken(token) {\n        const opts = {\n            url: this.serviceAccountImpersonationUrl,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: `Bearer ${token}`\n            },\n            data: {\n                scope: this.getScopesArray(),\n                lifetime: this.serviceAccountImpersonationLifetime + \"s\"\n            },\n            responseType: \"json\"\n        };\n        const response = await this.transporter.request(opts);\n        const successResponse = response.data;\n        return {\n            access_token: successResponse.accessToken,\n            // Convert from ISO format to timestamp.\n            expiry_date: new Date(successResponse.expireTime).getTime(),\n            res: response\n        };\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param accessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */ isExpired(accessToken) {\n        const now = new Date().getTime();\n        return accessToken.expiry_date ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis : false;\n    }\n    /**\n     * @return The list of scopes for the requested GCP access token.\n     */ getScopesArray() {\n        // Since scopes can be provided as string or array, the type should\n        // be normalized.\n        if (typeof this.scopes === \"string\") {\n            return [\n                this.scopes\n            ];\n        } else if (typeof this.scopes === \"undefined\") {\n            return [\n                DEFAULT_OAUTH_SCOPE\n            ];\n        } else {\n            return this.scopes;\n        }\n    }\n}\nexports.BaseExternalAccountClient = BaseExternalAccountClient; //# sourceMappingURL=baseexternalclient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9iYXNlZXh0ZXJuYWxjbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQ0FBaUMsR0FBR0EsOEJBQThCLEdBQUdBLDZCQUE2QixHQUFHQSw4QkFBOEIsR0FBRyxLQUFLO0FBQzNJLE1BQU1NLFNBQVNDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQy9CLE1BQU1DLGVBQWVELG1CQUFPQSxDQUFDLDJGQUFjO0FBQzNDLE1BQU1FLE1BQU1GLG1CQUFPQSxDQUFDLG1HQUFrQjtBQUN0Qzs7Q0FFQyxHQUNELE1BQU1HLGlCQUFpQjtBQUN2Qjs7Q0FFQyxHQUNELE1BQU1DLHlCQUF5QjtBQUMvQiw4REFBOEQsR0FDOUQsTUFBTUMsc0JBQXNCO0FBQzVCLG1EQUFtRCxHQUNuRCxNQUFNQyx5QkFBeUI7QUFDL0I7O0NBRUMsR0FDRGIsOEJBQThCLEdBQUcsSUFBSSxLQUFLO0FBQzFDOzs7Ozs7Q0FNQyxHQUNEQSw2QkFBNkIsR0FBRztBQUNoQyxxRUFBcUUsR0FDckVBLDhCQUE4QixHQUFHO0FBQ2pDLG9DQUFvQyxHQUNwQyxNQUFNYyw2QkFBNkI7QUFDbkM7Ozs7Ozs7O0NBUUMsR0FDRCxNQUFNWixrQ0FBa0NNLGFBQWFPLFVBQVU7SUFDM0Q7Ozs7Ozs7O0tBUUMsR0FDREMsWUFBWUMsT0FBTyxFQUFFQyxpQkFBaUIsQ0FBRTtRQUNwQyxJQUFJQyxJQUFJQztRQUNSLEtBQUs7UUFDTCxJQUFJSCxRQUFRSSxJQUFJ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O1FBQ2hDLE9BQ0s7WUFDRCxPQUFPLElBQUksQ0FBQ3FCLE1BQU07UUFDdEI7SUFDSjtBQUNKO0FBQ0FqQyxpQ0FBaUMsR0FBR0UsMkJBQ3BDLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2Jhc2VleHRlcm5hbGNsaWVudC5qcz82MDczIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQgPSBleHBvcnRzLkNMT1VEX1JFU09VUkNFX01BTkFHRVIgPSBleHBvcnRzLkVYVEVSTkFMX0FDQ09VTlRfVFlQRSA9IGV4cG9ydHMuRVhQSVJBVElPTl9USU1FX09GRlNFVCA9IHZvaWQgMDtcbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCBhdXRoY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoY2xpZW50XCIpO1xuY29uc3Qgc3RzID0gcmVxdWlyZShcIi4vc3RzY3JlZGVudGlhbHNcIik7XG4vKipcbiAqIFRoZSByZXF1aXJlZCB0b2tlbiBleGNoYW5nZSBncmFudF90eXBlOiByZmM4NjkzI3NlY3Rpb24tMi4xXG4gKi9cbmNvbnN0IFNUU19HUkFOVF9UWVBFID0gJ3VybjppZXRmOnBhcmFtczpvYXV0aDpncmFudC10eXBlOnRva2VuLWV4Y2hhbmdlJztcbi8qKlxuICogVGhlIHJlcXVlc3RlZCB0b2tlbiBleGNoYW5nZSByZXF1ZXN0ZWRfdG9rZW5fdHlwZTogcmZjODY5MyNzZWN0aW9uLTIuMVxuICovXG5jb25zdCBTVFNfUkVRVUVTVF9UT0tFTl9UWVBFID0gJ3VybjppZXRmOnBhcmFtczpvYXV0aDp0b2tlbi10eXBlOmFjY2Vzc190b2tlbic7XG4vKiogVGhlIGRlZmF1bHQgT0F1dGggc2NvcGUgdG8gcmVxdWVzdCB3aGVuIG5vbmUgaXMgcHJvdmlkZWQuICovXG5jb25zdCBERUZBVUxUX09BVVRIX1NDT1BFID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2xvdWQtcGxhdGZvcm0nO1xuLyoqIERlZmF1bHQgaW1wZXJzb25hdGVkIHRva2VuIGxpZmVzcGFuIGluIHNlY29uZHMuKi9cbmNvbnN0IERFRkFVTFRfVE9LRU5fTElGRVNQQU4gPSAzNjAwO1xuLyoqXG4gKiBPZmZzZXQgdG8gdGFrZSBpbnRvIGFjY291bnQgbmV0d29yayBkZWxheXMgYW5kIHNlcnZlciBjbG9jayBza2V3cy5cbiAqL1xuZXhwb3J0cy5FWFBJUkFUSU9OX1RJTUVfT0ZGU0VUID0gNSAqIDYwICogMTAwMDtcbi8qKlxuICogVGhlIGNyZWRlbnRpYWxzIEpTT04gZmlsZSB0eXBlIGZvciBleHRlcm5hbCBhY2NvdW50IGNsaWVudHMuXG4gKiBUaGVyZSBhcmUgMyB0eXBlcyBvZiBKU09OIGNvbmZpZ3M6XG4gKiAxLiBhdXRob3JpemVkX3VzZXIgPT4gR29vZ2xlIGVuZCB1c2VyIGNyZWRlbnRpYWxcbiAqIDIuIHNlcnZpY2VfYWNjb3VudCA9PiBHb29nbGUgc2VydmljZSBhY2NvdW50IGNyZWRlbnRpYWxcbiAqIDMuIGV4dGVybmFsX0FjY291bnQgPT4gbm9uLUdDUCBzZXJ2aWNlIChlZy4gQVdTLCBBenVyZSwgSzhzKVxuICovXG5leHBvcnRzLkVYVEVSTkFMX0FDQ09VTlRfVFlQRSA9ICdleHRlcm5hbF9hY2NvdW50Jztcbi8qKiBDbG91ZCByZXNvdXJjZSBtYW5hZ2VyIFVSTCB1c2VkIHRvIHJldHJpZXZlIHByb2plY3QgaW5mb3JtYXRpb24uICovXG5leHBvcnRzLkNMT1VEX1JFU09VUkNFX01BTkFHRVIgPSAnaHR0cHM6Ly9jbG91ZHJlc291cmNlbWFuYWdlci5nb29nbGVhcGlzLmNvbS92MS9wcm9qZWN0cy8nO1xuLyoqIFRoZSB3b3JrZm9yY2UgYXVkaWVuY2UgcGF0dGVybi4gKi9cbmNvbnN0IFdPUktGT1JDRV9BVURJRU5DRV9QQVRURVJOID0gJy8vaWFtLmdvb2dsZWFwaXMuY29tL2xvY2F0aW9ucy9bXi9dKy93b3JrZm9yY2VQb29scy9bXi9dKy9wcm92aWRlcnMvLisnO1xuLyoqXG4gKiBCYXNlIGV4dGVybmFsIGFjY291bnQgY2xpZW50LiBUaGlzIGlzIHVzZWQgdG8gaW5zdGFudGlhdGUgQXV0aENsaWVudHMgZm9yXG4gKiBleGNoYW5naW5nIGV4dGVybmFsIGFjY291bnQgY3JlZGVudGlhbHMgZm9yIEdDUCBhY2Nlc3MgdG9rZW4gYW5kIGF1dGhvcml6aW5nXG4gKiByZXF1ZXN0cyB0byBHQ1AgQVBJcy5cbiAqIFRoZSBiYXNlIGNsYXNzIGltcGxlbWVudHMgY29tbW9uIGxvZ2ljIGZvciBleGNoYW5naW5nIHZhcmlvdXMgdHlwZSBvZlxuICogZXh0ZXJuYWwgY3JlZGVudGlhbHMgZm9yIEdDUCBhY2Nlc3MgdG9rZW4uIFRoZSBsb2dpYyBvZiBkZXRlcm1pbmluZyBhbmRcbiAqIHJldHJpZXZpbmcgdGhlIGV4dGVybmFsIGNyZWRlbnRpYWwgYmFzZWQgb24gdGhlIGVudmlyb25tZW50IGFuZFxuICogY3JlZGVudGlhbF9zb3VyY2Ugd2lsbCBiZSBsZWZ0IGZvciB0aGUgc3ViY2xhc3Nlcy5cbiAqL1xuY2xhc3MgQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCBleHRlbmRzIGF1dGhjbGllbnRfMS5BdXRoQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhIEJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQgaW5zdGFuY2UgdXNpbmcgdGhlIHByb3ZpZGVkIEpTT05cbiAgICAgKiBvYmplY3QgbG9hZGVkIGZyb20gYW4gZXh0ZXJuYWwgYWNjb3VudCBjcmVkZW50aWFscyBmaWxlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBleHRlcm5hbCBhY2NvdW50IG9wdGlvbnMgb2JqZWN0IHR5cGljYWxseSBsb2FkZWRcbiAgICAgKiAgIGZyb20gdGhlIGV4dGVybmFsIGFjY291bnQgSlNPTiBjcmVkZW50aWFsIGZpbGUuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxPcHRpb25zIE9wdGlvbmFsIGFkZGl0aW9uYWwgYmVoYXZpb3IgY3VzdG9taXphdGlvblxuICAgICAqICAgb3B0aW9ucy4gVGhlc2UgY3VycmVudGx5IGN1c3RvbWl6ZSBleHBpcmF0aW9uIHRocmVzaG9sZCB0aW1lIGFuZFxuICAgICAqICAgd2hldGhlciB0byByZXRyeSBvbiA0MDEvNDAzIEFQSSByZXF1ZXN0IGVycm9ycy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAob3B0aW9ucy50eXBlICE9PSBleHBvcnRzLkVYVEVSTkFMX0FDQ09VTlRfVFlQRSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBcIiR7ZXhwb3J0cy5FWFRFUk5BTF9BQ0NPVU5UX1RZUEV9XCIgdHlwZSBidXQgYCArXG4gICAgICAgICAgICAgICAgYHJlY2VpdmVkIFwiJHtvcHRpb25zLnR5cGV9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsaWVudEF1dGggPSBvcHRpb25zLmNsaWVudF9pZFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgY29uZmlkZW50aWFsQ2xpZW50VHlwZTogJ2Jhc2ljJyxcbiAgICAgICAgICAgICAgICBjbGllbnRJZDogb3B0aW9ucy5jbGllbnRfaWQsXG4gICAgICAgICAgICAgICAgY2xpZW50U2VjcmV0OiBvcHRpb25zLmNsaWVudF9zZWNyZXQsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdHNDcmVkZW50aWFsID0gbmV3IHN0cy5TdHNDcmVkZW50aWFscyhvcHRpb25zLnRva2VuX3VybCwgdGhpcy5jbGllbnRBdXRoKTtcbiAgICAgICAgLy8gRGVmYXVsdCBPQXV0aCBzY29wZS4gVGhpcyBjb3VsZCBiZSBvdmVycmlkZGVuIHZpYSBwdWJsaWMgcHJvcGVydHkuXG4gICAgICAgIHRoaXMuc2NvcGVzID0gW0RFRkFVTFRfT0FVVEhfU0NPUEVdO1xuICAgICAgICB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdWRpZW5jZSA9IG9wdGlvbnMuYXVkaWVuY2U7XG4gICAgICAgIHRoaXMuc3ViamVjdFRva2VuVHlwZSA9IG9wdGlvbnMuc3ViamVjdF90b2tlbl90eXBlO1xuICAgICAgICB0aGlzLnF1b3RhUHJvamVjdElkID0gb3B0aW9ucy5xdW90YV9wcm9qZWN0X2lkO1xuICAgICAgICB0aGlzLndvcmtmb3JjZVBvb2xVc2VyUHJvamVjdCA9IG9wdGlvbnMud29ya2ZvcmNlX3Bvb2xfdXNlcl9wcm9qZWN0O1xuICAgICAgICBjb25zdCB3b3JrZm9yY2VBdWRpZW5jZVBhdHRlcm4gPSBuZXcgUmVnRXhwKFdPUktGT1JDRV9BVURJRU5DRV9QQVRURVJOKTtcbiAgICAgICAgaWYgKHRoaXMud29ya2ZvcmNlUG9vbFVzZXJQcm9qZWN0ICYmXG4gICAgICAgICAgICAhdGhpcy5hdWRpZW5jZS5tYXRjaCh3b3JrZm9yY2VBdWRpZW5jZVBhdHRlcm4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dvcmtmb3JjZVBvb2xVc2VyUHJvamVjdCBzaG91bGQgbm90IGJlIHNldCBmb3Igbm9uLXdvcmtmb3JjZSBwb29sICcgK1xuICAgICAgICAgICAgICAgICdjcmVkZW50aWFscy4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcnZpY2VBY2NvdW50SW1wZXJzb25hdGlvblVybCA9XG4gICAgICAgICAgICBvcHRpb25zLnNlcnZpY2VfYWNjb3VudF9pbXBlcnNvbmF0aW9uX3VybDtcbiAgICAgICAgdGhpcy5zZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25MaWZldGltZSA9XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBvcHRpb25zLnNlcnZpY2VfYWNjb3VudF9pbXBlcnNvbmF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9rZW5fbGlmZXRpbWVfc2Vjb25kcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogREVGQVVMVF9UT0tFTl9MSUZFU1BBTjtcbiAgICAgICAgLy8gQXMgdGhyZXNob2xkIGNvdWxkIGJlIHplcm8sXG4gICAgICAgIC8vIGVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyB8fCBFWFBJUkFUSU9OX1RJTUVfT0ZGU0VUIHdpbGwgb3ZlcnJpZGUgdGhlXG4gICAgICAgIC8vIHplcm8gdmFsdWUuXG4gICAgICAgIGlmICh0eXBlb2YgKGFkZGl0aW9uYWxPcHRpb25zID09PSBudWxsIHx8IGFkZGl0aW9uYWxPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZGRpdGlvbmFsT3B0aW9ucy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMpICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgPSBleHBvcnRzLkVYUElSQVRJT05fVElNRV9PRkZTRVQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyA9IGFkZGl0aW9uYWxPcHRpb25zXG4gICAgICAgICAgICAgICAgLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSA9ICEhKGFkZGl0aW9uYWxPcHRpb25zID09PSBudWxsIHx8IGFkZGl0aW9uYWxPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZGRpdGlvbmFsT3B0aW9ucy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUpO1xuICAgICAgICB0aGlzLnByb2plY3RJZCA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvamVjdE51bWJlciA9IHRoaXMuZ2V0UHJvamVjdE51bWJlcih0aGlzLmF1ZGllbmNlKTtcbiAgICAgICAgdGhpcy51bml2ZXJzZURvbWFpbiA9IG9wdGlvbnMudW5pdmVyc2VfZG9tYWluO1xuICAgIH1cbiAgICAvKiogVGhlIHNlcnZpY2UgYWNjb3VudCBlbWFpbCB0byBiZSBpbXBlcnNvbmF0ZWQsIGlmIGF2YWlsYWJsZS4gKi9cbiAgICBnZXRTZXJ2aWNlQWNjb3VudEVtYWlsKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLnNlcnZpY2VBY2NvdW50SW1wZXJzb25hdGlvblVybCkge1xuICAgICAgICAgICAgLy8gUGFyc2UgZW1haWwgZnJvbSBVUkwuIFRoZSBmb3JtYWwgbG9va3MgYXMgZm9sbG93czpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vaWFtY3JlZGVudGlhbHMuZ29vZ2xlYXBpcy5jb20vdjEvcHJvamVjdHMvLS9zZXJ2aWNlQWNjb3VudHMvbmFtZUBwcm9qZWN0LWlkLmlhbS5nc2VydmljZWFjY291bnQuY29tOmdlbmVyYXRlQWNjZXNzVG9rZW5cbiAgICAgICAgICAgIGNvbnN0IHJlID0gL3NlcnZpY2VBY2NvdW50c1xcLyg/PGVtYWlsPlteOl0rKTpnZW5lcmF0ZUFjY2Vzc1Rva2VuJC87XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZS5leGVjKHRoaXMuc2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uVXJsKTtcbiAgICAgICAgICAgIHJldHVybiAoKF9hID0gcmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0Lmdyb3VwcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVtYWlsKSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIG1lY2hhbmlzbSB0byBpbmplY3QgR0NQIGFjY2VzcyB0b2tlbnMgZGlyZWN0bHkuXG4gICAgICogV2hlbiB0aGUgcHJvdmlkZWQgY3JlZGVudGlhbCBleHBpcmVzLCBhIG5ldyBjcmVkZW50aWFsLCB1c2luZyB0aGVcbiAgICAgKiBleHRlcm5hbCBhY2NvdW50IG9wdGlvbnMsIGlzIHJldHJpZXZlZC5cbiAgICAgKiBAcGFyYW0gY3JlZGVudGlhbHMgVGhlIENyZWRlbnRpYWxzIG9iamVjdCB0byBzZXQgb24gdGhlIGN1cnJlbnQgY2xpZW50LlxuICAgICAqL1xuICAgIHNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHN1cGVyLnNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKTtcbiAgICAgICAgdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbiA9IGNyZWRlbnRpYWxzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGN1cnJlbnQgR0NQIGFjY2VzcyB0b2tlblxuICAgICAqICAgcmVzcG9uc2UuIElmIHRoZSBjdXJyZW50IGNyZWRlbnRpYWwgaXMgZXhwaXJlZCwgYSBuZXcgb25lIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBY2Nlc3NUb2tlbigpIHtcbiAgICAgICAgLy8gSWYgY2FjaGVkIGFjY2VzcyB0b2tlbiBpcyB1bmF2YWlsYWJsZSBvciBleHBpcmVkLCBmb3JjZSByZWZyZXNoLlxuICAgICAgICBpZiAoIXRoaXMuY2FjaGVkQWNjZXNzVG9rZW4gfHwgdGhpcy5pc0V4cGlyZWQodGhpcy5jYWNoZWRBY2Nlc3NUb2tlbikpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gR0NQIGFjY2VzcyB0b2tlbiBpbiBHZXRBY2Nlc3NUb2tlblJlc3BvbnNlIGZvcm1hdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRva2VuOiB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgIHJlczogdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbi5yZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtYWluIGF1dGhlbnRpY2F0aW9uIGludGVyZmFjZS4gSXQgdGFrZXMgYW4gb3B0aW9uYWwgdXJsIHdoaWNoIHdoZW5cbiAgICAgKiBwcmVzZW50IGlzIHRoZSBlbmRwb2ludCBiZWluZyBhY2Nlc3NlZCwgYW5kIHJldHVybnMgYSBQcm9taXNlIHdoaWNoXG4gICAgICogcmVzb2x2ZXMgd2l0aCBhdXRob3JpemF0aW9uIGhlYWRlciBmaWVsZHMuXG4gICAgICpcbiAgICAgKiBUaGUgcmVzdWx0IGhhcyB0aGUgZm9ybTpcbiAgICAgKiB7IEF1dGhvcml6YXRpb246ICdCZWFyZXIgPGFjY2Vzc190b2tlbl92YWx1ZT4nIH1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXF1ZXN0SGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5SZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0QWNjZXNzVG9rZW4oKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthY2Nlc3NUb2tlblJlc3BvbnNlLnRva2VufWAsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyhoZWFkZXJzKTtcbiAgICB9XG4gICAgcmVxdWVzdChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFzeW5jKG9wdHMpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByKSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUsIGUucmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QXN5bmMob3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBwcm9qZWN0IElEIGNvcnJlc3BvbmRpbmcgdG8gdGhlXG4gICAgICogICBjdXJyZW50IHdvcmtsb2FkIGlkZW50aXR5IHBvb2wgb3IgY3VycmVudCB3b3JrZm9yY2UgcG9vbCBpZlxuICAgICAqICAgZGV0ZXJtaW5hYmxlLiBGb3Igd29ya2ZvcmNlIHBvb2wgY3JlZGVudGlhbCwgaXQgcmV0dXJucyB0aGUgcHJvamVjdCBJRFxuICAgICAqICAgY29ycmVzcG9uZGluZyB0byB0aGUgd29ya2ZvcmNlUG9vbFVzZXJQcm9qZWN0LlxuICAgICAqICAgVGhpcyBpcyBpbnRyb2R1Y2VkIHRvIG1hdGNoIHRoZSBjdXJyZW50IHBhdHRlcm4gb2YgdXNpbmcgdGhlIEF1dGhcbiAgICAgKiAgIGxpYnJhcnk6XG4gICAgICogICBjb25zdCBwcm9qZWN0SWQgPSBhd2FpdCBhdXRoLmdldFByb2plY3RJZCgpO1xuICAgICAqICAgY29uc3QgdXJsID0gYGh0dHBzOi8vZG5zLmdvb2dsZWFwaXMuY29tL2Rucy92MS9wcm9qZWN0cy8ke3Byb2plY3RJZH1gO1xuICAgICAqICAgY29uc3QgcmVzID0gYXdhaXQgY2xpZW50LnJlcXVlc3QoeyB1cmwgfSk7XG4gICAgICogICBUaGUgcmVzb3VyY2UgbWF5IG5vdCBoYXZlIHBlcm1pc3Npb25cbiAgICAgKiAgIChyZXNvdXJjZW1hbmFnZXIucHJvamVjdHMuZ2V0KSB0byBjYWxsIHRoaXMgQVBJIG9yIHRoZSByZXF1aXJlZFxuICAgICAqICAgc2NvcGVzIG1heSBub3QgYmUgc2VsZWN0ZWQ6XG4gICAgICogICBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vcmVzb3VyY2UtbWFuYWdlci9yZWZlcmVuY2UvcmVzdC92MS9wcm9qZWN0cy9nZXQjYXV0aG9yaXphdGlvbi1zY29wZXNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRQcm9qZWN0SWQoKSB7XG4gICAgICAgIGNvbnN0IHByb2plY3ROdW1iZXIgPSB0aGlzLnByb2plY3ROdW1iZXIgfHwgdGhpcy53b3JrZm9yY2VQb29sVXNlclByb2plY3Q7XG4gICAgICAgIGlmICh0aGlzLnByb2plY3RJZCkge1xuICAgICAgICAgICAgLy8gUmV0dXJuIHByZXZpb3VzbHkgZGV0ZXJtaW5lZCBwcm9qZWN0IElELlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdElkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3ROdW1iZXIpIHtcbiAgICAgICAgICAgIC8vIFByZWZlcmFibGUgbm90IHRvIHVzZSByZXF1ZXN0KCkgdG8gYXZvaWQgcmV0cmlhbCBwb2xpY2llcy5cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCB0aGlzLmdldFJlcXVlc3RIZWFkZXJzKCk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICB1cmw6IGAke2V4cG9ydHMuQ0xPVURfUkVTT1VSQ0VfTUFOQUdFUn0ke3Byb2plY3ROdW1iZXJ9YCxcbiAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wcm9qZWN0SWQgPSByZXNwb25zZS5kYXRhLnByb2plY3RJZDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXV0aGVudGljYXRlcyB0aGUgcHJvdmlkZWQgSFRUUCByZXF1ZXN0LCBwcm9jZXNzZXMgaXQgYW5kIHJlc29sdmVzIHdpdGggdGhlXG4gICAgICogcmV0dXJuZWQgcmVzcG9uc2UuXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIEhUVFAgcmVxdWVzdCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSByZXRyeSBXaGV0aGVyIHRoZSBjdXJyZW50IGF0dGVtcHQgaXMgYSByZXRyeSBhZnRlciBhIGZhaWxlZCBhdHRlbXB0LlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAgICAgKi9cbiAgICBhc3luYyByZXF1ZXN0QXN5bmMob3B0cywgcmV0cnkgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdEhlYWRlcnMoKTtcbiAgICAgICAgICAgIG9wdHMuaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0SGVhZGVycyAmJiByZXF1ZXN0SGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J10gPVxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RIZWFkZXJzICYmIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24pIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gZS5yZXNwb25zZTtcbiAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgICAgICAvLyBSZXRyeSB0aGUgcmVxdWVzdCBmb3IgbWV0YWRhdGEgaWYgdGhlIGZvbGxvd2luZyBjcml0ZXJpYSBhcmUgdHJ1ZTpcbiAgICAgICAgICAgICAgICAvLyAtIFdlIGhhdmVuJ3QgYWxyZWFkeSByZXRyaWVkLiAgSXQgb25seSBtYWtlcyBzZW5zZSB0byByZXRyeSBvbmNlLlxuICAgICAgICAgICAgICAgIC8vIC0gVGhlIHJlc3BvbnNlIHdhcyBhIDQwMSBvciBhIDQwM1xuICAgICAgICAgICAgICAgIC8vIC0gVGhlIHJlcXVlc3QgZGlkbid0IHNlbmQgYSByZWFkYWJsZVN0cmVhbVxuICAgICAgICAgICAgICAgIC8vIC0gZm9yY2VSZWZyZXNoT25GYWlsdXJlIGlzIHRydWVcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlYWRhYmxlU3RyZWFtID0gcmVzLmNvbmZpZy5kYXRhIGluc3RhbmNlb2Ygc3RyZWFtLlJlYWRhYmxlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXV0aEVyciA9IHN0YXR1c0NvZGUgPT09IDQwMSB8fCBzdGF0dXNDb2RlID09PSA0MDM7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXRyeSAmJlxuICAgICAgICAgICAgICAgICAgICBpc0F1dGhFcnIgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzUmVhZGFibGVTdHJlYW0gJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXF1ZXN0QXN5bmMob3B0cywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcmNlcyB0b2tlbiByZWZyZXNoLCBldmVuIGlmIHVuZXhwaXJlZCB0b2tlbnMgYXJlIGN1cnJlbnRseSBjYWNoZWQuXG4gICAgICogRXh0ZXJuYWwgY3JlZGVudGlhbHMgYXJlIGV4Y2hhbmdlZCBmb3IgR0NQIGFjY2VzcyB0b2tlbnMgdmlhIHRoZSB0b2tlblxuICAgICAqIGV4Y2hhbmdlIGVuZHBvaW50IGFuZCBvdGhlciBzZXR0aW5ncyBwcm92aWRlZCBpbiB0aGUgY2xpZW50IG9wdGlvbnNcbiAgICAgKiBvYmplY3QuXG4gICAgICogSWYgdGhlIHNlcnZpY2VfYWNjb3VudF9pbXBlcnNvbmF0aW9uX3VybCBpcyBwcm92aWRlZCwgYW4gYWRkaXRpb25hbFxuICAgICAqIHN0ZXAgdG8gZXhjaGFuZ2UgdGhlIGV4dGVybmFsIGFjY291bnQgR0NQIGFjY2VzcyB0b2tlbiBmb3IgYSBzZXJ2aWNlXG4gICAgICogYWNjb3VudCBpbXBlcnNvbmF0ZWQgdG9rZW4gaXMgcGVyZm9ybWVkLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZnJlc2ggR0NQIGFjY2VzcyB0b2tlbnMuXG4gICAgICovXG4gICAgYXN5bmMgcmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKSB7XG4gICAgICAgIC8vIFJldHJpZXZlIHRoZSBleHRlcm5hbCBjcmVkZW50aWFsLlxuICAgICAgICBjb25zdCBzdWJqZWN0VG9rZW4gPSBhd2FpdCB0aGlzLnJldHJpZXZlU3ViamVjdFRva2VuKCk7XG4gICAgICAgIC8vIENvbnN0cnVjdCB0aGUgU1RTIGNyZWRlbnRpYWxzIG9wdGlvbnMuXG4gICAgICAgIGNvbnN0IHN0c0NyZWRlbnRpYWxzT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGdyYW50VHlwZTogU1RTX0dSQU5UX1RZUEUsXG4gICAgICAgICAgICBhdWRpZW5jZTogdGhpcy5hdWRpZW5jZSxcbiAgICAgICAgICAgIHJlcXVlc3RlZFRva2VuVHlwZTogU1RTX1JFUVVFU1RfVE9LRU5fVFlQRSxcbiAgICAgICAgICAgIHN1YmplY3RUb2tlbixcbiAgICAgICAgICAgIHN1YmplY3RUb2tlblR5cGU6IHRoaXMuc3ViamVjdFRva2VuVHlwZSxcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlQWNjZXNzVG9rZW4gcmVxdWlyZXMgdGhlIHByb3ZpZGVkIGFjY2VzcyB0b2tlbiB0byBoYXZlXG4gICAgICAgICAgICAvLyBzY29wZXM6XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2lhbSBvclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9jbG91ZC1wbGF0Zm9ybVxuICAgICAgICAgICAgLy8gVGhlIG5ldyBzZXJ2aWNlIGFjY291bnQgYWNjZXNzIHRva2VuIHNjb3BlcyB3aWxsIG1hdGNoIHRoZSB1c2VyXG4gICAgICAgICAgICAvLyBwcm92aWRlZCBvbmVzLlxuICAgICAgICAgICAgc2NvcGU6IHRoaXMuc2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uVXJsXG4gICAgICAgICAgICAgICAgPyBbREVGQVVMVF9PQVVUSF9TQ09QRV1cbiAgICAgICAgICAgICAgICA6IHRoaXMuZ2V0U2NvcGVzQXJyYXkoKSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRXhjaGFuZ2UgdGhlIGV4dGVybmFsIGNyZWRlbnRpYWxzIGZvciBhIEdDUCBhY2Nlc3MgdG9rZW4uXG4gICAgICAgIC8vIENsaWVudCBhdXRoIGlzIHByaW9yaXRpemVkIG92ZXIgcGFzc2luZyB0aGUgd29ya2ZvcmNlUG9vbFVzZXJQcm9qZWN0XG4gICAgICAgIC8vIHBhcmFtZXRlciBmb3IgU1RTIHRva2VuIGV4Y2hhbmdlLlxuICAgICAgICBjb25zdCBhZGRpdGlvbmFsT3B0aW9ucyA9ICF0aGlzLmNsaWVudEF1dGggJiYgdGhpcy53b3JrZm9yY2VQb29sVXNlclByb2plY3RcbiAgICAgICAgICAgID8geyB1c2VyUHJvamVjdDogdGhpcy53b3JrZm9yY2VQb29sVXNlclByb2plY3QgfVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHN0c1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5zdHNDcmVkZW50aWFsLmV4Y2hhbmdlVG9rZW4oc3RzQ3JlZGVudGlhbHNPcHRpb25zLCB1bmRlZmluZWQsIGFkZGl0aW9uYWxPcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuc2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uVXJsKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuID0gYXdhaXQgdGhpcy5nZXRJbXBlcnNvbmF0ZWRBY2Nlc3NUb2tlbihzdHNSZXNwb25zZS5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0c1Jlc3BvbnNlLmV4cGlyZXNfaW4pIHtcbiAgICAgICAgICAgIC8vIFNhdmUgcmVzcG9uc2UgaW4gY2FjaGVkIGFjY2VzcyB0b2tlbi5cbiAgICAgICAgICAgIHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4gPSB7XG4gICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiBzdHNSZXNwb25zZS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgZXhwaXJ5X2RhdGU6IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgc3RzUmVzcG9uc2UuZXhwaXJlc19pbiAqIDEwMDAsXG4gICAgICAgICAgICAgICAgcmVzOiBzdHNSZXNwb25zZS5yZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU2F2ZSByZXNwb25zZSBpbiBjYWNoZWQgYWNjZXNzIHRva2VuLlxuICAgICAgICAgICAgdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbiA9IHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW46IHN0c1Jlc3BvbnNlLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICByZXM6IHN0c1Jlc3BvbnNlLnJlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2F2ZSBjcmVkZW50aWFscy5cbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuY3JlZGVudGlhbHMsIHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4pO1xuICAgICAgICBkZWxldGUgdGhpcy5jcmVkZW50aWFscy5yZXM7XG4gICAgICAgIC8vIFRyaWdnZXIgdG9rZW5zIGV2ZW50IHRvIG5vdGlmeSBleHRlcm5hbCBsaXN0ZW5lcnMuXG4gICAgICAgIHRoaXMuZW1pdCgndG9rZW5zJywge1xuICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogbnVsbCxcbiAgICAgICAgICAgIGV4cGlyeV9kYXRlOiB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuLmV4cGlyeV9kYXRlLFxuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgIHRva2VuX3R5cGU6ICdCZWFyZXInLFxuICAgICAgICAgICAgaWRfdG9rZW46IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGNhY2hlZCBhY2Nlc3MgdG9rZW4uXG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3b3JrbG9hZCBpZGVudGl0eSBwb29sIHByb2plY3QgbnVtYmVyIGlmIGl0IGlzIGRldGVybWluYWJsZVxuICAgICAqIGZyb20gdGhlIGF1ZGllbmNlIHJlc291cmNlIG5hbWUuXG4gICAgICogQHBhcmFtIGF1ZGllbmNlIFRoZSBTVFMgYXVkaWVuY2UgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHByb2plY3QgbnVtYmVyLlxuICAgICAqIEByZXR1cm4gVGhlIHByb2plY3QgbnVtYmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgd29ya2xvYWQgaWRlbnRpdHkgcG9vbCwgaWZcbiAgICAgKiAgIHRoaXMgY2FuIGJlIGRldGVybWluZWQgZnJvbSB0aGUgU1RTIGF1ZGllbmNlIGZpZWxkLiBPdGhlcndpc2UsIG51bGwgaXNcbiAgICAgKiAgIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldFByb2plY3ROdW1iZXIoYXVkaWVuY2UpIHtcbiAgICAgICAgLy8gU1RTIGF1ZGllbmNlIHBhdHRlcm46XG4gICAgICAgIC8vIC8vaWFtLmdvb2dsZWFwaXMuY29tL3Byb2plY3RzLyRQUk9KRUNUX05VTUJFUi9sb2NhdGlvbnMvLi4uXG4gICAgICAgIGNvbnN0IG1hdGNoID0gYXVkaWVuY2UubWF0Y2goL1xcL3Byb2plY3RzXFwvKFteL10rKS8pO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2hbMV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4Y2hhbmdlcyBhbiBleHRlcm5hbCBhY2NvdW50IEdDUCBhY2Nlc3MgdG9rZW4gZm9yIGEgc2VydmljZVxuICAgICAqIGFjY291bnQgaW1wZXJzb25hdGVkIGFjY2VzcyB0b2tlbiB1c2luZyBpYW1jcmVkZW50aWFsc1xuICAgICAqIEdlbmVyYXRlQWNjZXNzVG9rZW4gQVBJLlxuICAgICAqIEBwYXJhbSB0b2tlbiBUaGUgYWNjZXNzIHRva2VuIHRvIGV4Y2hhbmdlIGZvciBhIHNlcnZpY2UgYWNjb3VudCBhY2Nlc3NcbiAgICAgKiAgIHRva2VuLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgc2VydmljZSBhY2NvdW50IGltcGVyc29uYXRlZFxuICAgICAqICAgY3JlZGVudGlhbHMgcmVzcG9uc2UuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SW1wZXJzb25hdGVkQWNjZXNzVG9rZW4odG9rZW4pIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIHVybDogdGhpcy5zZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25VcmwsXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBzY29wZTogdGhpcy5nZXRTY29wZXNBcnJheSgpLFxuICAgICAgICAgICAgICAgIGxpZmV0aW1lOiB0aGlzLnNlcnZpY2VBY2NvdW50SW1wZXJzb25hdGlvbkxpZmV0aW1lICsgJ3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgY29uc3Qgc3VjY2Vzc1Jlc3BvbnNlID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogc3VjY2Vzc1Jlc3BvbnNlLmFjY2Vzc1Rva2VuLFxuICAgICAgICAgICAgLy8gQ29udmVydCBmcm9tIElTTyBmb3JtYXQgdG8gdGltZXN0YW1wLlxuICAgICAgICAgICAgZXhwaXJ5X2RhdGU6IG5ldyBEYXRlKHN1Y2Nlc3NSZXNwb25zZS5leHBpcmVUaW1lKS5nZXRUaW1lKCksXG4gICAgICAgICAgICByZXM6IHJlc3BvbnNlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGNyZWRlbnRpYWxzIGFyZSBleHBpcmVkIG9yIG5vdC5cbiAgICAgKiBJZiB0aGVyZSBpcyBubyBleHBpcnkgdGltZSwgYXNzdW1lcyB0aGUgdG9rZW4gaXMgbm90IGV4cGlyZWQgb3IgZXhwaXJpbmcuXG4gICAgICogQHBhcmFtIGFjY2Vzc1Rva2VuIFRoZSBjcmVkZW50aWFscyB0byBjaGVjayBmb3IgZXhwaXJhdGlvbi5cbiAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhlIGNyZWRlbnRpYWxzIGFyZSBleHBpcmVkIG9yIG5vdC5cbiAgICAgKi9cbiAgICBpc0V4cGlyZWQoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHJldHVybiBhY2Nlc3NUb2tlbi5leHBpcnlfZGF0ZVxuICAgICAgICAgICAgPyBub3cgPj0gYWNjZXNzVG9rZW4uZXhwaXJ5X2RhdGUgLSB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpc1xuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiBUaGUgbGlzdCBvZiBzY29wZXMgZm9yIHRoZSByZXF1ZXN0ZWQgR0NQIGFjY2VzcyB0b2tlbi5cbiAgICAgKi9cbiAgICBnZXRTY29wZXNBcnJheSgpIHtcbiAgICAgICAgLy8gU2luY2Ugc2NvcGVzIGNhbiBiZSBwcm92aWRlZCBhcyBzdHJpbmcgb3IgYXJyYXksIHRoZSB0eXBlIHNob3VsZFxuICAgICAgICAvLyBiZSBub3JtYWxpemVkLlxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2NvcGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnNjb3Blc107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuc2NvcGVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIFtERUZBVUxUX09BVVRIX1NDT1BFXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjb3BlcztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCA9IEJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlZXh0ZXJuYWxjbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCIsIkNMT1VEX1JFU09VUkNFX01BTkFHRVIiLCJFWFRFUk5BTF9BQ0NPVU5UX1RZUEUiLCJFWFBJUkFUSU9OX1RJTUVfT0ZGU0VUIiwic3RyZWFtIiwicmVxdWlyZSIsImF1dGhjbGllbnRfMSIsInN0cyIsIlNUU19HUkFOVF9UWVBFIiwiU1RTX1JFUVVFU1RfVE9LRU5fVFlQRSIsIkRFRkFVTFRfT0FVVEhfU0NPUEUiLCJERUZBVUxUX1RPS0VOX0xJRkVTUEFOIiwiV09SS0ZPUkNFX0FVRElFTkNFX1BBVFRFUk4iLCJBdXRoQ2xpZW50IiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiYWRkaXRpb25hbE9wdGlvbnMiLCJfYSIsIl9iIiwidHlwZSIsIkVycm9yIiwiY2xpZW50QXV0aCIsImNsaWVudF9pZCIsImNvbmZpZGVudGlhbENsaWVudFR5cGUiLCJjbGllbnRJZCIsImNsaWVudFNlY3JldCIsImNsaWVudF9zZWNyZXQiLCJ1bmRlZmluZWQiLCJzdHNDcmVkZW50aWFsIiwiU3RzQ3JlZGVudGlhbHMiLCJ0b2tlbl91cmwiLCJzY29wZXMiLCJjYWNoZWRBY2Nlc3NUb2tlbiIsImF1ZGllbmNlIiwic3ViamVjdFRva2VuVHlwZSIsInN1YmplY3RfdG9rZW5fdHlwZSIsInF1b3RhUHJvamVjdElkIiwicXVvdGFfcHJvamVjdF9pZCIsIndvcmtmb3JjZVBvb2xVc2VyUHJvamVjdCIsIndvcmtmb3JjZV9wb29sX3VzZXJfcHJvamVjdCIsIndvcmtmb3JjZUF1ZGllbmNlUGF0dGVybiIsIlJlZ0V4cCIsIm1hdGNoIiwic2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uVXJsIiwic2VydmljZV9hY2NvdW50X2ltcGVyc29uYXRpb25fdXJsIiwic2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uTGlmZXRpbWUiLCJzZXJ2aWNlX2FjY291bnRfaW1wZXJzb25hdGlvbiIsInRva2VuX2xpZmV0aW1lX3NlY29uZHMiLCJlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMiLCJmb3JjZVJlZnJlc2hPbkZhaWx1cmUiLCJwcm9qZWN0SWQiLCJwcm9qZWN0TnVtYmVyIiwiZ2V0UHJvamVjdE51bWJlciIsInVuaXZlcnNlRG9tYWluIiwidW5pdmVyc2VfZG9tYWluIiwiZ2V0U2VydmljZUFjY291bnRFbWFpbCIsInJlIiwicmVzdWx0IiwiZXhlYyIsImdyb3VwcyIsImVtYWlsIiwic2V0Q3JlZGVudGlhbHMiLCJjcmVkZW50aWFscyIsImdldEFjY2Vzc1Rva2VuIiwiaXNFeHBpcmVkIiwicmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMiLCJ0b2tlbiIsImFjY2Vzc190b2tlbiIsInJlcyIsImdldFJlcXVlc3RIZWFkZXJzIiwiYWNjZXNzVG9rZW5SZXNwb25zZSIsImhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwiYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzIiwicmVxdWVzdCIsIm9wdHMiLCJjYWxsYmFjayIsInJlcXVlc3RBc3luYyIsInRoZW4iLCJyIiwiZSIsInJlc3BvbnNlIiwiZ2V0UHJvamVjdElkIiwidHJhbnNwb3J0ZXIiLCJ1cmwiLCJyZXNwb25zZVR5cGUiLCJkYXRhIiwicmV0cnkiLCJyZXF1ZXN0SGVhZGVycyIsInN0YXR1c0NvZGUiLCJzdGF0dXMiLCJpc1JlYWRhYmxlU3RyZWFtIiwiY29uZmlnIiwiUmVhZGFibGUiLCJpc0F1dGhFcnIiLCJzdWJqZWN0VG9rZW4iLCJyZXRyaWV2ZVN1YmplY3RUb2tlbiIsInN0c0NyZWRlbnRpYWxzT3B0aW9ucyIsImdyYW50VHlwZSIsInJlcXVlc3RlZFRva2VuVHlwZSIsInNjb3BlIiwiZ2V0U2NvcGVzQXJyYXkiLCJ1c2VyUHJvamVjdCIsInN0c1Jlc3BvbnNlIiwiZXhjaGFuZ2VUb2tlbiIsImdldEltcGVyc29uYXRlZEFjY2Vzc1Rva2VuIiwiZXhwaXJlc19pbiIsImV4cGlyeV9kYXRlIiwiRGF0ZSIsImdldFRpbWUiLCJhc3NpZ24iLCJlbWl0IiwicmVmcmVzaF90b2tlbiIsInRva2VuX3R5cGUiLCJpZF90b2tlbiIsIm1ldGhvZCIsImxpZmV0aW1lIiwic3VjY2Vzc1Jlc3BvbnNlIiwiYWNjZXNzVG9rZW4iLCJleHBpcmVUaW1lIiwibm93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/computeclient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/computeclient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2013 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Compute = void 0;\nconst arrify = __webpack_require__(/*! arrify */ \"(rsc)/./node_modules/arrify/index.js\");\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nconst gcpMetadata = __webpack_require__(/*! gcp-metadata */ \"(rsc)/./node_modules/gcp-metadata/build/src/index.js\");\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nclass Compute extends oauth2client_1.OAuth2Client {\n    /**\n     * Google Compute Engine service account credentials.\n     *\n     * Retrieve access token from the metadata server.\n     * See: https://developers.google.com/compute/docs/authentication\n     */ constructor(options = {}){\n        super(options);\n        // Start with an expired refresh token, which will automatically be\n        // refreshed before the first API call is made.\n        this.credentials = {\n            expiry_date: 1,\n            refresh_token: \"compute-placeholder\"\n        };\n        this.serviceAccountEmail = options.serviceAccountEmail || \"default\";\n        this.scopes = arrify(options.scopes);\n    }\n    /**\n     * Refreshes the access token.\n     * @param refreshToken Unused parameter\n     */ async refreshTokenNoCache(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refreshToken) {\n        const tokenPath = `service-accounts/${this.serviceAccountEmail}/token`;\n        let data;\n        try {\n            const instanceOptions = {\n                property: tokenPath\n            };\n            if (this.scopes.length > 0) {\n                instanceOptions.params = {\n                    scopes: this.scopes.join(\",\")\n                };\n            }\n            data = await gcpMetadata.instance(instanceOptions);\n        } catch (e) {\n            if (e instanceof gaxios_1.GaxiosError) {\n                e.message = `Could not refresh access token: ${e.message}`;\n                this.wrapError(e);\n            }\n            throw e;\n        }\n        const tokens = data;\n        if (data && data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit(\"tokens\", tokens);\n        return {\n            tokens,\n            res: null\n        };\n    }\n    /**\n     * Fetches an ID token.\n     * @param targetAudience the audience for the fetched ID token.\n     */ async fetchIdToken(targetAudience) {\n        const idTokenPath = `service-accounts/${this.serviceAccountEmail}/identity` + `?format=full&audience=${targetAudience}`;\n        let idToken;\n        try {\n            const instanceOptions = {\n                property: idTokenPath\n            };\n            idToken = await gcpMetadata.instance(instanceOptions);\n        } catch (e) {\n            if (e instanceof Error) {\n                e.message = `Could not fetch ID token: ${e.message}`;\n            }\n            throw e;\n        }\n        return idToken;\n    }\n    wrapError(e) {\n        const res = e.response;\n        if (res && res.status) {\n            e.code = res.status.toString();\n            if (res.status === 403) {\n                e.message = \"A Forbidden error was returned while attempting to retrieve an access \" + \"token for the Compute Engine built-in service account. This may be because the Compute \" + \"Engine instance does not have the correct permission scopes specified: \" + e.message;\n            } else if (res.status === 404) {\n                e.message = \"A Not Found error was returned while attempting to retrieve an access\" + \"token for the Compute Engine built-in service account. This may be because the Compute \" + \"Engine instance does not have any permission scopes specified: \" + e.message;\n            }\n        }\n    }\n}\nexports.Compute = Compute; //# sourceMappingURL=computeclient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9jb21wdXRlY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZUFBZSxHQUFHLEtBQUs7QUFDdkIsTUFBTUcsU0FBU0MsbUJBQU9BLENBQUMsb0RBQVE7QUFDL0IsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsOERBQVE7QUFDakMsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsMEVBQWM7QUFDMUMsTUFBTUcsaUJBQWlCSCxtQkFBT0EsQ0FBQywrRkFBZ0I7QUFDL0MsTUFBTUYsZ0JBQWdCSyxlQUFlQyxZQUFZO0lBQzdDOzs7OztLQUtDLEdBQ0RDLFlBQVlDLFVBQVUsQ0FBQyxDQUFDLENBQUU7UUFDdEIsS0FBSyxDQUFDQTtRQUNOLG1FQUFtRTtRQUNuRSwrQ0FBK0M7UUFDL0MsSUFBSSxDQUFDQyxXQUFXLEdBQUc7WUFBRUMsYUFBYTtZQUFHQyxlQUFlO1FBQXNCO1FBQzFFLElBQUksQ0FBQ0MsbUJBQW1CLEdBQUdKLFFBQVFJLG1CQUFtQixJQUFJO1FBQzFELElBQUksQ0FBQ0MsTUFBTSxHQUFHWixPQUFPTyxRQUFRSyxNQUFNO0lBQ3ZDO0lBQ0E7OztLQUdDLEdBQ0QsTUFBTUMsb0JBQ04sNkRBQTZEO0lBQzdEQyxZQUFZLEVBQUU7UUFDVixNQUFNQyxZQUFZLENBQUMsaUJBQWlCLEVBQUUsSUFBSSxDQUFDSixtQkFBbUIsQ0FBQyxNQUFNLENBQUM7UUFDdEUsSUFBSUs7UUFDSixJQUFJO1lBQ0EsTUFBTUMsa0JBQWtCO2dCQUNwQkMsVUFBVUg7WUFDZDtZQUNBLElBQUksSUFBSSxDQUFDSCxNQUFNLENBQUNPLE1BQU0sR0FBRyxHQUFHO2dCQUN4QkYsZ0JBQWdCRyxNQUFNLEdBQUc7b0JBQ3JCUixRQUFRLElBQUksQ0FBQ0EsTUFBTSxDQUFDUyxJQUFJLENBQUM7Z0JBQzdCO1lBQ0o7WUFDQUwsT0FBTyxNQUFNYixZQUFZbUIsUUFBUSxDQUFDTDtRQUN0QyxFQUNBLE9BQU9NLEdBQUc7WUFDTixJQUFJQSxhQUFhckIsU0FBU3NCLFdBQVcsRUFBRTtnQkFDbkNELEVBQUVFLE9BQU8sR0FBRyxDQUFDLGdDQUFnQyxFQUFFRixFQUFFRSxPQUFPLENBQUMsQ0FBQztnQkFDMUQsSUFBSSxDQUFDQyxTQUFTLENBQUNIO1lBQ25CO1lBQ0EsTUFBTUE7UUFDVjtRQUNBLE1BQU1JLFNBQVNYO1FBQ2YsSUFBSUEsUUFBUUEsS0FBS1ksVUFBVSxFQUFFO1lBQ3pCRCxPQUFPbEIsV0FBVyxHQUFHLElBQUlvQixPQUFPQyxPQUFPLEtBQUtkLEtBQUtZLFVBQVUsR0FBRztZQUM5RCxPQUFPRCxPQUFPQyxVQUFVO1FBQzVCO1FBQ0EsSUFBSSxDQUFDRyxJQUFJLENBQUMsVUFBVUo7UUFDcEIsT0FBTztZQUFFQTtZQUFRSyxLQUFLO1FBQUs7SUFDL0I7SUFDQTs7O0tBR0MsR0FDRCxNQUFNQyxhQUFhQyxjQUFjLEVBQUU7UUFDL0IsTUFBTUMsY0FBYyxDQUFDLGlCQUFpQixFQUFFLElBQUksQ0FBQ3hCLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxHQUN2RSxDQUFDLHNCQUFzQixFQUFFdUIsZUFBZSxDQUFDO1FBQzdDLElBQUlFO1FBQ0osSUFBSTtZQUNBLE1BQU1uQixrQkFBa0I7Z0JBQ3BCQyxVQUFVaUI7WUFDZDtZQUNBQyxVQUFVLE1BQU1qQyxZQUFZbUIsUUFBUSxDQUFDTDtRQUN6QyxFQUNBLE9BQU9NLEdBQUc7WUFDTixJQUFJQSxhQUFhYyxPQUFPO2dCQUNwQmQsRUFBRUUsT0FBTyxHQUFHLENBQUMsMEJBQTBCLEVBQUVGLEVBQUVFLE9BQU8sQ0FBQyxDQUFDO1lBQ3hEO1lBQ0EsTUFBTUY7UUFDVjtRQUNBLE9BQU9hO0lBQ1g7SUFDQVYsVUFBVUgsQ0FBQyxFQUFFO1FBQ1QsTUFBTVMsTUFBTVQsRUFBRWUsUUFBUTtRQUN0QixJQUFJTixPQUFPQSxJQUFJTyxNQUFNLEVBQUU7WUFDbkJoQixFQUFFaUIsSUFBSSxHQUFHUixJQUFJTyxNQUFNLENBQUNFLFFBQVE7WUFDNUIsSUFBSVQsSUFBSU8sTUFBTSxLQUFLLEtBQUs7Z0JBQ3BCaEIsRUFBRUUsT0FBTyxHQUNMLDJFQUNJLDRGQUNBLDRFQUNBRixFQUFFRSxPQUFPO1lBQ3JCLE9BQ0ssSUFBSU8sSUFBSU8sTUFBTSxLQUFLLEtBQUs7Z0JBQ3pCaEIsRUFBRUUsT0FBTyxHQUNMLDBFQUNJLDRGQUNBLG9FQUNBRixFQUFFRSxPQUFPO1lBQ3JCO1FBQ0o7SUFDSjtBQUNKO0FBQ0E1QixlQUFlLEdBQUdFLFNBQ2xCLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2NvbXB1dGVjbGllbnQuanM/NjNmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDEzIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21wdXRlID0gdm9pZCAwO1xuY29uc3QgYXJyaWZ5ID0gcmVxdWlyZShcImFycmlmeVwiKTtcbmNvbnN0IGdheGlvc18xID0gcmVxdWlyZShcImdheGlvc1wiKTtcbmNvbnN0IGdjcE1ldGFkYXRhID0gcmVxdWlyZShcImdjcC1tZXRhZGF0YVwiKTtcbmNvbnN0IG9hdXRoMmNsaWVudF8xID0gcmVxdWlyZShcIi4vb2F1dGgyY2xpZW50XCIpO1xuY2xhc3MgQ29tcHV0ZSBleHRlbmRzIG9hdXRoMmNsaWVudF8xLk9BdXRoMkNsaWVudCB7XG4gICAgLyoqXG4gICAgICogR29vZ2xlIENvbXB1dGUgRW5naW5lIHNlcnZpY2UgYWNjb3VudCBjcmVkZW50aWFscy5cbiAgICAgKlxuICAgICAqIFJldHJpZXZlIGFjY2VzcyB0b2tlbiBmcm9tIHRoZSBtZXRhZGF0YSBzZXJ2ZXIuXG4gICAgICogU2VlOiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9jb21wdXRlL2RvY3MvYXV0aGVudGljYXRpb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIC8vIFN0YXJ0IHdpdGggYW4gZXhwaXJlZCByZWZyZXNoIHRva2VuLCB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgYmVcbiAgICAgICAgLy8gcmVmcmVzaGVkIGJlZm9yZSB0aGUgZmlyc3QgQVBJIGNhbGwgaXMgbWFkZS5cbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHsgZXhwaXJ5X2RhdGU6IDEsIHJlZnJlc2hfdG9rZW46ICdjb21wdXRlLXBsYWNlaG9sZGVyJyB9O1xuICAgICAgICB0aGlzLnNlcnZpY2VBY2NvdW50RW1haWwgPSBvcHRpb25zLnNlcnZpY2VBY2NvdW50RW1haWwgfHwgJ2RlZmF1bHQnO1xuICAgICAgICB0aGlzLnNjb3BlcyA9IGFycmlmeShvcHRpb25zLnNjb3Blcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZnJlc2hlcyB0aGUgYWNjZXNzIHRva2VuLlxuICAgICAqIEBwYXJhbSByZWZyZXNoVG9rZW4gVW51c2VkIHBhcmFtZXRlclxuICAgICAqL1xuICAgIGFzeW5jIHJlZnJlc2hUb2tlbk5vQ2FjaGUoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHJlZnJlc2hUb2tlbikge1xuICAgICAgICBjb25zdCB0b2tlblBhdGggPSBgc2VydmljZS1hY2NvdW50cy8ke3RoaXMuc2VydmljZUFjY291bnRFbWFpbH0vdG9rZW5gO1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogdG9rZW5QYXRoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjb3Blcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VPcHRpb25zLnBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVzOiB0aGlzLnNjb3Blcy5qb2luKCcsJyksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEgPSBhd2FpdCBnY3BNZXRhZGF0YS5pbnN0YW5jZShpbnN0YW5jZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIGdheGlvc18xLkdheGlvc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gYENvdWxkIG5vdCByZWZyZXNoIGFjY2VzcyB0b2tlbjogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICB0aGlzLndyYXBFcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9rZW5zID0gZGF0YTtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5leHBpcmVzX2luKSB7XG4gICAgICAgICAgICB0b2tlbnMuZXhwaXJ5X2RhdGUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIGRhdGEuZXhwaXJlc19pbiAqIDEwMDA7XG4gICAgICAgICAgICBkZWxldGUgdG9rZW5zLmV4cGlyZXNfaW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCd0b2tlbnMnLCB0b2tlbnMpO1xuICAgICAgICByZXR1cm4geyB0b2tlbnMsIHJlczogbnVsbCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGFuIElEIHRva2VuLlxuICAgICAqIEBwYXJhbSB0YXJnZXRBdWRpZW5jZSB0aGUgYXVkaWVuY2UgZm9yIHRoZSBmZXRjaGVkIElEIHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoSWRUb2tlbih0YXJnZXRBdWRpZW5jZSkge1xuICAgICAgICBjb25zdCBpZFRva2VuUGF0aCA9IGBzZXJ2aWNlLWFjY291bnRzLyR7dGhpcy5zZXJ2aWNlQWNjb3VudEVtYWlsfS9pZGVudGl0eWAgK1xuICAgICAgICAgICAgYD9mb3JtYXQ9ZnVsbCZhdWRpZW5jZT0ke3RhcmdldEF1ZGllbmNlfWA7XG4gICAgICAgIGxldCBpZFRva2VuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2VPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5OiBpZFRva2VuUGF0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZFRva2VuID0gYXdhaXQgZ2NwTWV0YWRhdGEuaW5zdGFuY2UoaW5zdGFuY2VPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IGBDb3VsZCBub3QgZmV0Y2ggSUQgdG9rZW46ICR7ZS5tZXNzYWdlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZFRva2VuO1xuICAgIH1cbiAgICB3cmFwRXJyb3IoZSkge1xuICAgICAgICBjb25zdCByZXMgPSBlLnJlc3BvbnNlO1xuICAgICAgICBpZiAocmVzICYmIHJlcy5zdGF0dXMpIHtcbiAgICAgICAgICAgIGUuY29kZSA9IHJlcy5zdGF0dXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgICAgICAnQSBGb3JiaWRkZW4gZXJyb3Igd2FzIHJldHVybmVkIHdoaWxlIGF0dGVtcHRpbmcgdG8gcmV0cmlldmUgYW4gYWNjZXNzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3Rva2VuIGZvciB0aGUgQ29tcHV0ZSBFbmdpbmUgYnVpbHQtaW4gc2VydmljZSBhY2NvdW50LiBUaGlzIG1heSBiZSBiZWNhdXNlIHRoZSBDb21wdXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0VuZ2luZSBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIHRoZSBjb3JyZWN0IHBlcm1pc3Npb24gc2NvcGVzIHNwZWNpZmllZDogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBlLm1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXMuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgICAgICAnQSBOb3QgRm91bmQgZXJyb3Igd2FzIHJldHVybmVkIHdoaWxlIGF0dGVtcHRpbmcgdG8gcmV0cmlldmUgYW4gYWNjZXNzJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAndG9rZW4gZm9yIHRoZSBDb21wdXRlIEVuZ2luZSBidWlsdC1pbiBzZXJ2aWNlIGFjY291bnQuIFRoaXMgbWF5IGJlIGJlY2F1c2UgdGhlIENvbXB1dGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnRW5naW5lIGluc3RhbmNlIGRvZXMgbm90IGhhdmUgYW55IHBlcm1pc3Npb24gc2NvcGVzIHNwZWNpZmllZDogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBlLm1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNvbXB1dGUgPSBDb21wdXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcHV0ZWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDb21wdXRlIiwiYXJyaWZ5IiwicmVxdWlyZSIsImdheGlvc18xIiwiZ2NwTWV0YWRhdGEiLCJvYXV0aDJjbGllbnRfMSIsIk9BdXRoMkNsaWVudCIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImNyZWRlbnRpYWxzIiwiZXhwaXJ5X2RhdGUiLCJyZWZyZXNoX3Rva2VuIiwic2VydmljZUFjY291bnRFbWFpbCIsInNjb3BlcyIsInJlZnJlc2hUb2tlbk5vQ2FjaGUiLCJyZWZyZXNoVG9rZW4iLCJ0b2tlblBhdGgiLCJkYXRhIiwiaW5zdGFuY2VPcHRpb25zIiwicHJvcGVydHkiLCJsZW5ndGgiLCJwYXJhbXMiLCJqb2luIiwiaW5zdGFuY2UiLCJlIiwiR2F4aW9zRXJyb3IiLCJtZXNzYWdlIiwid3JhcEVycm9yIiwidG9rZW5zIiwiZXhwaXJlc19pbiIsIkRhdGUiLCJnZXRUaW1lIiwiZW1pdCIsInJlcyIsImZldGNoSWRUb2tlbiIsInRhcmdldEF1ZGllbmNlIiwiaWRUb2tlblBhdGgiLCJpZFRva2VuIiwiRXJyb3IiLCJyZXNwb25zZSIsInN0YXR1cyIsImNvZGUiLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/computeclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/downscopedclient.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/downscopedclient.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst sts = __webpack_require__(/*! ./stscredentials */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/stscredentials.js\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */ const STS_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:token-exchange\";\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */ const STS_REQUEST_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\";\n/**\n * The requested token exchange subject_token_type: rfc8693#section-2.1\n */ const STS_SUBJECT_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\";\n/** The STS access token exchange end point. */ const STS_ACCESS_TOKEN_URL = \"https://sts.googleapis.com/v1/token\";\n/**\n * The maximum number of access boundary rules a Credential Access Boundary\n * can contain.\n */ exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;\n/**\n * Offset to take into account network delays and server clock skews.\n */ exports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * Defines a set of Google credentials that are downscoped from an existing set\n * of Google OAuth2 credentials. This is useful to restrict the Identity and\n * Access Management (IAM) permissions that a short-lived credential can use.\n * The common pattern of usage is to have a token broker with elevated access\n * generate these downscoped credentials from higher access source credentials\n * and pass the downscoped short-lived access tokens to a token consumer via\n * some secure authenticated channel for limited access to Google Cloud Storage\n * resources.\n */ class DownscopedClient extends authclient_1.AuthClient {\n    /**\n     * Instantiates a downscoped client object using the provided source\n     * AuthClient and credential access boundary rules.\n     * To downscope permissions of a source AuthClient, a Credential Access\n     * Boundary that specifies which resources the new credential can access, as\n     * well as an upper bound on the permissions that are available on each\n     * resource, has to be defined. A downscoped client can then be instantiated\n     * using the source AuthClient and the Credential Access Boundary.\n     * @param authClient The source AuthClient to be downscoped based on the\n     *   provided Credential Access Boundary rules.\n     * @param credentialAccessBoundary The Credential Access Boundary which\n     *   contains a list of access boundary rules. Each rule contains information\n     *   on the resource that the rule applies to, the upper bound of the\n     *   permissions that are available on that resource and an optional\n     *   condition to further restrict permissions.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     * @param quotaProjectId Optional quota project id for setting up in the\n     *   x-goog-user-project header.\n     */ constructor(authClient, credentialAccessBoundary, additionalOptions, quotaProjectId){\n        super();\n        this.authClient = authClient;\n        this.credentialAccessBoundary = credentialAccessBoundary;\n        // Check 1-10 Access Boundary Rules are defined within Credential Access\n        // Boundary.\n        if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) {\n            throw new Error(\"At least one access boundary rule needs to be defined.\");\n        } else if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length > exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) {\n            throw new Error(\"The provided access boundary has more than \" + `${exports.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);\n        }\n        // Check at least one permission should be defined in each Access Boundary\n        // Rule.\n        for (const rule of credentialAccessBoundary.accessBoundary.accessBoundaryRules){\n            if (rule.availablePermissions.length === 0) {\n                throw new Error(\"At least one permission should be defined in access boundary rules.\");\n            }\n        }\n        this.stsCredential = new sts.StsCredentials(STS_ACCESS_TOKEN_URL);\n        this.cachedDownscopedAccessToken = null;\n        // As threshold could be zero,\n        // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n        // zero value.\n        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== \"number\") {\n            this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\n        } else {\n            this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;\n        }\n        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n        this.quotaProjectId = quotaProjectId;\n    }\n    /**\n     * Provides a mechanism to inject Downscoped access tokens directly.\n     * The expiry_date field is required to facilitate determination of the token\n     * expiration which would make it easier for the token consumer to handle.\n     * @param credentials The Credentials object to set on the current client.\n     */ setCredentials(credentials) {\n        if (!credentials.expiry_date) {\n            throw new Error(\"The access token expiry_date field is missing in the provided \" + \"credentials.\");\n        }\n        super.setCredentials(credentials);\n        this.cachedDownscopedAccessToken = credentials;\n    }\n    async getAccessToken() {\n        // If the cached access token is unavailable or expired, force refresh.\n        // The Downscoped access token will be returned in\n        // DownscopedAccessTokenResponse format.\n        if (!this.cachedDownscopedAccessToken || this.isExpired(this.cachedDownscopedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return Downscoped access token in DownscopedAccessTokenResponse format.\n        return {\n            token: this.cachedDownscopedAccessToken.access_token,\n            expirationTime: this.cachedDownscopedAccessToken.expiry_date,\n            res: this.cachedDownscopedAccessToken.res\n        };\n    }\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     */ async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then((r)=>callback(null, r), (e)=>{\n                return callback(e, e.response);\n            });\n        } else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param retry Whether the current attempt is a retry after a failed attempt.\n     * @return A promise that resolves with the successful response.\n     */ async requestAsync(opts, retry = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders[\"x-goog-user-project\"]) {\n                opts.headers[\"x-goog-user-project\"] = requestHeaders[\"x-goog-user-project\"];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        } catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * GCP access tokens are retrieved from authclient object/source credential.\n     * Then GCP access tokens are exchanged for downscoped access tokens via the\n     * token exchange endpoint.\n     * @return A promise that resolves with the fresh downscoped access token.\n     */ async refreshAccessTokenAsync() {\n        var _a;\n        // Retrieve GCP access token from source credential.\n        const subjectToken = (await this.authClient.getAccessToken()).token;\n        // Construct the STS credentials options.\n        const stsCredentialsOptions = {\n            grantType: STS_GRANT_TYPE,\n            requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n            subjectToken: subjectToken,\n            subjectTokenType: STS_SUBJECT_TOKEN_TYPE\n        };\n        // Exchange the source AuthClient access token for a Downscoped access\n        // token.\n        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, this.credentialAccessBoundary);\n        /**\n         * The STS endpoint will only return the expiration time for the downscoped\n         * access token if the original access token represents a service account.\n         * The downscoped token's expiration time will always match the source\n         * credential expiration. When no expires_in is returned, we can copy the\n         * source credential's expiration time.\n         */ const sourceCredExpireDate = ((_a = this.authClient.credentials) === null || _a === void 0 ? void 0 : _a.expiry_date) || null;\n        const expiryDate = stsResponse.expires_in ? new Date().getTime() + stsResponse.expires_in * 1000 : sourceCredExpireDate;\n        // Save response in cached access token.\n        this.cachedDownscopedAccessToken = {\n            access_token: stsResponse.access_token,\n            expiry_date: expiryDate,\n            res: stsResponse.res\n        };\n        // Save credentials.\n        this.credentials = {};\n        Object.assign(this.credentials, this.cachedDownscopedAccessToken);\n        delete this.credentials.res;\n        // Trigger tokens event to notify external listeners.\n        this.emit(\"tokens\", {\n            refresh_token: null,\n            expiry_date: this.cachedDownscopedAccessToken.expiry_date,\n            access_token: this.cachedDownscopedAccessToken.access_token,\n            token_type: \"Bearer\",\n            id_token: null\n        });\n        // Return the cached access token.\n        return this.cachedDownscopedAccessToken;\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param downscopedAccessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */ isExpired(downscopedAccessToken) {\n        const now = new Date().getTime();\n        return downscopedAccessToken.expiry_date ? now >= downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis : false;\n    }\n}\nexports.DownscopedClient = DownscopedClient; //# sourceMappingURL=downscopedclient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9kb3duc2NvcGVkY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsd0JBQXdCLEdBQUdBLDhCQUE4QixHQUFHQSx1Q0FBdUMsR0FBRyxLQUFLO0FBQzNHLE1BQU1LLFNBQVNDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQy9CLE1BQU1DLGVBQWVELG1CQUFPQSxDQUFDLDJGQUFjO0FBQzNDLE1BQU1FLE1BQU1GLG1CQUFPQSxDQUFDLG1HQUFrQjtBQUN0Qzs7Q0FFQyxHQUNELE1BQU1HLGlCQUFpQjtBQUN2Qjs7Q0FFQyxHQUNELE1BQU1DLHlCQUF5QjtBQUMvQjs7Q0FFQyxHQUNELE1BQU1DLHlCQUF5QjtBQUMvQiw2Q0FBNkMsR0FDN0MsTUFBTUMsdUJBQXVCO0FBQzdCOzs7Q0FHQyxHQUNEWix1Q0FBdUMsR0FBRztBQUMxQzs7Q0FFQyxHQUNEQSw4QkFBOEIsR0FBRyxJQUFJLEtBQUs7QUFDMUM7Ozs7Ozs7OztDQVNDLEdBQ0QsTUFBTUUseUJBQXlCSyxhQUFhTSxVQUFVO0lBQ2xEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQW9CQyxHQUNEQyxZQUFZQyxVQUFVLEVBQUVDLHdCQUF3QixFQUFFQyxpQkFBaUIsRUFBRUMsY0FBYyxDQUFFO1FBQ2pGLEtBQUs7UUFDTCxJQUFJLENBQUNILFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyx3QkFBd0IsR0FBR0E7UUFDaEMsd0VBQXdFO1FBQ3hFLFlBQVk7UUFD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UUFDbEMsT0FBTyxJQUFJLENBQUN0RCwyQkFBMkI7SUFDM0M7SUFDQTs7Ozs7S0FLQyxHQUNETyxVQUFVZ0QscUJBQXFCLEVBQUU7UUFDN0IsTUFBTUMsTUFBTSxJQUFJUixPQUFPQyxPQUFPO1FBQzlCLE9BQU9NLHNCQUFzQmxELFdBQVcsR0FDbENtRCxPQUNFRCxzQkFBc0JsRCxXQUFXLEdBQUcsSUFBSSxDQUFDSiwyQkFBMkIsR0FDdEU7SUFDVjtBQUNKO0FBQ0E1Qix3QkFBd0IsR0FBR0Usa0JBQzNCLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2Rvd25zY29wZWRjbGllbnQuanM/OGI5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Eb3duc2NvcGVkQ2xpZW50ID0gZXhwb3J0cy5FWFBJUkFUSU9OX1RJTUVfT0ZGU0VUID0gZXhwb3J0cy5NQVhfQUNDRVNTX0JPVU5EQVJZX1JVTEVTX0NPVU5UID0gdm9pZCAwO1xuY29uc3Qgc3RyZWFtID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IGF1dGhjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGhjbGllbnRcIik7XG5jb25zdCBzdHMgPSByZXF1aXJlKFwiLi9zdHNjcmVkZW50aWFsc1wiKTtcbi8qKlxuICogVGhlIHJlcXVpcmVkIHRva2VuIGV4Y2hhbmdlIGdyYW50X3R5cGU6IHJmYzg2OTMjc2VjdGlvbi0yLjFcbiAqL1xuY29uc3QgU1RTX0dSQU5UX1RZUEUgPSAndXJuOmlldGY6cGFyYW1zOm9hdXRoOmdyYW50LXR5cGU6dG9rZW4tZXhjaGFuZ2UnO1xuLyoqXG4gKiBUaGUgcmVxdWVzdGVkIHRva2VuIGV4Y2hhbmdlIHJlcXVlc3RlZF90b2tlbl90eXBlOiByZmM4NjkzI3NlY3Rpb24tMi4xXG4gKi9cbmNvbnN0IFNUU19SRVFVRVNUX1RPS0VOX1RZUEUgPSAndXJuOmlldGY6cGFyYW1zOm9hdXRoOnRva2VuLXR5cGU6YWNjZXNzX3Rva2VuJztcbi8qKlxuICogVGhlIHJlcXVlc3RlZCB0b2tlbiBleGNoYW5nZSBzdWJqZWN0X3Rva2VuX3R5cGU6IHJmYzg2OTMjc2VjdGlvbi0yLjFcbiAqL1xuY29uc3QgU1RTX1NVQkpFQ1RfVE9LRU5fVFlQRSA9ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6dG9rZW4tdHlwZTphY2Nlc3NfdG9rZW4nO1xuLyoqIFRoZSBTVFMgYWNjZXNzIHRva2VuIGV4Y2hhbmdlIGVuZCBwb2ludC4gKi9cbmNvbnN0IFNUU19BQ0NFU1NfVE9LRU5fVVJMID0gJ2h0dHBzOi8vc3RzLmdvb2dsZWFwaXMuY29tL3YxL3Rva2VuJztcbi8qKlxuICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGFjY2VzcyBib3VuZGFyeSBydWxlcyBhIENyZWRlbnRpYWwgQWNjZXNzIEJvdW5kYXJ5XG4gKiBjYW4gY29udGFpbi5cbiAqL1xuZXhwb3J0cy5NQVhfQUNDRVNTX0JPVU5EQVJZX1JVTEVTX0NPVU5UID0gMTA7XG4vKipcbiAqIE9mZnNldCB0byB0YWtlIGludG8gYWNjb3VudCBuZXR3b3JrIGRlbGF5cyBhbmQgc2VydmVyIGNsb2NrIHNrZXdzLlxuICovXG5leHBvcnRzLkVYUElSQVRJT05fVElNRV9PRkZTRVQgPSA1ICogNjAgKiAxMDAwO1xuLyoqXG4gKiBEZWZpbmVzIGEgc2V0IG9mIEdvb2dsZSBjcmVkZW50aWFscyB0aGF0IGFyZSBkb3duc2NvcGVkIGZyb20gYW4gZXhpc3Rpbmcgc2V0XG4gKiBvZiBHb29nbGUgT0F1dGgyIGNyZWRlbnRpYWxzLiBUaGlzIGlzIHVzZWZ1bCB0byByZXN0cmljdCB0aGUgSWRlbnRpdHkgYW5kXG4gKiBBY2Nlc3MgTWFuYWdlbWVudCAoSUFNKSBwZXJtaXNzaW9ucyB0aGF0IGEgc2hvcnQtbGl2ZWQgY3JlZGVudGlhbCBjYW4gdXNlLlxuICogVGhlIGNvbW1vbiBwYXR0ZXJuIG9mIHVzYWdlIGlzIHRvIGhhdmUgYSB0b2tlbiBicm9rZXIgd2l0aCBlbGV2YXRlZCBhY2Nlc3NcbiAqIGdlbmVyYXRlIHRoZXNlIGRvd25zY29wZWQgY3JlZGVudGlhbHMgZnJvbSBoaWdoZXIgYWNjZXNzIHNvdXJjZSBjcmVkZW50aWFsc1xuICogYW5kIHBhc3MgdGhlIGRvd25zY29wZWQgc2hvcnQtbGl2ZWQgYWNjZXNzIHRva2VucyB0byBhIHRva2VuIGNvbnN1bWVyIHZpYVxuICogc29tZSBzZWN1cmUgYXV0aGVudGljYXRlZCBjaGFubmVsIGZvciBsaW1pdGVkIGFjY2VzcyB0byBHb29nbGUgQ2xvdWQgU3RvcmFnZVxuICogcmVzb3VyY2VzLlxuICovXG5jbGFzcyBEb3duc2NvcGVkQ2xpZW50IGV4dGVuZHMgYXV0aGNsaWVudF8xLkF1dGhDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhIGRvd25zY29wZWQgY2xpZW50IG9iamVjdCB1c2luZyB0aGUgcHJvdmlkZWQgc291cmNlXG4gICAgICogQXV0aENsaWVudCBhbmQgY3JlZGVudGlhbCBhY2Nlc3MgYm91bmRhcnkgcnVsZXMuXG4gICAgICogVG8gZG93bnNjb3BlIHBlcm1pc3Npb25zIG9mIGEgc291cmNlIEF1dGhDbGllbnQsIGEgQ3JlZGVudGlhbCBBY2Nlc3NcbiAgICAgKiBCb3VuZGFyeSB0aGF0IHNwZWNpZmllcyB3aGljaCByZXNvdXJjZXMgdGhlIG5ldyBjcmVkZW50aWFsIGNhbiBhY2Nlc3MsIGFzXG4gICAgICogd2VsbCBhcyBhbiB1cHBlciBib3VuZCBvbiB0aGUgcGVybWlzc2lvbnMgdGhhdCBhcmUgYXZhaWxhYmxlIG9uIGVhY2hcbiAgICAgKiByZXNvdXJjZSwgaGFzIHRvIGJlIGRlZmluZWQuIEEgZG93bnNjb3BlZCBjbGllbnQgY2FuIHRoZW4gYmUgaW5zdGFudGlhdGVkXG4gICAgICogdXNpbmcgdGhlIHNvdXJjZSBBdXRoQ2xpZW50IGFuZCB0aGUgQ3JlZGVudGlhbCBBY2Nlc3MgQm91bmRhcnkuXG4gICAgICogQHBhcmFtIGF1dGhDbGllbnQgVGhlIHNvdXJjZSBBdXRoQ2xpZW50IHRvIGJlIGRvd25zY29wZWQgYmFzZWQgb24gdGhlXG4gICAgICogICBwcm92aWRlZCBDcmVkZW50aWFsIEFjY2VzcyBCb3VuZGFyeSBydWxlcy5cbiAgICAgKiBAcGFyYW0gY3JlZGVudGlhbEFjY2Vzc0JvdW5kYXJ5IFRoZSBDcmVkZW50aWFsIEFjY2VzcyBCb3VuZGFyeSB3aGljaFxuICAgICAqICAgY29udGFpbnMgYSBsaXN0IG9mIGFjY2VzcyBib3VuZGFyeSBydWxlcy4gRWFjaCBydWxlIGNvbnRhaW5zIGluZm9ybWF0aW9uXG4gICAgICogICBvbiB0aGUgcmVzb3VyY2UgdGhhdCB0aGUgcnVsZSBhcHBsaWVzIHRvLCB0aGUgdXBwZXIgYm91bmQgb2YgdGhlXG4gICAgICogICBwZXJtaXNzaW9ucyB0aGF0IGFyZSBhdmFpbGFibGUgb24gdGhhdCByZXNvdXJjZSBhbmQgYW4gb3B0aW9uYWxcbiAgICAgKiAgIGNvbmRpdGlvbiB0byBmdXJ0aGVyIHJlc3RyaWN0IHBlcm1pc3Npb25zLlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsT3B0aW9ucyBPcHRpb25hbCBhZGRpdGlvbmFsIGJlaGF2aW9yIGN1c3RvbWl6YXRpb25cbiAgICAgKiAgIG9wdGlvbnMuIFRoZXNlIGN1cnJlbnRseSBjdXN0b21pemUgZXhwaXJhdGlvbiB0aHJlc2hvbGQgdGltZSBhbmRcbiAgICAgKiAgIHdoZXRoZXIgdG8gcmV0cnkgb24gNDAxLzQwMyBBUEkgcmVxdWVzdCBlcnJvcnMuXG4gICAgICogQHBhcmFtIHF1b3RhUHJvamVjdElkIE9wdGlvbmFsIHF1b3RhIHByb2plY3QgaWQgZm9yIHNldHRpbmcgdXAgaW4gdGhlXG4gICAgICogICB4LWdvb2ctdXNlci1wcm9qZWN0IGhlYWRlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhdXRoQ2xpZW50LCBjcmVkZW50aWFsQWNjZXNzQm91bmRhcnksIGFkZGl0aW9uYWxPcHRpb25zLCBxdW90YVByb2plY3RJZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmF1dGhDbGllbnQgPSBhdXRoQ2xpZW50O1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxBY2Nlc3NCb3VuZGFyeSA9IGNyZWRlbnRpYWxBY2Nlc3NCb3VuZGFyeTtcbiAgICAgICAgLy8gQ2hlY2sgMS0xMCBBY2Nlc3MgQm91bmRhcnkgUnVsZXMgYXJlIGRlZmluZWQgd2l0aGluIENyZWRlbnRpYWwgQWNjZXNzXG4gICAgICAgIC8vIEJvdW5kYXJ5LlxuICAgICAgICBpZiAoY3JlZGVudGlhbEFjY2Vzc0JvdW5kYXJ5LmFjY2Vzc0JvdW5kYXJ5LmFjY2Vzc0JvdW5kYXJ5UnVsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0IGxlYXN0IG9uZSBhY2Nlc3MgYm91bmRhcnkgcnVsZSBuZWVkcyB0byBiZSBkZWZpbmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNyZWRlbnRpYWxBY2Nlc3NCb3VuZGFyeS5hY2Nlc3NCb3VuZGFyeS5hY2Nlc3NCb3VuZGFyeVJ1bGVzLmxlbmd0aCA+XG4gICAgICAgICAgICBleHBvcnRzLk1BWF9BQ0NFU1NfQk9VTkRBUllfUlVMRVNfQ09VTlQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIGFjY2VzcyBib3VuZGFyeSBoYXMgbW9yZSB0aGFuICcgK1xuICAgICAgICAgICAgICAgIGAke2V4cG9ydHMuTUFYX0FDQ0VTU19CT1VOREFSWV9SVUxFU19DT1VOVH0gYWNjZXNzIGJvdW5kYXJ5IHJ1bGVzLmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGF0IGxlYXN0IG9uZSBwZXJtaXNzaW9uIHNob3VsZCBiZSBkZWZpbmVkIGluIGVhY2ggQWNjZXNzIEJvdW5kYXJ5XG4gICAgICAgIC8vIFJ1bGUuXG4gICAgICAgIGZvciAoY29uc3QgcnVsZSBvZiBjcmVkZW50aWFsQWNjZXNzQm91bmRhcnkuYWNjZXNzQm91bmRhcnlcbiAgICAgICAgICAgIC5hY2Nlc3NCb3VuZGFyeVJ1bGVzKSB7XG4gICAgICAgICAgICBpZiAocnVsZS5hdmFpbGFibGVQZXJtaXNzaW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0IGxlYXN0IG9uZSBwZXJtaXNzaW9uIHNob3VsZCBiZSBkZWZpbmVkIGluIGFjY2VzcyBib3VuZGFyeSBydWxlcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0c0NyZWRlbnRpYWwgPSBuZXcgc3RzLlN0c0NyZWRlbnRpYWxzKFNUU19BQ0NFU1NfVE9LRU5fVVJMKTtcbiAgICAgICAgdGhpcy5jYWNoZWREb3duc2NvcGVkQWNjZXNzVG9rZW4gPSBudWxsO1xuICAgICAgICAvLyBBcyB0aHJlc2hvbGQgY291bGQgYmUgemVybyxcbiAgICAgICAgLy8gZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzIHx8IEVYUElSQVRJT05fVElNRV9PRkZTRVQgd2lsbCBvdmVycmlkZSB0aGVcbiAgICAgICAgLy8gemVybyB2YWx1ZS5cbiAgICAgICAgaWYgKHR5cGVvZiAoYWRkaXRpb25hbE9wdGlvbnMgPT09IG51bGwgfHwgYWRkaXRpb25hbE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFkZGl0aW9uYWxPcHRpb25zLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcykgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyA9IGV4cG9ydHMuRVhQSVJBVElPTl9USU1FX09GRlNFVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzID0gYWRkaXRpb25hbE9wdGlvbnNcbiAgICAgICAgICAgICAgICAuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoT25GYWlsdXJlID0gISEoYWRkaXRpb25hbE9wdGlvbnMgPT09IG51bGwgfHwgYWRkaXRpb25hbE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFkZGl0aW9uYWxPcHRpb25zLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSk7XG4gICAgICAgIHRoaXMucXVvdGFQcm9qZWN0SWQgPSBxdW90YVByb2plY3RJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBtZWNoYW5pc20gdG8gaW5qZWN0IERvd25zY29wZWQgYWNjZXNzIHRva2VucyBkaXJlY3RseS5cbiAgICAgKiBUaGUgZXhwaXJ5X2RhdGUgZmllbGQgaXMgcmVxdWlyZWQgdG8gZmFjaWxpdGF0ZSBkZXRlcm1pbmF0aW9uIG9mIHRoZSB0b2tlblxuICAgICAqIGV4cGlyYXRpb24gd2hpY2ggd291bGQgbWFrZSBpdCBlYXNpZXIgZm9yIHRoZSB0b2tlbiBjb25zdW1lciB0byBoYW5kbGUuXG4gICAgICogQHBhcmFtIGNyZWRlbnRpYWxzIFRoZSBDcmVkZW50aWFscyBvYmplY3QgdG8gc2V0IG9uIHRoZSBjdXJyZW50IGNsaWVudC5cbiAgICAgKi9cbiAgICBzZXRDcmVkZW50aWFscyhjcmVkZW50aWFscykge1xuICAgICAgICBpZiAoIWNyZWRlbnRpYWxzLmV4cGlyeV9kYXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBhY2Nlc3MgdG9rZW4gZXhwaXJ5X2RhdGUgZmllbGQgaXMgbWlzc2luZyBpbiB0aGUgcHJvdmlkZWQgJyArXG4gICAgICAgICAgICAgICAgJ2NyZWRlbnRpYWxzLicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKTtcbiAgICAgICAgdGhpcy5jYWNoZWREb3duc2NvcGVkQWNjZXNzVG9rZW4gPSBjcmVkZW50aWFscztcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIC8vIElmIHRoZSBjYWNoZWQgYWNjZXNzIHRva2VuIGlzIHVuYXZhaWxhYmxlIG9yIGV4cGlyZWQsIGZvcmNlIHJlZnJlc2guXG4gICAgICAgIC8vIFRoZSBEb3duc2NvcGVkIGFjY2VzcyB0b2tlbiB3aWxsIGJlIHJldHVybmVkIGluXG4gICAgICAgIC8vIERvd25zY29wZWRBY2Nlc3NUb2tlblJlc3BvbnNlIGZvcm1hdC5cbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlZERvd25zY29wZWRBY2Nlc3NUb2tlbiB8fFxuICAgICAgICAgICAgdGhpcy5pc0V4cGlyZWQodGhpcy5jYWNoZWREb3duc2NvcGVkQWNjZXNzVG9rZW4pKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIERvd25zY29wZWQgYWNjZXNzIHRva2VuIGluIERvd25zY29wZWRBY2Nlc3NUb2tlblJlc3BvbnNlIGZvcm1hdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRva2VuOiB0aGlzLmNhY2hlZERvd25zY29wZWRBY2Nlc3NUb2tlbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICBleHBpcmF0aW9uVGltZTogdGhpcy5jYWNoZWREb3duc2NvcGVkQWNjZXNzVG9rZW4uZXhwaXJ5X2RhdGUsXG4gICAgICAgICAgICByZXM6IHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuLnJlcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1haW4gYXV0aGVudGljYXRpb24gaW50ZXJmYWNlLiBJdCB0YWtlcyBhbiBvcHRpb25hbCB1cmwgd2hpY2ggd2hlblxuICAgICAqIHByZXNlbnQgaXMgdGhlIGVuZHBvaW50IGJlaW5nIGFjY2Vzc2VkLCBhbmQgcmV0dXJucyBhIFByb21pc2Ugd2hpY2hcbiAgICAgKiByZXNvbHZlcyB3aXRoIGF1dGhvcml6YXRpb24gaGVhZGVyIGZpZWxkcy5cbiAgICAgKlxuICAgICAqIFRoZSByZXN1bHQgaGFzIHRoZSBmb3JtOlxuICAgICAqIHsgQXV0aG9yaXphdGlvbjogJ0JlYXJlciA8YWNjZXNzX3Rva2VuX3ZhbHVlPicgfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFJlcXVlc3RIZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlblJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRBY2Nlc3NUb2tlbigpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2FjY2Vzc1Rva2VuUmVzcG9uc2UudG9rZW59YCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH1cbiAgICByZXF1ZXN0KG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QXN5bmMob3B0cykudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSwgZS5yZXNwb25zZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RBc3luYyhvcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdXRoZW50aWNhdGVzIHRoZSBwcm92aWRlZCBIVFRQIHJlcXVlc3QsIHByb2Nlc3NlcyBpdCBhbmQgcmVzb2x2ZXMgd2l0aCB0aGVcbiAgICAgKiByZXR1cm5lZCByZXNwb25zZS5cbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgSFRUUCByZXF1ZXN0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHJldHJ5IFdoZXRoZXIgdGhlIGN1cnJlbnQgYXR0ZW1wdCBpcyBhIHJldHJ5IGFmdGVyIGEgZmFpbGVkIGF0dGVtcHQuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIGFzeW5jIHJlcXVlc3RBc3luYyhvcHRzLCByZXRyeSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0SGVhZGVycygpO1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RIZWFkZXJzICYmIHJlcXVlc3RIZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J10pIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXSA9XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdEhlYWRlcnMgJiYgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbikge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBlLnJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgICAgIC8vIFJldHJ5IHRoZSByZXF1ZXN0IGZvciBtZXRhZGF0YSBpZiB0aGUgZm9sbG93aW5nIGNyaXRlcmlhIGFyZSB0cnVlOlxuICAgICAgICAgICAgICAgIC8vIC0gV2UgaGF2ZW4ndCBhbHJlYWR5IHJldHJpZWQuICBJdCBvbmx5IG1ha2VzIHNlbnNlIHRvIHJldHJ5IG9uY2UuXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgcmVzcG9uc2Ugd2FzIGEgNDAxIG9yIGEgNDAzXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgcmVxdWVzdCBkaWRuJ3Qgc2VuZCBhIHJlYWRhYmxlU3RyZWFtXG4gICAgICAgICAgICAgICAgLy8gLSBmb3JjZVJlZnJlc2hPbkZhaWx1cmUgaXMgdHJ1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVhZGFibGVTdHJlYW0gPSByZXMuY29uZmlnLmRhdGEgaW5zdGFuY2VvZiBzdHJlYW0uUmVhZGFibGU7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBdXRoRXJyID0gc3RhdHVzQ29kZSA9PT0gNDAxIHx8IHN0YXR1c0NvZGUgPT09IDQwMztcbiAgICAgICAgICAgICAgICBpZiAoIXJldHJ5ICYmXG4gICAgICAgICAgICAgICAgICAgIGlzQXV0aEVyciAmJlxuICAgICAgICAgICAgICAgICAgICAhaXNSZWFkYWJsZVN0cmVhbSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJlcXVlc3RBc3luYyhvcHRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yY2VzIHRva2VuIHJlZnJlc2gsIGV2ZW4gaWYgdW5leHBpcmVkIHRva2VucyBhcmUgY3VycmVudGx5IGNhY2hlZC5cbiAgICAgKiBHQ1AgYWNjZXNzIHRva2VucyBhcmUgcmV0cmlldmVkIGZyb20gYXV0aGNsaWVudCBvYmplY3Qvc291cmNlIGNyZWRlbnRpYWwuXG4gICAgICogVGhlbiBHQ1AgYWNjZXNzIHRva2VucyBhcmUgZXhjaGFuZ2VkIGZvciBkb3duc2NvcGVkIGFjY2VzcyB0b2tlbnMgdmlhIHRoZVxuICAgICAqIHRva2VuIGV4Y2hhbmdlIGVuZHBvaW50LlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZnJlc2ggZG93bnNjb3BlZCBhY2Nlc3MgdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgcmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gUmV0cmlldmUgR0NQIGFjY2VzcyB0b2tlbiBmcm9tIHNvdXJjZSBjcmVkZW50aWFsLlxuICAgICAgICBjb25zdCBzdWJqZWN0VG9rZW4gPSAoYXdhaXQgdGhpcy5hdXRoQ2xpZW50LmdldEFjY2Vzc1Rva2VuKCkpLnRva2VuO1xuICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIFNUUyBjcmVkZW50aWFscyBvcHRpb25zLlxuICAgICAgICBjb25zdCBzdHNDcmVkZW50aWFsc09wdGlvbnMgPSB7XG4gICAgICAgICAgICBncmFudFR5cGU6IFNUU19HUkFOVF9UWVBFLFxuICAgICAgICAgICAgcmVxdWVzdGVkVG9rZW5UeXBlOiBTVFNfUkVRVUVTVF9UT0tFTl9UWVBFLFxuICAgICAgICAgICAgc3ViamVjdFRva2VuOiBzdWJqZWN0VG9rZW4sXG4gICAgICAgICAgICBzdWJqZWN0VG9rZW5UeXBlOiBTVFNfU1VCSkVDVF9UT0tFTl9UWVBFLFxuICAgICAgICB9O1xuICAgICAgICAvLyBFeGNoYW5nZSB0aGUgc291cmNlIEF1dGhDbGllbnQgYWNjZXNzIHRva2VuIGZvciBhIERvd25zY29wZWQgYWNjZXNzXG4gICAgICAgIC8vIHRva2VuLlxuICAgICAgICBjb25zdCBzdHNSZXNwb25zZSA9IGF3YWl0IHRoaXMuc3RzQ3JlZGVudGlhbC5leGNoYW5nZVRva2VuKHN0c0NyZWRlbnRpYWxzT3B0aW9ucywgdW5kZWZpbmVkLCB0aGlzLmNyZWRlbnRpYWxBY2Nlc3NCb3VuZGFyeSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgU1RTIGVuZHBvaW50IHdpbGwgb25seSByZXR1cm4gdGhlIGV4cGlyYXRpb24gdGltZSBmb3IgdGhlIGRvd25zY29wZWRcbiAgICAgICAgICogYWNjZXNzIHRva2VuIGlmIHRoZSBvcmlnaW5hbCBhY2Nlc3MgdG9rZW4gcmVwcmVzZW50cyBhIHNlcnZpY2UgYWNjb3VudC5cbiAgICAgICAgICogVGhlIGRvd25zY29wZWQgdG9rZW4ncyBleHBpcmF0aW9uIHRpbWUgd2lsbCBhbHdheXMgbWF0Y2ggdGhlIHNvdXJjZVxuICAgICAgICAgKiBjcmVkZW50aWFsIGV4cGlyYXRpb24uIFdoZW4gbm8gZXhwaXJlc19pbiBpcyByZXR1cm5lZCwgd2UgY2FuIGNvcHkgdGhlXG4gICAgICAgICAqIHNvdXJjZSBjcmVkZW50aWFsJ3MgZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgc291cmNlQ3JlZEV4cGlyZURhdGUgPSAoKF9hID0gdGhpcy5hdXRoQ2xpZW50LmNyZWRlbnRpYWxzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXhwaXJ5X2RhdGUpIHx8IG51bGw7XG4gICAgICAgIGNvbnN0IGV4cGlyeURhdGUgPSBzdHNSZXNwb25zZS5leHBpcmVzX2luXG4gICAgICAgICAgICA/IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgc3RzUmVzcG9uc2UuZXhwaXJlc19pbiAqIDEwMDBcbiAgICAgICAgICAgIDogc291cmNlQ3JlZEV4cGlyZURhdGU7XG4gICAgICAgIC8vIFNhdmUgcmVzcG9uc2UgaW4gY2FjaGVkIGFjY2VzcyB0b2tlbi5cbiAgICAgICAgdGhpcy5jYWNoZWREb3duc2NvcGVkQWNjZXNzVG9rZW4gPSB7XG4gICAgICAgICAgICBhY2Nlc3NfdG9rZW46IHN0c1Jlc3BvbnNlLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgIGV4cGlyeV9kYXRlOiBleHBpcnlEYXRlLFxuICAgICAgICAgICAgcmVzOiBzdHNSZXNwb25zZS5yZXMsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFNhdmUgY3JlZGVudGlhbHMuXG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmNyZWRlbnRpYWxzLCB0aGlzLmNhY2hlZERvd25zY29wZWRBY2Nlc3NUb2tlbik7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNyZWRlbnRpYWxzLnJlcztcbiAgICAgICAgLy8gVHJpZ2dlciB0b2tlbnMgZXZlbnQgdG8gbm90aWZ5IGV4dGVybmFsIGxpc3RlbmVycy5cbiAgICAgICAgdGhpcy5lbWl0KCd0b2tlbnMnLCB7XG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuOiBudWxsLFxuICAgICAgICAgICAgZXhwaXJ5X2RhdGU6IHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuLmV4cGlyeV9kYXRlLFxuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiB0aGlzLmNhY2hlZERvd25zY29wZWRBY2Nlc3NUb2tlbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICB0b2tlbl90eXBlOiAnQmVhcmVyJyxcbiAgICAgICAgICAgIGlkX3Rva2VuOiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBjYWNoZWQgYWNjZXNzIHRva2VuLlxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWREb3duc2NvcGVkQWNjZXNzVG9rZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgY3JlZGVudGlhbHMgYXJlIGV4cGlyZWQgb3Igbm90LlxuICAgICAqIElmIHRoZXJlIGlzIG5vIGV4cGlyeSB0aW1lLCBhc3N1bWVzIHRoZSB0b2tlbiBpcyBub3QgZXhwaXJlZCBvciBleHBpcmluZy5cbiAgICAgKiBAcGFyYW0gZG93bnNjb3BlZEFjY2Vzc1Rva2VuIFRoZSBjcmVkZW50aWFscyB0byBjaGVjayBmb3IgZXhwaXJhdGlvbi5cbiAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhlIGNyZWRlbnRpYWxzIGFyZSBleHBpcmVkIG9yIG5vdC5cbiAgICAgKi9cbiAgICBpc0V4cGlyZWQoZG93bnNjb3BlZEFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICByZXR1cm4gZG93bnNjb3BlZEFjY2Vzc1Rva2VuLmV4cGlyeV9kYXRlXG4gICAgICAgICAgICA/IG5vdyA+PVxuICAgICAgICAgICAgICAgIGRvd25zY29wZWRBY2Nlc3NUb2tlbi5leHBpcnlfZGF0ZSAtIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuRG93bnNjb3BlZENsaWVudCA9IERvd25zY29wZWRDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb3duc2NvcGVkY2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkRvd25zY29wZWRDbGllbnQiLCJFWFBJUkFUSU9OX1RJTUVfT0ZGU0VUIiwiTUFYX0FDQ0VTU19CT1VOREFSWV9SVUxFU19DT1VOVCIsInN0cmVhbSIsInJlcXVpcmUiLCJhdXRoY2xpZW50XzEiLCJzdHMiLCJTVFNfR1JBTlRfVFlQRSIsIlNUU19SRVFVRVNUX1RPS0VOX1RZUEUiLCJTVFNfU1VCSkVDVF9UT0tFTl9UWVBFIiwiU1RTX0FDQ0VTU19UT0tFTl9VUkwiLCJBdXRoQ2xpZW50IiwiY29uc3RydWN0b3IiLCJhdXRoQ2xpZW50IiwiY3JlZGVudGlhbEFjY2Vzc0JvdW5kYXJ5IiwiYWRkaXRpb25hbE9wdGlvbnMiLCJxdW90YVByb2plY3RJZCIsImFjY2Vzc0JvdW5kYXJ5IiwiYWNjZXNzQm91bmRhcnlSdWxlcyIsImxlbmd0aCIsIkVycm9yIiwicnVsZSIsImF2YWlsYWJsZVBlcm1pc3Npb25zIiwic3RzQ3JlZGVudGlhbCIsIlN0c0NyZWRlbnRpYWxzIiwiY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuIiwiZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzIiwiZm9yY2VSZWZyZXNoT25GYWlsdXJlIiwic2V0Q3JlZGVudGlhbHMiLCJjcmVkZW50aWFscyIsImV4cGlyeV9kYXRlIiwiZ2V0QWNjZXNzVG9rZW4iLCJpc0V4cGlyZWQiLCJyZWZyZXNoQWNjZXNzVG9rZW5Bc3luYyIsInRva2VuIiwiYWNjZXNzX3Rva2VuIiwiZXhwaXJhdGlvblRpbWUiLCJyZXMiLCJnZXRSZXF1ZXN0SGVhZGVycyIsImFjY2Vzc1Rva2VuUmVzcG9uc2UiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsImFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyIsInJlcXVlc3QiLCJvcHRzIiwiY2FsbGJhY2siLCJyZXF1ZXN0QXN5bmMiLCJ0aGVuIiwiciIsImUiLCJyZXNwb25zZSIsInJldHJ5IiwicmVxdWVzdEhlYWRlcnMiLCJ0cmFuc3BvcnRlciIsInN0YXR1c0NvZGUiLCJzdGF0dXMiLCJpc1JlYWRhYmxlU3RyZWFtIiwiY29uZmlnIiwiZGF0YSIsIlJlYWRhYmxlIiwiaXNBdXRoRXJyIiwiX2EiLCJzdWJqZWN0VG9rZW4iLCJzdHNDcmVkZW50aWFsc09wdGlvbnMiLCJncmFudFR5cGUiLCJyZXF1ZXN0ZWRUb2tlblR5cGUiLCJzdWJqZWN0VG9rZW5UeXBlIiwic3RzUmVzcG9uc2UiLCJleGNoYW5nZVRva2VuIiwidW5kZWZpbmVkIiwic291cmNlQ3JlZEV4cGlyZURhdGUiLCJleHBpcnlEYXRlIiwiZXhwaXJlc19pbiIsIkRhdGUiLCJnZXRUaW1lIiwiYXNzaWduIiwiZW1pdCIsInJlZnJlc2hfdG9rZW4iLCJ0b2tlbl90eXBlIiwiaWRfdG9rZW4iLCJkb3duc2NvcGVkQWNjZXNzVG9rZW4iLCJub3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/downscopedclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/envDetect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/envDetect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2018 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getEnv = exports.clear = exports.GCPEnv = void 0;\nconst gcpMetadata = __webpack_require__(/*! gcp-metadata */ \"(rsc)/./node_modules/gcp-metadata/build/src/index.js\");\nvar GCPEnv;\n(function(GCPEnv) {\n    GCPEnv[\"APP_ENGINE\"] = \"APP_ENGINE\";\n    GCPEnv[\"KUBERNETES_ENGINE\"] = \"KUBERNETES_ENGINE\";\n    GCPEnv[\"CLOUD_FUNCTIONS\"] = \"CLOUD_FUNCTIONS\";\n    GCPEnv[\"COMPUTE_ENGINE\"] = \"COMPUTE_ENGINE\";\n    GCPEnv[\"CLOUD_RUN\"] = \"CLOUD_RUN\";\n    GCPEnv[\"NONE\"] = \"NONE\";\n})(GCPEnv = exports.GCPEnv || (exports.GCPEnv = {}));\nlet envPromise;\nfunction clear() {\n    envPromise = undefined;\n}\nexports.clear = clear;\nasync function getEnv() {\n    if (envPromise) {\n        return envPromise;\n    }\n    envPromise = getEnvMemoized();\n    return envPromise;\n}\nexports.getEnv = getEnv;\nasync function getEnvMemoized() {\n    let env = GCPEnv.NONE;\n    if (isAppEngine()) {\n        env = GCPEnv.APP_ENGINE;\n    } else if (isCloudFunction()) {\n        env = GCPEnv.CLOUD_FUNCTIONS;\n    } else if (await isComputeEngine()) {\n        if (await isKubernetesEngine()) {\n            env = GCPEnv.KUBERNETES_ENGINE;\n        } else if (isCloudRun()) {\n            env = GCPEnv.CLOUD_RUN;\n        } else {\n            env = GCPEnv.COMPUTE_ENGINE;\n        }\n    } else {\n        env = GCPEnv.NONE;\n    }\n    return env;\n}\nfunction isAppEngine() {\n    return !!(process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME);\n}\nfunction isCloudFunction() {\n    return !!(process.env.FUNCTION_NAME || process.env.FUNCTION_TARGET);\n}\n/**\n * This check only verifies that the environment is running knative.\n * This must be run *after* checking for Kubernetes, otherwise it will\n * return a false positive.\n */ function isCloudRun() {\n    return !!process.env.K_CONFIGURATION;\n}\nasync function isKubernetesEngine() {\n    try {\n        await gcpMetadata.instance(\"attributes/cluster-name\");\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nasync function isComputeEngine() {\n    return gcpMetadata.isAvailable();\n} //# sourceMappingURL=envDetect.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9lbnZEZXRlY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUdBLGFBQWEsR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDdkQsTUFBTUssY0FBY0MsbUJBQU9BLENBQUMsMEVBQWM7QUFDMUMsSUFBSUY7QUFDSCxVQUFVQSxNQUFNO0lBQ2JBLE1BQU0sQ0FBQyxhQUFhLEdBQUc7SUFDdkJBLE1BQU0sQ0FBQyxvQkFBb0IsR0FBRztJQUM5QkEsTUFBTSxDQUFDLGtCQUFrQixHQUFHO0lBQzVCQSxNQUFNLENBQUMsaUJBQWlCLEdBQUc7SUFDM0JBLE1BQU0sQ0FBQyxZQUFZLEdBQUc7SUFDdEJBLE1BQU0sQ0FBQyxPQUFPLEdBQUc7QUFDckIsR0FBR0EsU0FBU0osUUFBUUksTUFBTSxJQUFLSixDQUFBQSxjQUFjLEdBQUcsQ0FBQztBQUNqRCxJQUFJTztBQUNKLFNBQVNKO0lBQ0xJLGFBQWFDO0FBQ2pCO0FBQ0FSLGFBQWEsR0FBR0c7QUFDaEIsZUFBZUQ7SUFDWCxJQUFJSyxZQUFZO1FBQ1osT0FBT0E7SUFDWDtJQUNBQSxhQUFhRTtJQUNiLE9BQU9GO0FBQ1g7QUFDQVAsY0FBYyxHQUFHRTtBQUNqQixlQUFlTztJQUNYLElBQUlDLE1BQU1OLE9BQU9PLElBQUk7SUFDckIsSUFBSUMsZUFBZTtRQUNmRixNQUFNTixPQUFPUyxVQUFVO0lBQzNCLE9BQ0ssSUFBSUMsbUJBQW1CO1FBQ3hCSixNQUFNTixPQUFPVyxlQUFlO0lBQ2hDLE9BQ0ssSUFBSSxNQUFNQyxtQkFBbUI7UUFDOUIsSUFBSSxNQUFNQyxzQkFBc0I7WUFDNUJQLE1BQU1OLE9BQU9jLGlCQUFpQjtRQUNsQyxPQUNLLElBQUlDLGNBQWM7WUFDbkJULE1BQU1OLE9BQU9nQixTQUFTO1FBQzFCLE9BQ0s7WUFDRFYsTUFBTU4sT0FBT2lCLGNBQWM7UUFDL0I7SUFDSixPQUNLO1FBQ0RYLE1BQU1OLE9BQU9PLElBQUk7SUFDckI7SUFDQSxPQUFPRDtBQUNYO0FBQ0EsU0FBU0U7SUFDTCxPQUFPLENBQUMsQ0FBRVUsQ0FBQUEsUUFBUVosR0FBRyxDQUFDYSxXQUFXLElBQUlELFFBQVFaLEdBQUcsQ0FBQ2MsZUFBZTtBQUNwRTtBQUNBLFNBQVNWO0lBQ0wsT0FBTyxDQUFDLENBQUVRLENBQUFBLFFBQVFaLEdBQUcsQ0FBQ2UsYUFBYSxJQUFJSCxRQUFRWixHQUFHLENBQUNnQixlQUFlO0FBQ3RFO0FBQ0E7Ozs7Q0FJQyxHQUNELFNBQVNQO0lBQ0wsT0FBTyxDQUFDLENBQUNHLFFBQVFaLEdBQUcsQ0FBQ2lCLGVBQWU7QUFDeEM7QUFDQSxlQUFlVjtJQUNYLElBQUk7UUFDQSxNQUFNWixZQUFZdUIsUUFBUSxDQUFDO1FBQzNCLE9BQU87SUFDWCxFQUNBLE9BQU9DLEdBQUc7UUFDTixPQUFPO0lBQ1g7QUFDSjtBQUNBLGVBQWViO0lBQ1gsT0FBT1gsWUFBWXlCLFdBQVc7QUFDbEMsRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9lbnZEZXRlY3QuanM/Y2UzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRFbnYgPSBleHBvcnRzLmNsZWFyID0gZXhwb3J0cy5HQ1BFbnYgPSB2b2lkIDA7XG5jb25zdCBnY3BNZXRhZGF0YSA9IHJlcXVpcmUoXCJnY3AtbWV0YWRhdGFcIik7XG52YXIgR0NQRW52O1xuKGZ1bmN0aW9uIChHQ1BFbnYpIHtcbiAgICBHQ1BFbnZbXCJBUFBfRU5HSU5FXCJdID0gXCJBUFBfRU5HSU5FXCI7XG4gICAgR0NQRW52W1wiS1VCRVJORVRFU19FTkdJTkVcIl0gPSBcIktVQkVSTkVURVNfRU5HSU5FXCI7XG4gICAgR0NQRW52W1wiQ0xPVURfRlVOQ1RJT05TXCJdID0gXCJDTE9VRF9GVU5DVElPTlNcIjtcbiAgICBHQ1BFbnZbXCJDT01QVVRFX0VOR0lORVwiXSA9IFwiQ09NUFVURV9FTkdJTkVcIjtcbiAgICBHQ1BFbnZbXCJDTE9VRF9SVU5cIl0gPSBcIkNMT1VEX1JVTlwiO1xuICAgIEdDUEVudltcIk5PTkVcIl0gPSBcIk5PTkVcIjtcbn0pKEdDUEVudiA9IGV4cG9ydHMuR0NQRW52IHx8IChleHBvcnRzLkdDUEVudiA9IHt9KSk7XG5sZXQgZW52UHJvbWlzZTtcbmZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGVudlByb21pc2UgPSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmNsZWFyID0gY2xlYXI7XG5hc3luYyBmdW5jdGlvbiBnZXRFbnYoKSB7XG4gICAgaWYgKGVudlByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIGVudlByb21pc2U7XG4gICAgfVxuICAgIGVudlByb21pc2UgPSBnZXRFbnZNZW1vaXplZCgpO1xuICAgIHJldHVybiBlbnZQcm9taXNlO1xufVxuZXhwb3J0cy5nZXRFbnYgPSBnZXRFbnY7XG5hc3luYyBmdW5jdGlvbiBnZXRFbnZNZW1vaXplZCgpIHtcbiAgICBsZXQgZW52ID0gR0NQRW52Lk5PTkU7XG4gICAgaWYgKGlzQXBwRW5naW5lKCkpIHtcbiAgICAgICAgZW52ID0gR0NQRW52LkFQUF9FTkdJTkU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQ2xvdWRGdW5jdGlvbigpKSB7XG4gICAgICAgIGVudiA9IEdDUEVudi5DTE9VRF9GVU5DVElPTlM7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF3YWl0IGlzQ29tcHV0ZUVuZ2luZSgpKSB7XG4gICAgICAgIGlmIChhd2FpdCBpc0t1YmVybmV0ZXNFbmdpbmUoKSkge1xuICAgICAgICAgICAgZW52ID0gR0NQRW52LktVQkVSTkVURVNfRU5HSU5FO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ2xvdWRSdW4oKSkge1xuICAgICAgICAgICAgZW52ID0gR0NQRW52LkNMT1VEX1JVTjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVudiA9IEdDUEVudi5DT01QVVRFX0VOR0lORTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW52ID0gR0NQRW52Lk5PTkU7XG4gICAgfVxuICAgIHJldHVybiBlbnY7XG59XG5mdW5jdGlvbiBpc0FwcEVuZ2luZSgpIHtcbiAgICByZXR1cm4gISEocHJvY2Vzcy5lbnYuR0FFX1NFUlZJQ0UgfHwgcHJvY2Vzcy5lbnYuR0FFX01PRFVMRV9OQU1FKTtcbn1cbmZ1bmN0aW9uIGlzQ2xvdWRGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISEocHJvY2Vzcy5lbnYuRlVOQ1RJT05fTkFNRSB8fCBwcm9jZXNzLmVudi5GVU5DVElPTl9UQVJHRVQpO1xufVxuLyoqXG4gKiBUaGlzIGNoZWNrIG9ubHkgdmVyaWZpZXMgdGhhdCB0aGUgZW52aXJvbm1lbnQgaXMgcnVubmluZyBrbmF0aXZlLlxuICogVGhpcyBtdXN0IGJlIHJ1biAqYWZ0ZXIqIGNoZWNraW5nIGZvciBLdWJlcm5ldGVzLCBvdGhlcndpc2UgaXQgd2lsbFxuICogcmV0dXJuIGEgZmFsc2UgcG9zaXRpdmUuXG4gKi9cbmZ1bmN0aW9uIGlzQ2xvdWRSdW4oKSB7XG4gICAgcmV0dXJuICEhcHJvY2Vzcy5lbnYuS19DT05GSUdVUkFUSU9OO1xufVxuYXN5bmMgZnVuY3Rpb24gaXNLdWJlcm5ldGVzRW5naW5lKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGdjcE1ldGFkYXRhLmluc3RhbmNlKCdhdHRyaWJ1dGVzL2NsdXN0ZXItbmFtZScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGlzQ29tcHV0ZUVuZ2luZSgpIHtcbiAgICByZXR1cm4gZ2NwTWV0YWRhdGEuaXNBdmFpbGFibGUoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudkRldGVjdC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRFbnYiLCJjbGVhciIsIkdDUEVudiIsImdjcE1ldGFkYXRhIiwicmVxdWlyZSIsImVudlByb21pc2UiLCJ1bmRlZmluZWQiLCJnZXRFbnZNZW1vaXplZCIsImVudiIsIk5PTkUiLCJpc0FwcEVuZ2luZSIsIkFQUF9FTkdJTkUiLCJpc0Nsb3VkRnVuY3Rpb24iLCJDTE9VRF9GVU5DVElPTlMiLCJpc0NvbXB1dGVFbmdpbmUiLCJpc0t1YmVybmV0ZXNFbmdpbmUiLCJLVUJFUk5FVEVTX0VOR0lORSIsImlzQ2xvdWRSdW4iLCJDTE9VRF9SVU4iLCJDT01QVVRFX0VOR0lORSIsInByb2Nlc3MiLCJHQUVfU0VSVklDRSIsIkdBRV9NT0RVTEVfTkFNRSIsIkZVTkNUSU9OX05BTUUiLCJGVU5DVElPTl9UQVJHRVQiLCJLX0NPTkZJR1VSQVRJT04iLCJpbnN0YW5jZSIsImUiLCJpc0F2YWlsYWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/envDetect.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/executable-response.js":
/*!********************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/executable-response.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InvalidSubjectTokenError = exports.InvalidMessageFieldError = exports.InvalidCodeFieldError = exports.InvalidTokenTypeFieldError = exports.InvalidExpirationTimeFieldError = exports.InvalidSuccessFieldError = exports.InvalidVersionFieldError = exports.ExecutableResponseError = exports.ExecutableResponse = void 0;\nconst SAML_SUBJECT_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:saml2\";\nconst OIDC_SUBJECT_TOKEN_TYPE1 = \"urn:ietf:params:oauth:token-type:id_token\";\nconst OIDC_SUBJECT_TOKEN_TYPE2 = \"urn:ietf:params:oauth:token-type:jwt\";\n/**\n * Defines the response of a 3rd party executable run by the pluggable auth client.\n */ class ExecutableResponse {\n    /**\n     * Instantiates an ExecutableResponse instance using the provided JSON object\n     * from the output of the executable.\n     * @param responseJson Response from a 3rd party executable, loaded from a\n     * run of the executable or a cached output file.\n     */ constructor(responseJson){\n        // Check that the required fields exist in the json response.\n        if (!responseJson.version) {\n            throw new InvalidVersionFieldError(\"Executable response must contain a 'version' field.\");\n        }\n        if (responseJson.success === undefined) {\n            throw new InvalidSuccessFieldError(\"Executable response must contain a 'success' field.\");\n        }\n        this.version = responseJson.version;\n        this.success = responseJson.success;\n        // Validate required fields for a successful response.\n        if (this.success) {\n            this.expirationTime = responseJson.expiration_time;\n            this.tokenType = responseJson.token_type;\n            // Validate token type field.\n            if (this.tokenType !== SAML_SUBJECT_TOKEN_TYPE && this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE1 && this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE2) {\n                throw new InvalidTokenTypeFieldError(\"Executable response must contain a 'token_type' field when successful \" + `and it must be one of ${OIDC_SUBJECT_TOKEN_TYPE1}, ${OIDC_SUBJECT_TOKEN_TYPE2}, or ${SAML_SUBJECT_TOKEN_TYPE}.`);\n            }\n            // Validate subject token.\n            if (this.tokenType === SAML_SUBJECT_TOKEN_TYPE) {\n                if (!responseJson.saml_response) {\n                    throw new InvalidSubjectTokenError(`Executable response must contain a 'saml_response' field when token_type=${SAML_SUBJECT_TOKEN_TYPE}.`);\n                }\n                this.subjectToken = responseJson.saml_response;\n            } else {\n                if (!responseJson.id_token) {\n                    throw new InvalidSubjectTokenError(\"Executable response must contain a 'id_token' field when \" + `token_type=${OIDC_SUBJECT_TOKEN_TYPE1} or ${OIDC_SUBJECT_TOKEN_TYPE2}.`);\n                }\n                this.subjectToken = responseJson.id_token;\n            }\n        } else {\n            // Both code and message must be provided for unsuccessful responses.\n            if (!responseJson.code) {\n                throw new InvalidCodeFieldError(\"Executable response must contain a 'code' field when unsuccessful.\");\n            }\n            if (!responseJson.message) {\n                throw new InvalidMessageFieldError(\"Executable response must contain a 'message' field when unsuccessful.\");\n            }\n            this.errorCode = responseJson.code;\n            this.errorMessage = responseJson.message;\n        }\n    }\n    /**\n     * @return A boolean representing if the response has a valid token. Returns\n     * true when the response was successful and the token is not expired.\n     */ isValid() {\n        return !this.isExpired() && this.success;\n    }\n    /**\n     * @return A boolean representing if the response is expired. Returns true if the\n     * provided timeout has passed.\n     */ isExpired() {\n        return this.expirationTime !== undefined && this.expirationTime < Math.round(Date.now() / 1000);\n    }\n}\nexports.ExecutableResponse = ExecutableResponse;\n/**\n * An error thrown by the ExecutableResponse class.\n */ class ExecutableResponseError extends Error {\n    constructor(message){\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nexports.ExecutableResponseError = ExecutableResponseError;\n/**\n * An error thrown when the 'version' field in an executable response is missing or invalid.\n */ class InvalidVersionFieldError extends ExecutableResponseError {\n}\nexports.InvalidVersionFieldError = InvalidVersionFieldError;\n/**\n * An error thrown when the 'success' field in an executable response is missing or invalid.\n */ class InvalidSuccessFieldError extends ExecutableResponseError {\n}\nexports.InvalidSuccessFieldError = InvalidSuccessFieldError;\n/**\n * An error thrown when the 'expiration_time' field in an executable response is missing or invalid.\n */ class InvalidExpirationTimeFieldError extends ExecutableResponseError {\n}\nexports.InvalidExpirationTimeFieldError = InvalidExpirationTimeFieldError;\n/**\n * An error thrown when the 'token_type' field in an executable response is missing or invalid.\n */ class InvalidTokenTypeFieldError extends ExecutableResponseError {\n}\nexports.InvalidTokenTypeFieldError = InvalidTokenTypeFieldError;\n/**\n * An error thrown when the 'code' field in an executable response is missing or invalid.\n */ class InvalidCodeFieldError extends ExecutableResponseError {\n}\nexports.InvalidCodeFieldError = InvalidCodeFieldError;\n/**\n * An error thrown when the 'message' field in an executable response is missing or invalid.\n */ class InvalidMessageFieldError extends ExecutableResponseError {\n}\nexports.InvalidMessageFieldError = InvalidMessageFieldError;\n/**\n * An error thrown when the subject token in an executable response is missing or invalid.\n */ class InvalidSubjectTokenError extends ExecutableResponseError {\n}\nexports.InvalidSubjectTokenError = InvalidSubjectTokenError; //# sourceMappingURL=executable-response.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9leGVjdXRhYmxlLXJlc3BvbnNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0NBQWdDLEdBQUdBLGdDQUFnQyxHQUFHQSw2QkFBNkIsR0FBR0Esa0NBQWtDLEdBQUdBLHVDQUF1QyxHQUFHQSxnQ0FBZ0MsR0FBR0EsZ0NBQWdDLEdBQUdBLCtCQUErQixHQUFHQSwwQkFBMEIsR0FBRyxLQUFLO0FBQy9ULE1BQU1XLDBCQUEwQjtBQUNoQyxNQUFNQywyQkFBMkI7QUFDakMsTUFBTUMsMkJBQTJCO0FBQ2pDOztDQUVDLEdBQ0QsTUFBTUg7SUFDRjs7Ozs7S0FLQyxHQUNESSxZQUFZQyxZQUFZLENBQUU7UUFDdEIsNkRBQTZEO1FBQzdELElBQUksQ0FBQ0EsYUFBYUMsT0FBTyxFQUFFO1lBQ3ZCLE1BQU0sSUFBSVIseUJBQXlCO1FBQ3ZDO1FBQ0EsSUFBSU8sYUFBYUUsT0FBTyxLQUFLQyxXQUFXO1lBQ3BDLE1BQU0sSUFBSVgseUJBQXlCO1FBQ3ZDO1FBQ0EsSUFBSSxDQUFDUyxPQUFPLEdBQUdELGFBQWFDLE9BQU87UUFDbkMsSUFBSSxDQUFDQyxPQUFPLEdBQUdGLGFBQWFFLE9BQU87UUFDbkMsc0RBQXNEO1FBQ3RELElBQUksSUFBSSxDQUFDQSxPQUFPLEVBQUU7WUFDZCxJQUFJLENBQUNFLGNBQWMsR0FBR0osYUFBYUssZUFBZTtZQUNsRCxJQUFJLENBQUNDLFNBQVMsR0FBR04sYUFBYU8sVUFBVTtZQUN4Qyw2QkFBNkI7WUFDN0IsSUFBSSxJQUFJLENBQUNELFNBQVMsS0FBS1YsMkJBQ25CLElBQUksQ0FBQ1UsU0FBUyxLQUFLVCw0QkFDbkIsSUFBSSxDQUFDUyxTQUFTLEtBQUtSLDBCQUEwQjtnQkFDN0MsTUFBTSxJQUFJUiwyQkFBMkIsMkVBQ2pDLENBQUMsc0JBQXNCLEVBQUVPLHlCQUF5QixFQUFFLEVBQUVDLHlCQUF5QixLQUFLLEVBQUVGLHdCQUF3QixDQUFDLENBQUM7WUFDeEg7WUFDQSwwQkFBMEI7WUFDMUIsSUFBSSxJQUFJLENBQUNVLFNBQVMsS0FBS1YseUJBQXlCO2dCQUM1QyxJQUFJLENBQUNJLGFBQWFRLGFBQWEsRUFBRTtvQkFDN0IsTUFBTSxJQUFJckIseUJBQXlCLENBQUMseUVBQXlFLEVBQUVTLHdCQUF3QixDQUFDLENBQUM7Z0JBQzdJO2dCQUNBLElBQUksQ0FBQ2EsWUFBWSxHQUFHVCxhQUFhUSxhQUFhO1lBQ2xELE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDUixhQUFhVSxRQUFRLEVBQUU7b0JBQ3hCLE1BQU0sSUFBSXZCLHlCQUF5Qiw4REFDL0IsQ0FBQyxXQUFXLEVBQUVVLHlCQUF5QixJQUFJLEVBQUVDLHlCQUF5QixDQUFDLENBQUM7Z0JBQ2hGO2dCQUNBLElBQUksQ0FBQ1csWUFBWSxHQUFHVCxhQUFhVSxRQUFRO1lBQzdDO1FBQ0osT0FDSztZQUNELHFFQUFxRTtZQUNyRSxJQUFJLENBQUNWLGFBQWFXLElBQUksRUFBRTtnQkFDcEIsTUFBTSxJQUFJdEIsc0JBQXNCO1lBQ3BDO1lBQ0EsSUFBSSxDQUFDVyxhQUFhWSxPQUFPLEVBQUU7Z0JBQ3ZCLE1BQU0sSUFBSXhCLHlCQUF5QjtZQUN2QztZQUNBLElBQUksQ0FBQ3lCLFNBQVMsR0FBR2IsYUFBYVcsSUFBSTtZQUNsQyxJQUFJLENBQUNHLFlBQVksR0FBR2QsYUFBYVksT0FBTztRQUM1QztJQUNKO0lBQ0E7OztLQUdDLEdBQ0RHLFVBQVU7UUFDTixPQUFPLENBQUMsSUFBSSxDQUFDQyxTQUFTLE1BQU0sSUFBSSxDQUFDZCxPQUFPO0lBQzVDO0lBQ0E7OztLQUdDLEdBQ0RjLFlBQVk7UUFDUixPQUFRLElBQUksQ0FBQ1osY0FBYyxLQUFLRCxhQUM1QixJQUFJLENBQUNDLGNBQWMsR0FBR2EsS0FBS0MsS0FBSyxDQUFDQyxLQUFLQyxHQUFHLEtBQUs7SUFDdEQ7QUFDSjtBQUNBbkMsMEJBQTBCLEdBQUdVO0FBQzdCOztDQUVDLEdBQ0QsTUFBTUQsZ0NBQWdDMkI7SUFDbEN0QixZQUFZYSxPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDQTtRQUNON0IsT0FBT3VDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsV0FBV0MsU0FBUztJQUNwRDtBQUNKO0FBQ0F0QywrQkFBK0IsR0FBR1M7QUFDbEM7O0NBRUMsR0FDRCxNQUFNRCxpQ0FBaUNDO0FBQ3ZDO0FBQ0FULGdDQUFnQyxHQUFHUTtBQUNuQzs7Q0FFQyxHQUNELE1BQU1ELGlDQUFpQ0U7QUFDdkM7QUFDQVQsZ0NBQWdDLEdBQUdPO0FBQ25DOztDQUVDLEdBQ0QsTUFBTUQsd0NBQXdDRztBQUM5QztBQUNBVCx1Q0FBdUMsR0FBR007QUFDMUM7O0NBRUMsR0FDRCxNQUFNRCxtQ0FBbUNJO0FBQ3pDO0FBQ0FULGtDQUFrQyxHQUFHSztBQUNyQzs7Q0FFQyxHQUNELE1BQU1ELDhCQUE4Qks7QUFDcEM7QUFDQVQsNkJBQTZCLEdBQUdJO0FBQ2hDOztDQUVDLEdBQ0QsTUFBTUQsaUNBQWlDTTtBQUN2QztBQUNBVCxnQ0FBZ0MsR0FBR0c7QUFDbkM7O0NBRUMsR0FDRCxNQUFNRCxpQ0FBaUNPO0FBQ3ZDO0FBQ0FULGdDQUFnQyxHQUFHRSwwQkFDbkMsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZXhlY3V0YWJsZS1yZXNwb25zZS5qcz9kNTg5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkludmFsaWRTdWJqZWN0VG9rZW5FcnJvciA9IGV4cG9ydHMuSW52YWxpZE1lc3NhZ2VGaWVsZEVycm9yID0gZXhwb3J0cy5JbnZhbGlkQ29kZUZpZWxkRXJyb3IgPSBleHBvcnRzLkludmFsaWRUb2tlblR5cGVGaWVsZEVycm9yID0gZXhwb3J0cy5JbnZhbGlkRXhwaXJhdGlvblRpbWVGaWVsZEVycm9yID0gZXhwb3J0cy5JbnZhbGlkU3VjY2Vzc0ZpZWxkRXJyb3IgPSBleHBvcnRzLkludmFsaWRWZXJzaW9uRmllbGRFcnJvciA9IGV4cG9ydHMuRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3IgPSBleHBvcnRzLkV4ZWN1dGFibGVSZXNwb25zZSA9IHZvaWQgMDtcbmNvbnN0IFNBTUxfU1VCSkVDVF9UT0tFTl9UWVBFID0gJ3VybjppZXRmOnBhcmFtczpvYXV0aDp0b2tlbi10eXBlOnNhbWwyJztcbmNvbnN0IE9JRENfU1VCSkVDVF9UT0tFTl9UWVBFMSA9ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6dG9rZW4tdHlwZTppZF90b2tlbic7XG5jb25zdCBPSURDX1NVQkpFQ1RfVE9LRU5fVFlQRTIgPSAndXJuOmlldGY6cGFyYW1zOm9hdXRoOnRva2VuLXR5cGU6and0Jztcbi8qKlxuICogRGVmaW5lcyB0aGUgcmVzcG9uc2Ugb2YgYSAzcmQgcGFydHkgZXhlY3V0YWJsZSBydW4gYnkgdGhlIHBsdWdnYWJsZSBhdXRoIGNsaWVudC5cbiAqL1xuY2xhc3MgRXhlY3V0YWJsZVJlc3BvbnNlIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYW4gRXhlY3V0YWJsZVJlc3BvbnNlIGluc3RhbmNlIHVzaW5nIHRoZSBwcm92aWRlZCBKU09OIG9iamVjdFxuICAgICAqIGZyb20gdGhlIG91dHB1dCBvZiB0aGUgZXhlY3V0YWJsZS5cbiAgICAgKiBAcGFyYW0gcmVzcG9uc2VKc29uIFJlc3BvbnNlIGZyb20gYSAzcmQgcGFydHkgZXhlY3V0YWJsZSwgbG9hZGVkIGZyb20gYVxuICAgICAqIHJ1biBvZiB0aGUgZXhlY3V0YWJsZSBvciBhIGNhY2hlZCBvdXRwdXQgZmlsZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZUpzb24pIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgcmVxdWlyZWQgZmllbGRzIGV4aXN0IGluIHRoZSBqc29uIHJlc3BvbnNlLlxuICAgICAgICBpZiAoIXJlc3BvbnNlSnNvbi52ZXJzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFZlcnNpb25GaWVsZEVycm9yKFwiRXhlY3V0YWJsZSByZXNwb25zZSBtdXN0IGNvbnRhaW4gYSAndmVyc2lvbicgZmllbGQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZUpzb24uc3VjY2VzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN1Y2Nlc3NGaWVsZEVycm9yKFwiRXhlY3V0YWJsZSByZXNwb25zZSBtdXN0IGNvbnRhaW4gYSAnc3VjY2VzcycgZmllbGQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHJlc3BvbnNlSnNvbi52ZXJzaW9uO1xuICAgICAgICB0aGlzLnN1Y2Nlc3MgPSByZXNwb25zZUpzb24uc3VjY2VzcztcbiAgICAgICAgLy8gVmFsaWRhdGUgcmVxdWlyZWQgZmllbGRzIGZvciBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gICAgICAgIGlmICh0aGlzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWUgPSByZXNwb25zZUpzb24uZXhwaXJhdGlvbl90aW1lO1xuICAgICAgICAgICAgdGhpcy50b2tlblR5cGUgPSByZXNwb25zZUpzb24udG9rZW5fdHlwZTtcbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRva2VuIHR5cGUgZmllbGQuXG4gICAgICAgICAgICBpZiAodGhpcy50b2tlblR5cGUgIT09IFNBTUxfU1VCSkVDVF9UT0tFTl9UWVBFICYmXG4gICAgICAgICAgICAgICAgdGhpcy50b2tlblR5cGUgIT09IE9JRENfU1VCSkVDVF9UT0tFTl9UWVBFMSAmJlxuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5UeXBlICE9PSBPSURDX1NVQkpFQ1RfVE9LRU5fVFlQRTIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFRva2VuVHlwZUZpZWxkRXJyb3IoXCJFeGVjdXRhYmxlIHJlc3BvbnNlIG11c3QgY29udGFpbiBhICd0b2tlbl90eXBlJyBmaWVsZCB3aGVuIHN1Y2Nlc3NmdWwgXCIgK1xuICAgICAgICAgICAgICAgICAgICBgYW5kIGl0IG11c3QgYmUgb25lIG9mICR7T0lEQ19TVUJKRUNUX1RPS0VOX1RZUEUxfSwgJHtPSURDX1NVQkpFQ1RfVE9LRU5fVFlQRTJ9LCBvciAke1NBTUxfU1VCSkVDVF9UT0tFTl9UWVBFfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIHN1YmplY3QgdG9rZW4uXG4gICAgICAgICAgICBpZiAodGhpcy50b2tlblR5cGUgPT09IFNBTUxfU1VCSkVDVF9UT0tFTl9UWVBFKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZUpzb24uc2FtbF9yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN1YmplY3RUb2tlbkVycm9yKGBFeGVjdXRhYmxlIHJlc3BvbnNlIG11c3QgY29udGFpbiBhICdzYW1sX3Jlc3BvbnNlJyBmaWVsZCB3aGVuIHRva2VuX3R5cGU9JHtTQU1MX1NVQkpFQ1RfVE9LRU5fVFlQRX0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3ViamVjdFRva2VuID0gcmVzcG9uc2VKc29uLnNhbWxfcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlSnNvbi5pZF90b2tlbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN1YmplY3RUb2tlbkVycm9yKFwiRXhlY3V0YWJsZSByZXNwb25zZSBtdXN0IGNvbnRhaW4gYSAnaWRfdG9rZW4nIGZpZWxkIHdoZW4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYHRva2VuX3R5cGU9JHtPSURDX1NVQkpFQ1RfVE9LRU5fVFlQRTF9IG9yICR7T0lEQ19TVUJKRUNUX1RPS0VOX1RZUEUyfS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJqZWN0VG9rZW4gPSByZXNwb25zZUpzb24uaWRfdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBCb3RoIGNvZGUgYW5kIG1lc3NhZ2UgbXVzdCBiZSBwcm92aWRlZCBmb3IgdW5zdWNjZXNzZnVsIHJlc3BvbnNlcy5cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VKc29uLmNvZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZENvZGVGaWVsZEVycm9yKFwiRXhlY3V0YWJsZSByZXNwb25zZSBtdXN0IGNvbnRhaW4gYSAnY29kZScgZmllbGQgd2hlbiB1bnN1Y2Nlc3NmdWwuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZUpzb24ubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVzc2FnZUZpZWxkRXJyb3IoXCJFeGVjdXRhYmxlIHJlc3BvbnNlIG11c3QgY29udGFpbiBhICdtZXNzYWdlJyBmaWVsZCB3aGVuIHVuc3VjY2Vzc2Z1bC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVycm9yQ29kZSA9IHJlc3BvbnNlSnNvbi5jb2RlO1xuICAgICAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UgPSByZXNwb25zZUpzb24ubWVzc2FnZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgaWYgdGhlIHJlc3BvbnNlIGhhcyBhIHZhbGlkIHRva2VuLiBSZXR1cm5zXG4gICAgICogdHJ1ZSB3aGVuIHRoZSByZXNwb25zZSB3YXMgc3VjY2Vzc2Z1bCBhbmQgdGhlIHRva2VuIGlzIG5vdCBleHBpcmVkLlxuICAgICAqL1xuICAgIGlzVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc0V4cGlyZWQoKSAmJiB0aGlzLnN1Y2Nlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gQSBib29sZWFuIHJlcHJlc2VudGluZyBpZiB0aGUgcmVzcG9uc2UgaXMgZXhwaXJlZC4gUmV0dXJucyB0cnVlIGlmIHRoZVxuICAgICAqIHByb3ZpZGVkIHRpbWVvdXQgaGFzIHBhc3NlZC5cbiAgICAgKi9cbiAgICBpc0V4cGlyZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5leHBpcmF0aW9uVGltZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmV4cGlyYXRpb25UaW1lIDwgTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXhlY3V0YWJsZVJlc3BvbnNlID0gRXhlY3V0YWJsZVJlc3BvbnNlO1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gYnkgdGhlIEV4ZWN1dGFibGVSZXNwb25zZSBjbGFzcy5cbiAqL1xuY2xhc3MgRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLkV4ZWN1dGFibGVSZXNwb25zZUVycm9yID0gRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3I7XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIHRoZSAndmVyc2lvbicgZmllbGQgaW4gYW4gZXhlY3V0YWJsZSByZXNwb25zZSBpcyBtaXNzaW5nIG9yIGludmFsaWQuXG4gKi9cbmNsYXNzIEludmFsaWRWZXJzaW9uRmllbGRFcnJvciBleHRlbmRzIEV4ZWN1dGFibGVSZXNwb25zZUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZFZlcnNpb25GaWVsZEVycm9yID0gSW52YWxpZFZlcnNpb25GaWVsZEVycm9yO1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiB0aGUgJ3N1Y2Nlc3MnIGZpZWxkIGluIGFuIGV4ZWN1dGFibGUgcmVzcG9uc2UgaXMgbWlzc2luZyBvciBpbnZhbGlkLlxuICovXG5jbGFzcyBJbnZhbGlkU3VjY2Vzc0ZpZWxkRXJyb3IgZXh0ZW5kcyBFeGVjdXRhYmxlUmVzcG9uc2VFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRTdWNjZXNzRmllbGRFcnJvciA9IEludmFsaWRTdWNjZXNzRmllbGRFcnJvcjtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gdGhlICdleHBpcmF0aW9uX3RpbWUnIGZpZWxkIGluIGFuIGV4ZWN1dGFibGUgcmVzcG9uc2UgaXMgbWlzc2luZyBvciBpbnZhbGlkLlxuICovXG5jbGFzcyBJbnZhbGlkRXhwaXJhdGlvblRpbWVGaWVsZEVycm9yIGV4dGVuZHMgRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkRXhwaXJhdGlvblRpbWVGaWVsZEVycm9yID0gSW52YWxpZEV4cGlyYXRpb25UaW1lRmllbGRFcnJvcjtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gdGhlICd0b2tlbl90eXBlJyBmaWVsZCBpbiBhbiBleGVjdXRhYmxlIHJlc3BvbnNlIGlzIG1pc3Npbmcgb3IgaW52YWxpZC5cbiAqL1xuY2xhc3MgSW52YWxpZFRva2VuVHlwZUZpZWxkRXJyb3IgZXh0ZW5kcyBFeGVjdXRhYmxlUmVzcG9uc2VFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRUb2tlblR5cGVGaWVsZEVycm9yID0gSW52YWxpZFRva2VuVHlwZUZpZWxkRXJyb3I7XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIHRoZSAnY29kZScgZmllbGQgaW4gYW4gZXhlY3V0YWJsZSByZXNwb25zZSBpcyBtaXNzaW5nIG9yIGludmFsaWQuXG4gKi9cbmNsYXNzIEludmFsaWRDb2RlRmllbGRFcnJvciBleHRlbmRzIEV4ZWN1dGFibGVSZXNwb25zZUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZENvZGVGaWVsZEVycm9yID0gSW52YWxpZENvZGVGaWVsZEVycm9yO1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiB0aGUgJ21lc3NhZ2UnIGZpZWxkIGluIGFuIGV4ZWN1dGFibGUgcmVzcG9uc2UgaXMgbWlzc2luZyBvciBpbnZhbGlkLlxuICovXG5jbGFzcyBJbnZhbGlkTWVzc2FnZUZpZWxkRXJyb3IgZXh0ZW5kcyBFeGVjdXRhYmxlUmVzcG9uc2VFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRNZXNzYWdlRmllbGRFcnJvciA9IEludmFsaWRNZXNzYWdlRmllbGRFcnJvcjtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gdGhlIHN1YmplY3QgdG9rZW4gaW4gYW4gZXhlY3V0YWJsZSByZXNwb25zZSBpcyBtaXNzaW5nIG9yIGludmFsaWQuXG4gKi9cbmNsYXNzIEludmFsaWRTdWJqZWN0VG9rZW5FcnJvciBleHRlbmRzIEV4ZWN1dGFibGVSZXNwb25zZUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZFN1YmplY3RUb2tlbkVycm9yID0gSW52YWxpZFN1YmplY3RUb2tlbkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhlY3V0YWJsZS1yZXNwb25zZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJJbnZhbGlkU3ViamVjdFRva2VuRXJyb3IiLCJJbnZhbGlkTWVzc2FnZUZpZWxkRXJyb3IiLCJJbnZhbGlkQ29kZUZpZWxkRXJyb3IiLCJJbnZhbGlkVG9rZW5UeXBlRmllbGRFcnJvciIsIkludmFsaWRFeHBpcmF0aW9uVGltZUZpZWxkRXJyb3IiLCJJbnZhbGlkU3VjY2Vzc0ZpZWxkRXJyb3IiLCJJbnZhbGlkVmVyc2lvbkZpZWxkRXJyb3IiLCJFeGVjdXRhYmxlUmVzcG9uc2VFcnJvciIsIkV4ZWN1dGFibGVSZXNwb25zZSIsIlNBTUxfU1VCSkVDVF9UT0tFTl9UWVBFIiwiT0lEQ19TVUJKRUNUX1RPS0VOX1RZUEUxIiwiT0lEQ19TVUJKRUNUX1RPS0VOX1RZUEUyIiwiY29uc3RydWN0b3IiLCJyZXNwb25zZUpzb24iLCJ2ZXJzaW9uIiwic3VjY2VzcyIsInVuZGVmaW5lZCIsImV4cGlyYXRpb25UaW1lIiwiZXhwaXJhdGlvbl90aW1lIiwidG9rZW5UeXBlIiwidG9rZW5fdHlwZSIsInNhbWxfcmVzcG9uc2UiLCJzdWJqZWN0VG9rZW4iLCJpZF90b2tlbiIsImNvZGUiLCJtZXNzYWdlIiwiZXJyb3JDb2RlIiwiZXJyb3JNZXNzYWdlIiwiaXNWYWxpZCIsImlzRXhwaXJlZCIsIk1hdGgiLCJyb3VuZCIsIkRhdGUiLCJub3ciLCJFcnJvciIsInNldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/executable-response.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ExternalAccountAuthorizedUserClient = exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = void 0;\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst oauth2common_1 = __webpack_require__(/*! ./oauth2common */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2common.js\");\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\n/**\n * The credentials JSON file type for external account authorized user clients.\n */ exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = \"external_account_authorized_user\";\n/**\n * Handler for token refresh requests sent to the token_url endpoint for external\n * authorized user credentials.\n */ class ExternalAccountAuthorizedUserHandler extends oauth2common_1.OAuthClientAuthHandler {\n    /**\n     * Initializes an ExternalAccountAuthorizedUserHandler instance.\n     * @param url The URL of the token refresh endpoint.\n     * @param transporter The transporter to use for the refresh request.\n     * @param clientAuthentication The client authentication credentials to use\n     *   for the refresh request.\n     */ constructor(url, transporter, clientAuthentication){\n        super(clientAuthentication);\n        this.url = url;\n        this.transporter = transporter;\n    }\n    /**\n     * Requests a new access token from the token_url endpoint using the provided\n     *   refresh token.\n     * @param refreshToken The refresh token to use to generate a new access token.\n     * @param additionalHeaders Optional additional headers to pass along the\n     *   request.\n     * @return A promise that resolves with the token refresh response containing\n     *   the requested access token and its expiration time.\n     */ async refreshToken(refreshToken, additionalHeaders) {\n        const values = new URLSearchParams({\n            grant_type: \"refresh_token\",\n            refresh_token: refreshToken\n        });\n        const headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            ...additionalHeaders\n        };\n        const opts = {\n            url: this.url,\n            method: \"POST\",\n            headers,\n            data: values.toString(),\n            responseType: \"json\"\n        };\n        // Apply OAuth client authentication.\n        this.applyClientAuthenticationOptions(opts);\n        try {\n            const response = await this.transporter.request(opts);\n            // Successful response.\n            const tokenRefreshResponse = response.data;\n            tokenRefreshResponse.res = response;\n            return tokenRefreshResponse;\n        } catch (error) {\n            // Translate error to OAuthError.\n            if (error instanceof gaxios_1.GaxiosError && error.response) {\n                throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(error.response.data, // Preserve other fields from the original error.\n                error);\n            }\n            // Request could fail before the server responds.\n            throw error;\n        }\n    }\n}\n/**\n * External Account Authorized User Client. This is used for OAuth2 credentials\n * sourced using external identities through Workforce Identity Federation.\n * Obtaining the initial access and refresh token can be done through the\n * Google Cloud CLI.\n */ class ExternalAccountAuthorizedUserClient extends authclient_1.AuthClient {\n    /**\n     * Instantiates an ExternalAccountAuthorizedUserClient instances using the\n     * provided JSON object loaded from a credentials files.\n     * An error is throws if the credential is not valid.\n     * @param options The external account authorized user option object typically\n     *   from the external accoutn authorized user JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     */ constructor(options, additionalOptions){\n        super();\n        this.refreshToken = options.refresh_token;\n        const clientAuth = {\n            confidentialClientType: \"basic\",\n            clientId: options.client_id,\n            clientSecret: options.client_secret\n        };\n        this.externalAccountAuthorizedUserHandler = new ExternalAccountAuthorizedUserHandler(options.token_url, this.transporter, clientAuth);\n        this.cachedAccessToken = null;\n        this.quotaProjectId = options.quota_project_id;\n        // As threshold could be zero,\n        // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n        // zero value.\n        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== \"number\") {\n            this.eagerRefreshThresholdMillis = baseexternalclient_1.EXPIRATION_TIME_OFFSET;\n        } else {\n            this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;\n        }\n        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n    }\n    async getAccessToken() {\n        // If cached access token is unavailable or expired, force refresh.\n        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return GCP access token in GetAccessTokenResponse format.\n        return {\n            token: this.cachedAccessToken.access_token,\n            res: this.cachedAccessToken.res\n        };\n    }\n    async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then((r)=>callback(null, r), (e)=>{\n                return callback(e, e.response);\n            });\n        } else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param retry Whether the current attempt is a retry after a failed attempt.\n     * @return A promise that resolves with the successful response.\n     */ async requestAsync(opts, retry = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders[\"x-goog-user-project\"]) {\n                opts.headers[\"x-goog-user-project\"] = requestHeaders[\"x-goog-user-project\"];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        } catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * @return A promise that resolves with the refreshed credential.\n     */ async refreshAccessTokenAsync() {\n        // Refresh the access token using the refresh token.\n        const refreshResponse = await this.externalAccountAuthorizedUserHandler.refreshToken(this.refreshToken);\n        this.cachedAccessToken = {\n            access_token: refreshResponse.access_token,\n            expiry_date: new Date().getTime() + refreshResponse.expires_in * 1000,\n            res: refreshResponse.res\n        };\n        if (refreshResponse.refresh_token !== undefined) {\n            this.refreshToken = refreshResponse.refresh_token;\n        }\n        return this.cachedAccessToken;\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param credentials The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */ isExpired(credentials) {\n        const now = new Date().getTime();\n        return credentials.expiry_date ? now >= credentials.expiry_date - this.eagerRefreshThresholdMillis : false;\n    }\n}\nexports.ExternalAccountAuthorizedUserClient = ExternalAccountAuthorizedUserClient; //# sourceMappingURL=externalAccountAuthorizedUserClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9leHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJDQUEyQyxHQUFHQSw2Q0FBNkMsR0FBRyxLQUFLO0FBQ25HLE1BQU1JLGVBQWVDLG1CQUFPQSxDQUFDLDJGQUFjO0FBQzNDLE1BQU1DLGlCQUFpQkQsbUJBQU9BLENBQUMsK0ZBQWdCO0FBQy9DLE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLDhEQUFRO0FBQ2pDLE1BQU1HLFNBQVNILG1CQUFPQSxDQUFDLHNCQUFRO0FBQy9CLE1BQU1JLHVCQUF1QkosbUJBQU9BLENBQUMsMkdBQXNCO0FBQzNEOztDQUVDLEdBQ0RMLDZDQUE2QyxHQUFHO0FBQ2hEOzs7Q0FHQyxHQUNELE1BQU1VLDZDQUE2Q0osZUFBZUssc0JBQXNCO0lBQ3BGOzs7Ozs7S0FNQyxHQUNEQyxZQUFZQyxHQUFHLEVBQUVDLFdBQVcsRUFBRUMsb0JBQW9CLENBQUU7UUFDaEQsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0YsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsV0FBVyxHQUFHQTtJQUN2QjtJQUNBOzs7Ozs7OztLQVFDLEdBQ0QsTUFBTUUsYUFBYUEsWUFBWSxFQUFFQyxpQkFBaUIsRUFBRTtRQUNoRCxNQUFNQyxTQUFTLElBQUlDLGdCQUFnQjtZQUMvQkMsWUFBWTtZQUNaQyxlQUFlTDtRQUNuQjtRQUNBLE1BQU1NLFVBQVU7WUFDWixnQkFBZ0I7WUFDaEIsR0FBR0wsaUJBQWlCO1FBQ3hCO1FBQ0EsTUFBTU0sT0FBTztZQUNUVixLQUFLLElBQUksQ0FBQ0EsR0FBRztZQUNiVyxRQUFRO1lBQ1JGO1lBQ0FHLE1BQU1QLE9BQU9RLFFBQVE7WUFDckJDLGNBQWM7UUFDbEI7UUFDQSxxQ0FBcUM7UUFDckMsSUFBSSxDQUFDQyxnQ0FBZ0MsQ0FBQ0w7UUFDdEMsSUFBSTtZQUNBLE1BQU1NLFdBQVcsTUFBTSxJQUFJLENBQUNmLFdBQVcsQ0FBQ2dCLE9BQU8sQ0FBQ1A7WUFDaEQsdUJBQXVCO1lBQ3ZCLE1BQU1RLHVCQUF1QkYsU0FBU0osSUFBSTtZQUMxQ00scUJBQXFCQyxHQUFHLEdBQUdIO1lBQzNCLE9BQU9FO1FBQ1gsRUFDQSxPQUFPRSxPQUFPO1lBQ1YsaUNBQWlDO1lBQ2pDLElBQUlBLGlCQUFpQjFCLFNBQVMyQixXQUFXLElBQUlELE1BQU1KLFFBQVEsRUFBRTtnQkFDekQsTUFBTSxDQUFDLEdBQUd2QixlQUFlNkIsOEJBQThCLEVBQUVGLE1BQU1KLFFBQVEsQ0FBQ0osSUFBSSxFQUM1RSxpREFBaUQ7Z0JBQ2pEUTtZQUNKO1lBQ0EsaURBQWlEO1lBQ2pELE1BQU1BO1FBQ1Y7SUFDSjtBQUNKO0FBQ0E7Ozs7O0NBS0MsR0FDRCxNQUFNL0IsNENBQTRDRSxhQUFhZ0MsVUFBVTtJQUNyRTs7Ozs7Ozs7O0tBU0MsR0FDRHhCLFlBQVl5QixPQUFPLEVBQUVDLGlCQUFpQixDQUFFO1FBQ3BDLEtBQUs7UUFDTCxJQUFJLENBQUN0QixZQUFZLEdBQUdxQixRQUFRaEIsYUFBYTtRQUN6QyxNQUFNa0IsYUFBYTtZQUNmQyx3QkFBd0I7WUFDeEJDLFVBQVVKLFFBQVFLLFNBQVM7WUFDM0JDLGNBQWNOLFFBQVFPLGFBQWE7UUFDdkM7UUFDQSxJQUFJLENBQUNDLG9DQUFvQyxHQUNyQyxJQUFJbkMscUNBQXFDMkIsUUFBUVMsU0FBUyxFQUFFLElBQUksQ0FBQ2hDLFdBQVcsRUFBRXlCO1FBQ2xGLElBQUksQ0FBQ1EsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDQyxjQUFjLEdBQUdYLFFBQVFZLGdCQUFnQjtRQUM5Qyw4QkFBOEI7UUFDOUIsMEVBQTBFO1FBQzFFLGNBQWM7UUFDZCxJQUFJLE9BQVFYLENBQUFBLHNCQUFzQixRQUFRQSxzQkFBc0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsa0JBQWtCWSwyQkFBMkIsTUFBTSxVQUFVO1lBQzNJLElBQUksQ0FBQ0EsMkJBQTJCLEdBQUd6QyxxQkFBcUIwQyxzQkFBc0I7UUFDbEYsT0FDSztZQUNELElBQUksQ0FBQ0QsMkJBQTJCLEdBQUdaLGtCQUM5QlksMkJBQTJCO1FBQ3BDO1FBQ0EsSUFBSSxDQUFDRSxxQkFBcUIsR0FBRyxDQUFDLENBQUVkLENBQUFBLHNCQUFzQixRQUFRQSxzQkFBc0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsa0JBQWtCYyxxQkFBcUI7SUFDako7SUFDQSxNQUFNQyxpQkFBaUI7UUFDbkIsbUVBQW1FO1FBQ25FLElBQUksQ0FBQyxJQUFJLENBQUNOLGlCQUFpQixJQUFJLElBQUksQ0FBQ08sU0FBUyxDQUFDLElBQUksQ0FBQ1AsaUJBQWlCLEdBQUc7WUFDbkUsTUFBTSxJQUFJLENBQUNRLHVCQUF1QjtRQUN0QztRQUNBLDREQUE0RDtRQUM1RCxPQUFPO1lBQ0hDLE9BQU8sSUFBSSxDQUFDVCxpQkFBaUIsQ0FBQ1UsWUFBWTtZQUMxQ3pCLEtBQUssSUFBSSxDQUFDZSxpQkFBaUIsQ0FBQ2YsR0FBRztRQUNuQztJQUNKO0lBQ0EsTUFBTTBCLG9CQUFvQjtRQUN0QixNQUFNQyxzQkFBc0IsTUFBTSxJQUFJLENBQUNOLGNBQWM7UUFDckQsTUFBTS9CLFVBQVU7WUFDWnNDLGVBQWUsQ0FBQyxPQUFPLEVBQUVELG9CQUFvQkgsS0FBSyxDQUFDLENBQUM7UUFDeEQ7UUFDQSxPQUFPLElBQUksQ0FBQ0ssd0JBQXdCLENBQUN2QztJQUN6QztJQUNBUSxRQUFRUCxJQUFJLEVBQUV1QyxRQUFRLEVBQUU7UUFDcEIsSUFBSUEsVUFBVTtZQUNWLElBQUksQ0FBQ0MsWUFBWSxDQUFDeEMsTUFBTXlDLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0gsU0FBUyxNQUFNRyxJQUFJQyxDQUFBQTtnQkFDakQsT0FBT0osU0FBU0ksR0FBR0EsRUFBRXJDLFFBQVE7WUFDakM7UUFDSixPQUNLO1lBQ0QsT0FBTyxJQUFJLENBQUNrQyxZQUFZLENBQUN4QztRQUM3QjtJQUNKO0lBQ0E7Ozs7OztLQU1DLEdBQ0QsTUFBTXdDLGFBQWF4QyxJQUFJLEVBQUU0QyxRQUFRLEtBQUssRUFBRTtRQUNwQyxJQUFJdEM7UUFDSixJQUFJO1lBQ0EsTUFBTXVDLGlCQUFpQixNQUFNLElBQUksQ0FBQ1YsaUJBQWlCO1lBQ25EbkMsS0FBS0QsT0FBTyxHQUFHQyxLQUFLRCxPQUFPLElBQUksQ0FBQztZQUNoQyxJQUFJOEMsa0JBQWtCQSxjQUFjLENBQUMsc0JBQXNCLEVBQUU7Z0JBQ3pEN0MsS0FBS0QsT0FBTyxDQUFDLHNCQUFzQixHQUMvQjhDLGNBQWMsQ0FBQyxzQkFBc0I7WUFDN0M7WUFDQSxJQUFJQSxrQkFBa0JBLGVBQWVSLGFBQWEsRUFBRTtnQkFDaERyQyxLQUFLRCxPQUFPLENBQUNzQyxhQUFhLEdBQUdRLGVBQWVSLGFBQWE7WUFDN0Q7WUFDQS9CLFdBQVcsTUFBTSxJQUFJLENBQUNmLFdBQVcsQ0FBQ2dCLE9BQU8sQ0FBQ1A7UUFDOUMsRUFDQSxPQUFPMkMsR0FBRztZQUNOLE1BQU1sQyxNQUFNa0MsRUFBRXJDLFFBQVE7WUFDdEIsSUFBSUcsS0FBSztnQkFDTCxNQUFNcUMsYUFBYXJDLElBQUlzQyxNQUFNO2dCQUM3QixxRUFBcUU7Z0JBQ3JFLG9FQUFvRTtnQkFDcEUsb0NBQW9DO2dCQUNwQyw2Q0FBNkM7Z0JBQzdDLGtDQUFrQztnQkFDbEMsTUFBTUMsbUJBQW1CdkMsSUFBSXdDLE1BQU0sQ0FBQy9DLElBQUksWUFBWWpCLE9BQU9pRSxRQUFRO2dCQUNuRSxNQUFNQyxZQUFZTCxlQUFlLE9BQU9BLGVBQWU7Z0JBQ3ZELElBQUksQ0FBQ0YsU0FDRE8sYUFDQSxDQUFDSCxvQkFDRCxJQUFJLENBQUNuQixxQkFBcUIsRUFBRTtvQkFDNUIsTUFBTSxJQUFJLENBQUNHLHVCQUF1QjtvQkFDbEMsT0FBTyxNQUFNLElBQUksQ0FBQ1EsWUFBWSxDQUFDeEMsTUFBTTtnQkFDekM7WUFDSjtZQUNBLE1BQU0yQztRQUNWO1FBQ0EsT0FBT3JDO0lBQ1g7SUFDQTs7O0tBR0MsR0FDRCxNQUFNMEIsMEJBQTBCO1FBQzVCLG9EQUFvRDtRQUNwRCxNQUFNb0Isa0JBQWtCLE1BQU0sSUFBSSxDQUFDOUIsb0NBQW9DLENBQUM3QixZQUFZLENBQUMsSUFBSSxDQUFDQSxZQUFZO1FBQ3RHLElBQUksQ0FBQytCLGlCQUFpQixHQUFHO1lBQ3JCVSxjQUFja0IsZ0JBQWdCbEIsWUFBWTtZQUMxQ21CLGFBQWEsSUFBSUMsT0FBT0MsT0FBTyxLQUFLSCxnQkFBZ0JJLFVBQVUsR0FBRztZQUNqRS9DLEtBQUsyQyxnQkFBZ0IzQyxHQUFHO1FBQzVCO1FBQ0EsSUFBSTJDLGdCQUFnQnRELGFBQWEsS0FBSzJELFdBQVc7WUFDN0MsSUFBSSxDQUFDaEUsWUFBWSxHQUFHMkQsZ0JBQWdCdEQsYUFBYTtRQUNyRDtRQUNBLE9BQU8sSUFBSSxDQUFDMEIsaUJBQWlCO0lBQ2pDO0lBQ0E7Ozs7O0tBS0MsR0FDRE8sVUFBVTJCLFdBQVcsRUFBRTtRQUNuQixNQUFNQyxNQUFNLElBQUlMLE9BQU9DLE9BQU87UUFDOUIsT0FBT0csWUFBWUwsV0FBVyxHQUN4Qk0sT0FBT0QsWUFBWUwsV0FBVyxHQUFHLElBQUksQ0FBQzFCLDJCQUEyQixHQUNqRTtJQUNWO0FBQ0o7QUFDQWxELDJDQUEyQyxHQUFHRSxxQ0FDOUMsK0RBQStEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnQuanM/ODZkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FeHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudCA9IGV4cG9ydHMuRVhURVJOQUxfQUNDT1VOVF9BVVRIT1JJWkVEX1VTRVJfVFlQRSA9IHZvaWQgMDtcbmNvbnN0IGF1dGhjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGhjbGllbnRcIik7XG5jb25zdCBvYXV0aDJjb21tb25fMSA9IHJlcXVpcmUoXCIuL29hdXRoMmNvbW1vblwiKTtcbmNvbnN0IGdheGlvc18xID0gcmVxdWlyZShcImdheGlvc1wiKTtcbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCBiYXNlZXh0ZXJuYWxjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2Jhc2VleHRlcm5hbGNsaWVudFwiKTtcbi8qKlxuICogVGhlIGNyZWRlbnRpYWxzIEpTT04gZmlsZSB0eXBlIGZvciBleHRlcm5hbCBhY2NvdW50IGF1dGhvcml6ZWQgdXNlciBjbGllbnRzLlxuICovXG5leHBvcnRzLkVYVEVSTkFMX0FDQ09VTlRfQVVUSE9SSVpFRF9VU0VSX1RZUEUgPSAnZXh0ZXJuYWxfYWNjb3VudF9hdXRob3JpemVkX3VzZXInO1xuLyoqXG4gKiBIYW5kbGVyIGZvciB0b2tlbiByZWZyZXNoIHJlcXVlc3RzIHNlbnQgdG8gdGhlIHRva2VuX3VybCBlbmRwb2ludCBmb3IgZXh0ZXJuYWxcbiAqIGF1dGhvcml6ZWQgdXNlciBjcmVkZW50aWFscy5cbiAqL1xuY2xhc3MgRXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJIYW5kbGVyIGV4dGVuZHMgb2F1dGgyY29tbW9uXzEuT0F1dGhDbGllbnRBdXRoSGFuZGxlciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gRXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJIYW5kbGVyIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB1cmwgVGhlIFVSTCBvZiB0aGUgdG9rZW4gcmVmcmVzaCBlbmRwb2ludC5cbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0ZXIgVGhlIHRyYW5zcG9ydGVyIHRvIHVzZSBmb3IgdGhlIHJlZnJlc2ggcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gY2xpZW50QXV0aGVudGljYXRpb24gVGhlIGNsaWVudCBhdXRoZW50aWNhdGlvbiBjcmVkZW50aWFscyB0byB1c2VcbiAgICAgKiAgIGZvciB0aGUgcmVmcmVzaCByZXF1ZXN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCwgdHJhbnNwb3J0ZXIsIGNsaWVudEF1dGhlbnRpY2F0aW9uKSB7XG4gICAgICAgIHN1cGVyKGNsaWVudEF1dGhlbnRpY2F0aW9uKTtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ZXIgPSB0cmFuc3BvcnRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgYSBuZXcgYWNjZXNzIHRva2VuIGZyb20gdGhlIHRva2VuX3VybCBlbmRwb2ludCB1c2luZyB0aGUgcHJvdmlkZWRcbiAgICAgKiAgIHJlZnJlc2ggdG9rZW4uXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBUaGUgcmVmcmVzaCB0b2tlbiB0byB1c2UgdG8gZ2VuZXJhdGUgYSBuZXcgYWNjZXNzIHRva2VuLlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsSGVhZGVycyBPcHRpb25hbCBhZGRpdGlvbmFsIGhlYWRlcnMgdG8gcGFzcyBhbG9uZyB0aGVcbiAgICAgKiAgIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSB0b2tlbiByZWZyZXNoIHJlc3BvbnNlIGNvbnRhaW5pbmdcbiAgICAgKiAgIHRoZSByZXF1ZXN0ZWQgYWNjZXNzIHRva2VuIGFuZCBpdHMgZXhwaXJhdGlvbiB0aW1lLlxuICAgICAqL1xuICAgIGFzeW5jIHJlZnJlc2hUb2tlbihyZWZyZXNoVG9rZW4sIGFkZGl0aW9uYWxIZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgZ3JhbnRfdHlwZTogJ3JlZnJlc2hfdG9rZW4nLFxuICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgIC4uLmFkZGl0aW9uYWxIZWFkZXJzLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGRhdGE6IHZhbHVlcy50b1N0cmluZygpLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIC8vIEFwcGx5IE9BdXRoIGNsaWVudCBhdXRoZW50aWNhdGlvbi5cbiAgICAgICAgdGhpcy5hcHBseUNsaWVudEF1dGhlbnRpY2F0aW9uT3B0aW9ucyhvcHRzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICAgICAgLy8gU3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAgICAgICAgICAgIGNvbnN0IHRva2VuUmVmcmVzaFJlc3BvbnNlID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIHRva2VuUmVmcmVzaFJlc3BvbnNlLnJlcyA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuUmVmcmVzaFJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gVHJhbnNsYXRlIGVycm9yIHRvIE9BdXRoRXJyb3IuXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBnYXhpb3NfMS5HYXhpb3NFcnJvciAmJiBlcnJvci5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCBvYXV0aDJjb21tb25fMS5nZXRFcnJvckZyb21PQXV0aEVycm9yUmVzcG9uc2UpKGVycm9yLnJlc3BvbnNlLmRhdGEsIFxuICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIG90aGVyIGZpZWxkcyBmcm9tIHRoZSBvcmlnaW5hbCBlcnJvci5cbiAgICAgICAgICAgICAgICBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXF1ZXN0IGNvdWxkIGZhaWwgYmVmb3JlIHRoZSBzZXJ2ZXIgcmVzcG9uZHMuXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogRXh0ZXJuYWwgQWNjb3VudCBBdXRob3JpemVkIFVzZXIgQ2xpZW50LiBUaGlzIGlzIHVzZWQgZm9yIE9BdXRoMiBjcmVkZW50aWFsc1xuICogc291cmNlZCB1c2luZyBleHRlcm5hbCBpZGVudGl0aWVzIHRocm91Z2ggV29ya2ZvcmNlIElkZW50aXR5IEZlZGVyYXRpb24uXG4gKiBPYnRhaW5pbmcgdGhlIGluaXRpYWwgYWNjZXNzIGFuZCByZWZyZXNoIHRva2VuIGNhbiBiZSBkb25lIHRocm91Z2ggdGhlXG4gKiBHb29nbGUgQ2xvdWQgQ0xJLlxuICovXG5jbGFzcyBFeHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudCBleHRlbmRzIGF1dGhjbGllbnRfMS5BdXRoQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYW4gRXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnQgaW5zdGFuY2VzIHVzaW5nIHRoZVxuICAgICAqIHByb3ZpZGVkIEpTT04gb2JqZWN0IGxvYWRlZCBmcm9tIGEgY3JlZGVudGlhbHMgZmlsZXMuXG4gICAgICogQW4gZXJyb3IgaXMgdGhyb3dzIGlmIHRoZSBjcmVkZW50aWFsIGlzIG5vdCB2YWxpZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZXh0ZXJuYWwgYWNjb3VudCBhdXRob3JpemVkIHVzZXIgb3B0aW9uIG9iamVjdCB0eXBpY2FsbHlcbiAgICAgKiAgIGZyb20gdGhlIGV4dGVybmFsIGFjY291dG4gYXV0aG9yaXplZCB1c2VyIEpTT04gY3JlZGVudGlhbCBmaWxlLlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsT3B0aW9ucyBPcHRpb25hbCBhZGRpdGlvbmFsIGJlaGF2aW9yIGN1c3RvbWl6YXRpb25cbiAgICAgKiAgIG9wdGlvbnMuIFRoZXNlIGN1cnJlbnRseSBjdXN0b21pemUgZXhwaXJhdGlvbiB0aHJlc2hvbGQgdGltZSBhbmRcbiAgICAgKiAgIHdoZXRoZXIgdG8gcmV0cnkgb24gNDAxLzQwMyBBUEkgcmVxdWVzdCBlcnJvcnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoVG9rZW4gPSBvcHRpb25zLnJlZnJlc2hfdG9rZW47XG4gICAgICAgIGNvbnN0IGNsaWVudEF1dGggPSB7XG4gICAgICAgICAgICBjb25maWRlbnRpYWxDbGllbnRUeXBlOiAnYmFzaWMnLFxuICAgICAgICAgICAgY2xpZW50SWQ6IG9wdGlvbnMuY2xpZW50X2lkLFxuICAgICAgICAgICAgY2xpZW50U2VjcmV0OiBvcHRpb25zLmNsaWVudF9zZWNyZXQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJIYW5kbGVyID1cbiAgICAgICAgICAgIG5ldyBFeHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckhhbmRsZXIob3B0aW9ucy50b2tlbl91cmwsIHRoaXMudHJhbnNwb3J0ZXIsIGNsaWVudEF1dGgpO1xuICAgICAgICB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuID0gbnVsbDtcbiAgICAgICAgdGhpcy5xdW90YVByb2plY3RJZCA9IG9wdGlvbnMucXVvdGFfcHJvamVjdF9pZDtcbiAgICAgICAgLy8gQXMgdGhyZXNob2xkIGNvdWxkIGJlIHplcm8sXG4gICAgICAgIC8vIGVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyB8fCBFWFBJUkFUSU9OX1RJTUVfT0ZGU0VUIHdpbGwgb3ZlcnJpZGUgdGhlXG4gICAgICAgIC8vIHplcm8gdmFsdWUuXG4gICAgICAgIGlmICh0eXBlb2YgKGFkZGl0aW9uYWxPcHRpb25zID09PSBudWxsIHx8IGFkZGl0aW9uYWxPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZGRpdGlvbmFsT3B0aW9ucy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMpICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgPSBiYXNlZXh0ZXJuYWxjbGllbnRfMS5FWFBJUkFUSU9OX1RJTUVfT0ZGU0VUO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgPSBhZGRpdGlvbmFsT3B0aW9uc1xuICAgICAgICAgICAgICAgIC5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUgPSAhIShhZGRpdGlvbmFsT3B0aW9ucyA9PT0gbnVsbCB8fCBhZGRpdGlvbmFsT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWRkaXRpb25hbE9wdGlvbnMuZm9yY2VSZWZyZXNoT25GYWlsdXJlKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIC8vIElmIGNhY2hlZCBhY2Nlc3MgdG9rZW4gaXMgdW5hdmFpbGFibGUgb3IgZXhwaXJlZCwgZm9yY2UgcmVmcmVzaC5cbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuIHx8IHRoaXMuaXNFeHBpcmVkKHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4pKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIEdDUCBhY2Nlc3MgdG9rZW4gaW4gR2V0QWNjZXNzVG9rZW5SZXNwb25zZSBmb3JtYXQuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlbjogdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICByZXM6IHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4ucmVzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBnZXRSZXF1ZXN0SGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5SZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0QWNjZXNzVG9rZW4oKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthY2Nlc3NUb2tlblJlc3BvbnNlLnRva2VufWAsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyhoZWFkZXJzKTtcbiAgICB9XG4gICAgcmVxdWVzdChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFzeW5jKG9wdHMpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByKSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUsIGUucmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QXN5bmMob3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXV0aGVudGljYXRlcyB0aGUgcHJvdmlkZWQgSFRUUCByZXF1ZXN0LCBwcm9jZXNzZXMgaXQgYW5kIHJlc29sdmVzIHdpdGggdGhlXG4gICAgICogcmV0dXJuZWQgcmVzcG9uc2UuXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIEhUVFAgcmVxdWVzdCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSByZXRyeSBXaGV0aGVyIHRoZSBjdXJyZW50IGF0dGVtcHQgaXMgYSByZXRyeSBhZnRlciBhIGZhaWxlZCBhdHRlbXB0LlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAgICAgKi9cbiAgICBhc3luYyByZXF1ZXN0QXN5bmMob3B0cywgcmV0cnkgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdEhlYWRlcnMoKTtcbiAgICAgICAgICAgIG9wdHMuaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0SGVhZGVycyAmJiByZXF1ZXN0SGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J10gPVxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RIZWFkZXJzICYmIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24pIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gZS5yZXNwb25zZTtcbiAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgICAgICAvLyBSZXRyeSB0aGUgcmVxdWVzdCBmb3IgbWV0YWRhdGEgaWYgdGhlIGZvbGxvd2luZyBjcml0ZXJpYSBhcmUgdHJ1ZTpcbiAgICAgICAgICAgICAgICAvLyAtIFdlIGhhdmVuJ3QgYWxyZWFkeSByZXRyaWVkLiAgSXQgb25seSBtYWtlcyBzZW5zZSB0byByZXRyeSBvbmNlLlxuICAgICAgICAgICAgICAgIC8vIC0gVGhlIHJlc3BvbnNlIHdhcyBhIDQwMSBvciBhIDQwM1xuICAgICAgICAgICAgICAgIC8vIC0gVGhlIHJlcXVlc3QgZGlkbid0IHNlbmQgYSByZWFkYWJsZVN0cmVhbVxuICAgICAgICAgICAgICAgIC8vIC0gZm9yY2VSZWZyZXNoT25GYWlsdXJlIGlzIHRydWVcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlYWRhYmxlU3RyZWFtID0gcmVzLmNvbmZpZy5kYXRhIGluc3RhbmNlb2Ygc3RyZWFtLlJlYWRhYmxlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXV0aEVyciA9IHN0YXR1c0NvZGUgPT09IDQwMSB8fCBzdGF0dXNDb2RlID09PSA0MDM7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXRyeSAmJlxuICAgICAgICAgICAgICAgICAgICBpc0F1dGhFcnIgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzUmVhZGFibGVTdHJlYW0gJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXF1ZXN0QXN5bmMob3B0cywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcmNlcyB0b2tlbiByZWZyZXNoLCBldmVuIGlmIHVuZXhwaXJlZCB0b2tlbnMgYXJlIGN1cnJlbnRseSBjYWNoZWQuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZWZyZXNoZWQgY3JlZGVudGlhbC5cbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpIHtcbiAgICAgICAgLy8gUmVmcmVzaCB0aGUgYWNjZXNzIHRva2VuIHVzaW5nIHRoZSByZWZyZXNoIHRva2VuLlxuICAgICAgICBjb25zdCByZWZyZXNoUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VySGFuZGxlci5yZWZyZXNoVG9rZW4odGhpcy5yZWZyZXNoVG9rZW4pO1xuICAgICAgICB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuID0ge1xuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiByZWZyZXNoUmVzcG9uc2UuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgZXhwaXJ5X2RhdGU6IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgcmVmcmVzaFJlc3BvbnNlLmV4cGlyZXNfaW4gKiAxMDAwLFxuICAgICAgICAgICAgcmVzOiByZWZyZXNoUmVzcG9uc2UucmVzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVmcmVzaFJlc3BvbnNlLnJlZnJlc2hfdG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoVG9rZW4gPSByZWZyZXNoUmVzcG9uc2UucmVmcmVzaF90b2tlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBjcmVkZW50aWFscyBhcmUgZXhwaXJlZCBvciBub3QuXG4gICAgICogSWYgdGhlcmUgaXMgbm8gZXhwaXJ5IHRpbWUsIGFzc3VtZXMgdGhlIHRva2VuIGlzIG5vdCBleHBpcmVkIG9yIGV4cGlyaW5nLlxuICAgICAqIEBwYXJhbSBjcmVkZW50aWFscyBUaGUgY3JlZGVudGlhbHMgdG8gY2hlY2sgZm9yIGV4cGlyYXRpb24uXG4gICAgICogQHJldHVybiBXaGV0aGVyIHRoZSBjcmVkZW50aWFscyBhcmUgZXhwaXJlZCBvciBub3QuXG4gICAgICovXG4gICAgaXNFeHBpcmVkKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICByZXR1cm4gY3JlZGVudGlhbHMuZXhwaXJ5X2RhdGVcbiAgICAgICAgICAgID8gbm93ID49IGNyZWRlbnRpYWxzLmV4cGlyeV9kYXRlIC0gdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXNcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5FeHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudCA9IEV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VyQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnQiLCJFWFRFUk5BTF9BQ0NPVU5UX0FVVEhPUklaRURfVVNFUl9UWVBFIiwiYXV0aGNsaWVudF8xIiwicmVxdWlyZSIsIm9hdXRoMmNvbW1vbl8xIiwiZ2F4aW9zXzEiLCJzdHJlYW0iLCJiYXNlZXh0ZXJuYWxjbGllbnRfMSIsIkV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VySGFuZGxlciIsIk9BdXRoQ2xpZW50QXV0aEhhbmRsZXIiLCJjb25zdHJ1Y3RvciIsInVybCIsInRyYW5zcG9ydGVyIiwiY2xpZW50QXV0aGVudGljYXRpb24iLCJyZWZyZXNoVG9rZW4iLCJhZGRpdGlvbmFsSGVhZGVycyIsInZhbHVlcyIsIlVSTFNlYXJjaFBhcmFtcyIsImdyYW50X3R5cGUiLCJyZWZyZXNoX3Rva2VuIiwiaGVhZGVycyIsIm9wdHMiLCJtZXRob2QiLCJkYXRhIiwidG9TdHJpbmciLCJyZXNwb25zZVR5cGUiLCJhcHBseUNsaWVudEF1dGhlbnRpY2F0aW9uT3B0aW9ucyIsInJlc3BvbnNlIiwicmVxdWVzdCIsInRva2VuUmVmcmVzaFJlc3BvbnNlIiwicmVzIiwiZXJyb3IiLCJHYXhpb3NFcnJvciIsImdldEVycm9yRnJvbU9BdXRoRXJyb3JSZXNwb25zZSIsIkF1dGhDbGllbnQiLCJvcHRpb25zIiwiYWRkaXRpb25hbE9wdGlvbnMiLCJjbGllbnRBdXRoIiwiY29uZmlkZW50aWFsQ2xpZW50VHlwZSIsImNsaWVudElkIiwiY2xpZW50X2lkIiwiY2xpZW50U2VjcmV0IiwiY2xpZW50X3NlY3JldCIsImV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VySGFuZGxlciIsInRva2VuX3VybCIsImNhY2hlZEFjY2Vzc1Rva2VuIiwicXVvdGFQcm9qZWN0SWQiLCJxdW90YV9wcm9qZWN0X2lkIiwiZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzIiwiRVhQSVJBVElPTl9USU1FX09GRlNFVCIsImZvcmNlUmVmcmVzaE9uRmFpbHVyZSIsImdldEFjY2Vzc1Rva2VuIiwiaXNFeHBpcmVkIiwicmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMiLCJ0b2tlbiIsImFjY2Vzc190b2tlbiIsImdldFJlcXVlc3RIZWFkZXJzIiwiYWNjZXNzVG9rZW5SZXNwb25zZSIsIkF1dGhvcml6YXRpb24iLCJhZGRTaGFyZWRNZXRhZGF0YUhlYWRlcnMiLCJjYWxsYmFjayIsInJlcXVlc3RBc3luYyIsInRoZW4iLCJyIiwiZSIsInJldHJ5IiwicmVxdWVzdEhlYWRlcnMiLCJzdGF0dXNDb2RlIiwic3RhdHVzIiwiaXNSZWFkYWJsZVN0cmVhbSIsImNvbmZpZyIsIlJlYWRhYmxlIiwiaXNBdXRoRXJyIiwicmVmcmVzaFJlc3BvbnNlIiwiZXhwaXJ5X2RhdGUiLCJEYXRlIiwiZ2V0VGltZSIsImV4cGlyZXNfaW4iLCJ1bmRlZmluZWQiLCJjcmVkZW50aWFscyIsIm5vdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/externalclient.js":
/*!***************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/externalclient.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ExternalAccountClient = void 0;\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nconst identitypoolclient_1 = __webpack_require__(/*! ./identitypoolclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/identitypoolclient.js\");\nconst awsclient_1 = __webpack_require__(/*! ./awsclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/awsclient.js\");\nconst pluggable_auth_client_1 = __webpack_require__(/*! ./pluggable-auth-client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js\");\n/**\n * Dummy class with no constructor. Developers are expected to use fromJSON.\n */ class ExternalAccountClient {\n    constructor(){\n        throw new Error(\"ExternalAccountClients should be initialized via: \" + \"ExternalAccountClient.fromJSON(), \" + \"directly via explicit constructors, eg. \" + \"new AwsClient(options), new IdentityPoolClient(options), new\" + \"PluggableAuthClientOptions, or via \" + \"new GoogleAuth(options).getClient()\");\n    }\n    /**\n     * This static method will instantiate the\n     * corresponding type of external account credential depending on the\n     * underlying credential source.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     * @return A BaseExternalAccountClient instance or null if the options\n     *   provided do not correspond to an external account credential.\n     */ static fromJSON(options, additionalOptions) {\n        var _a, _b;\n        if (options && options.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n            if ((_a = options.credential_source) === null || _a === void 0 ? void 0 : _a.environment_id) {\n                return new awsclient_1.AwsClient(options, additionalOptions);\n            } else if ((_b = options.credential_source) === null || _b === void 0 ? void 0 : _b.executable) {\n                return new pluggable_auth_client_1.PluggableAuthClient(options, additionalOptions);\n            } else {\n                return new identitypoolclient_1.IdentityPoolClient(options, additionalOptions);\n            }\n        } else {\n            return null;\n        }\n    }\n}\nexports.ExternalAccountClient = ExternalAccountClient; //# sourceMappingURL=externalclient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9leHRlcm5hbGNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHLEtBQUs7QUFDckMsTUFBTUcsdUJBQXVCQyxtQkFBT0EsQ0FBQywyR0FBc0I7QUFDM0QsTUFBTUMsdUJBQXVCRCxtQkFBT0EsQ0FBQywyR0FBc0I7QUFDM0QsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMseUZBQWE7QUFDekMsTUFBTUcsMEJBQTBCSCxtQkFBT0EsQ0FBQyxpSEFBeUI7QUFDakU7O0NBRUMsR0FDRCxNQUFNRjtJQUNGTSxhQUFjO1FBQ1YsTUFBTSxJQUFJQyxNQUFNLHVEQUNaLHVDQUNBLDZDQUNBLGlFQUNBLHdDQUNBO0lBQ1I7SUFDQTs7Ozs7Ozs7Ozs7S0FXQyxHQUNELE9BQU9DLFNBQVNDLE9BQU8sRUFBRUMsaUJBQWlCLEVBQUU7UUFDeEMsSUFBSUMsSUFBSUM7UUFDUixJQUFJSCxXQUFXQSxRQUFRSSxJQUFJLEtBQUtaLHFCQUFxQmEscUJBQXFCLEVBQUU7WUFDeEUsSUFBSSxDQUFDSCxLQUFLRixRQUFRTSxpQkFBaUIsTUFBTSxRQUFRSixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdLLGNBQWMsRUFBRTtnQkFDekYsT0FBTyxJQUFJWixZQUFZYSxTQUFTLENBQUNSLFNBQVNDO1lBQzlDLE9BQ0ssSUFBSSxDQUFDRSxLQUFLSCxRQUFRTSxpQkFBaUIsTUFBTSxRQUFRSCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdNLFVBQVUsRUFBRTtnQkFDMUYsT0FBTyxJQUFJYix3QkFBd0JjLG1CQUFtQixDQUFDVixTQUFTQztZQUNwRSxPQUNLO2dCQUNELE9BQU8sSUFBSVAscUJBQXFCaUIsa0JBQWtCLENBQUNYLFNBQVNDO1lBQ2hFO1FBQ0osT0FDSztZQUNELE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQVosNkJBQTZCLEdBQUdFLHVCQUNoQywwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9leHRlcm5hbGNsaWVudC5qcz85YzllIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV4dGVybmFsQWNjb3VudENsaWVudCA9IHZvaWQgMDtcbmNvbnN0IGJhc2VleHRlcm5hbGNsaWVudF8xID0gcmVxdWlyZShcIi4vYmFzZWV4dGVybmFsY2xpZW50XCIpO1xuY29uc3QgaWRlbnRpdHlwb29sY2xpZW50XzEgPSByZXF1aXJlKFwiLi9pZGVudGl0eXBvb2xjbGllbnRcIik7XG5jb25zdCBhd3NjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F3c2NsaWVudFwiKTtcbmNvbnN0IHBsdWdnYWJsZV9hdXRoX2NsaWVudF8xID0gcmVxdWlyZShcIi4vcGx1Z2dhYmxlLWF1dGgtY2xpZW50XCIpO1xuLyoqXG4gKiBEdW1teSBjbGFzcyB3aXRoIG5vIGNvbnN0cnVjdG9yLiBEZXZlbG9wZXJzIGFyZSBleHBlY3RlZCB0byB1c2UgZnJvbUpTT04uXG4gKi9cbmNsYXNzIEV4dGVybmFsQWNjb3VudENsaWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXh0ZXJuYWxBY2NvdW50Q2xpZW50cyBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgdmlhOiAnICtcbiAgICAgICAgICAgICdFeHRlcm5hbEFjY291bnRDbGllbnQuZnJvbUpTT04oKSwgJyArXG4gICAgICAgICAgICAnZGlyZWN0bHkgdmlhIGV4cGxpY2l0IGNvbnN0cnVjdG9ycywgZWcuICcgK1xuICAgICAgICAgICAgJ25ldyBBd3NDbGllbnQob3B0aW9ucyksIG5ldyBJZGVudGl0eVBvb2xDbGllbnQob3B0aW9ucyksIG5ldycgK1xuICAgICAgICAgICAgJ1BsdWdnYWJsZUF1dGhDbGllbnRPcHRpb25zLCBvciB2aWEgJyArXG4gICAgICAgICAgICAnbmV3IEdvb2dsZUF1dGgob3B0aW9ucykuZ2V0Q2xpZW50KCknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBzdGF0aWMgbWV0aG9kIHdpbGwgaW5zdGFudGlhdGUgdGhlXG4gICAgICogY29ycmVzcG9uZGluZyB0eXBlIG9mIGV4dGVybmFsIGFjY291bnQgY3JlZGVudGlhbCBkZXBlbmRpbmcgb24gdGhlXG4gICAgICogdW5kZXJseWluZyBjcmVkZW50aWFsIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZXh0ZXJuYWwgYWNjb3VudCBvcHRpb25zIG9iamVjdCB0eXBpY2FsbHkgbG9hZGVkXG4gICAgICogICBmcm9tIHRoZSBleHRlcm5hbCBhY2NvdW50IEpTT04gY3JlZGVudGlhbCBmaWxlLlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsT3B0aW9ucyBPcHRpb25hbCBhZGRpdGlvbmFsIGJlaGF2aW9yIGN1c3RvbWl6YXRpb25cbiAgICAgKiAgIG9wdGlvbnMuIFRoZXNlIGN1cnJlbnRseSBjdXN0b21pemUgZXhwaXJhdGlvbiB0aHJlc2hvbGQgdGltZSBhbmRcbiAgICAgKiAgIHdoZXRoZXIgdG8gcmV0cnkgb24gNDAxLzQwMyBBUEkgcmVxdWVzdCBlcnJvcnMuXG4gICAgICogQHJldHVybiBBIEJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQgaW5zdGFuY2Ugb3IgbnVsbCBpZiB0aGUgb3B0aW9uc1xuICAgICAqICAgcHJvdmlkZWQgZG8gbm90IGNvcnJlc3BvbmQgdG8gYW4gZXh0ZXJuYWwgYWNjb3VudCBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihvcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgPT09IGJhc2VleHRlcm5hbGNsaWVudF8xLkVYVEVSTkFMX0FDQ09VTlRfVFlQRSkge1xuICAgICAgICAgICAgaWYgKChfYSA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbnZpcm9ubWVudF9pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXdzY2xpZW50XzEuQXdzQ2xpZW50KG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChfYiA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5leGVjdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBwbHVnZ2FibGVfYXV0aF9jbGllbnRfMS5QbHVnZ2FibGVBdXRoQ2xpZW50KG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaWRlbnRpdHlwb29sY2xpZW50XzEuSWRlbnRpdHlQb29sQ2xpZW50KG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5FeHRlcm5hbEFjY291bnRDbGllbnQgPSBFeHRlcm5hbEFjY291bnRDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRlcm5hbGNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJFeHRlcm5hbEFjY291bnRDbGllbnQiLCJiYXNlZXh0ZXJuYWxjbGllbnRfMSIsInJlcXVpcmUiLCJpZGVudGl0eXBvb2xjbGllbnRfMSIsImF3c2NsaWVudF8xIiwicGx1Z2dhYmxlX2F1dGhfY2xpZW50XzEiLCJjb25zdHJ1Y3RvciIsIkVycm9yIiwiZnJvbUpTT04iLCJvcHRpb25zIiwiYWRkaXRpb25hbE9wdGlvbnMiLCJfYSIsIl9iIiwidHlwZSIsIkVYVEVSTkFMX0FDQ09VTlRfVFlQRSIsImNyZWRlbnRpYWxfc291cmNlIiwiZW52aXJvbm1lbnRfaWQiLCJBd3NDbGllbnQiLCJleGVjdXRhYmxlIiwiUGx1Z2dhYmxlQXV0aENsaWVudCIsIklkZW50aXR5UG9vbENsaWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/externalclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/googleauth.js":
/*!***********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/googleauth.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.GoogleAuth = exports.CLOUD_SDK_CLIENT_ID = void 0;\nconst child_process_1 = __webpack_require__(/*! child_process */ \"child_process\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst gcpMetadata = __webpack_require__(/*! gcp-metadata */ \"(rsc)/./node_modules/gcp-metadata/build/src/index.js\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst crypto_1 = __webpack_require__(/*! ../crypto/crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js\");\nconst transporters_1 = __webpack_require__(/*! ../transporters */ \"(rsc)/./node_modules/google-auth-library/build/src/transporters.js\");\nconst computeclient_1 = __webpack_require__(/*! ./computeclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/computeclient.js\");\nconst idtokenclient_1 = __webpack_require__(/*! ./idtokenclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/idtokenclient.js\");\nconst envDetect_1 = __webpack_require__(/*! ./envDetect */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/envDetect.js\");\nconst jwtclient_1 = __webpack_require__(/*! ./jwtclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/jwtclient.js\");\nconst refreshclient_1 = __webpack_require__(/*! ./refreshclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/refreshclient.js\");\nconst impersonated_1 = __webpack_require__(/*! ./impersonated */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/impersonated.js\");\nconst externalclient_1 = __webpack_require__(/*! ./externalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/externalclient.js\");\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nconst externalAccountAuthorizedUserClient_1 = __webpack_require__(/*! ./externalAccountAuthorizedUserClient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js\");\nexports.CLOUD_SDK_CLIENT_ID = \"764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com\";\nconst GoogleAuthExceptionMessages = {\n    NO_PROJECT_ID_FOUND: \"Unable to detect a Project Id in the current environment. \\n\" + \"To learn more about authentication and Google APIs, visit: \\n\" + \"https://cloud.google.com/docs/authentication/getting-started\"\n};\nclass GoogleAuth {\n    // Note:  this properly is only public to satisify unit tests.\n    // https://github.com/Microsoft/TypeScript/issues/5228\n    get isGCE() {\n        return this.checkIsGCE;\n    }\n    constructor(opts){\n        /**\n         * Caches a value indicating whether the auth layer is running on Google\n         * Compute Engine.\n         * @private\n         */ this.checkIsGCE = undefined;\n        // To save the contents of the JSON credential file\n        this.jsonContent = null;\n        this.cachedCredential = null;\n        opts = opts || {};\n        this._cachedProjectId = opts.projectId || null;\n        this.cachedCredential = opts.authClient || null;\n        this.keyFilename = opts.keyFilename || opts.keyFile;\n        this.scopes = opts.scopes;\n        this.jsonContent = opts.credentials || null;\n        this.clientOptions = opts.clientOptions;\n    }\n    // GAPIC client libraries should always use self-signed JWTs. The following\n    // variables are set on the JWT client in order to indicate the type of library,\n    // and sign the JWT with the correct audience and scopes (if not supplied).\n    setGapicJWTValues(client) {\n        client.defaultServicePath = this.defaultServicePath;\n        client.useJWTAccessWithScope = this.useJWTAccessWithScope;\n        client.defaultScopes = this.defaultScopes;\n    }\n    getProjectId(callback) {\n        if (callback) {\n            this.getProjectIdAsync().then((r)=>callback(null, r), callback);\n        } else {\n            return this.getProjectIdAsync();\n        }\n    }\n    /**\n     * A temporary method for internal `getProjectId` usages where `null` is\n     * acceptable. In a future major release, `getProjectId` should return `null`\n     * (as the `Promise<string | null>` base signature describes) and this private\n     * method should be removed.\n     *\n     * @returns Promise that resolves with project id (or `null`)\n     */ async getProjectIdOptional() {\n        try {\n            return await this.getProjectId();\n        } catch (e) {\n            if (e instanceof Error && e.message === GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND) {\n                return null;\n            } else {\n                throw e;\n            }\n        }\n    }\n    /*\n     * A private method for finding and caching a projectId.\n     *\n     * Supports environments in order of precedence:\n     * - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n     * - GOOGLE_APPLICATION_CREDENTIALS JSON file\n     * - Cloud SDK: `gcloud config config-helper --format json`\n     * - GCE project ID from metadata server\n     *\n     * @returns projectId\n     */ async findAndCacheProjectId() {\n        let projectId = null;\n        projectId || (projectId = await this.getProductionProjectId());\n        projectId || (projectId = await this.getFileProjectId());\n        projectId || (projectId = await this.getDefaultServiceProjectId());\n        projectId || (projectId = await this.getGCEProjectId());\n        projectId || (projectId = await this.getExternalAccountClientProjectId());\n        if (projectId) {\n            this._cachedProjectId = projectId;\n            return projectId;\n        } else {\n            throw new Error(GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);\n        }\n    }\n    async getProjectIdAsync() {\n        if (this._cachedProjectId) {\n            return this._cachedProjectId;\n        }\n        if (!this._findProjectIdPromise) {\n            this._findProjectIdPromise = this.findAndCacheProjectId();\n        }\n        return this._findProjectIdPromise;\n    }\n    /**\n     * @returns Any scopes (user-specified or default scopes specified by the\n     *   client library) that need to be set on the current Auth client.\n     */ getAnyScopes() {\n        return this.scopes || this.defaultScopes;\n    }\n    getApplicationDefault(optionsOrCallback = {}, callback) {\n        let options;\n        if (typeof optionsOrCallback === \"function\") {\n            callback = optionsOrCallback;\n        } else {\n            options = optionsOrCallback;\n        }\n        if (callback) {\n            this.getApplicationDefaultAsync(options).then((r)=>callback(null, r.credential, r.projectId), callback);\n        } else {\n            return this.getApplicationDefaultAsync(options);\n        }\n    }\n    async getApplicationDefaultAsync(options = {}) {\n        // If we've already got a cached credential, return it.\n        // This will also preserve one's configured quota project, in case they\n        // set one directly on the credential previously.\n        if (this.cachedCredential) {\n            return await this.prepareAndCacheADC(this.cachedCredential);\n        }\n        // Since this is a 'new' ADC to cache we will use the environment variable\n        // if it's available. We prefer this value over the value from ADC.\n        const quotaProjectIdOverride = process.env[\"GOOGLE_CLOUD_QUOTA_PROJECT\"];\n        let credential;\n        // Check for the existence of a local environment variable pointing to the\n        // location of the credential file. This is typically used in local\n        // developer scenarios.\n        credential = await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);\n        if (credential) {\n            if (credential instanceof jwtclient_1.JWT) {\n                credential.scopes = this.scopes;\n            } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n                credential.scopes = this.getAnyScopes();\n            }\n            return await this.prepareAndCacheADC(credential, quotaProjectIdOverride);\n        }\n        // Look in the well-known credential file location.\n        credential = await this._tryGetApplicationCredentialsFromWellKnownFile(options);\n        if (credential) {\n            if (credential instanceof jwtclient_1.JWT) {\n                credential.scopes = this.scopes;\n            } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n                credential.scopes = this.getAnyScopes();\n            }\n            return await this.prepareAndCacheADC(credential, quotaProjectIdOverride);\n        }\n        // Determine if we're running on GCE.\n        let isGCE;\n        try {\n            isGCE = await this._checkIsGCE();\n        } catch (e) {\n            if (e instanceof Error) {\n                e.message = `Unexpected error determining execution environment: ${e.message}`;\n            }\n            throw e;\n        }\n        if (!isGCE) {\n            // We failed to find the default credentials. Bail out with an error.\n            throw new Error(\"Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.\");\n        }\n        // For GCE, just return a default ComputeClient. It will take care of\n        // the rest.\n        options.scopes = this.getAnyScopes();\n        return await this.prepareAndCacheADC(new computeclient_1.Compute(options), quotaProjectIdOverride);\n    }\n    async prepareAndCacheADC(credential, quotaProjectIdOverride) {\n        const projectId = await this.getProjectIdOptional();\n        if (quotaProjectIdOverride) {\n            credential.quotaProjectId = quotaProjectIdOverride;\n        }\n        this.cachedCredential = credential;\n        return {\n            credential,\n            projectId\n        };\n    }\n    /**\n     * Determines whether the auth layer is running on Google Compute Engine.\n     * Checks for GCP Residency, then fallback to checking if metadata server\n     * is available.\n     *\n     * @returns A promise that resolves with the boolean.\n     * @api private\n     */ async _checkIsGCE() {\n        if (this.checkIsGCE === undefined) {\n            this.checkIsGCE = gcpMetadata.getGCPResidency() || await gcpMetadata.isAvailable();\n        }\n        return this.checkIsGCE;\n    }\n    /**\n     * Attempts to load default credentials from the environment variable path..\n     * @returns Promise that resolves with the OAuth2Client or null.\n     * @api private\n     */ async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {\n        const credentialsPath = process.env[\"GOOGLE_APPLICATION_CREDENTIALS\"] || process.env[\"google_application_credentials\"];\n        if (!credentialsPath || credentialsPath.length === 0) {\n            return null;\n        }\n        try {\n            return this._getApplicationCredentialsFromFilePath(credentialsPath, options);\n        } catch (e) {\n            if (e instanceof Error) {\n                e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e.message}`;\n            }\n            throw e;\n        }\n    }\n    /**\n     * Attempts to load default credentials from a well-known file location\n     * @return Promise that resolves with the OAuth2Client or null.\n     * @api private\n     */ async _tryGetApplicationCredentialsFromWellKnownFile(options) {\n        // First, figure out the location of the file, depending upon the OS type.\n        let location = null;\n        if (this._isWindows()) {\n            // Windows\n            location = process.env[\"APPDATA\"];\n        } else {\n            // Linux or Mac\n            const home = process.env[\"HOME\"];\n            if (home) {\n                location = path.join(home, \".config\");\n            }\n        }\n        // If we found the root path, expand it.\n        if (location) {\n            location = path.join(location, \"gcloud\", \"application_default_credentials.json\");\n            if (!fs.existsSync(location)) {\n                location = null;\n            }\n        }\n        // The file does not exist.\n        if (!location) {\n            return null;\n        }\n        // The file seems to exist. Try to use it.\n        const client = await this._getApplicationCredentialsFromFilePath(location, options);\n        return client;\n    }\n    /**\n     * Attempts to load default credentials from a file at the given path..\n     * @param filePath The path to the file to read.\n     * @returns Promise that resolves with the OAuth2Client\n     * @api private\n     */ async _getApplicationCredentialsFromFilePath(filePath, options = {}) {\n        // Make sure the path looks like a string.\n        if (!filePath || filePath.length === 0) {\n            throw new Error(\"The file path is invalid.\");\n        }\n        // Make sure there is a file at the path. lstatSync will throw if there is\n        // nothing there.\n        try {\n            // Resolve path to actual file in case of symlink. Expect a thrown error\n            // if not resolvable.\n            filePath = fs.realpathSync(filePath);\n            if (!fs.lstatSync(filePath).isFile()) {\n                throw new Error();\n            }\n        } catch (err) {\n            if (err instanceof Error) {\n                err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n            }\n            throw err;\n        }\n        // Now open a read stream on the file, and parse it.\n        const readStream = fs.createReadStream(filePath);\n        return this.fromStream(readStream, options);\n    }\n    /**\n     * Create a credentials instance using a given impersonated input options.\n     * @param json The impersonated input object.\n     * @returns JWT or UserRefresh Client with data\n     */ fromImpersonatedJSON(json) {\n        var _a, _b, _c, _d;\n        if (!json) {\n            throw new Error(\"Must pass in a JSON object containing an  impersonated refresh token\");\n        }\n        if (json.type !== impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\n            throw new Error(`The incoming JSON object does not have the \"${impersonated_1.IMPERSONATED_ACCOUNT_TYPE}\" type`);\n        }\n        if (!json.source_credentials) {\n            throw new Error(\"The incoming JSON object does not contain a source_credentials field\");\n        }\n        if (!json.service_account_impersonation_url) {\n            throw new Error(\"The incoming JSON object does not contain a service_account_impersonation_url field\");\n        }\n        // Create source client for impersonation\n        const sourceClient = new refreshclient_1.UserRefreshClient(json.source_credentials.client_id, json.source_credentials.client_secret, json.source_credentials.refresh_token);\n        // Extreact service account from service_account_impersonation_url\n        const targetPrincipal = (_b = (_a = /(?<target>[^/]+):generateAccessToken$/.exec(json.service_account_impersonation_url)) === null || _a === void 0 ? void 0 : _a.groups) === null || _b === void 0 ? void 0 : _b.target;\n        if (!targetPrincipal) {\n            throw new RangeError(`Cannot extract target principal from ${json.service_account_impersonation_url}`);\n        }\n        const targetScopes = (_c = this.getAnyScopes()) !== null && _c !== void 0 ? _c : [];\n        const client = new impersonated_1.Impersonated({\n            delegates: (_d = json.delegates) !== null && _d !== void 0 ? _d : [],\n            sourceClient: sourceClient,\n            targetPrincipal: targetPrincipal,\n            targetScopes: Array.isArray(targetScopes) ? targetScopes : [\n                targetScopes\n            ]\n        });\n        return client;\n    }\n    /**\n     * Create a credentials instance using the given input options.\n     * @param json The input object.\n     * @param options The JWT or UserRefresh options for the client\n     * @returns JWT or UserRefresh Client with data\n     */ fromJSON(json, options = {}) {\n        let client;\n        options = options || {};\n        if (json.type === refreshclient_1.USER_REFRESH_ACCOUNT_TYPE) {\n            client = new refreshclient_1.UserRefreshClient(options);\n            client.fromJSON(json);\n        } else if (json.type === impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\n            client = this.fromImpersonatedJSON(json);\n        } else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n            client = externalclient_1.ExternalAccountClient.fromJSON(json, options);\n            client.scopes = this.getAnyScopes();\n        } else if (json.type === externalAccountAuthorizedUserClient_1.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE) {\n            client = new externalAccountAuthorizedUserClient_1.ExternalAccountAuthorizedUserClient(json, options);\n        } else {\n            options.scopes = this.scopes;\n            client = new jwtclient_1.JWT(options);\n            this.setGapicJWTValues(client);\n            client.fromJSON(json);\n        }\n        return client;\n    }\n    /**\n     * Return a JWT or UserRefreshClient from JavaScript object, caching both the\n     * object used to instantiate and the client.\n     * @param json The input object.\n     * @param options The JWT or UserRefresh options for the client\n     * @returns JWT or UserRefresh Client with data\n     */ _cacheClientFromJSON(json, options) {\n        const client = this.fromJSON(json, options);\n        // cache both raw data used to instantiate client and client itself.\n        this.jsonContent = json;\n        this.cachedCredential = client;\n        return client;\n    }\n    fromStream(inputStream, optionsOrCallback = {}, callback) {\n        let options = {};\n        if (typeof optionsOrCallback === \"function\") {\n            callback = optionsOrCallback;\n        } else {\n            options = optionsOrCallback;\n        }\n        if (callback) {\n            this.fromStreamAsync(inputStream, options).then((r)=>callback(null, r), callback);\n        } else {\n            return this.fromStreamAsync(inputStream, options);\n        }\n    }\n    fromStreamAsync(inputStream, options) {\n        return new Promise((resolve, reject)=>{\n            if (!inputStream) {\n                throw new Error(\"Must pass in a stream containing the Google auth settings.\");\n            }\n            let s = \"\";\n            inputStream.setEncoding(\"utf8\").on(\"error\", reject).on(\"data\", (chunk)=>s += chunk).on(\"end\", ()=>{\n                try {\n                    try {\n                        const data = JSON.parse(s);\n                        const r = this._cacheClientFromJSON(data, options);\n                        return resolve(r);\n                    } catch (err) {\n                        // If we failed parsing this.keyFileName, assume that it\n                        // is a PEM or p12 certificate:\n                        if (!this.keyFilename) throw err;\n                        const client = new jwtclient_1.JWT({\n                            ...this.clientOptions,\n                            keyFile: this.keyFilename\n                        });\n                        this.cachedCredential = client;\n                        this.setGapicJWTValues(client);\n                        return resolve(client);\n                    }\n                } catch (err) {\n                    return reject(err);\n                }\n            });\n        });\n    }\n    /**\n     * Create a credentials instance using the given API key string.\n     * @param apiKey The API key string\n     * @param options An optional options object.\n     * @returns A JWT loaded from the key\n     */ fromAPIKey(apiKey, options) {\n        options = options || {};\n        const client = new jwtclient_1.JWT(options);\n        client.fromAPIKey(apiKey);\n        return client;\n    }\n    /**\n     * Determines whether the current operating system is Windows.\n     * @api private\n     */ _isWindows() {\n        const sys = os.platform();\n        if (sys && sys.length >= 3) {\n            if (sys.substring(0, 3).toLowerCase() === \"win\") {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Run the Google Cloud SDK command that prints the default project ID\n     */ async getDefaultServiceProjectId() {\n        return new Promise((resolve)=>{\n            (0, child_process_1.exec)(\"gcloud config config-helper --format json\", (err, stdout)=>{\n                if (!err && stdout) {\n                    try {\n                        const projectId = JSON.parse(stdout).configuration.properties.core.project;\n                        resolve(projectId);\n                        return;\n                    } catch (e) {\n                    // ignore errors\n                    }\n                }\n                resolve(null);\n            });\n        });\n    }\n    /**\n     * Loads the project id from environment variables.\n     * @api private\n     */ getProductionProjectId() {\n        return process.env[\"GCLOUD_PROJECT\"] || process.env[\"GOOGLE_CLOUD_PROJECT\"] || process.env[\"gcloud_project\"] || process.env[\"google_cloud_project\"];\n    }\n    /**\n     * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n     * @api private\n     */ async getFileProjectId() {\n        if (this.cachedCredential) {\n            // Try to read the project ID from the cached credentials file\n            return this.cachedCredential.projectId;\n        }\n        // Ensure the projectId is loaded from the keyFile if available.\n        if (this.keyFilename) {\n            const creds = await this.getClient();\n            if (creds && creds.projectId) {\n                return creds.projectId;\n            }\n        }\n        // Try to load a credentials file and read its project ID\n        const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\n        if (r) {\n            return r.projectId;\n        } else {\n            return null;\n        }\n    }\n    /**\n     * Gets the project ID from external account client if available.\n     */ async getExternalAccountClientProjectId() {\n        if (!this.jsonContent || this.jsonContent.type !== baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n            return null;\n        }\n        const creds = await this.getClient();\n        // Do not suppress the underlying error, as the error could contain helpful\n        // information for debugging and fixing. This is especially true for\n        // external account creds as in order to get the project ID, the following\n        // operations have to succeed:\n        // 1. Valid credentials file should be supplied.\n        // 2. Ability to retrieve access tokens from STS token exchange API.\n        // 3. Ability to exchange for service account impersonated credentials (if\n        //    enabled).\n        // 4. Ability to get project info using the access token from step 2 or 3.\n        // Without surfacing the error, it is harder for developers to determine\n        // which step went wrong.\n        return await creds.getProjectId();\n    }\n    /**\n     * Gets the Compute Engine project ID if it can be inferred.\n     */ async getGCEProjectId() {\n        try {\n            const r = await gcpMetadata.project(\"project-id\");\n            return r;\n        } catch (e) {\n            // Ignore any errors\n            return null;\n        }\n    }\n    getCredentials(callback) {\n        if (callback) {\n            this.getCredentialsAsync().then((r)=>callback(null, r), callback);\n        } else {\n            return this.getCredentialsAsync();\n        }\n    }\n    async getCredentialsAsync() {\n        const client = await this.getClient();\n        if (client instanceof baseexternalclient_1.BaseExternalAccountClient) {\n            const serviceAccountEmail = client.getServiceAccountEmail();\n            if (serviceAccountEmail) {\n                return {\n                    client_email: serviceAccountEmail\n                };\n            }\n        }\n        if (this.jsonContent) {\n            const credential = {\n                client_email: this.jsonContent.client_email,\n                private_key: this.jsonContent.private_key\n            };\n            return credential;\n        }\n        const isGCE = await this._checkIsGCE();\n        if (!isGCE) {\n            throw new Error(\"Unknown error.\");\n        }\n        // For GCE, return the service account details from the metadata server\n        // NOTE: The trailing '/' at the end of service-accounts/ is very important!\n        // The GCF metadata server doesn't respect querystring params if this / is\n        // not included.\n        const data = await gcpMetadata.instance({\n            property: \"service-accounts/\",\n            params: {\n                recursive: \"true\"\n            }\n        });\n        if (!data || !data.default || !data.default.email) {\n            throw new Error(\"Failure from metadata server.\");\n        }\n        return {\n            client_email: data.default.email\n        };\n    }\n    /**\n     * Automatically obtain a client based on the provided configuration.  If no\n     * options were passed, use Application Default Credentials.\n     */ async getClient() {\n        if (!this.cachedCredential) {\n            if (this.jsonContent) {\n                this._cacheClientFromJSON(this.jsonContent, this.clientOptions);\n            } else if (this.keyFilename) {\n                const filePath = path.resolve(this.keyFilename);\n                const stream = fs.createReadStream(filePath);\n                await this.fromStreamAsync(stream, this.clientOptions);\n            } else {\n                await this.getApplicationDefaultAsync(this.clientOptions);\n            }\n        }\n        return this.cachedCredential;\n    }\n    /**\n     * Creates a client which will fetch an ID token for authorization.\n     * @param targetAudience the audience for the fetched ID token.\n     * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.\n     */ async getIdTokenClient(targetAudience) {\n        const client = await this.getClient();\n        if (!(\"fetchIdToken\" in client)) {\n            throw new Error(\"Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.\");\n        }\n        return new idtokenclient_1.IdTokenClient({\n            targetAudience,\n            idTokenProvider: client\n        });\n    }\n    /**\n     * Automatically obtain application default credentials, and return\n     * an access token for making requests.\n     */ async getAccessToken() {\n        const client = await this.getClient();\n        return (await client.getAccessToken()).token;\n    }\n    /**\n     * Obtain the HTTP headers that will provide authorization for a given\n     * request.\n     */ async getRequestHeaders(url) {\n        const client = await this.getClient();\n        return client.getRequestHeaders(url);\n    }\n    /**\n     * Obtain credentials for a request, then attach the appropriate headers to\n     * the request options.\n     * @param opts Axios or Request options on which to attach the headers\n     */ async authorizeRequest(opts) {\n        opts = opts || {};\n        const url = opts.url || opts.uri;\n        const client = await this.getClient();\n        const headers = await client.getRequestHeaders(url);\n        opts.headers = Object.assign(opts.headers || {}, headers);\n        return opts;\n    }\n    /**\n     * Automatically obtain application default credentials, and make an\n     * HTTP request using the given options.\n     * @param opts Axios request options for the HTTP request.\n     */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async request(opts) {\n        const client = await this.getClient();\n        return client.request(opts);\n    }\n    /**\n     * Determine the compute environment in which the code is running.\n     */ getEnv() {\n        return (0, envDetect_1.getEnv)();\n    }\n    /**\n     * Sign the given data with the current private key, or go out\n     * to the IAM API to sign it.\n     * @param data The data to be signed.\n     */ async sign(data) {\n        const client = await this.getClient();\n        const crypto = (0, crypto_1.createCrypto)();\n        if (client instanceof jwtclient_1.JWT && client.key) {\n            const sign = await crypto.sign(client.key, data);\n            return sign;\n        }\n        const creds = await this.getCredentials();\n        if (!creds.client_email) {\n            throw new Error(\"Cannot sign data without `client_email`.\");\n        }\n        return this.signBlob(crypto, creds.client_email, data);\n    }\n    async signBlob(crypto, emailOrUniqueId, data) {\n        const url = \"https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/\" + `${emailOrUniqueId}:signBlob`;\n        const res = await this.request({\n            method: \"POST\",\n            url,\n            data: {\n                payload: crypto.encodeBase64StringUtf8(data)\n            }\n        });\n        return res.data.signedBlob;\n    }\n}\nexports.GoogleAuth = GoogleAuth;\n/**\n * Export DefaultTransporter as a static property of the class.\n */ GoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter; //# sourceMappingURL=googleauth.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9nb29nbGVhdXRoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0JBQWtCLEdBQUdBLDJCQUEyQixHQUFHLEtBQUs7QUFDeEQsTUFBTUksa0JBQWtCQyxtQkFBT0EsQ0FBQyxvQ0FBZTtBQUMvQyxNQUFNQyxLQUFLRCxtQkFBT0EsQ0FBQyxjQUFJO0FBQ3ZCLE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLDBFQUFjO0FBQzFDLE1BQU1HLEtBQUtILG1CQUFPQSxDQUFDLGNBQUk7QUFDdkIsTUFBTUksT0FBT0osbUJBQU9BLENBQUMsa0JBQU07QUFDM0IsTUFBTUssV0FBV0wsbUJBQU9BLENBQUMsNkZBQWtCO0FBQzNDLE1BQU1NLGlCQUFpQk4sbUJBQU9BLENBQUMsMkZBQWlCO0FBQ2hELE1BQU1PLGtCQUFrQlAsbUJBQU9BLENBQUMsaUdBQWlCO0FBQ2pELE1BQU1RLGtCQUFrQlIsbUJBQU9BLENBQUMsaUdBQWlCO0FBQ2pELE1BQU1TLGNBQWNULG1CQUFPQSxDQUFDLHlGQUFhO0FBQ3pDLE1BQU1VLGNBQWNWLG1CQUFPQSxDQUFDLHlGQUFhO0FBQ3pDLE1BQU1XLGtCQUFrQlgsbUJBQU9BLENBQUMsaUdBQWlCO0FBQ2pELE1BQU1ZLGlCQUFpQlosbUJBQU9BLENBQUMsK0ZBQWdCO0FBQy9DLE1BQU1hLG1CQUFtQmIsbUJBQU9BLENBQUMsbUdBQWtCO0FBQ25ELE1BQU1jLHVCQUF1QmQsbUJBQU9BLENBQUMs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QUMrRyxTQUFTO1FBQ25DLE1BQU02QixTQUFTLENBQUMsR0FBR3pLLFNBQVMwSyxZQUFZO1FBQ3hDLElBQUk3SSxrQkFBa0J4QixZQUFZdUQsR0FBRyxJQUFJL0IsT0FBTzhJLEdBQUcsRUFBRTtZQUNqRCxNQUFNSCxPQUFPLE1BQU1DLE9BQU9ELElBQUksQ0FBQzNJLE9BQU84SSxHQUFHLEVBQUU5QztZQUMzQyxPQUFPMkM7UUFDWDtRQUNBLE1BQU03QixRQUFRLE1BQU0sSUFBSSxDQUFDRSxjQUFjO1FBQ3ZDLElBQUksQ0FBQ0YsTUFBTU0sWUFBWSxFQUFFO1lBQ3JCLE1BQU0sSUFBSXpHLE1BQU07UUFDcEI7UUFDQSxPQUFPLElBQUksQ0FBQ29JLFFBQVEsQ0FBQ0gsUUFBUTlCLE1BQU1NLFlBQVksRUFBRXBCO0lBQ3JEO0lBQ0EsTUFBTStDLFNBQVNILE1BQU0sRUFBRUksZUFBZSxFQUFFaEQsSUFBSSxFQUFFO1FBQzFDLE1BQU1vQyxNQUFNLHlFQUNSLENBQUMsRUFBRVksZ0JBQWdCLFNBQVMsQ0FBQztRQUNqQyxNQUFNQyxNQUFNLE1BQU0sSUFBSSxDQUFDUixPQUFPLENBQUM7WUFDM0JTLFFBQVE7WUFDUmQ7WUFDQXBDLE1BQU07Z0JBQ0ZtRCxTQUFTUCxPQUFPUSxzQkFBc0IsQ0FBQ3BEO1lBQzNDO1FBQ0o7UUFDQSxPQUFPaUQsSUFBSWpELElBQUksQ0FBQ3FELFVBQVU7SUFDOUI7QUFDSjtBQUNBNUwsa0JBQWtCLEdBQUdFO0FBQ3JCOztDQUVDLEdBQ0RBLFdBQVcyTCxrQkFBa0IsR0FBR2xMLGVBQWVrTCxrQkFBa0IsRUFDakUsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZ29vZ2xlYXV0aC5qcz8xZjM5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdvb2dsZUF1dGggPSBleHBvcnRzLkNMT1VEX1NES19DTElFTlRfSUQgPSB2b2lkIDA7XG5jb25zdCBjaGlsZF9wcm9jZXNzXzEgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgZ2NwTWV0YWRhdGEgPSByZXF1aXJlKFwiZ2NwLW1ldGFkYXRhXCIpO1xuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vY3J5cHRvXCIpO1xuY29uc3QgdHJhbnNwb3J0ZXJzXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNwb3J0ZXJzXCIpO1xuY29uc3QgY29tcHV0ZWNsaWVudF8xID0gcmVxdWlyZShcIi4vY29tcHV0ZWNsaWVudFwiKTtcbmNvbnN0IGlkdG9rZW5jbGllbnRfMSA9IHJlcXVpcmUoXCIuL2lkdG9rZW5jbGllbnRcIik7XG5jb25zdCBlbnZEZXRlY3RfMSA9IHJlcXVpcmUoXCIuL2VudkRldGVjdFwiKTtcbmNvbnN0IGp3dGNsaWVudF8xID0gcmVxdWlyZShcIi4vand0Y2xpZW50XCIpO1xuY29uc3QgcmVmcmVzaGNsaWVudF8xID0gcmVxdWlyZShcIi4vcmVmcmVzaGNsaWVudFwiKTtcbmNvbnN0IGltcGVyc29uYXRlZF8xID0gcmVxdWlyZShcIi4vaW1wZXJzb25hdGVkXCIpO1xuY29uc3QgZXh0ZXJuYWxjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2V4dGVybmFsY2xpZW50XCIpO1xuY29uc3QgYmFzZWV4dGVybmFsY2xpZW50XzEgPSByZXF1aXJlKFwiLi9iYXNlZXh0ZXJuYWxjbGllbnRcIik7XG5jb25zdCBleHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudF8xID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnRcIik7XG5leHBvcnRzLkNMT1VEX1NES19DTElFTlRfSUQgPSAnNzY0MDg2MDUxODUwLTZxcjRwNmdwaTZobjUwNnB0OGVqdXE4M2RpMzQxaHVyLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tJztcbmNvbnN0IEdvb2dsZUF1dGhFeGNlcHRpb25NZXNzYWdlcyA9IHtcbiAgICBOT19QUk9KRUNUX0lEX0ZPVU5EOiAnVW5hYmxlIHRvIGRldGVjdCBhIFByb2plY3QgSWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIFxcbicgK1xuICAgICAgICAnVG8gbGVhcm4gbW9yZSBhYm91dCBhdXRoZW50aWNhdGlvbiBhbmQgR29vZ2xlIEFQSXMsIHZpc2l0OiBcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9kb2NzL2F1dGhlbnRpY2F0aW9uL2dldHRpbmctc3RhcnRlZCcsXG59O1xuY2xhc3MgR29vZ2xlQXV0aCB7XG4gICAgLy8gTm90ZTogIHRoaXMgcHJvcGVybHkgaXMgb25seSBwdWJsaWMgdG8gc2F0aXNpZnkgdW5pdCB0ZXN0cy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzUyMjhcbiAgICBnZXQgaXNHQ0UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrSXNHQ0U7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhY2hlcyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgYXV0aCBsYXllciBpcyBydW5uaW5nIG9uIEdvb2dsZVxuICAgICAgICAgKiBDb21wdXRlIEVuZ2luZS5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hlY2tJc0dDRSA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gVG8gc2F2ZSB0aGUgY29udGVudHMgb2YgdGhlIEpTT04gY3JlZGVudGlhbCBmaWxlXG4gICAgICAgIHRoaXMuanNvbkNvbnRlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmNhY2hlZENyZWRlbnRpYWwgPSBudWxsO1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgdGhpcy5fY2FjaGVkUHJvamVjdElkID0gb3B0cy5wcm9qZWN0SWQgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5jYWNoZWRDcmVkZW50aWFsID0gb3B0cy5hdXRoQ2xpZW50IHx8IG51bGw7XG4gICAgICAgIHRoaXMua2V5RmlsZW5hbWUgPSBvcHRzLmtleUZpbGVuYW1lIHx8IG9wdHMua2V5RmlsZTtcbiAgICAgICAgdGhpcy5zY29wZXMgPSBvcHRzLnNjb3BlcztcbiAgICAgICAgdGhpcy5qc29uQ29udGVudCA9IG9wdHMuY3JlZGVudGlhbHMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zID0gb3B0cy5jbGllbnRPcHRpb25zO1xuICAgIH1cbiAgICAvLyBHQVBJQyBjbGllbnQgbGlicmFyaWVzIHNob3VsZCBhbHdheXMgdXNlIHNlbGYtc2lnbmVkIEpXVHMuIFRoZSBmb2xsb3dpbmdcbiAgICAvLyB2YXJpYWJsZXMgYXJlIHNldCBvbiB0aGUgSldUIGNsaWVudCBpbiBvcmRlciB0byBpbmRpY2F0ZSB0aGUgdHlwZSBvZiBsaWJyYXJ5LFxuICAgIC8vIGFuZCBzaWduIHRoZSBKV1Qgd2l0aCB0aGUgY29ycmVjdCBhdWRpZW5jZSBhbmQgc2NvcGVzIChpZiBub3Qgc3VwcGxpZWQpLlxuICAgIHNldEdhcGljSldUVmFsdWVzKGNsaWVudCkge1xuICAgICAgICBjbGllbnQuZGVmYXVsdFNlcnZpY2VQYXRoID0gdGhpcy5kZWZhdWx0U2VydmljZVBhdGg7XG4gICAgICAgIGNsaWVudC51c2VKV1RBY2Nlc3NXaXRoU2NvcGUgPSB0aGlzLnVzZUpXVEFjY2Vzc1dpdGhTY29wZTtcbiAgICAgICAgY2xpZW50LmRlZmF1bHRTY29wZXMgPSB0aGlzLmRlZmF1bHRTY29wZXM7XG4gICAgfVxuICAgIGdldFByb2plY3RJZChjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0UHJvamVjdElkQXN5bmMoKS50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgciksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFByb2plY3RJZEFzeW5jKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQSB0ZW1wb3JhcnkgbWV0aG9kIGZvciBpbnRlcm5hbCBgZ2V0UHJvamVjdElkYCB1c2FnZXMgd2hlcmUgYG51bGxgIGlzXG4gICAgICogYWNjZXB0YWJsZS4gSW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZSwgYGdldFByb2plY3RJZGAgc2hvdWxkIHJldHVybiBgbnVsbGBcbiAgICAgKiAoYXMgdGhlIGBQcm9taXNlPHN0cmluZyB8IG51bGw+YCBiYXNlIHNpZ25hdHVyZSBkZXNjcmliZXMpIGFuZCB0aGlzIHByaXZhdGVcbiAgICAgKiBtZXRob2Qgc2hvdWxkIGJlIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBwcm9qZWN0IGlkIChvciBgbnVsbGApXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHJvamVjdElkT3B0aW9uYWwoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRQcm9qZWN0SWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9PT0gR29vZ2xlQXV0aEV4Y2VwdGlvbk1lc3NhZ2VzLk5PX1BST0pFQ1RfSURfRk9VTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICAgKiBBIHByaXZhdGUgbWV0aG9kIGZvciBmaW5kaW5nIGFuZCBjYWNoaW5nIGEgcHJvamVjdElkLlxuICAgICAqXG4gICAgICogU3VwcG9ydHMgZW52aXJvbm1lbnRzIGluIG9yZGVyIG9mIHByZWNlZGVuY2U6XG4gICAgICogLSBHQ0xPVURfUFJPSkVDVCBvciBHT09HTEVfQ0xPVURfUFJPSkVDVCBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICAgICAqIC0gR09PR0xFX0FQUExJQ0FUSU9OX0NSRURFTlRJQUxTIEpTT04gZmlsZVxuICAgICAqIC0gQ2xvdWQgU0RLOiBgZ2Nsb3VkIGNvbmZpZyBjb25maWctaGVscGVyIC0tZm9ybWF0IGpzb25gXG4gICAgICogLSBHQ0UgcHJvamVjdCBJRCBmcm9tIG1ldGFkYXRhIHNlcnZlclxuICAgICAqXG4gICAgICogQHJldHVybnMgcHJvamVjdElkXG4gICAgICovXG4gICAgYXN5bmMgZmluZEFuZENhY2hlUHJvamVjdElkKCkge1xuICAgICAgICBsZXQgcHJvamVjdElkID0gbnVsbDtcbiAgICAgICAgcHJvamVjdElkIHx8IChwcm9qZWN0SWQgPSBhd2FpdCB0aGlzLmdldFByb2R1Y3Rpb25Qcm9qZWN0SWQoKSk7XG4gICAgICAgIHByb2plY3RJZCB8fCAocHJvamVjdElkID0gYXdhaXQgdGhpcy5nZXRGaWxlUHJvamVjdElkKCkpO1xuICAgICAgICBwcm9qZWN0SWQgfHwgKHByb2plY3RJZCA9IGF3YWl0IHRoaXMuZ2V0RGVmYXVsdFNlcnZpY2VQcm9qZWN0SWQoKSk7XG4gICAgICAgIHByb2plY3RJZCB8fCAocHJvamVjdElkID0gYXdhaXQgdGhpcy5nZXRHQ0VQcm9qZWN0SWQoKSk7XG4gICAgICAgIHByb2plY3RJZCB8fCAocHJvamVjdElkID0gYXdhaXQgdGhpcy5nZXRFeHRlcm5hbEFjY291bnRDbGllbnRQcm9qZWN0SWQoKSk7XG4gICAgICAgIGlmIChwcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZFByb2plY3RJZCA9IHByb2plY3RJZDtcbiAgICAgICAgICAgIHJldHVybiBwcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoR29vZ2xlQXV0aEV4Y2VwdGlvbk1lc3NhZ2VzLk5PX1BST0pFQ1RfSURfRk9VTkQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFByb2plY3RJZEFzeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5fY2FjaGVkUHJvamVjdElkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkUHJvamVjdElkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZmluZFByb2plY3RJZFByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmRQcm9qZWN0SWRQcm9taXNlID0gdGhpcy5maW5kQW5kQ2FjaGVQcm9qZWN0SWQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZmluZFByb2plY3RJZFByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEFueSBzY29wZXMgKHVzZXItc3BlY2lmaWVkIG9yIGRlZmF1bHQgc2NvcGVzIHNwZWNpZmllZCBieSB0aGVcbiAgICAgKiAgIGNsaWVudCBsaWJyYXJ5KSB0aGF0IG5lZWQgdG8gYmUgc2V0IG9uIHRoZSBjdXJyZW50IEF1dGggY2xpZW50LlxuICAgICAqL1xuICAgIGdldEFueVNjb3BlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGVzIHx8IHRoaXMuZGVmYXVsdFNjb3BlcztcbiAgICB9XG4gICAgZ2V0QXBwbGljYXRpb25EZWZhdWx0KG9wdGlvbnNPckNhbGxiYWNrID0ge30sIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNPckNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNPckNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5nZXRBcHBsaWNhdGlvbkRlZmF1bHRBc3luYyhvcHRpb25zKS50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgci5jcmVkZW50aWFsLCByLnByb2plY3RJZCksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFwcGxpY2F0aW9uRGVmYXVsdEFzeW5jKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldEFwcGxpY2F0aW9uRGVmYXVsdEFzeW5jKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhIGNhY2hlZCBjcmVkZW50aWFsLCByZXR1cm4gaXQuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBhbHNvIHByZXNlcnZlIG9uZSdzIGNvbmZpZ3VyZWQgcXVvdGEgcHJvamVjdCwgaW4gY2FzZSB0aGV5XG4gICAgICAgIC8vIHNldCBvbmUgZGlyZWN0bHkgb24gdGhlIGNyZWRlbnRpYWwgcHJldmlvdXNseS5cbiAgICAgICAgaWYgKHRoaXMuY2FjaGVkQ3JlZGVudGlhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJlcGFyZUFuZENhY2hlQURDKHRoaXMuY2FjaGVkQ3JlZGVudGlhbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBhICduZXcnIEFEQyB0byBjYWNoZSB3ZSB3aWxsIHVzZSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAgICAgICAgLy8gaWYgaXQncyBhdmFpbGFibGUuIFdlIHByZWZlciB0aGlzIHZhbHVlIG92ZXIgdGhlIHZhbHVlIGZyb20gQURDLlxuICAgICAgICBjb25zdCBxdW90YVByb2plY3RJZE92ZXJyaWRlID0gcHJvY2Vzcy5lbnZbJ0dPT0dMRV9DTE9VRF9RVU9UQV9QUk9KRUNUJ107XG4gICAgICAgIGxldCBjcmVkZW50aWFsO1xuICAgICAgICAvLyBDaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhIGxvY2FsIGVudmlyb25tZW50IHZhcmlhYmxlIHBvaW50aW5nIHRvIHRoZVxuICAgICAgICAvLyBsb2NhdGlvbiBvZiB0aGUgY3JlZGVudGlhbCBmaWxlLiBUaGlzIGlzIHR5cGljYWxseSB1c2VkIGluIGxvY2FsXG4gICAgICAgIC8vIGRldmVsb3BlciBzY2VuYXJpb3MuXG4gICAgICAgIGNyZWRlbnRpYWwgPVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fdHJ5R2V0QXBwbGljYXRpb25DcmVkZW50aWFsc0Zyb21FbnZpcm9ubWVudFZhcmlhYmxlKG9wdGlvbnMpO1xuICAgICAgICBpZiAoY3JlZGVudGlhbCkge1xuICAgICAgICAgICAgaWYgKGNyZWRlbnRpYWwgaW5zdGFuY2VvZiBqd3RjbGllbnRfMS5KV1QpIHtcbiAgICAgICAgICAgICAgICBjcmVkZW50aWFsLnNjb3BlcyA9IHRoaXMuc2NvcGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3JlZGVudGlhbCBpbnN0YW5jZW9mIGJhc2VleHRlcm5hbGNsaWVudF8xLkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQpIHtcbiAgICAgICAgICAgICAgICBjcmVkZW50aWFsLnNjb3BlcyA9IHRoaXMuZ2V0QW55U2NvcGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcmVwYXJlQW5kQ2FjaGVBREMoY3JlZGVudGlhbCwgcXVvdGFQcm9qZWN0SWRPdmVycmlkZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9vayBpbiB0aGUgd2VsbC1rbm93biBjcmVkZW50aWFsIGZpbGUgbG9jYXRpb24uXG4gICAgICAgIGNyZWRlbnRpYWwgPSBhd2FpdCB0aGlzLl90cnlHZXRBcHBsaWNhdGlvbkNyZWRlbnRpYWxzRnJvbVdlbGxLbm93bkZpbGUob3B0aW9ucyk7XG4gICAgICAgIGlmIChjcmVkZW50aWFsKSB7XG4gICAgICAgICAgICBpZiAoY3JlZGVudGlhbCBpbnN0YW5jZW9mIGp3dGNsaWVudF8xLkpXVCkge1xuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWwuc2NvcGVzID0gdGhpcy5zY29wZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjcmVkZW50aWFsIGluc3RhbmNlb2YgYmFzZWV4dGVybmFsY2xpZW50XzEuQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCkge1xuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWwuc2NvcGVzID0gdGhpcy5nZXRBbnlTY29wZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByZXBhcmVBbmRDYWNoZUFEQyhjcmVkZW50aWFsLCBxdW90YVByb2plY3RJZE92ZXJyaWRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBvbiBHQ0UuXG4gICAgICAgIGxldCBpc0dDRTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlzR0NFID0gYXdhaXQgdGhpcy5fY2hlY2tJc0dDRSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gYFVuZXhwZWN0ZWQgZXJyb3IgZGV0ZXJtaW5pbmcgZXhlY3V0aW9uIGVudmlyb25tZW50OiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzR0NFKSB7XG4gICAgICAgICAgICAvLyBXZSBmYWlsZWQgdG8gZmluZCB0aGUgZGVmYXVsdCBjcmVkZW50aWFscy4gQmFpbCBvdXQgd2l0aCBhbiBlcnJvci5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGxvYWQgdGhlIGRlZmF1bHQgY3JlZGVudGlhbHMuIEJyb3dzZSB0byBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vZG9jcy9hdXRoZW50aWNhdGlvbi9nZXR0aW5nLXN0YXJ0ZWQgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIEdDRSwganVzdCByZXR1cm4gYSBkZWZhdWx0IENvbXB1dGVDbGllbnQuIEl0IHdpbGwgdGFrZSBjYXJlIG9mXG4gICAgICAgIC8vIHRoZSByZXN0LlxuICAgICAgICBvcHRpb25zLnNjb3BlcyA9IHRoaXMuZ2V0QW55U2NvcGVzKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByZXBhcmVBbmRDYWNoZUFEQyhuZXcgY29tcHV0ZWNsaWVudF8xLkNvbXB1dGUob3B0aW9ucyksIHF1b3RhUHJvamVjdElkT3ZlcnJpZGUpO1xuICAgIH1cbiAgICBhc3luYyBwcmVwYXJlQW5kQ2FjaGVBREMoY3JlZGVudGlhbCwgcXVvdGFQcm9qZWN0SWRPdmVycmlkZSkge1xuICAgICAgICBjb25zdCBwcm9qZWN0SWQgPSBhd2FpdCB0aGlzLmdldFByb2plY3RJZE9wdGlvbmFsKCk7XG4gICAgICAgIGlmIChxdW90YVByb2plY3RJZE92ZXJyaWRlKSB7XG4gICAgICAgICAgICBjcmVkZW50aWFsLnF1b3RhUHJvamVjdElkID0gcXVvdGFQcm9qZWN0SWRPdmVycmlkZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlZENyZWRlbnRpYWwgPSBjcmVkZW50aWFsO1xuICAgICAgICByZXR1cm4geyBjcmVkZW50aWFsLCBwcm9qZWN0SWQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBhdXRoIGxheWVyIGlzIHJ1bm5pbmcgb24gR29vZ2xlIENvbXB1dGUgRW5naW5lLlxuICAgICAqIENoZWNrcyBmb3IgR0NQIFJlc2lkZW5jeSwgdGhlbiBmYWxsYmFjayB0byBjaGVja2luZyBpZiBtZXRhZGF0YSBzZXJ2ZXJcbiAgICAgKiBpcyBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBib29sZWFuLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIF9jaGVja0lzR0NFKCkge1xuICAgICAgICBpZiAodGhpcy5jaGVja0lzR0NFID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tJc0dDRSA9XG4gICAgICAgICAgICAgICAgZ2NwTWV0YWRhdGEuZ2V0R0NQUmVzaWRlbmN5KCkgfHwgKGF3YWl0IGdjcE1ldGFkYXRhLmlzQXZhaWxhYmxlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrSXNHQ0U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGxvYWQgZGVmYXVsdCBjcmVkZW50aWFscyBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBwYXRoLi5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgT0F1dGgyQ2xpZW50IG9yIG51bGwuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgX3RyeUdldEFwcGxpY2F0aW9uQ3JlZGVudGlhbHNGcm9tRW52aXJvbm1lbnRWYXJpYWJsZShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNyZWRlbnRpYWxzUGF0aCA9IHByb2Nlc3MuZW52WydHT09HTEVfQVBQTElDQVRJT05fQ1JFREVOVElBTFMnXSB8fFxuICAgICAgICAgICAgcHJvY2Vzcy5lbnZbJ2dvb2dsZV9hcHBsaWNhdGlvbl9jcmVkZW50aWFscyddO1xuICAgICAgICBpZiAoIWNyZWRlbnRpYWxzUGF0aCB8fCBjcmVkZW50aWFsc1BhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEFwcGxpY2F0aW9uQ3JlZGVudGlhbHNGcm9tRmlsZVBhdGgoY3JlZGVudGlhbHNQYXRoLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IGBVbmFibGUgdG8gcmVhZCB0aGUgY3JlZGVudGlhbCBmaWxlIHNwZWNpZmllZCBieSB0aGUgR09PR0xFX0FQUExJQ0FUSU9OX0NSRURFTlRJQUxTIGVudmlyb25tZW50IHZhcmlhYmxlOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBsb2FkIGRlZmF1bHQgY3JlZGVudGlhbHMgZnJvbSBhIHdlbGwta25vd24gZmlsZSBsb2NhdGlvblxuICAgICAqIEByZXR1cm4gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIE9BdXRoMkNsaWVudCBvciBudWxsLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIF90cnlHZXRBcHBsaWNhdGlvbkNyZWRlbnRpYWxzRnJvbVdlbGxLbm93bkZpbGUob3B0aW9ucykge1xuICAgICAgICAvLyBGaXJzdCwgZmlndXJlIG91dCB0aGUgbG9jYXRpb24gb2YgdGhlIGZpbGUsIGRlcGVuZGluZyB1cG9uIHRoZSBPUyB0eXBlLlxuICAgICAgICBsZXQgbG9jYXRpb24gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5faXNXaW5kb3dzKCkpIHtcbiAgICAgICAgICAgIC8vIFdpbmRvd3NcbiAgICAgICAgICAgIGxvY2F0aW9uID0gcHJvY2Vzcy5lbnZbJ0FQUERBVEEnXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIExpbnV4IG9yIE1hY1xuICAgICAgICAgICAgY29uc3QgaG9tZSA9IHByb2Nlc3MuZW52WydIT01FJ107XG4gICAgICAgICAgICBpZiAoaG9tZSkge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gcGF0aC5qb2luKGhvbWUsICcuY29uZmlnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZm91bmQgdGhlIHJvb3QgcGF0aCwgZXhwYW5kIGl0LlxuICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICAgIGxvY2F0aW9uID0gcGF0aC5qb2luKGxvY2F0aW9uLCAnZ2Nsb3VkJywgJ2FwcGxpY2F0aW9uX2RlZmF1bHRfY3JlZGVudGlhbHMuanNvbicpO1xuICAgICAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGxvY2F0aW9uKSkge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgZmlsZSBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgaWYgKCFsb2NhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGZpbGUgc2VlbXMgdG8gZXhpc3QuIFRyeSB0byB1c2UgaXQuXG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuX2dldEFwcGxpY2F0aW9uQ3JlZGVudGlhbHNGcm9tRmlsZVBhdGgobG9jYXRpb24sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBsb2FkIGRlZmF1bHQgY3JlZGVudGlhbHMgZnJvbSBhIGZpbGUgYXQgdGhlIGdpdmVuIHBhdGguLlxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCBUaGUgcGF0aCB0byB0aGUgZmlsZSB0byByZWFkLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBPQXV0aDJDbGllbnRcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0QXBwbGljYXRpb25DcmVkZW50aWFsc0Zyb21GaWxlUGF0aChmaWxlUGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcGF0aCBsb29rcyBsaWtlIGEgc3RyaW5nLlxuICAgICAgICBpZiAoIWZpbGVQYXRoIHx8IGZpbGVQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZmlsZSBwYXRoIGlzIGludmFsaWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZXJlIGlzIGEgZmlsZSBhdCB0aGUgcGF0aC4gbHN0YXRTeW5jIHdpbGwgdGhyb3cgaWYgdGhlcmUgaXNcbiAgICAgICAgLy8gbm90aGluZyB0aGVyZS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFJlc29sdmUgcGF0aCB0byBhY3R1YWwgZmlsZSBpbiBjYXNlIG9mIHN5bWxpbmsuIEV4cGVjdCBhIHRocm93biBlcnJvclxuICAgICAgICAgICAgLy8gaWYgbm90IHJlc29sdmFibGUuXG4gICAgICAgICAgICBmaWxlUGF0aCA9IGZzLnJlYWxwYXRoU3luYyhmaWxlUGF0aCk7XG4gICAgICAgICAgICBpZiAoIWZzLmxzdGF0U3luYyhmaWxlUGF0aCkuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGBUaGUgZmlsZSBhdCAke2ZpbGVQYXRofSBkb2VzIG5vdCBleGlzdCwgb3IgaXQgaXMgbm90IGEgZmlsZS4gJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyBvcGVuIGEgcmVhZCBzdHJlYW0gb24gdGhlIGZpbGUsIGFuZCBwYXJzZSBpdC5cbiAgICAgICAgY29uc3QgcmVhZFN0cmVhbSA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oZmlsZVBhdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tU3RyZWFtKHJlYWRTdHJlYW0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjcmVkZW50aWFscyBpbnN0YW5jZSB1c2luZyBhIGdpdmVuIGltcGVyc29uYXRlZCBpbnB1dCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBqc29uIFRoZSBpbXBlcnNvbmF0ZWQgaW5wdXQgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIEpXVCBvciBVc2VyUmVmcmVzaCBDbGllbnQgd2l0aCBkYXRhXG4gICAgICovXG4gICAgZnJvbUltcGVyc29uYXRlZEpTT04oanNvbikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGlmICghanNvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHBhc3MgaW4gYSBKU09OIG9iamVjdCBjb250YWluaW5nIGFuICBpbXBlcnNvbmF0ZWQgcmVmcmVzaCB0b2tlbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc29uLnR5cGUgIT09IGltcGVyc29uYXRlZF8xLklNUEVSU09OQVRFRF9BQ0NPVU5UX1RZUEUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGluY29taW5nIEpTT04gb2JqZWN0IGRvZXMgbm90IGhhdmUgdGhlIFwiJHtpbXBlcnNvbmF0ZWRfMS5JTVBFUlNPTkFURURfQUNDT1VOVF9UWVBFfVwiIHR5cGVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWpzb24uc291cmNlX2NyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgc291cmNlX2NyZWRlbnRpYWxzIGZpZWxkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc29uLnNlcnZpY2VfYWNjb3VudF9pbXBlcnNvbmF0aW9uX3VybCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW5jb21pbmcgSlNPTiBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhIHNlcnZpY2VfYWNjb3VudF9pbXBlcnNvbmF0aW9uX3VybCBmaWVsZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBzb3VyY2UgY2xpZW50IGZvciBpbXBlcnNvbmF0aW9uXG4gICAgICAgIGNvbnN0IHNvdXJjZUNsaWVudCA9IG5ldyByZWZyZXNoY2xpZW50XzEuVXNlclJlZnJlc2hDbGllbnQoanNvbi5zb3VyY2VfY3JlZGVudGlhbHMuY2xpZW50X2lkLCBqc29uLnNvdXJjZV9jcmVkZW50aWFscy5jbGllbnRfc2VjcmV0LCBqc29uLnNvdXJjZV9jcmVkZW50aWFscy5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgLy8gRXh0cmVhY3Qgc2VydmljZSBhY2NvdW50IGZyb20gc2VydmljZV9hY2NvdW50X2ltcGVyc29uYXRpb25fdXJsXG4gICAgICAgIGNvbnN0IHRhcmdldFByaW5jaXBhbCA9IChfYiA9IChfYSA9IC8oPzx0YXJnZXQ+W14vXSspOmdlbmVyYXRlQWNjZXNzVG9rZW4kLy5leGVjKGpzb24uc2VydmljZV9hY2NvdW50X2ltcGVyc29uYXRpb25fdXJsKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdyb3VwcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRhcmdldDtcbiAgICAgICAgaWYgKCF0YXJnZXRQcmluY2lwYWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBDYW5ub3QgZXh0cmFjdCB0YXJnZXQgcHJpbmNpcGFsIGZyb20gJHtqc29uLnNlcnZpY2VfYWNjb3VudF9pbXBlcnNvbmF0aW9uX3VybH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRTY29wZXMgPSAoX2MgPSB0aGlzLmdldEFueVNjb3BlcygpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gbmV3IGltcGVyc29uYXRlZF8xLkltcGVyc29uYXRlZCh7XG4gICAgICAgICAgICBkZWxlZ2F0ZXM6IChfZCA9IGpzb24uZGVsZWdhdGVzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBbXSxcbiAgICAgICAgICAgIHNvdXJjZUNsaWVudDogc291cmNlQ2xpZW50LFxuICAgICAgICAgICAgdGFyZ2V0UHJpbmNpcGFsOiB0YXJnZXRQcmluY2lwYWwsXG4gICAgICAgICAgICB0YXJnZXRTY29wZXM6IEFycmF5LmlzQXJyYXkodGFyZ2V0U2NvcGVzKSA/IHRhcmdldFNjb3BlcyA6IFt0YXJnZXRTY29wZXNdLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY3JlZGVudGlhbHMgaW5zdGFuY2UgdXNpbmcgdGhlIGdpdmVuIGlucHV0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGpzb24gVGhlIGlucHV0IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgSldUIG9yIFVzZXJSZWZyZXNoIG9wdGlvbnMgZm9yIHRoZSBjbGllbnRcbiAgICAgKiBAcmV0dXJucyBKV1Qgb3IgVXNlclJlZnJlc2ggQ2xpZW50IHdpdGggZGF0YVxuICAgICAqL1xuICAgIGZyb21KU09OKGpzb24sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgY2xpZW50O1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgaWYgKGpzb24udHlwZSA9PT0gcmVmcmVzaGNsaWVudF8xLlVTRVJfUkVGUkVTSF9BQ0NPVU5UX1RZUEUpIHtcbiAgICAgICAgICAgIGNsaWVudCA9IG5ldyByZWZyZXNoY2xpZW50XzEuVXNlclJlZnJlc2hDbGllbnQob3B0aW9ucyk7XG4gICAgICAgICAgICBjbGllbnQuZnJvbUpTT04oanNvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoanNvbi50eXBlID09PSBpbXBlcnNvbmF0ZWRfMS5JTVBFUlNPTkFURURfQUNDT1VOVF9UWVBFKSB7XG4gICAgICAgICAgICBjbGllbnQgPSB0aGlzLmZyb21JbXBlcnNvbmF0ZWRKU09OKGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzb24udHlwZSA9PT0gYmFzZWV4dGVybmFsY2xpZW50XzEuRVhURVJOQUxfQUNDT1VOVF9UWVBFKSB7XG4gICAgICAgICAgICBjbGllbnQgPSBleHRlcm5hbGNsaWVudF8xLkV4dGVybmFsQWNjb3VudENsaWVudC5mcm9tSlNPTihqc29uLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNsaWVudC5zY29wZXMgPSB0aGlzLmdldEFueVNjb3BlcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzb24udHlwZSA9PT0gZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnRfMS5FWFRFUk5BTF9BQ0NPVU5UX0FVVEhPUklaRURfVVNFUl9UWVBFKSB7XG4gICAgICAgICAgICBjbGllbnQgPSBuZXcgZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnRfMS5FeHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudChqc29uLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2NvcGVzID0gdGhpcy5zY29wZXM7XG4gICAgICAgICAgICBjbGllbnQgPSBuZXcgand0Y2xpZW50XzEuSldUKG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5zZXRHYXBpY0pXVFZhbHVlcyhjbGllbnQpO1xuICAgICAgICAgICAgY2xpZW50LmZyb21KU09OKGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIEpXVCBvciBVc2VyUmVmcmVzaENsaWVudCBmcm9tIEphdmFTY3JpcHQgb2JqZWN0LCBjYWNoaW5nIGJvdGggdGhlXG4gICAgICogb2JqZWN0IHVzZWQgdG8gaW5zdGFudGlhdGUgYW5kIHRoZSBjbGllbnQuXG4gICAgICogQHBhcmFtIGpzb24gVGhlIGlucHV0IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgSldUIG9yIFVzZXJSZWZyZXNoIG9wdGlvbnMgZm9yIHRoZSBjbGllbnRcbiAgICAgKiBAcmV0dXJucyBKV1Qgb3IgVXNlclJlZnJlc2ggQ2xpZW50IHdpdGggZGF0YVxuICAgICAqL1xuICAgIF9jYWNoZUNsaWVudEZyb21KU09OKGpzb24sIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5mcm9tSlNPTihqc29uLCBvcHRpb25zKTtcbiAgICAgICAgLy8gY2FjaGUgYm90aCByYXcgZGF0YSB1c2VkIHRvIGluc3RhbnRpYXRlIGNsaWVudCBhbmQgY2xpZW50IGl0c2VsZi5cbiAgICAgICAgdGhpcy5qc29uQ29udGVudCA9IGpzb247XG4gICAgICAgIHRoaXMuY2FjaGVkQ3JlZGVudGlhbCA9IGNsaWVudDtcbiAgICAgICAgcmV0dXJuIGNsaWVudDtcbiAgICB9XG4gICAgZnJvbVN0cmVhbShpbnB1dFN0cmVhbSwgb3B0aW9uc09yQ2FsbGJhY2sgPSB7fSwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zT3JDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zT3JDYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zT3JDYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtLCBvcHRpb25zKS50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgciksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlucHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHBhc3MgaW4gYSBzdHJlYW0gY29udGFpbmluZyB0aGUgR29vZ2xlIGF1dGggc2V0dGluZ3MuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcyA9ICcnO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW1cbiAgICAgICAgICAgICAgICAuc2V0RW5jb2RpbmcoJ3V0ZjgnKVxuICAgICAgICAgICAgICAgIC5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgICAgICAgICAgLm9uKCdkYXRhJywgY2h1bmsgPT4gKHMgKz0gY2h1bmspKVxuICAgICAgICAgICAgICAgIC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLl9jYWNoZUNsaWVudEZyb21KU09OKGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgZmFpbGVkIHBhcnNpbmcgdGhpcy5rZXlGaWxlTmFtZSwgYXNzdW1lIHRoYXQgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIGEgUEVNIG9yIHAxMiBjZXJ0aWZpY2F0ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5rZXlGaWxlbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnQgPSBuZXcgand0Y2xpZW50XzEuSldUKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmNsaWVudE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RmlsZTogdGhpcy5rZXlGaWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRDcmVkZW50aWFsID0gY2xpZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRHYXBpY0pXVFZhbHVlcyhjbGllbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoY2xpZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNyZWRlbnRpYWxzIGluc3RhbmNlIHVzaW5nIHRoZSBnaXZlbiBBUEkga2V5IHN0cmluZy5cbiAgICAgKiBAcGFyYW0gYXBpS2V5IFRoZSBBUEkga2V5IHN0cmluZ1xuICAgICAqIEBwYXJhbSBvcHRpb25zIEFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIEEgSldUIGxvYWRlZCBmcm9tIHRoZSBrZXlcbiAgICAgKi9cbiAgICBmcm9tQVBJS2V5KGFwaUtleSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gbmV3IGp3dGNsaWVudF8xLkpXVChvcHRpb25zKTtcbiAgICAgICAgY2xpZW50LmZyb21BUElLZXkoYXBpS2V5KTtcbiAgICAgICAgcmV0dXJuIGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjdXJyZW50IG9wZXJhdGluZyBzeXN0ZW0gaXMgV2luZG93cy5cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNXaW5kb3dzKCkge1xuICAgICAgICBjb25zdCBzeXMgPSBvcy5wbGF0Zm9ybSgpO1xuICAgICAgICBpZiAoc3lzICYmIHN5cy5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgaWYgKHN5cy5zdWJzdHJpbmcoMCwgMykudG9Mb3dlckNhc2UoKSA9PT0gJ3dpbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1biB0aGUgR29vZ2xlIENsb3VkIFNESyBjb21tYW5kIHRoYXQgcHJpbnRzIHRoZSBkZWZhdWx0IHByb2plY3QgSURcbiAgICAgKi9cbiAgICBhc3luYyBnZXREZWZhdWx0U2VydmljZVByb2plY3RJZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgKDAsIGNoaWxkX3Byb2Nlc3NfMS5leGVjKSgnZ2Nsb3VkIGNvbmZpZyBjb25maWctaGVscGVyIC0tZm9ybWF0IGpzb24nLCAoZXJyLCBzdGRvdXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWVyciAmJiBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2plY3RJZCA9IEpTT04ucGFyc2Uoc3Rkb3V0KS5jb25maWd1cmF0aW9uLnByb3BlcnRpZXMuY29yZS5wcm9qZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwcm9qZWN0SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIHByb2plY3QgaWQgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0UHJvZHVjdGlvblByb2plY3RJZCgpIHtcbiAgICAgICAgcmV0dXJuIChwcm9jZXNzLmVudlsnR0NMT1VEX1BST0pFQ1QnXSB8fFxuICAgICAgICAgICAgcHJvY2Vzcy5lbnZbJ0dPT0dMRV9DTE9VRF9QUk9KRUNUJ10gfHxcbiAgICAgICAgICAgIHByb2Nlc3MuZW52WydnY2xvdWRfcHJvamVjdCddIHx8XG4gICAgICAgICAgICBwcm9jZXNzLmVudlsnZ29vZ2xlX2Nsb3VkX3Byb2plY3QnXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBwcm9qZWN0IGlkIGZyb20gdGhlIEdPT0dMRV9BUFBMSUNBVElPTl9DUkVERU5USUFMUyBqc29uIGZpbGUuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RmlsZVByb2plY3RJZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVkQ3JlZGVudGlhbCkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIHJlYWQgdGhlIHByb2plY3QgSUQgZnJvbSB0aGUgY2FjaGVkIGNyZWRlbnRpYWxzIGZpbGVcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlZENyZWRlbnRpYWwucHJvamVjdElkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgcHJvamVjdElkIGlzIGxvYWRlZCBmcm9tIHRoZSBrZXlGaWxlIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgaWYgKHRoaXMua2V5RmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWRzID0gYXdhaXQgdGhpcy5nZXRDbGllbnQoKTtcbiAgICAgICAgICAgIGlmIChjcmVkcyAmJiBjcmVkcy5wcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlZHMucHJvamVjdElkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSB0byBsb2FkIGEgY3JlZGVudGlhbHMgZmlsZSBhbmQgcmVhZCBpdHMgcHJvamVjdCBJRFxuICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5fdHJ5R2V0QXBwbGljYXRpb25DcmVkZW50aWFsc0Zyb21FbnZpcm9ubWVudFZhcmlhYmxlKCk7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gci5wcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwcm9qZWN0IElEIGZyb20gZXh0ZXJuYWwgYWNjb3VudCBjbGllbnQgaWYgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEV4dGVybmFsQWNjb3VudENsaWVudFByb2plY3RJZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmpzb25Db250ZW50IHx8IHRoaXMuanNvbkNvbnRlbnQudHlwZSAhPT0gYmFzZWV4dGVybmFsY2xpZW50XzEuRVhURVJOQUxfQUNDT1VOVF9UWVBFKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVkcyA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIC8vIERvIG5vdCBzdXBwcmVzcyB0aGUgdW5kZXJseWluZyBlcnJvciwgYXMgdGhlIGVycm9yIGNvdWxkIGNvbnRhaW4gaGVscGZ1bFxuICAgICAgICAvLyBpbmZvcm1hdGlvbiBmb3IgZGVidWdnaW5nIGFuZCBmaXhpbmcuIFRoaXMgaXMgZXNwZWNpYWxseSB0cnVlIGZvclxuICAgICAgICAvLyBleHRlcm5hbCBhY2NvdW50IGNyZWRzIGFzIGluIG9yZGVyIHRvIGdldCB0aGUgcHJvamVjdCBJRCwgdGhlIGZvbGxvd2luZ1xuICAgICAgICAvLyBvcGVyYXRpb25zIGhhdmUgdG8gc3VjY2VlZDpcbiAgICAgICAgLy8gMS4gVmFsaWQgY3JlZGVudGlhbHMgZmlsZSBzaG91bGQgYmUgc3VwcGxpZWQuXG4gICAgICAgIC8vIDIuIEFiaWxpdHkgdG8gcmV0cmlldmUgYWNjZXNzIHRva2VucyBmcm9tIFNUUyB0b2tlbiBleGNoYW5nZSBBUEkuXG4gICAgICAgIC8vIDMuIEFiaWxpdHkgdG8gZXhjaGFuZ2UgZm9yIHNlcnZpY2UgYWNjb3VudCBpbXBlcnNvbmF0ZWQgY3JlZGVudGlhbHMgKGlmXG4gICAgICAgIC8vICAgIGVuYWJsZWQpLlxuICAgICAgICAvLyA0LiBBYmlsaXR5IHRvIGdldCBwcm9qZWN0IGluZm8gdXNpbmcgdGhlIGFjY2VzcyB0b2tlbiBmcm9tIHN0ZXAgMiBvciAzLlxuICAgICAgICAvLyBXaXRob3V0IHN1cmZhY2luZyB0aGUgZXJyb3IsIGl0IGlzIGhhcmRlciBmb3IgZGV2ZWxvcGVycyB0byBkZXRlcm1pbmVcbiAgICAgICAgLy8gd2hpY2ggc3RlcCB3ZW50IHdyb25nLlxuICAgICAgICByZXR1cm4gYXdhaXQgY3JlZHMuZ2V0UHJvamVjdElkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIENvbXB1dGUgRW5naW5lIHByb2plY3QgSUQgaWYgaXQgY2FuIGJlIGluZmVycmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEdDRVByb2plY3RJZCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBhd2FpdCBnY3BNZXRhZGF0YS5wcm9qZWN0KCdwcm9qZWN0LWlkJyk7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSWdub3JlIGFueSBlcnJvcnNcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENyZWRlbnRpYWxzKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5nZXRDcmVkZW50aWFsc0FzeW5jKCkudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDcmVkZW50aWFsc0FzeW5jKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0Q3JlZGVudGlhbHNBc3luYygpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5nZXRDbGllbnQoKTtcbiAgICAgICAgaWYgKGNsaWVudCBpbnN0YW5jZW9mIGJhc2VleHRlcm5hbGNsaWVudF8xLkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VBY2NvdW50RW1haWwgPSBjbGllbnQuZ2V0U2VydmljZUFjY291bnRFbWFpbCgpO1xuICAgICAgICAgICAgaWYgKHNlcnZpY2VBY2NvdW50RW1haWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjbGllbnRfZW1haWw6IHNlcnZpY2VBY2NvdW50RW1haWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5qc29uQ29udGVudCkge1xuICAgICAgICAgICAgY29uc3QgY3JlZGVudGlhbCA9IHtcbiAgICAgICAgICAgICAgICBjbGllbnRfZW1haWw6IHRoaXMuanNvbkNvbnRlbnQuY2xpZW50X2VtYWlsLFxuICAgICAgICAgICAgICAgIHByaXZhdGVfa2V5OiB0aGlzLmpzb25Db250ZW50LnByaXZhdGVfa2V5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBjcmVkZW50aWFsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzR0NFID0gYXdhaXQgdGhpcy5fY2hlY2tJc0dDRSgpO1xuICAgICAgICBpZiAoIWlzR0NFKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZXJyb3IuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIEdDRSwgcmV0dXJuIHRoZSBzZXJ2aWNlIGFjY291bnQgZGV0YWlscyBmcm9tIHRoZSBtZXRhZGF0YSBzZXJ2ZXJcbiAgICAgICAgLy8gTk9URTogVGhlIHRyYWlsaW5nICcvJyBhdCB0aGUgZW5kIG9mIHNlcnZpY2UtYWNjb3VudHMvIGlzIHZlcnkgaW1wb3J0YW50IVxuICAgICAgICAvLyBUaGUgR0NGIG1ldGFkYXRhIHNlcnZlciBkb2Vzbid0IHJlc3BlY3QgcXVlcnlzdHJpbmcgcGFyYW1zIGlmIHRoaXMgLyBpc1xuICAgICAgICAvLyBub3QgaW5jbHVkZWQuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnY3BNZXRhZGF0YS5pbnN0YW5jZSh7XG4gICAgICAgICAgICBwcm9wZXJ0eTogJ3NlcnZpY2UtYWNjb3VudHMvJyxcbiAgICAgICAgICAgIHBhcmFtczogeyByZWN1cnNpdmU6ICd0cnVlJyB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmRlZmF1bHQgfHwgIWRhdGEuZGVmYXVsdC5lbWFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsdXJlIGZyb20gbWV0YWRhdGEgc2VydmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNsaWVudF9lbWFpbDogZGF0YS5kZWZhdWx0LmVtYWlsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpY2FsbHkgb2J0YWluIGEgY2xpZW50IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uLiAgSWYgbm9cbiAgICAgKiBvcHRpb25zIHdlcmUgcGFzc2VkLCB1c2UgQXBwbGljYXRpb24gRGVmYXVsdCBDcmVkZW50aWFscy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDbGllbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWNoZWRDcmVkZW50aWFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5qc29uQ29udGVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlQ2xpZW50RnJvbUpTT04odGhpcy5qc29uQ29udGVudCwgdGhpcy5jbGllbnRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMua2V5RmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGgucmVzb2x2ZSh0aGlzLmtleUZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmZyb21TdHJlYW1Bc3luYyhzdHJlYW0sIHRoaXMuY2xpZW50T3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmdldEFwcGxpY2F0aW9uRGVmYXVsdEFzeW5jKHRoaXMuY2xpZW50T3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkQ3JlZGVudGlhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsaWVudCB3aGljaCB3aWxsIGZldGNoIGFuIElEIHRva2VuIGZvciBhdXRob3JpemF0aW9uLlxuICAgICAqIEBwYXJhbSB0YXJnZXRBdWRpZW5jZSB0aGUgYXVkaWVuY2UgZm9yIHRoZSBmZXRjaGVkIElEIHRva2VuLlxuICAgICAqIEByZXR1cm5zIElkVG9rZW5DbGllbnQgZm9yIG1ha2luZyBIVFRQIGNhbGxzIGF1dGhlbnRpY2F0ZWQgd2l0aCBJRCB0b2tlbnMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SWRUb2tlbkNsaWVudCh0YXJnZXRBdWRpZW5jZSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICBpZiAoISgnZmV0Y2hJZFRva2VuJyBpbiBjbGllbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmZXRjaCBJRCB0b2tlbiBpbiB0aGlzIGVudmlyb25tZW50LCB1c2UgR0NFIG9yIHNldCB0aGUgR09PR0xFX0FQUExJQ0FUSU9OX0NSRURFTlRJQUxTIGVudmlyb25tZW50IHZhcmlhYmxlIHRvIGEgc2VydmljZSBhY2NvdW50IGNyZWRlbnRpYWxzIEpTT04gZmlsZS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGlkdG9rZW5jbGllbnRfMS5JZFRva2VuQ2xpZW50KHsgdGFyZ2V0QXVkaWVuY2UsIGlkVG9rZW5Qcm92aWRlcjogY2xpZW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWNhbGx5IG9idGFpbiBhcHBsaWNhdGlvbiBkZWZhdWx0IGNyZWRlbnRpYWxzLCBhbmQgcmV0dXJuXG4gICAgICogYW4gYWNjZXNzIHRva2VuIGZvciBtYWtpbmcgcmVxdWVzdHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIHJldHVybiAoYXdhaXQgY2xpZW50LmdldEFjY2Vzc1Rva2VuKCkpLnRva2VuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPYnRhaW4gdGhlIEhUVFAgaGVhZGVycyB0aGF0IHdpbGwgcHJvdmlkZSBhdXRob3JpemF0aW9uIGZvciBhIGdpdmVuXG4gICAgICogcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXF1ZXN0SGVhZGVycyh1cmwpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5nZXRDbGllbnQoKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5nZXRSZXF1ZXN0SGVhZGVycyh1cmwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPYnRhaW4gY3JlZGVudGlhbHMgZm9yIGEgcmVxdWVzdCwgdGhlbiBhdHRhY2ggdGhlIGFwcHJvcHJpYXRlIGhlYWRlcnMgdG9cbiAgICAgKiB0aGUgcmVxdWVzdCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRzIEF4aW9zIG9yIFJlcXVlc3Qgb3B0aW9ucyBvbiB3aGljaCB0byBhdHRhY2ggdGhlIGhlYWRlcnNcbiAgICAgKi9cbiAgICBhc3luYyBhdXRob3JpemVSZXF1ZXN0KG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIGNvbnN0IHVybCA9IG9wdHMudXJsIHx8IG9wdHMudXJpO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gYXdhaXQgY2xpZW50LmdldFJlcXVlc3RIZWFkZXJzKHVybCk7XG4gICAgICAgIG9wdHMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24ob3B0cy5oZWFkZXJzIHx8IHt9LCBoZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpY2FsbHkgb2J0YWluIGFwcGxpY2F0aW9uIGRlZmF1bHQgY3JlZGVudGlhbHMsIGFuZCBtYWtlIGFuXG4gICAgICogSFRUUCByZXF1ZXN0IHVzaW5nIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRzIEF4aW9zIHJlcXVlc3Qgb3B0aW9ucyBmb3IgdGhlIEhUVFAgcmVxdWVzdC5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGFzeW5jIHJlcXVlc3Qob3B0cykge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICByZXR1cm4gY2xpZW50LnJlcXVlc3Qob3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgY29tcHV0ZSBlbnZpcm9ubWVudCBpbiB3aGljaCB0aGUgY29kZSBpcyBydW5uaW5nLlxuICAgICAqL1xuICAgIGdldEVudigpIHtcbiAgICAgICAgcmV0dXJuICgwLCBlbnZEZXRlY3RfMS5nZXRFbnYpKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ24gdGhlIGdpdmVuIGRhdGEgd2l0aCB0aGUgY3VycmVudCBwcml2YXRlIGtleSwgb3IgZ28gb3V0XG4gICAgICogdG8gdGhlIElBTSBBUEkgdG8gc2lnbiBpdC5cbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBiZSBzaWduZWQuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbihkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIGNvbnN0IGNyeXB0byA9ICgwLCBjcnlwdG9fMS5jcmVhdGVDcnlwdG8pKCk7XG4gICAgICAgIGlmIChjbGllbnQgaW5zdGFuY2VvZiBqd3RjbGllbnRfMS5KV1QgJiYgY2xpZW50LmtleSkge1xuICAgICAgICAgICAgY29uc3Qgc2lnbiA9IGF3YWl0IGNyeXB0by5zaWduKGNsaWVudC5rZXksIGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHNpZ247XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlZHMgPSBhd2FpdCB0aGlzLmdldENyZWRlbnRpYWxzKCk7XG4gICAgICAgIGlmICghY3JlZHMuY2xpZW50X2VtYWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzaWduIGRhdGEgd2l0aG91dCBgY2xpZW50X2VtYWlsYC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zaWduQmxvYihjcnlwdG8sIGNyZWRzLmNsaWVudF9lbWFpbCwgZGF0YSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25CbG9iKGNyeXB0bywgZW1haWxPclVuaXF1ZUlkLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IHVybCA9ICdodHRwczovL2lhbWNyZWRlbnRpYWxzLmdvb2dsZWFwaXMuY29tL3YxL3Byb2plY3RzLy0vc2VydmljZUFjY291bnRzLycgK1xuICAgICAgICAgICAgYCR7ZW1haWxPclVuaXF1ZUlkfTpzaWduQmxvYmA7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBjcnlwdG8uZW5jb2RlQmFzZTY0U3RyaW5nVXRmOChkYXRhKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzLmRhdGEuc2lnbmVkQmxvYjtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZUF1dGggPSBHb29nbGVBdXRoO1xuLyoqXG4gKiBFeHBvcnQgRGVmYXVsdFRyYW5zcG9ydGVyIGFzIGEgc3RhdGljIHByb3BlcnR5IG9mIHRoZSBjbGFzcy5cbiAqL1xuR29vZ2xlQXV0aC5EZWZhdWx0VHJhbnNwb3J0ZXIgPSB0cmFuc3BvcnRlcnNfMS5EZWZhdWx0VHJhbnNwb3J0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nb29nbGVhdXRoLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkdvb2dsZUF1dGgiLCJDTE9VRF9TREtfQ0xJRU5UX0lEIiwiY2hpbGRfcHJvY2Vzc18xIiwicmVxdWlyZSIsImZzIiwiZ2NwTWV0YWRhdGEiLCJvcyIsInBhdGgiLCJjcnlwdG9fMSIsInRyYW5zcG9ydGVyc18xIiwiY29tcHV0ZWNsaWVudF8xIiwiaWR0b2tlbmNsaWVudF8xIiwiZW52RGV0ZWN0XzEiLCJqd3RjbGllbnRfMSIsInJlZnJlc2hjbGllbnRfMSIsImltcGVyc29uYXRlZF8xIiwiZXh0ZXJuYWxjbGllbnRfMSIsImJhc2VleHRlcm5hbGNsaWVudF8xIiwiZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnRfMSIsIkdvb2dsZUF1dGhFeGNlcHRpb25NZXNzYWdlcyIsIk5PX1BST0pFQ1RfSURfRk9VTkQiLCJpc0dDRSIsImNoZWNrSXNHQ0UiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJ1bmRlZmluZWQiLCJqc29uQ29udGVudCIsImNhY2hlZENyZWRlbnRpYWwiLCJfY2FjaGVkUHJvamVjdElkIiwicHJvamVjdElkIiwiYXV0aENsaWVudCIsImtleUZpbGVuYW1lIiwia2V5RmlsZSIsInNjb3BlcyIsImNyZWRlbnRpYWxzIiwiY2xpZW50T3B0aW9ucyIsInNldEdhcGljSldUVmFsdWVzIiwiY2xpZW50IiwiZGVmYXVsdFNlcnZpY2VQYXRoIiwidXNlSldUQWNjZXNzV2l0aFNjb3BlIiwiZGVmYXVsdFNjb3BlcyIsImdldFByb2plY3RJZCIsImNhbGxiYWNrIiwiZ2V0UHJvamVjdElkQXN5bmMiLCJ0aGVuIiwiciIsImdldFByb2plY3RJZE9wdGlvbmFsIiwiZSIsIkVycm9yIiwibWVzc2FnZSIsImZpbmRBbmRDYWNoZVByb2plY3RJZCIsImdldFByb2R1Y3Rpb25Qcm9qZWN0SWQiLCJnZXRGaWxlUHJvamVjdElkIiwiZ2V0RGVmYXVsdFNlcnZpY2VQcm9qZWN0SWQiLCJnZXRHQ0VQcm9qZWN0SWQiLCJnZXRFeHRlcm5hbEFjY291bnRDbGllbnRQcm9qZWN0SWQiLCJfZmluZFByb2plY3RJZFByb21pc2UiLCJnZXRBbnlTY29wZXMiLCJnZXRBcHBsaWNhdGlvbkRlZmF1bHQiLCJvcHRpb25zT3JDYWxsYmFjayIsIm9wdGlvbnMiLCJnZXRBcHBsaWNhdGlvbkRlZmF1bHRBc3luYyIsImNyZWRlbnRpYWwiLCJwcmVwYXJlQW5kQ2FjaGVBREMiLCJxdW90YVByb2plY3RJZE92ZXJyaWRlIiwicHJvY2VzcyIsImVudiIsIl90cnlHZXRBcHBsaWNhdGlvbkNyZWRlbnRpYWxzRnJvbUVudmlyb25tZW50VmFyaWFibGUiLCJKV1QiLCJCYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50IiwiX3RyeUdldEFwcGxpY2F0aW9uQ3JlZGVudGlhbHNGcm9tV2VsbEtub3duRmlsZSIsIl9jaGVja0lzR0NFIiwiQ29tcHV0ZSIsInF1b3RhUHJvamVjdElkIiwiZ2V0R0NQUmVzaWRlbmN5IiwiaXNBdmFpbGFibGUiLCJjcmVkZW50aWFsc1BhdGgiLCJsZW5ndGgiLCJfZ2V0QXBwbGljYXRpb25DcmVkZW50aWFsc0Zyb21GaWxlUGF0aCIsImxvY2F0aW9uIiwiX2lzV2luZG93cyIsImhvbWUiLCJqb2luIiwiZXhpc3RzU3luYyIsImZpbGVQYXRoIiwicmVhbHBhdGhTeW5jIiwibHN0YXRTeW5jIiwiaXNGaWxlIiwiZXJyIiwicmVhZFN0cmVhbSIsImNyZWF0ZVJlYWRTdHJlYW0iLCJmcm9tU3RyZWFtIiwiZnJvbUltcGVyc29uYXRlZEpTT04iLCJqc29uIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJ0eXBlIiwiSU1QRVJTT05BVEVEX0FDQ09VTlRfVFlQRSIsInNvdXJjZV9jcmVkZW50aWFscyIsInNlcnZpY2VfYWNjb3VudF9pbXBlcnNvbmF0aW9uX3VybCIsInNvdXJjZUNsaWVudCIsIlVzZXJSZWZyZXNoQ2xpZW50IiwiY2xpZW50X2lkIiwiY2xpZW50X3NlY3JldCIsInJlZnJlc2hfdG9rZW4iLCJ0YXJnZXRQcmluY2lwYWwiLCJleGVjIiwiZ3JvdXBzIiwidGFyZ2V0IiwiUmFuZ2VFcnJvciIsInRhcmdldFNjb3BlcyIsIkltcGVyc29uYXRlZCIsImRlbGVnYXRlcyIsIkFycmF5IiwiaXNBcnJheSIsImZyb21KU09OIiwiVVNFUl9SRUZSRVNIX0FDQ09VTlRfVFlQRSIsIkVYVEVSTkFMX0FDQ09VTlRfVFlQRSIsIkV4dGVybmFsQWNjb3VudENsaWVudCIsIkVYVEVSTkFMX0FDQ09VTlRfQVVUSE9SSVpFRF9VU0VSX1RZUEUiLCJFeHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudCIsIl9jYWNoZUNsaWVudEZyb21KU09OIiwiaW5wdXRTdHJlYW0iLCJmcm9tU3RyZWFtQXN5bmMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInMiLCJzZXRFbmNvZGluZyIsIm9uIiwiY2h1bmsiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwiZnJvbUFQSUtleSIsImFwaUtleSIsInN5cyIsInBsYXRmb3JtIiwic3Vic3RyaW5nIiwidG9Mb3dlckNhc2UiLCJzdGRvdXQiLCJjb25maWd1cmF0aW9uIiwicHJvcGVydGllcyIsImNvcmUiLCJwcm9qZWN0IiwiY3JlZHMiLCJnZXRDbGllbnQiLCJnZXRDcmVkZW50aWFscyIsImdldENyZWRlbnRpYWxzQXN5bmMiLCJzZXJ2aWNlQWNjb3VudEVtYWlsIiwiZ2V0U2VydmljZUFjY291bnRFbWFpbCIsImNsaWVudF9lbWFpbCIsInByaXZhdGVfa2V5IiwiaW5zdGFuY2UiLCJwcm9wZXJ0eSIsInBhcmFtcyIsInJlY3Vyc2l2ZSIsImRlZmF1bHQiLCJlbWFpbCIsInN0cmVhbSIsImdldElkVG9rZW5DbGllbnQiLCJ0YXJnZXRBdWRpZW5jZSIsIklkVG9rZW5DbGllbnQiLCJpZFRva2VuUHJvdmlkZXIiLCJnZXRBY2Nlc3NUb2tlbiIsInRva2VuIiwiZ2V0UmVxdWVzdEhlYWRlcnMiLCJ1cmwiLCJhdXRob3JpemVSZXF1ZXN0IiwidXJpIiwiaGVhZGVycyIsImFzc2lnbiIsInJlcXVlc3QiLCJnZXRFbnYiLCJzaWduIiwiY3J5cHRvIiwiY3JlYXRlQ3J5cHRvIiwia2V5Iiwic2lnbkJsb2IiLCJlbWFpbE9yVW5pcXVlSWQiLCJyZXMiLCJtZXRob2QiLCJwYXlsb2FkIiwiZW5jb2RlQmFzZTY0U3RyaW5nVXRmOCIsInNpZ25lZEJsb2IiLCJEZWZhdWx0VHJhbnNwb3J0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/googleauth.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/iam.js":
/*!****************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/iam.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2014 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.IAMAuth = void 0;\nclass IAMAuth {\n    /**\n     * IAM credentials.\n     *\n     * @param selector the iam authority selector\n     * @param token the token\n     * @constructor\n     */ constructor(selector, token){\n        this.selector = selector;\n        this.token = token;\n        this.selector = selector;\n        this.token = token;\n    }\n    /**\n     * Acquire the HTTP headers required to make an authenticated request.\n     */ getRequestHeaders() {\n        return {\n            \"x-goog-iam-authority-selector\": this.selector,\n            \"x-goog-iam-authorization-token\": this.token\n        };\n    }\n}\nexports.IAMAuth = IAMAuth; //# sourceMappingURL=iam.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9pYW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxlQUFlLEdBQUcsS0FBSztBQUN2QixNQUFNRTtJQUNGOzs7Ozs7S0FNQyxHQUNEQyxZQUFZQyxRQUFRLEVBQUVDLEtBQUssQ0FBRTtRQUN6QixJQUFJLENBQUNELFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDRCxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtJQUNqQjtJQUNBOztLQUVDLEdBQ0RDLG9CQUFvQjtRQUNoQixPQUFPO1lBQ0gsaUNBQWlDLElBQUksQ0FBQ0YsUUFBUTtZQUM5QyxrQ0FBa0MsSUFBSSxDQUFDQyxLQUFLO1FBQ2hEO0lBQ0o7QUFDSjtBQUNBTCxlQUFlLEdBQUdFLFNBQ2xCLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2lhbS5qcz9iY2Y3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTQgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklBTUF1dGggPSB2b2lkIDA7XG5jbGFzcyBJQU1BdXRoIHtcbiAgICAvKipcbiAgICAgKiBJQU0gY3JlZGVudGlhbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VsZWN0b3IgdGhlIGlhbSBhdXRob3JpdHkgc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gdG9rZW4gdGhlIHRva2VuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2VsZWN0b3IsIHRva2VuKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNxdWlyZSB0aGUgSFRUUCBoZWFkZXJzIHJlcXVpcmVkIHRvIG1ha2UgYW4gYXV0aGVudGljYXRlZCByZXF1ZXN0LlxuICAgICAqL1xuICAgIGdldFJlcXVlc3RIZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3gtZ29vZy1pYW0tYXV0aG9yaXR5LXNlbGVjdG9yJzogdGhpcy5zZWxlY3RvcixcbiAgICAgICAgICAgICd4LWdvb2ctaWFtLWF1dGhvcml6YXRpb24tdG9rZW4nOiB0aGlzLnRva2VuLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuSUFNQXV0aCA9IElBTUF1dGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pYW0uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSUFNQXV0aCIsImNvbnN0cnVjdG9yIiwic2VsZWN0b3IiLCJ0b2tlbiIsImdldFJlcXVlc3RIZWFkZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/iam.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/identitypoolclient.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/identitypoolclient.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar _a, _b, _c;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.IdentityPoolClient = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\n// fs.readfile is undefined in browser karma tests causing\n// `npm run browser-test` to fail as test.oauth2.ts imports this file via\n// src/index.ts.\n// Fallback to void function to avoid promisify throwing a TypeError.\nconst readFile = (0, util_1.promisify)((_a = fs.readFile) !== null && _a !== void 0 ? _a : ()=>{});\nconst realpath = (0, util_1.promisify)((_b = fs.realpath) !== null && _b !== void 0 ? _b : ()=>{});\nconst lstat = (0, util_1.promisify)((_c = fs.lstat) !== null && _c !== void 0 ? _c : ()=>{});\n/**\n * Defines the Url-sourced and file-sourced external account clients mainly\n * used for K8s and Azure workloads.\n */ class IdentityPoolClient extends baseexternalclient_1.BaseExternalAccountClient {\n    /**\n     * Instantiate an IdentityPoolClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * An error is thrown if the credential is not a valid file-sourced or\n     * url-sourced credential or a workforce pool user project is provided\n     * with a non workforce audience.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     */ constructor(options, additionalOptions){\n        var _a, _b;\n        super(options, additionalOptions);\n        this.file = options.credential_source.file;\n        this.url = options.credential_source.url;\n        this.headers = options.credential_source.headers;\n        if (!this.file && !this.url) {\n            throw new Error('No valid Identity Pool \"credential_source\" provided');\n        }\n        // Text is the default format type.\n        this.formatType = ((_a = options.credential_source.format) === null || _a === void 0 ? void 0 : _a.type) || \"text\";\n        this.formatSubjectTokenFieldName = (_b = options.credential_source.format) === null || _b === void 0 ? void 0 : _b.subject_token_field_name;\n        if (this.formatType !== \"json\" && this.formatType !== \"text\") {\n            throw new Error(`Invalid credential_source format \"${this.formatType}\"`);\n        }\n        if (this.formatType === \"json\" && !this.formatSubjectTokenFieldName) {\n            throw new Error(\"Missing subject_token_field_name for JSON credential_source format\");\n        }\n    }\n    /**\n     * Triggered when a external subject token is needed to be exchanged for a GCP\n     * access token via GCP STS endpoint.\n     * This uses the `options.credential_source` object to figure out how\n     * to retrieve the token using the current environment. In this case,\n     * this either retrieves the local credential from a file location (k8s\n     * workload) or by sending a GET request to a local metadata server (Azure\n     * workloads).\n     * @return A promise that resolves with the external subject token.\n     */ async retrieveSubjectToken() {\n        if (this.file) {\n            return await this.getTokenFromFile(this.file, this.formatType, this.formatSubjectTokenFieldName);\n        }\n        return await this.getTokenFromUrl(this.url, this.formatType, this.formatSubjectTokenFieldName, this.headers);\n    }\n    /**\n     * Looks up the external subject token in the file path provided and\n     * resolves with that token.\n     * @param file The file path where the external credential is located.\n     * @param formatType The token file or URL response type (JSON or text).\n     * @param formatSubjectTokenFieldName For JSON response types, this is the\n     *   subject_token field name. For Azure, this is access_token. For text\n     *   response types, this is ignored.\n     * @return A promise that resolves with the external subject token.\n     */ async getTokenFromFile(filePath, formatType, formatSubjectTokenFieldName) {\n        // Make sure there is a file at the path. lstatSync will throw if there is\n        // nothing there.\n        try {\n            // Resolve path to actual file in case of symlink. Expect a thrown error\n            // if not resolvable.\n            filePath = await realpath(filePath);\n            if (!(await lstat(filePath)).isFile()) {\n                throw new Error();\n            }\n        } catch (err) {\n            if (err instanceof Error) {\n                err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n            }\n            throw err;\n        }\n        let subjectToken;\n        const rawText = await readFile(filePath, {\n            encoding: \"utf8\"\n        });\n        if (formatType === \"text\") {\n            subjectToken = rawText;\n        } else if (formatType === \"json\" && formatSubjectTokenFieldName) {\n            const json = JSON.parse(rawText);\n            subjectToken = json[formatSubjectTokenFieldName];\n        }\n        if (!subjectToken) {\n            throw new Error(\"Unable to parse the subject_token from the credential_source file\");\n        }\n        return subjectToken;\n    }\n    /**\n     * Sends a GET request to the URL provided and resolves with the returned\n     * external subject token.\n     * @param url The URL to call to retrieve the subject token. This is typically\n     *   a local metadata server.\n     * @param formatType The token file or URL response type (JSON or text).\n     * @param formatSubjectTokenFieldName For JSON response types, this is the\n     *   subject_token field name. For Azure, this is access_token. For text\n     *   response types, this is ignored.\n     * @param headers The optional additional headers to send with the request to\n     *   the metadata server url.\n     * @return A promise that resolves with the external subject token.\n     */ async getTokenFromUrl(url, formatType, formatSubjectTokenFieldName, headers) {\n        const opts = {\n            url,\n            method: \"GET\",\n            headers,\n            responseType: formatType\n        };\n        let subjectToken;\n        if (formatType === \"text\") {\n            const response = await this.transporter.request(opts);\n            subjectToken = response.data;\n        } else if (formatType === \"json\" && formatSubjectTokenFieldName) {\n            const response = await this.transporter.request(opts);\n            subjectToken = response.data[formatSubjectTokenFieldName];\n        }\n        if (!subjectToken) {\n            throw new Error(\"Unable to parse the subject_token from the credential_source URL\");\n        }\n        return subjectToken;\n    }\n}\nexports.IdentityPoolClient = IdentityPoolClient; //# sourceMappingURL=identitypoolclient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9pZGVudGl0eXBvb2xjbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakMsSUFBSUEsSUFBSUMsSUFBSUM7QUFDWkMsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDBCQUEwQixHQUFHLEtBQUs7QUFDbEMsTUFBTUcsS0FBS0MsbUJBQU9BLENBQUMsY0FBSTtBQUN2QixNQUFNQyxTQUFTRCxtQkFBT0EsQ0FBQyxrQkFBTTtBQUM3QixNQUFNRSx1QkFBdUJGLG1CQUFPQSxDQUFDLDJHQUFzQjtBQUMzRCwwREFBMEQ7QUFDMUQseUVBQXlFO0FBQ3pFLGdCQUFnQjtBQUNoQixxRUFBcUU7QUFDckUsTUFBTUcsV0FBVyxDQUFDLEdBQUdGLE9BQU9HLFNBQVMsRUFBRSxDQUFDYixLQUFLUSxHQUFHSSxRQUFRLE1BQU0sUUFBUVosT0FBTyxLQUFLLElBQUlBLEtBQU0sS0FBUTtBQUNwRyxNQUFNYyxXQUFXLENBQUMsR0FBR0osT0FBT0csU0FBUyxFQUFFLENBQUNaLEtBQUtPLEdBQUdNLFFBQVEsTUFBTSxRQUFRYixPQUFPLEtBQUssSUFBSUEsS0FBTSxLQUFRO0FBQ3BHLE1BQU1jLFFBQVEsQ0FBQyxHQUFHTCxPQUFPRyxTQUFTLEVBQUUsQ0FBQ1gsS0FBS00sR0FBR08sS0FBSyxNQUFNLFFBQVFiLE9BQU8sS0FBSyxJQUFJQSxLQUFNLEtBQVE7QUFDOUY7OztDQUdDLEdBQ0QsTUFBTUssMkJBQTJCSSxxQkFBcUJLLHlCQUF5QjtJQUMzRTs7Ozs7Ozs7Ozs7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QUFnQlYsR0FBRyxFQUFFRyxVQUFVLEVBQUVHLDJCQUEyQixFQUFFTCxPQUFPLEVBQUU7UUFDekUsTUFBTW9CLE9BQU87WUFDVHJCO1lBQ0FzQixRQUFRO1lBQ1JyQjtZQUNBc0IsY0FBY3BCO1FBQ2xCO1FBQ0EsSUFBSVk7UUFDSixJQUFJWixlQUFlLFFBQVE7WUFDdkIsTUFBTXFCLFdBQVcsTUFBTSxJQUFJLENBQUNDLFdBQVcsQ0FBQ0MsT0FBTyxDQUFDTDtZQUNoRE4sZUFBZVMsU0FBU0csSUFBSTtRQUNoQyxPQUNLLElBQUl4QixlQUFlLFVBQVVHLDZCQUE2QjtZQUMzRCxNQUFNa0IsV0FBVyxNQUFNLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxPQUFPLENBQUNMO1lBQ2hETixlQUFlUyxTQUFTRyxJQUFJLENBQUNyQiw0QkFBNEI7UUFDN0Q7UUFDQSxJQUFJLENBQUNTLGNBQWM7WUFDZixNQUFNLElBQUliLE1BQU07UUFDcEI7UUFDQSxPQUFPYTtJQUNYO0FBQ0o7QUFDQWhDLDBCQUEwQixHQUFHRSxvQkFDN0IsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvaWRlbnRpdHlwb29sY2xpZW50LmpzP2MzYWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfYSwgX2IsIF9jO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JZGVudGl0eVBvb2xDbGllbnQgPSB2b2lkIDA7XG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgYmFzZWV4dGVybmFsY2xpZW50XzEgPSByZXF1aXJlKFwiLi9iYXNlZXh0ZXJuYWxjbGllbnRcIik7XG4vLyBmcy5yZWFkZmlsZSBpcyB1bmRlZmluZWQgaW4gYnJvd3NlciBrYXJtYSB0ZXN0cyBjYXVzaW5nXG4vLyBgbnBtIHJ1biBicm93c2VyLXRlc3RgIHRvIGZhaWwgYXMgdGVzdC5vYXV0aDIudHMgaW1wb3J0cyB0aGlzIGZpbGUgdmlhXG4vLyBzcmMvaW5kZXgudHMuXG4vLyBGYWxsYmFjayB0byB2b2lkIGZ1bmN0aW9uIHRvIGF2b2lkIHByb21pc2lmeSB0aHJvd2luZyBhIFR5cGVFcnJvci5cbmNvbnN0IHJlYWRGaWxlID0gKDAsIHV0aWxfMS5wcm9taXNpZnkpKChfYSA9IGZzLnJlYWRGaWxlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoKCkgPT4geyB9KSk7XG5jb25zdCByZWFscGF0aCA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KSgoX2IgPSBmcy5yZWFscGF0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKCgpID0+IHsgfSkpO1xuY29uc3QgbHN0YXQgPSAoMCwgdXRpbF8xLnByb21pc2lmeSkoKF9jID0gZnMubHN0YXQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICgoKSA9PiB7IH0pKTtcbi8qKlxuICogRGVmaW5lcyB0aGUgVXJsLXNvdXJjZWQgYW5kIGZpbGUtc291cmNlZCBleHRlcm5hbCBhY2NvdW50IGNsaWVudHMgbWFpbmx5XG4gKiB1c2VkIGZvciBLOHMgYW5kIEF6dXJlIHdvcmtsb2Fkcy5cbiAqL1xuY2xhc3MgSWRlbnRpdHlQb29sQ2xpZW50IGV4dGVuZHMgYmFzZWV4dGVybmFsY2xpZW50XzEuQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYW4gSWRlbnRpdHlQb29sQ2xpZW50IGluc3RhbmNlIHVzaW5nIHRoZSBwcm92aWRlZCBKU09OXG4gICAgICogb2JqZWN0IGxvYWRlZCBmcm9tIGFuIGV4dGVybmFsIGFjY291bnQgY3JlZGVudGlhbHMgZmlsZS5cbiAgICAgKiBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIGNyZWRlbnRpYWwgaXMgbm90IGEgdmFsaWQgZmlsZS1zb3VyY2VkIG9yXG4gICAgICogdXJsLXNvdXJjZWQgY3JlZGVudGlhbCBvciBhIHdvcmtmb3JjZSBwb29sIHVzZXIgcHJvamVjdCBpcyBwcm92aWRlZFxuICAgICAqIHdpdGggYSBub24gd29ya2ZvcmNlIGF1ZGllbmNlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBleHRlcm5hbCBhY2NvdW50IG9wdGlvbnMgb2JqZWN0IHR5cGljYWxseSBsb2FkZWRcbiAgICAgKiAgIGZyb20gdGhlIGV4dGVybmFsIGFjY291bnQgSlNPTiBjcmVkZW50aWFsIGZpbGUuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxPcHRpb25zIE9wdGlvbmFsIGFkZGl0aW9uYWwgYmVoYXZpb3IgY3VzdG9taXphdGlvblxuICAgICAqICAgb3B0aW9ucy4gVGhlc2UgY3VycmVudGx5IGN1c3RvbWl6ZSBleHBpcmF0aW9uIHRocmVzaG9sZCB0aW1lIGFuZFxuICAgICAqICAgd2hldGhlciB0byByZXRyeSBvbiA0MDEvNDAzIEFQSSByZXF1ZXN0IGVycm9ycy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBzdXBlcihvcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZmlsZSA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UuZmlsZTtcbiAgICAgICAgdGhpcy51cmwgPSBvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLnVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gb3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS5oZWFkZXJzO1xuICAgICAgICBpZiAoIXRoaXMuZmlsZSAmJiAhdGhpcy51cmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgSWRlbnRpdHkgUG9vbCBcImNyZWRlbnRpYWxfc291cmNlXCIgcHJvdmlkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXh0IGlzIHRoZSBkZWZhdWx0IGZvcm1hdCB0eXBlLlxuICAgICAgICB0aGlzLmZvcm1hdFR5cGUgPSAoKF9hID0gb3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS5mb3JtYXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSB8fCAndGV4dCc7XG4gICAgICAgIHRoaXMuZm9ybWF0U3ViamVjdFRva2VuRmllbGROYW1lID1cbiAgICAgICAgICAgIChfYiA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UuZm9ybWF0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3ViamVjdF90b2tlbl9maWVsZF9uYW1lO1xuICAgICAgICBpZiAodGhpcy5mb3JtYXRUeXBlICE9PSAnanNvbicgJiYgdGhpcy5mb3JtYXRUeXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjcmVkZW50aWFsX3NvdXJjZSBmb3JtYXQgXCIke3RoaXMuZm9ybWF0VHlwZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZvcm1hdFR5cGUgPT09ICdqc29uJyAmJiAhdGhpcy5mb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBzdWJqZWN0X3Rva2VuX2ZpZWxkX25hbWUgZm9yIEpTT04gY3JlZGVudGlhbF9zb3VyY2UgZm9ybWF0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYSBleHRlcm5hbCBzdWJqZWN0IHRva2VuIGlzIG5lZWRlZCB0byBiZSBleGNoYW5nZWQgZm9yIGEgR0NQXG4gICAgICogYWNjZXNzIHRva2VuIHZpYSBHQ1AgU1RTIGVuZHBvaW50LlxuICAgICAqIFRoaXMgdXNlcyB0aGUgYG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2VgIG9iamVjdCB0byBmaWd1cmUgb3V0IGhvd1xuICAgICAqIHRvIHJldHJpZXZlIHRoZSB0b2tlbiB1c2luZyB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gSW4gdGhpcyBjYXNlLFxuICAgICAqIHRoaXMgZWl0aGVyIHJldHJpZXZlcyB0aGUgbG9jYWwgY3JlZGVudGlhbCBmcm9tIGEgZmlsZSBsb2NhdGlvbiAoazhzXG4gICAgICogd29ya2xvYWQpIG9yIGJ5IHNlbmRpbmcgYSBHRVQgcmVxdWVzdCB0byBhIGxvY2FsIG1ldGFkYXRhIHNlcnZlciAoQXp1cmVcbiAgICAgKiB3b3JrbG9hZHMpLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZXh0ZXJuYWwgc3ViamVjdCB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyByZXRyaWV2ZVN1YmplY3RUb2tlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0VG9rZW5Gcm9tRmlsZSh0aGlzLmZpbGUsIHRoaXMuZm9ybWF0VHlwZSwgdGhpcy5mb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFRva2VuRnJvbVVybCh0aGlzLnVybCwgdGhpcy5mb3JtYXRUeXBlLCB0aGlzLmZvcm1hdFN1YmplY3RUb2tlbkZpZWxkTmFtZSwgdGhpcy5oZWFkZXJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9va3MgdXAgdGhlIGV4dGVybmFsIHN1YmplY3QgdG9rZW4gaW4gdGhlIGZpbGUgcGF0aCBwcm92aWRlZCBhbmRcbiAgICAgKiByZXNvbHZlcyB3aXRoIHRoYXQgdG9rZW4uXG4gICAgICogQHBhcmFtIGZpbGUgVGhlIGZpbGUgcGF0aCB3aGVyZSB0aGUgZXh0ZXJuYWwgY3JlZGVudGlhbCBpcyBsb2NhdGVkLlxuICAgICAqIEBwYXJhbSBmb3JtYXRUeXBlIFRoZSB0b2tlbiBmaWxlIG9yIFVSTCByZXNwb25zZSB0eXBlIChKU09OIG9yIHRleHQpLlxuICAgICAqIEBwYXJhbSBmb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWUgRm9yIEpTT04gcmVzcG9uc2UgdHlwZXMsIHRoaXMgaXMgdGhlXG4gICAgICogICBzdWJqZWN0X3Rva2VuIGZpZWxkIG5hbWUuIEZvciBBenVyZSwgdGhpcyBpcyBhY2Nlc3NfdG9rZW4uIEZvciB0ZXh0XG4gICAgICogICByZXNwb25zZSB0eXBlcywgdGhpcyBpcyBpZ25vcmVkLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZXh0ZXJuYWwgc3ViamVjdCB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUb2tlbkZyb21GaWxlKGZpbGVQYXRoLCBmb3JtYXRUeXBlLCBmb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWUpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZXJlIGlzIGEgZmlsZSBhdCB0aGUgcGF0aC4gbHN0YXRTeW5jIHdpbGwgdGhyb3cgaWYgdGhlcmUgaXNcbiAgICAgICAgLy8gbm90aGluZyB0aGVyZS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFJlc29sdmUgcGF0aCB0byBhY3R1YWwgZmlsZSBpbiBjYXNlIG9mIHN5bWxpbmsuIEV4cGVjdCBhIHRocm93biBlcnJvclxuICAgICAgICAgICAgLy8gaWYgbm90IHJlc29sdmFibGUuXG4gICAgICAgICAgICBmaWxlUGF0aCA9IGF3YWl0IHJlYWxwYXRoKGZpbGVQYXRoKTtcbiAgICAgICAgICAgIGlmICghKGF3YWl0IGxzdGF0KGZpbGVQYXRoKSkuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGBUaGUgZmlsZSBhdCAke2ZpbGVQYXRofSBkb2VzIG5vdCBleGlzdCwgb3IgaXQgaXMgbm90IGEgZmlsZS4gJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJqZWN0VG9rZW47XG4gICAgICAgIGNvbnN0IHJhd1RleHQgPSBhd2FpdCByZWFkRmlsZShmaWxlUGF0aCwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pO1xuICAgICAgICBpZiAoZm9ybWF0VHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBzdWJqZWN0VG9rZW4gPSByYXdUZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvcm1hdFR5cGUgPT09ICdqc29uJyAmJiBmb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKHJhd1RleHQpO1xuICAgICAgICAgICAgc3ViamVjdFRva2VuID0ganNvbltmb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3ViamVjdFRva2VuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSB0aGUgc3ViamVjdF90b2tlbiBmcm9tIHRoZSBjcmVkZW50aWFsX3NvdXJjZSBmaWxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YmplY3RUb2tlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBHRVQgcmVxdWVzdCB0byB0aGUgVVJMIHByb3ZpZGVkIGFuZCByZXNvbHZlcyB3aXRoIHRoZSByZXR1cm5lZFxuICAgICAqIGV4dGVybmFsIHN1YmplY3QgdG9rZW4uXG4gICAgICogQHBhcmFtIHVybCBUaGUgVVJMIHRvIGNhbGwgdG8gcmV0cmlldmUgdGhlIHN1YmplY3QgdG9rZW4uIFRoaXMgaXMgdHlwaWNhbGx5XG4gICAgICogICBhIGxvY2FsIG1ldGFkYXRhIHNlcnZlci5cbiAgICAgKiBAcGFyYW0gZm9ybWF0VHlwZSBUaGUgdG9rZW4gZmlsZSBvciBVUkwgcmVzcG9uc2UgdHlwZSAoSlNPTiBvciB0ZXh0KS5cbiAgICAgKiBAcGFyYW0gZm9ybWF0U3ViamVjdFRva2VuRmllbGROYW1lIEZvciBKU09OIHJlc3BvbnNlIHR5cGVzLCB0aGlzIGlzIHRoZVxuICAgICAqICAgc3ViamVjdF90b2tlbiBmaWVsZCBuYW1lLiBGb3IgQXp1cmUsIHRoaXMgaXMgYWNjZXNzX3Rva2VuLiBGb3IgdGV4dFxuICAgICAqICAgcmVzcG9uc2UgdHlwZXMsIHRoaXMgaXMgaWdub3JlZC5cbiAgICAgKiBAcGFyYW0gaGVhZGVycyBUaGUgb3B0aW9uYWwgYWRkaXRpb25hbCBoZWFkZXJzIHRvIHNlbmQgd2l0aCB0aGUgcmVxdWVzdCB0b1xuICAgICAqICAgdGhlIG1ldGFkYXRhIHNlcnZlciB1cmwuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBleHRlcm5hbCBzdWJqZWN0IHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRva2VuRnJvbVVybCh1cmwsIGZvcm1hdFR5cGUsIGZvcm1hdFN1YmplY3RUb2tlbkZpZWxkTmFtZSwgaGVhZGVycykge1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6IGZvcm1hdFR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBzdWJqZWN0VG9rZW47XG4gICAgICAgIGlmIChmb3JtYXRUeXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICAgICAgc3ViamVjdFRva2VuID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb3JtYXRUeXBlID09PSAnanNvbicgJiYgZm9ybWF0U3ViamVjdFRva2VuRmllbGROYW1lKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgICAgIHN1YmplY3RUb2tlbiA9IHJlc3BvbnNlLmRhdGFbZm9ybWF0U3ViamVjdFRva2VuRmllbGROYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN1YmplY3RUb2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgdGhlIHN1YmplY3RfdG9rZW4gZnJvbSB0aGUgY3JlZGVudGlhbF9zb3VyY2UgVVJMJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YmplY3RUb2tlbjtcbiAgICB9XG59XG5leHBvcnRzLklkZW50aXR5UG9vbENsaWVudCA9IElkZW50aXR5UG9vbENsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkZW50aXR5cG9vbGNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiX2EiLCJfYiIsIl9jIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJJZGVudGl0eVBvb2xDbGllbnQiLCJmcyIsInJlcXVpcmUiLCJ1dGlsXzEiLCJiYXNlZXh0ZXJuYWxjbGllbnRfMSIsInJlYWRGaWxlIiwicHJvbWlzaWZ5IiwicmVhbHBhdGgiLCJsc3RhdCIsIkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJhZGRpdGlvbmFsT3B0aW9ucyIsImZpbGUiLCJjcmVkZW50aWFsX3NvdXJjZSIsInVybCIsImhlYWRlcnMiLCJFcnJvciIsImZvcm1hdFR5cGUiLCJmb3JtYXQiLCJ0eXBlIiwiZm9ybWF0U3ViamVjdFRva2VuRmllbGROYW1lIiwic3ViamVjdF90b2tlbl9maWVsZF9uYW1lIiwicmV0cmlldmVTdWJqZWN0VG9rZW4iLCJnZXRUb2tlbkZyb21GaWxlIiwiZ2V0VG9rZW5Gcm9tVXJsIiwiZmlsZVBhdGgiLCJpc0ZpbGUiLCJlcnIiLCJtZXNzYWdlIiwic3ViamVjdFRva2VuIiwicmF3VGV4dCIsImVuY29kaW5nIiwianNvbiIsIkpTT04iLCJwYXJzZSIsIm9wdHMiLCJtZXRob2QiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZSIsInRyYW5zcG9ydGVyIiwicmVxdWVzdCIsImRhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/identitypoolclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/idtokenclient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/idtokenclient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.IdTokenClient = void 0;\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nclass IdTokenClient extends oauth2client_1.OAuth2Client {\n    /**\n     * Google ID Token client\n     *\n     * Retrieve access token from the metadata server.\n     * See: https://developers.google.com/compute/docs/authentication\n     */ constructor(options){\n        super();\n        this.targetAudience = options.targetAudience;\n        this.idTokenProvider = options.idTokenProvider;\n    }\n    async getRequestMetadataAsync(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n    url) {\n        if (!this.credentials.id_token || !this.credentials.expiry_date || this.isTokenExpiring()) {\n            const idToken = await this.idTokenProvider.fetchIdToken(this.targetAudience);\n            this.credentials = {\n                id_token: idToken,\n                expiry_date: this.getIdTokenExpiryDate(idToken)\n            };\n        }\n        const headers = {\n            Authorization: \"Bearer \" + this.credentials.id_token\n        };\n        return {\n            headers\n        };\n    }\n    getIdTokenExpiryDate(idToken) {\n        const payloadB64 = idToken.split(\".\")[1];\n        if (payloadB64) {\n            const payload = JSON.parse(Buffer.from(payloadB64, \"base64\").toString(\"ascii\"));\n            return payload.exp * 1000;\n        }\n    }\n}\nexports.IdTokenClient = IdTokenClient; //# sourceMappingURL=idtokenclient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9pZHRva2VuY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQscUJBQXFCLEdBQUcsS0FBSztBQUM3QixNQUFNRyxpQkFBaUJDLG1CQUFPQSxDQUFDLCtGQUFnQjtBQUMvQyxNQUFNRixzQkFBc0JDLGVBQWVFLFlBQVk7SUFDbkQ7Ozs7O0tBS0MsR0FDREMsWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUs7UUFDTCxJQUFJLENBQUNDLGNBQWMsR0FBR0QsUUFBUUMsY0FBYztRQUM1QyxJQUFJLENBQUNDLGVBQWUsR0FBR0YsUUFBUUUsZUFBZTtJQUNsRDtJQUNBLE1BQU1DLHdCQUNOLDZEQUE2RDtJQUM3REMsR0FBRyxFQUFFO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxRQUFRLElBQzFCLENBQUMsSUFBSSxDQUFDRCxXQUFXLENBQUNFLFdBQVcsSUFDN0IsSUFBSSxDQUFDQyxlQUFlLElBQUk7WUFDeEIsTUFBTUMsVUFBVSxNQUFNLElBQUksQ0FBQ1AsZUFBZSxDQUFDUSxZQUFZLENBQUMsSUFBSSxDQUFDVCxjQUFjO1lBQzNFLElBQUksQ0FBQ0ksV0FBVyxHQUFHO2dCQUNmQyxVQUFVRztnQkFDVkYsYUFBYSxJQUFJLENBQUNJLG9CQUFvQixDQUFDRjtZQUMzQztRQUNKO1FBQ0EsTUFBTUcsVUFBVTtZQUNaQyxlQUFlLFlBQVksSUFBSSxDQUFDUixXQUFXLENBQUNDLFFBQVE7UUFDeEQ7UUFDQSxPQUFPO1lBQUVNO1FBQVE7SUFDckI7SUFDQUQscUJBQXFCRixPQUFPLEVBQUU7UUFDMUIsTUFBTUssYUFBYUwsUUFBUU0sS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQ3hDLElBQUlELFlBQVk7WUFDWixNQUFNRSxVQUFVQyxLQUFLQyxLQUFLLENBQUNDLE9BQU9DLElBQUksQ0FBQ04sWUFBWSxVQUFVTyxRQUFRLENBQUM7WUFDdEUsT0FBT0wsUUFBUU0sR0FBRyxHQUFHO1FBQ3pCO0lBQ0o7QUFDSjtBQUNBN0IscUJBQXFCLEdBQUdFLGVBQ3hCLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2lkdG9rZW5jbGllbnQuanM/MmIzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JZFRva2VuQ2xpZW50ID0gdm9pZCAwO1xuY29uc3Qgb2F1dGgyY2xpZW50XzEgPSByZXF1aXJlKFwiLi9vYXV0aDJjbGllbnRcIik7XG5jbGFzcyBJZFRva2VuQ2xpZW50IGV4dGVuZHMgb2F1dGgyY2xpZW50XzEuT0F1dGgyQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBHb29nbGUgSUQgVG9rZW4gY2xpZW50XG4gICAgICpcbiAgICAgKiBSZXRyaWV2ZSBhY2Nlc3MgdG9rZW4gZnJvbSB0aGUgbWV0YWRhdGEgc2VydmVyLlxuICAgICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vY29tcHV0ZS9kb2NzL2F1dGhlbnRpY2F0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRhcmdldEF1ZGllbmNlID0gb3B0aW9ucy50YXJnZXRBdWRpZW5jZTtcbiAgICAgICAgdGhpcy5pZFRva2VuUHJvdmlkZXIgPSBvcHRpb25zLmlkVG9rZW5Qcm92aWRlcjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UmVxdWVzdE1ldGFkYXRhQXN5bmMoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHVybCkge1xuICAgICAgICBpZiAoIXRoaXMuY3JlZGVudGlhbHMuaWRfdG9rZW4gfHxcbiAgICAgICAgICAgICF0aGlzLmNyZWRlbnRpYWxzLmV4cGlyeV9kYXRlIHx8XG4gICAgICAgICAgICB0aGlzLmlzVG9rZW5FeHBpcmluZygpKSB7XG4gICAgICAgICAgICBjb25zdCBpZFRva2VuID0gYXdhaXQgdGhpcy5pZFRva2VuUHJvdmlkZXIuZmV0Y2hJZFRva2VuKHRoaXMudGFyZ2V0QXVkaWVuY2UpO1xuICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHtcbiAgICAgICAgICAgICAgICBpZF90b2tlbjogaWRUb2tlbixcbiAgICAgICAgICAgICAgICBleHBpcnlfZGF0ZTogdGhpcy5nZXRJZFRva2VuRXhwaXJ5RGF0ZShpZFRva2VuKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb246ICdCZWFyZXIgJyArIHRoaXMuY3JlZGVudGlhbHMuaWRfdG9rZW4sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGhlYWRlcnMgfTtcbiAgICB9XG4gICAgZ2V0SWRUb2tlbkV4cGlyeURhdGUoaWRUb2tlbikge1xuICAgICAgICBjb25zdCBwYXlsb2FkQjY0ID0gaWRUb2tlbi5zcGxpdCgnLicpWzFdO1xuICAgICAgICBpZiAocGF5bG9hZEI2NCkge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoQnVmZmVyLmZyb20ocGF5bG9hZEI2NCwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdhc2NpaScpKTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkLmV4cCAqIDEwMDA7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLklkVG9rZW5DbGllbnQgPSBJZFRva2VuQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWR0b2tlbmNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJJZFRva2VuQ2xpZW50Iiwib2F1dGgyY2xpZW50XzEiLCJyZXF1aXJlIiwiT0F1dGgyQ2xpZW50IiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwidGFyZ2V0QXVkaWVuY2UiLCJpZFRva2VuUHJvdmlkZXIiLCJnZXRSZXF1ZXN0TWV0YWRhdGFBc3luYyIsInVybCIsImNyZWRlbnRpYWxzIiwiaWRfdG9rZW4iLCJleHBpcnlfZGF0ZSIsImlzVG9rZW5FeHBpcmluZyIsImlkVG9rZW4iLCJmZXRjaElkVG9rZW4iLCJnZXRJZFRva2VuRXhwaXJ5RGF0ZSIsImhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwicGF5bG9hZEI2NCIsInNwbGl0IiwicGF5bG9hZCIsIkpTT04iLCJwYXJzZSIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsImV4cCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/idtokenclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/impersonated.js":
/*!*************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/impersonated.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Impersonated = exports.IMPERSONATED_ACCOUNT_TYPE = void 0;\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nexports.IMPERSONATED_ACCOUNT_TYPE = \"impersonated_service_account\";\nclass Impersonated extends oauth2client_1.OAuth2Client {\n    /**\n     * Impersonated service account credentials.\n     *\n     * Create a new access token by impersonating another service account.\n     *\n     * Impersonated Credentials allowing credentials issued to a user or\n     * service account to impersonate another. The source project using\n     * Impersonated Credentials must enable the \"IAMCredentials\" API.\n     * Also, the target service account must grant the orginating principal\n     * the \"Service Account Token Creator\" IAM role.\n     *\n     * @param {object} options - The configuration object.\n     * @param {object} [options.sourceClient] the source credential used as to\n     * acquire the impersonated credentials.\n     * @param {string} [options.targetPrincipal] the service account to\n     * impersonate.\n     * @param {string[]} [options.delegates] the chained list of delegates\n     * required to grant the final access_token. If set, the sequence of\n     * identities must have \"Service Account Token Creator\" capability granted to\n     * the preceding identity. For example, if set to [serviceAccountB,\n     * serviceAccountC], the sourceCredential must have the Token Creator role on\n     * serviceAccountB. serviceAccountB must have the Token Creator on\n     * serviceAccountC. Finally, C must have Token Creator on target_principal.\n     * If left unset, sourceCredential must have that role on targetPrincipal.\n     * @param {string[]} [options.targetScopes] scopes to request during the\n     * authorization grant.\n     * @param {number} [options.lifetime] number of seconds the delegated\n     * credential should be valid for up to 3600 seconds by default, or 43,200\n     * seconds by extending the token's lifetime, see:\n     * https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials#sa-credentials-oauth\n     * @param {string} [options.endpoint] api endpoint override.\n     */ constructor(options = {}){\n        var _a, _b, _c, _d, _e, _f;\n        super(options);\n        this.credentials = {\n            expiry_date: 1,\n            refresh_token: \"impersonated-placeholder\"\n        };\n        this.sourceClient = (_a = options.sourceClient) !== null && _a !== void 0 ? _a : new oauth2client_1.OAuth2Client();\n        this.targetPrincipal = (_b = options.targetPrincipal) !== null && _b !== void 0 ? _b : \"\";\n        this.delegates = (_c = options.delegates) !== null && _c !== void 0 ? _c : [];\n        this.targetScopes = (_d = options.targetScopes) !== null && _d !== void 0 ? _d : [];\n        this.lifetime = (_e = options.lifetime) !== null && _e !== void 0 ? _e : 3600;\n        this.endpoint = (_f = options.endpoint) !== null && _f !== void 0 ? _f : \"https://iamcredentials.googleapis.com\";\n    }\n    /**\n     * Refreshes the access token.\n     * @param refreshToken Unused parameter\n     */ async refreshToken(refreshToken) {\n        var _a, _b, _c, _d, _e, _f;\n        try {\n            await this.sourceClient.getAccessToken();\n            const name = \"projects/-/serviceAccounts/\" + this.targetPrincipal;\n            const u = `${this.endpoint}/v1/${name}:generateAccessToken`;\n            const body = {\n                delegates: this.delegates,\n                scope: this.targetScopes,\n                lifetime: this.lifetime + \"s\"\n            };\n            const res = await this.sourceClient.request({\n                url: u,\n                data: body,\n                method: \"POST\"\n            });\n            const tokenResponse = res.data;\n            this.credentials.access_token = tokenResponse.accessToken;\n            this.credentials.expiry_date = Date.parse(tokenResponse.expireTime);\n            return {\n                tokens: this.credentials,\n                res\n            };\n        } catch (error) {\n            if (!(error instanceof Error)) throw error;\n            let status = 0;\n            let message = \"\";\n            if (error instanceof gaxios_1.GaxiosError) {\n                status = (_c = (_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.status;\n                message = (_f = (_e = (_d = error === null || error === void 0 ? void 0 : error.response) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.error) === null || _f === void 0 ? void 0 : _f.message;\n            }\n            if (status && message) {\n                error.message = `${status}: unable to impersonate: ${message}`;\n                throw error;\n            } else {\n                error.message = `unable to impersonate: ${error}`;\n                throw error;\n            }\n        }\n    }\n    /**\n     * Generates an OpenID Connect ID token for a service account.\n     *\n     * {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateIdToken Reference Documentation}\n     *\n     * @param targetAudience the audience for the fetched ID token.\n     * @param options the for the request\n     * @return an OpenID Connect ID token\n     */ async fetchIdToken(targetAudience, options) {\n        var _a;\n        await this.sourceClient.getAccessToken();\n        const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;\n        const u = `${this.endpoint}/v1/${name}:generateIdToken`;\n        const body = {\n            delegates: this.delegates,\n            audience: targetAudience,\n            includeEmail: (_a = options === null || options === void 0 ? void 0 : options.includeEmail) !== null && _a !== void 0 ? _a : true\n        };\n        const res = await this.sourceClient.request({\n            url: u,\n            data: body,\n            method: \"POST\"\n        });\n        return res.data.token;\n    }\n}\nexports.Impersonated = Impersonated; //# sourceMappingURL=impersonated.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9pbXBlcnNvbmF0ZWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsb0JBQW9CLEdBQUdBLGlDQUFpQyxHQUFHLEtBQUs7QUFDaEUsTUFBTUksaUJBQWlCQyxtQkFBT0EsQ0FBQywrRkFBZ0I7QUFDL0MsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsOERBQVE7QUFDakNMLGlDQUFpQyxHQUFHO0FBQ3BDLE1BQU1FLHFCQUFxQkUsZUFBZUcsWUFBWTtJQUNsRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQStCQyxHQUNEQyxZQUFZQyxVQUFVLENBQUMsQ0FBQyxDQUFFO1FBQ3RCLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDO1FBQ3hCLEtBQUssQ0FBQ047UUFDTixJQUFJLENBQUNPLFdBQVcsR0FBRztZQUNmQyxhQUFhO1lBQ2JDLGVBQWU7UUFDbkI7UUFDQSxJQUFJLENBQUNDLFlBQVksR0FBRyxDQUFDVCxLQUFLRCxRQUFRVSxZQUFZLE1BQU0sUUFBUVQsT0FBTyxLQUFLLElBQUlBLEtBQUssSUFBSU4sZUFBZUcsWUFBWTtRQUNoSCxJQUFJLENBQUNhLGVBQWUsR0FBRyxDQUFDVCxLQUFLRixRQUFRVyxlQUFlLE1BQU0sUUFBUVQsT0FBTyxLQUFLLElBQUlBLEtBQUs7UUFDdkYsSUFBSSxDQUFDVSxTQUFTLEdBQUcsQ0FBQ1QsS0FBS0gsUUFBUVksU0FBUyxNQUFNLFFBQVFULE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUU7UUFDN0UsSUFBSSxDQUFDVSxZQUFZLEdBQUcsQ0FBQ1QsS0FBS0osUUFBUWEsWUFBWSxNQUFNLFFBQVFULE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUU7UUFDbkYsSUFBSSxDQUFDVSxRQUFRLEdB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LE1BQU1RLElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQ0osUUFBUSxDQUFDLElBQUksRUFBRUcsS0FBSyxnQkFBZ0IsQ0FBQztRQUN2RCxNQUFNRSxPQUFPO1lBQ1RSLFdBQVcsSUFBSSxDQUFDQSxTQUFTO1lBQ3pCOEIsVUFBVUQ7WUFDVkUsY0FBYyxDQUFDMUMsS0FBS0QsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVEyQyxZQUFZLE1BQU0sUUFBUTFDLE9BQU8sS0FBSyxJQUFJQSxLQUFLO1FBQ2pJO1FBQ0EsTUFBTXFCLE1BQU0sTUFBTSxJQUFJLENBQUNaLFlBQVksQ0FBQ2EsT0FBTyxDQUFDO1lBQ3hDQyxLQUFLTDtZQUNMTSxNQUFNTDtZQUNOTSxRQUFRO1FBQ1o7UUFDQSxPQUFPSixJQUFJRyxJQUFJLENBQUNtQixLQUFLO0lBQ3pCO0FBQ0o7QUFDQXJELG9CQUFvQixHQUFHRSxjQUN2Qix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9pbXBlcnNvbmF0ZWQuanM/NWM5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW1wZXJzb25hdGVkID0gZXhwb3J0cy5JTVBFUlNPTkFURURfQUNDT1VOVF9UWVBFID0gdm9pZCAwO1xuY29uc3Qgb2F1dGgyY2xpZW50XzEgPSByZXF1aXJlKFwiLi9vYXV0aDJjbGllbnRcIik7XG5jb25zdCBnYXhpb3NfMSA9IHJlcXVpcmUoXCJnYXhpb3NcIik7XG5leHBvcnRzLklNUEVSU09OQVRFRF9BQ0NPVU5UX1RZUEUgPSAnaW1wZXJzb25hdGVkX3NlcnZpY2VfYWNjb3VudCc7XG5jbGFzcyBJbXBlcnNvbmF0ZWQgZXh0ZW5kcyBvYXV0aDJjbGllbnRfMS5PQXV0aDJDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEltcGVyc29uYXRlZCBzZXJ2aWNlIGFjY291bnQgY3JlZGVudGlhbHMuXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgYWNjZXNzIHRva2VuIGJ5IGltcGVyc29uYXRpbmcgYW5vdGhlciBzZXJ2aWNlIGFjY291bnQuXG4gICAgICpcbiAgICAgKiBJbXBlcnNvbmF0ZWQgQ3JlZGVudGlhbHMgYWxsb3dpbmcgY3JlZGVudGlhbHMgaXNzdWVkIHRvIGEgdXNlciBvclxuICAgICAqIHNlcnZpY2UgYWNjb3VudCB0byBpbXBlcnNvbmF0ZSBhbm90aGVyLiBUaGUgc291cmNlIHByb2plY3QgdXNpbmdcbiAgICAgKiBJbXBlcnNvbmF0ZWQgQ3JlZGVudGlhbHMgbXVzdCBlbmFibGUgdGhlIFwiSUFNQ3JlZGVudGlhbHNcIiBBUEkuXG4gICAgICogQWxzbywgdGhlIHRhcmdldCBzZXJ2aWNlIGFjY291bnQgbXVzdCBncmFudCB0aGUgb3JnaW5hdGluZyBwcmluY2lwYWxcbiAgICAgKiB0aGUgXCJTZXJ2aWNlIEFjY291bnQgVG9rZW4gQ3JlYXRvclwiIElBTSByb2xlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnNvdXJjZUNsaWVudF0gdGhlIHNvdXJjZSBjcmVkZW50aWFsIHVzZWQgYXMgdG9cbiAgICAgKiBhY3F1aXJlIHRoZSBpbXBlcnNvbmF0ZWQgY3JlZGVudGlhbHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRhcmdldFByaW5jaXBhbF0gdGhlIHNlcnZpY2UgYWNjb3VudCB0b1xuICAgICAqIGltcGVyc29uYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRpb25zLmRlbGVnYXRlc10gdGhlIGNoYWluZWQgbGlzdCBvZiBkZWxlZ2F0ZXNcbiAgICAgKiByZXF1aXJlZCB0byBncmFudCB0aGUgZmluYWwgYWNjZXNzX3Rva2VuLiBJZiBzZXQsIHRoZSBzZXF1ZW5jZSBvZlxuICAgICAqIGlkZW50aXRpZXMgbXVzdCBoYXZlIFwiU2VydmljZSBBY2NvdW50IFRva2VuIENyZWF0b3JcIiBjYXBhYmlsaXR5IGdyYW50ZWQgdG9cbiAgICAgKiB0aGUgcHJlY2VkaW5nIGlkZW50aXR5LiBGb3IgZXhhbXBsZSwgaWYgc2V0IHRvIFtzZXJ2aWNlQWNjb3VudEIsXG4gICAgICogc2VydmljZUFjY291bnRDXSwgdGhlIHNvdXJjZUNyZWRlbnRpYWwgbXVzdCBoYXZlIHRoZSBUb2tlbiBDcmVhdG9yIHJvbGUgb25cbiAgICAgKiBzZXJ2aWNlQWNjb3VudEIuIHNlcnZpY2VBY2NvdW50QiBtdXN0IGhhdmUgdGhlIFRva2VuIENyZWF0b3Igb25cbiAgICAgKiBzZXJ2aWNlQWNjb3VudEMuIEZpbmFsbHksIEMgbXVzdCBoYXZlIFRva2VuIENyZWF0b3Igb24gdGFyZ2V0X3ByaW5jaXBhbC5cbiAgICAgKiBJZiBsZWZ0IHVuc2V0LCBzb3VyY2VDcmVkZW50aWFsIG11c3QgaGF2ZSB0aGF0IHJvbGUgb24gdGFyZ2V0UHJpbmNpcGFsLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRpb25zLnRhcmdldFNjb3Blc10gc2NvcGVzIHRvIHJlcXVlc3QgZHVyaW5nIHRoZVxuICAgICAqIGF1dGhvcml6YXRpb24gZ3JhbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxpZmV0aW1lXSBudW1iZXIgb2Ygc2Vjb25kcyB0aGUgZGVsZWdhdGVkXG4gICAgICogY3JlZGVudGlhbCBzaG91bGQgYmUgdmFsaWQgZm9yIHVwIHRvIDM2MDAgc2Vjb25kcyBieSBkZWZhdWx0LCBvciA0MywyMDBcbiAgICAgKiBzZWNvbmRzIGJ5IGV4dGVuZGluZyB0aGUgdG9rZW4ncyBsaWZldGltZSwgc2VlOlxuICAgICAqIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9pYW0vZG9jcy9jcmVhdGluZy1zaG9ydC1saXZlZC1zZXJ2aWNlLWFjY291bnQtY3JlZGVudGlhbHMjc2EtY3JlZGVudGlhbHMtb2F1dGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5kcG9pbnRdIGFwaSBlbmRwb2ludCBvdmVycmlkZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0ge1xuICAgICAgICAgICAgZXhwaXJ5X2RhdGU6IDEsXG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuOiAnaW1wZXJzb25hdGVkLXBsYWNlaG9sZGVyJyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb3VyY2VDbGllbnQgPSAoX2EgPSBvcHRpb25zLnNvdXJjZUNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IG9hdXRoMmNsaWVudF8xLk9BdXRoMkNsaWVudCgpO1xuICAgICAgICB0aGlzLnRhcmdldFByaW5jaXBhbCA9IChfYiA9IG9wdGlvbnMudGFyZ2V0UHJpbmNpcGFsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZXMgPSAoX2MgPSBvcHRpb25zLmRlbGVnYXRlcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW107XG4gICAgICAgIHRoaXMudGFyZ2V0U2NvcGVzID0gKF9kID0gb3B0aW9ucy50YXJnZXRTY29wZXMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFtdO1xuICAgICAgICB0aGlzLmxpZmV0aW1lID0gKF9lID0gb3B0aW9ucy5saWZldGltZSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogMzYwMDtcbiAgICAgICAgdGhpcy5lbmRwb2ludCA9IChfZiA9IG9wdGlvbnMuZW5kcG9pbnQpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6ICdodHRwczovL2lhbWNyZWRlbnRpYWxzLmdvb2dsZWFwaXMuY29tJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBVbnVzZWQgcGFyYW1ldGVyXG4gICAgICovXG4gICAgYXN5bmMgcmVmcmVzaFRva2VuKHJlZnJlc2hUb2tlbikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc291cmNlQ2xpZW50LmdldEFjY2Vzc1Rva2VuKCk7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gJ3Byb2plY3RzLy0vc2VydmljZUFjY291bnRzLycgKyB0aGlzLnRhcmdldFByaW5jaXBhbDtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBgJHt0aGlzLmVuZHBvaW50fS92MS8ke25hbWV9OmdlbmVyYXRlQWNjZXNzVG9rZW5gO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZXM6IHRoaXMuZGVsZWdhdGVzLFxuICAgICAgICAgICAgICAgIHNjb3BlOiB0aGlzLnRhcmdldFNjb3BlcyxcbiAgICAgICAgICAgICAgICBsaWZldGltZTogdGhpcy5saWZldGltZSArICdzJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnNvdXJjZUNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB1cmw6IHUsXG4gICAgICAgICAgICAgICAgZGF0YTogYm9keSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5SZXNwb25zZSA9IHJlcy5kYXRhO1xuICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFscy5hY2Nlc3NfdG9rZW4gPSB0b2tlblJlc3BvbnNlLmFjY2Vzc1Rva2VuO1xuICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFscy5leHBpcnlfZGF0ZSA9IERhdGUucGFyc2UodG9rZW5SZXNwb25zZS5leHBpcmVUaW1lKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmNyZWRlbnRpYWxzLFxuICAgICAgICAgICAgICAgIHJlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGxldCBzdGF0dXMgPSAwO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGdheGlvc18xLkdheGlvc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gKF9jID0gKF9iID0gKF9hID0gZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLnJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVycm9yKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc3RhdHVzO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSAoX2YgPSAoX2UgPSAoX2QgPSBlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IucmVzcG9uc2UpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5kYXRhKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuZXJyb3IpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXR1cyAmJiBtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGAke3N0YXR1c306IHVuYWJsZSB0byBpbXBlcnNvbmF0ZTogJHttZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gYHVuYWJsZSB0byBpbXBlcnNvbmF0ZTogJHtlcnJvcn1gO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbiBPcGVuSUQgQ29ubmVjdCBJRCB0b2tlbiBmb3IgYSBzZXJ2aWNlIGFjY291bnQuXG4gICAgICpcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2lhbS9kb2NzL3JlZmVyZW5jZS9jcmVkZW50aWFscy9yZXN0L3YxL3Byb2plY3RzLnNlcnZpY2VBY2NvdW50cy9nZW5lcmF0ZUlkVG9rZW4gUmVmZXJlbmNlIERvY3VtZW50YXRpb259XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0QXVkaWVuY2UgdGhlIGF1ZGllbmNlIGZvciB0aGUgZmV0Y2hlZCBJRCB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgZm9yIHRoZSByZXF1ZXN0XG4gICAgICogQHJldHVybiBhbiBPcGVuSUQgQ29ubmVjdCBJRCB0b2tlblxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoSWRUb2tlbih0YXJnZXRBdWRpZW5jZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGF3YWl0IHRoaXMuc291cmNlQ2xpZW50LmdldEFjY2Vzc1Rva2VuKCk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBgcHJvamVjdHMvLS9zZXJ2aWNlQWNjb3VudHMvJHt0aGlzLnRhcmdldFByaW5jaXBhbH1gO1xuICAgICAgICBjb25zdCB1ID0gYCR7dGhpcy5lbmRwb2ludH0vdjEvJHtuYW1lfTpnZW5lcmF0ZUlkVG9rZW5gO1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgZGVsZWdhdGVzOiB0aGlzLmRlbGVnYXRlcyxcbiAgICAgICAgICAgIGF1ZGllbmNlOiB0YXJnZXRBdWRpZW5jZSxcbiAgICAgICAgICAgIGluY2x1ZGVFbWFpbDogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmluY2x1ZGVFbWFpbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5zb3VyY2VDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICB1cmw6IHUsXG4gICAgICAgICAgICBkYXRhOiBib2R5LFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzLmRhdGEudG9rZW47XG4gICAgfVxufVxuZXhwb3J0cy5JbXBlcnNvbmF0ZWQgPSBJbXBlcnNvbmF0ZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbXBlcnNvbmF0ZWQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSW1wZXJzb25hdGVkIiwiSU1QRVJTT05BVEVEX0FDQ09VTlRfVFlQRSIsIm9hdXRoMmNsaWVudF8xIiwicmVxdWlyZSIsImdheGlvc18xIiwiT0F1dGgyQ2xpZW50IiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiY3JlZGVudGlhbHMiLCJleHBpcnlfZGF0ZSIsInJlZnJlc2hfdG9rZW4iLCJzb3VyY2VDbGllbnQiLCJ0YXJnZXRQcmluY2lwYWwiLCJkZWxlZ2F0ZXMiLCJ0YXJnZXRTY29wZXMiLCJsaWZldGltZSIsImVuZHBvaW50IiwicmVmcmVzaFRva2VuIiwiZ2V0QWNjZXNzVG9rZW4iLCJuYW1lIiwidSIsImJvZHkiLCJzY29wZSIsInJlcyIsInJlcXVlc3QiLCJ1cmwiLCJkYXRhIiwibWV0aG9kIiwidG9rZW5SZXNwb25zZSIsImFjY2Vzc190b2tlbiIsImFjY2Vzc1Rva2VuIiwiRGF0ZSIsInBhcnNlIiwiZXhwaXJlVGltZSIsInRva2VucyIsImVycm9yIiwiRXJyb3IiLCJzdGF0dXMiLCJtZXNzYWdlIiwiR2F4aW9zRXJyb3IiLCJyZXNwb25zZSIsImZldGNoSWRUb2tlbiIsInRhcmdldEF1ZGllbmNlIiwiYXVkaWVuY2UiLCJpbmNsdWRlRW1haWwiLCJ0b2tlbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/impersonated.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/jwtaccess.js":
/*!**********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/jwtaccess.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2015 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.JWTAccess = void 0;\nconst jws = __webpack_require__(/*! jws */ \"(rsc)/./node_modules/jws/index.js\");\nconst LRU = __webpack_require__(/*! lru-cache */ \"(rsc)/./node_modules/lru-cache/index.js\");\nconst DEFAULT_HEADER = {\n    alg: \"RS256\",\n    typ: \"JWT\"\n};\nclass JWTAccess {\n    /**\n     * JWTAccess service account credentials.\n     *\n     * Create a new access token by using the credential to create a new JWT token\n     * that's recognized as the access token.\n     *\n     * @param email the service account email address.\n     * @param key the private key that will be used to sign the token.\n     * @param keyId the ID of the private key used to sign the token.\n     */ constructor(email, key, keyId, eagerRefreshThresholdMillis){\n        this.cache = new LRU({\n            max: 500,\n            maxAge: 60 * 60 * 1000\n        });\n        this.email = email;\n        this.key = key;\n        this.keyId = keyId;\n        this.eagerRefreshThresholdMillis = eagerRefreshThresholdMillis !== null && eagerRefreshThresholdMillis !== void 0 ? eagerRefreshThresholdMillis : 5 * 60 * 1000;\n    }\n    /**\n     * Ensures that we're caching a key appropriately, giving precedence to scopes vs. url\n     *\n     * @param url The URI being authorized.\n     * @param scopes The scope or scopes being authorized\n     * @returns A string that returns the cached key.\n     */ getCachedKey(url, scopes) {\n        let cacheKey = url;\n        if (scopes && Array.isArray(scopes) && scopes.length) {\n            cacheKey = url ? `${url}_${scopes.join(\"_\")}` : `${scopes.join(\"_\")}`;\n        } else if (typeof scopes === \"string\") {\n            cacheKey = url ? `${url}_${scopes}` : scopes;\n        }\n        if (!cacheKey) {\n            throw Error(\"Scopes or url must be provided\");\n        }\n        return cacheKey;\n    }\n    /**\n     * Get a non-expired access token, after refreshing if necessary.\n     *\n     * @param url The URI being authorized.\n     * @param additionalClaims An object with a set of additional claims to\n     * include in the payload.\n     * @returns An object that includes the authorization header.\n     */ getRequestHeaders(url, additionalClaims, scopes) {\n        // Return cached authorization headers, unless we are within\n        // eagerRefreshThresholdMillis ms of them expiring:\n        const key = this.getCachedKey(url, scopes);\n        const cachedToken = this.cache.get(key);\n        const now = Date.now();\n        if (cachedToken && cachedToken.expiration - now > this.eagerRefreshThresholdMillis) {\n            return cachedToken.headers;\n        }\n        const iat = Math.floor(Date.now() / 1000);\n        const exp = JWTAccess.getExpirationTime(iat);\n        let defaultClaims;\n        // Turn scopes into space-separated string\n        if (Array.isArray(scopes)) {\n            scopes = scopes.join(\" \");\n        }\n        // If scopes are specified, sign with scopes\n        if (scopes) {\n            defaultClaims = {\n                iss: this.email,\n                sub: this.email,\n                scope: scopes,\n                exp,\n                iat\n            };\n        } else {\n            defaultClaims = {\n                iss: this.email,\n                sub: this.email,\n                aud: url,\n                exp,\n                iat\n            };\n        }\n        // if additionalClaims are provided, ensure they do not collide with\n        // other required claims.\n        if (additionalClaims) {\n            for(const claim in defaultClaims){\n                if (additionalClaims[claim]) {\n                    throw new Error(`The '${claim}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);\n                }\n            }\n        }\n        const header = this.keyId ? {\n            ...DEFAULT_HEADER,\n            kid: this.keyId\n        } : DEFAULT_HEADER;\n        const payload = Object.assign(defaultClaims, additionalClaims);\n        // Sign the jwt and add it to the cache\n        const signedJWT = jws.sign({\n            header,\n            payload,\n            secret: this.key\n        });\n        const headers = {\n            Authorization: `Bearer ${signedJWT}`\n        };\n        this.cache.set(key, {\n            expiration: exp * 1000,\n            headers\n        });\n        return headers;\n    }\n    /**\n     * Returns an expiration time for the JWT token.\n     *\n     * @param iat The issued at time for the JWT.\n     * @returns An expiration time for the JWT.\n     */ static getExpirationTime(iat) {\n        const exp = iat + 3600; // 3600 seconds = 1 hour\n        return exp;\n    }\n    /**\n     * Create a JWTAccess credentials instance using the given input options.\n     * @param json The input object.\n     */ fromJSON(json) {\n        if (!json) {\n            throw new Error(\"Must pass in a JSON object containing the service account auth settings.\");\n        }\n        if (!json.client_email) {\n            throw new Error(\"The incoming JSON object does not contain a client_email field\");\n        }\n        if (!json.private_key) {\n            throw new Error(\"The incoming JSON object does not contain a private_key field\");\n        }\n        // Extract the relevant information from the json key file.\n        this.email = json.client_email;\n        this.key = json.private_key;\n        this.keyId = json.private_key_id;\n        this.projectId = json.project_id;\n    }\n    fromStream(inputStream, callback) {\n        if (callback) {\n            this.fromStreamAsync(inputStream).then(()=>callback(), callback);\n        } else {\n            return this.fromStreamAsync(inputStream);\n        }\n    }\n    fromStreamAsync(inputStream) {\n        return new Promise((resolve, reject)=>{\n            if (!inputStream) {\n                reject(new Error(\"Must pass in a stream containing the service account auth settings.\"));\n            }\n            let s = \"\";\n            inputStream.setEncoding(\"utf8\").on(\"data\", (chunk)=>s += chunk).on(\"error\", reject).on(\"end\", ()=>{\n                try {\n                    const data = JSON.parse(s);\n                    this.fromJSON(data);\n                    resolve();\n                } catch (err) {\n                    reject(err);\n                }\n            });\n        });\n    }\n}\nexports.JWTAccess = JWTAccess; //# sourceMappingURL=jwtaccess.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9qd3RhY2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLE1BQU1HLE1BQU1DLG1CQUFPQSxDQUFDLDhDQUFLO0FBQ3pCLE1BQU1DLE1BQU1ELG1CQUFPQSxDQUFDLDBEQUFXO0FBQy9CLE1BQU1FLGlCQUFpQjtJQUNuQkMsS0FBSztJQUNMQyxLQUFLO0FBQ1Q7QUFDQSxNQUFNTjtJQUNGOzs7Ozs7Ozs7S0FTQyxHQUNETyxZQUFZQyxLQUFLLEVBQUVDLEdBQUcsRUFBRUMsS0FBSyxFQUFFQywyQkFBMkIsQ0FBRTtRQUN4RCxJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJVCxJQUFJO1lBQ2pCVSxLQUFLO1lBQ0xDLFFBQVEsS0FBSyxLQUFLO1FBQ3RCO1FBQ0EsSUFBSSxDQUFDTixLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQywyQkFBMkIsR0FDNUJBLGdDQUFnQyxRQUFRQSxnQ0FBZ0MsS0FBSyxJQUFJQSw4QkFBOEIsSUFBSSxLQUFLO0lBQ2hJO0lBQ0E7Ozs7OztLQU1DLEdBQ0RJLGFBQWFDLEdBQUcsRUFBRUMsTUFBTSxFQUFFO1FBQ3RCLElBQUlDLFdBQVdGO1FBQ2YsSUFBSUMsVUFBVUUsTUFBTUMsT0FBTyxDQUFDSCxXQUFXQSxPQUFPSSxNQUFNLEVBQUU7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L2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvand0YWNjZXNzLmpzP2NiOTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxNSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSldUQWNjZXNzID0gdm9pZCAwO1xuY29uc3QgandzID0gcmVxdWlyZShcImp3c1wiKTtcbmNvbnN0IExSVSA9IHJlcXVpcmUoXCJscnUtY2FjaGVcIik7XG5jb25zdCBERUZBVUxUX0hFQURFUiA9IHtcbiAgICBhbGc6ICdSUzI1NicsXG4gICAgdHlwOiAnSldUJyxcbn07XG5jbGFzcyBKV1RBY2Nlc3Mge1xuICAgIC8qKlxuICAgICAqIEpXVEFjY2VzcyBzZXJ2aWNlIGFjY291bnQgY3JlZGVudGlhbHMuXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgYWNjZXNzIHRva2VuIGJ5IHVzaW5nIHRoZSBjcmVkZW50aWFsIHRvIGNyZWF0ZSBhIG5ldyBKV1QgdG9rZW5cbiAgICAgKiB0aGF0J3MgcmVjb2duaXplZCBhcyB0aGUgYWNjZXNzIHRva2VuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVtYWlsIHRoZSBzZXJ2aWNlIGFjY291bnQgZW1haWwgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0ga2V5IHRoZSBwcml2YXRlIGtleSB0aGF0IHdpbGwgYmUgdXNlZCB0byBzaWduIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ga2V5SWQgdGhlIElEIG9mIHRoZSBwcml2YXRlIGtleSB1c2VkIHRvIHNpZ24gdGhlIHRva2VuLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVtYWlsLCBrZXksIGtleUlkLCBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMpIHtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBMUlUoe1xuICAgICAgICAgICAgbWF4OiA1MDAsXG4gICAgICAgICAgICBtYXhBZ2U6IDYwICogNjAgKiAxMDAwLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWFpbCA9IGVtYWlsO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5rZXlJZCA9IGtleUlkO1xuICAgICAgICB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyA9XG4gICAgICAgICAgICBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgIT09IG51bGwgJiYgZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzICE9PSB2b2lkIDAgPyBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgOiA1ICogNjAgKiAxMDAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoYXQgd2UncmUgY2FjaGluZyBhIGtleSBhcHByb3ByaWF0ZWx5LCBnaXZpbmcgcHJlY2VkZW5jZSB0byBzY29wZXMgdnMuIHVybFxuICAgICAqXG4gICAgICogQHBhcmFtIHVybCBUaGUgVVJJIGJlaW5nIGF1dGhvcml6ZWQuXG4gICAgICogQHBhcmFtIHNjb3BlcyBUaGUgc2NvcGUgb3Igc2NvcGVzIGJlaW5nIGF1dGhvcml6ZWRcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyB0aGF0IHJldHVybnMgdGhlIGNhY2hlZCBrZXkuXG4gICAgICovXG4gICAgZ2V0Q2FjaGVkS2V5KHVybCwgc2NvcGVzKSB7XG4gICAgICAgIGxldCBjYWNoZUtleSA9IHVybDtcbiAgICAgICAgaWYgKHNjb3BlcyAmJiBBcnJheS5pc0FycmF5KHNjb3BlcykgJiYgc2NvcGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FjaGVLZXkgPSB1cmwgPyBgJHt1cmx9XyR7c2NvcGVzLmpvaW4oJ18nKX1gIDogYCR7c2NvcGVzLmpvaW4oJ18nKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzY29wZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjYWNoZUtleSA9IHVybCA/IGAke3VybH1fJHtzY29wZXN9YCA6IHNjb3BlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhY2hlS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignU2NvcGVzIG9yIHVybCBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlS2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBub24tZXhwaXJlZCBhY2Nlc3MgdG9rZW4sIGFmdGVyIHJlZnJlc2hpbmcgaWYgbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVybCBUaGUgVVJJIGJlaW5nIGF1dGhvcml6ZWQuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxDbGFpbXMgQW4gb2JqZWN0IHdpdGggYSBzZXQgb2YgYWRkaXRpb25hbCBjbGFpbXMgdG9cbiAgICAgKiBpbmNsdWRlIGluIHRoZSBwYXlsb2FkLlxuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCB0aGF0IGluY2x1ZGVzIHRoZSBhdXRob3JpemF0aW9uIGhlYWRlci5cbiAgICAgKi9cbiAgICBnZXRSZXF1ZXN0SGVhZGVycyh1cmwsIGFkZGl0aW9uYWxDbGFpbXMsIHNjb3Blcykge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGF1dGhvcml6YXRpb24gaGVhZGVycywgdW5sZXNzIHdlIGFyZSB3aXRoaW5cbiAgICAgICAgLy8gZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzIG1zIG9mIHRoZW0gZXhwaXJpbmc6XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0Q2FjaGVkS2V5KHVybCwgc2NvcGVzKTtcbiAgICAgICAgY29uc3QgY2FjaGVkVG9rZW4gPSB0aGlzLmNhY2hlLmdldChrZXkpO1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoY2FjaGVkVG9rZW4gJiZcbiAgICAgICAgICAgIGNhY2hlZFRva2VuLmV4cGlyYXRpb24gLSBub3cgPiB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcykge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFRva2VuLmhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWF0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICAgIGNvbnN0IGV4cCA9IEpXVEFjY2Vzcy5nZXRFeHBpcmF0aW9uVGltZShpYXQpO1xuICAgICAgICBsZXQgZGVmYXVsdENsYWltcztcbiAgICAgICAgLy8gVHVybiBzY29wZXMgaW50byBzcGFjZS1zZXBhcmF0ZWQgc3RyaW5nXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjb3BlcykpIHtcbiAgICAgICAgICAgIHNjb3BlcyA9IHNjb3Blcy5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgc2NvcGVzIGFyZSBzcGVjaWZpZWQsIHNpZ24gd2l0aCBzY29wZXNcbiAgICAgICAgaWYgKHNjb3Blcykge1xuICAgICAgICAgICAgZGVmYXVsdENsYWltcyA9IHtcbiAgICAgICAgICAgICAgICBpc3M6IHRoaXMuZW1haWwsXG4gICAgICAgICAgICAgICAgc3ViOiB0aGlzLmVtYWlsLFxuICAgICAgICAgICAgICAgIHNjb3BlOiBzY29wZXMsXG4gICAgICAgICAgICAgICAgZXhwLFxuICAgICAgICAgICAgICAgIGlhdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0Q2xhaW1zID0ge1xuICAgICAgICAgICAgICAgIGlzczogdGhpcy5lbWFpbCxcbiAgICAgICAgICAgICAgICBzdWI6IHRoaXMuZW1haWwsXG4gICAgICAgICAgICAgICAgYXVkOiB1cmwsXG4gICAgICAgICAgICAgICAgZXhwLFxuICAgICAgICAgICAgICAgIGlhdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYWRkaXRpb25hbENsYWltcyBhcmUgcHJvdmlkZWQsIGVuc3VyZSB0aGV5IGRvIG5vdCBjb2xsaWRlIHdpdGhcbiAgICAgICAgLy8gb3RoZXIgcmVxdWlyZWQgY2xhaW1zLlxuICAgICAgICBpZiAoYWRkaXRpb25hbENsYWltcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjbGFpbSBpbiBkZWZhdWx0Q2xhaW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZGl0aW9uYWxDbGFpbXNbY2xhaW1dKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICcke2NsYWltfScgcHJvcGVydHkgaXMgbm90IGFsbG93ZWQgd2hlbiBwYXNzaW5nIGFkZGl0aW9uYWxDbGFpbXMuIFRoaXMgY2xhaW0gaXMgaW5jbHVkZWQgaW4gdGhlIEpXVCBieSBkZWZhdWx0LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXIgPSB0aGlzLmtleUlkXG4gICAgICAgICAgICA/IHsgLi4uREVGQVVMVF9IRUFERVIsIGtpZDogdGhpcy5rZXlJZCB9XG4gICAgICAgICAgICA6IERFRkFVTFRfSEVBREVSO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0Q2xhaW1zLCBhZGRpdGlvbmFsQ2xhaW1zKTtcbiAgICAgICAgLy8gU2lnbiB0aGUgand0IGFuZCBhZGQgaXQgdG8gdGhlIGNhY2hlXG4gICAgICAgIGNvbnN0IHNpZ25lZEpXVCA9IGp3cy5zaWduKHsgaGVhZGVyLCBwYXlsb2FkLCBzZWNyZXQ6IHRoaXMua2V5IH0pO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0geyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7c2lnbmVkSldUfWAgfTtcbiAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCB7XG4gICAgICAgICAgICBleHBpcmF0aW9uOiBleHAgKiAxMDAwLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGV4cGlyYXRpb24gdGltZSBmb3IgdGhlIEpXVCB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpYXQgVGhlIGlzc3VlZCBhdCB0aW1lIGZvciB0aGUgSldULlxuICAgICAqIEByZXR1cm5zIEFuIGV4cGlyYXRpb24gdGltZSBmb3IgdGhlIEpXVC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RXhwaXJhdGlvblRpbWUoaWF0KSB7XG4gICAgICAgIGNvbnN0IGV4cCA9IGlhdCArIDM2MDA7IC8vIDM2MDAgc2Vjb25kcyA9IDEgaG91clxuICAgICAgICByZXR1cm4gZXhwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBKV1RBY2Nlc3MgY3JlZGVudGlhbHMgaW5zdGFuY2UgdXNpbmcgdGhlIGdpdmVuIGlucHV0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGpzb24gVGhlIGlucHV0IG9iamVjdC5cbiAgICAgKi9cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHBhc3MgaW4gYSBKU09OIG9iamVjdCBjb250YWluaW5nIHRoZSBzZXJ2aWNlIGFjY291bnQgYXV0aCBzZXR0aW5ncy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWpzb24uY2xpZW50X2VtYWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgY2xpZW50X2VtYWlsIGZpZWxkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc29uLnByaXZhdGVfa2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgcHJpdmF0ZV9rZXkgZmllbGQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHRyYWN0IHRoZSByZWxldmFudCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBqc29uIGtleSBmaWxlLlxuICAgICAgICB0aGlzLmVtYWlsID0ganNvbi5jbGllbnRfZW1haWw7XG4gICAgICAgIHRoaXMua2V5ID0ganNvbi5wcml2YXRlX2tleTtcbiAgICAgICAgdGhpcy5rZXlJZCA9IGpzb24ucHJpdmF0ZV9rZXlfaWQ7XG4gICAgICAgIHRoaXMucHJvamVjdElkID0ganNvbi5wcm9qZWN0X2lkO1xuICAgIH1cbiAgICBmcm9tU3RyZWFtKGlucHV0U3RyZWFtLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtKS50aGVuKCgpID0+IGNhbGxiYWNrKCksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlucHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTXVzdCBwYXNzIGluIGEgc3RyZWFtIGNvbnRhaW5pbmcgdGhlIHNlcnZpY2UgYWNjb3VudCBhdXRoIHNldHRpbmdzLicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzID0gJyc7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbVxuICAgICAgICAgICAgICAgIC5zZXRFbmNvZGluZygndXRmOCcpXG4gICAgICAgICAgICAgICAgLm9uKCdkYXRhJywgY2h1bmsgPT4gKHMgKz0gY2h1bmspKVxuICAgICAgICAgICAgICAgIC5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgICAgICAgICAgLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2Uocyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvbUpTT04oZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5KV1RBY2Nlc3MgPSBKV1RBY2Nlc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qd3RhY2Nlc3MuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSldUQWNjZXNzIiwiandzIiwicmVxdWlyZSIsIkxSVSIsIkRFRkFVTFRfSEVBREVSIiwiYWxnIiwidHlwIiwiY29uc3RydWN0b3IiLCJlbWFpbCIsImtleSIsImtleUlkIiwiZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzIiwiY2FjaGUiLCJtYXgiLCJtYXhBZ2UiLCJnZXRDYWNoZWRLZXkiLCJ1cmwiLCJzY29wZXMiLCJjYWNoZUtleSIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImpvaW4iLCJFcnJvciIsImdldFJlcXVlc3RIZWFkZXJzIiwiYWRkaXRpb25hbENsYWltcyIsImNhY2hlZFRva2VuIiwiZ2V0Iiwibm93IiwiRGF0ZSIsImV4cGlyYXRpb24iLCJoZWFkZXJzIiwiaWF0IiwiTWF0aCIsImZsb29yIiwiZXhwIiwiZ2V0RXhwaXJhdGlvblRpbWUiLCJkZWZhdWx0Q2xhaW1zIiwiaXNzIiwic3ViIiwic2NvcGUiLCJhdWQiLCJjbGFpbSIsImhlYWRlciIsImtpZCIsInBheWxvYWQiLCJhc3NpZ24iLCJzaWduZWRKV1QiLCJzaWduIiwic2VjcmV0IiwiQXV0aG9yaXphdGlvbiIsInNldCIsImZyb21KU09OIiwianNvbiIsImNsaWVudF9lbWFpbCIsInByaXZhdGVfa2V5IiwicHJpdmF0ZV9rZXlfaWQiLCJwcm9qZWN0SWQiLCJwcm9qZWN0X2lkIiwiZnJvbVN0cmVhbSIsImlucHV0U3RyZWFtIiwiY2FsbGJhY2siLCJmcm9tU3RyZWFtQXN5bmMiLCJ0aGVuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzIiwic2V0RW5jb2RpbmciLCJvbiIsImNodW5rIiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsImVyciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/jwtaccess.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/jwtclient.js":
/*!**********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/jwtclient.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2013 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.JWT = void 0;\nconst gtoken_1 = __webpack_require__(/*! gtoken */ \"(rsc)/./node_modules/gtoken/build/src/index.js\");\nconst jwtaccess_1 = __webpack_require__(/*! ./jwtaccess */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/jwtaccess.js\");\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nclass JWT extends oauth2client_1.OAuth2Client {\n    constructor(optionsOrEmail, keyFile, key, scopes, subject, keyId){\n        const opts = optionsOrEmail && typeof optionsOrEmail === \"object\" ? optionsOrEmail : {\n            email: optionsOrEmail,\n            keyFile,\n            key,\n            keyId,\n            scopes,\n            subject\n        };\n        super({\n            eagerRefreshThresholdMillis: opts.eagerRefreshThresholdMillis,\n            forceRefreshOnFailure: opts.forceRefreshOnFailure\n        });\n        this.email = opts.email;\n        this.keyFile = opts.keyFile;\n        this.key = opts.key;\n        this.keyId = opts.keyId;\n        this.scopes = opts.scopes;\n        this.subject = opts.subject;\n        this.additionalClaims = opts.additionalClaims;\n        this.credentials = {\n            refresh_token: \"jwt-placeholder\",\n            expiry_date: 1\n        };\n    }\n    /**\n     * Creates a copy of the credential with the specified scopes.\n     * @param scopes List of requested scopes or a single scope.\n     * @return The cloned instance.\n     */ createScoped(scopes) {\n        return new JWT({\n            email: this.email,\n            keyFile: this.keyFile,\n            key: this.key,\n            keyId: this.keyId,\n            scopes,\n            subject: this.subject,\n            additionalClaims: this.additionalClaims\n        });\n    }\n    /**\n     * Obtains the metadata to be sent with the request.\n     *\n     * @param url the URI being authorized.\n     */ async getRequestMetadataAsync(url) {\n        url = this.defaultServicePath ? `https://${this.defaultServicePath}/` : url;\n        const useSelfSignedJWT = !this.hasUserScopes() && url || this.useJWTAccessWithScope && this.hasAnyScopes();\n        if (!this.apiKey && useSelfSignedJWT) {\n            if (this.additionalClaims && this.additionalClaims.target_audience) {\n                const { tokens } = await this.refreshToken();\n                return {\n                    headers: this.addSharedMetadataHeaders({\n                        Authorization: `Bearer ${tokens.id_token}`\n                    })\n                };\n            } else {\n                // no scopes have been set, but a uri has been provided. Use JWTAccess\n                // credentials.\n                if (!this.access) {\n                    this.access = new jwtaccess_1.JWTAccess(this.email, this.key, this.keyId, this.eagerRefreshThresholdMillis);\n                }\n                let scopes;\n                if (this.hasUserScopes()) {\n                    scopes = this.scopes;\n                } else if (!url) {\n                    scopes = this.defaultScopes;\n                }\n                const headers = await this.access.getRequestHeaders(url !== null && url !== void 0 ? url : undefined, this.additionalClaims, // Scopes take precedent over audience for signing,\n                // so we only provide them if useJWTAccessWithScope is on\n                this.useJWTAccessWithScope ? scopes : undefined);\n                return {\n                    headers: this.addSharedMetadataHeaders(headers)\n                };\n            }\n        } else if (this.hasAnyScopes() || this.apiKey) {\n            return super.getRequestMetadataAsync(url);\n        } else {\n            // If no audience, apiKey, or scopes are provided, we should not attempt\n            // to populate any headers:\n            return {\n                headers: {}\n            };\n        }\n    }\n    /**\n     * Fetches an ID token.\n     * @param targetAudience the audience for the fetched ID token.\n     */ async fetchIdToken(targetAudience) {\n        // Create a new gToken for fetching an ID token\n        const gtoken = new gtoken_1.GoogleToken({\n            iss: this.email,\n            sub: this.subject,\n            scope: this.scopes || this.defaultScopes,\n            keyFile: this.keyFile,\n            key: this.key,\n            additionalClaims: {\n                target_audience: targetAudience\n            },\n            transporter: this.transporter\n        });\n        await gtoken.getToken({\n            forceRefresh: true\n        });\n        if (!gtoken.idToken) {\n            throw new Error(\"Unknown error: Failed to fetch ID token\");\n        }\n        return gtoken.idToken;\n    }\n    /**\n     * Determine if there are currently scopes available.\n     */ hasUserScopes() {\n        if (!this.scopes) {\n            return false;\n        }\n        return this.scopes.length > 0;\n    }\n    /**\n     * Are there any default or user scopes defined.\n     */ hasAnyScopes() {\n        if (this.scopes && this.scopes.length > 0) return true;\n        if (this.defaultScopes && this.defaultScopes.length > 0) return true;\n        return false;\n    }\n    authorize(callback) {\n        if (callback) {\n            this.authorizeAsync().then((r)=>callback(null, r), callback);\n        } else {\n            return this.authorizeAsync();\n        }\n    }\n    async authorizeAsync() {\n        const result = await this.refreshToken();\n        if (!result) {\n            throw new Error(\"No result returned\");\n        }\n        this.credentials = result.tokens;\n        this.credentials.refresh_token = \"jwt-placeholder\";\n        this.key = this.gtoken.key;\n        this.email = this.gtoken.iss;\n        return result.tokens;\n    }\n    /**\n     * Refreshes the access token.\n     * @param refreshToken ignored\n     * @private\n     */ async refreshTokenNoCache(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refreshToken) {\n        const gtoken = this.createGToken();\n        const token = await gtoken.getToken({\n            forceRefresh: this.isTokenExpiring()\n        });\n        const tokens = {\n            access_token: token.access_token,\n            token_type: \"Bearer\",\n            expiry_date: gtoken.expiresAt,\n            id_token: gtoken.idToken\n        };\n        this.emit(\"tokens\", tokens);\n        return {\n            res: null,\n            tokens\n        };\n    }\n    /**\n     * Create a gToken if it doesn't already exist.\n     */ createGToken() {\n        if (!this.gtoken) {\n            this.gtoken = new gtoken_1.GoogleToken({\n                iss: this.email,\n                sub: this.subject,\n                scope: this.scopes || this.defaultScopes,\n                keyFile: this.keyFile,\n                key: this.key,\n                additionalClaims: this.additionalClaims,\n                transporter: this.transporter\n            });\n        }\n        return this.gtoken;\n    }\n    /**\n     * Create a JWT credentials instance using the given input options.\n     * @param json The input object.\n     */ fromJSON(json) {\n        if (!json) {\n            throw new Error(\"Must pass in a JSON object containing the service account auth settings.\");\n        }\n        if (!json.client_email) {\n            throw new Error(\"The incoming JSON object does not contain a client_email field\");\n        }\n        if (!json.private_key) {\n            throw new Error(\"The incoming JSON object does not contain a private_key field\");\n        }\n        // Extract the relevant information from the json key file.\n        this.email = json.client_email;\n        this.key = json.private_key;\n        this.keyId = json.private_key_id;\n        this.projectId = json.project_id;\n        this.quotaProjectId = json.quota_project_id;\n    }\n    fromStream(inputStream, callback) {\n        if (callback) {\n            this.fromStreamAsync(inputStream).then(()=>callback(), callback);\n        } else {\n            return this.fromStreamAsync(inputStream);\n        }\n    }\n    fromStreamAsync(inputStream) {\n        return new Promise((resolve, reject)=>{\n            if (!inputStream) {\n                throw new Error(\"Must pass in a stream containing the service account auth settings.\");\n            }\n            let s = \"\";\n            inputStream.setEncoding(\"utf8\").on(\"error\", reject).on(\"data\", (chunk)=>s += chunk).on(\"end\", ()=>{\n                try {\n                    const data = JSON.parse(s);\n                    this.fromJSON(data);\n                    resolve();\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    /**\n     * Creates a JWT credentials instance using an API Key for authentication.\n     * @param apiKey The API Key in string form.\n     */ fromAPIKey(apiKey) {\n        if (typeof apiKey !== \"string\") {\n            throw new Error(\"Must provide an API Key string.\");\n        }\n        this.apiKey = apiKey;\n    }\n    /**\n     * Using the key or keyFile on the JWT client, obtain an object that contains\n     * the key and the client email.\n     */ async getCredentials() {\n        if (this.key) {\n            return {\n                private_key: this.key,\n                client_email: this.email\n            };\n        } else if (this.keyFile) {\n            const gtoken = this.createGToken();\n            const creds = await gtoken.getCredentials(this.keyFile);\n            return {\n                private_key: creds.privateKey,\n                client_email: creds.clientEmail\n            };\n        }\n        throw new Error(\"A key or a keyFile must be provided to getCredentials.\");\n    }\n}\nexports.JWT = JWT; //# sourceMappingURL=jwtclient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9qd3RjbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxXQUFXLEdBQUcsS0FBSztBQUNuQixNQUFNRyxXQUFXQyxtQkFBT0EsQ0FBQyw4REFBUTtBQUNqQyxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyx5RkFBYTtBQUN6QyxNQUFNRSxpQkFBaUJGLG1CQUFPQSxDQUFDLCtGQUFnQjtBQUMvQyxNQUFNRixZQUFZSSxlQUFlQyxZQUFZO0lBQ3pDQyxZQUFZQyxjQUFjLEVBQUVDLE9BQU8sRUFBRUMsR0FBRyxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsS0FBSyxDQUFFO1FBQzlELE1BQU1DLE9BQU9OLGtCQUFrQixPQUFPQSxtQkFBbUIsV0FDbkRBLGlCQUNBO1lBQUVPLE9BQU9QO1lBQWdCQztZQUFTQztZQUFLRztZQUFPRjtZQUFRQztRQUFRO1FBQ3BFLEtBQUssQ0FBQztZQUNGSSw2QkFBNkJGLEtBQUtFLDJCQUEyQjtZQUM3REMsdUJBQXVCSCxLQUFLRyxxQkFBcUI7UUFDckQ7UUFDQSxJQUFJLENBQUNGLEtBQUssR0FBR0QsS0FBS0MsS0FBSztRQUN2QixJQUFJLENBQUNOLE9BQU8sR0FBR0ssS0FBS0wsT0FBTztRQUMzQixJQUFJLENBQUNDLEdBQUcsR0FBR0ksS0FBS0osR0FBRztRQUNuQixJQUFJLENBQUNHLEtBQUssR0FBR0MsS0FBS0QsS0FBSztRQUN2QixJQUFJLENBQUNGLE1BQU0s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LE9BQU9DLEtBQUtDLEtBQUssQ0FBQ047b0JBQ3hCLElBQUksQ0FBQ2YsUUFBUSxDQUFDbUI7b0JBQ2ROO2dCQUNKLEVBQ0EsT0FBT1MsR0FBRztvQkFDTlIsT0FBT1E7Z0JBQ1g7WUFDSjtRQUNKO0lBQ0o7SUFDQTs7O0tBR0MsR0FDREMsV0FBV2hFLE1BQU0sRUFBRTtRQUNmLElBQUksT0FBT0EsV0FBVyxVQUFVO1lBQzVCLE1BQU0sSUFBSXdCLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUN4QixNQUFNLEdBQUdBO0lBQ2xCO0lBQ0E7OztLQUdDLEdBQ0QsTUFBTWlFLGlCQUFpQjtRQUNuQixJQUFJLElBQUksQ0FBQ3JGLEdBQUcsRUFBRTtZQUNWLE9BQU87Z0JBQUVnRSxhQUFhLElBQUksQ0FBQ2hFLEdBQUc7Z0JBQUUrRCxjQUFjLElBQUksQ0FBQzFELEtBQUs7WUFBQztRQUM3RCxPQUNLLElBQUksSUFBSSxDQUFDTixPQUFPLEVBQUU7WUFDbkIsTUFBTW9DLFNBQVMsSUFBSSxDQUFDa0IsWUFBWTtZQUNoQyxNQUFNaUMsUUFBUSxNQUFNbkQsT0FBT2tELGNBQWMsQ0FBQyxJQUFJLENBQUN0RixPQUFPO1lBQ3RELE9BQU87Z0JBQUVpRSxhQUFhc0IsTUFBTUMsVUFBVTtnQkFBRXhCLGNBQWN1QixNQUFNRSxXQUFXO1lBQUM7UUFDNUU7UUFDQSxNQUFNLElBQUk1QyxNQUFNO0lBQ3BCO0FBQ0o7QUFDQXZELFdBQVcsR0FBR0UsS0FDZCxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9qd3RjbGllbnQuanM/YzJkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDEzIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5KV1QgPSB2b2lkIDA7XG5jb25zdCBndG9rZW5fMSA9IHJlcXVpcmUoXCJndG9rZW5cIik7XG5jb25zdCBqd3RhY2Nlc3NfMSA9IHJlcXVpcmUoXCIuL2p3dGFjY2Vzc1wiKTtcbmNvbnN0IG9hdXRoMmNsaWVudF8xID0gcmVxdWlyZShcIi4vb2F1dGgyY2xpZW50XCIpO1xuY2xhc3MgSldUIGV4dGVuZHMgb2F1dGgyY2xpZW50XzEuT0F1dGgyQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zT3JFbWFpbCwga2V5RmlsZSwga2V5LCBzY29wZXMsIHN1YmplY3QsIGtleUlkKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zT3JFbWFpbCAmJiB0eXBlb2Ygb3B0aW9uc09yRW1haWwgPT09ICdvYmplY3QnXG4gICAgICAgICAgICA/IG9wdGlvbnNPckVtYWlsXG4gICAgICAgICAgICA6IHsgZW1haWw6IG9wdGlvbnNPckVtYWlsLCBrZXlGaWxlLCBrZXksIGtleUlkLCBzY29wZXMsIHN1YmplY3QgfTtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzOiBvcHRzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyxcbiAgICAgICAgICAgIGZvcmNlUmVmcmVzaE9uRmFpbHVyZTogb3B0cy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtYWlsID0gb3B0cy5lbWFpbDtcbiAgICAgICAgdGhpcy5rZXlGaWxlID0gb3B0cy5rZXlGaWxlO1xuICAgICAgICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICAgICAgICB0aGlzLmtleUlkID0gb3B0cy5rZXlJZDtcbiAgICAgICAgdGhpcy5zY29wZXMgPSBvcHRzLnNjb3BlcztcbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gb3B0cy5zdWJqZWN0O1xuICAgICAgICB0aGlzLmFkZGl0aW9uYWxDbGFpbXMgPSBvcHRzLmFkZGl0aW9uYWxDbGFpbXM7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSB7IHJlZnJlc2hfdG9rZW46ICdqd3QtcGxhY2Vob2xkZXInLCBleHBpcnlfZGF0ZTogMSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGUgY3JlZGVudGlhbCB3aXRoIHRoZSBzcGVjaWZpZWQgc2NvcGVzLlxuICAgICAqIEBwYXJhbSBzY29wZXMgTGlzdCBvZiByZXF1ZXN0ZWQgc2NvcGVzIG9yIGEgc2luZ2xlIHNjb3BlLlxuICAgICAqIEByZXR1cm4gVGhlIGNsb25lZCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBjcmVhdGVTY29wZWQoc2NvcGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgSldUKHtcbiAgICAgICAgICAgIGVtYWlsOiB0aGlzLmVtYWlsLFxuICAgICAgICAgICAga2V5RmlsZTogdGhpcy5rZXlGaWxlLFxuICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgIGtleUlkOiB0aGlzLmtleUlkLFxuICAgICAgICAgICAgc2NvcGVzLFxuICAgICAgICAgICAgc3ViamVjdDogdGhpcy5zdWJqZWN0LFxuICAgICAgICAgICAgYWRkaXRpb25hbENsYWltczogdGhpcy5hZGRpdGlvbmFsQ2xhaW1zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT2J0YWlucyB0aGUgbWV0YWRhdGEgdG8gYmUgc2VudCB3aXRoIHRoZSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVybCB0aGUgVVJJIGJlaW5nIGF1dGhvcml6ZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UmVxdWVzdE1ldGFkYXRhQXN5bmModXJsKSB7XG4gICAgICAgIHVybCA9IHRoaXMuZGVmYXVsdFNlcnZpY2VQYXRoID8gYGh0dHBzOi8vJHt0aGlzLmRlZmF1bHRTZXJ2aWNlUGF0aH0vYCA6IHVybDtcbiAgICAgICAgY29uc3QgdXNlU2VsZlNpZ25lZEpXVCA9ICghdGhpcy5oYXNVc2VyU2NvcGVzKCkgJiYgdXJsKSB8fFxuICAgICAgICAgICAgKHRoaXMudXNlSldUQWNjZXNzV2l0aFNjb3BlICYmIHRoaXMuaGFzQW55U2NvcGVzKCkpO1xuICAgICAgICBpZiAoIXRoaXMuYXBpS2V5ICYmIHVzZVNlbGZTaWduZWRKV1QpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFkZGl0aW9uYWxDbGFpbXMgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmFkZGl0aW9uYWxDbGFpbXMudGFyZ2V0X2F1ZGllbmNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0b2tlbnMgfSA9IGF3YWl0IHRoaXMucmVmcmVzaFRva2VuKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5hZGRTaGFyZWRNZXRhZGF0YUhlYWRlcnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2Vucy5pZF90b2tlbn1gLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gc2NvcGVzIGhhdmUgYmVlbiBzZXQsIGJ1dCBhIHVyaSBoYXMgYmVlbiBwcm92aWRlZC4gVXNlIEpXVEFjY2Vzc1xuICAgICAgICAgICAgICAgIC8vIGNyZWRlbnRpYWxzLlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hY2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY2Nlc3MgPSBuZXcgand0YWNjZXNzXzEuSldUQWNjZXNzKHRoaXMuZW1haWwsIHRoaXMua2V5LCB0aGlzLmtleUlkLCB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBzY29wZXM7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzVXNlclNjb3BlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlcyA9IHRoaXMuc2NvcGVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlcyA9IHRoaXMuZGVmYXVsdFNjb3BlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IGF3YWl0IHRoaXMuYWNjZXNzLmdldFJlcXVlc3RIZWFkZXJzKHVybCAhPT0gbnVsbCAmJiB1cmwgIT09IHZvaWQgMCA/IHVybCA6IHVuZGVmaW5lZCwgdGhpcy5hZGRpdGlvbmFsQ2xhaW1zLCBcbiAgICAgICAgICAgICAgICAvLyBTY29wZXMgdGFrZSBwcmVjZWRlbnQgb3ZlciBhdWRpZW5jZSBmb3Igc2lnbmluZyxcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBvbmx5IHByb3ZpZGUgdGhlbSBpZiB1c2VKV1RBY2Nlc3NXaXRoU2NvcGUgaXMgb25cbiAgICAgICAgICAgICAgICB0aGlzLnVzZUpXVEFjY2Vzc1dpdGhTY29wZSA/IHNjb3BlcyA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaGVhZGVyczogdGhpcy5hZGRTaGFyZWRNZXRhZGF0YUhlYWRlcnMoaGVhZGVycykgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmhhc0FueVNjb3BlcygpIHx8IHRoaXMuYXBpS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuZ2V0UmVxdWVzdE1ldGFkYXRhQXN5bmModXJsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIG5vIGF1ZGllbmNlLCBhcGlLZXksIG9yIHNjb3BlcyBhcmUgcHJvdmlkZWQsIHdlIHNob3VsZCBub3QgYXR0ZW1wdFxuICAgICAgICAgICAgLy8gdG8gcG9wdWxhdGUgYW55IGhlYWRlcnM6XG4gICAgICAgICAgICByZXR1cm4geyBoZWFkZXJzOiB7fSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYW4gSUQgdG9rZW4uXG4gICAgICogQHBhcmFtIHRhcmdldEF1ZGllbmNlIHRoZSBhdWRpZW5jZSBmb3IgdGhlIGZldGNoZWQgSUQgdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hJZFRva2VuKHRhcmdldEF1ZGllbmNlKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBnVG9rZW4gZm9yIGZldGNoaW5nIGFuIElEIHRva2VuXG4gICAgICAgIGNvbnN0IGd0b2tlbiA9IG5ldyBndG9rZW5fMS5Hb29nbGVUb2tlbih7XG4gICAgICAgICAgICBpc3M6IHRoaXMuZW1haWwsXG4gICAgICAgICAgICBzdWI6IHRoaXMuc3ViamVjdCxcbiAgICAgICAgICAgIHNjb3BlOiB0aGlzLnNjb3BlcyB8fCB0aGlzLmRlZmF1bHRTY29wZXMsXG4gICAgICAgICAgICBrZXlGaWxlOiB0aGlzLmtleUZpbGUsXG4gICAgICAgICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgICAgICAgYWRkaXRpb25hbENsYWltczogeyB0YXJnZXRfYXVkaWVuY2U6IHRhcmdldEF1ZGllbmNlIH0sXG4gICAgICAgICAgICB0cmFuc3BvcnRlcjogdGhpcy50cmFuc3BvcnRlcixcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IGd0b2tlbi5nZXRUb2tlbih7XG4gICAgICAgICAgICBmb3JjZVJlZnJlc2g6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWd0b2tlbi5pZFRva2VuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZXJyb3I6IEZhaWxlZCB0byBmZXRjaCBJRCB0b2tlbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBndG9rZW4uaWRUb2tlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIHRoZXJlIGFyZSBjdXJyZW50bHkgc2NvcGVzIGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICBoYXNVc2VyU2NvcGVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2NvcGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGVzLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFyZSB0aGVyZSBhbnkgZGVmYXVsdCBvciB1c2VyIHNjb3BlcyBkZWZpbmVkLlxuICAgICAqL1xuICAgIGhhc0FueVNjb3BlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGVzICYmIHRoaXMuc2NvcGVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdFNjb3BlcyAmJiB0aGlzLmRlZmF1bHRTY29wZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGF1dGhvcml6ZShjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuYXV0aG9yaXplQXN5bmMoKS50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgciksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF1dGhvcml6ZUFzeW5jKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgYXV0aG9yaXplQXN5bmMoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVmcmVzaFRva2VuKCk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlc3VsdCByZXR1cm5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSByZXN1bHQudG9rZW5zO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzLnJlZnJlc2hfdG9rZW4gPSAnand0LXBsYWNlaG9sZGVyJztcbiAgICAgICAgdGhpcy5rZXkgPSB0aGlzLmd0b2tlbi5rZXk7XG4gICAgICAgIHRoaXMuZW1haWwgPSB0aGlzLmd0b2tlbi5pc3M7XG4gICAgICAgIHJldHVybiByZXN1bHQudG9rZW5zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgdGhlIGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAcGFyYW0gcmVmcmVzaFRva2VuIGlnbm9yZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIHJlZnJlc2hUb2tlbk5vQ2FjaGUoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHJlZnJlc2hUb2tlbikge1xuICAgICAgICBjb25zdCBndG9rZW4gPSB0aGlzLmNyZWF0ZUdUb2tlbigpO1xuICAgICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IGd0b2tlbi5nZXRUb2tlbih7XG4gICAgICAgICAgICBmb3JjZVJlZnJlc2g6IHRoaXMuaXNUb2tlbkV4cGlyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0b2tlbnMgPSB7XG4gICAgICAgICAgICBhY2Nlc3NfdG9rZW46IHRva2VuLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgIHRva2VuX3R5cGU6ICdCZWFyZXInLFxuICAgICAgICAgICAgZXhwaXJ5X2RhdGU6IGd0b2tlbi5leHBpcmVzQXQsXG4gICAgICAgICAgICBpZF90b2tlbjogZ3Rva2VuLmlkVG9rZW4sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW1pdCgndG9rZW5zJywgdG9rZW5zKTtcbiAgICAgICAgcmV0dXJuIHsgcmVzOiBudWxsLCB0b2tlbnMgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZ1Rva2VuIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdC5cbiAgICAgKi9cbiAgICBjcmVhdGVHVG9rZW4oKSB7XG4gICAgICAgIGlmICghdGhpcy5ndG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMuZ3Rva2VuID0gbmV3IGd0b2tlbl8xLkdvb2dsZVRva2VuKHtcbiAgICAgICAgICAgICAgICBpc3M6IHRoaXMuZW1haWwsXG4gICAgICAgICAgICAgICAgc3ViOiB0aGlzLnN1YmplY3QsXG4gICAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuc2NvcGVzIHx8IHRoaXMuZGVmYXVsdFNjb3BlcyxcbiAgICAgICAgICAgICAgICBrZXlGaWxlOiB0aGlzLmtleUZpbGUsXG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsQ2xhaW1zOiB0aGlzLmFkZGl0aW9uYWxDbGFpbXMsXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0ZXI6IHRoaXMudHJhbnNwb3J0ZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ndG9rZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIEpXVCBjcmVkZW50aWFscyBpbnN0YW5jZSB1c2luZyB0aGUgZ2l2ZW4gaW5wdXQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ganNvbiBUaGUgaW5wdXQgb2JqZWN0LlxuICAgICAqL1xuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcGFzcyBpbiBhIEpTT04gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNlcnZpY2UgYWNjb3VudCBhdXRoIHNldHRpbmdzLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghanNvbi5jbGllbnRfZW1haWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluY29taW5nIEpTT04gb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gYSBjbGllbnRfZW1haWwgZmllbGQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWpzb24ucHJpdmF0ZV9rZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluY29taW5nIEpTT04gb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gYSBwcml2YXRlX2tleSBmaWVsZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIHJlbGV2YW50IGluZm9ybWF0aW9uIGZyb20gdGhlIGpzb24ga2V5IGZpbGUuXG4gICAgICAgIHRoaXMuZW1haWwgPSBqc29uLmNsaWVudF9lbWFpbDtcbiAgICAgICAgdGhpcy5rZXkgPSBqc29uLnByaXZhdGVfa2V5O1xuICAgICAgICB0aGlzLmtleUlkID0ganNvbi5wcml2YXRlX2tleV9pZDtcbiAgICAgICAgdGhpcy5wcm9qZWN0SWQgPSBqc29uLnByb2plY3RfaWQ7XG4gICAgICAgIHRoaXMucXVvdGFQcm9qZWN0SWQgPSBqc29uLnF1b3RhX3Byb2plY3RfaWQ7XG4gICAgfVxuICAgIGZyb21TdHJlYW0oaW5wdXRTdHJlYW0sIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5mcm9tU3RyZWFtQXN5bmMoaW5wdXRTdHJlYW0pLnRoZW4oKCkgPT4gY2FsbGJhY2soKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmcm9tU3RyZWFtQXN5bmMoaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICghaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcGFzcyBpbiBhIHN0cmVhbSBjb250YWluaW5nIHRoZSBzZXJ2aWNlIGFjY291bnQgYXV0aCBzZXR0aW5ncy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzID0gJyc7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbVxuICAgICAgICAgICAgICAgIC5zZXRFbmNvZGluZygndXRmOCcpXG4gICAgICAgICAgICAgICAgLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICAgICAgICAgICAgICAub24oJ2RhdGEnLCBjaHVuayA9PiAocyArPSBjaHVuaykpXG4gICAgICAgICAgICAgICAgLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2Uocyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvbUpTT04oZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEpXVCBjcmVkZW50aWFscyBpbnN0YW5jZSB1c2luZyBhbiBBUEkgS2V5IGZvciBhdXRoZW50aWNhdGlvbi5cbiAgICAgKiBAcGFyYW0gYXBpS2V5IFRoZSBBUEkgS2V5IGluIHN0cmluZyBmb3JtLlxuICAgICAqL1xuICAgIGZyb21BUElLZXkoYXBpS2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXBpS2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYW4gQVBJIEtleSBzdHJpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzaW5nIHRoZSBrZXkgb3Iga2V5RmlsZSBvbiB0aGUgSldUIGNsaWVudCwgb2J0YWluIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zXG4gICAgICogdGhlIGtleSBhbmQgdGhlIGNsaWVudCBlbWFpbC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDcmVkZW50aWFscygpIHtcbiAgICAgICAgaWYgKHRoaXMua2V5KSB7XG4gICAgICAgICAgICByZXR1cm4geyBwcml2YXRlX2tleTogdGhpcy5rZXksIGNsaWVudF9lbWFpbDogdGhpcy5lbWFpbCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMua2V5RmlsZSkge1xuICAgICAgICAgICAgY29uc3QgZ3Rva2VuID0gdGhpcy5jcmVhdGVHVG9rZW4oKTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWRzID0gYXdhaXQgZ3Rva2VuLmdldENyZWRlbnRpYWxzKHRoaXMua2V5RmlsZSk7XG4gICAgICAgICAgICByZXR1cm4geyBwcml2YXRlX2tleTogY3JlZHMucHJpdmF0ZUtleSwgY2xpZW50X2VtYWlsOiBjcmVkcy5jbGllbnRFbWFpbCB9O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQSBrZXkgb3IgYSBrZXlGaWxlIG11c3QgYmUgcHJvdmlkZWQgdG8gZ2V0Q3JlZGVudGlhbHMuJyk7XG4gICAgfVxufVxuZXhwb3J0cy5KV1QgPSBKV1Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qd3RjbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSldUIiwiZ3Rva2VuXzEiLCJyZXF1aXJlIiwiand0YWNjZXNzXzEiLCJvYXV0aDJjbGllbnRfMSIsIk9BdXRoMkNsaWVudCIsImNvbnN0cnVjdG9yIiwib3B0aW9uc09yRW1haWwiLCJrZXlGaWxlIiwia2V5Iiwic2NvcGVzIiwic3ViamVjdCIsImtleUlkIiwib3B0cyIsImVtYWlsIiwiZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzIiwiZm9yY2VSZWZyZXNoT25GYWlsdXJlIiwiYWRkaXRpb25hbENsYWltcyIsImNyZWRlbnRpYWxzIiwicmVmcmVzaF90b2tlbiIsImV4cGlyeV9kYXRlIiwiY3JlYXRlU2NvcGVkIiwiZ2V0UmVxdWVzdE1ldGFkYXRhQXN5bmMiLCJ1cmwiLCJkZWZhdWx0U2VydmljZVBhdGgiLCJ1c2VTZWxmU2lnbmVkSldUIiwiaGFzVXNlclNjb3BlcyIsInVzZUpXVEFjY2Vzc1dpdGhTY29wZSIsImhhc0FueVNjb3BlcyIsImFwaUtleSIsInRhcmdldF9hdWRpZW5jZSIsInRva2VucyIsInJlZnJlc2hUb2tlbiIsImhlYWRlcnMiLCJhZGRTaGFyZWRNZXRhZGF0YUhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwiaWRfdG9rZW4iLCJhY2Nlc3MiLCJKV1RBY2Nlc3MiLCJkZWZhdWx0U2NvcGVzIiwiZ2V0UmVxdWVzdEhlYWRlcnMiLCJ1bmRlZmluZWQiLCJmZXRjaElkVG9rZW4iLCJ0YXJnZXRBdWRpZW5jZSIsImd0b2tlbiIsIkdvb2dsZVRva2VuIiwiaXNzIiwic3ViIiwic2NvcGUiLCJ0cmFuc3BvcnRlciIsImdldFRva2VuIiwiZm9yY2VSZWZyZXNoIiwiaWRUb2tlbiIsIkVycm9yIiwibGVuZ3RoIiwiYXV0aG9yaXplIiwiY2FsbGJhY2siLCJhdXRob3JpemVBc3luYyIsInRoZW4iLCJyIiwicmVzdWx0IiwicmVmcmVzaFRva2VuTm9DYWNoZSIsImNyZWF0ZUdUb2tlbiIsInRva2VuIiwiaXNUb2tlbkV4cGlyaW5nIiwiYWNjZXNzX3Rva2VuIiwidG9rZW5fdHlwZSIsImV4cGlyZXNBdCIsImVtaXQiLCJyZXMiLCJmcm9tSlNPTiIsImpzb24iLCJjbGllbnRfZW1haWwiLCJwcml2YXRlX2tleSIsInByaXZhdGVfa2V5X2lkIiwicHJvamVjdElkIiwicHJvamVjdF9pZCIsInF1b3RhUHJvamVjdElkIiwicXVvdGFfcHJvamVjdF9pZCIsImZyb21TdHJlYW0iLCJpbnB1dFN0cmVhbSIsImZyb21TdHJlYW1Bc3luYyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicyIsInNldEVuY29kaW5nIiwib24iLCJjaHVuayIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJlIiwiZnJvbUFQSUtleSIsImdldENyZWRlbnRpYWxzIiwiY3JlZHMiLCJwcml2YXRlS2V5IiwiY2xpZW50RW1haWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/jwtclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/loginticket.js":
/*!************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/loginticket.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2014 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LoginTicket = void 0;\nclass LoginTicket {\n    /**\n     * Create a simple class to extract user ID from an ID Token\n     *\n     * @param {string} env Envelope of the jwt\n     * @param {TokenPayload} pay Payload of the jwt\n     * @constructor\n     */ constructor(env, pay){\n        this.envelope = env;\n        this.payload = pay;\n    }\n    getEnvelope() {\n        return this.envelope;\n    }\n    getPayload() {\n        return this.payload;\n    }\n    /**\n     * Create a simple class to extract user ID from an ID Token\n     *\n     * @return The user ID\n     */ getUserId() {\n        const payload = this.getPayload();\n        if (payload && payload.sub) {\n            return payload.sub;\n        }\n        return null;\n    }\n    /**\n     * Returns attributes from the login ticket.  This can contain\n     * various information about the user session.\n     *\n     * @return The envelope and payload\n     */ getAttributes() {\n        return {\n            envelope: this.getEnvelope(),\n            payload: this.getPayload()\n        };\n    }\n}\nexports.LoginTicket = LoginTicket; //# sourceMappingURL=loginticket.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9sb2dpbnRpY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1CQUFtQixHQUFHLEtBQUs7QUFDM0IsTUFBTUU7SUFDRjs7Ozs7O0tBTUMsR0FDREMsWUFBWUMsR0FBRyxFQUFFQyxHQUFHLENBQUU7UUFDbEIsSUFBSSxDQUFDQyxRQUFRLEdBQUdGO1FBQ2hCLElBQUksQ0FBQ0csT0FBTyxHQUFHRjtJQUNuQjtJQUNBRyxjQUFjO1FBQ1YsT0FBTyxJQUFJLENBQUNGLFFBQVE7SUFDeEI7SUFDQUcsYUFBYTtRQUNULE9BQU8sSUFBSSxDQUFDRixPQUFPO0lBQ3ZCO0lBQ0E7Ozs7S0FJQyxHQUNERyxZQUFZO1FBQ1IsTUFBTUgsVUFBVSxJQUFJLENBQUNFLFVBQVU7UUFDL0IsSUFBSUYsV0FBV0EsUUFBUUksR0FBRyxFQUFFO1lBQ3hCLE9BQU9KLFFBQVFJLEdBQUc7UUFDdEI7UUFDQSxPQUFPO0lBQ1g7SUFDQTs7Ozs7S0FLQyxHQUNEQyxnQkFBZ0I7UUFDWixPQUFPO1lBQUVOLFVBQVUsSUFBSSxDQUFDRSxXQUFXO1lBQUlELFNBQVMsSUFBSSxDQUFDRSxVQUFVO1FBQUc7SUFDdEU7QUFDSjtBQUNBVCxtQkFBbUIsR0FBR0UsYUFDdEIsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvbG9naW50aWNrZXQuanM/Zjc5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE0IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2dpblRpY2tldCA9IHZvaWQgMDtcbmNsYXNzIExvZ2luVGlja2V0IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzaW1wbGUgY2xhc3MgdG8gZXh0cmFjdCB1c2VyIElEIGZyb20gYW4gSUQgVG9rZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbnYgRW52ZWxvcGUgb2YgdGhlIGp3dFxuICAgICAqIEBwYXJhbSB7VG9rZW5QYXlsb2FkfSBwYXkgUGF5bG9hZCBvZiB0aGUgand0XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZW52LCBwYXkpIHtcbiAgICAgICAgdGhpcy5lbnZlbG9wZSA9IGVudjtcbiAgICAgICAgdGhpcy5wYXlsb2FkID0gcGF5O1xuICAgIH1cbiAgICBnZXRFbnZlbG9wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW52ZWxvcGU7XG4gICAgfVxuICAgIGdldFBheWxvYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBheWxvYWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHNpbXBsZSBjbGFzcyB0byBleHRyYWN0IHVzZXIgSUQgZnJvbSBhbiBJRCBUb2tlblxuICAgICAqXG4gICAgICogQHJldHVybiBUaGUgdXNlciBJRFxuICAgICAqL1xuICAgIGdldFVzZXJJZCgpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuZ2V0UGF5bG9hZCgpO1xuICAgICAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLnN1Yikge1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQuc3ViO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGF0dHJpYnV0ZXMgZnJvbSB0aGUgbG9naW4gdGlja2V0LiAgVGhpcyBjYW4gY29udGFpblxuICAgICAqIHZhcmlvdXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHVzZXIgc2Vzc2lvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gVGhlIGVudmVsb3BlIGFuZCBwYXlsb2FkXG4gICAgICovXG4gICAgZ2V0QXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHsgZW52ZWxvcGU6IHRoaXMuZ2V0RW52ZWxvcGUoKSwgcGF5bG9hZDogdGhpcy5nZXRQYXlsb2FkKCkgfTtcbiAgICB9XG59XG5leHBvcnRzLkxvZ2luVGlja2V0ID0gTG9naW5UaWNrZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dpbnRpY2tldC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJMb2dpblRpY2tldCIsImNvbnN0cnVjdG9yIiwiZW52IiwicGF5IiwiZW52ZWxvcGUiLCJwYXlsb2FkIiwiZ2V0RW52ZWxvcGUiLCJnZXRQYXlsb2FkIiwiZ2V0VXNlcklkIiwic3ViIiwiZ2V0QXR0cmlidXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/loginticket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js":
/*!*************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/oauth2client.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.OAuth2Client = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst formatEcdsa = __webpack_require__(/*! ecdsa-sig-formatter */ \"(rsc)/./node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js\");\nconst crypto_1 = __webpack_require__(/*! ../crypto/crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js\");\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst loginticket_1 = __webpack_require__(/*! ./loginticket */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/loginticket.js\");\nvar CodeChallengeMethod;\n(function(CodeChallengeMethod) {\n    CodeChallengeMethod[\"Plain\"] = \"plain\";\n    CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\nvar CertificateFormat;\n(function(CertificateFormat) {\n    CertificateFormat[\"PEM\"] = \"PEM\";\n    CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));\nclass OAuth2Client extends authclient_1.AuthClient {\n    constructor(optionsOrClientId, clientSecret, redirectUri){\n        super();\n        this.certificateCache = {};\n        this.certificateExpiry = null;\n        this.certificateCacheFormat = CertificateFormat.PEM;\n        this.refreshTokenPromises = new Map();\n        const opts = optionsOrClientId && typeof optionsOrClientId === \"object\" ? optionsOrClientId : {\n            clientId: optionsOrClientId,\n            clientSecret,\n            redirectUri\n        };\n        this._clientId = opts.clientId;\n        this._clientSecret = opts.clientSecret;\n        this.redirectUri = opts.redirectUri;\n        this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n        this.forceRefreshOnFailure = !!opts.forceRefreshOnFailure;\n    }\n    /**\n     * Generates URL for consent page landing.\n     * @param opts Options.\n     * @return URL to consent page.\n     */ generateAuthUrl(opts = {}) {\n        if (opts.code_challenge_method && !opts.code_challenge) {\n            throw new Error(\"If a code_challenge_method is provided, code_challenge must be included.\");\n        }\n        opts.response_type = opts.response_type || \"code\";\n        opts.client_id = opts.client_id || this._clientId;\n        opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n        // Allow scopes to be passed either as array or a string\n        if (Array.isArray(opts.scope)) {\n            opts.scope = opts.scope.join(\" \");\n        }\n        const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n        return rootUrl + \"?\" + querystring.stringify(opts);\n    }\n    generateCodeVerifier() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error(\"generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.\");\n    }\n    /**\n     * Convenience method to automatically generate a code_verifier, and its\n     * resulting SHA256. If used, this must be paired with a S256\n     * code_challenge_method.\n     *\n     * For a full example see:\n     * https://github.com/googleapis/google-auth-library-nodejs/blob/main/samples/oauth2-codeVerifier.js\n     */ async generateCodeVerifierAsync() {\n        // base64 encoding uses 6 bits per character, and we want to generate128\n        // characters. 6*128/8 = 96.\n        const crypto = (0, crypto_1.createCrypto)();\n        const randomString = crypto.randomBytesBase64(96);\n        // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n        // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n        // swapping out a few chars.\n        const codeVerifier = randomString.replace(/\\+/g, \"~\").replace(/=/g, \"_\").replace(/\\//g, \"-\");\n        // Generate the base64 encoded SHA256\n        const unencodedCodeChallenge = await crypto.sha256DigestBase64(codeVerifier);\n        // We need to use base64UrlEncoding instead of standard base64\n        const codeChallenge = unencodedCodeChallenge.split(\"=\")[0].replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n        return {\n            codeVerifier,\n            codeChallenge\n        };\n    }\n    getToken(codeOrOptions, callback) {\n        const options = typeof codeOrOptions === \"string\" ? {\n            code: codeOrOptions\n        } : codeOrOptions;\n        if (callback) {\n            this.getTokenAsync(options).then((r)=>callback(null, r.tokens, r.res), (e)=>callback(e, null, e.response));\n        } else {\n            return this.getTokenAsync(options);\n        }\n    }\n    async getTokenAsync(options) {\n        const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n        const values = {\n            code: options.code,\n            client_id: options.client_id || this._clientId,\n            client_secret: this._clientSecret,\n            redirect_uri: options.redirect_uri || this.redirectUri,\n            grant_type: \"authorization_code\",\n            code_verifier: options.codeVerifier\n        };\n        const res = await this.transporter.request({\n            method: \"POST\",\n            url,\n            data: querystring.stringify(values),\n            headers: {\n                \"Content-Type\": \"application/x-www-form-urlencoded\"\n            }\n        });\n        const tokens = res.data;\n        if (res.data && res.data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit(\"tokens\", tokens);\n        return {\n            tokens,\n            res\n        };\n    }\n    /**\n     * Refreshes the access token.\n     * @param refresh_token Existing refresh token.\n     * @private\n     */ async refreshToken(refreshToken) {\n        if (!refreshToken) {\n            return this.refreshTokenNoCache(refreshToken);\n        }\n        // If a request to refresh using the same token has started,\n        // return the same promise.\n        if (this.refreshTokenPromises.has(refreshToken)) {\n            return this.refreshTokenPromises.get(refreshToken);\n        }\n        const p = this.refreshTokenNoCache(refreshToken).then((r)=>{\n            this.refreshTokenPromises.delete(refreshToken);\n            return r;\n        }, (e)=>{\n            this.refreshTokenPromises.delete(refreshToken);\n            throw e;\n        });\n        this.refreshTokenPromises.set(refreshToken, p);\n        return p;\n    }\n    async refreshTokenNoCache(refreshToken) {\n        var _a;\n        if (!refreshToken) {\n            throw new Error(\"No refresh token is set.\");\n        }\n        const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n        const data = {\n            refresh_token: refreshToken,\n            client_id: this._clientId,\n            client_secret: this._clientSecret,\n            grant_type: \"refresh_token\"\n        };\n        let res;\n        try {\n            // request for new token\n            res = await this.transporter.request({\n                method: \"POST\",\n                url,\n                data: querystring.stringify(data),\n                headers: {\n                    \"Content-Type\": \"application/x-www-form-urlencoded\"\n                }\n            });\n        } catch (e) {\n            if (e instanceof gaxios_1.GaxiosError && e.message === \"invalid_grant\" && ((_a = e.response) === null || _a === void 0 ? void 0 : _a.data) && /ReAuth/i.test(e.response.data.error_description)) {\n                e.message = JSON.stringify(e.response.data);\n            }\n            throw e;\n        }\n        const tokens = res.data;\n        // TODO: de-duplicate this code from a few spots\n        if (res.data && res.data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit(\"tokens\", tokens);\n        return {\n            tokens,\n            res\n        };\n    }\n    refreshAccessToken(callback) {\n        if (callback) {\n            this.refreshAccessTokenAsync().then((r)=>callback(null, r.credentials, r.res), callback);\n        } else {\n            return this.refreshAccessTokenAsync();\n        }\n    }\n    async refreshAccessTokenAsync() {\n        const r = await this.refreshToken(this.credentials.refresh_token);\n        const tokens = r.tokens;\n        tokens.refresh_token = this.credentials.refresh_token;\n        this.credentials = tokens;\n        return {\n            credentials: this.credentials,\n            res: r.res\n        };\n    }\n    getAccessToken(callback) {\n        if (callback) {\n            this.getAccessTokenAsync().then((r)=>callback(null, r.token, r.res), callback);\n        } else {\n            return this.getAccessTokenAsync();\n        }\n    }\n    async getAccessTokenAsync() {\n        const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n        if (shouldRefresh) {\n            if (!this.credentials.refresh_token) {\n                if (this.refreshHandler) {\n                    const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n                    if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n                        this.setCredentials(refreshedAccessToken);\n                        return {\n                            token: this.credentials.access_token\n                        };\n                    }\n                } else {\n                    throw new Error(\"No refresh token or refresh handler callback is set.\");\n                }\n            }\n            const r = await this.refreshAccessTokenAsync();\n            if (!r.credentials || r.credentials && !r.credentials.access_token) {\n                throw new Error(\"Could not refresh access token.\");\n            }\n            return {\n                token: r.credentials.access_token,\n                res: r.res\n            };\n        } else {\n            return {\n                token: this.credentials.access_token\n            };\n        }\n    }\n    /**\n     * The main authentication interface.  It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * In OAuth2Client, the result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     * @param url The optional url being authorized\n     */ async getRequestHeaders(url) {\n        const headers = (await this.getRequestMetadataAsync(url)).headers;\n        return headers;\n    }\n    async getRequestMetadataAsync(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n    url) {\n        const thisCreds = this.credentials;\n        if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey && !this.refreshHandler) {\n            throw new Error(\"No access, refresh token, API key or refresh handler callback is set.\");\n        }\n        if (thisCreds.access_token && !this.isTokenExpiring()) {\n            thisCreds.token_type = thisCreds.token_type || \"Bearer\";\n            const headers = {\n                Authorization: thisCreds.token_type + \" \" + thisCreds.access_token\n            };\n            return {\n                headers: this.addSharedMetadataHeaders(headers)\n            };\n        }\n        // If refreshHandler exists, call processAndValidateRefreshHandler().\n        if (this.refreshHandler) {\n            const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n            if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n                this.setCredentials(refreshedAccessToken);\n                const headers = {\n                    Authorization: \"Bearer \" + this.credentials.access_token\n                };\n                return {\n                    headers: this.addSharedMetadataHeaders(headers)\n                };\n            }\n        }\n        if (this.apiKey) {\n            return {\n                headers: {\n                    \"X-Goog-Api-Key\": this.apiKey\n                }\n            };\n        }\n        let r = null;\n        let tokens = null;\n        try {\n            r = await this.refreshToken(thisCreds.refresh_token);\n            tokens = r.tokens;\n        } catch (err) {\n            const e = err;\n            if (e.response && (e.response.status === 403 || e.response.status === 404)) {\n                e.message = `Could not refresh access token: ${e.message}`;\n            }\n            throw e;\n        }\n        const credentials = this.credentials;\n        credentials.token_type = credentials.token_type || \"Bearer\";\n        tokens.refresh_token = credentials.refresh_token;\n        this.credentials = tokens;\n        const headers = {\n            Authorization: credentials.token_type + \" \" + tokens.access_token\n        };\n        return {\n            headers: this.addSharedMetadataHeaders(headers),\n            res: r.res\n        };\n    }\n    /**\n     * Generates an URL to revoke the given token.\n     * @param token The existing token to be revoked.\n     */ static getRevokeTokenUrl(token) {\n        const parameters = querystring.stringify({\n            token\n        });\n        return `${OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_}?${parameters}`;\n    }\n    revokeToken(token, callback) {\n        const opts = {\n            url: OAuth2Client.getRevokeTokenUrl(token),\n            method: \"POST\"\n        };\n        if (callback) {\n            this.transporter.request(opts).then((r)=>callback(null, r), callback);\n        } else {\n            return this.transporter.request(opts);\n        }\n    }\n    revokeCredentials(callback) {\n        if (callback) {\n            this.revokeCredentialsAsync().then((res)=>callback(null, res), callback);\n        } else {\n            return this.revokeCredentialsAsync();\n        }\n    }\n    async revokeCredentialsAsync() {\n        const token = this.credentials.access_token;\n        this.credentials = {};\n        if (token) {\n            return this.revokeToken(token);\n        } else {\n            throw new Error(\"No access token to revoke.\");\n        }\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then((r)=>callback(null, r), (e)=>{\n                return callback(e, e.response);\n            });\n        } else {\n            return this.requestAsync(opts);\n        }\n    }\n    async requestAsync(opts, retry = false) {\n        let r2;\n        try {\n            const r = await this.getRequestMetadataAsync(opts.url);\n            opts.headers = opts.headers || {};\n            if (r.headers && r.headers[\"x-goog-user-project\"]) {\n                opts.headers[\"x-goog-user-project\"] = r.headers[\"x-goog-user-project\"];\n            }\n            if (r.headers && r.headers.Authorization) {\n                opts.headers.Authorization = r.headers.Authorization;\n            }\n            if (this.apiKey) {\n                opts.headers[\"X-Goog-Api-Key\"] = this.apiKey;\n            }\n            r2 = await this.transporter.request(opts);\n        } catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - An access_token and refresh_token were available, but either no\n                //   expiry_date was available or the forceRefreshOnFailure flag is set.\n                //   The absent expiry_date case can happen when developers stash the\n                //   access_token and refresh_token for later use, but the access_token\n                //   fails on the first try because it's expired. Some developers may\n                //   choose to enable forceRefreshOnFailure to mitigate time-related\n                //   errors.\n                // Or the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - No refresh_token was available\n                // - An access_token and a refreshHandler callback were available, but\n                //   either no expiry_date was available or the forceRefreshOnFailure\n                //   flag is set. The access_token fails on the first try because it's\n                //   expired. Some developers may choose to enable forceRefreshOnFailure\n                //   to mitigate time-related errors.\n                const mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure);\n                const mayRequireRefreshWithNoRefreshToken = this.credentials && this.credentials.access_token && !this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure) && this.refreshHandler;\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n                    await this.refreshAccessTokenAsync();\n                    return this.requestAsync(opts, true);\n                } else if (!retry && isAuthErr && !isReadableStream && mayRequireRefreshWithNoRefreshToken) {\n                    const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n                    if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n                        this.setCredentials(refreshedAccessToken);\n                    }\n                    return this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return r2;\n    }\n    verifyIdToken(options, callback) {\n        // This function used to accept two arguments instead of an options object.\n        // Check the types to help users upgrade with less pain.\n        // This check can be removed after a 2.0 release.\n        if (callback && typeof callback !== \"function\") {\n            throw new Error(\"This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.\");\n        }\n        if (callback) {\n            this.verifyIdTokenAsync(options).then((r)=>callback(null, r), callback);\n        } else {\n            return this.verifyIdTokenAsync(options);\n        }\n    }\n    async verifyIdTokenAsync(options) {\n        if (!options.idToken) {\n            throw new Error(\"The verifyIdToken method requires an ID Token\");\n        }\n        const response = await this.getFederatedSignonCertsAsync();\n        const login = await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\n        return login;\n    }\n    /**\n     * Obtains information about the provisioned access token.  Especially useful\n     * if you want to check the scopes that were provisioned to a given token.\n     *\n     * @param accessToken Required.  The Access Token for which you want to get\n     * user info.\n     */ async getTokenInfo(accessToken) {\n        const { data } = await this.transporter.request({\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/x-www-form-urlencoded\",\n                Authorization: `Bearer ${accessToken}`\n            },\n            url: OAuth2Client.GOOGLE_TOKEN_INFO_URL\n        });\n        const info = Object.assign({\n            expiry_date: new Date().getTime() + data.expires_in * 1000,\n            scopes: data.scope.split(\" \")\n        }, data);\n        delete info.expires_in;\n        delete info.scope;\n        return info;\n    }\n    getFederatedSignonCerts(callback) {\n        if (callback) {\n            this.getFederatedSignonCertsAsync().then((r)=>callback(null, r.certs, r.res), callback);\n        } else {\n            return this.getFederatedSignonCertsAsync();\n        }\n    }\n    async getFederatedSignonCertsAsync() {\n        const nowTime = new Date().getTime();\n        const format = (0, crypto_1.hasBrowserCrypto)() ? CertificateFormat.JWK : CertificateFormat.PEM;\n        if (this.certificateExpiry && nowTime < this.certificateExpiry.getTime() && this.certificateCacheFormat === format) {\n            return {\n                certs: this.certificateCache,\n                format\n            };\n        }\n        let res;\n        let url;\n        switch(format){\n            case CertificateFormat.PEM:\n                url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;\n                break;\n            case CertificateFormat.JWK:\n                url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;\n                break;\n            default:\n                throw new Error(`Unsupported certificate format ${format}`);\n        }\n        try {\n            res = await this.transporter.request({\n                url\n            });\n        } catch (e) {\n            if (e instanceof Error) {\n                e.message = `Failed to retrieve verification certificates: ${e.message}`;\n            }\n            throw e;\n        }\n        const cacheControl = res ? res.headers[\"cache-control\"] : undefined;\n        let cacheAge = -1;\n        if (cacheControl) {\n            const pattern = new RegExp(\"max-age=([0-9]*)\");\n            const regexResult = pattern.exec(cacheControl);\n            if (regexResult && regexResult.length === 2) {\n                // Cache results with max-age (in seconds)\n                cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n            }\n        }\n        let certificates = {};\n        switch(format){\n            case CertificateFormat.PEM:\n                certificates = res.data;\n                break;\n            case CertificateFormat.JWK:\n                for (const key of res.data.keys){\n                    certificates[key.kid] = key;\n                }\n                break;\n            default:\n                throw new Error(`Unsupported certificate format ${format}`);\n        }\n        const now = new Date();\n        this.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n        this.certificateCache = certificates;\n        this.certificateCacheFormat = format;\n        return {\n            certs: certificates,\n            format,\n            res\n        };\n    }\n    getIapPublicKeys(callback) {\n        if (callback) {\n            this.getIapPublicKeysAsync().then((r)=>callback(null, r.pubkeys, r.res), callback);\n        } else {\n            return this.getIapPublicKeysAsync();\n        }\n    }\n    async getIapPublicKeysAsync() {\n        let res;\n        const url = OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_;\n        try {\n            res = await this.transporter.request({\n                url\n            });\n        } catch (e) {\n            if (e instanceof Error) {\n                e.message = `Failed to retrieve verification certificates: ${e.message}`;\n            }\n            throw e;\n        }\n        return {\n            pubkeys: res.data,\n            res\n        };\n    }\n    verifySignedJwtWithCerts() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error(\"verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.\");\n    }\n    /**\n     * Verify the id token is signed with the correct certificate\n     * and is from the correct audience.\n     * @param jwt The jwt to verify (The ID Token in this case).\n     * @param certs The array of certs to test the jwt against.\n     * @param requiredAudience The audience to test the jwt against.\n     * @param issuers The allowed issuers of the jwt (Optional).\n     * @param maxExpiry The max expiry the certificate can be (Optional).\n     * @return Returns a promise resolving to LoginTicket on verification.\n     */ async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\n        const crypto = (0, crypto_1.createCrypto)();\n        if (!maxExpiry) {\n            maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n        }\n        const segments = jwt.split(\".\");\n        if (segments.length !== 3) {\n            throw new Error(\"Wrong number of segments in token: \" + jwt);\n        }\n        const signed = segments[0] + \".\" + segments[1];\n        let signature = segments[2];\n        let envelope;\n        let payload;\n        try {\n            envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n        } catch (err) {\n            if (err instanceof Error) {\n                err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;\n            }\n            throw err;\n        }\n        if (!envelope) {\n            throw new Error(\"Can't parse token envelope: \" + segments[0]);\n        }\n        try {\n            payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n        } catch (err) {\n            if (err instanceof Error) {\n                err.message = `Can't parse token payload '${segments[0]}`;\n            }\n            throw err;\n        }\n        if (!payload) {\n            throw new Error(\"Can't parse token payload: \" + segments[1]);\n        }\n        if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {\n            // If this is not present, then there's no reason to attempt verification\n            throw new Error(\"No pem found for envelope: \" + JSON.stringify(envelope));\n        }\n        const cert = certs[envelope.kid];\n        if (envelope.alg === \"ES256\") {\n            signature = formatEcdsa.joseToDer(signature, \"ES256\").toString(\"base64\");\n        }\n        const verified = await crypto.verify(cert, signed, signature);\n        if (!verified) {\n            throw new Error(\"Invalid token signature: \" + jwt);\n        }\n        if (!payload.iat) {\n            throw new Error(\"No issue time in token: \" + JSON.stringify(payload));\n        }\n        if (!payload.exp) {\n            throw new Error(\"No expiration time in token: \" + JSON.stringify(payload));\n        }\n        const iat = Number(payload.iat);\n        if (isNaN(iat)) throw new Error(\"iat field using invalid format\");\n        const exp = Number(payload.exp);\n        if (isNaN(exp)) throw new Error(\"exp field using invalid format\");\n        const now = new Date().getTime() / 1000;\n        if (exp >= now + maxExpiry) {\n            throw new Error(\"Expiration time too far in future: \" + JSON.stringify(payload));\n        }\n        const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n        const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n        if (now < earliest) {\n            throw new Error(\"Token used too early, \" + now + \" < \" + earliest + \": \" + JSON.stringify(payload));\n        }\n        if (now > latest) {\n            throw new Error(\"Token used too late, \" + now + \" > \" + latest + \": \" + JSON.stringify(payload));\n        }\n        if (issuers && issuers.indexOf(payload.iss) < 0) {\n            throw new Error(\"Invalid issuer, expected one of [\" + issuers + \"], but got \" + payload.iss);\n        }\n        // Check the audience matches if we have one\n        if (typeof requiredAudience !== \"undefined\" && requiredAudience !== null) {\n            const aud = payload.aud;\n            let audVerified = false;\n            // If the requiredAudience is an array, check if it contains token\n            // audience\n            if (requiredAudience.constructor === Array) {\n                audVerified = requiredAudience.indexOf(aud) > -1;\n            } else {\n                audVerified = aud === requiredAudience;\n            }\n            if (!audVerified) {\n                throw new Error(\"Wrong recipient, payload audience != requiredAudience\");\n            }\n        }\n        return new loginticket_1.LoginTicket(envelope, payload);\n    }\n    /**\n     * Returns a promise that resolves with AccessTokenResponse type if\n     * refreshHandler is defined.\n     * If not, nothing is returned.\n     */ async processAndValidateRefreshHandler() {\n        if (this.refreshHandler) {\n            const accessTokenResponse = await this.refreshHandler();\n            if (!accessTokenResponse.access_token) {\n                throw new Error(\"No access token is returned by the refreshHandler callback.\");\n            }\n            return accessTokenResponse;\n        }\n        return;\n    }\n    /**\n     * Returns true if a token is expired or will expire within\n     * eagerRefreshThresholdMillismilliseconds.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     */ isTokenExpiring() {\n        const expiryDate = this.credentials.expiry_date;\n        return expiryDate ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis : false;\n    }\n}\nexports.OAuth2Client = OAuth2Client;\nOAuth2Client.GOOGLE_TOKEN_INFO_URL = \"https://oauth2.googleapis.com/tokeninfo\";\n/**\n * The base URL for auth endpoints.\n */ OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = \"https://accounts.google.com/o/oauth2/v2/auth\";\n/**\n * The base endpoint for token retrieval.\n */ OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = \"https://oauth2.googleapis.com/token\";\n/**\n * The base endpoint to revoke tokens.\n */ OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = \"https://oauth2.googleapis.com/revoke\";\n/**\n * Google Sign on certificates in PEM format.\n */ OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = \"https://www.googleapis.com/oauth2/v1/certs\";\n/**\n * Google Sign on certificates in JWK format.\n */ OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = \"https://www.googleapis.com/oauth2/v3/certs\";\n/**\n * Google Sign on certificates in JWK format.\n */ OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_ = \"https://www.gstatic.com/iap/verify/public_key\";\n/**\n * Clock skew - five minutes in seconds\n */ OAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\n * Max Token Lifetime is one day in seconds\n */ OAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n/**\n * The allowed oauth token issuers.\n */ OAuth2Client.ISSUERS_ = [\n    \"accounts.google.com\",\n    \"https://accounts.google.com\"\n]; //# sourceMappingURL=oauth2client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9vYXV0aDJjbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBR0EseUJBQXlCLEdBQUdBLDJCQUEyQixHQUFHLEtBQUs7QUFDdEYsTUFBTUssV0FBV0MsbUJBQU9BLENBQUMsOERBQVE7QUFDakMsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsZ0NBQWE7QUFDekMsTUFBTUUsU0FBU0YsbUJBQU9BLENBQUMsc0JBQVE7QUFDL0IsTUFBTUcsY0FBY0gsbUJBQU9BLENBQUMsZ0dBQXFCO0FBQ2pELE1BQU1JLFdBQVdKLG1CQUFPQSxDQUFDLDZGQUFrQjtBQUMzQyxNQUFNSyxlQUFlTCxtQkFBT0EsQ0FBQywyRkFBYztBQUMzQyxNQUFNTSxnQkFBZ0JOLG1CQUFPQSxDQUFDLDZGQUFlO0FBQzdDLElBQUlGO0FBQ0gsVUFBVUEsbUJBQW1CO0lBQzFCQSxtQkFBbUIsQ0FBQyxRQUFRLEdBQUc7SUFDL0JBLG1CQUFtQixDQUFDLE9BQU8sR0FBRztBQUNsQyxHQUFHQSxzQkFBc0JKLFFBQVFJLG1CQUFtQixJQUFLSixDQUFBQSwyQkFBMkIsR0FBRyxDQUFDO0FBQ3hGLElBQUlHO0FBQ0gsVUFBVUEsaUJBQWlCO0lBQ3hCQSxpQkFBaUIsQ0FBQyxNQUFNLEdBQUc7SUFDM0JBLGlCQUFpQixDQUFDLE1BQU0sR0FBRztBQUMvQixHQUFHQSxvQkFBb0JILFFBQVFHLGlCQUFpQixJQUFLSCxDQUFBQSx5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YyxJQUFJakksT0FBT0MsT0FBTyxLQUFLLElBQUksQ0FBQ3RELDJCQUEyQixHQUNyRTtJQUNWO0FBQ0o7QUFDQTVCLG9CQUFvQixHQUFHRTtBQUN2QkEsYUFBYWtKLHFCQUFxQixHQUFHO0FBQ3JDOztDQUVDLEdBQ0RsSixhQUFhd0MsNEJBQTRCLEdBQUc7QUFDNUM7O0NBRUMsR0FDRHhDLGFBQWFtRSx3QkFBd0IsR0FBRztBQUN4Qzs7Q0FFQyxHQUNEbkUsYUFBYXdILHlCQUF5QixHQUFHO0FBQ3pDOztDQUVDLEdBQ0R4SCxhQUFhMkosNkNBQTZDLEdBQUc7QUFDN0Q7O0NBRUMsR0FDRDNKLGFBQWE0Siw2Q0FBNkMsR0FBRztBQUM3RDs7Q0FFQyxHQUNENUosYUFBYThLLGlDQUFpQyxHQUFHO0FBQ2pEOztDQUVDLEdBQ0Q5SyxhQUFhd00sZ0JBQWdCLEdBQUc7QUFDaEM7O0NBRUMsR0FDRHhNLGFBQWFtTCx3QkFBd0IsR0FBRztBQUN4Qzs7Q0FFQyxHQUNEbkwsYUFBYThJLFFBQVEsR0FBRztJQUNwQjtJQUNBO0NBQ0gsRUFDRCx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9vYXV0aDJjbGllbnQuanM/Njg2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PQXV0aDJDbGllbnQgPSBleHBvcnRzLkNlcnRpZmljYXRlRm9ybWF0ID0gZXhwb3J0cy5Db2RlQ2hhbGxlbmdlTWV0aG9kID0gdm9pZCAwO1xuY29uc3QgZ2F4aW9zXzEgPSByZXF1aXJlKFwiZ2F4aW9zXCIpO1xuY29uc3QgcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwicXVlcnlzdHJpbmdcIik7XG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgZm9ybWF0RWNkc2EgPSByZXF1aXJlKFwiZWNkc2Etc2lnLWZvcm1hdHRlclwiKTtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIi4uL2NyeXB0by9jcnlwdG9cIik7XG5jb25zdCBhdXRoY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoY2xpZW50XCIpO1xuY29uc3QgbG9naW50aWNrZXRfMSA9IHJlcXVpcmUoXCIuL2xvZ2ludGlja2V0XCIpO1xudmFyIENvZGVDaGFsbGVuZ2VNZXRob2Q7XG4oZnVuY3Rpb24gKENvZGVDaGFsbGVuZ2VNZXRob2QpIHtcbiAgICBDb2RlQ2hhbGxlbmdlTWV0aG9kW1wiUGxhaW5cIl0gPSBcInBsYWluXCI7XG4gICAgQ29kZUNoYWxsZW5nZU1ldGhvZFtcIlMyNTZcIl0gPSBcIlMyNTZcIjtcbn0pKENvZGVDaGFsbGVuZ2VNZXRob2QgPSBleHBvcnRzLkNvZGVDaGFsbGVuZ2VNZXRob2QgfHwgKGV4cG9ydHMuQ29kZUNoYWxsZW5nZU1ldGhvZCA9IHt9KSk7XG52YXIgQ2VydGlmaWNhdGVGb3JtYXQ7XG4oZnVuY3Rpb24gKENlcnRpZmljYXRlRm9ybWF0KSB7XG4gICAgQ2VydGlmaWNhdGVGb3JtYXRbXCJQRU1cIl0gPSBcIlBFTVwiO1xuICAgIENlcnRpZmljYXRlRm9ybWF0W1wiSldLXCJdID0gXCJKV0tcIjtcbn0pKENlcnRpZmljYXRlRm9ybWF0ID0gZXhwb3J0cy5DZXJ0aWZpY2F0ZUZvcm1hdCB8fCAoZXhwb3J0cy5DZXJ0aWZpY2F0ZUZvcm1hdCA9IHt9KSk7XG5jbGFzcyBPQXV0aDJDbGllbnQgZXh0ZW5kcyBhdXRoY2xpZW50XzEuQXV0aENsaWVudCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9uc09yQ2xpZW50SWQsIGNsaWVudFNlY3JldCwgcmVkaXJlY3RVcmkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jZXJ0aWZpY2F0ZUNhY2hlID0ge307XG4gICAgICAgIHRoaXMuY2VydGlmaWNhdGVFeHBpcnkgPSBudWxsO1xuICAgICAgICB0aGlzLmNlcnRpZmljYXRlQ2FjaGVGb3JtYXQgPSBDZXJ0aWZpY2F0ZUZvcm1hdC5QRU07XG4gICAgICAgIHRoaXMucmVmcmVzaFRva2VuUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zT3JDbGllbnRJZCAmJiB0eXBlb2Ygb3B0aW9uc09yQ2xpZW50SWQgPT09ICdvYmplY3QnXG4gICAgICAgICAgICA/IG9wdGlvbnNPckNsaWVudElkXG4gICAgICAgICAgICA6IHsgY2xpZW50SWQ6IG9wdGlvbnNPckNsaWVudElkLCBjbGllbnRTZWNyZXQsIHJlZGlyZWN0VXJpIH07XG4gICAgICAgIHRoaXMuX2NsaWVudElkID0gb3B0cy5jbGllbnRJZDtcbiAgICAgICAgdGhpcy5fY2xpZW50U2VjcmV0ID0gb3B0cy5jbGllbnRTZWNyZXQ7XG4gICAgICAgIHRoaXMucmVkaXJlY3RVcmkgPSBvcHRzLnJlZGlyZWN0VXJpO1xuICAgICAgICB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyA9XG4gICAgICAgICAgICBvcHRzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyB8fCA1ICogNjAgKiAxMDAwO1xuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSA9ICEhb3B0cy5mb3JjZVJlZnJlc2hPbkZhaWx1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBVUkwgZm9yIGNvbnNlbnQgcGFnZSBsYW5kaW5nLlxuICAgICAqIEBwYXJhbSBvcHRzIE9wdGlvbnMuXG4gICAgICogQHJldHVybiBVUkwgdG8gY29uc2VudCBwYWdlLlxuICAgICAqL1xuICAgIGdlbmVyYXRlQXV0aFVybChvcHRzID0ge30pIHtcbiAgICAgICAgaWYgKG9wdHMuY29kZV9jaGFsbGVuZ2VfbWV0aG9kICYmICFvcHRzLmNvZGVfY2hhbGxlbmdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lmIGEgY29kZV9jaGFsbGVuZ2VfbWV0aG9kIGlzIHByb3ZpZGVkLCBjb2RlX2NoYWxsZW5nZSBtdXN0IGJlIGluY2x1ZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMucmVzcG9uc2VfdHlwZSA9IG9wdHMucmVzcG9uc2VfdHlwZSB8fCAnY29kZSc7XG4gICAgICAgIG9wdHMuY2xpZW50X2lkID0gb3B0cy5jbGllbnRfaWQgfHwgdGhpcy5fY2xpZW50SWQ7XG4gICAgICAgIG9wdHMucmVkaXJlY3RfdXJpID0gb3B0cy5yZWRpcmVjdF91cmkgfHwgdGhpcy5yZWRpcmVjdFVyaTtcbiAgICAgICAgLy8gQWxsb3cgc2NvcGVzIHRvIGJlIHBhc3NlZCBlaXRoZXIgYXMgYXJyYXkgb3IgYSBzdHJpbmdcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cy5zY29wZSkpIHtcbiAgICAgICAgICAgIG9wdHMuc2NvcGUgPSBvcHRzLnNjb3BlLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb290VXJsID0gT0F1dGgyQ2xpZW50LkdPT0dMRV9PQVVUSDJfQVVUSF9CQVNFX1VSTF87XG4gICAgICAgIHJldHVybiAocm9vdFVybCArXG4gICAgICAgICAgICAnPycgK1xuICAgICAgICAgICAgcXVlcnlzdHJpbmcuc3RyaW5naWZ5KG9wdHMpKTtcbiAgICB9XG4gICAgZ2VuZXJhdGVDb2RlVmVyaWZpZXIoKSB7XG4gICAgICAgIC8vIFRvIG1ha2UgdGhlIGNvZGUgY29tcGF0aWJsZSB3aXRoIGJyb3dzZXIgU3VidGxlQ3J5cHRvIHdlIG5lZWQgdG8gbWFrZVxuICAgICAgICAvLyB0aGlzIG1ldGhvZCBhc3luYy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZW5lcmF0ZUNvZGVWZXJpZmllciBpcyByZW1vdmVkLCBwbGVhc2UgdXNlIGdlbmVyYXRlQ29kZVZlcmlmaWVyQXN5bmMgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgYSBjb2RlX3ZlcmlmaWVyLCBhbmQgaXRzXG4gICAgICogcmVzdWx0aW5nIFNIQTI1Ni4gSWYgdXNlZCwgdGhpcyBtdXN0IGJlIHBhaXJlZCB3aXRoIGEgUzI1NlxuICAgICAqIGNvZGVfY2hhbGxlbmdlX21ldGhvZC5cbiAgICAgKlxuICAgICAqIEZvciBhIGZ1bGwgZXhhbXBsZSBzZWU6XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWFwaXMvZ29vZ2xlLWF1dGgtbGlicmFyeS1ub2RlanMvYmxvYi9tYWluL3NhbXBsZXMvb2F1dGgyLWNvZGVWZXJpZmllci5qc1xuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlQ29kZVZlcmlmaWVyQXN5bmMoKSB7XG4gICAgICAgIC8vIGJhc2U2NCBlbmNvZGluZyB1c2VzIDYgYml0cyBwZXIgY2hhcmFjdGVyLCBhbmQgd2Ugd2FudCB0byBnZW5lcmF0ZTEyOFxuICAgICAgICAvLyBjaGFyYWN0ZXJzLiA2KjEyOC84ID0gOTYuXG4gICAgICAgIGNvbnN0IGNyeXB0byA9ICgwLCBjcnlwdG9fMS5jcmVhdGVDcnlwdG8pKCk7XG4gICAgICAgIGNvbnN0IHJhbmRvbVN0cmluZyA9IGNyeXB0by5yYW5kb21CeXRlc0Jhc2U2NCg5Nik7XG4gICAgICAgIC8vIFRoZSB2YWxpZCBjaGFyYWN0ZXJzIGluIHRoZSBjb2RlX3ZlcmlmaWVyIGFyZSBbQS1aXS9bYS16XS9bMC05XS9cbiAgICAgICAgLy8gXCItXCIvXCIuXCIvXCJfXCIvXCJ+XCIuIEJhc2U2NCBlbmNvZGVkIHN0cmluZ3MgYXJlIHByZXR0eSBjbG9zZSwgc28gd2UncmUganVzdFxuICAgICAgICAvLyBzd2FwcGluZyBvdXQgYSBmZXcgY2hhcnMuXG4gICAgICAgIGNvbnN0IGNvZGVWZXJpZmllciA9IHJhbmRvbVN0cmluZ1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xcKy9nLCAnficpXG4gICAgICAgICAgICAucmVwbGFjZSgvPS9nLCAnXycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwvL2csICctJyk7XG4gICAgICAgIC8vIEdlbmVyYXRlIHRoZSBiYXNlNjQgZW5jb2RlZCBTSEEyNTZcbiAgICAgICAgY29uc3QgdW5lbmNvZGVkQ29kZUNoYWxsZW5nZSA9IGF3YWl0IGNyeXB0by5zaGEyNTZEaWdlc3RCYXNlNjQoY29kZVZlcmlmaWVyKTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byB1c2UgYmFzZTY0VXJsRW5jb2RpbmcgaW5zdGVhZCBvZiBzdGFuZGFyZCBiYXNlNjRcbiAgICAgICAgY29uc3QgY29kZUNoYWxsZW5nZSA9IHVuZW5jb2RlZENvZGVDaGFsbGVuZ2VcbiAgICAgICAgICAgIC5zcGxpdCgnPScpWzBdXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwrL2csICctJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC8vZywgJ18nKTtcbiAgICAgICAgcmV0dXJuIHsgY29kZVZlcmlmaWVyLCBjb2RlQ2hhbGxlbmdlIH07XG4gICAgfVxuICAgIGdldFRva2VuKGNvZGVPck9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2YgY29kZU9yT3B0aW9ucyA9PT0gJ3N0cmluZycgPyB7IGNvZGU6IGNvZGVPck9wdGlvbnMgfSA6IGNvZGVPck9wdGlvbnM7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5nZXRUb2tlbkFzeW5jKG9wdGlvbnMpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByLnRva2Vucywgci5yZXMpLCBlID0+IGNhbGxiYWNrKGUsIG51bGwsIGUucmVzcG9uc2UpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRva2VuQXN5bmMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VG9rZW5Bc3luYyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IE9BdXRoMkNsaWVudC5HT09HTEVfT0FVVEgyX1RPS0VOX1VSTF87XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHtcbiAgICAgICAgICAgIGNvZGU6IG9wdGlvbnMuY29kZSxcbiAgICAgICAgICAgIGNsaWVudF9pZDogb3B0aW9ucy5jbGllbnRfaWQgfHwgdGhpcy5fY2xpZW50SWQsXG4gICAgICAgICAgICBjbGllbnRfc2VjcmV0OiB0aGlzLl9jbGllbnRTZWNyZXQsXG4gICAgICAgICAgICByZWRpcmVjdF91cmk6IG9wdGlvbnMucmVkaXJlY3RfdXJpIHx8IHRoaXMucmVkaXJlY3RVcmksXG4gICAgICAgICAgICBncmFudF90eXBlOiAnYXV0aG9yaXphdGlvbl9jb2RlJyxcbiAgICAgICAgICAgIGNvZGVfdmVyaWZpZXI6IG9wdGlvbnMuY29kZVZlcmlmaWVyLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBkYXRhOiBxdWVyeXN0cmluZy5zdHJpbmdpZnkodmFsdWVzKSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0b2tlbnMgPSByZXMuZGF0YTtcbiAgICAgICAgaWYgKHJlcy5kYXRhICYmIHJlcy5kYXRhLmV4cGlyZXNfaW4pIHtcbiAgICAgICAgICAgIHRva2Vucy5leHBpcnlfZGF0ZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgcmVzLmRhdGEuZXhwaXJlc19pbiAqIDEwMDA7XG4gICAgICAgICAgICBkZWxldGUgdG9rZW5zLmV4cGlyZXNfaW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCd0b2tlbnMnLCB0b2tlbnMpO1xuICAgICAgICByZXR1cm4geyB0b2tlbnMsIHJlcyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgdGhlIGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAcGFyYW0gcmVmcmVzaF90b2tlbiBFeGlzdGluZyByZWZyZXNoIHRva2VuLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgcmVmcmVzaFRva2VuKHJlZnJlc2hUb2tlbikge1xuICAgICAgICBpZiAoIXJlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmcmVzaFRva2VuTm9DYWNoZShyZWZyZXNoVG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGEgcmVxdWVzdCB0byByZWZyZXNoIHVzaW5nIHRoZSBzYW1lIHRva2VuIGhhcyBzdGFydGVkLFxuICAgICAgICAvLyByZXR1cm4gdGhlIHNhbWUgcHJvbWlzZS5cbiAgICAgICAgaWYgKHRoaXMucmVmcmVzaFRva2VuUHJvbWlzZXMuaGFzKHJlZnJlc2hUb2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZnJlc2hUb2tlblByb21pc2VzLmdldChyZWZyZXNoVG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLnJlZnJlc2hUb2tlbk5vQ2FjaGUocmVmcmVzaFRva2VuKS50aGVuKHIgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoVG9rZW5Qcm9taXNlcy5kZWxldGUocmVmcmVzaFRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9LCBlID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFRva2VuUHJvbWlzZXMuZGVsZXRlKHJlZnJlc2hUb2tlbik7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWZyZXNoVG9rZW5Qcm9taXNlcy5zZXQocmVmcmVzaFRva2VuLCBwKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGFzeW5jIHJlZnJlc2hUb2tlbk5vQ2FjaGUocmVmcmVzaFRva2VuKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVmcmVzaCB0b2tlbiBpcyBzZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gT0F1dGgyQ2xpZW50LkdPT0dMRV9PQVVUSDJfVE9LRU5fVVJMXztcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbixcbiAgICAgICAgICAgIGNsaWVudF9pZDogdGhpcy5fY2xpZW50SWQsXG4gICAgICAgICAgICBjbGllbnRfc2VjcmV0OiB0aGlzLl9jbGllbnRTZWNyZXQsXG4gICAgICAgICAgICBncmFudF90eXBlOiAncmVmcmVzaF90b2tlbicsXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyByZXF1ZXN0IGZvciBuZXcgdG9rZW5cbiAgICAgICAgICAgIHJlcyA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGRhdGE6IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgZ2F4aW9zXzEuR2F4aW9zRXJyb3IgJiZcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPT09ICdpbnZhbGlkX2dyYW50JyAmJlxuICAgICAgICAgICAgICAgICgoX2EgPSBlLnJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0YSkgJiZcbiAgICAgICAgICAgICAgICAvUmVBdXRoL2kudGVzdChlLnJlc3BvbnNlLmRhdGEuZXJyb3JfZGVzY3JpcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZS5yZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9rZW5zID0gcmVzLmRhdGE7XG4gICAgICAgIC8vIFRPRE86IGRlLWR1cGxpY2F0ZSB0aGlzIGNvZGUgZnJvbSBhIGZldyBzcG90c1xuICAgICAgICBpZiAocmVzLmRhdGEgJiYgcmVzLmRhdGEuZXhwaXJlc19pbikge1xuICAgICAgICAgICAgdG9rZW5zLmV4cGlyeV9kYXRlID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyByZXMuZGF0YS5leHBpcmVzX2luICogMTAwMDtcbiAgICAgICAgICAgIGRlbGV0ZSB0b2tlbnMuZXhwaXJlc19pbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3Rva2VucycsIHRva2Vucyk7XG4gICAgICAgIHJldHVybiB7IHRva2VucywgcmVzIH07XG4gICAgfVxuICAgIHJlZnJlc2hBY2Nlc3NUb2tlbihjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKS50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgci5jcmVkZW50aWFscywgci5yZXMpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCkge1xuICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5yZWZyZXNoVG9rZW4odGhpcy5jcmVkZW50aWFscy5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gci50b2tlbnM7XG4gICAgICAgIHRva2Vucy5yZWZyZXNoX3Rva2VuID0gdGhpcy5jcmVkZW50aWFscy5yZWZyZXNoX3Rva2VuO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gdG9rZW5zO1xuICAgICAgICByZXR1cm4geyBjcmVkZW50aWFsczogdGhpcy5jcmVkZW50aWFscywgcmVzOiByLnJlcyB9O1xuICAgIH1cbiAgICBnZXRBY2Nlc3NUb2tlbihjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0QWNjZXNzVG9rZW5Bc3luYygpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByLnRva2VuLCByLnJlcyksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFjY2Vzc1Rva2VuQXN5bmMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRBY2Nlc3NUb2tlbkFzeW5jKCkge1xuICAgICAgICBjb25zdCBzaG91bGRSZWZyZXNoID0gIXRoaXMuY3JlZGVudGlhbHMuYWNjZXNzX3Rva2VuIHx8IHRoaXMuaXNUb2tlbkV4cGlyaW5nKCk7XG4gICAgICAgIGlmIChzaG91bGRSZWZyZXNoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY3JlZGVudGlhbHMucmVmcmVzaF90b2tlbikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlZnJlc2hIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZnJlc2hlZEFjY2Vzc1Rva2VuID0gYXdhaXQgdGhpcy5wcm9jZXNzQW5kVmFsaWRhdGVSZWZyZXNoSGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmcmVzaGVkQWNjZXNzVG9rZW4gPT09IG51bGwgfHwgcmVmcmVzaGVkQWNjZXNzVG9rZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZnJlc2hlZEFjY2Vzc1Rva2VuLmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDcmVkZW50aWFscyhyZWZyZXNoZWRBY2Nlc3NUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0b2tlbjogdGhpcy5jcmVkZW50aWFscy5hY2Nlc3NfdG9rZW4gfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZWZyZXNoIHRva2VuIG9yIHJlZnJlc2ggaGFuZGxlciBjYWxsYmFjayBpcyBzZXQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMucmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKTtcbiAgICAgICAgICAgIGlmICghci5jcmVkZW50aWFscyB8fCAoci5jcmVkZW50aWFscyAmJiAhci5jcmVkZW50aWFscy5hY2Nlc3NfdG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcmVmcmVzaCBhY2Nlc3MgdG9rZW4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyB0b2tlbjogci5jcmVkZW50aWFscy5hY2Nlc3NfdG9rZW4sIHJlczogci5yZXMgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IHRva2VuOiB0aGlzLmNyZWRlbnRpYWxzLmFjY2Vzc190b2tlbiB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtYWluIGF1dGhlbnRpY2F0aW9uIGludGVyZmFjZS4gIEl0IHRha2VzIGFuIG9wdGlvbmFsIHVybCB3aGljaCB3aGVuXG4gICAgICogcHJlc2VudCBpcyB0aGUgZW5kcG9pbnQgYmVpbmcgYWNjZXNzZWQsIGFuZCByZXR1cm5zIGEgUHJvbWlzZSB3aGljaFxuICAgICAqIHJlc29sdmVzIHdpdGggYXV0aG9yaXphdGlvbiBoZWFkZXIgZmllbGRzLlxuICAgICAqXG4gICAgICogSW4gT0F1dGgyQ2xpZW50LCB0aGUgcmVzdWx0IGhhcyB0aGUgZm9ybTpcbiAgICAgKiB7IEF1dGhvcml6YXRpb246ICdCZWFyZXIgPGFjY2Vzc190b2tlbl92YWx1ZT4nIH1cbiAgICAgKiBAcGFyYW0gdXJsIFRoZSBvcHRpb25hbCB1cmwgYmVpbmcgYXV0aG9yaXplZFxuICAgICAqL1xuICAgIGFzeW5jIGdldFJlcXVlc3RIZWFkZXJzKHVybCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gKGF3YWl0IHRoaXMuZ2V0UmVxdWVzdE1ldGFkYXRhQXN5bmModXJsKSkuaGVhZGVycztcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlcXVlc3RNZXRhZGF0YUFzeW5jKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICB1cmwpIHtcbiAgICAgICAgY29uc3QgdGhpc0NyZWRzID0gdGhpcy5jcmVkZW50aWFscztcbiAgICAgICAgaWYgKCF0aGlzQ3JlZHMuYWNjZXNzX3Rva2VuICYmXG4gICAgICAgICAgICAhdGhpc0NyZWRzLnJlZnJlc2hfdG9rZW4gJiZcbiAgICAgICAgICAgICF0aGlzLmFwaUtleSAmJlxuICAgICAgICAgICAgIXRoaXMucmVmcmVzaEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWNjZXNzLCByZWZyZXNoIHRva2VuLCBBUEkga2V5IG9yIHJlZnJlc2ggaGFuZGxlciBjYWxsYmFjayBpcyBzZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXNDcmVkcy5hY2Nlc3NfdG9rZW4gJiYgIXRoaXMuaXNUb2tlbkV4cGlyaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXNDcmVkcy50b2tlbl90eXBlID0gdGhpc0NyZWRzLnRva2VuX3R5cGUgfHwgJ0JlYXJlcic7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IHRoaXNDcmVkcy50b2tlbl90eXBlICsgJyAnICsgdGhpc0NyZWRzLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyBoZWFkZXJzOiB0aGlzLmFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyhoZWFkZXJzKSB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHJlZnJlc2hIYW5kbGVyIGV4aXN0cywgY2FsbCBwcm9jZXNzQW5kVmFsaWRhdGVSZWZyZXNoSGFuZGxlcigpLlxuICAgICAgICBpZiAodGhpcy5yZWZyZXNoSGFuZGxlcikge1xuICAgICAgICAgICAgY29uc3QgcmVmcmVzaGVkQWNjZXNzVG9rZW4gPSBhd2FpdCB0aGlzLnByb2Nlc3NBbmRWYWxpZGF0ZVJlZnJlc2hIYW5kbGVyKCk7XG4gICAgICAgICAgICBpZiAocmVmcmVzaGVkQWNjZXNzVG9rZW4gPT09IG51bGwgfHwgcmVmcmVzaGVkQWNjZXNzVG9rZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZnJlc2hlZEFjY2Vzc1Rva2VuLmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3JlZGVudGlhbHMocmVmcmVzaGVkQWNjZXNzVG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246ICdCZWFyZXIgJyArIHRoaXMuY3JlZGVudGlhbHMuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaGVhZGVyczogdGhpcy5hZGRTaGFyZWRNZXRhZGF0YUhlYWRlcnMoaGVhZGVycykgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hcGlLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGhlYWRlcnM6IHsgJ1gtR29vZy1BcGktS2V5JzogdGhpcy5hcGlLZXkgfSB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCByID0gbnVsbDtcbiAgICAgICAgbGV0IHRva2VucyA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByID0gYXdhaXQgdGhpcy5yZWZyZXNoVG9rZW4odGhpc0NyZWRzLnJlZnJlc2hfdG9rZW4pO1xuICAgICAgICAgICAgdG9rZW5zID0gci50b2tlbnM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc3QgZSA9IGVycjtcbiAgICAgICAgICAgIGlmIChlLnJlc3BvbnNlICYmXG4gICAgICAgICAgICAgICAgKGUucmVzcG9uc2Uuc3RhdHVzID09PSA0MDMgfHwgZS5yZXNwb25zZS5zdGF0dXMgPT09IDQwNCkpIHtcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBgQ291bGQgbm90IHJlZnJlc2ggYWNjZXNzIHRva2VuOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVkZW50aWFscyA9IHRoaXMuY3JlZGVudGlhbHM7XG4gICAgICAgIGNyZWRlbnRpYWxzLnRva2VuX3R5cGUgPSBjcmVkZW50aWFscy50b2tlbl90eXBlIHx8ICdCZWFyZXInO1xuICAgICAgICB0b2tlbnMucmVmcmVzaF90b2tlbiA9IGNyZWRlbnRpYWxzLnJlZnJlc2hfdG9rZW47XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSB0b2tlbnM7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiBjcmVkZW50aWFscy50b2tlbl90eXBlICsgJyAnICsgdG9rZW5zLmFjY2Vzc190b2tlbixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgaGVhZGVyczogdGhpcy5hZGRTaGFyZWRNZXRhZGF0YUhlYWRlcnMoaGVhZGVycyksIHJlczogci5yZXMgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIFVSTCB0byByZXZva2UgdGhlIGdpdmVuIHRva2VuLlxuICAgICAqIEBwYXJhbSB0b2tlbiBUaGUgZXhpc3RpbmcgdG9rZW4gdG8gYmUgcmV2b2tlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UmV2b2tlVG9rZW5VcmwodG9rZW4pIHtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh7IHRva2VuIH0pO1xuICAgICAgICByZXR1cm4gYCR7T0F1dGgyQ2xpZW50LkdPT0dMRV9PQVVUSDJfUkVWT0tFX1VSTF99PyR7cGFyYW1ldGVyc31gO1xuICAgIH1cbiAgICByZXZva2VUb2tlbih0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIHVybDogT0F1dGgyQ2xpZW50LmdldFJldm9rZVRva2VuVXJsKHRva2VuKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ZXJcbiAgICAgICAgICAgICAgICAucmVxdWVzdChvcHRzKVxuICAgICAgICAgICAgICAgIC50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgciksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qob3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV2b2tlQ3JlZGVudGlhbHMoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnJldm9rZUNyZWRlbnRpYWxzQXN5bmMoKS50aGVuKHJlcyA9PiBjYWxsYmFjayhudWxsLCByZXMpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXZva2VDcmVkZW50aWFsc0FzeW5jKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmV2b2tlQ3JlZGVudGlhbHNBc3luYygpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmNyZWRlbnRpYWxzLmFjY2Vzc190b2tlbjtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHt9O1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldm9rZVRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWNjZXNzIHRva2VuIHRvIHJldm9rZS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXF1ZXN0KG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QXN5bmMob3B0cykudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSwgZS5yZXNwb25zZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RBc3luYyhvcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZXF1ZXN0QXN5bmMob3B0cywgcmV0cnkgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcjI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0TWV0YWRhdGFBc3luYyhvcHRzLnVybCk7XG4gICAgICAgICAgICBvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgICBpZiAoci5oZWFkZXJzICYmIHIuaGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J10gPSByLmhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyLmhlYWRlcnMgJiYgci5oZWFkZXJzLkF1dGhvcml6YXRpb24pIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IHIuaGVhZGVycy5BdXRob3JpemF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzWydYLUdvb2ctQXBpLUtleSddID0gdGhpcy5hcGlLZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByMiA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gZS5yZXNwb25zZTtcbiAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgICAgICAvLyBSZXRyeSB0aGUgcmVxdWVzdCBmb3IgbWV0YWRhdGEgaWYgdGhlIGZvbGxvd2luZyBjcml0ZXJpYSBhcmUgdHJ1ZTpcbiAgICAgICAgICAgICAgICAvLyAtIFdlIGhhdmVuJ3QgYWxyZWFkeSByZXRyaWVkLiAgSXQgb25seSBtYWtlcyBzZW5zZSB0byByZXRyeSBvbmNlLlxuICAgICAgICAgICAgICAgIC8vIC0gVGhlIHJlc3BvbnNlIHdhcyBhIDQwMSBvciBhIDQwM1xuICAgICAgICAgICAgICAgIC8vIC0gVGhlIHJlcXVlc3QgZGlkbid0IHNlbmQgYSByZWFkYWJsZVN0cmVhbVxuICAgICAgICAgICAgICAgIC8vIC0gQW4gYWNjZXNzX3Rva2VuIGFuZCByZWZyZXNoX3Rva2VuIHdlcmUgYXZhaWxhYmxlLCBidXQgZWl0aGVyIG5vXG4gICAgICAgICAgICAgICAgLy8gICBleHBpcnlfZGF0ZSB3YXMgYXZhaWxhYmxlIG9yIHRoZSBmb3JjZVJlZnJlc2hPbkZhaWx1cmUgZmxhZyBpcyBzZXQuXG4gICAgICAgICAgICAgICAgLy8gICBUaGUgYWJzZW50IGV4cGlyeV9kYXRlIGNhc2UgY2FuIGhhcHBlbiB3aGVuIGRldmVsb3BlcnMgc3Rhc2ggdGhlXG4gICAgICAgICAgICAgICAgLy8gICBhY2Nlc3NfdG9rZW4gYW5kIHJlZnJlc2hfdG9rZW4gZm9yIGxhdGVyIHVzZSwgYnV0IHRoZSBhY2Nlc3NfdG9rZW5cbiAgICAgICAgICAgICAgICAvLyAgIGZhaWxzIG9uIHRoZSBmaXJzdCB0cnkgYmVjYXVzZSBpdCdzIGV4cGlyZWQuIFNvbWUgZGV2ZWxvcGVycyBtYXlcbiAgICAgICAgICAgICAgICAvLyAgIGNob29zZSB0byBlbmFibGUgZm9yY2VSZWZyZXNoT25GYWlsdXJlIHRvIG1pdGlnYXRlIHRpbWUtcmVsYXRlZFxuICAgICAgICAgICAgICAgIC8vICAgZXJyb3JzLlxuICAgICAgICAgICAgICAgIC8vIE9yIHRoZSBmb2xsb3dpbmcgY3JpdGVyaWEgYXJlIHRydWU6XG4gICAgICAgICAgICAgICAgLy8gLSBXZSBoYXZlbid0IGFscmVhZHkgcmV0cmllZC4gIEl0IG9ubHkgbWFrZXMgc2Vuc2UgdG8gcmV0cnkgb25jZS5cbiAgICAgICAgICAgICAgICAvLyAtIFRoZSByZXNwb25zZSB3YXMgYSA0MDEgb3IgYSA0MDNcbiAgICAgICAgICAgICAgICAvLyAtIFRoZSByZXF1ZXN0IGRpZG4ndCBzZW5kIGEgcmVhZGFibGVTdHJlYW1cbiAgICAgICAgICAgICAgICAvLyAtIE5vIHJlZnJlc2hfdG9rZW4gd2FzIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIC8vIC0gQW4gYWNjZXNzX3Rva2VuIGFuZCBhIHJlZnJlc2hIYW5kbGVyIGNhbGxiYWNrIHdlcmUgYXZhaWxhYmxlLCBidXRcbiAgICAgICAgICAgICAgICAvLyAgIGVpdGhlciBubyBleHBpcnlfZGF0ZSB3YXMgYXZhaWxhYmxlIG9yIHRoZSBmb3JjZVJlZnJlc2hPbkZhaWx1cmVcbiAgICAgICAgICAgICAgICAvLyAgIGZsYWcgaXMgc2V0LiBUaGUgYWNjZXNzX3Rva2VuIGZhaWxzIG9uIHRoZSBmaXJzdCB0cnkgYmVjYXVzZSBpdCdzXG4gICAgICAgICAgICAgICAgLy8gICBleHBpcmVkLiBTb21lIGRldmVsb3BlcnMgbWF5IGNob29zZSB0byBlbmFibGUgZm9yY2VSZWZyZXNoT25GYWlsdXJlXG4gICAgICAgICAgICAgICAgLy8gICB0byBtaXRpZ2F0ZSB0aW1lLXJlbGF0ZWQgZXJyb3JzLlxuICAgICAgICAgICAgICAgIGNvbnN0IG1heVJlcXVpcmVSZWZyZXNoID0gdGhpcy5jcmVkZW50aWFscyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxzLmFjY2Vzc190b2tlbiAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxzLnJlZnJlc2hfdG9rZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgKCF0aGlzLmNyZWRlbnRpYWxzLmV4cGlyeV9kYXRlIHx8IHRoaXMuZm9yY2VSZWZyZXNoT25GYWlsdXJlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXlSZXF1aXJlUmVmcmVzaFdpdGhOb1JlZnJlc2hUb2tlbiA9IHRoaXMuY3JlZGVudGlhbHMgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFscy5hY2Nlc3NfdG9rZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuY3JlZGVudGlhbHMucmVmcmVzaF90b2tlbiAmJlxuICAgICAgICAgICAgICAgICAgICAoIXRoaXMuY3JlZGVudGlhbHMuZXhwaXJ5X2RhdGUgfHwgdGhpcy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUpICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaEhhbmRsZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZWFkYWJsZVN0cmVhbSA9IHJlcy5jb25maWcuZGF0YSBpbnN0YW5jZW9mIHN0cmVhbS5SZWFkYWJsZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0F1dGhFcnIgPSBzdGF0dXNDb2RlID09PSA0MDEgfHwgc3RhdHVzQ29kZSA9PT0gNDAzO1xuICAgICAgICAgICAgICAgIGlmICghcmV0cnkgJiYgaXNBdXRoRXJyICYmICFpc1JlYWRhYmxlU3RyZWFtICYmIG1heVJlcXVpcmVSZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEFzeW5jKG9wdHMsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghcmV0cnkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNBdXRoRXJyICYmXG4gICAgICAgICAgICAgICAgICAgICFpc1JlYWRhYmxlU3RyZWFtICYmXG4gICAgICAgICAgICAgICAgICAgIG1heVJlcXVpcmVSZWZyZXNoV2l0aE5vUmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZnJlc2hlZEFjY2Vzc1Rva2VuID0gYXdhaXQgdGhpcy5wcm9jZXNzQW5kVmFsaWRhdGVSZWZyZXNoSGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmcmVzaGVkQWNjZXNzVG9rZW4gPT09IG51bGwgfHwgcmVmcmVzaGVkQWNjZXNzVG9rZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZnJlc2hlZEFjY2Vzc1Rva2VuLmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDcmVkZW50aWFscyhyZWZyZXNoZWRBY2Nlc3NUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEFzeW5jKG9wdHMsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHIyO1xuICAgIH1cbiAgICB2ZXJpZnlJZFRva2VuKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gdXNlZCB0byBhY2NlcHQgdHdvIGFyZ3VtZW50cyBpbnN0ZWFkIG9mIGFuIG9wdGlvbnMgb2JqZWN0LlxuICAgICAgICAvLyBDaGVjayB0aGUgdHlwZXMgdG8gaGVscCB1c2VycyB1cGdyYWRlIHdpdGggbGVzcyBwYWluLlxuICAgICAgICAvLyBUaGlzIGNoZWNrIGNhbiBiZSByZW1vdmVkIGFmdGVyIGEgMi4wIHJlbGVhc2UuXG4gICAgICAgIGlmIChjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgYWNjZXB0cyBhbiBvcHRpb25zIG9iamVjdCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLCB3aGljaCBpbmNsdWRlcyB0aGUgaWRUb2tlbiwgYXVkaWVuY2UsIGFuZCBtYXhFeHBpcnkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnZlcmlmeUlkVG9rZW5Bc3luYyhvcHRpb25zKS50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgciksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeUlkVG9rZW5Bc3luYyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB2ZXJpZnlJZFRva2VuQXN5bmMob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMuaWRUb2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmVyaWZ5SWRUb2tlbiBtZXRob2QgcmVxdWlyZXMgYW4gSUQgVG9rZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0RmVkZXJhdGVkU2lnbm9uQ2VydHNBc3luYygpO1xuICAgICAgICBjb25zdCBsb2dpbiA9IGF3YWl0IHRoaXMudmVyaWZ5U2lnbmVkSnd0V2l0aENlcnRzQXN5bmMob3B0aW9ucy5pZFRva2VuLCByZXNwb25zZS5jZXJ0cywgb3B0aW9ucy5hdWRpZW5jZSwgT0F1dGgyQ2xpZW50LklTU1VFUlNfLCBvcHRpb25zLm1heEV4cGlyeSk7XG4gICAgICAgIHJldHVybiBsb2dpbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT2J0YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcHJvdmlzaW9uZWQgYWNjZXNzIHRva2VuLiAgRXNwZWNpYWxseSB1c2VmdWxcbiAgICAgKiBpZiB5b3Ugd2FudCB0byBjaGVjayB0aGUgc2NvcGVzIHRoYXQgd2VyZSBwcm92aXNpb25lZCB0byBhIGdpdmVuIHRva2VuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFjY2Vzc1Rva2VuIFJlcXVpcmVkLiAgVGhlIEFjY2VzcyBUb2tlbiBmb3Igd2hpY2ggeW91IHdhbnQgdG8gZ2V0XG4gICAgICogdXNlciBpbmZvLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRva2VuSW5mbyhhY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdCh7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2FjY2Vzc1Rva2VufWAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXJsOiBPQXV0aDJDbGllbnQuR09PR0xFX1RPS0VOX0lORk9fVVJMLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaW5mbyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgZXhwaXJ5X2RhdGU6IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgZGF0YS5leHBpcmVzX2luICogMTAwMCxcbiAgICAgICAgICAgIHNjb3BlczogZGF0YS5zY29wZS5zcGxpdCgnICcpLFxuICAgICAgICB9LCBkYXRhKTtcbiAgICAgICAgZGVsZXRlIGluZm8uZXhwaXJlc19pbjtcbiAgICAgICAgZGVsZXRlIGluZm8uc2NvcGU7XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cbiAgICBnZXRGZWRlcmF0ZWRTaWdub25DZXJ0cyhjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RmVkZXJhdGVkU2lnbm9uQ2VydHNBc3luYygpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByLmNlcnRzLCByLnJlcyksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZlZGVyYXRlZFNpZ25vbkNlcnRzQXN5bmMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRGZWRlcmF0ZWRTaWdub25DZXJ0c0FzeW5jKCkge1xuICAgICAgICBjb25zdCBub3dUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9ICgwLCBjcnlwdG9fMS5oYXNCcm93c2VyQ3J5cHRvKSgpXG4gICAgICAgICAgICA/IENlcnRpZmljYXRlRm9ybWF0LkpXS1xuICAgICAgICAgICAgOiBDZXJ0aWZpY2F0ZUZvcm1hdC5QRU07XG4gICAgICAgIGlmICh0aGlzLmNlcnRpZmljYXRlRXhwaXJ5ICYmXG4gICAgICAgICAgICBub3dUaW1lIDwgdGhpcy5jZXJ0aWZpY2F0ZUV4cGlyeS5nZXRUaW1lKCkgJiZcbiAgICAgICAgICAgIHRoaXMuY2VydGlmaWNhdGVDYWNoZUZvcm1hdCA9PT0gZm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4geyBjZXJ0czogdGhpcy5jZXJ0aWZpY2F0ZUNhY2hlLCBmb3JtYXQgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzO1xuICAgICAgICBsZXQgdXJsO1xuICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSBDZXJ0aWZpY2F0ZUZvcm1hdC5QRU06XG4gICAgICAgICAgICAgICAgdXJsID0gT0F1dGgyQ2xpZW50LkdPT0dMRV9PQVVUSDJfRkVERVJBVEVEX1NJR05PTl9QRU1fQ0VSVFNfVVJMXztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ2VydGlmaWNhdGVGb3JtYXQuSldLOlxuICAgICAgICAgICAgICAgIHVybCA9IE9BdXRoMkNsaWVudC5HT09HTEVfT0FVVEgyX0ZFREVSQVRFRF9TSUdOT05fSldLX0NFUlRTX1VSTF87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY2VydGlmaWNhdGUgZm9ybWF0ICR7Zm9ybWF0fWApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3QoeyB1cmwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBgRmFpbGVkIHRvIHJldHJpZXZlIHZlcmlmaWNhdGlvbiBjZXJ0aWZpY2F0ZXM6ICR7ZS5tZXNzYWdlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhY2hlQ29udHJvbCA9IHJlcyA/IHJlcy5oZWFkZXJzWydjYWNoZS1jb250cm9sJ10gOiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjYWNoZUFnZSA9IC0xO1xuICAgICAgICBpZiAoY2FjaGVDb250cm9sKSB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cCgnbWF4LWFnZT0oWzAtOV0qKScpO1xuICAgICAgICAgICAgY29uc3QgcmVnZXhSZXN1bHQgPSBwYXR0ZXJuLmV4ZWMoY2FjaGVDb250cm9sKTtcbiAgICAgICAgICAgIGlmIChyZWdleFJlc3VsdCAmJiByZWdleFJlc3VsdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBDYWNoZSByZXN1bHRzIHdpdGggbWF4LWFnZSAoaW4gc2Vjb25kcylcbiAgICAgICAgICAgICAgICBjYWNoZUFnZSA9IE51bWJlcihyZWdleFJlc3VsdFsxXSkgKiAxMDAwOyAvLyBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2VydGlmaWNhdGVzID0ge307XG4gICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlIENlcnRpZmljYXRlRm9ybWF0LlBFTTpcbiAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZXMgPSByZXMuZGF0YTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ2VydGlmaWNhdGVGb3JtYXQuSldLOlxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHJlcy5kYXRhLmtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VydGlmaWNhdGVzW2tleS5raWRdID0ga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjZXJ0aWZpY2F0ZSBmb3JtYXQgJHtmb3JtYXR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5jZXJ0aWZpY2F0ZUV4cGlyeSA9XG4gICAgICAgICAgICBjYWNoZUFnZSA9PT0gLTEgPyBudWxsIDogbmV3IERhdGUobm93LmdldFRpbWUoKSArIGNhY2hlQWdlKTtcbiAgICAgICAgdGhpcy5jZXJ0aWZpY2F0ZUNhY2hlID0gY2VydGlmaWNhdGVzO1xuICAgICAgICB0aGlzLmNlcnRpZmljYXRlQ2FjaGVGb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIHJldHVybiB7IGNlcnRzOiBjZXJ0aWZpY2F0ZXMsIGZvcm1hdCwgcmVzIH07XG4gICAgfVxuICAgIGdldElhcFB1YmxpY0tleXMoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmdldElhcFB1YmxpY0tleXNBc3luYygpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByLnB1YmtleXMsIHIucmVzKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SWFwUHVibGljS2V5c0FzeW5jKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0SWFwUHVibGljS2V5c0FzeW5jKCkge1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICBjb25zdCB1cmwgPSBPQXV0aDJDbGllbnQuR09PR0xFX09BVVRIMl9JQVBfUFVCTElDX0tFWV9VUkxfO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KHsgdXJsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gYEZhaWxlZCB0byByZXRyaWV2ZSB2ZXJpZmljYXRpb24gY2VydGlmaWNhdGVzOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwdWJrZXlzOiByZXMuZGF0YSwgcmVzIH07XG4gICAgfVxuICAgIHZlcmlmeVNpZ25lZEp3dFdpdGhDZXJ0cygpIHtcbiAgICAgICAgLy8gVG8gbWFrZSB0aGUgY29kZSBjb21wYXRpYmxlIHdpdGggYnJvd3NlciBTdWJ0bGVDcnlwdG8gd2UgbmVlZCB0byBtYWtlXG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIGFzeW5jLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlcmlmeVNpZ25lZEp3dFdpdGhDZXJ0cyBpcyByZW1vdmVkLCBwbGVhc2UgdXNlIHZlcmlmeVNpZ25lZEp3dFdpdGhDZXJ0c0FzeW5jIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmeSB0aGUgaWQgdG9rZW4gaXMgc2lnbmVkIHdpdGggdGhlIGNvcnJlY3QgY2VydGlmaWNhdGVcbiAgICAgKiBhbmQgaXMgZnJvbSB0aGUgY29ycmVjdCBhdWRpZW5jZS5cbiAgICAgKiBAcGFyYW0gand0IFRoZSBqd3QgdG8gdmVyaWZ5IChUaGUgSUQgVG9rZW4gaW4gdGhpcyBjYXNlKS5cbiAgICAgKiBAcGFyYW0gY2VydHMgVGhlIGFycmF5IG9mIGNlcnRzIHRvIHRlc3QgdGhlIGp3dCBhZ2FpbnN0LlxuICAgICAqIEBwYXJhbSByZXF1aXJlZEF1ZGllbmNlIFRoZSBhdWRpZW5jZSB0byB0ZXN0IHRoZSBqd3QgYWdhaW5zdC5cbiAgICAgKiBAcGFyYW0gaXNzdWVycyBUaGUgYWxsb3dlZCBpc3N1ZXJzIG9mIHRoZSBqd3QgKE9wdGlvbmFsKS5cbiAgICAgKiBAcGFyYW0gbWF4RXhwaXJ5IFRoZSBtYXggZXhwaXJ5IHRoZSBjZXJ0aWZpY2F0ZSBjYW4gYmUgKE9wdGlvbmFsKS5cbiAgICAgKiBAcmV0dXJuIFJldHVybnMgYSBwcm9taXNlIHJlc29sdmluZyB0byBMb2dpblRpY2tldCBvbiB2ZXJpZmljYXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgdmVyaWZ5U2lnbmVkSnd0V2l0aENlcnRzQXN5bmMoand0LCBjZXJ0cywgcmVxdWlyZWRBdWRpZW5jZSwgaXNzdWVycywgbWF4RXhwaXJ5KSB7XG4gICAgICAgIGNvbnN0IGNyeXB0byA9ICgwLCBjcnlwdG9fMS5jcmVhdGVDcnlwdG8pKCk7XG4gICAgICAgIGlmICghbWF4RXhwaXJ5KSB7XG4gICAgICAgICAgICBtYXhFeHBpcnkgPSBPQXV0aDJDbGllbnQuTUFYX1RPS0VOX0xJRkVUSU1FX1NFQ1NfO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gand0LnNwbGl0KCcuJyk7XG4gICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRva2VuOiAnICsgand0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduZWQgPSBzZWdtZW50c1swXSArICcuJyArIHNlZ21lbnRzWzFdO1xuICAgICAgICBsZXQgc2lnbmF0dXJlID0gc2VnbWVudHNbMl07XG4gICAgICAgIGxldCBlbnZlbG9wZTtcbiAgICAgICAgbGV0IHBheWxvYWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBlbnZlbG9wZSA9IEpTT04ucGFyc2UoY3J5cHRvLmRlY29kZUJhc2U2NFN0cmluZ1V0Zjgoc2VnbWVudHNbMF0pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGBDYW4ndCBwYXJzZSB0b2tlbiBlbnZlbG9wZTogJHtzZWdtZW50c1swXX0nOiAke2Vyci5tZXNzYWdlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbnZlbG9wZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGFyc2UgdG9rZW4gZW52ZWxvcGU6IFwiICsgc2VnbWVudHNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShjcnlwdG8uZGVjb2RlQmFzZTY0U3RyaW5nVXRmOChzZWdtZW50c1sxXSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gYENhbid0IHBhcnNlIHRva2VuIHBheWxvYWQgJyR7c2VnbWVudHNbMF19YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBheWxvYWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBhcnNlIHRva2VuIHBheWxvYWQ6IFwiICsgc2VnbWVudHNbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNlcnRzLCBlbnZlbG9wZS5raWQpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCBwcmVzZW50LCB0aGVuIHRoZXJlJ3Mgbm8gcmVhc29uIHRvIGF0dGVtcHQgdmVyaWZpY2F0aW9uXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHBlbSBmb3VuZCBmb3IgZW52ZWxvcGU6ICcgKyBKU09OLnN0cmluZ2lmeShlbnZlbG9wZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlcnQgPSBjZXJ0c1tlbnZlbG9wZS5raWRdO1xuICAgICAgICBpZiAoZW52ZWxvcGUuYWxnID09PSAnRVMyNTYnKSB7XG4gICAgICAgICAgICBzaWduYXR1cmUgPSBmb3JtYXRFY2RzYS5qb3NlVG9EZXIoc2lnbmF0dXJlLCAnRVMyNTYnKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyaWZpZWQgPSBhd2FpdCBjcnlwdG8udmVyaWZ5KGNlcnQsIHNpZ25lZCwgc2lnbmF0dXJlKTtcbiAgICAgICAgaWYgKCF2ZXJpZmllZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRva2VuIHNpZ25hdHVyZTogJyArIGp3dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXlsb2FkLmlhdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpc3N1ZSB0aW1lIGluIHRva2VuOiAnICsgSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGF5bG9hZC5leHApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXhwaXJhdGlvbiB0aW1lIGluIHRva2VuOiAnICsgSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlhdCA9IE51bWJlcihwYXlsb2FkLmlhdCk7XG4gICAgICAgIGlmIChpc05hTihpYXQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpYXQgZmllbGQgdXNpbmcgaW52YWxpZCBmb3JtYXQnKTtcbiAgICAgICAgY29uc3QgZXhwID0gTnVtYmVyKHBheWxvYWQuZXhwKTtcbiAgICAgICAgaWYgKGlzTmFOKGV4cCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cCBmaWVsZCB1c2luZyBpbnZhbGlkIGZvcm1hdCcpO1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDA7XG4gICAgICAgIGlmIChleHAgPj0gbm93ICsgbWF4RXhwaXJ5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGlyYXRpb24gdGltZSB0b28gZmFyIGluIGZ1dHVyZTogJyArIEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlYXJsaWVzdCA9IGlhdCAtIE9BdXRoMkNsaWVudC5DTE9DS19TS0VXX1NFQ1NfO1xuICAgICAgICBjb25zdCBsYXRlc3QgPSBleHAgKyBPQXV0aDJDbGllbnQuQ0xPQ0tfU0tFV19TRUNTXztcbiAgICAgICAgaWYgKG5vdyA8IGVhcmxpZXN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rva2VuIHVzZWQgdG9vIGVhcmx5LCAnICtcbiAgICAgICAgICAgICAgICBub3cgK1xuICAgICAgICAgICAgICAgICcgPCAnICtcbiAgICAgICAgICAgICAgICBlYXJsaWVzdCArXG4gICAgICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3cgPiBsYXRlc3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9rZW4gdXNlZCB0b28gbGF0ZSwgJyArXG4gICAgICAgICAgICAgICAgbm93ICtcbiAgICAgICAgICAgICAgICAnID4gJyArXG4gICAgICAgICAgICAgICAgbGF0ZXN0ICtcbiAgICAgICAgICAgICAgICAnOiAnICtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzc3VlcnMgJiYgaXNzdWVycy5pbmRleE9mKHBheWxvYWQuaXNzKSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpc3N1ZXIsIGV4cGVjdGVkIG9uZSBvZiBbJyArXG4gICAgICAgICAgICAgICAgaXNzdWVycyArXG4gICAgICAgICAgICAgICAgJ10sIGJ1dCBnb3QgJyArXG4gICAgICAgICAgICAgICAgcGF5bG9hZC5pc3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHRoZSBhdWRpZW5jZSBtYXRjaGVzIGlmIHdlIGhhdmUgb25lXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWRBdWRpZW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcmVxdWlyZWRBdWRpZW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgYXVkID0gcGF5bG9hZC5hdWQ7XG4gICAgICAgICAgICBsZXQgYXVkVmVyaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIElmIHRoZSByZXF1aXJlZEF1ZGllbmNlIGlzIGFuIGFycmF5LCBjaGVjayBpZiBpdCBjb250YWlucyB0b2tlblxuICAgICAgICAgICAgLy8gYXVkaWVuY2VcbiAgICAgICAgICAgIGlmIChyZXF1aXJlZEF1ZGllbmNlLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgICAgIGF1ZFZlcmlmaWVkID0gcmVxdWlyZWRBdWRpZW5jZS5pbmRleE9mKGF1ZCkgPiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF1ZFZlcmlmaWVkID0gYXVkID09PSByZXF1aXJlZEF1ZGllbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhdWRWZXJpZmllZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgcmVjaXBpZW50LCBwYXlsb2FkIGF1ZGllbmNlICE9IHJlcXVpcmVkQXVkaWVuY2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGxvZ2ludGlja2V0XzEuTG9naW5UaWNrZXQoZW52ZWxvcGUsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggQWNjZXNzVG9rZW5SZXNwb25zZSB0eXBlIGlmXG4gICAgICogcmVmcmVzaEhhbmRsZXIgaXMgZGVmaW5lZC5cbiAgICAgKiBJZiBub3QsIG5vdGhpbmcgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgYXN5bmMgcHJvY2Vzc0FuZFZhbGlkYXRlUmVmcmVzaEhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZnJlc2hIYW5kbGVyKSB7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NUb2tlblJlc3BvbnNlID0gYXdhaXQgdGhpcy5yZWZyZXNoSGFuZGxlcigpO1xuICAgICAgICAgICAgaWYgKCFhY2Nlc3NUb2tlblJlc3BvbnNlLmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWNjZXNzIHRva2VuIGlzIHJldHVybmVkIGJ5IHRoZSByZWZyZXNoSGFuZGxlciBjYWxsYmFjay4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3NUb2tlblJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGEgdG9rZW4gaXMgZXhwaXJlZCBvciB3aWxsIGV4cGlyZSB3aXRoaW5cbiAgICAgKiBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXNtaWxsaXNlY29uZHMuXG4gICAgICogSWYgdGhlcmUgaXMgbm8gZXhwaXJ5IHRpbWUsIGFzc3VtZXMgdGhlIHRva2VuIGlzIG5vdCBleHBpcmVkIG9yIGV4cGlyaW5nLlxuICAgICAqL1xuICAgIGlzVG9rZW5FeHBpcmluZygpIHtcbiAgICAgICAgY29uc3QgZXhwaXJ5RGF0ZSA9IHRoaXMuY3JlZGVudGlhbHMuZXhwaXJ5X2RhdGU7XG4gICAgICAgIHJldHVybiBleHBpcnlEYXRlXG4gICAgICAgICAgICA/IGV4cGlyeURhdGUgPD0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpc1xuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLk9BdXRoMkNsaWVudCA9IE9BdXRoMkNsaWVudDtcbk9BdXRoMkNsaWVudC5HT09HTEVfVE9LRU5fSU5GT19VUkwgPSAnaHR0cHM6Ly9vYXV0aDIuZ29vZ2xlYXBpcy5jb20vdG9rZW5pbmZvJztcbi8qKlxuICogVGhlIGJhc2UgVVJMIGZvciBhdXRoIGVuZHBvaW50cy5cbiAqL1xuT0F1dGgyQ2xpZW50LkdPT0dMRV9PQVVUSDJfQVVUSF9CQVNFX1VSTF8gPSAnaHR0cHM6Ly9hY2NvdW50cy5nb29nbGUuY29tL28vb2F1dGgyL3YyL2F1dGgnO1xuLyoqXG4gKiBUaGUgYmFzZSBlbmRwb2ludCBmb3IgdG9rZW4gcmV0cmlldmFsLlxuICovXG5PQXV0aDJDbGllbnQuR09PR0xFX09BVVRIMl9UT0tFTl9VUkxfID0gJ2h0dHBzOi8vb2F1dGgyLmdvb2dsZWFwaXMuY29tL3Rva2VuJztcbi8qKlxuICogVGhlIGJhc2UgZW5kcG9pbnQgdG8gcmV2b2tlIHRva2Vucy5cbiAqL1xuT0F1dGgyQ2xpZW50LkdPT0dMRV9PQVVUSDJfUkVWT0tFX1VSTF8gPSAnaHR0cHM6Ly9vYXV0aDIuZ29vZ2xlYXBpcy5jb20vcmV2b2tlJztcbi8qKlxuICogR29vZ2xlIFNpZ24gb24gY2VydGlmaWNhdGVzIGluIFBFTSBmb3JtYXQuXG4gKi9cbk9BdXRoMkNsaWVudC5HT09HTEVfT0FVVEgyX0ZFREVSQVRFRF9TSUdOT05fUEVNX0NFUlRTX1VSTF8gPSAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vb2F1dGgyL3YxL2NlcnRzJztcbi8qKlxuICogR29vZ2xlIFNpZ24gb24gY2VydGlmaWNhdGVzIGluIEpXSyBmb3JtYXQuXG4gKi9cbk9BdXRoMkNsaWVudC5HT09HTEVfT0FVVEgyX0ZFREVSQVRFRF9TSUdOT05fSldLX0NFUlRTX1VSTF8gPSAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vb2F1dGgyL3YzL2NlcnRzJztcbi8qKlxuICogR29vZ2xlIFNpZ24gb24gY2VydGlmaWNhdGVzIGluIEpXSyBmb3JtYXQuXG4gKi9cbk9BdXRoMkNsaWVudC5HT09HTEVfT0FVVEgyX0lBUF9QVUJMSUNfS0VZX1VSTF8gPSAnaHR0cHM6Ly93d3cuZ3N0YXRpYy5jb20vaWFwL3ZlcmlmeS9wdWJsaWNfa2V5Jztcbi8qKlxuICogQ2xvY2sgc2tldyAtIGZpdmUgbWludXRlcyBpbiBzZWNvbmRzXG4gKi9cbk9BdXRoMkNsaWVudC5DTE9DS19TS0VXX1NFQ1NfID0gMzAwO1xuLyoqXG4gKiBNYXggVG9rZW4gTGlmZXRpbWUgaXMgb25lIGRheSBpbiBzZWNvbmRzXG4gKi9cbk9BdXRoMkNsaWVudC5NQVhfVE9LRU5fTElGRVRJTUVfU0VDU18gPSA4NjQwMDtcbi8qKlxuICogVGhlIGFsbG93ZWQgb2F1dGggdG9rZW4gaXNzdWVycy5cbiAqL1xuT0F1dGgyQ2xpZW50LklTU1VFUlNfID0gW1xuICAgICdhY2NvdW50cy5nb29nbGUuY29tJyxcbiAgICAnaHR0cHM6Ly9hY2NvdW50cy5nb29nbGUuY29tJyxcbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYXV0aDJjbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiT0F1dGgyQ2xpZW50IiwiQ2VydGlmaWNhdGVGb3JtYXQiLCJDb2RlQ2hhbGxlbmdlTWV0aG9kIiwiZ2F4aW9zXzEiLCJyZXF1aXJlIiwicXVlcnlzdHJpbmciLCJzdHJlYW0iLCJmb3JtYXRFY2RzYSIsImNyeXB0b18xIiwiYXV0aGNsaWVudF8xIiwibG9naW50aWNrZXRfMSIsIkF1dGhDbGllbnQiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnNPckNsaWVudElkIiwiY2xpZW50U2VjcmV0IiwicmVkaXJlY3RVcmkiLCJjZXJ0aWZpY2F0ZUNhY2hlIiwiY2VydGlmaWNhdGVFeHBpcnkiLCJjZXJ0aWZpY2F0ZUNhY2hlRm9ybWF0IiwiUEVNIiwicmVmcmVzaFRva2VuUHJvbWlzZXMiLCJNYXAiLCJvcHRzIiwiY2xpZW50SWQiLCJfY2xpZW50SWQiLCJfY2xpZW50U2VjcmV0IiwiZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzIiwiZm9yY2VSZWZyZXNoT25GYWlsdXJlIiwiZ2VuZXJhdGVBdXRoVXJsIiwiY29kZV9jaGFsbGVuZ2VfbWV0aG9kIiwiY29kZV9jaGFsbGVuZ2UiLCJFcnJvciIsInJlc3BvbnNlX3R5cGUiLCJjbGllbnRfaWQiLCJyZWRpcmVjdF91cmkiLCJBcnJheSIsImlzQXJyYXkiLCJzY29wZSIsImpvaW4iLCJyb290VXJsIiwiR09PR0xFX09BVVRIMl9BVVRIX0JBU0VfVVJMXyIsInN0cmluZ2lmeSIsImdlbmVyYXRlQ29kZVZlcmlmaWVyIiwiZ2VuZXJhdGVDb2RlVmVyaWZpZXJBc3luYyIsImNyeXB0byIsImNyZWF0ZUNyeXB0byIsInJhbmRvbVN0cmluZyIsInJhbmRvbUJ5dGVzQmFzZTY0IiwiY29kZVZlcmlmaWVyIiwicmVwbGFjZSIsInVuZW5jb2RlZENvZGVDaGFsbGVuZ2UiLCJzaGEyNTZEaWdlc3RCYXNlNjQiLCJjb2RlQ2hhbGxlbmdlIiwic3BsaXQiLCJnZXRUb2tlbiIsImNvZGVPck9wdGlvbnMiLCJjYWxsYmFjayIsIm9wdGlvbnMiLCJjb2RlIiwiZ2V0VG9rZW5Bc3luYyIsInRoZW4iLCJyIiwidG9rZW5zIiwicmVzIiwiZSIsInJlc3BvbnNlIiwidXJsIiwiR09PR0xFX09BVVRIMl9UT0tFTl9VUkxfIiwidmFsdWVzIiwiY2xpZW50X3NlY3JldCIsImdyYW50X3R5cGUiLCJjb2RlX3ZlcmlmaWVyIiwidHJhbnNwb3J0ZXIiLCJyZXF1ZXN0IiwibWV0aG9kIiwiZGF0YSIsImhlYWRlcnMiLCJleHBpcmVzX2luIiwiZXhwaXJ5X2RhdGUiLCJEYXRlIiwiZ2V0VGltZSIsImVtaXQiLCJyZWZyZXNoVG9rZW4iLCJyZWZyZXNoVG9rZW5Ob0NhY2hlIiwiaGFzIiwiZ2V0IiwicCIsImRlbGV0ZSIsInNldCIsIl9hIiwicmVmcmVzaF90b2tlbiIsIkdheGlvc0Vycm9yIiwibWVzc2FnZSIsInRlc3QiLCJlcnJvcl9kZXNjcmlwdGlvbiIsIkpTT04iLCJyZWZyZXNoQWNjZXNzVG9rZW4iLCJyZWZyZXNoQWNjZXNzVG9rZW5Bc3luYyIsImNyZWRlbnRpYWxzIiwiZ2V0QWNjZXNzVG9rZW4iLCJnZXRBY2Nlc3NUb2tlbkFzeW5jIiwidG9rZW4iLCJzaG91bGRSZWZyZXNoIiwiYWNjZXNzX3Rva2VuIiwiaXNUb2tlbkV4cGlyaW5nIiwicmVmcmVzaEhhbmRsZXIiLCJyZWZyZXNoZWRBY2Nlc3NUb2tlbiIsInByb2Nlc3NBbmRWYWxpZGF0ZVJlZnJlc2hIYW5kbGVyIiwic2V0Q3JlZGVudGlhbHMiLCJnZXRSZXF1ZXN0SGVhZGVycyIsImdldFJlcXVlc3RNZXRhZGF0YUFzeW5jIiwidGhpc0NyZWRzIiwiYXBpS2V5IiwidG9rZW5fdHlwZSIsIkF1dGhvcml6YXRpb24iLCJhZGRTaGFyZWRNZXRhZGF0YUhlYWRlcnMiLCJlcnIiLCJzdGF0dXMiLCJnZXRSZXZva2VUb2tlblVybCIsInBhcmFtZXRlcnMiLCJHT09HTEVfT0FVVEgyX1JFVk9LRV9VUkxfIiwicmV2b2tlVG9rZW4iLCJyZXZva2VDcmVkZW50aWFscyIsInJldm9rZUNyZWRlbnRpYWxzQXN5bmMiLCJyZXF1ZXN0QXN5bmMiLCJyZXRyeSIsInIyIiwic3RhdHVzQ29kZSIsIm1heVJlcXVpcmVSZWZyZXNoIiwibWF5UmVxdWlyZVJlZnJlc2hXaXRoTm9SZWZyZXNoVG9rZW4iLCJpc1JlYWRhYmxlU3RyZWFtIiwiY29uZmlnIiwiUmVhZGFibGUiLCJpc0F1dGhFcnIiLCJ2ZXJpZnlJZFRva2VuIiwidmVyaWZ5SWRUb2tlbkFzeW5jIiwiaWRUb2tlbiIsImdldEZlZGVyYXRlZFNpZ25vbkNlcnRzQXN5bmMiLCJsb2dpbiIsInZlcmlmeVNpZ25lZEp3dFdpdGhDZXJ0c0FzeW5jIiwiY2VydHMiLCJhdWRpZW5jZSIsIklTU1VFUlNfIiwibWF4RXhwaXJ5IiwiZ2V0VG9rZW5JbmZvIiwiYWNjZXNzVG9rZW4iLCJHT09HTEVfVE9LRU5fSU5GT19VUkwiLCJpbmZvIiwiYXNzaWduIiwic2NvcGVzIiwiZ2V0RmVkZXJhdGVkU2lnbm9uQ2VydHMiLCJub3dUaW1lIiwiZm9ybWF0IiwiaGFzQnJvd3NlckNyeXB0byIsIkpXSyIsIkdPT0dMRV9PQVVUSDJfRkVERVJBVEVEX1NJR05PTl9QRU1fQ0VSVFNfVVJMXyIsIkdPT0dMRV9PQVVUSDJfRkVERVJBVEVEX1NJR05PTl9KV0tfQ0VSVFNfVVJMXyIsImNhY2hlQ29udHJvbCIsInVuZGVmaW5lZCIsImNhY2hlQWdlIiwicGF0dGVybiIsIlJlZ0V4cCIsInJlZ2V4UmVzdWx0IiwiZXhlYyIsImxlbmd0aCIsIk51bWJlciIsImNlcnRpZmljYXRlcyIsImtleSIsImtleXMiLCJraWQiLCJub3ciLCJnZXRJYXBQdWJsaWNLZXlzIiwiZ2V0SWFwUHVibGljS2V5c0FzeW5jIiwicHVia2V5cyIsIkdPT0dMRV9PQVVUSDJfSUFQX1BVQkxJQ19LRVlfVVJMXyIsInZlcmlmeVNpZ25lZEp3dFdpdGhDZXJ0cyIsImp3dCIsInJlcXVpcmVkQXVkaWVuY2UiLCJpc3N1ZXJzIiwiTUFYX1RPS0VOX0xJRkVUSU1FX1NFQ1NfIiwic2VnbWVudHMiLCJzaWduZWQiLCJzaWduYXR1cmUiLCJlbnZlbG9wZSIsInBheWxvYWQiLCJwYXJzZSIsImRlY29kZUJhc2U2NFN0cmluZ1V0ZjgiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJjZXJ0IiwiYWxnIiwiam9zZVRvRGVyIiwidG9TdHJpbmciLCJ2ZXJpZmllZCIsInZlcmlmeSIsImlhdCIsImV4cCIsImlzTmFOIiwiZWFybGllc3QiLCJDTE9DS19TS0VXX1NFQ1NfIiwibGF0ZXN0IiwiaW5kZXhPZiIsImlzcyIsImF1ZCIsImF1ZFZlcmlmaWVkIiwiTG9naW5UaWNrZXQiLCJhY2Nlc3NUb2tlblJlc3BvbnNlIiwiZXhwaXJ5RGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2common.js":
/*!*************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/oauth2common.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getErrorFromOAuthErrorResponse = exports.OAuthClientAuthHandler = void 0;\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst crypto_1 = __webpack_require__(/*! ../crypto/crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js\");\n/** List of HTTP methods that accept request bodies. */ const METHODS_SUPPORTING_REQUEST_BODY = [\n    \"PUT\",\n    \"POST\",\n    \"PATCH\"\n];\n/**\n * Abstract class for handling client authentication in OAuth-based\n * operations.\n * When request-body client authentication is used, only application/json and\n * application/x-www-form-urlencoded content types for HTTP methods that support\n * request bodies are supported.\n */ class OAuthClientAuthHandler {\n    /**\n     * Instantiates an OAuth client authentication handler.\n     * @param clientAuthentication The client auth credentials.\n     */ constructor(clientAuthentication){\n        this.clientAuthentication = clientAuthentication;\n        this.crypto = (0, crypto_1.createCrypto)();\n    }\n    /**\n     * Applies client authentication on the OAuth request's headers or POST\n     * body but does not process the request.\n     * @param opts The GaxiosOptions whose headers or data are to be modified\n     *   depending on the client authentication mechanism to be used.\n     * @param bearerToken The optional bearer token to use for authentication.\n     *   When this is used, no client authentication credentials are needed.\n     */ applyClientAuthenticationOptions(opts, bearerToken) {\n        // Inject authenticated header.\n        this.injectAuthenticatedHeaders(opts, bearerToken);\n        // Inject authenticated request body.\n        if (!bearerToken) {\n            this.injectAuthenticatedRequestBody(opts);\n        }\n    }\n    /**\n     * Applies client authentication on the request's header if either\n     * basic authentication or bearer token authentication is selected.\n     *\n     * @param opts The GaxiosOptions whose headers or data are to be modified\n     *   depending on the client authentication mechanism to be used.\n     * @param bearerToken The optional bearer token to use for authentication.\n     *   When this is used, no client authentication credentials are needed.\n     */ injectAuthenticatedHeaders(opts, bearerToken) {\n        var _a;\n        // Bearer token prioritized higher than basic Auth.\n        if (bearerToken) {\n            opts.headers = opts.headers || {};\n            Object.assign(opts.headers, {\n                Authorization: `Bearer ${bearerToken}}`\n            });\n        } else if (((_a = this.clientAuthentication) === null || _a === void 0 ? void 0 : _a.confidentialClientType) === \"basic\") {\n            opts.headers = opts.headers || {};\n            const clientId = this.clientAuthentication.clientId;\n            const clientSecret = this.clientAuthentication.clientSecret || \"\";\n            const base64EncodedCreds = this.crypto.encodeBase64StringUtf8(`${clientId}:${clientSecret}`);\n            Object.assign(opts.headers, {\n                Authorization: `Basic ${base64EncodedCreds}`\n            });\n        }\n    }\n    /**\n     * Applies client authentication on the request's body if request-body\n     * client authentication is selected.\n     *\n     * @param opts The GaxiosOptions whose headers or data are to be modified\n     *   depending on the client authentication mechanism to be used.\n     */ injectAuthenticatedRequestBody(opts) {\n        var _a;\n        if (((_a = this.clientAuthentication) === null || _a === void 0 ? void 0 : _a.confidentialClientType) === \"request-body\") {\n            const method = (opts.method || \"GET\").toUpperCase();\n            // Inject authenticated request body.\n            if (METHODS_SUPPORTING_REQUEST_BODY.indexOf(method) !== -1) {\n                // Get content-type.\n                let contentType;\n                const headers = opts.headers || {};\n                for(const key in headers){\n                    if (key.toLowerCase() === \"content-type\" && headers[key]) {\n                        contentType = headers[key].toLowerCase();\n                        break;\n                    }\n                }\n                if (contentType === \"application/x-www-form-urlencoded\") {\n                    opts.data = opts.data || \"\";\n                    const data = querystring.parse(opts.data);\n                    Object.assign(data, {\n                        client_id: this.clientAuthentication.clientId,\n                        client_secret: this.clientAuthentication.clientSecret || \"\"\n                    });\n                    opts.data = querystring.stringify(data);\n                } else if (contentType === \"application/json\") {\n                    opts.data = opts.data || {};\n                    Object.assign(opts.data, {\n                        client_id: this.clientAuthentication.clientId,\n                        client_secret: this.clientAuthentication.clientSecret || \"\"\n                    });\n                } else {\n                    throw new Error(`${contentType} content-types are not supported with ` + `${this.clientAuthentication.confidentialClientType} ` + \"client authentication\");\n                }\n            } else {\n                throw new Error(`${method} HTTP method does not support ` + `${this.clientAuthentication.confidentialClientType} ` + \"client authentication\");\n            }\n        }\n    }\n}\nexports.OAuthClientAuthHandler = OAuthClientAuthHandler;\n/**\n * Converts an OAuth error response to a native JavaScript Error.\n * @param resp The OAuth error response to convert to a native Error object.\n * @param err The optional original error. If provided, the error properties\n *   will be copied to the new error.\n * @return The converted native Error object.\n */ function getErrorFromOAuthErrorResponse(resp, err) {\n    // Error response.\n    const errorCode = resp.error;\n    const errorDescription = resp.error_description;\n    const errorUri = resp.error_uri;\n    let message = `Error code ${errorCode}`;\n    if (typeof errorDescription !== \"undefined\") {\n        message += `: ${errorDescription}`;\n    }\n    if (typeof errorUri !== \"undefined\") {\n        message += ` - ${errorUri}`;\n    }\n    const newError = new Error(message);\n    // Copy properties from original error to newly generated error.\n    if (err) {\n        const keys = Object.keys(err);\n        if (err.stack) {\n            // Copy error.stack if available.\n            keys.push(\"stack\");\n        }\n        keys.forEach((key)=>{\n            // Do not overwrite the message field.\n            if (key !== \"message\") {\n                Object.defineProperty(newError, key, {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    value: err[key],\n                    writable: false,\n                    enumerable: true\n                });\n            }\n        });\n    }\n    return newError;\n}\nexports.getErrorFromOAuthErrorResponse = getErrorFromOAuthErrorResponse; //# sourceMappingURL=oauth2common.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9vYXV0aDJjb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQ0FBc0MsR0FBR0EsOEJBQThCLEdBQUcsS0FBSztBQUMvRSxNQUFNSSxjQUFjQyxtQkFBT0EsQ0FBQyxnQ0FBYTtBQUN6QyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyw2RkFBa0I7QUFDM0MscURBQXFELEdBQ3JELE1BQU1FLGtDQUFrQztJQUFDO0lBQU87SUFBUTtDQUFRO0FBQ2hFOzs7Ozs7Q0FNQyxHQUNELE1BQU1KO0lBQ0Y7OztLQUdDLEdBQ0RLLFlBQVlDLG9CQUFvQixDQUFFO1FBQzlCLElBQUksQ0FBQ0Esb0JBQW9CLEdBQUdBO1FBQzVCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLENBQUMsR0FBR0osU0FBU0ssWUFBWTtJQUMzQztJQUNBOzs7Ozs7O0tBT0MsR0FDREMsaUNBQWlDQyxJQUFJLEVBQUVDLFdBQVcsRUFBRTtRQUNoRCwrQkFBK0I7UUFDL0IsSUFBSSxDQUFDQywwQkFBMEIsQ0FBQ0YsTUFBTUM7UUFDdEMscUNBQXFDO1FBQ3JDLElBQUksQ0FBQ0EsYUFBYTtZQUNkLElBQUksQ0FBQ0UsOEJBQThCLENBQUNIO1FBQ3hDO0lBQ0o7SUFDQTs7Ozs7Ozs7S0FRQyxHQUNERSwyQkFBMkJGLElBQUksRUFBRUMsV0FBVyxFQUFFO1FBQzFDLElBQUlHO1FBQ0osbURBQW1EO1FBQ25ELElBQUlILGFBQWE7WUFDYkQsS0FBS0ss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QixDQUFDWSxzQkFBc0IsQ0FBQyxDQUFDLENBQUMsR0FDdEQ7WUFDUjtRQUNKO0lBQ0o7QUFDSjtBQUNBckIsOEJBQThCLEdBQUdHO0FBQ2pDOzs7Ozs7Q0FNQyxHQUNELFNBQVNELCtCQUErQm9DLElBQUksRUFBRUMsR0FBRztJQUM3QyxrQkFBa0I7SUFDbEIsTUFBTUMsWUFBWUYsS0FBS0csS0FBSztJQUM1QixNQUFNQyxtQkFBbUJKLEtBQUtLLGlCQUFpQjtJQUMvQyxNQUFNQyxXQUFXTixLQUFLTyxTQUFTO0lBQy9CLElBQUlDLFVBQVUsQ0FBQyxXQUFXLEVBQUVOLFVBQVUsQ0FBQztJQUN2QyxJQUFJLE9BQU9FLHFCQUFxQixhQUFhO1FBQ3pDSSxXQUFXLENBQUMsRUFBRSxFQUFFSixpQkFBaUIsQ0FBQztJQUN0QztJQUNBLElBQUksT0FBT0UsYUFBYSxhQUFhO1FBQ2pDRSxXQUFXLENBQUMsR0FBRyxFQUFFRixTQUFTLENBQUM7SUFDL0I7SUFDQSxNQUFNRyxXQUFXLElBQUlWLE1BQU1TO0lBQzNCLGdFQUFnRTtJQUNoRSxJQUFJUCxLQUFLO1FBQ0wsTUFBTVMsT0FBT2xELE9BQU9rRCxJQUFJLENBQUNUO1FBQ3pCLElBQUlBLElBQUlVLEtBQUssRUFBRTtZQUNYLGlDQUFpQztZQUNqQ0QsS0FBS0UsSUFBSSxDQUFDO1FBQ2Q7UUFDQUYsS0FBS0csT0FBTyxDQUFDckIsQ0FBQUE7WUFDVCxzQ0FBc0M7WUFDdEMsSUFBSUEsUUFBUSxXQUFXO2dCQUNuQmhDLE9BQU9DLGNBQWMsQ0FBQ2dELFVBQVVqQixLQUFLO29CQUNqQyw4REFBOEQ7b0JBQzlEN0IsT0FBT3NDLEdBQUcsQ0FBQ1QsSUFBSTtvQkFDZnNCLFVBQVU7b0JBQ1ZDLFlBQVk7Z0JBQ2hCO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsT0FBT047QUFDWDtBQUNBL0Msc0NBQXNDLEdBQUdFLGdDQUN6Qyx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9vYXV0aDJjb21tb24uanM/MWYxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRFcnJvckZyb21PQXV0aEVycm9yUmVzcG9uc2UgPSBleHBvcnRzLk9BdXRoQ2xpZW50QXV0aEhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBxdWVyeXN0cmluZyA9IHJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKTtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIi4uL2NyeXB0by9jcnlwdG9cIik7XG4vKiogTGlzdCBvZiBIVFRQIG1ldGhvZHMgdGhhdCBhY2NlcHQgcmVxdWVzdCBib2RpZXMuICovXG5jb25zdCBNRVRIT0RTX1NVUFBPUlRJTkdfUkVRVUVTVF9CT0RZID0gWydQVVQnLCAnUE9TVCcsICdQQVRDSCddO1xuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyBmb3IgaGFuZGxpbmcgY2xpZW50IGF1dGhlbnRpY2F0aW9uIGluIE9BdXRoLWJhc2VkXG4gKiBvcGVyYXRpb25zLlxuICogV2hlbiByZXF1ZXN0LWJvZHkgY2xpZW50IGF1dGhlbnRpY2F0aW9uIGlzIHVzZWQsIG9ubHkgYXBwbGljYXRpb24vanNvbiBhbmRcbiAqIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCBjb250ZW50IHR5cGVzIGZvciBIVFRQIG1ldGhvZHMgdGhhdCBzdXBwb3J0XG4gKiByZXF1ZXN0IGJvZGllcyBhcmUgc3VwcG9ydGVkLlxuICovXG5jbGFzcyBPQXV0aENsaWVudEF1dGhIYW5kbGVyIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYW4gT0F1dGggY2xpZW50IGF1dGhlbnRpY2F0aW9uIGhhbmRsZXIuXG4gICAgICogQHBhcmFtIGNsaWVudEF1dGhlbnRpY2F0aW9uIFRoZSBjbGllbnQgYXV0aCBjcmVkZW50aWFscy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGllbnRBdXRoZW50aWNhdGlvbikge1xuICAgICAgICB0aGlzLmNsaWVudEF1dGhlbnRpY2F0aW9uID0gY2xpZW50QXV0aGVudGljYXRpb247XG4gICAgICAgIHRoaXMuY3J5cHRvID0gKDAsIGNyeXB0b18xLmNyZWF0ZUNyeXB0bykoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBjbGllbnQgYXV0aGVudGljYXRpb24gb24gdGhlIE9BdXRoIHJlcXVlc3QncyBoZWFkZXJzIG9yIFBPU1RcbiAgICAgKiBib2R5IGJ1dCBkb2VzIG5vdCBwcm9jZXNzIHRoZSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBHYXhpb3NPcHRpb25zIHdob3NlIGhlYWRlcnMgb3IgZGF0YSBhcmUgdG8gYmUgbW9kaWZpZWRcbiAgICAgKiAgIGRlcGVuZGluZyBvbiB0aGUgY2xpZW50IGF1dGhlbnRpY2F0aW9uIG1lY2hhbmlzbSB0byBiZSB1c2VkLlxuICAgICAqIEBwYXJhbSBiZWFyZXJUb2tlbiBUaGUgb3B0aW9uYWwgYmVhcmVyIHRva2VuIHRvIHVzZSBmb3IgYXV0aGVudGljYXRpb24uXG4gICAgICogICBXaGVuIHRoaXMgaXMgdXNlZCwgbm8gY2xpZW50IGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzIGFyZSBuZWVkZWQuXG4gICAgICovXG4gICAgYXBwbHlDbGllbnRBdXRoZW50aWNhdGlvbk9wdGlvbnMob3B0cywgYmVhcmVyVG9rZW4pIHtcbiAgICAgICAgLy8gSW5qZWN0IGF1dGhlbnRpY2F0ZWQgaGVhZGVyLlxuICAgICAgICB0aGlzLmluamVjdEF1dGhlbnRpY2F0ZWRIZWFkZXJzKG9wdHMsIGJlYXJlclRva2VuKTtcbiAgICAgICAgLy8gSW5qZWN0IGF1dGhlbnRpY2F0ZWQgcmVxdWVzdCBib2R5LlxuICAgICAgICBpZiAoIWJlYXJlclRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLmluamVjdEF1dGhlbnRpY2F0ZWRSZXF1ZXN0Qm9keShvcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGNsaWVudCBhdXRoZW50aWNhdGlvbiBvbiB0aGUgcmVxdWVzdCdzIGhlYWRlciBpZiBlaXRoZXJcbiAgICAgKiBiYXNpYyBhdXRoZW50aWNhdGlvbiBvciBiZWFyZXIgdG9rZW4gYXV0aGVudGljYXRpb24gaXMgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgR2F4aW9zT3B0aW9ucyB3aG9zZSBoZWFkZXJzIG9yIGRhdGEgYXJlIHRvIGJlIG1vZGlmaWVkXG4gICAgICogICBkZXBlbmRpbmcgb24gdGhlIGNsaWVudCBhdXRoZW50aWNhdGlvbiBtZWNoYW5pc20gdG8gYmUgdXNlZC5cbiAgICAgKiBAcGFyYW0gYmVhcmVyVG9rZW4gVGhlIG9wdGlvbmFsIGJlYXJlciB0b2tlbiB0byB1c2UgZm9yIGF1dGhlbnRpY2F0aW9uLlxuICAgICAqICAgV2hlbiB0aGlzIGlzIHVzZWQsIG5vIGNsaWVudCBhdXRoZW50aWNhdGlvbiBjcmVkZW50aWFscyBhcmUgbmVlZGVkLlxuICAgICAqL1xuICAgIGluamVjdEF1dGhlbnRpY2F0ZWRIZWFkZXJzKG9wdHMsIGJlYXJlclRva2VuKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gQmVhcmVyIHRva2VuIHByaW9yaXRpemVkIGhpZ2hlciB0aGFuIGJhc2ljIEF1dGguXG4gICAgICAgIGlmIChiZWFyZXJUb2tlbikge1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLmhlYWRlcnMsIHtcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YmVhcmVyVG9rZW59fWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoKF9hID0gdGhpcy5jbGllbnRBdXRoZW50aWNhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmZpZGVudGlhbENsaWVudFR5cGUpID09PSAnYmFzaWMnKSB7XG4gICAgICAgICAgICBvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgICBjb25zdCBjbGllbnRJZCA9IHRoaXMuY2xpZW50QXV0aGVudGljYXRpb24uY2xpZW50SWQ7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRTZWNyZXQgPSB0aGlzLmNsaWVudEF1dGhlbnRpY2F0aW9uLmNsaWVudFNlY3JldCB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IGJhc2U2NEVuY29kZWRDcmVkcyA9IHRoaXMuY3J5cHRvLmVuY29kZUJhc2U2NFN0cmluZ1V0ZjgoYCR7Y2xpZW50SWR9OiR7Y2xpZW50U2VjcmV0fWApO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLmhlYWRlcnMsIHtcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmFzaWMgJHtiYXNlNjRFbmNvZGVkQ3JlZHN9YCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgY2xpZW50IGF1dGhlbnRpY2F0aW9uIG9uIHRoZSByZXF1ZXN0J3MgYm9keSBpZiByZXF1ZXN0LWJvZHlcbiAgICAgKiBjbGllbnQgYXV0aGVudGljYXRpb24gaXMgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgR2F4aW9zT3B0aW9ucyB3aG9zZSBoZWFkZXJzIG9yIGRhdGEgYXJlIHRvIGJlIG1vZGlmaWVkXG4gICAgICogICBkZXBlbmRpbmcgb24gdGhlIGNsaWVudCBhdXRoZW50aWNhdGlvbiBtZWNoYW5pc20gdG8gYmUgdXNlZC5cbiAgICAgKi9cbiAgICBpbmplY3RBdXRoZW50aWNhdGVkUmVxdWVzdEJvZHkob3B0cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5jbGllbnRBdXRoZW50aWNhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmZpZGVudGlhbENsaWVudFR5cGUpID09PSAncmVxdWVzdC1ib2R5Jykge1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gKG9wdHMubWV0aG9kIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgLy8gSW5qZWN0IGF1dGhlbnRpY2F0ZWQgcmVxdWVzdCBib2R5LlxuICAgICAgICAgICAgaWYgKE1FVEhPRFNfU1VQUE9SVElOR19SRVFVRVNUX0JPRFkuaW5kZXhPZihtZXRob2QpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIEdldCBjb250ZW50LXR5cGUuXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnICYmIGhlYWRlcnNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGUgPSBoZWFkZXJzW2tleV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5kYXRhID0gb3B0cy5kYXRhIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcXVlcnlzdHJpbmcucGFyc2Uob3B0cy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihkYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRfaWQ6IHRoaXMuY2xpZW50QXV0aGVudGljYXRpb24uY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRfc2VjcmV0OiB0aGlzLmNsaWVudEF1dGhlbnRpY2F0aW9uLmNsaWVudFNlY3JldCB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMuZGF0YSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9qc29uJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRzLmRhdGEgPSBvcHRzLmRhdGEgfHwge307XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0cy5kYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRfaWQ6IHRoaXMuY2xpZW50QXV0aGVudGljYXRpb24uY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRfc2VjcmV0OiB0aGlzLmNsaWVudEF1dGhlbnRpY2F0aW9uLmNsaWVudFNlY3JldCB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGVudFR5cGV9IGNvbnRlbnQtdHlwZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke3RoaXMuY2xpZW50QXV0aGVudGljYXRpb24uY29uZmlkZW50aWFsQ2xpZW50VHlwZX0gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xpZW50IGF1dGhlbnRpY2F0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke21ldGhvZH0gSFRUUCBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBgICtcbiAgICAgICAgICAgICAgICAgICAgYCR7dGhpcy5jbGllbnRBdXRoZW50aWNhdGlvbi5jb25maWRlbnRpYWxDbGllbnRUeXBlfSBgICtcbiAgICAgICAgICAgICAgICAgICAgJ2NsaWVudCBhdXRoZW50aWNhdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5PQXV0aENsaWVudEF1dGhIYW5kbGVyID0gT0F1dGhDbGllbnRBdXRoSGFuZGxlcjtcbi8qKlxuICogQ29udmVydHMgYW4gT0F1dGggZXJyb3IgcmVzcG9uc2UgdG8gYSBuYXRpdmUgSmF2YVNjcmlwdCBFcnJvci5cbiAqIEBwYXJhbSByZXNwIFRoZSBPQXV0aCBlcnJvciByZXNwb25zZSB0byBjb252ZXJ0IHRvIGEgbmF0aXZlIEVycm9yIG9iamVjdC5cbiAqIEBwYXJhbSBlcnIgVGhlIG9wdGlvbmFsIG9yaWdpbmFsIGVycm9yLiBJZiBwcm92aWRlZCwgdGhlIGVycm9yIHByb3BlcnRpZXNcbiAqICAgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIG5ldyBlcnJvci5cbiAqIEByZXR1cm4gVGhlIGNvbnZlcnRlZCBuYXRpdmUgRXJyb3Igb2JqZWN0LlxuICovXG5mdW5jdGlvbiBnZXRFcnJvckZyb21PQXV0aEVycm9yUmVzcG9uc2UocmVzcCwgZXJyKSB7XG4gICAgLy8gRXJyb3IgcmVzcG9uc2UuXG4gICAgY29uc3QgZXJyb3JDb2RlID0gcmVzcC5lcnJvcjtcbiAgICBjb25zdCBlcnJvckRlc2NyaXB0aW9uID0gcmVzcC5lcnJvcl9kZXNjcmlwdGlvbjtcbiAgICBjb25zdCBlcnJvclVyaSA9IHJlc3AuZXJyb3JfdXJpO1xuICAgIGxldCBtZXNzYWdlID0gYEVycm9yIGNvZGUgJHtlcnJvckNvZGV9YDtcbiAgICBpZiAodHlwZW9mIGVycm9yRGVzY3JpcHRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYDogJHtlcnJvckRlc2NyaXB0aW9ufWA7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXJyb3JVcmkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYCAtICR7ZXJyb3JVcml9YDtcbiAgICB9XG4gICAgY29uc3QgbmV3RXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gb3JpZ2luYWwgZXJyb3IgdG8gbmV3bHkgZ2VuZXJhdGVkIGVycm9yLlxuICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGVycik7XG4gICAgICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgICAgICAgIC8vIENvcHkgZXJyb3Iuc3RhY2sgaWYgYXZhaWxhYmxlLlxuICAgICAgICAgICAga2V5cy5wdXNoKCdzdGFjaycpO1xuICAgICAgICB9XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgLy8gRG8gbm90IG92ZXJ3cml0ZSB0aGUgbWVzc2FnZSBmaWVsZC5cbiAgICAgICAgICAgIGlmIChrZXkgIT09ICdtZXNzYWdlJykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdFcnJvciwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlcnJba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0Vycm9yO1xufVxuZXhwb3J0cy5nZXRFcnJvckZyb21PQXV0aEVycm9yUmVzcG9uc2UgPSBnZXRFcnJvckZyb21PQXV0aEVycm9yUmVzcG9uc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYXV0aDJjb21tb24uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0RXJyb3JGcm9tT0F1dGhFcnJvclJlc3BvbnNlIiwiT0F1dGhDbGllbnRBdXRoSGFuZGxlciIsInF1ZXJ5c3RyaW5nIiwicmVxdWlyZSIsImNyeXB0b18xIiwiTUVUSE9EU19TVVBQT1JUSU5HX1JFUVVFU1RfQk9EWSIsImNvbnN0cnVjdG9yIiwiY2xpZW50QXV0aGVudGljYXRpb24iLCJjcnlwdG8iLCJjcmVhdGVDcnlwdG8iLCJhcHBseUNsaWVudEF1dGhlbnRpY2F0aW9uT3B0aW9ucyIsIm9wdHMiLCJiZWFyZXJUb2tlbiIsImluamVjdEF1dGhlbnRpY2F0ZWRIZWFkZXJzIiwiaW5qZWN0QXV0aGVudGljYXRlZFJlcXVlc3RCb2R5IiwiX2EiLCJoZWFkZXJzIiwiYXNzaWduIiwiQXV0aG9yaXphdGlvbiIsImNvbmZpZGVudGlhbENsaWVudFR5cGUiLCJjbGllbnRJZCIsImNsaWVudFNlY3JldCIsImJhc2U2NEVuY29kZWRDcmVkcyIsImVuY29kZUJhc2U2NFN0cmluZ1V0ZjgiLCJtZXRob2QiLCJ0b1VwcGVyQ2FzZSIsImluZGV4T2YiLCJjb250ZW50VHlwZSIsImtleSIsInRvTG93ZXJDYXNlIiwiZGF0YSIsInBhcnNlIiwiY2xpZW50X2lkIiwiY2xpZW50X3NlY3JldCIsInN0cmluZ2lmeSIsIkVycm9yIiwicmVzcCIsImVyciIsImVycm9yQ29kZSIsImVycm9yIiwiZXJyb3JEZXNjcmlwdGlvbiIsImVycm9yX2Rlc2NyaXB0aW9uIiwiZXJyb3JVcmkiLCJlcnJvcl91cmkiLCJtZXNzYWdlIiwibmV3RXJyb3IiLCJrZXlzIiwic3RhY2siLCJwdXNoIiwiZm9yRWFjaCIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PluggableAuthClient = exports.ExecutableError = void 0;\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nconst executable_response_1 = __webpack_require__(/*! ./executable-response */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/executable-response.js\");\nconst pluggable_auth_handler_1 = __webpack_require__(/*! ./pluggable-auth-handler */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js\");\n/**\n * Error thrown from the executable run by PluggableAuthClient.\n */ class ExecutableError extends Error {\n    constructor(message, code){\n        super(`The executable failed with exit code: ${code} and error message: ${message}.`);\n        this.code = code;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nexports.ExecutableError = ExecutableError;\n/**\n * The default executable timeout when none is provided, in milliseconds.\n */ const DEFAULT_EXECUTABLE_TIMEOUT_MILLIS = 30 * 1000;\n/**\n * The minimum allowed executable timeout in milliseconds.\n */ const MINIMUM_EXECUTABLE_TIMEOUT_MILLIS = 5 * 1000;\n/**\n * The maximum allowed executable timeout in milliseconds.\n */ const MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS = 120 * 1000;\n/**\n * The environment variable to check to see if executable can be run.\n * Value must be set to '1' for the executable to run.\n */ const GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES = \"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\";\n/**\n * The maximum currently supported executable version.\n */ const MAXIMUM_EXECUTABLE_VERSION = 1;\n/**\n * PluggableAuthClient enables the exchange of workload identity pool external credentials for\n * Google access tokens by retrieving 3rd party tokens through a user supplied executable. These\n * scripts/executables are completely independent of the Google Cloud Auth libraries. These\n * credentials plug into ADC and will call the specified executable to retrieve the 3rd party token\n * to be exchanged for a Google access token.\n *\n * <p>To use these credentials, the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment variable\n * must be set to '1'. This is for security reasons.\n *\n * <p>Both OIDC and SAML are supported. The executable must adhere to a specific response format\n * defined below.\n *\n * <p>The executable must print out the 3rd party token to STDOUT in JSON format. When an\n * output_file is specified in the credential configuration, the executable must also handle writing the\n * JSON response to this file.\n *\n * <pre>\n * OIDC response sample:\n * {\n *   \"version\": 1,\n *   \"success\": true,\n *   \"token_type\": \"urn:ietf:params:oauth:token-type:id_token\",\n *   \"id_token\": \"HEADER.PAYLOAD.SIGNATURE\",\n *   \"expiration_time\": 1620433341\n * }\n *\n * SAML2 response sample:\n * {\n *   \"version\": 1,\n *   \"success\": true,\n *   \"token_type\": \"urn:ietf:params:oauth:token-type:saml2\",\n *   \"saml_response\": \"...\",\n *   \"expiration_time\": 1620433341\n * }\n *\n * Error response sample:\n * {\n *   \"version\": 1,\n *   \"success\": false,\n *   \"code\": \"401\",\n *   \"message\": \"Error message.\"\n * }\n * </pre>\n *\n * <p>The \"expiration_time\" field in the JSON response is only required for successful\n * responses when an output file was specified in the credential configuration\n *\n * <p>The auth libraries will populate certain environment variables that will be accessible by the\n * executable, such as: GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE, GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE,\n * GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE, GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL, and\n * GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE.\n *\n * <p>Please see this repositories README for a complete executable request/response specification.\n */ class PluggableAuthClient extends baseexternalclient_1.BaseExternalAccountClient {\n    /**\n     * Instantiates a PluggableAuthClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * An error is thrown if the credential is not a valid pluggable auth credential.\n     * @param options The external account options object typically loaded from\n     *   the external account JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     */ constructor(options, additionalOptions){\n        super(options, additionalOptions);\n        if (!options.credential_source.executable) {\n            throw new Error('No valid Pluggable Auth \"credential_source\" provided.');\n        }\n        this.command = options.credential_source.executable.command;\n        if (!this.command) {\n            throw new Error('No valid Pluggable Auth \"credential_source\" provided.');\n        }\n        // Check if the provided timeout exists and if it is valid.\n        if (options.credential_source.executable.timeout_millis === undefined) {\n            this.timeoutMillis = DEFAULT_EXECUTABLE_TIMEOUT_MILLIS;\n        } else {\n            this.timeoutMillis = options.credential_source.executable.timeout_millis;\n            if (this.timeoutMillis < MINIMUM_EXECUTABLE_TIMEOUT_MILLIS || this.timeoutMillis > MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS) {\n                throw new Error(`Timeout must be between ${MINIMUM_EXECUTABLE_TIMEOUT_MILLIS} and ` + `${MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS} milliseconds.`);\n            }\n        }\n        this.outputFile = options.credential_source.executable.output_file;\n        this.handler = new pluggable_auth_handler_1.PluggableAuthHandler({\n            command: this.command,\n            timeoutMillis: this.timeoutMillis,\n            outputFile: this.outputFile\n        });\n    }\n    /**\n     * Triggered when an external subject token is needed to be exchanged for a\n     * GCP access token via GCP STS endpoint.\n     * This uses the `options.credential_source` object to figure out how\n     * to retrieve the token using the current environment. In this case,\n     * this calls a user provided executable which returns the subject token.\n     * The logic is summarized as:\n     * 1. Validated that the executable is allowed to run. The\n     *    GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment must be set to\n     *    1 for security reasons.\n     * 2. If an output file is specified by the user, check the file location\n     *    for a response. If the file exists and contains a valid response,\n     *    return the subject token from the file.\n     * 3. Call the provided executable and return response.\n     * @return A promise that resolves with the external subject token.\n     */ async retrieveSubjectToken() {\n        // Check if the executable is allowed to run.\n        if (process.env[GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES] !== \"1\") {\n            throw new Error(\"Pluggable Auth executables need to be explicitly allowed to run by \" + \"setting the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment \" + \"Variable to 1.\");\n        }\n        let executableResponse = undefined;\n        // Try to get cached executable response from output file.\n        if (this.outputFile) {\n            executableResponse = await this.handler.retrieveCachedResponse();\n        }\n        // If no response from output file, call the executable.\n        if (!executableResponse) {\n            // Set up environment map with required values for the executable.\n            const envMap = new Map();\n            envMap.set(\"GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE\", this.audience);\n            envMap.set(\"GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE\", this.subjectTokenType);\n            // Always set to 0 because interactive mode is not supported.\n            envMap.set(\"GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE\", \"0\");\n            if (this.outputFile) {\n                envMap.set(\"GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE\", this.outputFile);\n            }\n            const serviceAccountEmail = this.getServiceAccountEmail();\n            if (serviceAccountEmail) {\n                envMap.set(\"GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL\", serviceAccountEmail);\n            }\n            executableResponse = await this.handler.retrieveResponseFromExecutable(envMap);\n        }\n        if (executableResponse.version > MAXIMUM_EXECUTABLE_VERSION) {\n            throw new Error(`Version of executable is not currently supported, maximum supported version is ${MAXIMUM_EXECUTABLE_VERSION}.`);\n        }\n        // Check that response was successful.\n        if (!executableResponse.success) {\n            throw new ExecutableError(executableResponse.errorMessage, executableResponse.errorCode);\n        }\n        // Check that response contains expiration time if output file was specified.\n        if (this.outputFile) {\n            if (!executableResponse.expirationTime) {\n                throw new executable_response_1.InvalidExpirationTimeFieldError(\"The executable response must contain the `expiration_time` field for successful responses when an output_file has been specified in the configuration.\");\n            }\n        }\n        // Check that response is not expired.\n        if (executableResponse.isExpired()) {\n            throw new Error(\"Executable response is expired.\");\n        }\n        // Return subject token from response.\n        return executableResponse.subjectToken;\n    }\n}\nexports.PluggableAuthClient = PluggableAuthClient; //# sourceMappingURL=pluggable-auth-client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9wbHVnZ2FibGUtYXV0aC1jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQkFBMkIsR0FBR0EsdUJBQXVCLEdBQUcsS0FBSztBQUM3RCxNQUFNSSx1QkFBdUJDLG1CQUFPQSxDQUFDLDJHQUFzQjtBQUMzRCxNQUFNQyx3QkFBd0JELG1CQUFPQSxDQUFDLDZHQUF1QjtBQUM3RCxNQUFNRSwyQkFBMkJGLG1CQUFPQSxDQUFDLG1IQUEwQjtBQUNuRTs7Q0FFQyxHQUNELE1BQU1GLHdCQUF3Qks7SUFDMUJDLFlBQVlDLE9BQU8sRUFBRUMsSUFBSSxDQUFFO1FBQ3ZCLEtBQUssQ0FBQyxDQUFDLHNDQUFzQyxFQUFFQSxLQUFLLG9CQUFvQixFQUFFRCxRQUFRLENBQUMsQ0FBQztRQUNwRixJQUFJLENBQUNDLElBQUksR0FBR0E7UUFDWmIsT0FBT2MsY0FBYyxDQUFDLElBQUksRUFBRSxXQUFXQyxTQUFTO0lBQ3BEO0FBQ0o7QUFDQWIsdUJBQXVCLEdBQUdHO0FBQzFCOztDQUVDLEdBQ0QsTUFBTVcsb0NBQW9DLEtBQUs7QUFDL0M7O0NBRUMsR0FDRCxNQUFNQyxvQ0FBb0MsSUFBSTtBQUM5Qzs7Q0FFQyxHQUNELE1BQU1DLG9DQUFvQyxNQUFNO0FBQ2hEOzs7Q0FHQyxHQUNELE1BQU1DLDRDQUE0QztBQUNsRDs7Q0FFQyxHQUNELE1BQU1DLDZCQUE2QjtBQUNuQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0RDLEdBQ0QsTUFBTWhCLDRCQUE0QkUscUJBQXFCZSx5QkFBeUI7SUFDNUU7Ozs7Ozs7OztLQVNDLEdBQ0RWLFlBQVlXLE9BQU8sRUFBRUMsaUJBQWlCLENBQUU7UUFDcEMsS0FBSyxDQUFDRCxTQUFTQztRQUNmLElBQUksQ0FBQ0QsUUFBUUUsaUJBQWlCLENBQUNDLFVBQVUsRUFBRTtZQUN2QyxNQUFNLElBQUlmLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUNnQixPQUFPLEdBQUdKLFFBQVFFLGlCQUFpQixDQUFDQyxVQUFVLENBQUNDLE9BQU87UUFDM0QsSUFBSSxDQUFDLElBQUksQ0FBQ0EsT0FBTyxFQUFFO1lBQ2YsTUFBTSxJQUFJaEIsTUFBTTtRQUNwQjtRQUNBLDJEQUEyRDtRQUMzRCxJQUFJWSxRQUFRRSxpQkFBaUIsQ0FBQ0MsVUFBVSxDQUFDRSxjQUFjLEtBQUtDLFdBQVc7WUFDbkUsSUFBSSxDQUFDQyxhQUFhLEdBQUdiO1FBQ3pCLE9BQ0s7WUFDRCxJQUFJLENBQUNhLGFBQWEsR0FBR1AsUUFBUUUsaUJBQWlCLENBQUNDLFVBQVUsQ0FBQ0UsY0FBYztZQUN4RSxJQUFJLElBQUksQ0FBQ0UsYUFBYSxHQUFHWixxQ0FDckIsSUFBSSxDQUFDWSxhQUFhLEdBQUdYLG1DQUFtQztnQkFDeEQsTUFBTSxJQUFJUixNQUFNLENBQUMsd0JBQXdCLEVBQUVPLGtDQUFrQyxLQUFLLENBQUMsR0FDL0UsQ0FBQyxFQUFFQyxrQ0FBa0MsY0FBYyxDQUFDO1lBQzVEO1FBQ0o7UUFDQSxJQUFJLENBQUNZLFVBQVUsR0FBR1IsUUFBUUUsaUJBQWlCLENBQUNDLFVBQVUsQ0FBQ00sV0FBVztRQUNsRSxJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJdkIseUJBQXlCd0Isb0JBQW9CLENBQUM7WUFDN0RQLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCRyxlQUFlLElBQUksQ0FBQ0EsYUFBYTtZQUNqQ0MsWUFBWSxJQUFJLENBQUNBLFVBQVU7UUFDL0I7SUFDSjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7S0FlQyxHQUNELE1BQU1JLHVCQUF1QjtRQUN6Qiw2Q0FBNkM7UUFDN0MsSUFBSUMsUUFBUUMsR0FBRyxDQUFDakIsMENBQTBDLEtBQUssS0FBSztZQUNoRSxNQUFNLElBQUlULE1BQU0sd0VBQ1osdUVBQ0E7UUFDUjtRQUNBLElBQUkyQixxQkFBcUJUO1FBQ3pCLDBEQUEwRDtRQUMxRCxJQUFJLElBQUksQ0FBQ0UsVUFBVSxFQUFFO1lBQ2pCTyxxQkFBcUIsTUFBTSxJQUFJLENBQUNMLE9BQU8sQ0FBQ00sc0JBQXNCO1FBQ2xFO1FBQ0Esd0RBQXdEO1FBQ3hELElBQUksQ0FBQ0Qsb0JBQW9CO1lBQ3JCLGtFQUFrRTtZQUNsRSxNQUFNRSxTQUFTLElBQUlDO1lBQ25CRCxPQUFPRSxHQUFHLENBQUMsb0NBQW9DLElBQUksQ0FBQ0MsUUFBUTtZQUM1REgsT0FBT0UsR0FBRyxDQUFDLHNDQUFzQyxJQUFJLENBQUNFLGdCQUFnQjtZQUN0RSw2REFBNkQ7WUFDN0RKLE9BQU9FLEdBQUcsQ0FBQyx1Q0FBdUM7WUFDbEQsSUFBSSxJQUFJLENBQUNYLFVBQVUsRUFBRTtnQkFDakJTLE9BQU9FLEdBQUcsQ0FBQyx1Q0FBdUMsSUFBSSxDQUFDWCxVQUFVO1lBQ3JFO1lBQ0EsTUFBTWMsc0JBQXNCLElBQUksQ0FBQ0Msc0JBQXNCO1lBQ3ZELElBQUlELHFCQUFxQjtnQkFDckJMLE9BQU9FLEdBQUcsQ0FBQyw4Q0FBOENHO1lBQzdEO1lBQ0FQLHFCQUFxQixNQUFNLElBQUksQ0FBQ0wsT0FBTyxDQUFDYyw4QkFBOEIsQ0FBQ1A7UUFDM0U7UUFDQSxJQUFJRixtQkFBbUJVLE9BQU8sR0FBRzNCLDRCQUE0QjtZQUN6RCxNQUFNLElBQUlWLE1BQU0sQ0FBQywrRUFBK0UsRUFBRVUsMkJBQTJCLENBQUMsQ0FBQztRQUNuSTtRQUNBLHNDQUFzQztRQUN0QyxJQUFJLENBQUNpQixtQkFBbUJXLE9BQU8sRUFBRTtZQUM3QixNQUFNLElBQUkzQyxnQkFBZ0JnQyxtQkFBbUJZLFlBQVksRUFBRVosbUJBQW1CYSxTQUFTO1FBQzNGO1FBQ0EsNkVBQTZFO1FBQzdFLElBQUksSUFBSSxDQUFDcEIsVUFBVSxFQUFFO1lBQ2pCLElBQUksQ0FBQ08sbUJBQW1CYyxjQUFjLEVBQUU7Z0JBQ3BDLE1BQU0sSUFBSTNDLHNCQUFzQjRDLCtCQUErQixDQUFDO1lBQ3BFO1FBQ0o7UUFDQSxzQ0FBc0M7UUFDdEMsSUFBSWYsbUJBQW1CZ0IsU0FBUyxJQUFJO1lBQ2hDLE1BQU0sSUFBSTNDLE1BQU07UUFDcEI7UUFDQSxzQ0FBc0M7UUFDdEMsT0FBTzJCLG1CQUFtQmlCLFlBQVk7SUFDMUM7QUFDSjtBQUNBcEQsMkJBQTJCLEdBQUdFLHFCQUM5QixpREFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9wbHVnZ2FibGUtYXV0aC1jbGllbnQuanM/YzE4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QbHVnZ2FibGVBdXRoQ2xpZW50ID0gZXhwb3J0cy5FeGVjdXRhYmxlRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBiYXNlZXh0ZXJuYWxjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2Jhc2VleHRlcm5hbGNsaWVudFwiKTtcbmNvbnN0IGV4ZWN1dGFibGVfcmVzcG9uc2VfMSA9IHJlcXVpcmUoXCIuL2V4ZWN1dGFibGUtcmVzcG9uc2VcIik7XG5jb25zdCBwbHVnZ2FibGVfYXV0aF9oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9wbHVnZ2FibGUtYXV0aC1oYW5kbGVyXCIpO1xuLyoqXG4gKiBFcnJvciB0aHJvd24gZnJvbSB0aGUgZXhlY3V0YWJsZSBydW4gYnkgUGx1Z2dhYmxlQXV0aENsaWVudC5cbiAqL1xuY2xhc3MgRXhlY3V0YWJsZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIoYFRoZSBleGVjdXRhYmxlIGZhaWxlZCB3aXRoIGV4aXQgY29kZTogJHtjb2RlfSBhbmQgZXJyb3IgbWVzc2FnZTogJHttZXNzYWdlfS5gKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLkV4ZWN1dGFibGVFcnJvciA9IEV4ZWN1dGFibGVFcnJvcjtcbi8qKlxuICogVGhlIGRlZmF1bHQgZXhlY3V0YWJsZSB0aW1lb3V0IHdoZW4gbm9uZSBpcyBwcm92aWRlZCwgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5jb25zdCBERUZBVUxUX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVMgPSAzMCAqIDEwMDA7XG4vKipcbiAqIFRoZSBtaW5pbXVtIGFsbG93ZWQgZXhlY3V0YWJsZSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuY29uc3QgTUlOSU1VTV9FWEVDVVRBQkxFX1RJTUVPVVRfTUlMTElTID0gNSAqIDEwMDA7XG4vKipcbiAqIFRoZSBtYXhpbXVtIGFsbG93ZWQgZXhlY3V0YWJsZSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuY29uc3QgTUFYSU1VTV9FWEVDVVRBQkxFX1RJTUVPVVRfTUlMTElTID0gMTIwICogMTAwMDtcbi8qKlxuICogVGhlIGVudmlyb25tZW50IHZhcmlhYmxlIHRvIGNoZWNrIHRvIHNlZSBpZiBleGVjdXRhYmxlIGNhbiBiZSBydW4uXG4gKiBWYWx1ZSBtdXN0IGJlIHNldCB0byAnMScgZm9yIHRoZSBleGVjdXRhYmxlIHRvIHJ1bi5cbiAqL1xuY29uc3QgR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfQUxMT1dfRVhFQ1VUQUJMRVMgPSAnR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfQUxMT1dfRVhFQ1VUQUJMRVMnO1xuLyoqXG4gKiBUaGUgbWF4aW11bSBjdXJyZW50bHkgc3VwcG9ydGVkIGV4ZWN1dGFibGUgdmVyc2lvbi5cbiAqL1xuY29uc3QgTUFYSU1VTV9FWEVDVVRBQkxFX1ZFUlNJT04gPSAxO1xuLyoqXG4gKiBQbHVnZ2FibGVBdXRoQ2xpZW50IGVuYWJsZXMgdGhlIGV4Y2hhbmdlIG9mIHdvcmtsb2FkIGlkZW50aXR5IHBvb2wgZXh0ZXJuYWwgY3JlZGVudGlhbHMgZm9yXG4gKiBHb29nbGUgYWNjZXNzIHRva2VucyBieSByZXRyaWV2aW5nIDNyZCBwYXJ0eSB0b2tlbnMgdGhyb3VnaCBhIHVzZXIgc3VwcGxpZWQgZXhlY3V0YWJsZS4gVGhlc2VcbiAqIHNjcmlwdHMvZXhlY3V0YWJsZXMgYXJlIGNvbXBsZXRlbHkgaW5kZXBlbmRlbnQgb2YgdGhlIEdvb2dsZSBDbG91ZCBBdXRoIGxpYnJhcmllcy4gVGhlc2VcbiAqIGNyZWRlbnRpYWxzIHBsdWcgaW50byBBREMgYW5kIHdpbGwgY2FsbCB0aGUgc3BlY2lmaWVkIGV4ZWN1dGFibGUgdG8gcmV0cmlldmUgdGhlIDNyZCBwYXJ0eSB0b2tlblxuICogdG8gYmUgZXhjaGFuZ2VkIGZvciBhIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXG4gKlxuICogPHA+VG8gdXNlIHRoZXNlIGNyZWRlbnRpYWxzLCB0aGUgR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfQUxMT1dfRVhFQ1VUQUJMRVMgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAqIG11c3QgYmUgc2V0IHRvICcxJy4gVGhpcyBpcyBmb3Igc2VjdXJpdHkgcmVhc29ucy5cbiAqXG4gKiA8cD5Cb3RoIE9JREMgYW5kIFNBTUwgYXJlIHN1cHBvcnRlZC4gVGhlIGV4ZWN1dGFibGUgbXVzdCBhZGhlcmUgdG8gYSBzcGVjaWZpYyByZXNwb25zZSBmb3JtYXRcbiAqIGRlZmluZWQgYmVsb3cuXG4gKlxuICogPHA+VGhlIGV4ZWN1dGFibGUgbXVzdCBwcmludCBvdXQgdGhlIDNyZCBwYXJ0eSB0b2tlbiB0byBTVERPVVQgaW4gSlNPTiBmb3JtYXQuIFdoZW4gYW5cbiAqIG91dHB1dF9maWxlIGlzIHNwZWNpZmllZCBpbiB0aGUgY3JlZGVudGlhbCBjb25maWd1cmF0aW9uLCB0aGUgZXhlY3V0YWJsZSBtdXN0IGFsc28gaGFuZGxlIHdyaXRpbmcgdGhlXG4gKiBKU09OIHJlc3BvbnNlIHRvIHRoaXMgZmlsZS5cbiAqXG4gKiA8cHJlPlxuICogT0lEQyByZXNwb25zZSBzYW1wbGU6XG4gKiB7XG4gKiAgIFwidmVyc2lvblwiOiAxLFxuICogICBcInN1Y2Nlc3NcIjogdHJ1ZSxcbiAqICAgXCJ0b2tlbl90eXBlXCI6IFwidXJuOmlldGY6cGFyYW1zOm9hdXRoOnRva2VuLXR5cGU6aWRfdG9rZW5cIixcbiAqICAgXCJpZF90b2tlblwiOiBcIkhFQURFUi5QQVlMT0FELlNJR05BVFVSRVwiLFxuICogICBcImV4cGlyYXRpb25fdGltZVwiOiAxNjIwNDMzMzQxXG4gKiB9XG4gKlxuICogU0FNTDIgcmVzcG9uc2Ugc2FtcGxlOlxuICoge1xuICogICBcInZlcnNpb25cIjogMSxcbiAqICAgXCJzdWNjZXNzXCI6IHRydWUsXG4gKiAgIFwidG9rZW5fdHlwZVwiOiBcInVybjppZXRmOnBhcmFtczpvYXV0aDp0b2tlbi10eXBlOnNhbWwyXCIsXG4gKiAgIFwic2FtbF9yZXNwb25zZVwiOiBcIi4uLlwiLFxuICogICBcImV4cGlyYXRpb25fdGltZVwiOiAxNjIwNDMzMzQxXG4gKiB9XG4gKlxuICogRXJyb3IgcmVzcG9uc2Ugc2FtcGxlOlxuICoge1xuICogICBcInZlcnNpb25cIjogMSxcbiAqICAgXCJzdWNjZXNzXCI6IGZhbHNlLFxuICogICBcImNvZGVcIjogXCI0MDFcIixcbiAqICAgXCJtZXNzYWdlXCI6IFwiRXJyb3IgbWVzc2FnZS5cIlxuICogfVxuICogPC9wcmU+XG4gKlxuICogPHA+VGhlIFwiZXhwaXJhdGlvbl90aW1lXCIgZmllbGQgaW4gdGhlIEpTT04gcmVzcG9uc2UgaXMgb25seSByZXF1aXJlZCBmb3Igc3VjY2Vzc2Z1bFxuICogcmVzcG9uc2VzIHdoZW4gYW4gb3V0cHV0IGZpbGUgd2FzIHNwZWNpZmllZCBpbiB0aGUgY3JlZGVudGlhbCBjb25maWd1cmF0aW9uXG4gKlxuICogPHA+VGhlIGF1dGggbGlicmFyaWVzIHdpbGwgcG9wdWxhdGUgY2VydGFpbiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdGhhdCB3aWxsIGJlIGFjY2Vzc2libGUgYnkgdGhlXG4gKiBleGVjdXRhYmxlLCBzdWNoIGFzOiBHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9BVURJRU5DRSwgR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfVE9LRU5fVFlQRSxcbiAqIEdPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX0lOVEVSQUNUSVZFLCBHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9JTVBFUlNPTkFURURfRU1BSUwsIGFuZFxuICogR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfT1VUUFVUX0ZJTEUuXG4gKlxuICogPHA+UGxlYXNlIHNlZSB0aGlzIHJlcG9zaXRvcmllcyBSRUFETUUgZm9yIGEgY29tcGxldGUgZXhlY3V0YWJsZSByZXF1ZXN0L3Jlc3BvbnNlIHNwZWNpZmljYXRpb24uXG4gKi9cbmNsYXNzIFBsdWdnYWJsZUF1dGhDbGllbnQgZXh0ZW5kcyBiYXNlZXh0ZXJuYWxjbGllbnRfMS5CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYSBQbHVnZ2FibGVBdXRoQ2xpZW50IGluc3RhbmNlIHVzaW5nIHRoZSBwcm92aWRlZCBKU09OXG4gICAgICogb2JqZWN0IGxvYWRlZCBmcm9tIGFuIGV4dGVybmFsIGFjY291bnQgY3JlZGVudGlhbHMgZmlsZS5cbiAgICAgKiBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIGNyZWRlbnRpYWwgaXMgbm90IGEgdmFsaWQgcGx1Z2dhYmxlIGF1dGggY3JlZGVudGlhbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZXh0ZXJuYWwgYWNjb3VudCBvcHRpb25zIG9iamVjdCB0eXBpY2FsbHkgbG9hZGVkIGZyb21cbiAgICAgKiAgIHRoZSBleHRlcm5hbCBhY2NvdW50IEpTT04gY3JlZGVudGlhbCBmaWxlLlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsT3B0aW9ucyBPcHRpb25hbCBhZGRpdGlvbmFsIGJlaGF2aW9yIGN1c3RvbWl6YXRpb25cbiAgICAgKiAgIG9wdGlvbnMuIFRoZXNlIGN1cnJlbnRseSBjdXN0b21pemUgZXhwaXJhdGlvbiB0aHJlc2hvbGQgdGltZSBhbmRcbiAgICAgKiAgIHdoZXRoZXIgdG8gcmV0cnkgb24gNDAxLzQwMyBBUEkgcmVxdWVzdCBlcnJvcnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpO1xuICAgICAgICBpZiAoIW9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UuZXhlY3V0YWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBQbHVnZ2FibGUgQXV0aCBcImNyZWRlbnRpYWxfc291cmNlXCIgcHJvdmlkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21tYW5kID0gb3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS5leGVjdXRhYmxlLmNvbW1hbmQ7XG4gICAgICAgIGlmICghdGhpcy5jb21tYW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIFBsdWdnYWJsZSBBdXRoIFwiY3JlZGVudGlhbF9zb3VyY2VcIiBwcm92aWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgcHJvdmlkZWQgdGltZW91dCBleGlzdHMgYW5kIGlmIGl0IGlzIHZhbGlkLlxuICAgICAgICBpZiAob3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS5leGVjdXRhYmxlLnRpbWVvdXRfbWlsbGlzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudGltZW91dE1pbGxpcyA9IERFRkFVTFRfRVhFQ1VUQUJMRV9USU1FT1VUX01JTExJUztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGltZW91dE1pbGxpcyA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UuZXhlY3V0YWJsZS50aW1lb3V0X21pbGxpcztcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVvdXRNaWxsaXMgPCBNSU5JTVVNX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVMgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRNaWxsaXMgPiBNQVhJTVVNX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRpbWVvdXQgbXVzdCBiZSBiZXR3ZWVuICR7TUlOSU1VTV9FWEVDVVRBQkxFX1RJTUVPVVRfTUlMTElTfSBhbmQgYCArXG4gICAgICAgICAgICAgICAgICAgIGAke01BWElNVU1fRVhFQ1VUQUJMRV9USU1FT1VUX01JTExJU30gbWlsbGlzZWNvbmRzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0RmlsZSA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UuZXhlY3V0YWJsZS5vdXRwdXRfZmlsZTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gbmV3IHBsdWdnYWJsZV9hdXRoX2hhbmRsZXJfMS5QbHVnZ2FibGVBdXRoSGFuZGxlcih7XG4gICAgICAgICAgICBjb21tYW5kOiB0aGlzLmNvbW1hbmQsXG4gICAgICAgICAgICB0aW1lb3V0TWlsbGlzOiB0aGlzLnRpbWVvdXRNaWxsaXMsXG4gICAgICAgICAgICBvdXRwdXRGaWxlOiB0aGlzLm91dHB1dEZpbGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhbiBleHRlcm5hbCBzdWJqZWN0IHRva2VuIGlzIG5lZWRlZCB0byBiZSBleGNoYW5nZWQgZm9yIGFcbiAgICAgKiBHQ1AgYWNjZXNzIHRva2VuIHZpYSBHQ1AgU1RTIGVuZHBvaW50LlxuICAgICAqIFRoaXMgdXNlcyB0aGUgYG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2VgIG9iamVjdCB0byBmaWd1cmUgb3V0IGhvd1xuICAgICAqIHRvIHJldHJpZXZlIHRoZSB0b2tlbiB1c2luZyB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gSW4gdGhpcyBjYXNlLFxuICAgICAqIHRoaXMgY2FsbHMgYSB1c2VyIHByb3ZpZGVkIGV4ZWN1dGFibGUgd2hpY2ggcmV0dXJucyB0aGUgc3ViamVjdCB0b2tlbi5cbiAgICAgKiBUaGUgbG9naWMgaXMgc3VtbWFyaXplZCBhczpcbiAgICAgKiAxLiBWYWxpZGF0ZWQgdGhhdCB0aGUgZXhlY3V0YWJsZSBpcyBhbGxvd2VkIHRvIHJ1bi4gVGhlXG4gICAgICogICAgR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfQUxMT1dfRVhFQ1VUQUJMRVMgZW52aXJvbm1lbnQgbXVzdCBiZSBzZXQgdG9cbiAgICAgKiAgICAxIGZvciBzZWN1cml0eSByZWFzb25zLlxuICAgICAqIDIuIElmIGFuIG91dHB1dCBmaWxlIGlzIHNwZWNpZmllZCBieSB0aGUgdXNlciwgY2hlY2sgdGhlIGZpbGUgbG9jYXRpb25cbiAgICAgKiAgICBmb3IgYSByZXNwb25zZS4gSWYgdGhlIGZpbGUgZXhpc3RzIGFuZCBjb250YWlucyBhIHZhbGlkIHJlc3BvbnNlLFxuICAgICAqICAgIHJldHVybiB0aGUgc3ViamVjdCB0b2tlbiBmcm9tIHRoZSBmaWxlLlxuICAgICAqIDMuIENhbGwgdGhlIHByb3ZpZGVkIGV4ZWN1dGFibGUgYW5kIHJldHVybiByZXNwb25zZS5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGV4dGVybmFsIHN1YmplY3QgdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgcmV0cmlldmVTdWJqZWN0VG9rZW4oKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBleGVjdXRhYmxlIGlzIGFsbG93ZWQgdG8gcnVuLlxuICAgICAgICBpZiAocHJvY2Vzcy5lbnZbR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfQUxMT1dfRVhFQ1VUQUJMRVNdICE9PSAnMScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGx1Z2dhYmxlIEF1dGggZXhlY3V0YWJsZXMgbmVlZCB0byBiZSBleHBsaWNpdGx5IGFsbG93ZWQgdG8gcnVuIGJ5ICcgK1xuICAgICAgICAgICAgICAgICdzZXR0aW5nIHRoZSBHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9BTExPV19FWEVDVVRBQkxFUyBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgICAgICAgICAnVmFyaWFibGUgdG8gMS4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXhlY3V0YWJsZVJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBUcnkgdG8gZ2V0IGNhY2hlZCBleGVjdXRhYmxlIHJlc3BvbnNlIGZyb20gb3V0cHV0IGZpbGUuXG4gICAgICAgIGlmICh0aGlzLm91dHB1dEZpbGUpIHtcbiAgICAgICAgICAgIGV4ZWN1dGFibGVSZXNwb25zZSA9IGF3YWl0IHRoaXMuaGFuZGxlci5yZXRyaWV2ZUNhY2hlZFJlc3BvbnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gcmVzcG9uc2UgZnJvbSBvdXRwdXQgZmlsZSwgY2FsbCB0aGUgZXhlY3V0YWJsZS5cbiAgICAgICAgaWYgKCFleGVjdXRhYmxlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIC8vIFNldCB1cCBlbnZpcm9ubWVudCBtYXAgd2l0aCByZXF1aXJlZCB2YWx1ZXMgZm9yIHRoZSBleGVjdXRhYmxlLlxuICAgICAgICAgICAgY29uc3QgZW52TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZW52TWFwLnNldCgnR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfQVVESUVOQ0UnLCB0aGlzLmF1ZGllbmNlKTtcbiAgICAgICAgICAgIGVudk1hcC5zZXQoJ0dPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX1RPS0VOX1RZUEUnLCB0aGlzLnN1YmplY3RUb2tlblR5cGUpO1xuICAgICAgICAgICAgLy8gQWx3YXlzIHNldCB0byAwIGJlY2F1c2UgaW50ZXJhY3RpdmUgbW9kZSBpcyBub3Qgc3VwcG9ydGVkLlxuICAgICAgICAgICAgZW52TWFwLnNldCgnR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfSU5URVJBQ1RJVkUnLCAnMCcpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsZSkge1xuICAgICAgICAgICAgICAgIGVudk1hcC5zZXQoJ0dPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX09VVFBVVF9GSUxFJywgdGhpcy5vdXRwdXRGaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VBY2NvdW50RW1haWwgPSB0aGlzLmdldFNlcnZpY2VBY2NvdW50RW1haWwoKTtcbiAgICAgICAgICAgIGlmIChzZXJ2aWNlQWNjb3VudEVtYWlsKSB7XG4gICAgICAgICAgICAgICAgZW52TWFwLnNldCgnR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfSU1QRVJTT05BVEVEX0VNQUlMJywgc2VydmljZUFjY291bnRFbWFpbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleGVjdXRhYmxlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmhhbmRsZXIucmV0cmlldmVSZXNwb25zZUZyb21FeGVjdXRhYmxlKGVudk1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4ZWN1dGFibGVSZXNwb25zZS52ZXJzaW9uID4gTUFYSU1VTV9FWEVDVVRBQkxFX1ZFUlNJT04pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmVyc2lvbiBvZiBleGVjdXRhYmxlIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLCBtYXhpbXVtIHN1cHBvcnRlZCB2ZXJzaW9uIGlzICR7TUFYSU1VTV9FWEVDVVRBQkxFX1ZFUlNJT059LmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHRoYXQgcmVzcG9uc2Ugd2FzIHN1Y2Nlc3NmdWwuXG4gICAgICAgIGlmICghZXhlY3V0YWJsZVJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGVjdXRhYmxlRXJyb3IoZXhlY3V0YWJsZVJlc3BvbnNlLmVycm9yTWVzc2FnZSwgZXhlY3V0YWJsZVJlc3BvbnNlLmVycm9yQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgdGhhdCByZXNwb25zZSBjb250YWlucyBleHBpcmF0aW9uIHRpbWUgaWYgb3V0cHV0IGZpbGUgd2FzIHNwZWNpZmllZC5cbiAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsZSkge1xuICAgICAgICAgICAgaWYgKCFleGVjdXRhYmxlUmVzcG9uc2UuZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhlY3V0YWJsZV9yZXNwb25zZV8xLkludmFsaWRFeHBpcmF0aW9uVGltZUZpZWxkRXJyb3IoJ1RoZSBleGVjdXRhYmxlIHJlc3BvbnNlIG11c3QgY29udGFpbiB0aGUgYGV4cGlyYXRpb25fdGltZWAgZmllbGQgZm9yIHN1Y2Nlc3NmdWwgcmVzcG9uc2VzIHdoZW4gYW4gb3V0cHV0X2ZpbGUgaGFzIGJlZW4gc3BlY2lmaWVkIGluIHRoZSBjb25maWd1cmF0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHRoYXQgcmVzcG9uc2UgaXMgbm90IGV4cGlyZWQuXG4gICAgICAgIGlmIChleGVjdXRhYmxlUmVzcG9uc2UuaXNFeHBpcmVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhlY3V0YWJsZSByZXNwb25zZSBpcyBleHBpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBzdWJqZWN0IHRva2VuIGZyb20gcmVzcG9uc2UuXG4gICAgICAgIHJldHVybiBleGVjdXRhYmxlUmVzcG9uc2Uuc3ViamVjdFRva2VuO1xuICAgIH1cbn1cbmV4cG9ydHMuUGx1Z2dhYmxlQXV0aENsaWVudCA9IFBsdWdnYWJsZUF1dGhDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnZ2FibGUtYXV0aC1jbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUGx1Z2dhYmxlQXV0aENsaWVudCIsIkV4ZWN1dGFibGVFcnJvciIsImJhc2VleHRlcm5hbGNsaWVudF8xIiwicmVxdWlyZSIsImV4ZWN1dGFibGVfcmVzcG9uc2VfMSIsInBsdWdnYWJsZV9hdXRoX2hhbmRsZXJfMSIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiY29kZSIsInNldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIiwiREVGQVVMVF9FWEVDVVRBQkxFX1RJTUVPVVRfTUlMTElTIiwiTUlOSU1VTV9FWEVDVVRBQkxFX1RJTUVPVVRfTUlMTElTIiwiTUFYSU1VTV9FWEVDVVRBQkxFX1RJTUVPVVRfTUlMTElTIiwiR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfQUxMT1dfRVhFQ1VUQUJMRVMiLCJNQVhJTVVNX0VYRUNVVEFCTEVfVkVSU0lPTiIsIkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQiLCJvcHRpb25zIiwiYWRkaXRpb25hbE9wdGlvbnMiLCJjcmVkZW50aWFsX3NvdXJjZSIsImV4ZWN1dGFibGUiLCJjb21tYW5kIiwidGltZW91dF9taWxsaXMiLCJ1bmRlZmluZWQiLCJ0aW1lb3V0TWlsbGlzIiwib3V0cHV0RmlsZSIsIm91dHB1dF9maWxlIiwiaGFuZGxlciIsIlBsdWdnYWJsZUF1dGhIYW5kbGVyIiwicmV0cmlldmVTdWJqZWN0VG9rZW4iLCJwcm9jZXNzIiwiZW52IiwiZXhlY3V0YWJsZVJlc3BvbnNlIiwicmV0cmlldmVDYWNoZWRSZXNwb25zZSIsImVudk1hcCIsIk1hcCIsInNldCIsImF1ZGllbmNlIiwic3ViamVjdFRva2VuVHlwZSIsInNlcnZpY2VBY2NvdW50RW1haWwiLCJnZXRTZXJ2aWNlQWNjb3VudEVtYWlsIiwicmV0cmlldmVSZXNwb25zZUZyb21FeGVjdXRhYmxlIiwidmVyc2lvbiIsInN1Y2Nlc3MiLCJlcnJvck1lc3NhZ2UiLCJlcnJvckNvZGUiLCJleHBpcmF0aW9uVGltZSIsIkludmFsaWRFeHBpcmF0aW9uVGltZUZpZWxkRXJyb3IiLCJpc0V4cGlyZWQiLCJzdWJqZWN0VG9rZW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PluggableAuthHandler = void 0;\nconst pluggable_auth_client_1 = __webpack_require__(/*! ./pluggable-auth-client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js\");\nconst executable_response_1 = __webpack_require__(/*! ./executable-response */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/executable-response.js\");\nconst childProcess = __webpack_require__(/*! child_process */ \"child_process\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\n/**\n * A handler used to retrieve 3rd party token responses from user defined\n * executables and cached file output for the PluggableAuthClient class.\n */ class PluggableAuthHandler {\n    /**\n     * Instantiates a PluggableAuthHandler instance using the provided\n     * PluggableAuthHandlerOptions object.\n     */ constructor(options){\n        if (!options.command) {\n            throw new Error(\"No command provided.\");\n        }\n        this.commandComponents = PluggableAuthHandler.parseCommand(options.command);\n        this.timeoutMillis = options.timeoutMillis;\n        if (!this.timeoutMillis) {\n            throw new Error(\"No timeoutMillis provided.\");\n        }\n        this.outputFile = options.outputFile;\n    }\n    /**\n     * Calls user provided executable to get a 3rd party subject token and\n     * returns the response.\n     * @param envMap a Map of additional Environment Variables required for\n     *   the executable.\n     * @return A promise that resolves with the executable response.\n     */ retrieveResponseFromExecutable(envMap) {\n        return new Promise((resolve, reject)=>{\n            // Spawn process to run executable using added environment variables.\n            const child = childProcess.spawn(this.commandComponents[0], this.commandComponents.slice(1), {\n                env: {\n                    ...process.env,\n                    ...Object.fromEntries(envMap)\n                }\n            });\n            let output = \"\";\n            // Append stdout to output as executable runs.\n            child.stdout.on(\"data\", (data)=>{\n                output += data;\n            });\n            // Append stderr as executable runs.\n            child.stderr.on(\"data\", (err)=>{\n                output += err;\n            });\n            // Set up a timeout to end the child process and throw an error.\n            const timeout = setTimeout(()=>{\n                // Kill child process and remove listeners so 'close' event doesn't get\n                // read after child process is killed.\n                child.removeAllListeners();\n                child.kill();\n                return reject(new Error(\"The executable failed to finish within the timeout specified.\"));\n            }, this.timeoutMillis);\n            child.on(\"close\", (code)=>{\n                // Cancel timeout if executable closes before timeout is reached.\n                clearTimeout(timeout);\n                if (code === 0) {\n                    // If the executable completed successfully, try to return the parsed response.\n                    try {\n                        const responseJson = JSON.parse(output);\n                        const response = new executable_response_1.ExecutableResponse(responseJson);\n                        return resolve(response);\n                    } catch (error) {\n                        if (error instanceof executable_response_1.ExecutableResponseError) {\n                            return reject(error);\n                        }\n                        return reject(new executable_response_1.ExecutableResponseError(`The executable returned an invalid response: ${output}`));\n                    }\n                } else {\n                    return reject(new pluggable_auth_client_1.ExecutableError(output, code.toString()));\n                }\n            });\n        });\n    }\n    /**\n     * Checks user provided output file for response from previous run of\n     * executable and return the response if it exists, is formatted correctly, and is not expired.\n     */ async retrieveCachedResponse() {\n        if (!this.outputFile || this.outputFile.length === 0) {\n            return undefined;\n        }\n        let filePath;\n        try {\n            filePath = await fs.promises.realpath(this.outputFile);\n        } catch (_a) {\n            // If file path cannot be resolved, return undefined.\n            return undefined;\n        }\n        if (!(await fs.promises.lstat(filePath)).isFile()) {\n            // If path does not lead to file, return undefined.\n            return undefined;\n        }\n        const responseString = await fs.promises.readFile(filePath, {\n            encoding: \"utf8\"\n        });\n        if (responseString === \"\") {\n            return undefined;\n        }\n        try {\n            const responseJson = JSON.parse(responseString);\n            const response = new executable_response_1.ExecutableResponse(responseJson);\n            // Check if response is successful and unexpired.\n            if (response.isValid()) {\n                return new executable_response_1.ExecutableResponse(responseJson);\n            }\n            return undefined;\n        } catch (error) {\n            if (error instanceof executable_response_1.ExecutableResponseError) {\n                throw error;\n            }\n            throw new executable_response_1.ExecutableResponseError(`The output file contained an invalid response: ${responseString}`);\n        }\n    }\n    /**\n     * Parses given command string into component array, splitting on spaces unless\n     * spaces are between quotation marks.\n     */ static parseCommand(command) {\n        // Split the command into components by splitting on spaces,\n        // unless spaces are contained in quotation marks.\n        const components = command.match(/(?:[^\\s\"]+|\"[^\"]*\")+/g);\n        if (!components) {\n            throw new Error(`Provided command: \"${command}\" could not be parsed.`);\n        }\n        // Remove quotation marks from the beginning and end of each component if they are present.\n        for(let i = 0; i < components.length; i++){\n            if (components[i][0] === '\"' && components[i].slice(-1) === '\"') {\n                components[i] = components[i].slice(1, -1);\n            }\n        }\n        return components;\n    }\n}\nexports.PluggableAuthHandler = PluggableAuthHandler; //# sourceMappingURL=pluggable-auth-handler.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9wbHVnZ2FibGUtYXV0aC1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNEJBQTRCLEdBQUcsS0FBSztBQUNwQyxNQUFNRywwQkFBMEJDLG1CQUFPQSxDQUFDLGlIQUF5QjtBQUNqRSxNQUFNQyx3QkFBd0JELG1CQUFPQSxDQUFDLDZHQUF1QjtBQUM3RCxNQUFNRSxlQUFlRixtQkFBT0EsQ0FBQyxvQ0FBZTtBQUM1QyxNQUFNRyxLQUFLSCxtQkFBT0EsQ0FBQyxjQUFJO0FBQ3ZCOzs7Q0FHQyxHQUNELE1BQU1GO0lBQ0Y7OztLQUdDLEdBQ0RNLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixJQUFJLENBQUNBLFFBQVFDLE9BQU8sRUFBRTtZQUNsQixNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUNDLGlCQUFpQixHQUFHVixxQkFBcUJXLFlBQVksQ0FBQ0osUUFBUUMsT0FBTztRQUMxRSxJQUFJLENBQUNJLGFBQWEsR0FBR0wsUUFBUUssYUFBYTtRQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDQSxhQUFhLEVBQUU7WUFDckIsTUFBTSxJQUFJSCxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDSSxVQUFVLEdBQUdOLFFBQVFNLFVBQVU7SUFDeEM7SUFDQTs7Ozs7O0tBTUMsR0FDREMsK0JBQStCQyxNQUFNLEVBQUU7UUFDbkMsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1lBQ3pCLHFF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Q0FBK0MsRUFBRVksZUFBZSxDQUFDO1FBQzlIO0lBQ0o7SUFDQTs7O0tBR0MsR0FDRCxPQUFPNUMsYUFBYUgsT0FBTyxFQUFFO1FBQ3pCLDREQUE0RDtRQUM1RCxrREFBa0Q7UUFDbEQsTUFBTW1ELGFBQWFuRCxRQUFRb0QsS0FBSyxDQUFDO1FBQ2pDLElBQUksQ0FBQ0QsWUFBWTtZQUNiLE1BQU0sSUFBSWxELE1BQU0sQ0FBQyxtQkFBbUIsRUFBRUQsUUFBUSxzQkFBc0IsQ0FBQztRQUN6RTtRQUNBLDJGQUEyRjtRQUMzRixJQUFLLElBQUlxRCxJQUFJLEdBQUdBLElBQUlGLFdBQVdaLE1BQU0sRUFBRWMsSUFBSztZQUN4QyxJQUFJRixVQUFVLENBQUNFLEVBQUUsQ0FBQyxFQUFFLEtBQUssT0FBT0YsVUFBVSxDQUFDRSxFQUFFLENBQUN4QyxLQUFLLENBQUMsQ0FBQyxPQUFPLEtBQUs7Z0JBQzdEc0MsVUFBVSxDQUFDRSxFQUFFLEdBQUdGLFVBQVUsQ0FBQ0UsRUFBRSxDQUFDeEMsS0FBSyxDQUFDLEdBQUcsQ0FBQztZQUM1QztRQUNKO1FBQ0EsT0FBT3NDO0lBQ1g7QUFDSjtBQUNBN0QsNEJBQTRCLEdBQUdFLHNCQUMvQixrREFBa0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9wbHVnZ2FibGUtYXV0aC1oYW5kbGVyLmpzPzBkNDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGx1Z2dhYmxlQXV0aEhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBwbHVnZ2FibGVfYXV0aF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL3BsdWdnYWJsZS1hdXRoLWNsaWVudFwiKTtcbmNvbnN0IGV4ZWN1dGFibGVfcmVzcG9uc2VfMSA9IHJlcXVpcmUoXCIuL2V4ZWN1dGFibGUtcmVzcG9uc2VcIik7XG5jb25zdCBjaGlsZFByb2Nlc3MgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuLyoqXG4gKiBBIGhhbmRsZXIgdXNlZCB0byByZXRyaWV2ZSAzcmQgcGFydHkgdG9rZW4gcmVzcG9uc2VzIGZyb20gdXNlciBkZWZpbmVkXG4gKiBleGVjdXRhYmxlcyBhbmQgY2FjaGVkIGZpbGUgb3V0cHV0IGZvciB0aGUgUGx1Z2dhYmxlQXV0aENsaWVudCBjbGFzcy5cbiAqL1xuY2xhc3MgUGx1Z2dhYmxlQXV0aEhhbmRsZXIge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhIFBsdWdnYWJsZUF1dGhIYW5kbGVyIGluc3RhbmNlIHVzaW5nIHRoZSBwcm92aWRlZFxuICAgICAqIFBsdWdnYWJsZUF1dGhIYW5kbGVyT3B0aW9ucyBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMuY29tbWFuZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb21tYW5kIHByb3ZpZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tbWFuZENvbXBvbmVudHMgPSBQbHVnZ2FibGVBdXRoSGFuZGxlci5wYXJzZUNvbW1hbmQob3B0aW9ucy5jb21tYW5kKTtcbiAgICAgICAgdGhpcy50aW1lb3V0TWlsbGlzID0gb3B0aW9ucy50aW1lb3V0TWlsbGlzO1xuICAgICAgICBpZiAoIXRoaXMudGltZW91dE1pbGxpcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0aW1lb3V0TWlsbGlzIHByb3ZpZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0RmlsZSA9IG9wdGlvbnMub3V0cHV0RmlsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdXNlciBwcm92aWRlZCBleGVjdXRhYmxlIHRvIGdldCBhIDNyZCBwYXJ0eSBzdWJqZWN0IHRva2VuIGFuZFxuICAgICAqIHJldHVybnMgdGhlIHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSBlbnZNYXAgYSBNYXAgb2YgYWRkaXRpb25hbCBFbnZpcm9ubWVudCBWYXJpYWJsZXMgcmVxdWlyZWQgZm9yXG4gICAgICogICB0aGUgZXhlY3V0YWJsZS5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGV4ZWN1dGFibGUgcmVzcG9uc2UuXG4gICAgICovXG4gICAgcmV0cmlldmVSZXNwb25zZUZyb21FeGVjdXRhYmxlKGVudk1hcCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gU3Bhd24gcHJvY2VzcyB0byBydW4gZXhlY3V0YWJsZSB1c2luZyBhZGRlZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkUHJvY2Vzcy5zcGF3bih0aGlzLmNvbW1hbmRDb21wb25lbnRzWzBdLCB0aGlzLmNvbW1hbmRDb21wb25lbnRzLnNsaWNlKDEpLCB7XG4gICAgICAgICAgICAgICAgZW52OiB7IC4uLnByb2Nlc3MuZW52LCAuLi5PYmplY3QuZnJvbUVudHJpZXMoZW52TWFwKSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gJyc7XG4gICAgICAgICAgICAvLyBBcHBlbmQgc3Rkb3V0IHRvIG91dHB1dCBhcyBleGVjdXRhYmxlIHJ1bnMuXG4gICAgICAgICAgICBjaGlsZC5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBkYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBBcHBlbmQgc3RkZXJyIGFzIGV4ZWN1dGFibGUgcnVucy5cbiAgICAgICAgICAgIGNoaWxkLnN0ZGVyci5vbignZGF0YScsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gZXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBTZXQgdXAgYSB0aW1lb3V0IHRvIGVuZCB0aGUgY2hpbGQgcHJvY2VzcyBhbmQgdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gS2lsbCBjaGlsZCBwcm9jZXNzIGFuZCByZW1vdmUgbGlzdGVuZXJzIHNvICdjbG9zZScgZXZlbnQgZG9lc24ndCBnZXRcbiAgICAgICAgICAgICAgICAvLyByZWFkIGFmdGVyIGNoaWxkIHByb2Nlc3MgaXMga2lsbGVkLlxuICAgICAgICAgICAgICAgIGNoaWxkLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIGNoaWxkLmtpbGwoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignVGhlIGV4ZWN1dGFibGUgZmFpbGVkIHRvIGZpbmlzaCB3aXRoaW4gdGhlIHRpbWVvdXQgc3BlY2lmaWVkLicpKTtcbiAgICAgICAgICAgIH0sIHRoaXMudGltZW91dE1pbGxpcyk7XG4gICAgICAgICAgICBjaGlsZC5vbignY2xvc2UnLCAoY29kZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIENhbmNlbCB0aW1lb3V0IGlmIGV4ZWN1dGFibGUgY2xvc2VzIGJlZm9yZSB0aW1lb3V0IGlzIHJlYWNoZWQuXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBleGVjdXRhYmxlIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHksIHRyeSB0byByZXR1cm4gdGhlIHBhcnNlZCByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlSnNvbiA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IGV4ZWN1dGFibGVfcmVzcG9uc2VfMS5FeGVjdXRhYmxlUmVzcG9uc2UocmVzcG9uc2VKc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGV4ZWN1dGFibGVfcmVzcG9uc2VfMS5FeGVjdXRhYmxlUmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhlY3V0YWJsZV9yZXNwb25zZV8xLkV4ZWN1dGFibGVSZXNwb25zZUVycm9yKGBUaGUgZXhlY3V0YWJsZSByZXR1cm5lZCBhbiBpbnZhbGlkIHJlc3BvbnNlOiAke291dHB1dH1gKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IHBsdWdnYWJsZV9hdXRoX2NsaWVudF8xLkV4ZWN1dGFibGVFcnJvcihvdXRwdXQsIGNvZGUudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHVzZXIgcHJvdmlkZWQgb3V0cHV0IGZpbGUgZm9yIHJlc3BvbnNlIGZyb20gcHJldmlvdXMgcnVuIG9mXG4gICAgICogZXhlY3V0YWJsZSBhbmQgcmV0dXJuIHRoZSByZXNwb25zZSBpZiBpdCBleGlzdHMsIGlzIGZvcm1hdHRlZCBjb3JyZWN0bHksIGFuZCBpcyBub3QgZXhwaXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyByZXRyaWV2ZUNhY2hlZFJlc3BvbnNlKCkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0RmlsZSB8fCB0aGlzLm91dHB1dEZpbGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWxlUGF0aDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbGVQYXRoID0gYXdhaXQgZnMucHJvbWlzZXMucmVhbHBhdGgodGhpcy5vdXRwdXRGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIC8vIElmIGZpbGUgcGF0aCBjYW5ub3QgYmUgcmVzb2x2ZWQsIHJldHVybiB1bmRlZmluZWQuXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGF3YWl0IGZzLnByb21pc2VzLmxzdGF0KGZpbGVQYXRoKSkuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgIC8vIElmIHBhdGggZG9lcyBub3QgbGVhZCB0byBmaWxlLCByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZVN0cmluZyA9IGF3YWl0IGZzLnByb21pc2VzLnJlYWRGaWxlKGZpbGVQYXRoLCB7XG4gICAgICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlU3RyaW5nID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VKc29uID0gSlNPTi5wYXJzZShyZXNwb25zZVN0cmluZyk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBleGVjdXRhYmxlX3Jlc3BvbnNlXzEuRXhlY3V0YWJsZVJlc3BvbnNlKHJlc3BvbnNlSnNvbik7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiByZXNwb25zZSBpcyBzdWNjZXNzZnVsIGFuZCB1bmV4cGlyZWQuXG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBleGVjdXRhYmxlX3Jlc3BvbnNlXzEuRXhlY3V0YWJsZVJlc3BvbnNlKHJlc3BvbnNlSnNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgZXhlY3V0YWJsZV9yZXNwb25zZV8xLkV4ZWN1dGFibGVSZXNwb25zZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhlY3V0YWJsZV9yZXNwb25zZV8xLkV4ZWN1dGFibGVSZXNwb25zZUVycm9yKGBUaGUgb3V0cHV0IGZpbGUgY29udGFpbmVkIGFuIGludmFsaWQgcmVzcG9uc2U6ICR7cmVzcG9uc2VTdHJpbmd9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGdpdmVuIGNvbW1hbmQgc3RyaW5nIGludG8gY29tcG9uZW50IGFycmF5LCBzcGxpdHRpbmcgb24gc3BhY2VzIHVubGVzc1xuICAgICAqIHNwYWNlcyBhcmUgYmV0d2VlbiBxdW90YXRpb24gbWFya3MuXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlQ29tbWFuZChjb21tYW5kKSB7XG4gICAgICAgIC8vIFNwbGl0IHRoZSBjb21tYW5kIGludG8gY29tcG9uZW50cyBieSBzcGxpdHRpbmcgb24gc3BhY2VzLFxuICAgICAgICAvLyB1bmxlc3Mgc3BhY2VzIGFyZSBjb250YWluZWQgaW4gcXVvdGF0aW9uIG1hcmtzLlxuICAgICAgICBjb25zdCBjb21wb25lbnRzID0gY29tbWFuZC5tYXRjaCgvKD86W15cXHNcIl0rfFwiW15cIl0qXCIpKy9nKTtcbiAgICAgICAgaWYgKCFjb21wb25lbnRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3ZpZGVkIGNvbW1hbmQ6IFwiJHtjb21tYW5kfVwiIGNvdWxkIG5vdCBiZSBwYXJzZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHF1b3RhdGlvbiBtYXJrcyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBlYWNoIGNvbXBvbmVudCBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzW2ldWzBdID09PSAnXCInICYmIGNvbXBvbmVudHNbaV0uc2xpY2UoLTEpID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50c1tpXSA9IGNvbXBvbmVudHNbaV0uc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbn1cbmV4cG9ydHMuUGx1Z2dhYmxlQXV0aEhhbmRsZXIgPSBQbHVnZ2FibGVBdXRoSGFuZGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdnYWJsZS1hdXRoLWhhbmRsZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUGx1Z2dhYmxlQXV0aEhhbmRsZXIiLCJwbHVnZ2FibGVfYXV0aF9jbGllbnRfMSIsInJlcXVpcmUiLCJleGVjdXRhYmxlX3Jlc3BvbnNlXzEiLCJjaGlsZFByb2Nlc3MiLCJmcyIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImNvbW1hbmQiLCJFcnJvciIsImNvbW1hbmRDb21wb25lbnRzIiwicGFyc2VDb21tYW5kIiwidGltZW91dE1pbGxpcyIsIm91dHB1dEZpbGUiLCJyZXRyaWV2ZVJlc3BvbnNlRnJvbUV4ZWN1dGFibGUiLCJlbnZNYXAiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNoaWxkIiwic3Bhd24iLCJzbGljZSIsImVudiIsInByb2Nlc3MiLCJmcm9tRW50cmllcyIsIm91dHB1dCIsInN0ZG91dCIsIm9uIiwiZGF0YSIsInN0ZGVyciIsImVyciIsInRpbWVvdXQiLCJzZXRUaW1lb3V0IiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwia2lsbCIsImNvZGUiLCJjbGVhclRpbWVvdXQiLCJyZXNwb25zZUpzb24iLCJKU09OIiwicGFyc2UiLCJyZXNwb25zZSIsIkV4ZWN1dGFibGVSZXNwb25zZSIsImVycm9yIiwiRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3IiLCJFeGVjdXRhYmxlRXJyb3IiLCJ0b1N0cmluZyIsInJldHJpZXZlQ2FjaGVkUmVzcG9uc2UiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJmaWxlUGF0aCIsInByb21pc2VzIiwicmVhbHBhdGgiLCJfYSIsImxzdGF0IiwiaXNGaWxlIiwicmVzcG9uc2VTdHJpbmciLCJyZWFkRmlsZSIsImVuY29kaW5nIiwiaXNWYWxpZCIsImNvbXBvbmVudHMiLCJtYXRjaCIsImkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/refreshclient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/refreshclient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2015 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.UserRefreshClient = exports.USER_REFRESH_ACCOUNT_TYPE = void 0;\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nexports.USER_REFRESH_ACCOUNT_TYPE = \"authorized_user\";\nclass UserRefreshClient extends oauth2client_1.OAuth2Client {\n    constructor(optionsOrClientId, clientSecret, refreshToken, eagerRefreshThresholdMillis, forceRefreshOnFailure){\n        const opts = optionsOrClientId && typeof optionsOrClientId === \"object\" ? optionsOrClientId : {\n            clientId: optionsOrClientId,\n            clientSecret,\n            refreshToken,\n            eagerRefreshThresholdMillis,\n            forceRefreshOnFailure\n        };\n        super({\n            clientId: opts.clientId,\n            clientSecret: opts.clientSecret,\n            eagerRefreshThresholdMillis: opts.eagerRefreshThresholdMillis,\n            forceRefreshOnFailure: opts.forceRefreshOnFailure\n        });\n        this._refreshToken = opts.refreshToken;\n        this.credentials.refresh_token = opts.refreshToken;\n    }\n    /**\n     * Refreshes the access token.\n     * @param refreshToken An ignored refreshToken..\n     * @param callback Optional callback.\n     */ async refreshTokenNoCache(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refreshToken) {\n        return super.refreshTokenNoCache(this._refreshToken);\n    }\n    /**\n     * Create a UserRefreshClient credentials instance using the given input\n     * options.\n     * @param json The input object.\n     */ fromJSON(json) {\n        if (!json) {\n            throw new Error(\"Must pass in a JSON object containing the user refresh token\");\n        }\n        if (json.type !== \"authorized_user\") {\n            throw new Error('The incoming JSON object does not have the \"authorized_user\" type');\n        }\n        if (!json.client_id) {\n            throw new Error(\"The incoming JSON object does not contain a client_id field\");\n        }\n        if (!json.client_secret) {\n            throw new Error(\"The incoming JSON object does not contain a client_secret field\");\n        }\n        if (!json.refresh_token) {\n            throw new Error(\"The incoming JSON object does not contain a refresh_token field\");\n        }\n        this._clientId = json.client_id;\n        this._clientSecret = json.client_secret;\n        this._refreshToken = json.refresh_token;\n        this.credentials.refresh_token = json.refresh_token;\n        this.quotaProjectId = json.quota_project_id;\n    }\n    fromStream(inputStream, callback) {\n        if (callback) {\n            this.fromStreamAsync(inputStream).then(()=>callback(), callback);\n        } else {\n            return this.fromStreamAsync(inputStream);\n        }\n    }\n    async fromStreamAsync(inputStream) {\n        return new Promise((resolve, reject)=>{\n            if (!inputStream) {\n                return reject(new Error(\"Must pass in a stream containing the user refresh token.\"));\n            }\n            let s = \"\";\n            inputStream.setEncoding(\"utf8\").on(\"error\", reject).on(\"data\", (chunk)=>s += chunk).on(\"end\", ()=>{\n                try {\n                    const data = JSON.parse(s);\n                    this.fromJSON(data);\n                    return resolve();\n                } catch (err) {\n                    return reject(err);\n                }\n            });\n        });\n    }\n}\nexports.UserRefreshClient = UserRefreshClient; //# sourceMappingURL=refreshclient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9yZWZyZXNoY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQseUJBQXlCLEdBQUdBLGlDQUFpQyxHQUFHLEtBQUs7QUFDckUsTUFBTUksaUJBQWlCQyxtQkFBT0EsQ0FBQywrRkFBZ0I7QUFDL0NMLGlDQUFpQyxHQUFHO0FBQ3BDLE1BQU1FLDBCQUEwQkUsZUFBZUUsWUFBWTtJQUN2REMsWUFBWUMsaUJBQWlCLEVBQUVDLFlBQVksRUFBRUMsWUFBWSxFQUFFQywyQkFBMkIsRUFBRUMscUJBQXFCLENBQUU7UUFDM0csTUFBTUMsT0FBT0wscUJBQXFCLE9BQU9BLHNCQUFzQixXQUN6REEsb0JBQ0E7WUFDRU0sVUFBVU47WUFDVkM7WUFDQUM7WUFDQUM7WUFDQUM7UUFDSjtRQUNKLEtBQUssQ0FBQztZQUNGRSxVQUFVRCxLQUFLQyxRQUFRO1lBQ3ZCTCxjQUFjSSxLQUFLSixZQUFZO1lBQy9CRSw2QkFBNkJFLEtBQUtGLDJCQUEyQjtZQUM3REMsdUJBQXVCQyxLQUFLRCxxQkFBcUI7UUFDckQ7UUFDQSxJQUFJLENBQUNHLGFBQWEsR0FBR0YsS0FBS0gsWUFBWTtRQUN0QyxJQUFJLENBQUNNLFdBQVcsQ0FBQ0MsYUFBYSxHQUFHSixLQUFLSCxZQUFZO0lBQ3REO0lBQ0E7Ozs7S0FJQyxHQUNELE1BQU1RLG9CQUNOLDZEQUE2RDtJQUM3RFIsWUFBWSxFQUFFO1FBQ1YsT0FBTyxLQUFLLENBQUNRLG9CQUFvQixJQUFJLENBQUNILGFBQWE7SUFDdkQ7SUFDQTs7OztLQUlDLEdBQ0RJLFNBQVNDLElBQUksRUFBRTtRQUNYLElBQUksQ0FBQ0EsTUFBTTtZQUNQLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLElBQUlELEtBQUtFLElBQUksS0FBSyxtQkFBbUI7WUFDakMsTUFBTSxJQUFJRCxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDRCxLQUFLRyxTQUFTLEVBQUU7WUFDakIsTUFBTSxJQUFJRixNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDRCxLQUFLSSxhQUFhLEVBQUU7WUFDckIsTUFBTSxJQUFJSCxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDRCxLQUFLSCxhQUFhLEVBQUU7WUFDckIsTUFBTSxJQUFJSSxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDSSxTQUFTLEdBQUdMLEtBQUtHLFNBQVM7UUFDL0IsSUFBSSxDQUFDRyxhQUFhLEdBQUdOLEtBQUtJLGFBQWE7UUFDdkMsSUFBSSxDQUFDVCxhQUFhLEdBQUdLLEtBQUtILGFBQWE7UUFDdkMsSUFBSSxDQUFDRCxXQUFXLENBQUNDLGFBQWEsR0FBR0csS0FBS0gsYUFBYTtRQUNuRCxJQUFJLENBQUNVLGNBQWMsR0FBR1AsS0FBS1EsZ0JBQWdCO0lBQy9DO0lBQ0FDLFdBQVdDLFdBQVcsRUFBRUMsUUFBUSxFQUFFO1FBQzlCLElBQUlBLFVBQVU7WUFDVixJQUFJLENBQUNDLGVBQWUsQ0FBQ0YsYUFBYUcsSUFBSSxDQUFDLElBQU1GLFlBQVlBO1FBQzdELE9BQ0s7WUFDRCxPQUFPLElBQUksQ0FBQ0MsZUFBZSxDQUFDRjtRQUNoQztJQUNKO0lBQ0EsTUFBTUUsZ0JBQWdCRixXQUFXLEVBQUU7UUFDL0IsT0FBTyxJQUFJSSxRQUFRLENBQUNDLFNBQVNDO1lBQ3pCLElBQUksQ0FBQ04sYUFBYTtnQkFDZCxPQUFPTSxPQUFPLElBQUlmLE1BQU07WUFDNUI7WUFDQSxJQUFJZ0IsSUFBSTtZQUNSUCxZQUNLUSxXQUFXLENBQUMsUUFDWkMsRUFBRSxDQUFDLFNBQVNILFFBQ1pHLEVBQUUsQ0FBQyxRQUFRQyxDQUFBQSxRQUFVSCxLQUFLRyxPQUMxQkQsRUFBRSxDQUFDLE9BQU87Z0JBQ1gsSUFBSTtvQkFDQSxNQUFNRSxPQUFPQyxLQUFLQyxLQUFLLENBQUNOO29CQUN4QixJQUFJLENBQUNsQixRQUFRLENBQUNzQjtvQkFDZCxPQUFPTjtnQkFDWCxFQUNBLE9BQU9TLEtBQUs7b0JBQ1IsT0FBT1IsT0FBT1E7Z0JBQ2xCO1lBQ0o7UUFDSjtJQUNKO0FBQ0o7QUFDQTVDLHlCQUF5QixHQUFHRSxtQkFDNUIseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvcmVmcmVzaGNsaWVudC5qcz9iZTYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTUgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVzZXJSZWZyZXNoQ2xpZW50ID0gZXhwb3J0cy5VU0VSX1JFRlJFU0hfQUNDT1VOVF9UWVBFID0gdm9pZCAwO1xuY29uc3Qgb2F1dGgyY2xpZW50XzEgPSByZXF1aXJlKFwiLi9vYXV0aDJjbGllbnRcIik7XG5leHBvcnRzLlVTRVJfUkVGUkVTSF9BQ0NPVU5UX1RZUEUgPSAnYXV0aG9yaXplZF91c2VyJztcbmNsYXNzIFVzZXJSZWZyZXNoQ2xpZW50IGV4dGVuZHMgb2F1dGgyY2xpZW50XzEuT0F1dGgyQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zT3JDbGllbnRJZCwgY2xpZW50U2VjcmV0LCByZWZyZXNoVG9rZW4sIGVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcywgZm9yY2VSZWZyZXNoT25GYWlsdXJlKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zT3JDbGllbnRJZCAmJiB0eXBlb2Ygb3B0aW9uc09yQ2xpZW50SWQgPT09ICdvYmplY3QnXG4gICAgICAgICAgICA/IG9wdGlvbnNPckNsaWVudElkXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBjbGllbnRJZDogb3B0aW9uc09yQ2xpZW50SWQsXG4gICAgICAgICAgICAgICAgY2xpZW50U2VjcmV0LFxuICAgICAgICAgICAgICAgIHJlZnJlc2hUb2tlbixcbiAgICAgICAgICAgICAgICBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMsXG4gICAgICAgICAgICAgICAgZm9yY2VSZWZyZXNoT25GYWlsdXJlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgY2xpZW50SWQ6IG9wdHMuY2xpZW50SWQsXG4gICAgICAgICAgICBjbGllbnRTZWNyZXQ6IG9wdHMuY2xpZW50U2VjcmV0LFxuICAgICAgICAgICAgZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzOiBvcHRzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyxcbiAgICAgICAgICAgIGZvcmNlUmVmcmVzaE9uRmFpbHVyZTogb3B0cy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9yZWZyZXNoVG9rZW4gPSBvcHRzLnJlZnJlc2hUb2tlbjtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscy5yZWZyZXNoX3Rva2VuID0gb3B0cy5yZWZyZXNoVG9rZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZnJlc2hlcyB0aGUgYWNjZXNzIHRva2VuLlxuICAgICAqIEBwYXJhbSByZWZyZXNoVG9rZW4gQW4gaWdub3JlZCByZWZyZXNoVG9rZW4uLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoVG9rZW5Ob0NhY2hlKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICByZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJlZnJlc2hUb2tlbk5vQ2FjaGUodGhpcy5fcmVmcmVzaFRva2VuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgVXNlclJlZnJlc2hDbGllbnQgY3JlZGVudGlhbHMgaW5zdGFuY2UgdXNpbmcgdGhlIGdpdmVuIGlucHV0XG4gICAgICogb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ganNvbiBUaGUgaW5wdXQgb2JqZWN0LlxuICAgICAqL1xuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcGFzcyBpbiBhIEpTT04gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHVzZXIgcmVmcmVzaCB0b2tlbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc29uLnR5cGUgIT09ICdhdXRob3JpemVkX3VzZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBoYXZlIHRoZSBcImF1dGhvcml6ZWRfdXNlclwiIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWpzb24uY2xpZW50X2lkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgY2xpZW50X2lkIGZpZWxkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc29uLmNsaWVudF9zZWNyZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluY29taW5nIEpTT04gb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gYSBjbGllbnRfc2VjcmV0IGZpZWxkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc29uLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluY29taW5nIEpTT04gb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gYSByZWZyZXNoX3Rva2VuIGZpZWxkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xpZW50SWQgPSBqc29uLmNsaWVudF9pZDtcbiAgICAgICAgdGhpcy5fY2xpZW50U2VjcmV0ID0ganNvbi5jbGllbnRfc2VjcmV0O1xuICAgICAgICB0aGlzLl9yZWZyZXNoVG9rZW4gPSBqc29uLnJlZnJlc2hfdG9rZW47XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMucmVmcmVzaF90b2tlbiA9IGpzb24ucmVmcmVzaF90b2tlbjtcbiAgICAgICAgdGhpcy5xdW90YVByb2plY3RJZCA9IGpzb24ucXVvdGFfcHJvamVjdF9pZDtcbiAgICB9XG4gICAgZnJvbVN0cmVhbShpbnB1dFN0cmVhbSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSkudGhlbigoKSA9PiBjYWxsYmFjaygpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tU3RyZWFtQXN5bmMoaW5wdXRTdHJlYW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpbnB1dFN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdNdXN0IHBhc3MgaW4gYSBzdHJlYW0gY29udGFpbmluZyB0aGUgdXNlciByZWZyZXNoIHRva2VuLicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzID0gJyc7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbVxuICAgICAgICAgICAgICAgIC5zZXRFbmNvZGluZygndXRmOCcpXG4gICAgICAgICAgICAgICAgLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICAgICAgICAgICAgICAub24oJ2RhdGEnLCBjaHVuayA9PiAocyArPSBjaHVuaykpXG4gICAgICAgICAgICAgICAgLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2Uocyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvbUpTT04oZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlVzZXJSZWZyZXNoQ2xpZW50ID0gVXNlclJlZnJlc2hDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZyZXNoY2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlVzZXJSZWZyZXNoQ2xpZW50IiwiVVNFUl9SRUZSRVNIX0FDQ09VTlRfVFlQRSIsIm9hdXRoMmNsaWVudF8xIiwicmVxdWlyZSIsIk9BdXRoMkNsaWVudCIsImNvbnN0cnVjdG9yIiwib3B0aW9uc09yQ2xpZW50SWQiLCJjbGllbnRTZWNyZXQiLCJyZWZyZXNoVG9rZW4iLCJlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMiLCJmb3JjZVJlZnJlc2hPbkZhaWx1cmUiLCJvcHRzIiwiY2xpZW50SWQiLCJfcmVmcmVzaFRva2VuIiwiY3JlZGVudGlhbHMiLCJyZWZyZXNoX3Rva2VuIiwicmVmcmVzaFRva2VuTm9DYWNoZSIsImZyb21KU09OIiwianNvbiIsIkVycm9yIiwidHlwZSIsImNsaWVudF9pZCIsImNsaWVudF9zZWNyZXQiLCJfY2xpZW50SWQiLCJfY2xpZW50U2VjcmV0IiwicXVvdGFQcm9qZWN0SWQiLCJxdW90YV9wcm9qZWN0X2lkIiwiZnJvbVN0cmVhbSIsImlucHV0U3RyZWFtIiwiY2FsbGJhY2siLCJmcm9tU3RyZWFtQXN5bmMiLCJ0aGVuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzIiwic2V0RW5jb2RpbmciLCJvbiIsImNodW5rIiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsImVyciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/refreshclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/stscredentials.js":
/*!***************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/stscredentials.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.StsCredentials = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst transporters_1 = __webpack_require__(/*! ../transporters */ \"(rsc)/./node_modules/google-auth-library/build/src/transporters.js\");\nconst oauth2common_1 = __webpack_require__(/*! ./oauth2common */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2common.js\");\n/**\n * Implements the OAuth 2.0 token exchange based on\n * https://tools.ietf.org/html/rfc8693\n */ class StsCredentials extends oauth2common_1.OAuthClientAuthHandler {\n    /**\n     * Initializes an STS credentials instance.\n     * @param tokenExchangeEndpoint The token exchange endpoint.\n     * @param clientAuthentication The client authentication credentials if\n     *   available.\n     */ constructor(tokenExchangeEndpoint, clientAuthentication){\n        super(clientAuthentication);\n        this.tokenExchangeEndpoint = tokenExchangeEndpoint;\n        this.transporter = new transporters_1.DefaultTransporter();\n    }\n    /**\n     * Exchanges the provided token for another type of token based on the\n     * rfc8693 spec.\n     * @param stsCredentialsOptions The token exchange options used to populate\n     *   the token exchange request.\n     * @param additionalHeaders Optional additional headers to pass along the\n     *   request.\n     * @param options Optional additional GCP-specific non-spec defined options\n     *   to send with the request.\n     *   Example: `&options=${encodeUriComponent(JSON.stringified(options))}`\n     * @return A promise that resolves with the token exchange response containing\n     *   the requested token and its expiration time.\n     */ async exchangeToken(stsCredentialsOptions, additionalHeaders, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    options) {\n        var _a, _b, _c;\n        const values = {\n            grant_type: stsCredentialsOptions.grantType,\n            resource: stsCredentialsOptions.resource,\n            audience: stsCredentialsOptions.audience,\n            scope: (_a = stsCredentialsOptions.scope) === null || _a === void 0 ? void 0 : _a.join(\" \"),\n            requested_token_type: stsCredentialsOptions.requestedTokenType,\n            subject_token: stsCredentialsOptions.subjectToken,\n            subject_token_type: stsCredentialsOptions.subjectTokenType,\n            actor_token: (_b = stsCredentialsOptions.actingParty) === null || _b === void 0 ? void 0 : _b.actorToken,\n            actor_token_type: (_c = stsCredentialsOptions.actingParty) === null || _c === void 0 ? void 0 : _c.actorTokenType,\n            // Non-standard GCP-specific options.\n            options: options && JSON.stringify(options)\n        };\n        // Remove undefined fields.\n        Object.keys(values).forEach((key)=>{\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (typeof values[key] === \"undefined\") {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                delete values[key];\n            }\n        });\n        const headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n        };\n        // Inject additional STS headers if available.\n        Object.assign(headers, additionalHeaders || {});\n        const opts = {\n            url: this.tokenExchangeEndpoint,\n            method: \"POST\",\n            headers,\n            data: querystring.stringify(values),\n            responseType: \"json\"\n        };\n        // Apply OAuth client authentication.\n        this.applyClientAuthenticationOptions(opts);\n        try {\n            const response = await this.transporter.request(opts);\n            // Successful response.\n            const stsSuccessfulResponse = response.data;\n            stsSuccessfulResponse.res = response;\n            return stsSuccessfulResponse;\n        } catch (error) {\n            // Translate error to OAuthError.\n            if (error instanceof gaxios_1.GaxiosError && error.response) {\n                throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(error.response.data, // Preserve other fields from the original error.\n                error);\n            }\n            // Request could fail before the server responds.\n            throw error;\n        }\n    }\n}\nexports.StsCredentials = StsCredentials; //# sourceMappingURL=stscredentials.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9zdHNjcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHNCQUFzQixHQUFHLEtBQUs7QUFDOUIsTUFBTUcsV0FBV0MsbUJBQU9BLENBQUMsOERBQVE7QUFDakMsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsZ0NBQWE7QUFDekMsTUFBTUUsaUJBQWlCRixtQkFBT0EsQ0FBQywyRkFBaUI7QUFDaEQsTUFBTUcsaUJBQWlCSCxtQkFBT0EsQ0FBQywrRkFBZ0I7QUFDL0M7OztDQUdDLEdBQ0QsTUFBTUYsdUJBQXVCSyxlQUFlQyxzQkFBc0I7SUFDOUQ7Ozs7O0tBS0MsR0FDREMsWUFBWUMscUJBQXFCLEVBQUVDLG9CQUFvQixDQUFFO1FBQ3JELEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNELHFCQUFxQixHQUFHQTtRQUM3QixJQUFJLENBQUNFLFdBQVcsR0FBRyxJQUFJTixlQUFlTyxrQkFBa0I7SUFDNUQ7SUFDQTs7Ozs7Ozs7Ozs7O0tBWUMsR0FDRCxNQUFNQyxjQUFjQyxxQkFBcUIsRUFBRUMsaUJBQWlCLEVBQzVELDhEQUE4RDtJQUM5REMsT0FBTyxFQUFFO1FBQ0wsSUFBSUMsSUFBSUMsSUFBSUM7UUFDWixNQUFNQyxTQUFTO1lBQ1hDLFlBQVlQLHNCQUFzQlEsU0FBUztZQUMzQ0MsVUFBVVQsc0JBQXNCUyxRQUFRO1lBQ3hDQyxVQUFVVixzQkFBc0JVLFFBQVE7WUFDeENDLE9BQU8sQ0FBQ1IsS0FBS0gsc0JBQXNCVyxLQUFLLE1BQU0sUUFBUVIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHUyxJQUFJLENBQUM7WUFDdkZDLHNCQUFzQmIsc0JBQXNCYyxrQkFBa0I7WUFDOURDLGVBQWVmLHNCQUFzQmdCLFlBQVk7WUFDakRDLG9CQUFvQmpCLHNCQUFzQmtCLGdCQUFnQjtZQUMxREMsYUFBYSxDQUFDZixLQUFLSixzQkFBc0JvQixXQUFXLE1BQU0sUUFBUWhCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2lCLFVBQVU7WUFDeEdDLGtCQUFrQixDQUFDakIsS0FBS0wsc0JBQXNCb0IsV0FBVyxNQUFNLFFBQVFmLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tCLGNBQWM7WUFDakgscUNBQXFDO1lBQ3JDckIsU0FBU0EsV0FBV3NCLEtBQUtDLFNBQVMsQ0FBQ3ZCO1FBQ3ZDO1FBQ0EsMkJBQTJCO1FBQzNCbkIsT0FBTzJDLElBQUksQ0FBQ3BCLFFBQVFxQixPQUFPLENBQUNDLENBQUFBO1lBQ3hCLDhEQUE4RDtZQUM5RCxJQUFJLE9BQU90QixNQUFNLENBQUNzQixJQUFJLEtBQUssYUFBYTtnQkFDcEMsOERBQThEO2dCQUM5RCxPQUFPdEIsTUFBTSxDQUFDc0IsSUFBSTtZQUN0QjtRQUNKO1FBQ0EsTUFBTUMsVUFBVTtZQUNaLGdCQUFnQjtRQUNwQjtRQUNBLDhDQUE4QztRQUM5QzlDLE9BQU8rQyxNQUFNLENBQUNELFNBQVM1QixxQkFBcUIsQ0FBQztRQUM3QyxNQUFNOEIsT0FBTztZQUNUQyxLQUFLLElBQUksQ0FBQ3JDLHFCQUFxQjtZQUMvQnNDLFFBQVE7WUFDUko7WUFDQUssTUFBTTVDLFlBQVltQyxTQUFTLENBQUNuQjtZQUM1QjZCLGNBQWM7UUFDbEI7UUFDQSxxQ0FBcUM7UUFDckMsSUFBSSxDQUFDQyxnQ0FBZ0MsQ0FBQ0w7UUFDdEMsSUFBSTtZQUNBLE1BQU1NLFdBQVcsTUFBTSxJQUFJLENBQUN4QyxXQUFXLENBQUN5QyxPQUFPLENBQUNQO1lBQ2hELHVCQUF1QjtZQUN2QixNQUFNUSx3QkFBd0JGLFNBQVNILElBQUk7WUFDM0NLLHNCQUFzQkMsR0FBRyxHQUFHSDtZQUM1QixPQUFPRTtRQUNYLEVBQ0EsT0FBT0UsT0FBTztZQUNWLGlDQUFpQztZQUNqQyxJQUFJQSxpQkFBaUJyRCxTQUFTc0QsV0FBVyxJQUFJRCxNQUFNSixRQUFRLEVBQUU7Z0JBQ3pELE1BQU0sQ0FBQyxHQUFHN0MsZUFBZW1ELDhCQUE4QixFQUFFRixNQUFNSixRQUFRLENBQUNILElBQUksRUFDNUUsaURBQWlEO2dCQUNqRE87WUFDSjtZQUNBLGlEQUFpRDtZQUNqRCxNQUFNQTtRQUNWO0lBQ0o7QUFDSjtBQUNBeEQsc0JBQXNCLEdBQUdFLGdCQUN6QiwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9zdHNjcmVkZW50aWFscy5qcz9iN2U0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0c0NyZWRlbnRpYWxzID0gdm9pZCAwO1xuY29uc3QgZ2F4aW9zXzEgPSByZXF1aXJlKFwiZ2F4aW9zXCIpO1xuY29uc3QgcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwicXVlcnlzdHJpbmdcIik7XG5jb25zdCB0cmFuc3BvcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc3BvcnRlcnNcIik7XG5jb25zdCBvYXV0aDJjb21tb25fMSA9IHJlcXVpcmUoXCIuL29hdXRoMmNvbW1vblwiKTtcbi8qKlxuICogSW1wbGVtZW50cyB0aGUgT0F1dGggMi4wIHRva2VuIGV4Y2hhbmdlIGJhc2VkIG9uXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjODY5M1xuICovXG5jbGFzcyBTdHNDcmVkZW50aWFscyBleHRlbmRzIG9hdXRoMmNvbW1vbl8xLk9BdXRoQ2xpZW50QXV0aEhhbmRsZXIge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIFNUUyBjcmVkZW50aWFscyBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gdG9rZW5FeGNoYW5nZUVuZHBvaW50IFRoZSB0b2tlbiBleGNoYW5nZSBlbmRwb2ludC5cbiAgICAgKiBAcGFyYW0gY2xpZW50QXV0aGVudGljYXRpb24gVGhlIGNsaWVudCBhdXRoZW50aWNhdGlvbiBjcmVkZW50aWFscyBpZlxuICAgICAqICAgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRva2VuRXhjaGFuZ2VFbmRwb2ludCwgY2xpZW50QXV0aGVudGljYXRpb24pIHtcbiAgICAgICAgc3VwZXIoY2xpZW50QXV0aGVudGljYXRpb24pO1xuICAgICAgICB0aGlzLnRva2VuRXhjaGFuZ2VFbmRwb2ludCA9IHRva2VuRXhjaGFuZ2VFbmRwb2ludDtcbiAgICAgICAgdGhpcy50cmFuc3BvcnRlciA9IG5ldyB0cmFuc3BvcnRlcnNfMS5EZWZhdWx0VHJhbnNwb3J0ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhjaGFuZ2VzIHRoZSBwcm92aWRlZCB0b2tlbiBmb3IgYW5vdGhlciB0eXBlIG9mIHRva2VuIGJhc2VkIG9uIHRoZVxuICAgICAqIHJmYzg2OTMgc3BlYy5cbiAgICAgKiBAcGFyYW0gc3RzQ3JlZGVudGlhbHNPcHRpb25zIFRoZSB0b2tlbiBleGNoYW5nZSBvcHRpb25zIHVzZWQgdG8gcG9wdWxhdGVcbiAgICAgKiAgIHRoZSB0b2tlbiBleGNoYW5nZSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsSGVhZGVycyBPcHRpb25hbCBhZGRpdGlvbmFsIGhlYWRlcnMgdG8gcGFzcyBhbG9uZyB0aGVcbiAgICAgKiAgIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgYWRkaXRpb25hbCBHQ1Atc3BlY2lmaWMgbm9uLXNwZWMgZGVmaW5lZCBvcHRpb25zXG4gICAgICogICB0byBzZW5kIHdpdGggdGhlIHJlcXVlc3QuXG4gICAgICogICBFeGFtcGxlOiBgJm9wdGlvbnM9JHtlbmNvZGVVcmlDb21wb25lbnQoSlNPTi5zdHJpbmdpZmllZChvcHRpb25zKSl9YFxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgdG9rZW4gZXhjaGFuZ2UgcmVzcG9uc2UgY29udGFpbmluZ1xuICAgICAqICAgdGhlIHJlcXVlc3RlZCB0b2tlbiBhbmQgaXRzIGV4cGlyYXRpb24gdGltZS5cbiAgICAgKi9cbiAgICBhc3luYyBleGNoYW5nZVRva2VuKHN0c0NyZWRlbnRpYWxzT3B0aW9ucywgYWRkaXRpb25hbEhlYWRlcnMsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgdmFsdWVzID0ge1xuICAgICAgICAgICAgZ3JhbnRfdHlwZTogc3RzQ3JlZGVudGlhbHNPcHRpb25zLmdyYW50VHlwZSxcbiAgICAgICAgICAgIHJlc291cmNlOiBzdHNDcmVkZW50aWFsc09wdGlvbnMucmVzb3VyY2UsXG4gICAgICAgICAgICBhdWRpZW5jZTogc3RzQ3JlZGVudGlhbHNPcHRpb25zLmF1ZGllbmNlLFxuICAgICAgICAgICAgc2NvcGU6IChfYSA9IHN0c0NyZWRlbnRpYWxzT3B0aW9ucy5zY29wZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIHJlcXVlc3RlZF90b2tlbl90eXBlOiBzdHNDcmVkZW50aWFsc09wdGlvbnMucmVxdWVzdGVkVG9rZW5UeXBlLFxuICAgICAgICAgICAgc3ViamVjdF90b2tlbjogc3RzQ3JlZGVudGlhbHNPcHRpb25zLnN1YmplY3RUb2tlbixcbiAgICAgICAgICAgIHN1YmplY3RfdG9rZW5fdHlwZTogc3RzQ3JlZGVudGlhbHNPcHRpb25zLnN1YmplY3RUb2tlblR5cGUsXG4gICAgICAgICAgICBhY3Rvcl90b2tlbjogKF9iID0gc3RzQ3JlZGVudGlhbHNPcHRpb25zLmFjdGluZ1BhcnR5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWN0b3JUb2tlbixcbiAgICAgICAgICAgIGFjdG9yX3Rva2VuX3R5cGU6IChfYyA9IHN0c0NyZWRlbnRpYWxzT3B0aW9ucy5hY3RpbmdQYXJ0eSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFjdG9yVG9rZW5UeXBlLFxuICAgICAgICAgICAgLy8gTm9uLXN0YW5kYXJkIEdDUC1zcGVjaWZpYyBvcHRpb25zLlxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyAmJiBKU09OLnN0cmluZ2lmeShvcHRpb25zKSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVtb3ZlIHVuZGVmaW5lZCBmaWVsZHMuXG4gICAgICAgIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVzW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICB9O1xuICAgICAgICAvLyBJbmplY3QgYWRkaXRpb25hbCBTVFMgaGVhZGVycyBpZiBhdmFpbGFibGUuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oaGVhZGVycywgYWRkaXRpb25hbEhlYWRlcnMgfHwge30pO1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgdXJsOiB0aGlzLnRva2VuRXhjaGFuZ2VFbmRwb2ludCxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGRhdGE6IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh2YWx1ZXMpLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIC8vIEFwcGx5IE9BdXRoIGNsaWVudCBhdXRoZW50aWNhdGlvbi5cbiAgICAgICAgdGhpcy5hcHBseUNsaWVudEF1dGhlbnRpY2F0aW9uT3B0aW9ucyhvcHRzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICAgICAgLy8gU3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAgICAgICAgICAgIGNvbnN0IHN0c1N1Y2Nlc3NmdWxSZXNwb25zZSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgICBzdHNTdWNjZXNzZnVsUmVzcG9uc2UucmVzID0gcmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm4gc3RzU3VjY2Vzc2Z1bFJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gVHJhbnNsYXRlIGVycm9yIHRvIE9BdXRoRXJyb3IuXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBnYXhpb3NfMS5HYXhpb3NFcnJvciAmJiBlcnJvci5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCBvYXV0aDJjb21tb25fMS5nZXRFcnJvckZyb21PQXV0aEVycm9yUmVzcG9uc2UpKGVycm9yLnJlc3BvbnNlLmRhdGEsIFxuICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIG90aGVyIGZpZWxkcyBmcm9tIHRoZSBvcmlnaW5hbCBlcnJvci5cbiAgICAgICAgICAgICAgICBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXF1ZXN0IGNvdWxkIGZhaWwgYmVmb3JlIHRoZSBzZXJ2ZXIgcmVzcG9uZHMuXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU3RzQ3JlZGVudGlhbHMgPSBTdHNDcmVkZW50aWFscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0c2NyZWRlbnRpYWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlN0c0NyZWRlbnRpYWxzIiwiZ2F4aW9zXzEiLCJyZXF1aXJlIiwicXVlcnlzdHJpbmciLCJ0cmFuc3BvcnRlcnNfMSIsIm9hdXRoMmNvbW1vbl8xIiwiT0F1dGhDbGllbnRBdXRoSGFuZGxlciIsImNvbnN0cnVjdG9yIiwidG9rZW5FeGNoYW5nZUVuZHBvaW50IiwiY2xpZW50QXV0aGVudGljYXRpb24iLCJ0cmFuc3BvcnRlciIsIkRlZmF1bHRUcmFuc3BvcnRlciIsImV4Y2hhbmdlVG9rZW4iLCJzdHNDcmVkZW50aWFsc09wdGlvbnMiLCJhZGRpdGlvbmFsSGVhZGVycyIsIm9wdGlvbnMiLCJfYSIsIl9iIiwiX2MiLCJ2YWx1ZXMiLCJncmFudF90eXBlIiwiZ3JhbnRUeXBlIiwicmVzb3VyY2UiLCJhdWRpZW5jZSIsInNjb3BlIiwiam9pbiIsInJlcXVlc3RlZF90b2tlbl90eXBlIiwicmVxdWVzdGVkVG9rZW5UeXBlIiwic3ViamVjdF90b2tlbiIsInN1YmplY3RUb2tlbiIsInN1YmplY3RfdG9rZW5fdHlwZSIsInN1YmplY3RUb2tlblR5cGUiLCJhY3Rvcl90b2tlbiIsImFjdGluZ1BhcnR5IiwiYWN0b3JUb2tlbiIsImFjdG9yX3Rva2VuX3R5cGUiLCJhY3RvclRva2VuVHlwZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImhlYWRlcnMiLCJhc3NpZ24iLCJvcHRzIiwidXJsIiwibWV0aG9kIiwiZGF0YSIsInJlc3BvbnNlVHlwZSIsImFwcGx5Q2xpZW50QXV0aGVudGljYXRpb25PcHRpb25zIiwicmVzcG9uc2UiLCJyZXF1ZXN0Iiwic3RzU3VjY2Vzc2Z1bFJlc3BvbnNlIiwicmVzIiwiZXJyb3IiLCJHYXhpb3NFcnJvciIsImdldEVycm9yRnJvbU9BdXRoRXJyb3JSZXNwb25zZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/stscredentials.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/crypto/browser/crypto.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/crypto/browser/crypto.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* global window */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BrowserCrypto = void 0;\n// This file implements crypto functions we need using in-browser\n// SubtleCrypto interface `window.crypto.subtle`.\nconst base64js = __webpack_require__(/*! base64-js */ \"(rsc)/./node_modules/base64-js/index.js\");\n// Not all browsers support `TextEncoder`. The following `require` will\n// provide a fast UTF8-only replacement for those browsers that don't support\n// text encoding natively.\n// eslint-disable-next-line node/no-unsupported-features/node-builtins\nif (typeof process === \"undefined\" && typeof TextEncoder === \"undefined\") {\n    __webpack_require__(/*! fast-text-encoding */ \"(rsc)/./node_modules/fast-text-encoding/text.min.js\");\n}\nconst crypto_1 = __webpack_require__(/*! ../crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js\");\nclass BrowserCrypto {\n    constructor(){\n        if (true) {\n            throw new Error(\"SubtleCrypto not found. Make sure it's an https:// website.\");\n        }\n    }\n    async sha256DigestBase64(str) {\n        // SubtleCrypto digest() method is async, so we must make\n        // this method async as well.\n        // To calculate SHA256 digest using SubtleCrypto, we first\n        // need to convert an input string to an ArrayBuffer:\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const inputBuffer = new TextEncoder().encode(str);\n        // Result is ArrayBuffer as well.\n        const outputBuffer = await window.crypto.subtle.digest(\"SHA-256\", inputBuffer);\n        return base64js.fromByteArray(new Uint8Array(outputBuffer));\n    }\n    randomBytesBase64(count) {\n        const array = new Uint8Array(count);\n        window.crypto.getRandomValues(array);\n        return base64js.fromByteArray(array);\n    }\n    static padBase64(base64) {\n        // base64js requires padding, so let's add some '='\n        while(base64.length % 4 !== 0){\n            base64 += \"=\";\n        }\n        return base64;\n    }\n    async verify(pubkey, data, signature) {\n        const algo = {\n            name: \"RSASSA-PKCS1-v1_5\",\n            hash: {\n                name: \"SHA-256\"\n            }\n        };\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const dataArray = new TextEncoder().encode(data);\n        const signatureArray = base64js.toByteArray(BrowserCrypto.padBase64(signature));\n        const cryptoKey = await window.crypto.subtle.importKey(\"jwk\", pubkey, algo, true, [\n            \"verify\"\n        ]);\n        // SubtleCrypto's verify method is async so we must make\n        // this method async as well.\n        const result = await window.crypto.subtle.verify(algo, cryptoKey, signatureArray, dataArray);\n        return result;\n    }\n    async sign(privateKey, data) {\n        const algo = {\n            name: \"RSASSA-PKCS1-v1_5\",\n            hash: {\n                name: \"SHA-256\"\n            }\n        };\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const dataArray = new TextEncoder().encode(data);\n        const cryptoKey = await window.crypto.subtle.importKey(\"jwk\", privateKey, algo, true, [\n            \"sign\"\n        ]);\n        // SubtleCrypto's sign method is async so we must make\n        // this method async as well.\n        const result = await window.crypto.subtle.sign(algo, cryptoKey, dataArray);\n        return base64js.fromByteArray(new Uint8Array(result));\n    }\n    decodeBase64StringUtf8(base64) {\n        const uint8array = base64js.toByteArray(BrowserCrypto.padBase64(base64));\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const result = new TextDecoder().decode(uint8array);\n        return result;\n    }\n    encodeBase64StringUtf8(text) {\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const uint8array = new TextEncoder().encode(text);\n        const result = base64js.fromByteArray(uint8array);\n        return result;\n    }\n    /**\n     * Computes the SHA-256 hash of the provided string.\n     * @param str The plain text string to hash.\n     * @return A promise that resolves with the SHA-256 hash of the provided\n     *   string in hexadecimal encoding.\n     */ async sha256DigestHex(str) {\n        // SubtleCrypto digest() method is async, so we must make\n        // this method async as well.\n        // To calculate SHA256 digest using SubtleCrypto, we first\n        // need to convert an input string to an ArrayBuffer:\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const inputBuffer = new TextEncoder().encode(str);\n        // Result is ArrayBuffer as well.\n        const outputBuffer = await window.crypto.subtle.digest(\"SHA-256\", inputBuffer);\n        return (0, crypto_1.fromArrayBufferToHex)(outputBuffer);\n    }\n    /**\n     * Computes the HMAC hash of a message using the provided crypto key and the\n     * SHA-256 algorithm.\n     * @param key The secret crypto key in utf-8 or ArrayBuffer format.\n     * @param msg The plain text message.\n     * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer\n     *   format.\n     */ async signWithHmacSha256(key, msg) {\n        // Convert key, if provided in ArrayBuffer format, to string.\n        const rawKey = typeof key === \"string\" ? key : String.fromCharCode(...new Uint16Array(key));\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const enc = new TextEncoder();\n        const cryptoKey = await window.crypto.subtle.importKey(\"raw\", enc.encode(rawKey), {\n            name: \"HMAC\",\n            hash: {\n                name: \"SHA-256\"\n            }\n        }, false, [\n            \"sign\"\n        ]);\n        return window.crypto.subtle.sign(\"HMAC\", cryptoKey, enc.encode(msg));\n    }\n}\nexports.BrowserCrypto = BrowserCrypto; //# sourceMappingURL=crypto.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvY3J5cHRvL2Jyb3dzZXIvY3J5cHRvLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDLGlCQUFpQixHQUNqQkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHLEtBQUs7QUFDN0IsaUVBQWlFO0FBQ2pFLGlEQUFpRDtBQUNqRCxNQUFNRyxXQUFXQyxtQkFBT0EsQ0FBQywwREFBVztBQUNwQyx1RUFBdUU7QUFDdkUsNkVBQTZFO0FBQzdFLDBCQUEwQjtBQUMxQixzRUFBc0U7QUFDdEUsSUFBSSxPQUFPQyxZQUFZLGVBQWUsT0FBT0MsZ0JBQWdCLGFBQWE7SUFDdEVGLG1CQUFPQSxDQUFDO0FBQ1o7QUFDQSxNQUFNRyxXQUFXSCxtQkFBT0EsQ0FBQyxzRkFBVztBQUNwQyxNQUFNRjtJQUNGTSxhQUFjO1FBQ1YsSUFBSSxJQUVrQ0csRUFBRTtZQUNwQyxNQUFNLElBQUlFLE1BQU07UUFDcEI7SUFDSjtJQUNBLE1BQU1DLG1CQUFtQkMsR0FBRyxFQUFFO1FBQzFCLHlEQUF5RDtRQUN6RCw2QkFBNkI7UUFDN0IsMERBQTBEO1FBQzFELHFEQUFxRDtRQUNyRCxzRUFBc0U7UUFDdEUsTUFBTUMsY0FBYyxJQUFJVixjQUFjVyxNQUFNLENBQUNGO1FBQzdDLGlDQUFpQztRQUNqQyxNQUFNRyxlQUFlLE1BQU1ULE9BQU9DLE1BQU0sQ0FBQ0UsTUFBTSxDQUFDTyxNQUFNLENBQUMsV0FBV0g7UUFDbEUsT0FBT2IsU0FBU2lCLGFBQWEsQ0FBQyxJQUFJQyxXQUFX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c0U7UUFDdEUsTUFBTU0sTUFBTSxJQUFJckQ7UUFDaEIsTUFBTWlDLFlBQVksTUFBTTlCLE9BQU9DLE1BQU0sQ0FBQ0UsTUFBTSxDQUFDNEIsU0FBUyxDQUFDLE9BQU9tQixJQUFJMUMsTUFBTSxDQUFDc0MsU0FBUztZQUM5RXJCLE1BQU07WUFDTkMsTUFBTTtnQkFDRkQsTUFBTTtZQUNWO1FBQ0osR0FBRyxPQUFPO1lBQUM7U0FBTztRQUNsQixPQUFPekIsT0FBT0MsTUFBTSxDQUFDRSxNQUFNLENBQUM4QixJQUFJLENBQUMsUUFBUUgsV0FBV29CLElBQUkxQyxNQUFNLENBQUNxQztJQUNuRTtBQUNKO0FBQ0F0RCxxQkFBcUIsR0FBR0UsZUFDeEIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2NyeXB0by9icm93c2VyL2NyeXB0by5qcz9mZDYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKiBnbG9iYWwgd2luZG93ICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJyb3dzZXJDcnlwdG8gPSB2b2lkIDA7XG4vLyBUaGlzIGZpbGUgaW1wbGVtZW50cyBjcnlwdG8gZnVuY3Rpb25zIHdlIG5lZWQgdXNpbmcgaW4tYnJvd3NlclxuLy8gU3VidGxlQ3J5cHRvIGludGVyZmFjZSBgd2luZG93LmNyeXB0by5zdWJ0bGVgLlxuY29uc3QgYmFzZTY0anMgPSByZXF1aXJlKFwiYmFzZTY0LWpzXCIpO1xuLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IGBUZXh0RW5jb2RlcmAuIFRoZSBmb2xsb3dpbmcgYHJlcXVpcmVgIHdpbGxcbi8vIHByb3ZpZGUgYSBmYXN0IFVURjgtb25seSByZXBsYWNlbWVudCBmb3IgdGhvc2UgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0XG4vLyB0ZXh0IGVuY29kaW5nIG5hdGl2ZWx5LlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgVGV4dEVuY29kZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmVxdWlyZSgnZmFzdC10ZXh0LWVuY29kaW5nJyk7XG59XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG9cIik7XG5jbGFzcyBCcm93c2VyQ3J5cHRvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICB3aW5kb3cuY3J5cHRvID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHdpbmRvdy5jcnlwdG8uc3VidGxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1YnRsZUNyeXB0byBub3QgZm91bmQuIE1ha2Ugc3VyZSBpdCdzIGFuIGh0dHBzOi8vIHdlYnNpdGUuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNoYTI1NkRpZ2VzdEJhc2U2NChzdHIpIHtcbiAgICAgICAgLy8gU3VidGxlQ3J5cHRvIGRpZ2VzdCgpIG1ldGhvZCBpcyBhc3luYywgc28gd2UgbXVzdCBtYWtlXG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIGFzeW5jIGFzIHdlbGwuXG4gICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBTSEEyNTYgZGlnZXN0IHVzaW5nIFN1YnRsZUNyeXB0bywgd2UgZmlyc3RcbiAgICAgICAgLy8gbmVlZCB0byBjb252ZXJ0IGFuIGlucHV0IHN0cmluZyB0byBhbiBBcnJheUJ1ZmZlcjpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICBjb25zdCBpbnB1dEJ1ZmZlciA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpO1xuICAgICAgICAvLyBSZXN1bHQgaXMgQXJyYXlCdWZmZXIgYXMgd2VsbC5cbiAgICAgICAgY29uc3Qgb3V0cHV0QnVmZmVyID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgaW5wdXRCdWZmZXIpO1xuICAgICAgICByZXR1cm4gYmFzZTY0anMuZnJvbUJ5dGVBcnJheShuZXcgVWludDhBcnJheShvdXRwdXRCdWZmZXIpKTtcbiAgICB9XG4gICAgcmFuZG9tQnl0ZXNCYXNlNjQoY291bnQpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShjb3VudCk7XG4gICAgICAgIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICAgICAgcmV0dXJuIGJhc2U2NGpzLmZyb21CeXRlQXJyYXkoYXJyYXkpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFkQmFzZTY0KGJhc2U2NCkge1xuICAgICAgICAvLyBiYXNlNjRqcyByZXF1aXJlcyBwYWRkaW5nLCBzbyBsZXQncyBhZGQgc29tZSAnPSdcbiAgICAgICAgd2hpbGUgKGJhc2U2NC5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICAgICAgICBiYXNlNjQgKz0gJz0nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfVxuICAgIGFzeW5jIHZlcmlmeShwdWJrZXksIGRhdGEsIHNpZ25hdHVyZSkge1xuICAgICAgICBjb25zdCBhbGdvID0ge1xuICAgICAgICAgICAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgICAgICAgICAgIGhhc2g6IHsgbmFtZTogJ1NIQS0yNTYnIH0sXG4gICAgICAgIH07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgY29uc3QgZGF0YUFycmF5ID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGRhdGEpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmVBcnJheSA9IGJhc2U2NGpzLnRvQnl0ZUFycmF5KEJyb3dzZXJDcnlwdG8ucGFkQmFzZTY0KHNpZ25hdHVyZSkpO1xuICAgICAgICBjb25zdCBjcnlwdG9LZXkgPSBhd2FpdCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ2p3aycsIHB1YmtleSwgYWxnbywgdHJ1ZSwgWyd2ZXJpZnknXSk7XG4gICAgICAgIC8vIFN1YnRsZUNyeXB0bydzIHZlcmlmeSBtZXRob2QgaXMgYXN5bmMgc28gd2UgbXVzdCBtYWtlXG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIGFzeW5jIGFzIHdlbGwuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdpbmRvdy5jcnlwdG8uc3VidGxlLnZlcmlmeShhbGdvLCBjcnlwdG9LZXksIHNpZ25hdHVyZUFycmF5LCBkYXRhQXJyYXkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBzaWduKHByaXZhdGVLZXksIGRhdGEpIHtcbiAgICAgICAgY29uc3QgYWxnbyA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsXG4gICAgICAgICAgICBoYXNoOiB7IG5hbWU6ICdTSEEtMjU2JyB9LFxuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgIGNvbnN0IGRhdGFBcnJheSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKTtcbiAgICAgICAgY29uc3QgY3J5cHRvS2V5ID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdqd2snLCBwcml2YXRlS2V5LCBhbGdvLCB0cnVlLCBbJ3NpZ24nXSk7XG4gICAgICAgIC8vIFN1YnRsZUNyeXB0bydzIHNpZ24gbWV0aG9kIGlzIGFzeW5jIHNvIHdlIG11c3QgbWFrZVxuICAgICAgICAvLyB0aGlzIG1ldGhvZCBhc3luYyBhcyB3ZWxsLlxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5zaWduKGFsZ28sIGNyeXB0b0tleSwgZGF0YUFycmF5KTtcbiAgICAgICAgcmV0dXJuIGJhc2U2NGpzLmZyb21CeXRlQXJyYXkobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSk7XG4gICAgfVxuICAgIGRlY29kZUJhc2U2NFN0cmluZ1V0ZjgoYmFzZTY0KSB7XG4gICAgICAgIGNvbnN0IHVpbnQ4YXJyYXkgPSBiYXNlNjRqcy50b0J5dGVBcnJheShCcm93c2VyQ3J5cHRvLnBhZEJhc2U2NChiYXNlNjQpKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodWludDhhcnJheSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVuY29kZUJhc2U2NFN0cmluZ1V0ZjgodGV4dCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgIGNvbnN0IHVpbnQ4YXJyYXkgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGV4dCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGJhc2U2NGpzLmZyb21CeXRlQXJyYXkodWludDhhcnJheSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBTSEEtMjU2IGhhc2ggb2YgdGhlIHByb3ZpZGVkIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gc3RyIFRoZSBwbGFpbiB0ZXh0IHN0cmluZyB0byBoYXNoLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgU0hBLTI1NiBoYXNoIG9mIHRoZSBwcm92aWRlZFxuICAgICAqICAgc3RyaW5nIGluIGhleGFkZWNpbWFsIGVuY29kaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHNoYTI1NkRpZ2VzdEhleChzdHIpIHtcbiAgICAgICAgLy8gU3VidGxlQ3J5cHRvIGRpZ2VzdCgpIG1ldGhvZCBpcyBhc3luYywgc28gd2UgbXVzdCBtYWtlXG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIGFzeW5jIGFzIHdlbGwuXG4gICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBTSEEyNTYgZGlnZXN0IHVzaW5nIFN1YnRsZUNyeXB0bywgd2UgZmlyc3RcbiAgICAgICAgLy8gbmVlZCB0byBjb252ZXJ0IGFuIGlucHV0IHN0cmluZyB0byBhbiBBcnJheUJ1ZmZlcjpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICBjb25zdCBpbnB1dEJ1ZmZlciA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpO1xuICAgICAgICAvLyBSZXN1bHQgaXMgQXJyYXlCdWZmZXIgYXMgd2VsbC5cbiAgICAgICAgY29uc3Qgb3V0cHV0QnVmZmVyID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgaW5wdXRCdWZmZXIpO1xuICAgICAgICByZXR1cm4gKDAsIGNyeXB0b18xLmZyb21BcnJheUJ1ZmZlclRvSGV4KShvdXRwdXRCdWZmZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgSE1BQyBoYXNoIG9mIGEgbWVzc2FnZSB1c2luZyB0aGUgcHJvdmlkZWQgY3J5cHRvIGtleSBhbmQgdGhlXG4gICAgICogU0hBLTI1NiBhbGdvcml0aG0uXG4gICAgICogQHBhcmFtIGtleSBUaGUgc2VjcmV0IGNyeXB0byBrZXkgaW4gdXRmLTggb3IgQXJyYXlCdWZmZXIgZm9ybWF0LlxuICAgICAqIEBwYXJhbSBtc2cgVGhlIHBsYWluIHRleHQgbWVzc2FnZS5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIEhNQUMtU0hBMjU2IGhhc2ggaW4gQXJyYXlCdWZmZXJcbiAgICAgKiAgIGZvcm1hdC5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduV2l0aEhtYWNTaGEyNTYoa2V5LCBtc2cpIHtcbiAgICAgICAgLy8gQ29udmVydCBrZXksIGlmIHByb3ZpZGVkIGluIEFycmF5QnVmZmVyIGZvcm1hdCwgdG8gc3RyaW5nLlxuICAgICAgICBjb25zdCByYXdLZXkgPSB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgIDogU3RyaW5nLmZyb21DaGFyQ29kZSguLi5uZXcgVWludDE2QXJyYXkoa2V5KSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgY29uc3QgZW5jID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IHdpbmRvdy5jcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3JywgZW5jLmVuY29kZShyYXdLZXkpLCB7XG4gICAgICAgICAgICBuYW1lOiAnSE1BQycsXG4gICAgICAgICAgICBoYXNoOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NIQS0yNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgZmFsc2UsIFsnc2lnbiddKTtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5jcnlwdG8uc3VidGxlLnNpZ24oJ0hNQUMnLCBjcnlwdG9LZXksIGVuYy5lbmNvZGUobXNnKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm93c2VyQ3J5cHRvID0gQnJvd3NlckNyeXB0bztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJCcm93c2VyQ3J5cHRvIiwiYmFzZTY0anMiLCJyZXF1aXJlIiwicHJvY2VzcyIsIlRleHRFbmNvZGVyIiwiY3J5cHRvXzEiLCJjb25zdHJ1Y3RvciIsIndpbmRvdyIsImNyeXB0byIsInVuZGVmaW5lZCIsInN1YnRsZSIsIkVycm9yIiwic2hhMjU2RGlnZXN0QmFzZTY0Iiwic3RyIiwiaW5wdXRCdWZmZXIiLCJlbmNvZGUiLCJvdXRwdXRCdWZmZXIiLCJkaWdlc3QiLCJmcm9tQnl0ZUFycmF5IiwiVWludDhBcnJheSIsInJhbmRvbUJ5dGVzQmFzZTY0IiwiY291bnQiLCJhcnJheSIsImdldFJhbmRvbVZhbHVlcyIsInBhZEJhc2U2NCIsImJhc2U2NCIsImxlbmd0aCIsInZlcmlmeSIsInB1YmtleSIsImRhdGEiLCJzaWduYXR1cmUiLCJhbGdvIiwibmFtZSIsImhhc2giLCJkYXRhQXJyYXkiLCJzaWduYXR1cmVBcnJheSIsInRvQnl0ZUFycmF5IiwiY3J5cHRvS2V5IiwiaW1wb3J0S2V5IiwicmVzdWx0Iiwic2lnbiIsInByaXZhdGVLZXkiLCJkZWNvZGVCYXNlNjRTdHJpbmdVdGY4IiwidWludDhhcnJheSIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwiZW5jb2RlQmFzZTY0U3RyaW5nVXRmOCIsInRleHQiLCJzaGEyNTZEaWdlc3RIZXgiLCJmcm9tQXJyYXlCdWZmZXJUb0hleCIsInNpZ25XaXRoSG1hY1NoYTI1NiIsImtleSIsIm1zZyIsInJhd0tleSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIlVpbnQxNkFycmF5IiwiZW5jIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/crypto/browser/crypto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js":
/*!*********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/crypto/crypto.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* global window */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.fromArrayBufferToHex = exports.hasBrowserCrypto = exports.createCrypto = void 0;\nconst crypto_1 = __webpack_require__(/*! ./browser/crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/browser/crypto.js\");\nconst crypto_2 = __webpack_require__(/*! ./node/crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/node/crypto.js\");\nfunction createCrypto() {\n    if (hasBrowserCrypto()) {\n        return new crypto_1.BrowserCrypto();\n    }\n    return new crypto_2.NodeCrypto();\n}\nexports.createCrypto = createCrypto;\nfunction hasBrowserCrypto() {\n    return  false && 0;\n}\nexports.hasBrowserCrypto = hasBrowserCrypto;\n/**\n * Converts an ArrayBuffer to a hexadecimal string.\n * @param arrayBuffer The ArrayBuffer to convert to hexadecimal string.\n * @return The hexadecimal encoding of the ArrayBuffer.\n */ function fromArrayBufferToHex(arrayBuffer) {\n    // Convert buffer to byte array.\n    const byteArray = Array.from(new Uint8Array(arrayBuffer));\n    // Convert bytes to hex string.\n    return byteArray.map((byte)=>{\n        return byte.toString(16).padStart(2, \"0\");\n    }).join(\"\");\n}\nexports.fromArrayBufferToHex = fromArrayBufferToHex; //# sourceMappingURL=crypto.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvY3J5cHRvL2NyeXB0by5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQyxpQkFBaUIsR0FDakJBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw0QkFBNEIsR0FBR0Esd0JBQXdCLEdBQUdBLG9CQUFvQixHQUFHLEtBQUs7QUFDdEYsTUFBTUssV0FBV0MsbUJBQU9BLENBQUMscUdBQWtCO0FBQzNDLE1BQU1DLFdBQVdELG1CQUFPQSxDQUFDLCtGQUFlO0FBQ3hDLFNBQVNGO0lBQ0wsSUFBSUQsb0JBQW9CO1FBQ3BCLE9BQU8sSUFBSUUsU0FBU0csYUFBYTtJQUNyQztJQUNBLE9BQU8sSUFBSUQsU0FBU0UsVUFBVTtBQUNsQztBQUNBVCxvQkFBb0IsR0FBR0k7QUFDdkIsU0FBU0Q7SUFDTCxPQUFRLE1BQ3FCLElBQ3pCLENBQWdDO0FBQ3hDO0FBQ0FILHdCQUF3QixHQUFHRztBQUMzQjs7OztDQUlDLEdBQ0QsU0FBU0QscUJBQXFCVyxXQUFXO0lBQ3JDLGdDQUFnQztJQUNoQyxNQUFNQyxZQUFZQyxNQUFNQyxJQUFJLENBQUMsSUFBSUMsV0FBV0o7SUFDNUMsK0JBQStCO0lBQy9CLE9BQU9DLFVBQ0ZJLEdBQUcsQ0FBQ0MsQ0FBQUE7UUFDTCxPQUFPQSxLQUFLQyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUc7SUFDekMsR0FDS0MsSUFBSSxDQUFDO0FBQ2Q7QUFDQXRCLDRCQUE0QixHQUFHRSxzQkFDL0Isa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2NyeXB0by9jcnlwdG8uanM/NDA4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mcm9tQXJyYXlCdWZmZXJUb0hleCA9IGV4cG9ydHMuaGFzQnJvd3NlckNyeXB0byA9IGV4cG9ydHMuY3JlYXRlQ3J5cHRvID0gdm9pZCAwO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiLi9icm93c2VyL2NyeXB0b1wiKTtcbmNvbnN0IGNyeXB0b18yID0gcmVxdWlyZShcIi4vbm9kZS9jcnlwdG9cIik7XG5mdW5jdGlvbiBjcmVhdGVDcnlwdG8oKSB7XG4gICAgaWYgKGhhc0Jyb3dzZXJDcnlwdG8oKSkge1xuICAgICAgICByZXR1cm4gbmV3IGNyeXB0b18xLkJyb3dzZXJDcnlwdG8oKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBjcnlwdG9fMi5Ob2RlQ3J5cHRvKCk7XG59XG5leHBvcnRzLmNyZWF0ZUNyeXB0byA9IGNyZWF0ZUNyeXB0bztcbmZ1bmN0aW9uIGhhc0Jyb3dzZXJDcnlwdG8oKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2Ygd2luZG93LmNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIHdpbmRvdy5jcnlwdG8uc3VidGxlICE9PSAndW5kZWZpbmVkJyk7XG59XG5leHBvcnRzLmhhc0Jyb3dzZXJDcnlwdG8gPSBoYXNCcm93c2VyQ3J5cHRvO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBBcnJheUJ1ZmZlciB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEBwYXJhbSBhcnJheUJ1ZmZlciBUaGUgQXJyYXlCdWZmZXIgdG8gY29udmVydCB0byBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJuIFRoZSBoZXhhZGVjaW1hbCBlbmNvZGluZyBvZiB0aGUgQXJyYXlCdWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlclRvSGV4KGFycmF5QnVmZmVyKSB7XG4gICAgLy8gQ29udmVydCBidWZmZXIgdG8gYnl0ZSBhcnJheS5cbiAgICBjb25zdCBieXRlQXJyYXkgPSBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gICAgLy8gQ29udmVydCBieXRlcyB0byBoZXggc3RyaW5nLlxuICAgIHJldHVybiBieXRlQXJyYXlcbiAgICAgICAgLm1hcChieXRlID0+IHtcbiAgICAgICAgcmV0dXJuIGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oJycpO1xufVxuZXhwb3J0cy5mcm9tQXJyYXlCdWZmZXJUb0hleCA9IGZyb21BcnJheUJ1ZmZlclRvSGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImZyb21BcnJheUJ1ZmZlclRvSGV4IiwiaGFzQnJvd3NlckNyeXB0byIsImNyZWF0ZUNyeXB0byIsImNyeXB0b18xIiwicmVxdWlyZSIsImNyeXB0b18yIiwiQnJvd3NlckNyeXB0byIsIk5vZGVDcnlwdG8iLCJ3aW5kb3ciLCJjcnlwdG8iLCJzdWJ0bGUiLCJhcnJheUJ1ZmZlciIsImJ5dGVBcnJheSIsIkFycmF5IiwiZnJvbSIsIlVpbnQ4QXJyYXkiLCJtYXAiLCJieXRlIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImpvaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/crypto/node/crypto.js":
/*!**************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/crypto/node/crypto.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.NodeCrypto = void 0;\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nclass NodeCrypto {\n    async sha256DigestBase64(str) {\n        return crypto.createHash(\"sha256\").update(str).digest(\"base64\");\n    }\n    randomBytesBase64(count) {\n        return crypto.randomBytes(count).toString(\"base64\");\n    }\n    async verify(pubkey, data, signature) {\n        const verifier = crypto.createVerify(\"sha256\");\n        verifier.update(data);\n        verifier.end();\n        return verifier.verify(pubkey, signature, \"base64\");\n    }\n    async sign(privateKey, data) {\n        const signer = crypto.createSign(\"RSA-SHA256\");\n        signer.update(data);\n        signer.end();\n        return signer.sign(privateKey, \"base64\");\n    }\n    decodeBase64StringUtf8(base64) {\n        return Buffer.from(base64, \"base64\").toString(\"utf-8\");\n    }\n    encodeBase64StringUtf8(text) {\n        return Buffer.from(text, \"utf-8\").toString(\"base64\");\n    }\n    /**\n     * Computes the SHA-256 hash of the provided string.\n     * @param str The plain text string to hash.\n     * @return A promise that resolves with the SHA-256 hash of the provided\n     *   string in hexadecimal encoding.\n     */ async sha256DigestHex(str) {\n        return crypto.createHash(\"sha256\").update(str).digest(\"hex\");\n    }\n    /**\n     * Computes the HMAC hash of a message using the provided crypto key and the\n     * SHA-256 algorithm.\n     * @param key The secret crypto key in utf-8 or ArrayBuffer format.\n     * @param msg The plain text message.\n     * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer\n     *   format.\n     */ async signWithHmacSha256(key, msg) {\n        const cryptoKey = typeof key === \"string\" ? key : toBuffer(key);\n        return toArrayBuffer(crypto.createHmac(\"sha256\", cryptoKey).update(msg).digest());\n    }\n}\nexports.NodeCrypto = NodeCrypto;\n/**\n * Converts a Node.js Buffer to an ArrayBuffer.\n * https://stackoverflow.com/questions/8609289/convert-a-binary-nodejs-buffer-to-javascript-arraybuffer\n * @param buffer The Buffer input to covert.\n * @return The ArrayBuffer representation of the input.\n */ function toArrayBuffer(buffer) {\n    return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\n}\n/**\n * Converts an ArrayBuffer to a Node.js Buffer.\n * @param arrayBuffer The ArrayBuffer input to covert.\n * @return The Buffer representation of the input.\n */ function toBuffer(arrayBuffer) {\n    return Buffer.from(arrayBuffer);\n} //# sourceMappingURL=crypto.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvY3J5cHRvL25vZGUvY3J5cHRvLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0JBQWtCLEdBQUcsS0FBSztBQUMxQixNQUFNRyxTQUFTQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUMvQixNQUFNRjtJQUNGLE1BQU1HLG1CQUFtQkMsR0FBRyxFQUFFO1FBQzFCLE9BQU9ILE9BQU9JLFVBQVUsQ0FBQyxVQUFVQyxNQUFNLENBQUNGLEtBQUtHLE1BQU0sQ0FBQztJQUMxRDtJQUNBQyxrQkFBa0JDLEtBQUssRUFBRTtRQUNyQixPQUFPUixPQUFPUyxXQUFXLENBQUNELE9BQU9FLFFBQVEsQ0FBQztJQUM5QztJQUNBLE1BQU1DLE9BQU9DLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxTQUFTLEVBQUU7UUFDbEMsTUFBTUMsV0FBV2YsT0FBT2dCLFlBQVksQ0FBQztRQUNyQ0QsU0FBU1YsTUFBTSxDQUFDUTtRQUNoQkUsU0FBU0UsR0FBRztRQUNaLE9BQU9GLFNBQVNKLE1BQU0sQ0FBQ0MsUUFBUUUsV0FBVztJQUM5QztJQUNBLE1BQU1JLEtBQUtDLFVBQVUsRUFBRU4sSUFBSSxFQUFFO1FBQ3pCLE1BQU1PLFNBQVNwQixPQUFPcUIsVUFBVSxDQUFDO1FBQ2pDRCxPQUFPZixNQUFNLENBQUNRO1FBQ2RPLE9BQU9ILEdBQUc7UUFDVixPQUFPRyxPQUFPRixJQUFJLENBQUNDLFlBQVk7SUFDbkM7SUFDQUcsdUJBQXVCQyxNQUFNLEVBQUU7UUFDM0IsT0FBT0MsT0FBT0MsSUFBSSxDQUFDRixRQUFRLFVBQVViLFFBQVEsQ0FBQztJQUNsRDtJQUNBZ0IsdUJBQXVCQyxJQUFJLEVBQUU7UUFDekIsT0FBT0gsT0FBT0MsSUFBSSxDQUFDRSxNQUFNLFNBQVNqQixRQUFRLENBQUM7SUFDL0M7SUFDQTs7Ozs7S0FLQyxHQUNELE1BQU1rQixnQkFBZ0J6QixHQUFHLEVBQUU7UUFDdkIsT0FBT0gsT0FBT0ksVUFBVSxDQUFDLFVBQVVDLE1BQU0sQ0FBQ0YsS0FBS0csTUFBTSxDQUFDO0lBQzFEO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNELE1BQU11QixtQkFBbUJDLEdBQUcsRUFBRUMsR0FBRyxFQUFFO1FBQy9CLE1BQU1DLFlBQVksT0FBT0YsUUFBUSxXQUFXQSxNQUFNRyxTQUFTSDtRQUMzRCxPQUFPSSxjQUFjbEMsT0FBT21DLFVBQVUsQ0FBQyxVQUFVSCxXQUFXM0IsTUFBTSxDQUFDMEIsS0FBS3pCLE1BQU07SUFDbEY7QUFDSjtBQUNBVCxrQkFBa0IsR0FBR0U7QUFDckI7Ozs7O0NBS0MsR0FDRCxTQUFTbUMsY0FBY0UsTUFBTTtJQUN6QixPQUFPQSxPQUFPQSxNQUFNLENBQUNDLEtBQUssQ0FBQ0QsT0FBT0UsVUFBVSxFQUFFRixPQUFPRSxVQUFVLEdBQUdGLE9BQU9HLFVBQVU7QUFDdkY7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU04sU0FBU08sV0FBVztJQUN6QixPQUFPaEIsT0FBT0MsSUFBSSxDQUFDZTtBQUN2QixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9jcnlwdG8vbm9kZS9jcnlwdG8uanM/ZTJlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ob2RlQ3J5cHRvID0gdm9pZCAwO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbmNsYXNzIE5vZGVDcnlwdG8ge1xuICAgIGFzeW5jIHNoYTI1NkRpZ2VzdEJhc2U2NChzdHIpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoc3RyKS5kaWdlc3QoJ2Jhc2U2NCcpO1xuICAgIH1cbiAgICByYW5kb21CeXRlc0Jhc2U2NChjb3VudCkge1xuICAgICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKGNvdW50KS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICAgIGFzeW5jIHZlcmlmeShwdWJrZXksIGRhdGEsIHNpZ25hdHVyZSkge1xuICAgICAgICBjb25zdCB2ZXJpZmllciA9IGNyeXB0by5jcmVhdGVWZXJpZnkoJ3NoYTI1NicpO1xuICAgICAgICB2ZXJpZmllci51cGRhdGUoZGF0YSk7XG4gICAgICAgIHZlcmlmaWVyLmVuZCgpO1xuICAgICAgICByZXR1cm4gdmVyaWZpZXIudmVyaWZ5KHB1YmtleSwgc2lnbmF0dXJlLCAnYmFzZTY0Jyk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ24ocHJpdmF0ZUtleSwgZGF0YSkge1xuICAgICAgICBjb25zdCBzaWduZXIgPSBjcnlwdG8uY3JlYXRlU2lnbignUlNBLVNIQTI1NicpO1xuICAgICAgICBzaWduZXIudXBkYXRlKGRhdGEpO1xuICAgICAgICBzaWduZXIuZW5kKCk7XG4gICAgICAgIHJldHVybiBzaWduZXIuc2lnbihwcml2YXRlS2V5LCAnYmFzZTY0Jyk7XG4gICAgfVxuICAgIGRlY29kZUJhc2U2NFN0cmluZ1V0ZjgoYmFzZTY0KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShiYXNlNjQsICdiYXNlNjQnKS50b1N0cmluZygndXRmLTgnKTtcbiAgICB9XG4gICAgZW5jb2RlQmFzZTY0U3RyaW5nVXRmOCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0ZXh0LCAndXRmLTgnKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBTSEEtMjU2IGhhc2ggb2YgdGhlIHByb3ZpZGVkIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gc3RyIFRoZSBwbGFpbiB0ZXh0IHN0cmluZyB0byBoYXNoLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgU0hBLTI1NiBoYXNoIG9mIHRoZSBwcm92aWRlZFxuICAgICAqICAgc3RyaW5nIGluIGhleGFkZWNpbWFsIGVuY29kaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHNoYTI1NkRpZ2VzdEhleChzdHIpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoc3RyKS5kaWdlc3QoJ2hleCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgSE1BQyBoYXNoIG9mIGEgbWVzc2FnZSB1c2luZyB0aGUgcHJvdmlkZWQgY3J5cHRvIGtleSBhbmQgdGhlXG4gICAgICogU0hBLTI1NiBhbGdvcml0aG0uXG4gICAgICogQHBhcmFtIGtleSBUaGUgc2VjcmV0IGNyeXB0byBrZXkgaW4gdXRmLTggb3IgQXJyYXlCdWZmZXIgZm9ybWF0LlxuICAgICAqIEBwYXJhbSBtc2cgVGhlIHBsYWluIHRleHQgbWVzc2FnZS5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIEhNQUMtU0hBMjU2IGhhc2ggaW4gQXJyYXlCdWZmZXJcbiAgICAgKiAgIGZvcm1hdC5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduV2l0aEhtYWNTaGEyNTYoa2V5LCBtc2cpIHtcbiAgICAgICAgY29uc3QgY3J5cHRvS2V5ID0gdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgPyBrZXkgOiB0b0J1ZmZlcihrZXkpO1xuICAgICAgICByZXR1cm4gdG9BcnJheUJ1ZmZlcihjcnlwdG8uY3JlYXRlSG1hYygnc2hhMjU2JywgY3J5cHRvS2V5KS51cGRhdGUobXNnKS5kaWdlc3QoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob2RlQ3J5cHRvID0gTm9kZUNyeXB0bztcbi8qKlxuICogQ29udmVydHMgYSBOb2RlLmpzIEJ1ZmZlciB0byBhbiBBcnJheUJ1ZmZlci5cbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg2MDkyODkvY29udmVydC1hLWJpbmFyeS1ub2RlanMtYnVmZmVyLXRvLWphdmFzY3JpcHQtYXJyYXlidWZmZXJcbiAqIEBwYXJhbSBidWZmZXIgVGhlIEJ1ZmZlciBpbnB1dCB0byBjb3ZlcnQuXG4gKiBAcmV0dXJuIFRoZSBBcnJheUJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5idWZmZXIuc2xpY2UoYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlT2Zmc2V0ICsgYnVmZmVyLmJ5dGVMZW5ndGgpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBBcnJheUJ1ZmZlciB0byBhIE5vZGUuanMgQnVmZmVyLlxuICogQHBhcmFtIGFycmF5QnVmZmVyIFRoZSBBcnJheUJ1ZmZlciBpbnB1dCB0byBjb3ZlcnQuXG4gKiBAcmV0dXJuIFRoZSBCdWZmZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIGlucHV0LlxuICovXG5mdW5jdGlvbiB0b0J1ZmZlcihhcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlcik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG8uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTm9kZUNyeXB0byIsImNyeXB0byIsInJlcXVpcmUiLCJzaGEyNTZEaWdlc3RCYXNlNjQiLCJzdHIiLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiZGlnZXN0IiwicmFuZG9tQnl0ZXNCYXNlNjQiLCJjb3VudCIsInJhbmRvbUJ5dGVzIiwidG9TdHJpbmciLCJ2ZXJpZnkiLCJwdWJrZXkiLCJkYXRhIiwic2lnbmF0dXJlIiwidmVyaWZpZXIiLCJjcmVhdGVWZXJpZnkiLCJlbmQiLCJzaWduIiwicHJpdmF0ZUtleSIsInNpZ25lciIsImNyZWF0ZVNpZ24iLCJkZWNvZGVCYXNlNjRTdHJpbmdVdGY4IiwiYmFzZTY0IiwiQnVmZmVyIiwiZnJvbSIsImVuY29kZUJhc2U2NFN0cmluZ1V0ZjgiLCJ0ZXh0Iiwic2hhMjU2RGlnZXN0SGV4Iiwic2lnbldpdGhIbWFjU2hhMjU2Iiwia2V5IiwibXNnIiwiY3J5cHRvS2V5IiwidG9CdWZmZXIiLCJ0b0FycmF5QnVmZmVyIiwiY3JlYXRlSG1hYyIsImJ1ZmZlciIsInNsaWNlIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJhcnJheUJ1ZmZlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/crypto/node/crypto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.GoogleAuth = exports.auth = exports.DefaultTransporter = exports.PluggableAuthClient = exports.DownscopedClient = exports.BaseExternalAccountClient = exports.ExternalAccountClient = exports.IdentityPoolClient = exports.AwsClient = exports.UserRefreshClient = exports.LoginTicket = exports.OAuth2Client = exports.CodeChallengeMethod = exports.Impersonated = exports.JWT = exports.JWTAccess = exports.IdTokenClient = exports.IAMAuth = exports.GCPEnv = exports.Compute = exports.AuthClient = void 0;\n// Copyright 2017 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst googleauth_1 = __webpack_require__(/*! ./auth/googleauth */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/googleauth.js\");\nObject.defineProperty(exports, \"GoogleAuth\", ({\n    enumerable: true,\n    get: function() {\n        return googleauth_1.GoogleAuth;\n    }\n}));\nvar authclient_1 = __webpack_require__(/*! ./auth/authclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nObject.defineProperty(exports, \"AuthClient\", ({\n    enumerable: true,\n    get: function() {\n        return authclient_1.AuthClient;\n    }\n}));\nvar computeclient_1 = __webpack_require__(/*! ./auth/computeclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/computeclient.js\");\nObject.defineProperty(exports, \"Compute\", ({\n    enumerable: true,\n    get: function() {\n        return computeclient_1.Compute;\n    }\n}));\nvar envDetect_1 = __webpack_require__(/*! ./auth/envDetect */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/envDetect.js\");\nObject.defineProperty(exports, \"GCPEnv\", ({\n    enumerable: true,\n    get: function() {\n        return envDetect_1.GCPEnv;\n    }\n}));\nvar iam_1 = __webpack_require__(/*! ./auth/iam */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/iam.js\");\nObject.defineProperty(exports, \"IAMAuth\", ({\n    enumerable: true,\n    get: function() {\n        return iam_1.IAMAuth;\n    }\n}));\nvar idtokenclient_1 = __webpack_require__(/*! ./auth/idtokenclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/idtokenclient.js\");\nObject.defineProperty(exports, \"IdTokenClient\", ({\n    enumerable: true,\n    get: function() {\n        return idtokenclient_1.IdTokenClient;\n    }\n}));\nvar jwtaccess_1 = __webpack_require__(/*! ./auth/jwtaccess */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/jwtaccess.js\");\nObject.defineProperty(exports, \"JWTAccess\", ({\n    enumerable: true,\n    get: function() {\n        return jwtaccess_1.JWTAccess;\n    }\n}));\nvar jwtclient_1 = __webpack_require__(/*! ./auth/jwtclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/jwtclient.js\");\nObject.defineProperty(exports, \"JWT\", ({\n    enumerable: true,\n    get: function() {\n        return jwtclient_1.JWT;\n    }\n}));\nvar impersonated_1 = __webpack_require__(/*! ./auth/impersonated */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/impersonated.js\");\nObject.defineProperty(exports, \"Impersonated\", ({\n    enumerable: true,\n    get: function() {\n        return impersonated_1.Impersonated;\n    }\n}));\nvar oauth2client_1 = __webpack_require__(/*! ./auth/oauth2client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nObject.defineProperty(exports, \"CodeChallengeMethod\", ({\n    enumerable: true,\n    get: function() {\n        return oauth2client_1.CodeChallengeMethod;\n    }\n}));\nObject.defineProperty(exports, \"OAuth2Client\", ({\n    enumerable: true,\n    get: function() {\n        return oauth2client_1.OAuth2Client;\n    }\n}));\nvar loginticket_1 = __webpack_require__(/*! ./auth/loginticket */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/loginticket.js\");\nObject.defineProperty(exports, \"LoginTicket\", ({\n    enumerable: true,\n    get: function() {\n        return loginticket_1.LoginTicket;\n    }\n}));\nvar refreshclient_1 = __webpack_require__(/*! ./auth/refreshclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/refreshclient.js\");\nObject.defineProperty(exports, \"UserRefreshClient\", ({\n    enumerable: true,\n    get: function() {\n        return refreshclient_1.UserRefreshClient;\n    }\n}));\nvar awsclient_1 = __webpack_require__(/*! ./auth/awsclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/awsclient.js\");\nObject.defineProperty(exports, \"AwsClient\", ({\n    enumerable: true,\n    get: function() {\n        return awsclient_1.AwsClient;\n    }\n}));\nvar identitypoolclient_1 = __webpack_require__(/*! ./auth/identitypoolclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/identitypoolclient.js\");\nObject.defineProperty(exports, \"IdentityPoolClient\", ({\n    enumerable: true,\n    get: function() {\n        return identitypoolclient_1.IdentityPoolClient;\n    }\n}));\nvar externalclient_1 = __webpack_require__(/*! ./auth/externalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/externalclient.js\");\nObject.defineProperty(exports, \"ExternalAccountClient\", ({\n    enumerable: true,\n    get: function() {\n        return externalclient_1.ExternalAccountClient;\n    }\n}));\nvar baseexternalclient_1 = __webpack_require__(/*! ./auth/baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nObject.defineProperty(exports, \"BaseExternalAccountClient\", ({\n    enumerable: true,\n    get: function() {\n        return baseexternalclient_1.BaseExternalAccountClient;\n    }\n}));\nvar downscopedclient_1 = __webpack_require__(/*! ./auth/downscopedclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/downscopedclient.js\");\nObject.defineProperty(exports, \"DownscopedClient\", ({\n    enumerable: true,\n    get: function() {\n        return downscopedclient_1.DownscopedClient;\n    }\n}));\nvar pluggable_auth_client_1 = __webpack_require__(/*! ./auth/pluggable-auth-client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js\");\nObject.defineProperty(exports, \"PluggableAuthClient\", ({\n    enumerable: true,\n    get: function() {\n        return pluggable_auth_client_1.PluggableAuthClient;\n    }\n}));\nvar transporters_1 = __webpack_require__(/*! ./transporters */ \"(rsc)/./node_modules/google-auth-library/build/src/transporters.js\");\nObject.defineProperty(exports, \"DefaultTransporter\", ({\n    enumerable: true,\n    get: function() {\n        return transporters_1.DefaultTransporter;\n    }\n}));\nconst auth = new googleauth_1.GoogleAuth();\nexports.auth = auth; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFrQixHQUFHQSxZQUFZLEdBQUdBLDBCQUEwQixHQUFHQSwyQkFBMkIsR0FBR0Esd0JBQXdCLEdBQUdBLGlDQUFpQyxHQUFHQSw2QkFBNkIsR0FBR0EsMEJBQTBCLEdBQUdBLGlCQUFpQixHQUFHQSx5QkFBeUIsR0FBR0EsbUJBQW1CLEdBQUdBLG9CQUFvQixHQUFHQSwyQkFBMkIsR0FBR0Esb0JBQW9CLEdBQUdBLFdBQVcsR0FBR0EsaUJBQWlCLEdBQUdBLHFCQUFxQixHQUFHQSxlQUFlLEdBQUdBLGNBQWMsR0FBR0EsZUFBZSxHQUFHQSxrQkFBa0IsR0FBRyxLQUFLO0FBQ3RmLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQyxNQUFNdUIsZUFBZUMsbUJBQU9BLENBQUMsZ0dBQW1CO0FBQ2hEMUIsOENBQTZDO0lBQUUyQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxhQUFhckIsVUFBVTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3hILElBQUl5QixlQUFlSCxtQkFBT0EsQ0FBQyxnR0FBbUI7QUFDOUMxQiw4Q0FBNkM7SUFBRTJCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9DLGFBQWFMLFVBQVU7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN4SCxJQUFJTSxrQkFBa0JKLG1CQUFPQSxDQUFDLHNHQUFzQjtBQUNwRDFCLDJDQUEwQztJQUFFMkIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0UsZ0JB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QUFFLENBQUMsRUFBQztBQUMxSSxJQUFJcUMsMEJBQTBCbkIsbUJBQU9BLENBQUMsc0hBQThCO0FBQ3BFMUIsdURBQXNEO0lBQUUyQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPaUIsd0JBQXdCdEMsbUJBQW1CO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDckosSUFBSXVDLGlCQUFpQnBCLG1CQUFPQSxDQUFDLDBGQUFnQjtBQUM3QzFCLHNEQUFxRDtJQUFFMkIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT2tCLGVBQWV4QyxrQkFBa0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMxSSxNQUFNRCxPQUFPLElBQUlvQixhQUFhckIsVUFBVTtBQUN4Q0YsWUFBWSxHQUFHRyxNQUNmLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9pbmRleC5qcz8wOTY2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Hb29nbGVBdXRoID0gZXhwb3J0cy5hdXRoID0gZXhwb3J0cy5EZWZhdWx0VHJhbnNwb3J0ZXIgPSBleHBvcnRzLlBsdWdnYWJsZUF1dGhDbGllbnQgPSBleHBvcnRzLkRvd25zY29wZWRDbGllbnQgPSBleHBvcnRzLkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQgPSBleHBvcnRzLkV4dGVybmFsQWNjb3VudENsaWVudCA9IGV4cG9ydHMuSWRlbnRpdHlQb29sQ2xpZW50ID0gZXhwb3J0cy5Bd3NDbGllbnQgPSBleHBvcnRzLlVzZXJSZWZyZXNoQ2xpZW50ID0gZXhwb3J0cy5Mb2dpblRpY2tldCA9IGV4cG9ydHMuT0F1dGgyQ2xpZW50ID0gZXhwb3J0cy5Db2RlQ2hhbGxlbmdlTWV0aG9kID0gZXhwb3J0cy5JbXBlcnNvbmF0ZWQgPSBleHBvcnRzLkpXVCA9IGV4cG9ydHMuSldUQWNjZXNzID0gZXhwb3J0cy5JZFRva2VuQ2xpZW50ID0gZXhwb3J0cy5JQU1BdXRoID0gZXhwb3J0cy5HQ1BFbnYgPSBleHBvcnRzLkNvbXB1dGUgPSBleHBvcnRzLkF1dGhDbGllbnQgPSB2b2lkIDA7XG4vLyBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmNvbnN0IGdvb2dsZWF1dGhfMSA9IHJlcXVpcmUoXCIuL2F1dGgvZ29vZ2xlYXV0aFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkdvb2dsZUF1dGhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdvb2dsZWF1dGhfMS5Hb29nbGVBdXRoOyB9IH0pO1xudmFyIGF1dGhjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvYXV0aGNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkF1dGhDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGF1dGhjbGllbnRfMS5BdXRoQ2xpZW50OyB9IH0pO1xudmFyIGNvbXB1dGVjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvY29tcHV0ZWNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbXB1dGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXB1dGVjbGllbnRfMS5Db21wdXRlOyB9IH0pO1xudmFyIGVudkRldGVjdF8xID0gcmVxdWlyZShcIi4vYXV0aC9lbnZEZXRlY3RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJHQ1BFbnZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVudkRldGVjdF8xLkdDUEVudjsgfSB9KTtcbnZhciBpYW1fMSA9IHJlcXVpcmUoXCIuL2F1dGgvaWFtXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSUFNQXV0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaWFtXzEuSUFNQXV0aDsgfSB9KTtcbnZhciBpZHRva2VuY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL2lkdG9rZW5jbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJZFRva2VuQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpZHRva2VuY2xpZW50XzEuSWRUb2tlbkNsaWVudDsgfSB9KTtcbnZhciBqd3RhY2Nlc3NfMSA9IHJlcXVpcmUoXCIuL2F1dGgvand0YWNjZXNzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSldUQWNjZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqd3RhY2Nlc3NfMS5KV1RBY2Nlc3M7IH0gfSk7XG52YXIgand0Y2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL2p3dGNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpXVFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gand0Y2xpZW50XzEuSldUOyB9IH0pO1xudmFyIGltcGVyc29uYXRlZF8xID0gcmVxdWlyZShcIi4vYXV0aC9pbXBlcnNvbmF0ZWRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbXBlcnNvbmF0ZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGltcGVyc29uYXRlZF8xLkltcGVyc29uYXRlZDsgfSB9KTtcbnZhciBvYXV0aDJjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvb2F1dGgyY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29kZUNoYWxsZW5nZU1ldGhvZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb2F1dGgyY2xpZW50XzEuQ29kZUNoYWxsZW5nZU1ldGhvZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk9BdXRoMkNsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb2F1dGgyY2xpZW50XzEuT0F1dGgyQ2xpZW50OyB9IH0pO1xudmFyIGxvZ2ludGlja2V0XzEgPSByZXF1aXJlKFwiLi9hdXRoL2xvZ2ludGlja2V0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9naW5UaWNrZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvZ2ludGlja2V0XzEuTG9naW5UaWNrZXQ7IH0gfSk7XG52YXIgcmVmcmVzaGNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aC9yZWZyZXNoY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVXNlclJlZnJlc2hDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZnJlc2hjbGllbnRfMS5Vc2VyUmVmcmVzaENsaWVudDsgfSB9KTtcbnZhciBhd3NjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvYXdzY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXdzQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhd3NjbGllbnRfMS5Bd3NDbGllbnQ7IH0gfSk7XG52YXIgaWRlbnRpdHlwb29sY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL2lkZW50aXR5cG9vbGNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklkZW50aXR5UG9vbENsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaWRlbnRpdHlwb29sY2xpZW50XzEuSWRlbnRpdHlQb29sQ2xpZW50OyB9IH0pO1xudmFyIGV4dGVybmFsY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL2V4dGVybmFsY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXh0ZXJuYWxBY2NvdW50Q2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleHRlcm5hbGNsaWVudF8xLkV4dGVybmFsQWNjb3VudENsaWVudDsgfSB9KTtcbnZhciBiYXNlZXh0ZXJuYWxjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvYmFzZWV4dGVybmFsY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZUV4dGVybmFsQWNjb3VudENsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZWV4dGVybmFsY2xpZW50XzEuQmFzZUV4dGVybmFsQWNjb3VudENsaWVudDsgfSB9KTtcbnZhciBkb3duc2NvcGVkY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL2Rvd25zY29wZWRjbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEb3duc2NvcGVkQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb3duc2NvcGVkY2xpZW50XzEuRG93bnNjb3BlZENsaWVudDsgfSB9KTtcbnZhciBwbHVnZ2FibGVfYXV0aF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvcGx1Z2dhYmxlLWF1dGgtY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGx1Z2dhYmxlQXV0aENsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGx1Z2dhYmxlX2F1dGhfY2xpZW50XzEuUGx1Z2dhYmxlQXV0aENsaWVudDsgfSB9KTtcbnZhciB0cmFuc3BvcnRlcnNfMSA9IHJlcXVpcmUoXCIuL3RyYW5zcG9ydGVyc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRlZmF1bHRUcmFuc3BvcnRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnNwb3J0ZXJzXzEuRGVmYXVsdFRyYW5zcG9ydGVyOyB9IH0pO1xuY29uc3QgYXV0aCA9IG5ldyBnb29nbGVhdXRoXzEuR29vZ2xlQXV0aCgpO1xuZXhwb3J0cy5hdXRoID0gYXV0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkdvb2dsZUF1dGgiLCJhdXRoIiwiRGVmYXVsdFRyYW5zcG9ydGVyIiwiUGx1Z2dhYmxlQXV0aENsaWVudCIsIkRvd25zY29wZWRDbGllbnQiLCJCYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50IiwiRXh0ZXJuYWxBY2NvdW50Q2xpZW50IiwiSWRlbnRpdHlQb29sQ2xpZW50IiwiQXdzQ2xpZW50IiwiVXNlclJlZnJlc2hDbGllbnQiLCJMb2dpblRpY2tldCIsIk9BdXRoMkNsaWVudCIsIkNvZGVDaGFsbGVuZ2VNZXRob2QiLCJJbXBlcnNvbmF0ZWQiLCJKV1QiLCJKV1RBY2Nlc3MiLCJJZFRva2VuQ2xpZW50IiwiSUFNQXV0aCIsIkdDUEVudiIsIkNvbXB1dGUiLCJBdXRoQ2xpZW50IiwiZ29vZ2xlYXV0aF8xIiwicmVxdWlyZSIsImVudW1lcmFibGUiLCJnZXQiLCJhdXRoY2xpZW50XzEiLCJjb21wdXRlY2xpZW50XzEiLCJlbnZEZXRlY3RfMSIsImlhbV8xIiwiaWR0b2tlbmNsaWVudF8xIiwiand0YWNjZXNzXzEiLCJqd3RjbGllbnRfMSIsImltcGVyc29uYXRlZF8xIiwib2F1dGgyY2xpZW50XzEiLCJsb2dpbnRpY2tldF8xIiwicmVmcmVzaGNsaWVudF8xIiwiYXdzY2xpZW50XzEiLCJpZGVudGl0eXBvb2xjbGllbnRfMSIsImV4dGVybmFsY2xpZW50XzEiLCJiYXNlZXh0ZXJuYWxjbGllbnRfMSIsImRvd25zY29wZWRjbGllbnRfMSIsInBsdWdnYWJsZV9hdXRoX2NsaWVudF8xIiwidHJhbnNwb3J0ZXJzXzEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/options.js":
/*!***************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/options.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2017 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.validate = void 0;\n// Accepts an options object passed from the user to the API.  In the\n// previous version of the API, it referred to a `Request` options object.\n// Now it refers to an Axiox Request Config object.  This is here to help\n// ensure users don't pass invalid options when they upgrade from 0.x to 1.x.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction validate(options) {\n    const vpairs = [\n        {\n            invalid: \"uri\",\n            expected: \"url\"\n        },\n        {\n            invalid: \"json\",\n            expected: \"data\"\n        },\n        {\n            invalid: \"qs\",\n            expected: \"params\"\n        }\n    ];\n    for (const pair of vpairs){\n        if (options[pair.invalid]) {\n            const e = `'${pair.invalid}' is not a valid configuration option. Please use '${pair.expected}' instead. This library is using Axios for requests. Please see https://github.com/axios/axios to learn more about the valid request options.`;\n            throw new Error(e);\n        }\n    }\n}\nexports.validate = validate; //# sourceMappingURL=options.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvb3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdCQUFnQixHQUFHLEtBQUs7QUFDeEIscUVBQXFFO0FBQ3JFLDBFQUEwRTtBQUMxRSx5RUFBeUU7QUFDekUsNkVBQTZFO0FBQzdFLDhEQUE4RDtBQUM5RCxTQUFTRSxTQUFTQyxPQUFPO0lBQ3JCLE1BQU1DLFNBQVM7UUFDWDtZQUFFQyxTQUFTO1lBQU9DLFVBQVU7UUFBTTtRQUNsQztZQUFFRCxTQUFTO1lBQVFDLFVBQVU7UUFBTztRQUNwQztZQUFFRCxTQUFTO1lBQU1DLFVBQVU7UUFBUztLQUN2QztJQUNELEtBQUssTUFBTUMsUUFBUUgsT0FBUTtRQUN2QixJQUFJRCxPQUFPLENBQUNJLEtBQUtGLE9BQU8sQ0FBQyxFQUFFO1lBQ3ZCLE1BQU1HLElBQUksQ0FBQyxDQUFDLEVBQUVELEtBQUtGLE9BQU8sQ0FBQyxtREFBbUQsRUFBRUUsS0FBS0QsUUFBUSxDQUFDLDZJQUE2SSxDQUFDO1lBQzVPLE1BQU0sSUFBSUcsTUFBTUQ7UUFDcEI7SUFDSjtBQUNKO0FBQ0FSLGdCQUFnQixHQUFHRSxVQUNuQixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvb3B0aW9ucy5qcz81MzczIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlID0gdm9pZCAwO1xuLy8gQWNjZXB0cyBhbiBvcHRpb25zIG9iamVjdCBwYXNzZWQgZnJvbSB0aGUgdXNlciB0byB0aGUgQVBJLiAgSW4gdGhlXG4vLyBwcmV2aW91cyB2ZXJzaW9uIG9mIHRoZSBBUEksIGl0IHJlZmVycmVkIHRvIGEgYFJlcXVlc3RgIG9wdGlvbnMgb2JqZWN0LlxuLy8gTm93IGl0IHJlZmVycyB0byBhbiBBeGlveCBSZXF1ZXN0IENvbmZpZyBvYmplY3QuICBUaGlzIGlzIGhlcmUgdG8gaGVscFxuLy8gZW5zdXJlIHVzZXJzIGRvbid0IHBhc3MgaW52YWxpZCBvcHRpb25zIHdoZW4gdGhleSB1cGdyYWRlIGZyb20gMC54IHRvIDEueC5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiB2YWxpZGF0ZShvcHRpb25zKSB7XG4gICAgY29uc3QgdnBhaXJzID0gW1xuICAgICAgICB7IGludmFsaWQ6ICd1cmknLCBleHBlY3RlZDogJ3VybCcgfSxcbiAgICAgICAgeyBpbnZhbGlkOiAnanNvbicsIGV4cGVjdGVkOiAnZGF0YScgfSxcbiAgICAgICAgeyBpbnZhbGlkOiAncXMnLCBleHBlY3RlZDogJ3BhcmFtcycgfSxcbiAgICBdO1xuICAgIGZvciAoY29uc3QgcGFpciBvZiB2cGFpcnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnNbcGFpci5pbnZhbGlkXSkge1xuICAgICAgICAgICAgY29uc3QgZSA9IGAnJHtwYWlyLmludmFsaWR9JyBpcyBub3QgYSB2YWxpZCBjb25maWd1cmF0aW9uIG9wdGlvbi4gUGxlYXNlIHVzZSAnJHtwYWlyLmV4cGVjdGVkfScgaW5zdGVhZC4gVGhpcyBsaWJyYXJ5IGlzIHVzaW5nIEF4aW9zIGZvciByZXF1ZXN0cy4gUGxlYXNlIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYXhpb3MvYXhpb3MgdG8gbGVhcm4gbW9yZSBhYm91dCB0aGUgdmFsaWQgcmVxdWVzdCBvcHRpb25zLmA7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcHRpb25zLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInZhbGlkYXRlIiwib3B0aW9ucyIsInZwYWlycyIsImludmFsaWQiLCJleHBlY3RlZCIsInBhaXIiLCJlIiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/transporters.js":
/*!********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/transporters.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DefaultTransporter = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nconst options_1 = __webpack_require__(/*! ./options */ \"(rsc)/./node_modules/google-auth-library/build/src/options.js\");\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst pkg = __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/google-auth-library/package.json\");\nconst PRODUCT_NAME = \"google-api-nodejs-client\";\nclass DefaultTransporter {\n    /**\n     * Configures request options before making a request.\n     * @param opts GaxiosOptions options.\n     * @return Configured options.\n     */ configure(opts = {}) {\n        opts.headers = opts.headers || {};\n        if (true) {\n            // set transporter user agent if not in browser\n            const uaValue = opts.headers[\"User-Agent\"];\n            if (!uaValue) {\n                opts.headers[\"User-Agent\"] = DefaultTransporter.USER_AGENT;\n            } else if (!uaValue.includes(`${PRODUCT_NAME}/`)) {\n                opts.headers[\"User-Agent\"] = `${uaValue} ${DefaultTransporter.USER_AGENT}`;\n            }\n            // track google-auth-library-nodejs version:\n            if (!opts.headers[\"x-goog-api-client\"]) {\n                const nodeVersion = process.version.replace(/^v/, \"\");\n                opts.headers[\"x-goog-api-client\"] = `gl-node/${nodeVersion}`;\n            }\n        }\n        return opts;\n    }\n    request(opts, callback) {\n        // ensure the user isn't passing in request-style options\n        opts = this.configure(opts);\n        try {\n            (0, options_1.validate)(opts);\n        } catch (e) {\n            if (callback) {\n                return callback(e);\n            } else {\n                throw e;\n            }\n        }\n        if (callback) {\n            (0, gaxios_1.request)(opts).then((r)=>{\n                callback(null, r);\n            }, (e)=>{\n                callback(this.processError(e));\n            });\n        } else {\n            return (0, gaxios_1.request)(opts).catch((e)=>{\n                throw this.processError(e);\n            });\n        }\n    }\n    /**\n     * Changes the error to include details from the body.\n     */ processError(e) {\n        const res = e.response;\n        const err = e;\n        const body = res ? res.data : null;\n        if (res && body && body.error && res.status !== 200) {\n            if (typeof body.error === \"string\") {\n                err.message = body.error;\n                err.code = res.status.toString();\n            } else if (Array.isArray(body.error.errors)) {\n                err.message = body.error.errors.map((err2)=>err2.message).join(\"\\n\");\n                err.code = body.error.code;\n                err.errors = body.error.errors;\n            } else {\n                err.message = body.error.message;\n                err.code = body.error.code || res.status;\n            }\n        } else if (res && res.status >= 400) {\n            // Consider all 4xx and 5xx responses errors.\n            err.message = body;\n            err.code = res.status.toString();\n        }\n        return err;\n    }\n}\nexports.DefaultTransporter = DefaultTransporter;\n/**\n * Default user agent.\n */ DefaultTransporter.USER_AGENT = `${PRODUCT_NAME}/${pkg.version}`; //# sourceMappingURL=transporters.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvdHJhbnNwb3J0ZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMEJBQTBCLEdBQUcsS0FBSztBQUNsQyxNQUFNRyxXQUFXQyxtQkFBT0EsQ0FBQyw4REFBUTtBQUNqQyxNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQyxnRkFBVztBQUNyQyw4REFBOEQ7QUFDOUQsTUFBTUUsTUFBTUYsbUJBQU9BLENBQUM7QUFDcEIsTUFBTUcsZUFBZTtBQUNyQixNQUFNTDtJQUNGOzs7O0tBSUMsR0FDRE0sVUFBVUMsT0FBTyxDQUFDLENBQUMsRUFBRTtRQUNqQkEsS0FBS0MsT0FBTyxHQUFHRCxLQUFLQyxPQUFPLElBQUksQ0FBQztRQUNoQyxJQUFJLElBQWtCLEVBQWE7WUFDL0IsK0NBQStDO1lBQy9DLE1BQU1DLFVBQVVGLEtBQUtDLE9BQU8sQ0FBQyxhQUFhO1lBQzFDLElBQUksQ0FBQ0MsU0FBUztnQkFDVkYsS0FBS0MsT0FBTyxDQUFDLGFBQWEsR0FBR1IsbUJBQW1CVSxVQUFVO1lBQzlELE9BQ0ssSUFBSSxDQUFDRCxRQUFRRSxRQUFRLENBQUMsQ0FBQyxFQUFFTixhQUFhLENBQUMsQ0FBQyxHQUFHO2dCQUM1Q0UsS0FBS0MsT0FBTyxDQUFDLGFBQWEsR0FBRyxDQUFDLEVBQUVDLFFBQVEsQ0FBQyxFQUFFVCxtQkFBbUJVLFVBQVUsQ0FBQyxDQUFDO1lBQzlFO1lBQ0EsNENBQTRDO1lBQzVDLElBQUksQ0FBQ0gsS0FBS0MsT0FBTyxDQUFDLG9CQUFvQixFQUFFO2dCQUNwQyxNQUFNSSxjQUFjQyxRQUFRQyxPQUFPLENBQUNDLE9BQU8sQ0FBQyxNQUFNO2dCQUNsRFIsS0FBS0MsT0FBTyxDQUFDLG9CQUFvQixHQUFHLENBQUMsUUFBUSxFQUFFSSxZQUFZLENBQUM7WUFDaEU7UUFDSjtRQUNBLE9BQU9MO0lBQ1g7SUFDQVMsUUFBUVQsSUFBSSxFQUFFVSxRQUFRLEVBQUU7UUFDcEIseURBQXlEO1FBQ3pEVixPQUFPLElBQUksQ0FBQ0QsU0FBUyxDQUFDQztRQUN0QixJQUFJO1lBQ0MsSUFBR0osVUFBVWUsUUFBUSxFQUFFWDtRQUM1QixFQUNBLE9BQU9ZLEdBQUc7WUFDTixJQUFJRixVQUFVO2dCQUNWLE9BQU9BLFNBQVNFO1lBQ3BCLE9BQ0s7Z0JBQ0QsTUFBTUE7WUFDVjtRQUNKO1FBQ0EsSUFBSUYsVUFBVTtZQUNULElBQUdoQixTQUFTZSxPQUFPLEVBQUVULE1BQU1hLElBQUksQ0FBQ0MsQ0FBQUE7Z0JBQzdCSixTQUFTLE1BQU1JO1lBQ25CLEdBQUdGLENBQUFBO2dCQUNDRixTQUFTLElBQUksQ0FBQ0ssWUFBWSxDQUFDSDtZQUMvQjtRQUNKLE9BQ0s7WUFDRCxPQUFPLENBQUMsR0FBR2xCLFNBQVNlLE9BQU8sRUFBRVQsTUFBTWdCLEtBQUssQ0FBQ0osQ0FBQUE7Z0JBQ3JDLE1BQU0sSUFBSSxDQUFDRyxZQUFZLENBQUNIO1lBQzVCO1FBQ0o7SUFDSjtJQUNBOztLQUVDLEdBQ0RHLGFBQWFILENBQUMsRUFBRTtRQUNaLE1BQU1LLE1BQU1MLEVBQUVNLFFBQVE7UUFDdEIsTUFBTUMsTUFBTVA7UUFDWixNQUFNUSxPQUFPSCxNQUFNQSxJQUFJSSxJQUFJLEdBQUc7UUFDOUIsSUFBSUosT0FBT0csUUFBUUEsS0FBS0UsS0FBSyxJQUFJTCxJQUFJTSxNQUFNLEtBQUssS0FBSztZQUNqRCxJQUFJLE9BQU9ILEtBQUtFLEtBQUssS0FBSyxVQUFVO2dCQUNoQ0gsSUFBSUssT0FBTyxHQUFHSixLQUFLRSxLQUFLO2dCQUN4QkgsSUFBSU0sSUFBSSxHQUFHUixJQUFJTSxNQUFNLENBQUNHLFFBQVE7WUFDbEMsT0FDSyxJQUFJQyxNQUFNQyxPQUFPLENBQUNSLEtBQUtFLEtBQUssQ0FBQ08sTUFBTSxHQUFHO2dCQUN2Q1YsSUFBSUssT0FBTyxHQUFHSixLQUFLRSxLQUFLLENBQUNPLE1BQU0sQ0FDMUJDLEdBQUcsQ0FBQyxDQUFDQyxPQUFTQSxLQUFLUCxPQUFPLEVBQzFCUSxJQUFJLENBQUM7Z0JBQ1ZiLElBQUlNLElBQUksR0FBR0wsS0FBS0UsS0FBSyxDQUFDRyxJQUFJO2dCQUMxQk4sSUFBSVUsTUFBTSxHQUFHVCxLQUFLRSxLQUFLLENBQUNPLE1BQU07WUFDbEMsT0FDSztnQkFDRFYsSUFBSUssT0FBTyxHQUFHSixLQUFLRSxLQUFLLENBQUNFLE9BQU87Z0JBQ2hDTCxJQUFJTSxJQUFJLEdBQUdMLEtBQUtFLEtBQUssQ0FBQ0csSUFBSSxJQUFJUixJQUFJTSxNQUFNO1lBQzVDO1FBQ0osT0FDSyxJQUFJTixPQUFPQSxJQUFJTSxNQUFNLElBQUksS0FBSztZQUMvQiw2Q0FBNkM7WUFDN0NKLElBQUlLLE9BQU8sR0FBR0o7WUFDZEQsSUFBSU0sSUFBSSxHQUFHUixJQUFJTSxNQUFNLENBQUNHLFFBQVE7UUFDbEM7UUFDQSxPQUFPUDtJQUNYO0FBQ0o7QUFDQTVCLDBCQUEwQixHQUFHRTtBQUM3Qjs7Q0FFQyxHQUNEQSxtQkFBbUJVLFVBQVUsR0FBRyxDQUFDLEVBQUVMLGFBQWEsQ0FBQyxFQUFFRCxJQUFJVSxPQUFPLENBQUMsQ0FBQyxFQUNoRSx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96b21hdG8tYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvdHJhbnNwb3J0ZXJzLmpzPzc3OTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVmYXVsdFRyYW5zcG9ydGVyID0gdm9pZCAwO1xuY29uc3QgZ2F4aW9zXzEgPSByZXF1aXJlKFwiZ2F4aW9zXCIpO1xuY29uc3Qgb3B0aW9uc18xID0gcmVxdWlyZShcIi4vb3B0aW9uc1wiKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG5jb25zdCBwa2cgPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKTtcbmNvbnN0IFBST0RVQ1RfTkFNRSA9ICdnb29nbGUtYXBpLW5vZGVqcy1jbGllbnQnO1xuY2xhc3MgRGVmYXVsdFRyYW5zcG9ydGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHJlcXVlc3Qgb3B0aW9ucyBiZWZvcmUgbWFraW5nIGEgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gb3B0cyBHYXhpb3NPcHRpb25zIG9wdGlvbnMuXG4gICAgICogQHJldHVybiBDb25maWd1cmVkIG9wdGlvbnMuXG4gICAgICovXG4gICAgY29uZmlndXJlKG9wdHMgPSB7fSkge1xuICAgICAgICBvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge307XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gc2V0IHRyYW5zcG9ydGVyIHVzZXIgYWdlbnQgaWYgbm90IGluIGJyb3dzZXJcbiAgICAgICAgICAgIGNvbnN0IHVhVmFsdWUgPSBvcHRzLmhlYWRlcnNbJ1VzZXItQWdlbnQnXTtcbiAgICAgICAgICAgIGlmICghdWFWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVyc1snVXNlci1BZ2VudCddID0gRGVmYXVsdFRyYW5zcG9ydGVyLlVTRVJfQUdFTlQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdWFWYWx1ZS5pbmNsdWRlcyhgJHtQUk9EVUNUX05BTUV9L2ApKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzWydVc2VyLUFnZW50J10gPSBgJHt1YVZhbHVlfSAke0RlZmF1bHRUcmFuc3BvcnRlci5VU0VSX0FHRU5UfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cmFjayBnb29nbGUtYXV0aC1saWJyYXJ5LW5vZGVqcyB2ZXJzaW9uOlxuICAgICAgICAgICAgaWYgKCFvcHRzLmhlYWRlcnNbJ3gtZ29vZy1hcGktY2xpZW50J10pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlVmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbi5yZXBsYWNlKC9edi8sICcnKTtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnNbJ3gtZ29vZy1hcGktY2xpZW50J10gPSBgZ2wtbm9kZS8ke25vZGVWZXJzaW9ufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfVxuICAgIHJlcXVlc3Qob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gZW5zdXJlIHRoZSB1c2VyIGlzbid0IHBhc3NpbmcgaW4gcmVxdWVzdC1zdHlsZSBvcHRpb25zXG4gICAgICAgIG9wdHMgPSB0aGlzLmNvbmZpZ3VyZShvcHRzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICgwLCBvcHRpb25zXzEudmFsaWRhdGUpKG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgKDAsIGdheGlvc18xLnJlcXVlc3QpKG9wdHMpLnRoZW4ociA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcik7XG4gICAgICAgICAgICB9LCBlID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh0aGlzLnByb2Nlc3NFcnJvcihlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZ2F4aW9zXzEucmVxdWVzdCkob3B0cykuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5wcm9jZXNzRXJyb3IoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBlcnJvciB0byBpbmNsdWRlIGRldGFpbHMgZnJvbSB0aGUgYm9keS5cbiAgICAgKi9cbiAgICBwcm9jZXNzRXJyb3IoZSkge1xuICAgICAgICBjb25zdCByZXMgPSBlLnJlc3BvbnNlO1xuICAgICAgICBjb25zdCBlcnIgPSBlO1xuICAgICAgICBjb25zdCBib2R5ID0gcmVzID8gcmVzLmRhdGEgOiBudWxsO1xuICAgICAgICBpZiAocmVzICYmIGJvZHkgJiYgYm9keS5lcnJvciAmJiByZXMuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYm9keS5lcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGJvZHkuZXJyb3I7XG4gICAgICAgICAgICAgICAgZXJyLmNvZGUgPSByZXMuc3RhdHVzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJvZHkuZXJyb3IuZXJyb3JzKSkge1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gYm9keS5lcnJvci5lcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoZXJyMikgPT4gZXJyMi5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgICAgICAgICAgICAgZXJyLmNvZGUgPSBib2R5LmVycm9yLmNvZGU7XG4gICAgICAgICAgICAgICAgZXJyLmVycm9ycyA9IGJvZHkuZXJyb3IuZXJyb3JzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBib2R5LmVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgZXJyLmNvZGUgPSBib2R5LmVycm9yLmNvZGUgfHwgcmVzLnN0YXR1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXMgJiYgcmVzLnN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgICAgIC8vIENvbnNpZGVyIGFsbCA0eHggYW5kIDV4eCByZXNwb25zZXMgZXJyb3JzLlxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBib2R5O1xuICAgICAgICAgICAgZXJyLmNvZGUgPSByZXMuc3RhdHVzLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG59XG5leHBvcnRzLkRlZmF1bHRUcmFuc3BvcnRlciA9IERlZmF1bHRUcmFuc3BvcnRlcjtcbi8qKlxuICogRGVmYXVsdCB1c2VyIGFnZW50LlxuICovXG5EZWZhdWx0VHJhbnNwb3J0ZXIuVVNFUl9BR0VOVCA9IGAke1BST0RVQ1RfTkFNRX0vJHtwa2cudmVyc2lvbn1gO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNwb3J0ZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkRlZmF1bHRUcmFuc3BvcnRlciIsImdheGlvc18xIiwicmVxdWlyZSIsIm9wdGlvbnNfMSIsInBrZyIsIlBST0RVQ1RfTkFNRSIsImNvbmZpZ3VyZSIsIm9wdHMiLCJoZWFkZXJzIiwidWFWYWx1ZSIsIlVTRVJfQUdFTlQiLCJpbmNsdWRlcyIsIm5vZGVWZXJzaW9uIiwicHJvY2VzcyIsInZlcnNpb24iLCJyZXBsYWNlIiwicmVxdWVzdCIsImNhbGxiYWNrIiwidmFsaWRhdGUiLCJlIiwidGhlbiIsInIiLCJwcm9jZXNzRXJyb3IiLCJjYXRjaCIsInJlcyIsInJlc3BvbnNlIiwiZXJyIiwiYm9keSIsImRhdGEiLCJlcnJvciIsInN0YXR1cyIsIm1lc3NhZ2UiLCJjb2RlIiwidG9TdHJpbmciLCJBcnJheSIsImlzQXJyYXkiLCJlcnJvcnMiLCJtYXAiLCJlcnIyIiwiam9pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/transporters.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/package.json":
/*!*******************************************************!*\
  !*** ./node_modules/google-auth-library/package.json ***!
  \*******************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"google-auth-library","version":"8.9.0","author":"Google Inc.","description":"Google APIs Authentication Client Library for Node.js","engines":{"node":">=12"},"main":"./build/src/index.js","types":"./build/src/index.d.ts","repository":"googleapis/google-auth-library-nodejs.git","keywords":["google","api","google apis","client","client library"],"dependencies":{"arrify":"^2.0.0","base64-js":"^1.3.0","ecdsa-sig-formatter":"^1.0.11","fast-text-encoding":"^1.0.0","gaxios":"^5.0.0","gcp-metadata":"^5.3.0","gtoken":"^6.1.0","jws":"^4.0.0","lru-cache":"^6.0.0"},"devDependencies":{"@compodoc/compodoc":"^1.1.7","@types/base64-js":"^1.2.5","@types/chai":"^4.1.7","@types/jws":"^3.1.0","@types/lru-cache":"^5.0.0","@types/mocha":"^9.0.0","@types/mv":"^2.1.0","@types/ncp":"^2.0.1","@types/node":"^16.0.0","@types/sinon":"^10.0.0","assert-rejects":"^1.0.0","c8":"^8.0.0","chai":"^4.2.0","codecov":"^3.0.2","execa":"^5.0.0","gts":"^3.1.0","is-docker":"^2.0.0","karma":"^6.0.0","karma-chrome-launcher":"^3.0.0","karma-coverage":"^2.0.0","karma-firefox-launcher":"^2.0.0","karma-mocha":"^2.0.0","karma-sourcemap-loader":"^0.4.0","karma-webpack":"^5.0.0","keypair":"^1.0.4","linkinator":"^4.0.0","mocha":"^9.2.2","mv":"^2.1.1","ncp":"^2.0.0","nock":"^13.0.0","null-loader":"^4.0.0","puppeteer":"^20.0.0","sinon":"^15.0.0","ts-loader":"^8.0.0","typescript":"^4.6.3","webpack":"^5.21.2","webpack-cli":"^4.0.0"},"files":["build/src","!build/src/**/*.map"],"scripts":{"test":"c8 mocha build/test","clean":"gts clean","prepare":"npm run compile","lint":"gts check","compile":"tsc -p .","fix":"gts fix","pretest":"npm run compile","docs":"compodoc src/","samples-setup":"cd samples/ && npm link ../ && npm run setup && cd ../","samples-test":"cd samples/ && npm link ../ && npm test && cd ../","system-test":"mocha build/system-test --timeout 60000","presystem-test":"npm run compile","webpack":"webpack","browser-test":"karma start","docs-test":"linkinator docs","predocs-test":"npm run docs","prelint":"cd samples; npm link ../; npm install","precompile":"gts clean"},"license":"Apache-2.0"}');

/***/ })

};
;