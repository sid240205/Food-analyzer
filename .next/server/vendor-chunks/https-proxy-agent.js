"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/https-proxy-agent";
exports.ids = ["vendor-chunks/https-proxy-agent"];
exports.modules = {

/***/ "(rsc)/./node_modules/https-proxy-agent/dist/agent.js":
/*!******************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/agent.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __awaiter = (void 0) && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst net_1 = __importDefault(__webpack_require__(/*! net */ \"net\"));\nconst tls_1 = __importDefault(__webpack_require__(/*! tls */ \"tls\"));\nconst url_1 = __importDefault(__webpack_require__(/*! url */ \"url\"));\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst agent_base_1 = __webpack_require__(/*! agent-base */ \"(rsc)/./node_modules/agent-base/dist/src/index.js\");\nconst parse_proxy_response_1 = __importDefault(__webpack_require__(/*! ./parse-proxy-response */ \"(rsc)/./node_modules/https-proxy-agent/dist/parse-proxy-response.js\"));\nconst debug = debug_1.default(\"https-proxy-agent:agent\");\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * Outgoing HTTP requests are first tunneled through the proxy server using the\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\n * and then the proxy server connects to the destination target and issues the\n * HTTP request from the proxy server.\n *\n * `https:` requests have their socket connection upgraded to TLS once\n * the connection to the proxy server has been established.\n *\n * @api public\n */ class HttpsProxyAgent extends agent_base_1.Agent {\n    constructor(_opts){\n        let opts;\n        if (typeof _opts === \"string\") {\n            opts = url_1.default.parse(_opts);\n        } else {\n            opts = _opts;\n        }\n        if (!opts) {\n            throw new Error(\"an HTTP(S) proxy server `host` and `port` must be specified!\");\n        }\n        debug(\"creating new HttpsProxyAgent instance: %o\", opts);\n        super(opts);\n        const proxy = Object.assign({}, opts);\n        // If `true`, then connect to the proxy server over TLS.\n        // Defaults to `false`.\n        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);\n        // Prefer `hostname` over `host`, and set the `port` if needed.\n        proxy.host = proxy.hostname || proxy.host;\n        if (typeof proxy.port === \"string\") {\n            proxy.port = parseInt(proxy.port, 10);\n        }\n        if (!proxy.port && proxy.host) {\n            proxy.port = this.secureProxy ? 443 : 80;\n        }\n        // ALPN is supported by Node.js >= v5.\n        // attempt to negotiate http/1.1 for proxy servers that support http/2\n        if (this.secureProxy && !(\"ALPNProtocols\" in proxy)) {\n            proxy.ALPNProtocols = [\n                \"http 1.1\"\n            ];\n        }\n        if (proxy.host && proxy.path) {\n            // If both a `host` and `path` are specified then it's most likely\n            // the result of a `url.parse()` call... we need to remove the\n            // `path` portion so that `net.connect()` doesn't attempt to open\n            // that as a Unix socket file.\n            delete proxy.path;\n            delete proxy.pathname;\n        }\n        this.proxy = proxy;\n    }\n    /**\n     * Called when the node-core HTTP client library is creating a\n     * new HTTP request.\n     *\n     * @api protected\n     */ callback(req, opts) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { proxy, secureProxy } = this;\n            // Create a socket connection to the proxy server.\n            let socket;\n            if (secureProxy) {\n                debug(\"Creating `tls.Socket`: %o\", proxy);\n                socket = tls_1.default.connect(proxy);\n            } else {\n                debug(\"Creating `net.Socket`: %o\", proxy);\n                socket = net_1.default.connect(proxy);\n            }\n            const headers = Object.assign({}, proxy.headers);\n            const hostname = `${opts.host}:${opts.port}`;\n            let payload = `CONNECT ${hostname} HTTP/1.1\\r\\n`;\n            // Inject the `Proxy-Authorization` header if necessary.\n            if (proxy.auth) {\n                headers[\"Proxy-Authorization\"] = `Basic ${Buffer.from(proxy.auth).toString(\"base64\")}`;\n            }\n            // The `Host` header should only include the port\n            // number when it is not the default port.\n            let { host, port, secureEndpoint } = opts;\n            if (!isDefaultPort(port, secureEndpoint)) {\n                host += `:${port}`;\n            }\n            headers.Host = host;\n            headers.Connection = \"close\";\n            for (const name of Object.keys(headers)){\n                payload += `${name}: ${headers[name]}\\r\\n`;\n            }\n            const proxyResponsePromise = parse_proxy_response_1.default(socket);\n            socket.write(`${payload}\\r\\n`);\n            const { statusCode, buffered } = yield proxyResponsePromise;\n            if (statusCode === 200) {\n                req.once(\"socket\", resume);\n                if (opts.secureEndpoint) {\n                    // The proxy is connecting to a TLS server, so upgrade\n                    // this socket connection to a TLS connection.\n                    debug(\"Upgrading socket connection to TLS\");\n                    const servername = opts.servername || opts.host;\n                    return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, \"host\", \"hostname\", \"path\", \"port\")), {\n                        socket,\n                        servername\n                    }));\n                }\n                return socket;\n            }\n            // Some other status code that's not 200... need to re-play the HTTP\n            // header \"data\" events onto the socket once the HTTP machinery is\n            // attached so that the node core `http` can parse and handle the\n            // error status code.\n            // Close the original socket, and a new \"fake\" socket is returned\n            // instead, so that the proxy doesn't get the HTTP request\n            // written to it (which may contain `Authorization` headers or other\n            // sensitive data).\n            //\n            // See: https://hackerone.com/reports/541502\n            socket.destroy();\n            const fakeSocket = new net_1.default.Socket({\n                writable: false\n            });\n            fakeSocket.readable = true;\n            // Need to wait for the \"socket\" event to re-play the \"data\" events.\n            req.once(\"socket\", (s)=>{\n                debug(\"replaying proxy buffer for failed request\");\n                assert_1.default(s.listenerCount(\"data\") > 0);\n                // Replay the \"buffered\" Buffer onto the fake `socket`, since at\n                // this point the HTTP module machinery has been hooked up for\n                // the user.\n                s.push(buffered);\n                s.push(null);\n            });\n            return fakeSocket;\n        });\n    }\n}\nexports[\"default\"] = HttpsProxyAgent;\nfunction resume(socket) {\n    socket.resume();\n}\nfunction isDefaultPort(port, secure) {\n    return Boolean(!secure && port === 80 || secure && port === 443);\n}\nfunction isHTTPS(protocol) {\n    return typeof protocol === \"string\" ? /^https:?$/i.test(protocol) : false;\n}\nfunction omit(obj, ...keys) {\n    const ret = {};\n    let key;\n    for(key in obj){\n        if (!keys.includes(key)) {\n            ret[key] = obj[key];\n        }\n    }\n    return ret;\n} //# sourceMappingURL=agent.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9hZ2VudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFlBQVksQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxTQUFTLElBQUssU0FBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNuRixTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBQ0EsSUFBSU8sa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVE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QUFJQztJQUNKLElBQUtBLE9BQU9GLElBQUs7UUFDYixJQUFJLENBQUNwQixLQUFLdUIsUUFBUSxDQUFDRCxNQUFNO1lBQ3JCRCxHQUFHLENBQUNDLElBQUksR0FBR0YsR0FBRyxDQUFDRSxJQUFJO1FBQ3ZCO0lBQ0o7SUFDQSxPQUFPRDtBQUNYLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL2h0dHBzLXByb3h5LWFnZW50L2Rpc3QvYWdlbnQuanM/NTY2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgbmV0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm5ldFwiKSk7XG5jb25zdCB0bHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidGxzXCIpKTtcbmNvbnN0IHVybF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ1cmxcIikpO1xuY29uc3QgYXNzZXJ0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFzc2VydFwiKSk7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBhZ2VudF9iYXNlXzEgPSByZXF1aXJlKFwiYWdlbnQtYmFzZVwiKTtcbmNvbnN0IHBhcnNlX3Byb3h5X3Jlc3BvbnNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcGFyc2UtcHJveHktcmVzcG9uc2VcIikpO1xuY29uc3QgZGVidWcgPSBkZWJ1Z18xLmRlZmF1bHQoJ2h0dHBzLXByb3h5LWFnZW50OmFnZW50Jyk7XG4vKipcbiAqIFRoZSBgSHR0cHNQcm94eUFnZW50YCBpbXBsZW1lbnRzIGFuIEhUVFAgQWdlbnQgc3ViY2xhc3MgdGhhdCBjb25uZWN0cyB0b1xuICogdGhlIHNwZWNpZmllZCBcIkhUVFAocykgcHJveHkgc2VydmVyXCIgaW4gb3JkZXIgdG8gcHJveHkgSFRUUFMgcmVxdWVzdHMuXG4gKlxuICogT3V0Z29pbmcgSFRUUCByZXF1ZXN0cyBhcmUgZmlyc3QgdHVubmVsZWQgdGhyb3VnaCB0aGUgcHJveHkgc2VydmVyIHVzaW5nIHRoZVxuICogYENPTk5FQ1RgIEhUVFAgcmVxdWVzdCBtZXRob2QgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB0byB0aGUgcHJveHkgc2VydmVyLFxuICogYW5kIHRoZW4gdGhlIHByb3h5IHNlcnZlciBjb25uZWN0cyB0byB0aGUgZGVzdGluYXRpb24gdGFyZ2V0IGFuZCBpc3N1ZXMgdGhlXG4gKiBIVFRQIHJlcXVlc3QgZnJvbSB0aGUgcHJveHkgc2VydmVyLlxuICpcbiAqIGBodHRwczpgIHJlcXVlc3RzIGhhdmUgdGhlaXIgc29ja2V0IGNvbm5lY3Rpb24gdXBncmFkZWQgdG8gVExTIG9uY2VcbiAqIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBwcm94eSBzZXJ2ZXIgaGFzIGJlZW4gZXN0YWJsaXNoZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuY2xhc3MgSHR0cHNQcm94eUFnZW50IGV4dGVuZHMgYWdlbnRfYmFzZV8xLkFnZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihfb3B0cykge1xuICAgICAgICBsZXQgb3B0cztcbiAgICAgICAgaWYgKHR5cGVvZiBfb3B0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9wdHMgPSB1cmxfMS5kZWZhdWx0LnBhcnNlKF9vcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdHMgPSBfb3B0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYW4gSFRUUChTKSBwcm94eSBzZXJ2ZXIgYGhvc3RgIGFuZCBgcG9ydGAgbXVzdCBiZSBzcGVjaWZpZWQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ2NyZWF0aW5nIG5ldyBIdHRwc1Byb3h5QWdlbnQgaW5zdGFuY2U6ICVvJywgb3B0cyk7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICBjb25zdCBwcm94eSA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpO1xuICAgICAgICAvLyBJZiBgdHJ1ZWAsIHRoZW4gY29ubmVjdCB0byB0aGUgcHJveHkgc2VydmVyIG92ZXIgVExTLlxuICAgICAgICAvLyBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICB0aGlzLnNlY3VyZVByb3h5ID0gb3B0cy5zZWN1cmVQcm94eSB8fCBpc0hUVFBTKHByb3h5LnByb3RvY29sKTtcbiAgICAgICAgLy8gUHJlZmVyIGBob3N0bmFtZWAgb3ZlciBgaG9zdGAsIGFuZCBzZXQgdGhlIGBwb3J0YCBpZiBuZWVkZWQuXG4gICAgICAgIHByb3h5Lmhvc3QgPSBwcm94eS5ob3N0bmFtZSB8fCBwcm94eS5ob3N0O1xuICAgICAgICBpZiAodHlwZW9mIHByb3h5LnBvcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwcm94eS5wb3J0ID0gcGFyc2VJbnQocHJveHkucG9ydCwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJveHkucG9ydCAmJiBwcm94eS5ob3N0KSB7XG4gICAgICAgICAgICBwcm94eS5wb3J0ID0gdGhpcy5zZWN1cmVQcm94eSA/IDQ0MyA6IDgwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFMUE4gaXMgc3VwcG9ydGVkIGJ5IE5vZGUuanMgPj0gdjUuXG4gICAgICAgIC8vIGF0dGVtcHQgdG8gbmVnb3RpYXRlIGh0dHAvMS4xIGZvciBwcm94eSBzZXJ2ZXJzIHRoYXQgc3VwcG9ydCBodHRwLzJcbiAgICAgICAgaWYgKHRoaXMuc2VjdXJlUHJveHkgJiYgISgnQUxQTlByb3RvY29scycgaW4gcHJveHkpKSB7XG4gICAgICAgICAgICBwcm94eS5BTFBOUHJvdG9jb2xzID0gWydodHRwIDEuMSddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm94eS5ob3N0ICYmIHByb3h5LnBhdGgpIHtcbiAgICAgICAgICAgIC8vIElmIGJvdGggYSBgaG9zdGAgYW5kIGBwYXRoYCBhcmUgc3BlY2lmaWVkIHRoZW4gaXQncyBtb3N0IGxpa2VseVxuICAgICAgICAgICAgLy8gdGhlIHJlc3VsdCBvZiBhIGB1cmwucGFyc2UoKWAgY2FsbC4uLiB3ZSBuZWVkIHRvIHJlbW92ZSB0aGVcbiAgICAgICAgICAgIC8vIGBwYXRoYCBwb3J0aW9uIHNvIHRoYXQgYG5ldC5jb25uZWN0KClgIGRvZXNuJ3QgYXR0ZW1wdCB0byBvcGVuXG4gICAgICAgICAgICAvLyB0aGF0IGFzIGEgVW5peCBzb2NrZXQgZmlsZS5cbiAgICAgICAgICAgIGRlbGV0ZSBwcm94eS5wYXRoO1xuICAgICAgICAgICAgZGVsZXRlIHByb3h5LnBhdGhuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJveHkgPSBwcm94eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIG5vZGUtY29yZSBIVFRQIGNsaWVudCBsaWJyYXJ5IGlzIGNyZWF0aW5nIGFcbiAgICAgKiBuZXcgSFRUUCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQGFwaSBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjYWxsYmFjayhyZXEsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJveHksIHNlY3VyZVByb3h5IH0gPSB0aGlzO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIHByb3h5IHNlcnZlci5cbiAgICAgICAgICAgIGxldCBzb2NrZXQ7XG4gICAgICAgICAgICBpZiAoc2VjdXJlUHJveHkpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnQ3JlYXRpbmcgYHRscy5Tb2NrZXRgOiAlbycsIHByb3h5KTtcbiAgICAgICAgICAgICAgICBzb2NrZXQgPSB0bHNfMS5kZWZhdWx0LmNvbm5lY3QocHJveHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ0NyZWF0aW5nIGBuZXQuU29ja2V0YDogJW8nLCBwcm94eSk7XG4gICAgICAgICAgICAgICAgc29ja2V0ID0gbmV0XzEuZGVmYXVsdC5jb25uZWN0KHByb3h5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm94eS5oZWFkZXJzKTtcbiAgICAgICAgICAgIGNvbnN0IGhvc3RuYW1lID0gYCR7b3B0cy5ob3N0fToke29wdHMucG9ydH1gO1xuICAgICAgICAgICAgbGV0IHBheWxvYWQgPSBgQ09OTkVDVCAke2hvc3RuYW1lfSBIVFRQLzEuMVxcclxcbmA7XG4gICAgICAgICAgICAvLyBJbmplY3QgdGhlIGBQcm94eS1BdXRob3JpemF0aW9uYCBoZWFkZXIgaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgaWYgKHByb3h5LmF1dGgpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPSBgQmFzaWMgJHtCdWZmZXIuZnJvbShwcm94eS5hdXRoKS50b1N0cmluZygnYmFzZTY0Jyl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBgSG9zdGAgaGVhZGVyIHNob3VsZCBvbmx5IGluY2x1ZGUgdGhlIHBvcnRcbiAgICAgICAgICAgIC8vIG51bWJlciB3aGVuIGl0IGlzIG5vdCB0aGUgZGVmYXVsdCBwb3J0LlxuICAgICAgICAgICAgbGV0IHsgaG9zdCwgcG9ydCwgc2VjdXJlRW5kcG9pbnQgfSA9IG9wdHM7XG4gICAgICAgICAgICBpZiAoIWlzRGVmYXVsdFBvcnQocG9ydCwgc2VjdXJlRW5kcG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgaG9zdCArPSBgOiR7cG9ydH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVhZGVycy5Ib3N0ID0gaG9zdDtcbiAgICAgICAgICAgIGhlYWRlcnMuQ29ubmVjdGlvbiA9ICdjbG9zZSc7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkICs9IGAke25hbWV9OiAke2hlYWRlcnNbbmFtZV19XFxyXFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb3h5UmVzcG9uc2VQcm9taXNlID0gcGFyc2VfcHJveHlfcmVzcG9uc2VfMS5kZWZhdWx0KHNvY2tldCk7XG4gICAgICAgICAgICBzb2NrZXQud3JpdGUoYCR7cGF5bG9hZH1cXHJcXG5gKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdHVzQ29kZSwgYnVmZmVyZWQgfSA9IHlpZWxkIHByb3h5UmVzcG9uc2VQcm9taXNlO1xuICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHJlcS5vbmNlKCdzb2NrZXQnLCByZXN1bWUpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnNlY3VyZUVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBwcm94eSBpcyBjb25uZWN0aW5nIHRvIGEgVExTIHNlcnZlciwgc28gdXBncmFkZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHNvY2tldCBjb25uZWN0aW9uIHRvIGEgVExTIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKCdVcGdyYWRpbmcgc29ja2V0IGNvbm5lY3Rpb24gdG8gVExTJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlcm5hbWUgPSBvcHRzLnNlcnZlcm5hbWUgfHwgb3B0cy5ob3N0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGxzXzEuZGVmYXVsdC5jb25uZWN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb21pdChvcHRzLCAnaG9zdCcsICdob3N0bmFtZScsICdwYXRoJywgJ3BvcnQnKSksIHsgc29ja2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVybmFtZSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21lIG90aGVyIHN0YXR1cyBjb2RlIHRoYXQncyBub3QgMjAwLi4uIG5lZWQgdG8gcmUtcGxheSB0aGUgSFRUUFxuICAgICAgICAgICAgLy8gaGVhZGVyIFwiZGF0YVwiIGV2ZW50cyBvbnRvIHRoZSBzb2NrZXQgb25jZSB0aGUgSFRUUCBtYWNoaW5lcnkgaXNcbiAgICAgICAgICAgIC8vIGF0dGFjaGVkIHNvIHRoYXQgdGhlIG5vZGUgY29yZSBgaHR0cGAgY2FuIHBhcnNlIGFuZCBoYW5kbGUgdGhlXG4gICAgICAgICAgICAvLyBlcnJvciBzdGF0dXMgY29kZS5cbiAgICAgICAgICAgIC8vIENsb3NlIHRoZSBvcmlnaW5hbCBzb2NrZXQsIGFuZCBhIG5ldyBcImZha2VcIiBzb2NrZXQgaXMgcmV0dXJuZWRcbiAgICAgICAgICAgIC8vIGluc3RlYWQsIHNvIHRoYXQgdGhlIHByb3h5IGRvZXNuJ3QgZ2V0IHRoZSBIVFRQIHJlcXVlc3RcbiAgICAgICAgICAgIC8vIHdyaXR0ZW4gdG8gaXQgKHdoaWNoIG1heSBjb250YWluIGBBdXRob3JpemF0aW9uYCBoZWFkZXJzIG9yIG90aGVyXG4gICAgICAgICAgICAvLyBzZW5zaXRpdmUgZGF0YSkuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2hhY2tlcm9uZS5jb20vcmVwb3J0cy81NDE1MDJcbiAgICAgICAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgICAgICBjb25zdCBmYWtlU29ja2V0ID0gbmV3IG5ldF8xLmRlZmF1bHQuU29ja2V0KHsgd3JpdGFibGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgZmFrZVNvY2tldC5yZWFkYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAvLyBOZWVkIHRvIHdhaXQgZm9yIHRoZSBcInNvY2tldFwiIGV2ZW50IHRvIHJlLXBsYXkgdGhlIFwiZGF0YVwiIGV2ZW50cy5cbiAgICAgICAgICAgIHJlcS5vbmNlKCdzb2NrZXQnLCAocykgPT4ge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdyZXBsYXlpbmcgcHJveHkgYnVmZmVyIGZvciBmYWlsZWQgcmVxdWVzdCcpO1xuICAgICAgICAgICAgICAgIGFzc2VydF8xLmRlZmF1bHQocy5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwKTtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYXkgdGhlIFwiYnVmZmVyZWRcIiBCdWZmZXIgb250byB0aGUgZmFrZSBgc29ja2V0YCwgc2luY2UgYXRcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHBvaW50IHRoZSBIVFRQIG1vZHVsZSBtYWNoaW5lcnkgaGFzIGJlZW4gaG9va2VkIHVwIGZvclxuICAgICAgICAgICAgICAgIC8vIHRoZSB1c2VyLlxuICAgICAgICAgICAgICAgIHMucHVzaChidWZmZXJlZCk7XG4gICAgICAgICAgICAgICAgcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFrZVNvY2tldDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gSHR0cHNQcm94eUFnZW50O1xuZnVuY3Rpb24gcmVzdW1lKHNvY2tldCkge1xuICAgIHNvY2tldC5yZXN1bWUoKTtcbn1cbmZ1bmN0aW9uIGlzRGVmYXVsdFBvcnQocG9ydCwgc2VjdXJlKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oKCFzZWN1cmUgJiYgcG9ydCA9PT0gODApIHx8IChzZWN1cmUgJiYgcG9ydCA9PT0gNDQzKSk7XG59XG5mdW5jdGlvbiBpc0hUVFBTKHByb3RvY29sKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm90b2NvbCA9PT0gJ3N0cmluZycgPyAvXmh0dHBzOj8kL2kudGVzdChwcm90b2NvbCkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG9taXQob2JqLCAuLi5rZXlzKSB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgbGV0IGtleTtcbiAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKCFrZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIHJldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFnZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwibmV0XzEiLCJyZXF1aXJlIiwidGxzXzEiLCJ1cmxfMSIsImFzc2VydF8xIiwiZGVidWdfMSIsImFnZW50X2Jhc2VfMSIsInBhcnNlX3Byb3h5X3Jlc3BvbnNlXzEiLCJkZWJ1ZyIsImRlZmF1bHQiLCJIdHRwc1Byb3h5QWdlbnQiLCJBZ2VudCIsImNvbnN0cnVjdG9yIiwiX29wdHMiLCJvcHRzIiwicGFyc2UiLCJFcnJvciIsInByb3h5IiwiYXNzaWduIiwic2VjdXJlUHJveHkiLCJpc0hUVFBTIiwicHJvdG9jb2wiLCJob3N0IiwiaG9zdG5hbWUiLCJwb3J0IiwicGFyc2VJbnQiLCJBTFBOUHJvdG9jb2xzIiwicGF0aCIsInBhdGhuYW1lIiwiY2FsbGJhY2siLCJyZXEiLCJzb2NrZXQiLCJjb25uZWN0IiwiaGVhZGVycyIsInBheWxvYWQiLCJhdXRoIiwiQnVmZmVyIiwiZnJvbSIsInRvU3RyaW5nIiwic2VjdXJlRW5kcG9pbnQiLCJpc0RlZmF1bHRQb3J0IiwiSG9zdCIsIkNvbm5lY3Rpb24iLCJuYW1lIiwia2V5cyIsInByb3h5UmVzcG9uc2VQcm9taXNlIiwid3JpdGUiLCJzdGF0dXNDb2RlIiwiYnVmZmVyZWQiLCJvbmNlIiwicmVzdW1lIiwic2VydmVybmFtZSIsIm9taXQiLCJkZXN0cm95IiwiZmFrZVNvY2tldCIsIlNvY2tldCIsIndyaXRhYmxlIiwicmVhZGFibGUiLCJzIiwibGlzdGVuZXJDb3VudCIsInB1c2giLCJzZWN1cmUiLCJCb29sZWFuIiwidGVzdCIsIm9iaiIsInJldCIsImtleSIsImluY2x1ZGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/https-proxy-agent/dist/agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/https-proxy-agent/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nconst agent_1 = __importDefault(__webpack_require__(/*! ./agent */ \"(rsc)/./node_modules/https-proxy-agent/dist/agent.js\"));\nfunction createHttpsProxyAgent(opts) {\n    return new agent_1.default(opts);\n}\n(function(createHttpsProxyAgent) {\n    createHttpsProxyAgent.HttpsProxyAgent = agent_1.default;\n    createHttpsProxyAgent.prototype = agent_1.default.prototype;\n})(createHttpsProxyAgent || (createHttpsProxyAgent = {}));\nmodule.exports = createHttpsProxyAgent; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBLE1BQU1FLFVBQVVILGdCQUFnQkksbUJBQU9BLENBQUMscUVBQVM7QUFDakQsU0FBU0Msc0JBQXNCQyxJQUFJO0lBQy9CLE9BQU8sSUFBSUgsUUFBUUksT0FBTyxDQUFDRDtBQUMvQjtBQUNDLFVBQVVELHFCQUFxQjtJQUM1QkEsc0JBQXNCRyxlQUFlLEdBQUdMLFFBQVFJLE9BQU87SUFDdkRGLHNCQUFzQkksU0FBUyxHQUFHTixRQUFRSSxPQUFPLENBQUNFLFNBQVM7QUFDL0QsR0FBR0oseUJBQTBCQSxDQUFBQSx3QkFBd0IsQ0FBQztBQUN0REssT0FBT0MsT0FBTyxHQUFHTix1QkFDakIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL2h0dHBzLXByb3h5LWFnZW50L2Rpc3QvaW5kZXguanM/ZjJmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbmNvbnN0IGFnZW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYWdlbnRcIikpO1xuZnVuY3Rpb24gY3JlYXRlSHR0cHNQcm94eUFnZW50KG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IGFnZW50XzEuZGVmYXVsdChvcHRzKTtcbn1cbihmdW5jdGlvbiAoY3JlYXRlSHR0cHNQcm94eUFnZW50KSB7XG4gICAgY3JlYXRlSHR0cHNQcm94eUFnZW50Lkh0dHBzUHJveHlBZ2VudCA9IGFnZW50XzEuZGVmYXVsdDtcbiAgICBjcmVhdGVIdHRwc1Byb3h5QWdlbnQucHJvdG90eXBlID0gYWdlbnRfMS5kZWZhdWx0LnByb3RvdHlwZTtcbn0pKGNyZWF0ZUh0dHBzUHJveHlBZ2VudCB8fCAoY3JlYXRlSHR0cHNQcm94eUFnZW50ID0ge30pKTtcbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlSHR0cHNQcm94eUFnZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJhZ2VudF8xIiwicmVxdWlyZSIsImNyZWF0ZUh0dHBzUHJveHlBZ2VudCIsIm9wdHMiLCJkZWZhdWx0IiwiSHR0cHNQcm94eUFnZW50IiwicHJvdG90eXBlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/https-proxy-agent/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/https-proxy-agent/dist/parse-proxy-response.js":
/*!*********************************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/parse-proxy-response.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst debug = debug_1.default(\"https-proxy-agent:parse-proxy-response\");\nfunction parseProxyResponse(socket) {\n    return new Promise((resolve, reject)=>{\n        // we need to buffer any HTTP traffic that happens with the proxy before we get\n        // the CONNECT response, so that if the response is anything other than an \"200\"\n        // response code, then we can re-play the \"data\" events on the socket once the\n        // HTTP parser is hooked up...\n        let buffersLength = 0;\n        const buffers = [];\n        function read() {\n            const b = socket.read();\n            if (b) ondata(b);\n            else socket.once(\"readable\", read);\n        }\n        function cleanup() {\n            socket.removeListener(\"end\", onend);\n            socket.removeListener(\"error\", onerror);\n            socket.removeListener(\"close\", onclose);\n            socket.removeListener(\"readable\", read);\n        }\n        function onclose(err) {\n            debug(\"onclose had error %o\", err);\n        }\n        function onend() {\n            debug(\"onend\");\n        }\n        function onerror(err) {\n            cleanup();\n            debug(\"onerror %o\", err);\n            reject(err);\n        }\n        function ondata(b) {\n            buffers.push(b);\n            buffersLength += b.length;\n            const buffered = Buffer.concat(buffers, buffersLength);\n            const endOfHeaders = buffered.indexOf(\"\\r\\n\\r\\n\");\n            if (endOfHeaders === -1) {\n                // keep buffering\n                debug(\"have not received end of HTTP headers yet...\");\n                read();\n                return;\n            }\n            const firstLine = buffered.toString(\"ascii\", 0, buffered.indexOf(\"\\r\\n\"));\n            const statusCode = +firstLine.split(\" \")[1];\n            debug(\"got proxy server response: %o\", firstLine);\n            resolve({\n                statusCode,\n                buffered\n            });\n        }\n        socket.on(\"error\", onerror);\n        socket.on(\"close\", onclose);\n        socket.on(\"end\", onend);\n        read();\n    });\n}\nexports[\"default\"] = parseProxyResponse; //# sourceMappingURL=parse-proxy-response.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9wYXJzZS1wcm94eS1yZXNwb25zZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxVQUFVUCxnQkFBZ0JRLG1CQUFPQSxDQUFDLHNEQUFPO0FBQy9DLE1BQU1DLFFBQVFGLFFBQVFHLE9BQU8sQ0FBQztBQUM5QixTQUFTQyxtQkFBbUJDLE1BQU07SUFDOUIsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1FBQ3pCLCtFQUErRTtRQUMvRSxnRkFBZ0Y7UUFDaEYsOEVBQThFO1FBQzlFLDhCQUE4QjtRQUM5QixJQUFJQyxnQkFBZ0I7UUFDcEIsTUFBTUMsVUFBVSxFQUFFO1FBQ2xCLFNBQVNDO1lBQ0wsTUFBTUMsSUFBSVAsT0FBT00sSUFBSTtZQUNyQixJQUFJQyxHQUNBQyxPQUFPRDtpQkFFUFAsT0FBT1MsSUFBSSxDQUFDLFlBQVlIO1FBQ2hDO1FBQ0EsU0FBU0k7WUFDTFYsT0FBT1csY0FBYyxDQUFDLE9BQU9DO1lBQzdCWixPQUFPVyxjQUFjLENBQUMsU0FBU0U7WUFDL0JiLE9BQU9XLGNBQWMsQ0FBQyxTQUFTRztZQUMvQmQsT0FBT1csY0FBYyxDQUFDLFlBQVlMO1FBQ3RDO1FBQ0EsU0FBU1EsUUFBUUMsR0FBRztZQUNoQmxCLE1BQU0sd0JBQXdCa0I7UUFDbEM7UUFDQSxTQUFTSDtZQUNMZixNQUFNO1FBQ1Y7UUFDQSxTQUFTZ0IsUUFBUUUsR0FBRztZQUNoQkw7WUFDQWIsTUFBTSxjQUFja0I7WUFDcEJaLE9BQU9ZO1FBQ1g7UUFDQSxTQUFTUCxPQUFPRCxDQUFDO1lBQ2JGLFFBQVFXLElBQUksQ0FBQ1Q7WUFDYkgsaUJBQWlCRyxFQUFFVSxNQUFNO1lBQ3pCLE1BQU1DLFdBQVdDLE9BQU9DLE1BQU0sQ0FBQ2YsU0FBU0Q7WUFDeEMsTUFBTWlCLGVBQWVILFNBQVNJLE9BQU8sQ0FBQztZQUN0QyxJQUFJRCxpQkFBaUIsQ0FBQyxHQUFHO2dCQUNyQixpQkFBaUI7Z0JBQ2pCeEIsTUFBTTtnQkFDTlM7Z0JBQ0E7WUFDSjtZQUNBLE1BQU1pQixZQUFZTCxTQUFTTSxRQUFRLENBQUMsU0FBUyxHQUFHTixTQUFTSSxPQUFPLENBQUM7WUFDakUsTUFBTUcsYUFBYSxDQUFDRixVQUFVRyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDM0M3QixNQUFNLGlDQUFpQzBCO1lBQ3ZDckIsUUFBUTtnQkFDSnVCO2dCQUNBUDtZQUNKO1FBQ0o7UUFDQWxCLE9BQU8yQixFQUFFLENBQUMsU0FBU2Q7UUFDbkJiLE9BQU8yQixFQUFFLENBQUMsU0FBU2I7UUFDbkJkLE9BQU8yQixFQUFFLENBQUMsT0FBT2Y7UUFDakJOO0lBQ0o7QUFDSjtBQUNBYixrQkFBZSxHQUFHTSxvQkFDbEIsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL2h0dHBzLXByb3h5LWFnZW50L2Rpc3QvcGFyc2UtcHJveHktcmVzcG9uc2UuanM/Y2QzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGRlYnVnID0gZGVidWdfMS5kZWZhdWx0KCdodHRwcy1wcm94eS1hZ2VudDpwYXJzZS1wcm94eS1yZXNwb25zZScpO1xuZnVuY3Rpb24gcGFyc2VQcm94eVJlc3BvbnNlKHNvY2tldCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gYnVmZmVyIGFueSBIVFRQIHRyYWZmaWMgdGhhdCBoYXBwZW5zIHdpdGggdGhlIHByb3h5IGJlZm9yZSB3ZSBnZXRcbiAgICAgICAgLy8gdGhlIENPTk5FQ1QgcmVzcG9uc2UsIHNvIHRoYXQgaWYgdGhlIHJlc3BvbnNlIGlzIGFueXRoaW5nIG90aGVyIHRoYW4gYW4gXCIyMDBcIlxuICAgICAgICAvLyByZXNwb25zZSBjb2RlLCB0aGVuIHdlIGNhbiByZS1wbGF5IHRoZSBcImRhdGFcIiBldmVudHMgb24gdGhlIHNvY2tldCBvbmNlIHRoZVxuICAgICAgICAvLyBIVFRQIHBhcnNlciBpcyBob29rZWQgdXAuLi5cbiAgICAgICAgbGV0IGJ1ZmZlcnNMZW5ndGggPSAwO1xuICAgICAgICBjb25zdCBidWZmZXJzID0gW107XG4gICAgICAgIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICAgICAgICBjb25zdCBiID0gc29ja2V0LnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChiKVxuICAgICAgICAgICAgICAgIG9uZGF0YShiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzb2NrZXQub25jZSgncmVhZGFibGUnLCByZWFkKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ3JlYWRhYmxlJywgcmVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25jbG9zZShlcnIpIHtcbiAgICAgICAgICAgIGRlYnVnKCdvbmNsb3NlIGhhZCBlcnJvciAlbycsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgICAgICAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgZGVidWcoJ29uZXJyb3IgJW8nLCBlcnIpO1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25kYXRhKGIpIHtcbiAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChiKTtcbiAgICAgICAgICAgIGJ1ZmZlcnNMZW5ndGggKz0gYi5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJlZCA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycywgYnVmZmVyc0xlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBlbmRPZkhlYWRlcnMgPSBidWZmZXJlZC5pbmRleE9mKCdcXHJcXG5cXHJcXG4nKTtcbiAgICAgICAgICAgIGlmIChlbmRPZkhlYWRlcnMgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8ga2VlcCBidWZmZXJpbmdcbiAgICAgICAgICAgICAgICBkZWJ1ZygnaGF2ZSBub3QgcmVjZWl2ZWQgZW5kIG9mIEhUVFAgaGVhZGVycyB5ZXQuLi4nKTtcbiAgICAgICAgICAgICAgICByZWFkKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlyc3RMaW5lID0gYnVmZmVyZWQudG9TdHJpbmcoJ2FzY2lpJywgMCwgYnVmZmVyZWQuaW5kZXhPZignXFxyXFxuJykpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9ICtmaXJzdExpbmUuc3BsaXQoJyAnKVsxXTtcbiAgICAgICAgICAgIGRlYnVnKCdnb3QgcHJveHkgc2VydmVyIHJlc3BvbnNlOiAlbycsIGZpcnN0TGluZSk7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgIGJ1ZmZlcmVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzb2NrZXQub24oJ2Vycm9yJywgb25lcnJvcik7XG4gICAgICAgIHNvY2tldC5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICAgICAgc29ja2V0Lm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgICAgIHJlYWQoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlUHJveHlSZXNwb25zZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLXByb3h5LXJlc3BvbnNlLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWJ1Z18xIiwicmVxdWlyZSIsImRlYnVnIiwiZGVmYXVsdCIsInBhcnNlUHJveHlSZXNwb25zZSIsInNvY2tldCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiYnVmZmVyc0xlbmd0aCIsImJ1ZmZlcnMiLCJyZWFkIiwiYiIsIm9uZGF0YSIsIm9uY2UiLCJjbGVhbnVwIiwicmVtb3ZlTGlzdGVuZXIiLCJvbmVuZCIsIm9uZXJyb3IiLCJvbmNsb3NlIiwiZXJyIiwicHVzaCIsImxlbmd0aCIsImJ1ZmZlcmVkIiwiQnVmZmVyIiwiY29uY2F0IiwiZW5kT2ZIZWFkZXJzIiwiaW5kZXhPZiIsImZpcnN0TGluZSIsInRvU3RyaW5nIiwic3RhdHVzQ29kZSIsInNwbGl0Iiwib24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/https-proxy-agent/dist/parse-proxy-response.js\n");

/***/ })

};
;