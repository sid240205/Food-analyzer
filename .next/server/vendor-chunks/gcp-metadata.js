"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/gcp-metadata";
exports.ids = ["vendor-chunks/gcp-metadata"];
exports.modules = {

/***/ "(rsc)/./node_modules/gcp-metadata/build/src/gcp-residency.js":
/*!**************************************************************!*\
  !*** ./node_modules/gcp-metadata/build/src/gcp-residency.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.detectGCPResidency = exports.isGoogleComputeEngine = exports.isGoogleComputeEngineMACAddress = exports.isGoogleComputeEngineLinux = exports.isGoogleCloudServerless = exports.GCE_LINUX_BIOS_PATHS = void 0;\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst os_1 = __webpack_require__(/*! os */ \"os\");\n/**\n * Known paths unique to Google Compute Engine Linux instances\n */ exports.GCE_LINUX_BIOS_PATHS = {\n    BIOS_DATE: \"/sys/class/dmi/id/bios_date\",\n    BIOS_VENDOR: \"/sys/class/dmi/id/bios_vendor\"\n};\nconst GCE_MAC_ADDRESS_REGEX = /^42:01/;\n/**\n * Determines if the process is running on a Google Cloud Serverless environment (Cloud Run or Cloud Functions instance).\n *\n * Uses the:\n * - {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.\n * - {@link https://cloud.google.com/functions/docs/env-var Cloud Functions environment variables}.\n *\n * @returns {boolean} `true` if the process is running on GCP serverless, `false` otherwise.\n */ function isGoogleCloudServerless() {\n    /**\n     * `CLOUD_RUN_JOB` is used for Cloud Run Jobs\n     * - See {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.\n     *\n     * `FUNCTION_NAME` is used in older Cloud Functions environments:\n     * - See {@link https://cloud.google.com/functions/docs/env-var Python 3.7 and Go 1.11}.\n     *\n     * `K_SERVICE` is used in Cloud Run and newer Cloud Functions environments:\n     * - See {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.\n     * - See {@link https://cloud.google.com/functions/docs/env-var Cloud Functions newer runtimes}.\n     */ const isGFEnvironment = process.env.CLOUD_RUN_JOB || process.env.FUNCTION_NAME || process.env.K_SERVICE;\n    return !!isGFEnvironment;\n}\nexports.isGoogleCloudServerless = isGoogleCloudServerless;\n/**\n * Determines if the process is running on a Linux Google Compute Engine instance.\n *\n * @returns {boolean} `true` if the process is running on Linux GCE, `false` otherwise.\n */ function isGoogleComputeEngineLinux() {\n    if ((0, os_1.platform)() !== \"linux\") return false;\n    try {\n        // ensure this file exist\n        (0, fs_1.statSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_DATE);\n        // ensure this file exist and matches\n        const biosVendor = (0, fs_1.readFileSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_VENDOR, \"utf8\");\n        return /Google/.test(biosVendor);\n    } catch (_a) {\n        return false;\n    }\n}\nexports.isGoogleComputeEngineLinux = isGoogleComputeEngineLinux;\n/**\n * Determines if the process is running on a Google Compute Engine instance with a known\n * MAC address.\n *\n * @returns {boolean} `true` if the process is running on GCE (as determined by MAC address), `false` otherwise.\n */ function isGoogleComputeEngineMACAddress() {\n    const interfaces = (0, os_1.networkInterfaces)();\n    for (const item of Object.values(interfaces)){\n        if (!item) continue;\n        for (const { mac } of item){\n            if (GCE_MAC_ADDRESS_REGEX.test(mac)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexports.isGoogleComputeEngineMACAddress = isGoogleComputeEngineMACAddress;\n/**\n * Determines if the process is running on a Google Compute Engine instance.\n *\n * @returns {boolean} `true` if the process is running on GCE, `false` otherwise.\n */ function isGoogleComputeEngine() {\n    return isGoogleComputeEngineLinux() || isGoogleComputeEngineMACAddress();\n}\nexports.isGoogleComputeEngine = isGoogleComputeEngine;\n/**\n * Determines if the process is running on Google Cloud Platform.\n *\n * @returns {boolean} `true` if the process is running on GCP, `false` otherwise.\n */ function detectGCPResidency() {\n    return isGoogleCloudServerless() || isGoogleComputeEngine();\n}\nexports.detectGCPResidency = detectGCPResidency; //# sourceMappingURL=gcp-residency.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2NwLW1ldGFkYXRhL2J1aWxkL3NyYy9nY3AtcmVzaWRlbmN5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDBCQUEwQixHQUFHQSw2QkFBNkIsR0FBR0EsdUNBQXVDLEdBQUdBLGtDQUFrQyxHQUFHQSwrQkFBK0IsR0FBR0EsNEJBQTRCLEdBQUcsS0FBSztBQUNsTixNQUFNUSxPQUFPQyxtQkFBT0EsQ0FBQyxjQUFJO0FBQ3pCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDLGNBQUk7QUFDekI7O0NBRUMsR0FDRFQsNEJBQTRCLEdBQUc7SUFDM0JXLFdBQVc7SUFDWEMsYUFBYTtBQUNqQjtBQUNBLE1BQU1DLHdCQUF3QjtBQUM5Qjs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNQO0lBQ0w7Ozs7Ozs7Ozs7S0FVQyxHQUNELE1BQU1RLGtCQUFrQkMsUUFBUUMsR0FBRyxDQUFDQyxhQUFhLElBQzdDRixRQUFRQyxHQUFHLENBQUNFLGFBQWEsSUFDekJILFFBQVFDLEdBQUcsQ0FBQ0csU0FBUztJQUN6QixPQUFPLENBQUMsQ0FBQ0w7QUFDYjtBQUNBZCwrQkFBK0IsR0FBR007QUFDbEM7Ozs7Q0FJQyxHQUNELFNBQVNEO0lBQ0wsSUFBSSxDQUFDLEdBQUdLLEtBQUtVLFFBQVEsUUFBUSxTQUN6QixPQUFPO0lBQ1gsSUFBSTtRQUNBLHlCQUF5QjtRQUN4QixJQUFHWixLQUFLYSxRQUFRLEVBQUVyQixRQUFRTyxvQkFBb0IsQ0FBQ0ksU0FBUztRQUN6RCxxQ0FBcUM7UUFDckMsTUFBTVcsYUFBYSxDQUFDLEdBQUdkLEtBQUtlLFlBQVksRUFBRXZCLFFBQVFPLG9CQUFvQixDQUFDSyxXQUFXLEVBQUU7UUFDcEYsT0FBTyxTQUFTWSxJQUFJLENBQUNGO0lBQ3pCLEVBQ0EsT0FBT0csSUFBSTtRQUNQLE9BQU87SUFDWDtBQUNKO0FBQ0F6QixrQ0FBa0MsR0FBR0s7QUFDckM7Ozs7O0NBS0MsR0FDRCxTQUFTRDtJQUNMLE1BQU1zQixhQUFhLENBQUMsR0FBR2hCLEtBQUtpQixpQkFBaUI7SUFDN0MsS0FBSyxNQUFNQyxRQUFROUIsT0FBTytCLE1BQU0sQ0FBQ0gsWUFBYTtRQUMxQyxJQUFJLENBQUNFLE1BQ0Q7UUFDSixLQUFLLE1BQU0sRUFBRUUsR0FBRyxFQUFFLElBQUlGLEtBQU07WUFDeEIsSUFBSWYsc0JBQXNCVyxJQUFJLENBQUNNLE1BQU07Z0JBQ2pDLE9BQU87WUFDWDtRQUNKO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFDQTlCLHVDQUF1QyxHQUFHSTtBQUMxQzs7OztDQUlDLEdBQ0QsU0FBU0Q7SUFDTCxPQUFPRSxnQ0FBZ0NEO0FBQzNDO0FBQ0FKLDZCQUE2QixHQUFHRztBQUNoQzs7OztDQUlDLEdBQ0QsU0FBU0Q7SUFDTCxPQUFPSSw2QkFBNkJIO0FBQ3hDO0FBQ0FILDBCQUEwQixHQUFHRSxvQkFDN0IseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9tYXRvLWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL2djcC1tZXRhZGF0YS9idWlsZC9zcmMvZ2NwLXJlc2lkZW5jeS5qcz82MDFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZXRlY3RHQ1BSZXNpZGVuY3kgPSBleHBvcnRzLmlzR29vZ2xlQ29tcHV0ZUVuZ2luZSA9IGV4cG9ydHMuaXNHb29nbGVDb21wdXRlRW5naW5lTUFDQWRkcmVzcyA9IGV4cG9ydHMuaXNHb29nbGVDb21wdXRlRW5naW5lTGludXggPSBleHBvcnRzLmlzR29vZ2xlQ2xvdWRTZXJ2ZXJsZXNzID0gZXhwb3J0cy5HQ0VfTElOVVhfQklPU19QQVRIUyA9IHZvaWQgMDtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBvc18xID0gcmVxdWlyZShcIm9zXCIpO1xuLyoqXG4gKiBLbm93biBwYXRocyB1bmlxdWUgdG8gR29vZ2xlIENvbXB1dGUgRW5naW5lIExpbnV4IGluc3RhbmNlc1xuICovXG5leHBvcnRzLkdDRV9MSU5VWF9CSU9TX1BBVEhTID0ge1xuICAgIEJJT1NfREFURTogJy9zeXMvY2xhc3MvZG1pL2lkL2Jpb3NfZGF0ZScsXG4gICAgQklPU19WRU5ET1I6ICcvc3lzL2NsYXNzL2RtaS9pZC9iaW9zX3ZlbmRvcicsXG59O1xuY29uc3QgR0NFX01BQ19BRERSRVNTX1JFR0VYID0gL140MjowMS87XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHByb2Nlc3MgaXMgcnVubmluZyBvbiBhIEdvb2dsZSBDbG91ZCBTZXJ2ZXJsZXNzIGVudmlyb25tZW50IChDbG91ZCBSdW4gb3IgQ2xvdWQgRnVuY3Rpb25zIGluc3RhbmNlKS5cbiAqXG4gKiBVc2VzIHRoZTpcbiAqIC0ge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9ydW4vZG9jcy9jb250YWluZXItY29udHJhY3QjZW52LXZhcnMgQ2xvdWQgUnVuIGVudmlyb25tZW50IHZhcmlhYmxlc30uXG4gKiAtIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vZnVuY3Rpb25zL2RvY3MvZW52LXZhciBDbG91ZCBGdW5jdGlvbnMgZW52aXJvbm1lbnQgdmFyaWFibGVzfS5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gR0NQIHNlcnZlcmxlc3MsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0dvb2dsZUNsb3VkU2VydmVybGVzcygpIHtcbiAgICAvKipcbiAgICAgKiBgQ0xPVURfUlVOX0pPQmAgaXMgdXNlZCBmb3IgQ2xvdWQgUnVuIEpvYnNcbiAgICAgKiAtIFNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3J1bi9kb2NzL2NvbnRhaW5lci1jb250cmFjdCNlbnYtdmFycyBDbG91ZCBSdW4gZW52aXJvbm1lbnQgdmFyaWFibGVzfS5cbiAgICAgKlxuICAgICAqIGBGVU5DVElPTl9OQU1FYCBpcyB1c2VkIGluIG9sZGVyIENsb3VkIEZ1bmN0aW9ucyBlbnZpcm9ubWVudHM6XG4gICAgICogLSBTZWUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9mdW5jdGlvbnMvZG9jcy9lbnYtdmFyIFB5dGhvbiAzLjcgYW5kIEdvIDEuMTF9LlxuICAgICAqXG4gICAgICogYEtfU0VSVklDRWAgaXMgdXNlZCBpbiBDbG91ZCBSdW4gYW5kIG5ld2VyIENsb3VkIEZ1bmN0aW9ucyBlbnZpcm9ubWVudHM6XG4gICAgICogLSBTZWUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9ydW4vZG9jcy9jb250YWluZXItY29udHJhY3QjZW52LXZhcnMgQ2xvdWQgUnVuIGVudmlyb25tZW50IHZhcmlhYmxlc30uXG4gICAgICogLSBTZWUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9mdW5jdGlvbnMvZG9jcy9lbnYtdmFyIENsb3VkIEZ1bmN0aW9ucyBuZXdlciBydW50aW1lc30uXG4gICAgICovXG4gICAgY29uc3QgaXNHRkVudmlyb25tZW50ID0gcHJvY2Vzcy5lbnYuQ0xPVURfUlVOX0pPQiB8fFxuICAgICAgICBwcm9jZXNzLmVudi5GVU5DVElPTl9OQU1FIHx8XG4gICAgICAgIHByb2Nlc3MuZW52LktfU0VSVklDRTtcbiAgICByZXR1cm4gISFpc0dGRW52aXJvbm1lbnQ7XG59XG5leHBvcnRzLmlzR29vZ2xlQ2xvdWRTZXJ2ZXJsZXNzID0gaXNHb29nbGVDbG91ZFNlcnZlcmxlc3M7XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHByb2Nlc3MgaXMgcnVubmluZyBvbiBhIExpbnV4IEdvb2dsZSBDb21wdXRlIEVuZ2luZSBpbnN0YW5jZS5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gTGludXggR0NFLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNHb29nbGVDb21wdXRlRW5naW5lTGludXgoKSB7XG4gICAgaWYgKCgwLCBvc18xLnBsYXRmb3JtKSgpICE9PSAnbGludXgnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gZW5zdXJlIHRoaXMgZmlsZSBleGlzdFxuICAgICAgICAoMCwgZnNfMS5zdGF0U3luYykoZXhwb3J0cy5HQ0VfTElOVVhfQklPU19QQVRIUy5CSU9TX0RBVEUpO1xuICAgICAgICAvLyBlbnN1cmUgdGhpcyBmaWxlIGV4aXN0IGFuZCBtYXRjaGVzXG4gICAgICAgIGNvbnN0IGJpb3NWZW5kb3IgPSAoMCwgZnNfMS5yZWFkRmlsZVN5bmMpKGV4cG9ydHMuR0NFX0xJTlVYX0JJT1NfUEFUSFMuQklPU19WRU5ET1IsICd1dGY4Jyk7XG4gICAgICAgIHJldHVybiAvR29vZ2xlLy50ZXN0KGJpb3NWZW5kb3IpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuaXNHb29nbGVDb21wdXRlRW5naW5lTGludXggPSBpc0dvb2dsZUNvbXB1dGVFbmdpbmVMaW51eDtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIGEgR29vZ2xlIENvbXB1dGUgRW5naW5lIGluc3RhbmNlIHdpdGggYSBrbm93blxuICogTUFDIGFkZHJlc3MuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIEdDRSAoYXMgZGV0ZXJtaW5lZCBieSBNQUMgYWRkcmVzcyksIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0dvb2dsZUNvbXB1dGVFbmdpbmVNQUNBZGRyZXNzKCkge1xuICAgIGNvbnN0IGludGVyZmFjZXMgPSAoMCwgb3NfMS5uZXR3b3JrSW50ZXJmYWNlcykoKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgT2JqZWN0LnZhbHVlcyhpbnRlcmZhY2VzKSkge1xuICAgICAgICBpZiAoIWl0ZW0pXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChjb25zdCB7IG1hYyB9IG9mIGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChHQ0VfTUFDX0FERFJFU1NfUkVHRVgudGVzdChtYWMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc0dvb2dsZUNvbXB1dGVFbmdpbmVNQUNBZGRyZXNzID0gaXNHb29nbGVDb21wdXRlRW5naW5lTUFDQWRkcmVzcztcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIGEgR29vZ2xlIENvbXB1dGUgRW5naW5lIGluc3RhbmNlLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByb2Nlc3MgaXMgcnVubmluZyBvbiBHQ0UsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0dvb2dsZUNvbXB1dGVFbmdpbmUoKSB7XG4gICAgcmV0dXJuIGlzR29vZ2xlQ29tcHV0ZUVuZ2luZUxpbnV4KCkgfHwgaXNHb29nbGVDb21wdXRlRW5naW5lTUFDQWRkcmVzcygpO1xufVxuZXhwb3J0cy5pc0dvb2dsZUNvbXB1dGVFbmdpbmUgPSBpc0dvb2dsZUNvbXB1dGVFbmdpbmU7XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHByb2Nlc3MgaXMgcnVubmluZyBvbiBHb29nbGUgQ2xvdWQgUGxhdGZvcm0uXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIEdDUCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdEdDUFJlc2lkZW5jeSgpIHtcbiAgICByZXR1cm4gaXNHb29nbGVDbG91ZFNlcnZlcmxlc3MoKSB8fCBpc0dvb2dsZUNvbXB1dGVFbmdpbmUoKTtcbn1cbmV4cG9ydHMuZGV0ZWN0R0NQUmVzaWRlbmN5ID0gZGV0ZWN0R0NQUmVzaWRlbmN5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2NwLXJlc2lkZW5jeS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZXRlY3RHQ1BSZXNpZGVuY3kiLCJpc0dvb2dsZUNvbXB1dGVFbmdpbmUiLCJpc0dvb2dsZUNvbXB1dGVFbmdpbmVNQUNBZGRyZXNzIiwiaXNHb29nbGVDb21wdXRlRW5naW5lTGludXgiLCJpc0dvb2dsZUNsb3VkU2VydmVybGVzcyIsIkdDRV9MSU5VWF9CSU9TX1BBVEhTIiwiZnNfMSIsInJlcXVpcmUiLCJvc18xIiwiQklPU19EQVRFIiwiQklPU19WRU5ET1IiLCJHQ0VfTUFDX0FERFJFU1NfUkVHRVgiLCJpc0dGRW52aXJvbm1lbnQiLCJwcm9jZXNzIiwiZW52IiwiQ0xPVURfUlVOX0pPQiIsIkZVTkNUSU9OX05BTUUiLCJLX1NFUlZJQ0UiLCJwbGF0Zm9ybSIsInN0YXRTeW5jIiwiYmlvc1ZlbmRvciIsInJlYWRGaWxlU3luYyIsInRlc3QiLCJfYSIsImludGVyZmFjZXMiLCJuZXR3b3JrSW50ZXJmYWNlcyIsIml0ZW0iLCJ2YWx1ZXMiLCJtYWMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gcp-metadata/build/src/gcp-residency.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gcp-metadata/build/src/index.js":
/*!******************************************************!*\
  !*** ./node_modules/gcp-metadata/build/src/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright 2018 Google LLC\n *\n * Distributed under MIT license.\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n */ var __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.requestTimeout = exports.setGCPResidency = exports.getGCPResidency = exports.gcpResidencyCache = exports.resetIsAvailableCache = exports.isAvailable = exports.project = exports.instance = exports.METADATA_SERVER_DETECTION = exports.HEADERS = exports.HEADER_VALUE = exports.HEADER_NAME = exports.SECONDARY_HOST_ADDRESS = exports.HOST_ADDRESS = exports.BASE_PATH = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nconst jsonBigint = __webpack_require__(/*! json-bigint */ \"(rsc)/./node_modules/json-bigint/index.js\");\nconst gcp_residency_1 = __webpack_require__(/*! ./gcp-residency */ \"(rsc)/./node_modules/gcp-metadata/build/src/gcp-residency.js\");\nexports.BASE_PATH = \"/computeMetadata/v1\";\nexports.HOST_ADDRESS = \"http://169.254.169.254\";\nexports.SECONDARY_HOST_ADDRESS = \"http://metadata.google.internal.\";\nexports.HEADER_NAME = \"Metadata-Flavor\";\nexports.HEADER_VALUE = \"Google\";\nexports.HEADERS = Object.freeze({\n    [exports.HEADER_NAME]: exports.HEADER_VALUE\n});\n/**\n * Metadata server detection override options.\n *\n * Available via `process.env.METADATA_SERVER_DETECTION`.\n */ exports.METADATA_SERVER_DETECTION = Object.freeze({\n    \"assume-present\": \"don't try to ping the metadata server, but assume it's present\",\n    none: \"don't try to ping the metadata server, but don't try to use it either\",\n    \"bios-only\": \"treat the result of a BIOS probe as canonical (don't fall back to pinging)\",\n    \"ping-only\": \"skip the BIOS probe, and go straight to pinging\"\n});\n/**\n * Returns the base URL while taking into account the GCE_METADATA_HOST\n * environment variable if it exists.\n *\n * @returns The base URL, e.g., http://169.254.169.254/computeMetadata/v1.\n */ function getBaseUrl(baseUrl) {\n    if (!baseUrl) {\n        baseUrl = process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST || exports.HOST_ADDRESS;\n    }\n    // If no scheme is provided default to HTTP:\n    if (!/^https?:\\/\\//.test(baseUrl)) {\n        baseUrl = `http://${baseUrl}`;\n    }\n    return new URL(exports.BASE_PATH, baseUrl).href;\n}\n// Accepts an options object passed from the user to the API. In previous\n// versions of the API, it referred to a `Request` or an `Axios` request\n// options object.  Now it refers to an object with very limited property\n// names. This is here to help ensure users don't pass invalid options when\n// they  upgrade from 0.4 to 0.5 to 0.8.\nfunction validate(options) {\n    Object.keys(options).forEach((key)=>{\n        switch(key){\n            case \"params\":\n            case \"property\":\n            case \"headers\":\n                break;\n            case \"qs\":\n                throw new Error(\"'qs' is not a valid configuration option. Please use 'params' instead.\");\n            default:\n                throw new Error(`'${key}' is not a valid configuration option.`);\n        }\n    });\n}\nasync function metadataAccessor(type, options, noResponseRetries = 3, fastFail = false) {\n    options = options || {};\n    if (typeof options === \"string\") {\n        options = {\n            property: options\n        };\n    }\n    let property = \"\";\n    if (typeof options === \"object\" && options.property) {\n        property = \"/\" + options.property;\n    }\n    validate(options);\n    try {\n        const requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;\n        const res = await requestMethod({\n            url: `${getBaseUrl()}/${type}${property}`,\n            headers: Object.assign({}, exports.HEADERS, options.headers),\n            retryConfig: {\n                noResponseRetries\n            },\n            params: options.params,\n            responseType: \"text\",\n            timeout: requestTimeout()\n        });\n        // NOTE: node.js converts all incoming headers to lower case.\n        if (res.headers[exports.HEADER_NAME.toLowerCase()] !== exports.HEADER_VALUE) {\n            throw new Error(`Invalid response from metadata service: incorrect ${exports.HEADER_NAME} header.`);\n        } else if (!res.data) {\n            throw new Error(\"Invalid response from the metadata service\");\n        }\n        if (typeof res.data === \"string\") {\n            try {\n                return jsonBigint.parse(res.data);\n            } catch (_a) {\n            /* ignore */ }\n        }\n        return res.data;\n    } catch (e) {\n        const err = e;\n        if (err.response && err.response.status !== 200) {\n            err.message = `Unsuccessful response status code. ${err.message}`;\n        }\n        throw e;\n    }\n}\nasync function fastFailMetadataRequest(options) {\n    const secondaryOptions = {\n        ...options,\n        url: options.url.replace(getBaseUrl(), getBaseUrl(exports.SECONDARY_HOST_ADDRESS))\n    };\n    // We race a connection between DNS/IP to metadata server. There are a couple\n    // reasons for this:\n    //\n    // 1. the DNS is slow in some GCP environments; by checking both, we might\n    //    detect the runtime environment signficantly faster.\n    // 2. we can't just check the IP, which is tarpitted and slow to respond\n    //    on a user's local machine.\n    //\n    // Additional logic has been added to make sure that we don't create an\n    // unhandled rejection in scenarios where a failure happens sometime\n    // after a success.\n    //\n    // Note, however, if a failure happens prior to a success, a rejection should\n    // occur, this is for folks running locally.\n    //\n    let responded = false;\n    const r1 = (0, gaxios_1.request)(options).then((res)=>{\n        responded = true;\n        return res;\n    }).catch((err)=>{\n        if (responded) {\n            return r2;\n        } else {\n            responded = true;\n            throw err;\n        }\n    });\n    const r2 = (0, gaxios_1.request)(secondaryOptions).then((res)=>{\n        responded = true;\n        return res;\n    }).catch((err)=>{\n        if (responded) {\n            return r1;\n        } else {\n            responded = true;\n            throw err;\n        }\n    });\n    return Promise.race([\n        r1,\n        r2\n    ]);\n}\n/**\n * Obtain metadata for the current GCE instance\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction instance(options) {\n    return metadataAccessor(\"instance\", options);\n}\nexports.instance = instance;\n/**\n * Obtain metadata for the current GCP Project.\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction project(options) {\n    return metadataAccessor(\"project\", options);\n}\nexports.project = project;\n/*\n * How many times should we retry detecting GCP environment.\n */ function detectGCPAvailableRetries() {\n    return process.env.DETECT_GCP_RETRIES ? Number(process.env.DETECT_GCP_RETRIES) : 0;\n}\nlet cachedIsAvailableResponse;\n/**\n * Determine if the metadata server is currently available.\n */ async function isAvailable() {\n    if (process.env.METADATA_SERVER_DETECTION) {\n        const value = process.env.METADATA_SERVER_DETECTION.trim().toLocaleLowerCase();\n        if (!(value in exports.METADATA_SERVER_DETECTION)) {\n            throw new RangeError(`Unknown \\`METADATA_SERVER_DETECTION\\` env variable. Got \\`${value}\\`, but it should be \\`${Object.keys(exports.METADATA_SERVER_DETECTION).join(\"`, `\")}\\`, or unset`);\n        }\n        switch(value){\n            case \"assume-present\":\n                return true;\n            case \"none\":\n                return false;\n            case \"bios-only\":\n                return getGCPResidency();\n            case \"ping-only\":\n        }\n    }\n    try {\n        // If a user is instantiating several GCP libraries at the same time,\n        // this may result in multiple calls to isAvailable(), to detect the\n        // runtime environment. We use the same promise for each of these calls\n        // to reduce the network load.\n        if (cachedIsAvailableResponse === undefined) {\n            cachedIsAvailableResponse = metadataAccessor(\"instance\", undefined, detectGCPAvailableRetries(), // If the default HOST_ADDRESS has been overridden, we should not\n            // make an effort to try SECONDARY_HOST_ADDRESS (as we are likely in\n            // a non-GCP environment):\n            !(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST));\n        }\n        await cachedIsAvailableResponse;\n        return true;\n    } catch (e) {\n        const err = e;\n        if (process.env.DEBUG_AUTH) {\n            console.info(err);\n        }\n        if (err.type === \"request-timeout\") {\n            // If running in a GCP environment, metadata endpoint should return\n            // within ms.\n            return false;\n        }\n        if (err.response && err.response.status === 404) {\n            return false;\n        } else {\n            if (!(err.response && err.response.status === 404) && // A warning is emitted if we see an unexpected err.code, or err.code\n            // is not populated:\n            (!err.code || ![\n                \"EHOSTDOWN\",\n                \"EHOSTUNREACH\",\n                \"ENETUNREACH\",\n                \"ENOENT\",\n                \"ENOTFOUND\",\n                \"ECONNREFUSED\"\n            ].includes(err.code))) {\n                let code = \"UNKNOWN\";\n                if (err.code) code = err.code;\n                process.emitWarning(`received unexpected error = ${err.message} code = ${code}`, \"MetadataLookupWarning\");\n            }\n            // Failure to resolve the metadata service means that it is not available.\n            return false;\n        }\n    }\n}\nexports.isAvailable = isAvailable;\n/**\n * reset the memoized isAvailable() lookup.\n */ function resetIsAvailableCache() {\n    cachedIsAvailableResponse = undefined;\n}\nexports.resetIsAvailableCache = resetIsAvailableCache;\n/**\n * A cache for the detected GCP Residency.\n */ exports.gcpResidencyCache = null;\n/**\n * Detects GCP Residency.\n * Caches results to reduce costs for subsequent calls.\n *\n * @see setGCPResidency for setting\n */ function getGCPResidency() {\n    if (exports.gcpResidencyCache === null) {\n        setGCPResidency();\n    }\n    return exports.gcpResidencyCache;\n}\nexports.getGCPResidency = getGCPResidency;\n/**\n * Sets the detected GCP Residency.\n * Useful for forcing metadata server detection behavior.\n *\n * Set `null` to autodetect the environment (default behavior).\n * @see getGCPResidency for getting\n */ function setGCPResidency(value = null) {\n    exports.gcpResidencyCache = value !== null ? value : (0, gcp_residency_1.detectGCPResidency)();\n}\nexports.setGCPResidency = setGCPResidency;\n/**\n * Obtain the timeout for requests to the metadata server.\n *\n * In certain environments and conditions requests can take longer than\n * the default timeout to complete. This function will determine the\n * appropriate timeout based on the environment.\n *\n * @returns {number} a request timeout duration in milliseconds.\n */ function requestTimeout() {\n    return getGCPResidency() ? 0 : 3000;\n}\nexports.requestTimeout = requestTimeout;\n__exportStar(__webpack_require__(/*! ./gcp-residency */ \"(rsc)/./node_modules/gcp-metadata/build/src/gcp-residency.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2NwLW1ldGFkYXRhL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7OztDQUtDLEdBQ0QsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcsZUFBZSxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLFlBQVksSUFBSyxTQUFTWixDQUFDLEVBQUVhLFFBQU87SUFDakUsSUFBSyxJQUFJQyxLQUFLZCxFQUFHLElBQUljLE1BQU0sYUFBYSxDQUFDakIsT0FBT2tCLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFVBQVNDLElBQUlsQixnQkFBZ0JpQixVQUFTYixHQUFHYztBQUMzSDtBQUNBakIsOENBQTZDO0lBQUVxQixPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdETCxzQkFB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Q0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7YUFDSCxDQUFDQyxRQUFRLENBQUN6QixJQUFJd0IsSUFBSSxJQUFJO2dCQUMzQixJQUFJQSxPQUFPO2dCQUNYLElBQUl4QixJQUFJd0IsSUFBSSxFQUNSQSxPQUFPeEIsSUFBSXdCLElBQUk7Z0JBQ25CMUQsUUFBUTRELFdBQVcsQ0FBQyxDQUFDLDRCQUE0QixFQUFFMUIsSUFBSUcsT0FBTyxDQUFDLFFBQVEsRUFBRXFCLEtBQUssQ0FBQyxFQUFFO1lBQ3JGO1lBQ0EsMEVBQTBFO1lBQzFFLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQXZGLG1CQUFtQixHQUFHVztBQUN0Qjs7Q0FFQyxHQUNELFNBQVNEO0lBQ0xxRSw0QkFBNEJ6RjtBQUNoQztBQUNBVSw2QkFBNkIsR0FBR1U7QUFDaEM7O0NBRUMsR0FDRFYseUJBQXlCLEdBQUc7QUFDNUI7Ozs7O0NBS0MsR0FDRCxTQUFTUTtJQUNMLElBQUlSLFFBQVFTLGlCQUFpQixLQUFLLE1BQU07UUFDcENGO0lBQ0o7SUFDQSxPQUFPUCxRQUFRUyxpQkFBaUI7QUFDcEM7QUFDQVQsdUJBQXVCLEdBQUdRO0FBQzFCOzs7Ozs7Q0FNQyxHQUNELFNBQVNELGdCQUFnQkYsUUFBUSxJQUFJO0lBQ2pDTCx5QkFBeUIsR0FBR0ssVUFBVSxPQUFPQSxRQUFRLENBQUMsR0FBR21CLGdCQUFnQmtFLGtCQUFrQjtBQUMvRjtBQUNBMUYsdUJBQXVCLEdBQUdPO0FBQzFCOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0Q7SUFDTCxPQUFPRSxvQkFBb0IsSUFBSTtBQUNuQztBQUNBUixzQkFBc0IsR0FBR007QUFDekJQLGFBQWF1QixtQkFBT0EsQ0FBQyxxRkFBaUIsR0FBR3RCLFVBQ3pDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3pvbWF0by1hbmFseXplci8uL25vZGVfbW9kdWxlcy9nY3AtbWV0YWRhdGEvYnVpbGQvc3JjL2luZGV4LmpzP2YxNTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBEaXN0cmlidXRlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFNlZSBmaWxlIExJQ0VOU0UgZm9yIGRldGFpbCBvciBjb3B5IGF0IGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXF1ZXN0VGltZW91dCA9IGV4cG9ydHMuc2V0R0NQUmVzaWRlbmN5ID0gZXhwb3J0cy5nZXRHQ1BSZXNpZGVuY3kgPSBleHBvcnRzLmdjcFJlc2lkZW5jeUNhY2hlID0gZXhwb3J0cy5yZXNldElzQXZhaWxhYmxlQ2FjaGUgPSBleHBvcnRzLmlzQXZhaWxhYmxlID0gZXhwb3J0cy5wcm9qZWN0ID0gZXhwb3J0cy5pbnN0YW5jZSA9IGV4cG9ydHMuTUVUQURBVEFfU0VSVkVSX0RFVEVDVElPTiA9IGV4cG9ydHMuSEVBREVSUyA9IGV4cG9ydHMuSEVBREVSX1ZBTFVFID0gZXhwb3J0cy5IRUFERVJfTkFNRSA9IGV4cG9ydHMuU0VDT05EQVJZX0hPU1RfQUREUkVTUyA9IGV4cG9ydHMuSE9TVF9BRERSRVNTID0gZXhwb3J0cy5CQVNFX1BBVEggPSB2b2lkIDA7XG5jb25zdCBnYXhpb3NfMSA9IHJlcXVpcmUoXCJnYXhpb3NcIik7XG5jb25zdCBqc29uQmlnaW50ID0gcmVxdWlyZShcImpzb24tYmlnaW50XCIpO1xuY29uc3QgZ2NwX3Jlc2lkZW5jeV8xID0gcmVxdWlyZShcIi4vZ2NwLXJlc2lkZW5jeVwiKTtcbmV4cG9ydHMuQkFTRV9QQVRIID0gJy9jb21wdXRlTWV0YWRhdGEvdjEnO1xuZXhwb3J0cy5IT1NUX0FERFJFU1MgPSAnaHR0cDovLzE2OS4yNTQuMTY5LjI1NCc7XG5leHBvcnRzLlNFQ09OREFSWV9IT1NUX0FERFJFU1MgPSAnaHR0cDovL21ldGFkYXRhLmdvb2dsZS5pbnRlcm5hbC4nO1xuZXhwb3J0cy5IRUFERVJfTkFNRSA9ICdNZXRhZGF0YS1GbGF2b3InO1xuZXhwb3J0cy5IRUFERVJfVkFMVUUgPSAnR29vZ2xlJztcbmV4cG9ydHMuSEVBREVSUyA9IE9iamVjdC5mcmVlemUoeyBbZXhwb3J0cy5IRUFERVJfTkFNRV06IGV4cG9ydHMuSEVBREVSX1ZBTFVFIH0pO1xuLyoqXG4gKiBNZXRhZGF0YSBzZXJ2ZXIgZGV0ZWN0aW9uIG92ZXJyaWRlIG9wdGlvbnMuXG4gKlxuICogQXZhaWxhYmxlIHZpYSBgcHJvY2Vzcy5lbnYuTUVUQURBVEFfU0VSVkVSX0RFVEVDVElPTmAuXG4gKi9cbmV4cG9ydHMuTUVUQURBVEFfU0VSVkVSX0RFVEVDVElPTiA9IE9iamVjdC5mcmVlemUoe1xuICAgICdhc3N1bWUtcHJlc2VudCc6IFwiZG9uJ3QgdHJ5IHRvIHBpbmcgdGhlIG1ldGFkYXRhIHNlcnZlciwgYnV0IGFzc3VtZSBpdCdzIHByZXNlbnRcIixcbiAgICBub25lOiBcImRvbid0IHRyeSB0byBwaW5nIHRoZSBtZXRhZGF0YSBzZXJ2ZXIsIGJ1dCBkb24ndCB0cnkgdG8gdXNlIGl0IGVpdGhlclwiLFxuICAgICdiaW9zLW9ubHknOiBcInRyZWF0IHRoZSByZXN1bHQgb2YgYSBCSU9TIHByb2JlIGFzIGNhbm9uaWNhbCAoZG9uJ3QgZmFsbCBiYWNrIHRvIHBpbmdpbmcpXCIsXG4gICAgJ3Bpbmctb25seSc6ICdza2lwIHRoZSBCSU9TIHByb2JlLCBhbmQgZ28gc3RyYWlnaHQgdG8gcGluZ2luZycsXG59KTtcbi8qKlxuICogUmV0dXJucyB0aGUgYmFzZSBVUkwgd2hpbGUgdGFraW5nIGludG8gYWNjb3VudCB0aGUgR0NFX01FVEFEQVRBX0hPU1RcbiAqIGVudmlyb25tZW50IHZhcmlhYmxlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgYmFzZSBVUkwsIGUuZy4sIGh0dHA6Ly8xNjkuMjU0LjE2OS4yNTQvY29tcHV0ZU1ldGFkYXRhL3YxLlxuICovXG5mdW5jdGlvbiBnZXRCYXNlVXJsKGJhc2VVcmwpIHtcbiAgICBpZiAoIWJhc2VVcmwpIHtcbiAgICAgICAgYmFzZVVybCA9XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5HQ0VfTUVUQURBVEFfSVAgfHxcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5HQ0VfTUVUQURBVEFfSE9TVCB8fFxuICAgICAgICAgICAgICAgIGV4cG9ydHMuSE9TVF9BRERSRVNTO1xuICAgIH1cbiAgICAvLyBJZiBubyBzY2hlbWUgaXMgcHJvdmlkZWQgZGVmYXVsdCB0byBIVFRQOlxuICAgIGlmICghL15odHRwcz86XFwvXFwvLy50ZXN0KGJhc2VVcmwpKSB7XG4gICAgICAgIGJhc2VVcmwgPSBgaHR0cDovLyR7YmFzZVVybH1gO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVSTChleHBvcnRzLkJBU0VfUEFUSCwgYmFzZVVybCkuaHJlZjtcbn1cbi8vIEFjY2VwdHMgYW4gb3B0aW9ucyBvYmplY3QgcGFzc2VkIGZyb20gdGhlIHVzZXIgdG8gdGhlIEFQSS4gSW4gcHJldmlvdXNcbi8vIHZlcnNpb25zIG9mIHRoZSBBUEksIGl0IHJlZmVycmVkIHRvIGEgYFJlcXVlc3RgIG9yIGFuIGBBeGlvc2AgcmVxdWVzdFxuLy8gb3B0aW9ucyBvYmplY3QuICBOb3cgaXQgcmVmZXJzIHRvIGFuIG9iamVjdCB3aXRoIHZlcnkgbGltaXRlZCBwcm9wZXJ0eVxuLy8gbmFtZXMuIFRoaXMgaXMgaGVyZSB0byBoZWxwIGVuc3VyZSB1c2VycyBkb24ndCBwYXNzIGludmFsaWQgb3B0aW9ucyB3aGVuXG4vLyB0aGV5ICB1cGdyYWRlIGZyb20gMC40IHRvIDAuNSB0byAwLjguXG5mdW5jdGlvbiB2YWxpZGF0ZShvcHRpb25zKSB7XG4gICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAncGFyYW1zJzpcbiAgICAgICAgICAgIGNhc2UgJ3Byb3BlcnR5JzpcbiAgICAgICAgICAgIGNhc2UgJ2hlYWRlcnMnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXMnOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidxcycgaXMgbm90IGEgdmFsaWQgY29uZmlndXJhdGlvbiBvcHRpb24uIFBsZWFzZSB1c2UgJ3BhcmFtcycgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJyR7a2V5fScgaXMgbm90IGEgdmFsaWQgY29uZmlndXJhdGlvbiBvcHRpb24uYCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG1ldGFkYXRhQWNjZXNzb3IodHlwZSwgb3B0aW9ucywgbm9SZXNwb25zZVJldHJpZXMgPSAzLCBmYXN0RmFpbCA9IGZhbHNlKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRpb25zID0geyBwcm9wZXJ0eTogb3B0aW9ucyB9O1xuICAgIH1cbiAgICBsZXQgcHJvcGVydHkgPSAnJztcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMucHJvcGVydHkpIHtcbiAgICAgICAgcHJvcGVydHkgPSAnLycgKyBvcHRpb25zLnByb3BlcnR5O1xuICAgIH1cbiAgICB2YWxpZGF0ZShvcHRpb25zKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXF1ZXN0TWV0aG9kID0gZmFzdEZhaWwgPyBmYXN0RmFpbE1ldGFkYXRhUmVxdWVzdCA6IGdheGlvc18xLnJlcXVlc3Q7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3RNZXRob2Qoe1xuICAgICAgICAgICAgdXJsOiBgJHtnZXRCYXNlVXJsKCl9LyR7dHlwZX0ke3Byb3BlcnR5fWAsXG4gICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHt9LCBleHBvcnRzLkhFQURFUlMsIG9wdGlvbnMuaGVhZGVycyksXG4gICAgICAgICAgICByZXRyeUNvbmZpZzogeyBub1Jlc3BvbnNlUmV0cmllcyB9LFxuICAgICAgICAgICAgcGFyYW1zOiBvcHRpb25zLnBhcmFtcyxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgdGltZW91dDogcmVxdWVzdFRpbWVvdXQoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5PVEU6IG5vZGUuanMgY29udmVydHMgYWxsIGluY29taW5nIGhlYWRlcnMgdG8gbG93ZXIgY2FzZS5cbiAgICAgICAgaWYgKHJlcy5oZWFkZXJzW2V4cG9ydHMuSEVBREVSX05BTUUudG9Mb3dlckNhc2UoKV0gIT09IGV4cG9ydHMuSEVBREVSX1ZBTFVFKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgZnJvbSBtZXRhZGF0YSBzZXJ2aWNlOiBpbmNvcnJlY3QgJHtleHBvcnRzLkhFQURFUl9OQU1FfSBoZWFkZXIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXJlcy5kYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVzcG9uc2UgZnJvbSB0aGUgbWV0YWRhdGEgc2VydmljZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVzLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqc29uQmlnaW50LnBhcnNlKHJlcy5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIC8qIGlnbm9yZSAqL1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXMuZGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXJyID0gZTtcbiAgICAgICAgaWYgKGVyci5yZXNwb25zZSAmJiBlcnIucmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID0gYFVuc3VjY2Vzc2Z1bCByZXNwb25zZSBzdGF0dXMgY29kZS4gJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZmFzdEZhaWxNZXRhZGF0YVJlcXVlc3Qob3B0aW9ucykge1xuICAgIGNvbnN0IHNlY29uZGFyeU9wdGlvbnMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHVybDogb3B0aW9ucy51cmwucmVwbGFjZShnZXRCYXNlVXJsKCksIGdldEJhc2VVcmwoZXhwb3J0cy5TRUNPTkRBUllfSE9TVF9BRERSRVNTKSksXG4gICAgfTtcbiAgICAvLyBXZSByYWNlIGEgY29ubmVjdGlvbiBiZXR3ZWVuIEROUy9JUCB0byBtZXRhZGF0YSBzZXJ2ZXIuIFRoZXJlIGFyZSBhIGNvdXBsZVxuICAgIC8vIHJlYXNvbnMgZm9yIHRoaXM6XG4gICAgLy9cbiAgICAvLyAxLiB0aGUgRE5TIGlzIHNsb3cgaW4gc29tZSBHQ1AgZW52aXJvbm1lbnRzOyBieSBjaGVja2luZyBib3RoLCB3ZSBtaWdodFxuICAgIC8vICAgIGRldGVjdCB0aGUgcnVudGltZSBlbnZpcm9ubWVudCBzaWduZmljYW50bHkgZmFzdGVyLlxuICAgIC8vIDIuIHdlIGNhbid0IGp1c3QgY2hlY2sgdGhlIElQLCB3aGljaCBpcyB0YXJwaXR0ZWQgYW5kIHNsb3cgdG8gcmVzcG9uZFxuICAgIC8vICAgIG9uIGEgdXNlcidzIGxvY2FsIG1hY2hpbmUuXG4gICAgLy9cbiAgICAvLyBBZGRpdGlvbmFsIGxvZ2ljIGhhcyBiZWVuIGFkZGVkIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGRvbid0IGNyZWF0ZSBhblxuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb24gaW4gc2NlbmFyaW9zIHdoZXJlIGEgZmFpbHVyZSBoYXBwZW5zIHNvbWV0aW1lXG4gICAgLy8gYWZ0ZXIgYSBzdWNjZXNzLlxuICAgIC8vXG4gICAgLy8gTm90ZSwgaG93ZXZlciwgaWYgYSBmYWlsdXJlIGhhcHBlbnMgcHJpb3IgdG8gYSBzdWNjZXNzLCBhIHJlamVjdGlvbiBzaG91bGRcbiAgICAvLyBvY2N1ciwgdGhpcyBpcyBmb3IgZm9sa3MgcnVubmluZyBsb2NhbGx5LlxuICAgIC8vXG4gICAgbGV0IHJlc3BvbmRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHIxID0gKDAsIGdheGlvc18xLnJlcXVlc3QpKG9wdGlvbnMpXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgIHJlc3BvbmRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmIChyZXNwb25kZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3BvbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCByMiA9ICgwLCBnYXhpb3NfMS5yZXF1ZXN0KShzZWNvbmRhcnlPcHRpb25zKVxuICAgICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICByZXNwb25kZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICBpZiAocmVzcG9uZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcjE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNwb25kZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbcjEsIHIyXSk7XG59XG4vKipcbiAqIE9idGFpbiBtZXRhZGF0YSBmb3IgdGhlIGN1cnJlbnQgR0NFIGluc3RhbmNlXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBpbnN0YW5jZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG1ldGFkYXRhQWNjZXNzb3IoJ2luc3RhbmNlJywgb3B0aW9ucyk7XG59XG5leHBvcnRzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4vKipcbiAqIE9idGFpbiBtZXRhZGF0YSBmb3IgdGhlIGN1cnJlbnQgR0NQIFByb2plY3QuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBwcm9qZWN0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbWV0YWRhdGFBY2Nlc3NvcigncHJvamVjdCcsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5wcm9qZWN0ID0gcHJvamVjdDtcbi8qXG4gKiBIb3cgbWFueSB0aW1lcyBzaG91bGQgd2UgcmV0cnkgZGV0ZWN0aW5nIEdDUCBlbnZpcm9ubWVudC5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0R0NQQXZhaWxhYmxlUmV0cmllcygpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuREVURUNUX0dDUF9SRVRSSUVTXG4gICAgICAgID8gTnVtYmVyKHByb2Nlc3MuZW52LkRFVEVDVF9HQ1BfUkVUUklFUylcbiAgICAgICAgOiAwO1xufVxubGV0IGNhY2hlZElzQXZhaWxhYmxlUmVzcG9uc2U7XG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgbWV0YWRhdGEgc2VydmVyIGlzIGN1cnJlbnRseSBhdmFpbGFibGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGlzQXZhaWxhYmxlKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5NRVRBREFUQV9TRVJWRVJfREVURUNUSU9OKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcHJvY2Vzcy5lbnYuTUVUQURBVEFfU0VSVkVSX0RFVEVDVElPTi50cmltKCkudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCEodmFsdWUgaW4gZXhwb3J0cy5NRVRBREFUQV9TRVJWRVJfREVURUNUSU9OKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVua25vd24gXFxgTUVUQURBVEFfU0VSVkVSX0RFVEVDVElPTlxcYCBlbnYgdmFyaWFibGUuIEdvdCBcXGAke3ZhbHVlfVxcYCwgYnV0IGl0IHNob3VsZCBiZSBcXGAke09iamVjdC5rZXlzKGV4cG9ydHMuTUVUQURBVEFfU0VSVkVSX0RFVEVDVElPTikuam9pbignYCwgYCcpfVxcYCwgb3IgdW5zZXRgKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdhc3N1bWUtcHJlc2VudCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlICdiaW9zLW9ubHknOlxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRHQ1BSZXNpZGVuY3koKTtcbiAgICAgICAgICAgIGNhc2UgJ3Bpbmctb25seSc6XG4gICAgICAgICAgICAvLyBjb250aW51ZSwgd2Ugd2FudCB0byBwaW5nIHRoZSBzZXJ2ZXJcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyBJZiBhIHVzZXIgaXMgaW5zdGFudGlhdGluZyBzZXZlcmFsIEdDUCBsaWJyYXJpZXMgYXQgdGhlIHNhbWUgdGltZSxcbiAgICAgICAgLy8gdGhpcyBtYXkgcmVzdWx0IGluIG11bHRpcGxlIGNhbGxzIHRvIGlzQXZhaWxhYmxlKCksIHRvIGRldGVjdCB0aGVcbiAgICAgICAgLy8gcnVudGltZSBlbnZpcm9ubWVudC4gV2UgdXNlIHRoZSBzYW1lIHByb21pc2UgZm9yIGVhY2ggb2YgdGhlc2UgY2FsbHNcbiAgICAgICAgLy8gdG8gcmVkdWNlIHRoZSBuZXR3b3JrIGxvYWQuXG4gICAgICAgIGlmIChjYWNoZWRJc0F2YWlsYWJsZVJlc3BvbnNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNhY2hlZElzQXZhaWxhYmxlUmVzcG9uc2UgPSBtZXRhZGF0YUFjY2Vzc29yKCdpbnN0YW5jZScsIHVuZGVmaW5lZCwgZGV0ZWN0R0NQQXZhaWxhYmxlUmV0cmllcygpLCBcbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWZhdWx0IEhPU1RfQUREUkVTUyBoYXMgYmVlbiBvdmVycmlkZGVuLCB3ZSBzaG91bGQgbm90XG4gICAgICAgICAgICAvLyBtYWtlIGFuIGVmZm9ydCB0byB0cnkgU0VDT05EQVJZX0hPU1RfQUREUkVTUyAoYXMgd2UgYXJlIGxpa2VseSBpblxuICAgICAgICAgICAgLy8gYSBub24tR0NQIGVudmlyb25tZW50KTpcbiAgICAgICAgICAgICEocHJvY2Vzcy5lbnYuR0NFX01FVEFEQVRBX0lQIHx8IHByb2Nlc3MuZW52LkdDRV9NRVRBREFUQV9IT1NUKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgY2FjaGVkSXNBdmFpbGFibGVSZXNwb25zZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IGU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5ERUJVR19BVVRIKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyLnR5cGUgPT09ICdyZXF1ZXN0LXRpbWVvdXQnKSB7XG4gICAgICAgICAgICAvLyBJZiBydW5uaW5nIGluIGEgR0NQIGVudmlyb25tZW50LCBtZXRhZGF0YSBlbmRwb2ludCBzaG91bGQgcmV0dXJuXG4gICAgICAgICAgICAvLyB3aXRoaW4gbXMuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyci5yZXNwb25zZSAmJiBlcnIucmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghKGVyci5yZXNwb25zZSAmJiBlcnIucmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpICYmXG4gICAgICAgICAgICAgICAgLy8gQSB3YXJuaW5nIGlzIGVtaXR0ZWQgaWYgd2Ugc2VlIGFuIHVuZXhwZWN0ZWQgZXJyLmNvZGUsIG9yIGVyci5jb2RlXG4gICAgICAgICAgICAgICAgLy8gaXMgbm90IHBvcHVsYXRlZDpcbiAgICAgICAgICAgICAgICAoIWVyci5jb2RlIHx8XG4gICAgICAgICAgICAgICAgICAgICFbXG4gICAgICAgICAgICAgICAgICAgICAgICAnRUhPU1RET1dOJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFSE9TVFVOUkVBQ0gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VORVRVTlJFQUNIJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFTk9FTlQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VOT1RGT1VORCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRUNPTk5SRUZVU0VEJyxcbiAgICAgICAgICAgICAgICAgICAgXS5pbmNsdWRlcyhlcnIuY29kZSkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGUgPSAnVU5LTk9XTic7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlKVxuICAgICAgICAgICAgICAgICAgICBjb2RlID0gZXJyLmNvZGU7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhgcmVjZWl2ZWQgdW5leHBlY3RlZCBlcnJvciA9ICR7ZXJyLm1lc3NhZ2V9IGNvZGUgPSAke2NvZGV9YCwgJ01ldGFkYXRhTG9va3VwV2FybmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmFpbHVyZSB0byByZXNvbHZlIHRoZSBtZXRhZGF0YSBzZXJ2aWNlIG1lYW5zIHRoYXQgaXQgaXMgbm90IGF2YWlsYWJsZS5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuaXNBdmFpbGFibGUgPSBpc0F2YWlsYWJsZTtcbi8qKlxuICogcmVzZXQgdGhlIG1lbW9pemVkIGlzQXZhaWxhYmxlKCkgbG9va3VwLlxuICovXG5mdW5jdGlvbiByZXNldElzQXZhaWxhYmxlQ2FjaGUoKSB7XG4gICAgY2FjaGVkSXNBdmFpbGFibGVSZXNwb25zZSA9IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMucmVzZXRJc0F2YWlsYWJsZUNhY2hlID0gcmVzZXRJc0F2YWlsYWJsZUNhY2hlO1xuLyoqXG4gKiBBIGNhY2hlIGZvciB0aGUgZGV0ZWN0ZWQgR0NQIFJlc2lkZW5jeS5cbiAqL1xuZXhwb3J0cy5nY3BSZXNpZGVuY3lDYWNoZSA9IG51bGw7XG4vKipcbiAqIERldGVjdHMgR0NQIFJlc2lkZW5jeS5cbiAqIENhY2hlcyByZXN1bHRzIHRvIHJlZHVjZSBjb3N0cyBmb3Igc3Vic2VxdWVudCBjYWxscy5cbiAqXG4gKiBAc2VlIHNldEdDUFJlc2lkZW5jeSBmb3Igc2V0dGluZ1xuICovXG5mdW5jdGlvbiBnZXRHQ1BSZXNpZGVuY3koKSB7XG4gICAgaWYgKGV4cG9ydHMuZ2NwUmVzaWRlbmN5Q2FjaGUgPT09IG51bGwpIHtcbiAgICAgICAgc2V0R0NQUmVzaWRlbmN5KCk7XG4gICAgfVxuICAgIHJldHVybiBleHBvcnRzLmdjcFJlc2lkZW5jeUNhY2hlO1xufVxuZXhwb3J0cy5nZXRHQ1BSZXNpZGVuY3kgPSBnZXRHQ1BSZXNpZGVuY3k7XG4vKipcbiAqIFNldHMgdGhlIGRldGVjdGVkIEdDUCBSZXNpZGVuY3kuXG4gKiBVc2VmdWwgZm9yIGZvcmNpbmcgbWV0YWRhdGEgc2VydmVyIGRldGVjdGlvbiBiZWhhdmlvci5cbiAqXG4gKiBTZXQgYG51bGxgIHRvIGF1dG9kZXRlY3QgdGhlIGVudmlyb25tZW50IChkZWZhdWx0IGJlaGF2aW9yKS5cbiAqIEBzZWUgZ2V0R0NQUmVzaWRlbmN5IGZvciBnZXR0aW5nXG4gKi9cbmZ1bmN0aW9uIHNldEdDUFJlc2lkZW5jeSh2YWx1ZSA9IG51bGwpIHtcbiAgICBleHBvcnRzLmdjcFJlc2lkZW5jeUNhY2hlID0gdmFsdWUgIT09IG51bGwgPyB2YWx1ZSA6ICgwLCBnY3BfcmVzaWRlbmN5XzEuZGV0ZWN0R0NQUmVzaWRlbmN5KSgpO1xufVxuZXhwb3J0cy5zZXRHQ1BSZXNpZGVuY3kgPSBzZXRHQ1BSZXNpZGVuY3k7XG4vKipcbiAqIE9idGFpbiB0aGUgdGltZW91dCBmb3IgcmVxdWVzdHMgdG8gdGhlIG1ldGFkYXRhIHNlcnZlci5cbiAqXG4gKiBJbiBjZXJ0YWluIGVudmlyb25tZW50cyBhbmQgY29uZGl0aW9ucyByZXF1ZXN0cyBjYW4gdGFrZSBsb25nZXIgdGhhblxuICogdGhlIGRlZmF1bHQgdGltZW91dCB0byBjb21wbGV0ZS4gVGhpcyBmdW5jdGlvbiB3aWxsIGRldGVybWluZSB0aGVcbiAqIGFwcHJvcHJpYXRlIHRpbWVvdXQgYmFzZWQgb24gdGhlIGVudmlyb25tZW50LlxuICpcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGEgcmVxdWVzdCB0aW1lb3V0IGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuZnVuY3Rpb24gcmVxdWVzdFRpbWVvdXQoKSB7XG4gICAgcmV0dXJuIGdldEdDUFJlc2lkZW5jeSgpID8gMCA6IDMwMDA7XG59XG5leHBvcnRzLnJlcXVlc3RUaW1lb3V0ID0gcmVxdWVzdFRpbWVvdXQ7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZ2NwLXJlc2lkZW5jeVwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19leHBvcnRTdGFyIiwiZXhwb3J0cyIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ2YWx1ZSIsInJlcXVlc3RUaW1lb3V0Iiwic2V0R0NQUmVzaWRlbmN5IiwiZ2V0R0NQUmVzaWRlbmN5IiwiZ2NwUmVzaWRlbmN5Q2FjaGUiLCJyZXNldElzQXZhaWxhYmxlQ2FjaGUiLCJpc0F2YWlsYWJsZSIsInByb2plY3QiLCJpbnN0YW5jZSIsIk1FVEFEQVRBX1NFUlZFUl9ERVRFQ1RJT04iLCJIRUFERVJTIiwiSEVBREVSX1ZBTFVFIiwiSEVBREVSX05BTUUiLCJTRUNPTkRBUllfSE9TVF9BRERSRVNTIiwiSE9TVF9BRERSRVNTIiwiQkFTRV9QQVRIIiwiZ2F4aW9zXzEiLCJyZXF1aXJlIiwianNvbkJpZ2ludCIsImdjcF9yZXNpZGVuY3lfMSIsImZyZWV6ZSIsIm5vbmUiLCJnZXRCYXNlVXJsIiwiYmFzZVVybCIsInByb2Nlc3MiLCJlbnYiLCJHQ0VfTUVUQURBVEFfSVAiLCJHQ0VfTUVUQURBVEFfSE9TVCIsInRlc3QiLCJVUkwiLCJocmVmIiwidmFsaWRhdGUiLCJvcHRpb25zIiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJFcnJvciIsIm1ldGFkYXRhQWNjZXNzb3IiLCJ0eXBlIiwibm9SZXNwb25zZVJldHJpZXMiLCJmYXN0RmFpbCIsInByb3BlcnR5IiwicmVxdWVzdE1ldGhvZCIsImZhc3RGYWlsTWV0YWRhdGFSZXF1ZXN0IiwicmVxdWVzdCIsInJlcyIsInVybCIsImhlYWRlcnMiLCJhc3NpZ24iLCJyZXRyeUNvbmZpZyIsInBhcmFtcyIsInJlc3BvbnNlVHlwZSIsInRpbWVvdXQiLCJ0b0xvd2VyQ2FzZSIsImRhdGEiLCJwYXJzZSIsIl9hIiwiZSIsImVyciIsInJlc3BvbnNlIiwic3RhdHVzIiwibWVzc2FnZSIsInNlY29uZGFyeU9wdGlvbnMiLCJyZXBsYWNlIiwicmVzcG9uZGVkIiwicjEiLCJ0aGVuIiwiY2F0Y2giLCJyMiIsIlByb21pc2UiLCJyYWNlIiwiZGV0ZWN0R0NQQXZhaWxhYmxlUmV0cmllcyIsIkRFVEVDVF9HQ1BfUkVUUklFUyIsIk51bWJlciIsImNhY2hlZElzQXZhaWxhYmxlUmVzcG9uc2UiLCJ0cmltIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJSYW5nZUVycm9yIiwiam9pbiIsIkRFQlVHX0FVVEgiLCJjb25zb2xlIiwiaW5mbyIsImNvZGUiLCJpbmNsdWRlcyIsImVtaXRXYXJuaW5nIiwiZGV0ZWN0R0NQUmVzaWRlbmN5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gcp-metadata/build/src/index.js\n");

/***/ })

};
;